{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60214",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60214/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60214/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60214/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60214",
  "id": 3656126978,
  "node_id": "PR_kwDOABkWpM61Dm2u",
  "number": 60214,
  "title": "Finish PR: inference: fix the ptrfree field check",
  "user": {
    "login": "MasonProtter",
    "id": 29157027,
    "node_id": "MDQ6VXNlcjI5MTU3MDI3",
    "avatar_url": "https://avatars.githubusercontent.com/u/29157027?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MasonProtter",
    "html_url": "https://github.com/MasonProtter",
    "followers_url": "https://api.github.com/users/MasonProtter/followers",
    "following_url": "https://api.github.com/users/MasonProtter/following{/other_user}",
    "gists_url": "https://api.github.com/users/MasonProtter/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MasonProtter/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MasonProtter/subscriptions",
    "organizations_url": "https://api.github.com/users/MasonProtter/orgs",
    "repos_url": "https://api.github.com/users/MasonProtter/repos",
    "events_url": "https://api.github.com/users/MasonProtter/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MasonProtter/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": {
    "login": "aviatesk",
    "id": 40514306,
    "node_id": "MDQ6VXNlcjQwNTE0MzA2",
    "avatar_url": "https://avatars.githubusercontent.com/u/40514306?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/aviatesk",
    "html_url": "https://github.com/aviatesk",
    "followers_url": "https://api.github.com/users/aviatesk/followers",
    "following_url": "https://api.github.com/users/aviatesk/following{/other_user}",
    "gists_url": "https://api.github.com/users/aviatesk/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/aviatesk/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/aviatesk/subscriptions",
    "organizations_url": "https://api.github.com/users/aviatesk/orgs",
    "repos_url": "https://api.github.com/users/aviatesk/repos",
    "events_url": "https://api.github.com/users/aviatesk/events{/privacy}",
    "received_events_url": "https://api.github.com/users/aviatesk/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "aviatesk",
      "id": 40514306,
      "node_id": "MDQ6VXNlcjQwNTE0MzA2",
      "avatar_url": "https://avatars.githubusercontent.com/u/40514306?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aviatesk",
      "html_url": "https://github.com/aviatesk",
      "followers_url": "https://api.github.com/users/aviatesk/followers",
      "following_url": "https://api.github.com/users/aviatesk/following{/other_user}",
      "gists_url": "https://api.github.com/users/aviatesk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aviatesk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aviatesk/subscriptions",
      "organizations_url": "https://api.github.com/users/aviatesk/orgs",
      "repos_url": "https://api.github.com/users/aviatesk/repos",
      "events_url": "https://api.github.com/users/aviatesk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aviatesk/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-11-23T15:20:19Z",
  "updated_at": "2025-11-24T18:22:57Z",
  "closed_at": "2025-11-24T18:22:57Z",
  "author_association": "CONTRIBUTOR",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60214",
    "html_url": "https://github.com/JuliaLang/julia/pull/60214",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60214.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60214.patch",
    "merged_at": "2025-11-24T18:22:57Z"
  },
  "body": "This should address the `# TODO` item in https://github.com/JuliaLang/julia/pull/57550. \r\n\r\nUnconditionally indexing `DataTypeFieldDesc(dt::DataType)[fidx]` will error when `dt` has no layout because we define\r\n```julia\r\nstruct DataTypeFieldDesc\r\n    dt::DataType\r\n    function DataTypeFieldDesc(dt::DataType)\r\n        dt.layout == C_NULL && throw(UndefRefError())\r\n        new(dt)\r\n    end\r\nend\r\n``` \r\nFor all the `DataType`s I could find, they only had `dt.layout == C_NULL`  if `!isconcretetype(dt)`, so maybe it would be preferable to check if they're `!isconcretetype` rather than checking if `dt.layout == C_NULL`, but I figured it'd be safer to just mimic the validation logic in `DataTypeFieldDesc` instead.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60214/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60214/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "3808797275e1527e0a47b560dd269cb5c1f1290b",
      "filename": "Compiler/src/abstractinterpretation.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 3,
      "changes": 12,
      "blob_url": "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fabstractinterpretation.jl?ref=08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f",
      "patch": "@@ -3079,6 +3079,13 @@ function abstract_eval_call(interp::AbstractInterpreter, e::Expr, sstate::Statem\n     end\n end\n \n+function is_field_pointerfree(dt::DataType, fidx::Int)\n+    dt.layout::Ptr{Cvoid} == C_NULL && return false\n+    DataTypeFieldDesc(dt)[fidx].isptr && return false\n+    ft = fieldtype(dt, fidx)\n+    return ft isa DataType && datatype_pointerfree(ft)\n+end\n+\n function abstract_eval_new(interp::AbstractInterpreter, e::Expr, sstate::StatementState,\n                            sv::AbsIntState)\n     \ud835\udd43\u1d62 = typeinf_lattice(interp)\n@@ -3089,9 +3096,8 @@ function abstract_eval_new(interp::AbstractInterpreter, e::Expr, sstate::Stateme\n         ismutable = ismutabletype(ut)\n         fcount = datatype_fieldcount(ut)\n         nargs = length(e.args) - 1\n-        has_any_uninitialized = (fcount === nothing || (fcount > nargs && (let t = rt\n-                any(i::Int -> !is_undefref_fieldtype(fieldtype(t, i)), (nargs+1):fcount)\n-            end)))\n+        has_any_uninitialized = fcount === nothing || (fcount > nargs &&\n+            any(i::Int->is_field_pointerfree(ut, i), (nargs+1):fcount))\n         if has_any_uninitialized\n             # allocation with undefined field is inconsistent always\n             consistent = ALWAYS_FALSE"
    },
    {
      "sha": "3c23974c88920cde14cf34b7af948c6e2b60d15b",
      "filename": "Compiler/src/tfuncs.jl",
      "status": "modified",
      "additions": 0,
      "deletions": 12,
      "changes": 12,
      "blob_url": "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler%2Fsrc%2Ftfuncs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler%2Fsrc%2Ftfuncs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftfuncs.jl?ref=08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f",
      "patch": "@@ -1286,18 +1286,6 @@ end\n     return rewrap_unionall(R, s00)\n end\n \n-# checks if a field of this type is guaranteed to be defined to a value\n-# and that access to an uninitialized field will cause an `UndefRefError` or return zero\n-# - is_undefref_fieldtype(String) === true\n-# - is_undefref_fieldtype(Integer) === true\n-# - is_undefref_fieldtype(Any) === true\n-# - is_undefref_fieldtype(Int) === false\n-# - is_undefref_fieldtype(Union{Int32,Int64}) === false\n-# - is_undefref_fieldtype(T) === false\n-function is_undefref_fieldtype(@nospecialize ftyp)\n-    return !has_free_typevars(ftyp) && !allocatedinline(ftyp)\n-end\n-\n @nospecs function setfield!_tfunc(\ud835\udd43::AbstractLattice, o, f, v, order)\n     if !isvarargtype(order)\n         hasintersect(widenconst(order), Symbol) || return Bottom"
    },
    {
      "sha": "fa97c0c94c58df3407f7e066269ef6e32d6f50db",
      "filename": "Compiler/test/effects.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler%2Ftest%2Feffects.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler%2Ftest%2Feffects.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Feffects.jl?ref=08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f",
      "patch": "@@ -266,6 +266,9 @@ end |> Compiler.is_consistent\n @test Base.infer_effects() do\n     Maybe{String}()[]\n end |> Compiler.is_consistent\n+@test Base.infer_effects() do\n+    Maybe{Some{Base.RefValue{Int}}}()\n+end |> Compiler.is_consistent\n let f() = Maybe{String}()[]\n     @test Base.return_types() do\n         f() # this call should be concrete evaluated"
    }
  ]
}