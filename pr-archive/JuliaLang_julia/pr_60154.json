{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60154",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60154/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60154/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60154/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60154",
  "id": 3633357970,
  "node_id": "PR_kwDOABkWpM6z25jk",
  "number": 60154,
  "title": "Replace some uses of `Array` by `Vector` or `Matrix`",
  "user": {
    "login": "fingolfin",
    "id": 241512,
    "node_id": "MDQ6VXNlcjI0MTUxMg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/241512?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fingolfin",
    "html_url": "https://github.com/fingolfin",
    "followers_url": "https://api.github.com/users/fingolfin/followers",
    "following_url": "https://api.github.com/users/fingolfin/following{/other_user}",
    "gists_url": "https://api.github.com/users/fingolfin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fingolfin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fingolfin/subscriptions",
    "organizations_url": "https://api.github.com/users/fingolfin/orgs",
    "repos_url": "https://api.github.com/users/fingolfin/repos",
    "events_url": "https://api.github.com/users/fingolfin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fingolfin/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 3,
  "created_at": "2025-11-17T13:31:41Z",
  "updated_at": "2025-11-23T15:47:35Z",
  "closed_at": "2025-11-23T15:47:33Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60154",
    "html_url": "https://github.com/JuliaLang/julia/pull/60154",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60154.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60154.patch",
    "merged_at": "2025-11-23T15:47:33Z"
  },
  "body": "Progress towards issue #56922 by @LilithHafner. Turns out I didn't find many uses of `Array{T, 1}` or `Array{T, 2}` in `doc` or `base` that were \"clearly\" in need of being updated to `Vector` or `Matrix`. \r\n\r\nThere are a bunch that can't be changed because they occur before `Vector` or `Matrix` are even defined.\r\n\r\nThere are a couple borderline cases, and I may have overlooked some, but most I looked at felt like \"I could change it to Vector or Matrix but I think there is a didactical point in using `Array` here. E.g. in the definition of `struct BitVector <: AbstractArray{Bool, 1}; end` I think the context makes it desirable to leave it at that instead of changing it to `Vector` -- but I admit this is subjective.\r\n\r\nThere was more in `test`, though that's perhaps less important.\r\n\r\nAll in all I think we could close #56922",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60154/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60154/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "b2ffd0ef0b57bbec019e064f1b0471344b875e6f",
      "filename": "Compiler/src/typeutils.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/Compiler%2Fsrc%2Ftypeutils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/Compiler%2Fsrc%2Ftypeutils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftypeutils.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -48,7 +48,7 @@ has_extended_info(@nospecialize x) = (!isa(x, Type) && !isvarargtype(x)) || isTy\n # certain combinations of `a` and `b` where one/both isa/are `Union`/`UnionAll` type(s)s.\n isnotbrokensubtype(@nospecialize(a), @nospecialize(b)) = (!iskindtype(b) || !isType(a) || hasuniquerep(a.parameters[1]) || b <: a)\n \n-function argtypes_to_type(argtypes::Array{Any,1})\n+function argtypes_to_type(argtypes::Vector{Any})\n     argtypes = anymap(@nospecialize(a) -> isvarargtype(a) ? a : widenconst(a), argtypes)\n     filter!(@nospecialize(x) -> !isvarargtype(x) || valid_as_lattice(unwrapva(x), true), argtypes)\n     all(@nospecialize(x) -> isvarargtype(x) || valid_as_lattice(x, true), argtypes) || return Bottom"
    },
    {
      "sha": "865d76eda9e845c0f7985dea3430d47ca5194eb8",
      "filename": "Compiler/src/utilities.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/Compiler%2Fsrc%2Futilities.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/Compiler%2Fsrc%2Futilities.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Futilities.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -21,7 +21,7 @@ function contains_is(itr, @nospecialize(x))\n     return false\n end\n \n-anymap(f::Function, a::Array{Any,1}) = Any[ f(a[i]) for i in 1:length(a) ]\n+anymap(f::Function, a::Vector{Any}) = Any[ f(a[i]) for i in 1:length(a) ]\n \n ############\n # inlining #"
    },
    {
      "sha": "35402c0d0fa5b01f9c9fdaf2ad1d38a56c894c22",
      "filename": "Compiler/test/inference.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/Compiler%2Ftest%2Finference.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/Compiler%2Ftest%2Finference.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Finference.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -105,12 +105,12 @@ end\n \n # issue #51694\n @test Compiler.type_more_complex(\n-       Base.Generator{Base.Iterators.Flatten{Array{Bool, 1}}, typeof(identity)},\n-       Base.Generator{Array{Bool, 1}, typeof(identity)},\n+       Base.Generator{Base.Iterators.Flatten{Vector{Bool}}, typeof(identity)},\n+       Base.Generator{Vector{Bool}, typeof(identity)},\n        Core.svec(), 0, 0, 0)\n @test Compiler.type_more_complex(\n-       Base.Generator{Base.Iterators.Flatten{Base.Generator{Array{Bool, 1}, typeof(identity)}}, typeof(identity)},\n-       Base.Generator{Array{Bool, 1}, typeof(identity)},\n+       Base.Generator{Base.Iterators.Flatten{Base.Generator{Vector{Bool}, typeof(identity)}}, typeof(identity)},\n+       Base.Generator{Vector{Bool}, typeof(identity)},\n        Core.svec(), 0, 0, 0)\n \n let # 40336\n@@ -419,7 +419,7 @@ end\n \n # issue #12826\n f12826(v::Vector{I}) where {I<:Integer} = v[1]\n-@test Base.return_types(f12826,Tuple{Array{I,1} where I<:Integer})[1] == Integer\n+@test Base.return_types(f12826,Tuple{Vector{I} where I<:Integer})[1] == Integer\n \n \n # non-terminating inference, issue #14009\n@@ -1465,8 +1465,8 @@ let egal_tfunc\n     @test egal_tfunc(Array, Array) == Bool\n     @test egal_tfunc(Array, AbstractArray{Int}) == Bool\n     @test egal_tfunc(Array{Real}, AbstractArray{Int}) === Const(false)\n-    @test egal_tfunc(Array{Real, 2}, AbstractArray{Real, 2}) === Bool\n-    @test egal_tfunc(Array{Real, 2}, AbstractArray{Int, 2}) === Const(false)\n+    @test egal_tfunc(Matrix{Real}, AbstractMatrix{Real}) === Bool\n+    @test egal_tfunc(Matrix{Real}, AbstractMatrix{Int}) === Const(false)\n     @test egal_tfunc(DataType, Int) === Const(false)\n     @test egal_tfunc(DataType, Const(Int)) === Bool\n     @test egal_tfunc(DataType, Const(Array)) === Const(false)"
    },
    {
      "sha": "b6a4e9e852aef44c9959dee18825541d80c37214",
      "filename": "base/array.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/base%2Farray.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/base%2Farray.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Farray.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -399,10 +399,10 @@ end\n \n ## Constructors ##\n \n-similar(a::Array{T,1}) where {T}                    = Vector{T}(undef, size(a,1))\n-similar(a::Array{T,2}) where {T}                    = Matrix{T}(undef, size(a,1), size(a,2))\n-similar(a::Array{T,1}, S::Type) where {T}           = Vector{S}(undef, size(a,1))\n-similar(a::Array{T,2}, S::Type) where {T}           = Matrix{S}(undef, size(a,1), size(a,2))\n+similar(a::Vector{T}) where {T}                    = Vector{T}(undef, size(a,1))\n+similar(a::Matrix{T}) where {T}                    = Matrix{T}(undef, size(a,1), size(a,2))\n+similar(a::Vector{T}, S::Type) where {T}           = Vector{S}(undef, size(a,1))\n+similar(a::Matrix{T}, S::Type) where {T}           = Matrix{S}(undef, size(a,1), size(a,2))\n similar(a::Array{T}, m::Int) where {T}              = Vector{T}(undef, m)\n similar(a::Array, T::Type, dims::Dims{N}) where {N} = Array{T,N}(undef, dims)\n similar(a::Array{T}, dims::Dims{N}) where {T,N}     = Array{T,N}(undef, dims)\n@@ -1832,12 +1832,12 @@ julia> insert!(Any[1:6;], 3, \"here\")\n  6\n ```\n \"\"\"\n-function insert!(a::Array{T,1}, i::Integer, item) where T\n+function insert!(a::Vector{T}, i::Integer, item) where T\n     @_propagate_inbounds_meta\n     item = item isa T ? item : convert(T, item)::T\n     return _insert!(a, i, item)\n end\n-function _insert!(a::Array{T,1}, i::Integer, item::T) where T\n+function _insert!(a::Vector{T}, i::Integer, item::T) where T\n     @_noub_meta\n     # Throw convert error before changing the shape of the array\n     _growat!(a, i, 1)"
    },
    {
      "sha": "87b29716ef03664097a38816b63dffdb005a6e12",
      "filename": "base/iostream.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/base%2Fiostream.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/base%2Fiostream.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fiostream.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -12,13 +12,13 @@ Mostly used to represent files returned by [`open`](@ref).\n \"\"\"\n mutable struct IOStream <: IO\n     handle::Ptr{Cvoid}\n-    ios::Array{UInt8,1}\n+    ios::Vector{UInt8}\n     name::String\n     mark::Int64\n     lock::ReentrantLock\n     _dolock::Bool\n \n-    IOStream(name::AbstractString, buf::Array{UInt8,1}) = new(pointer(buf), buf, name, -1, ReentrantLock(), true)\n+    IOStream(name::AbstractString, buf::Vector{UInt8}) = new(pointer(buf), buf, name, -1, ReentrantLock(), true)\n end\n \n function IOStream(name::AbstractString, finalize::Bool)\n@@ -470,7 +470,7 @@ take!(s::IOStream) =\n     @_lock_ios s ccall(:jl_take_buffer, Vector{UInt8}, (Ptr{Cvoid},), s.ios)\n \n function readuntil(s::IOStream, delim::UInt8; keep::Bool=false)\n-    @_lock_ios s ccall(:jl_readuntil, Array{UInt8,1}, (Ptr{Cvoid}, UInt8, UInt8, UInt8), s.ios, delim, 0, !keep)\n+    @_lock_ios s ccall(:jl_readuntil, Vector{UInt8}, (Ptr{Cvoid}, UInt8, UInt8, UInt8), s.ios, delim, 0, !keep)\n end\n \n # like readuntil, above, but returns a String without requiring a copy"
    },
    {
      "sha": "024c88ecf2a1601d0d2902232a2719629405a8eb",
      "filename": "base/libdl.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/base%2Flibdl.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/base%2Flibdl.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Flibdl.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -279,7 +279,7 @@ if (Sys.islinux() || Sys.isbsd()) && !Sys.isapple()\n \n     # This callback function called by dl_iterate_phdr() on Linux and BSD's\n     # DL_ITERATE_PHDR(3) on freebsd\n-    function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dynamic_libraries::Array{String,1})\n+    function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dynamic_libraries::Vector{String})\n         name = unsafe_string(di.name)\n         push!(dynamic_libraries, name)\n         return Cint(0)"
    },
    {
      "sha": "a92c15b1aea73fa25cd443f3e81719840d95553f",
      "filename": "doc/src/manual/interfaces.md",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/doc%2Fsrc%2Fmanual%2Finterfaces.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/doc%2Fsrc%2Fmanual%2Finterfaces.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fmanual%2Finterfaces.md?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -255,10 +255,10 @@ library module, only supports two dimensions, so it just defines\n `getindex(A::SparseMatrixCSC, i::Int, j::Int)`. The same holds for [`setindex!`](@ref).\n \n Returning to the sequence of squares from above, we could instead define it as a subtype of an\n-`AbstractArray{Int, 1}`:\n+`AbstractVector{Int}`:\n \n ```jldoctest squarevectype\n-julia> struct SquaresVector <: AbstractArray{Int, 1}\n+julia> struct SquaresVector <: AbstractVector{Int}\n            count::Int\n        end\n "
    },
    {
      "sha": "f821738d3b16100d0d50d0081f0c7f58c9187b0c",
      "filename": "doc/src/manual/performance-tips.md",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/doc%2Fsrc%2Fmanual%2Fperformance-tips.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/doc%2Fsrc%2Fmanual%2Fperformance-tips.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fmanual%2Fperformance-tips.md?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -541,7 +541,7 @@ of type `Array{Any}`). But, if you're using one of these structures and happen t\n of an element, it helps to share this knowledge with the compiler:\n \n ```julia\n-function foo(a::Array{Any,1})\n+function foo(a::Vector{Any})\n     x = a[1]::Int32\n     b = x+1\n     ..."
    },
    {
      "sha": "490b39625a962ffa1319718773f3dd447b26ed3e",
      "filename": "test/core.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/test%2Fcore.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/test%2Fcore.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fcore.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -462,12 +462,12 @@ end\n mutable struct A3890{T1}\n     x::Matrix{Complex{T1}}\n end\n-@test A3890{Float64}.types[1] === Array{ComplexF64,2}\n+@test A3890{Float64}.types[1] === Matrix{ComplexF64}\n # make sure the field type Matrix{Complex{T1}} isn't cached\n mutable struct B3890{T2}\n     x::Matrix{Complex{T2}}\n end\n-@test B3890{Float64}.types[1] === Array{ComplexF64,2}\n+@test B3890{Float64}.types[1] === Matrix{ComplexF64}\n \n # issue #786\n mutable struct Node{T}\n@@ -3894,14 +3894,14 @@ f12092(x::Int, y::Int...) = 2\n \n # issue #12063\n # NOTE: should have > MAX_TUPLETYPE_LEN arguments\n-f12063(tt, g, p, c, b, v, cu::T, d::AbstractArray{T, 2}, ve) where {T} = 1\n+f12063(tt, g, p, c, b, v, cu::T, d::AbstractMatrix{T}, ve) where {T} = 1\n f12063(args...) = 2\n g12063() = f12063(0, 0, 0, 0, 0, 0, 0.0, zeros(0,0), Int[])\n @test g12063() == 1\n \n # issue #11587\n mutable struct Sampler11587{N}\n-    clampedpos::Array{Int,2}\n+    clampedpos::Matrix{Int}\n     buf::Array{Float64,N}\n end\n function Sampler11587()\n@@ -7435,9 +7435,9 @@ end\n @test repackage28445()\n \n # issue #28597\n-@test_throws ArgumentError Array{Int, 2}(undef, 0, -10)\n-@test_throws ArgumentError Array{Int, 2}(undef, -10, 0)\n-@test_throws ArgumentError Array{Int, 2}(undef, -1, -1)\n+@test_throws ArgumentError Matrix{Int}(undef, 0, -10)\n+@test_throws ArgumentError Matrix{Int}(undef, -10, 0)\n+@test_throws ArgumentError Matrix{Int}(undef, -1, -1)\n \n # issue #54244\n # test that zero sized array doesn't throw even with large axes"
    },
    {
      "sha": "4b6c2e9019980682e2b4b9b25e7fd718d673e912",
      "filename": "test/offsetarray.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/test%2Foffsetarray.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/test%2Foffsetarray.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Foffsetarray.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -247,17 +247,17 @@ PV = view(P, 2:3, :)\n \n # Similar\n B = similar(A, Float32)\n-@test isa(B, OffsetArray{Float32,2})\n+@test isa(B, OffsetMatrix{Float32})\n @test axes(B) === axes(A)\n B = similar(A, (3,4))\n-@test isa(B, Array{Int,2})\n+@test isa(B, Matrix{Int})\n @test size(B) == (3,4)\n @test axes(B) === (Base.OneTo(3), Base.OneTo(4))\n B = similar(A, (-3:3,1:4))\n-@test isa(B, OffsetArray{Int,2})\n+@test isa(B, OffsetMatrix{Int})\n @test axes(B) === (OffsetArrays.IdOffsetRange(Base.OneTo(7), -4), OffsetArrays.IdOffsetRange(Base.OneTo(4)))\n B = similar(parent(A), (-3:3,1:4))\n-@test isa(B, OffsetArray{Int,2})\n+@test isa(B, OffsetMatrix{Int})\n @test axes(B) === (OffsetArrays.IdOffsetRange(Base.OneTo(7), -4), OffsetArrays.IdOffsetRange(Base.OneTo(4)))\n \n # Indexing with OffsetArray indices\n@@ -923,7 +923,7 @@ end\n     @test axes(A) == Base.IdentityUnitRange.((2:3, 4:5))\n \n     B = reshape(A0, -10:-9, 9:10)\n-    @test isa(B, OffsetArray{Int,2})\n+    @test isa(B, OffsetMatrix{Int})\n     @test parent(B) == A0\n     @test axes(B) == Base.IdentityUnitRange.((-10:-9, 9:10))\n end"
    },
    {
      "sha": "46253d02b0c7f77bcf0bd3e6b7325363d28090e6",
      "filename": "test/specificity.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/test%2Fspecificity.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/test%2Fspecificity.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fspecificity.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -170,7 +170,7 @@ let A = Tuple{Ref, Tuple{T}} where T,\n end\n \n # issue #22339\n-let A = Tuple{T, Array{T, 1}} where T,\n+let A = Tuple{T, Vector{T}} where T,\n     B = Tuple{T} where T,\n     C = Tuple{T} where T<:AbstractFloat\n     @test args_morespecific(B, A)"
    },
    {
      "sha": "c4f8c7537457e6441eed8502d3de40f1a5e75334",
      "filename": "test/strings/basic.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/test%2Fstrings%2Fbasic.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/test%2Fstrings%2Fbasic.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fstrings%2Fbasic.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -402,7 +402,7 @@ end\n end\n # test AbstractString functions at beginning of string.jl\n struct tstStringType <: AbstractString\n-    data::Array{UInt8,1}\n+    data::Vector{UInt8}\n end\n @testset \"AbstractString functions\" begin\n     tstr = tstStringType(unsafe_wrap(Vector{UInt8},\"12\"))"
    },
    {
      "sha": "c9ceada7e90f5756377855c3817eaf56f32112bd",
      "filename": "test/subtype.jl",
      "status": "modified",
      "additions": 128,
      "deletions": 128,
      "changes": 256,
      "blob_url": "https://github.com/JuliaLang/julia/blob/cbf449d41ce732b97cdca6956ce8ffe9add948c7/test%2Fsubtype.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/cbf449d41ce732b97cdca6956ce8ffe9add948c7/test%2Fsubtype.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fsubtype.jl?ref=cbf449d41ce732b97cdca6956ce8ffe9add948c7",
      "patch": "@@ -20,22 +20,22 @@ intersection_env(@nospecialize(x), @nospecialize(y)) = ccall(:jl_type_intersecti\n # level 1: no varags, union, UnionAll\n function test_1()\n     @test issub_strict(Int, Integer)\n-    @test issub_strict(Array{Int,1}, AbstractArray{Int,1})\n+    @test issub_strict(Vector{Int}, AbstractVector{Int})\n \n     @test isequal_type(Int, Int)\n     @test isequal_type(Integer, Integer)\n-    @test isequal_type(Array{Int,1}, Array{Int,1})\n-    @test isequal_type(AbstractArray{Int,1}, AbstractArray{Int,1})\n+    @test isequal_type(Vector{Int}, Vector{Int})\n+    @test isequal_type(AbstractVector{Int}, AbstractVector{Int})\n \n     @test issub_strict(Tuple{Int,Int}, Tuple{Integer,Integer})\n-    @test issub_strict(Tuple{Array{Int,1}}, Tuple{AbstractArray{Int,1}})\n+    @test issub_strict(Tuple{Vector{Int}}, Tuple{AbstractVector{Int}})\n \n     @test isequal_type(Tuple{Integer,Integer}, Tuple{Integer,Integer})\n \n     @test !issub(Tuple{Int,Int}, Tuple{Int})\n     @test !issub(Tuple{Int}, Tuple{Integer,Integer})\n \n-    @test !issub(Array{Int,1}, Array{Integer,1})\n+    @test !issub(Vector{Int}, Vector{Integer})\n end\n \n # level 2: varargs\n@@ -109,7 +109,7 @@ function test_diagonal()\n     @test !issub(Tuple{Real,Real}, @UnionAll T<:Real Tuple{T,T})\n \n     @test issub((@UnionAll S<:Int (@UnionAll R<:AbstractString Tuple{S,R,Vector{Any}})),\n-                (@UnionAll T Tuple{T, T, Array{T,1}}))\n+                (@UnionAll T Tuple{T, T, Vector{T}}))\n \n     @test issub_strict(Tuple{String, Real, Ref{Number}},\n                        (@UnionAll T Tuple{Union{T,String}, T, Ref{T}}))\n@@ -171,7 +171,7 @@ function test_diagonal()\n     end\n \n     # #26108\n-    @test !issub((Tuple{T, T, Array{T, 1}} where T), Tuple{T, T, Any} where T)\n+    @test !issub((Tuple{T, T, Vector{T}} where T), Tuple{T, T, Any} where T)\n \n     # #26716\n     @test !issub((Union{Tuple{Int,Bool}, Tuple{P,Bool}} where P), Tuple{Union{T,Int}, T} where T)\n@@ -188,7 +188,7 @@ end\n \n # level 3: UnionAll\n function test_3()\n-    @test issub_strict(Array{Int,1}, @UnionAll T Vector{T})\n+    @test issub_strict(Vector{Int}, @UnionAll T Vector{T})\n     @test issub_strict((@UnionAll T Pair{T,T}), Pair)\n     @test issub(Pair{Int,Int8}, Pair)\n     @test issub(Pair{Int,Int8}, (@UnionAll S Pair{Int,S}))\n@@ -203,8 +203,8 @@ function test_3()\n     @test issub_strict((@UnionAll T Tuple{Array{T},Array{T}}),\n                        Tuple{Array, Array})\n \n-    AUA = Array{(@UnionAll T Array{T,1}), 1}\n-    UAA = (@UnionAll T Array{Array{T,1}, 1})\n+    AUA = Vector{(@UnionAll T Vector{T})}\n+    UAA = (@UnionAll T Vector{Vector{T}})\n \n     @test !issub(AUA, UAA)\n     @test !issub(UAA, AUA)\n@@ -221,68 +221,68 @@ function test_3()\n     @test isequal_type((@UnionAll T Tuple{T}), Tuple{Any})\n     @test isequal_type((@UnionAll T<:Real Tuple{T}), Tuple{Real})\n \n-    @test  issub(Tuple{Array{Integer,1}, Int},\n-                 @UnionAll T<:Integer @UnionAll S<:T Tuple{Array{T,1},S})\n+    @test  issub(Tuple{Vector{Integer}, Int},\n+                 @UnionAll T<:Integer @UnionAll S<:T Tuple{Vector{T},S})\n \n-    @test !issub(Tuple{Array{Integer,1}, Real},\n-                 @UnionAll T<:Integer Tuple{Array{T,1},T})\n+    @test !issub(Tuple{Vector{Integer}, Real},\n+                 @UnionAll T<:Integer Tuple{Vector{T},T})\n \n     @test !issub(Tuple{Int,String,Vector{Integer}},\n-                 @UnionAll T Tuple{T, T, Array{T,1}})\n+                 @UnionAll T Tuple{T, T, Vector{T}})\n     @test !issub(Tuple{String,Int,Vector{Integer}},\n-                 @UnionAll T Tuple{T, T, Array{T,1}})\n+                 @UnionAll T Tuple{T, T, Vector{T}})\n     @test !issub(Tuple{Int,String,Vector{Tuple{Integer}}},\n-                 @UnionAll T Tuple{T,T,Array{Tuple{T},1}})\n+                 @UnionAll T Tuple{T,T,Vector{Tuple{T}}})\n \n     @test issub(Tuple{Int,String,Vector{Any}},\n-                @UnionAll T Tuple{T, T, Array{T,1}})\n+                @UnionAll T Tuple{T, T, Vector{T}})\n \n-    @test isequal_type(Array{Int,1}, Array{(@UnionAll T<:Int T), 1})\n-    @test isequal_type(Array{Tuple{Any},1}, Array{(@UnionAll T Tuple{T}), 1})\n+    @test isequal_type(Vector{Int}, Vector{(@UnionAll T<:Int T)})\n+    @test isequal_type(Vector{Tuple{Any}}, Vector{(@UnionAll T Tuple{T})})\n \n-    @test isequal_type(Array{Tuple{Int,Int},1},\n-                       Array{(@UnionAll T<:Int Tuple{T,T}), 1})\n-    @test !issub(Array{Tuple{Int,Integer},1},\n-                 Array{(@UnionAll T<:Integer Tuple{T,T}), 1})\n+    @test isequal_type(Vector{Tuple{Int,Int}},\n+                       Vector{(@UnionAll T<:Int Tuple{T,T})})\n+    @test !issub(Vector{Tuple{Int,Integer}},\n+                 Vector{(@UnionAll T<:Integer Tuple{T,T})})\n \n     @test !issub(Pair{Int,Int8}, (@UnionAll T Pair{T,T}))\n \n-    @test !issub(Tuple{Array{Int,1}, Integer},\n-                 @UnionAll T<:Integer Tuple{Array{T,1},T})\n+    @test !issub(Tuple{Vector{Int}, Integer},\n+                 @UnionAll T<:Integer Tuple{Vector{T},T})\n \n-    @test !issub(Tuple{Integer, Array{Int,1}},\n-                 @UnionAll T<:Integer Tuple{T, Array{T,1}})\n+    @test !issub(Tuple{Integer, Vector{Int}},\n+                 @UnionAll T<:Integer Tuple{T, Vector{T}})\n \n-    @test !issub(Pair{Array{Int,1},Integer}, @UnionAll T Pair{Array{T,1},T})\n-    @test  issub(Pair{Array{Int,1},Int}, @UnionAll T Pair{Array{T,1},T})\n+    @test !issub(Pair{Vector{Int},Integer}, @UnionAll T Pair{Vector{T},T})\n+    @test  issub(Pair{Vector{Int},Int}, @UnionAll T Pair{Vector{T},T})\n \n     @test  issub(Tuple{Integer,Int}, @UnionAll T<:Integer @UnionAll S<:T Tuple{T,S})\n     @test !issub(Tuple{Integer,Int}, @UnionAll T<:Int     @UnionAll S<:T Tuple{T,S})\n     @test !issub(Tuple{Integer,Int}, @UnionAll T<:String  @UnionAll S<:T Tuple{T,S})\n \n-    @test issub(Tuple{Float32,Array{Float32,1}},\n-                @UnionAll T<:Real @UnionAll S<:AbstractArray{T,1} Tuple{T,S})\n+    @test issub(Tuple{Float32,Vector{Float32}},\n+                @UnionAll T<:Real @UnionAll S<:AbstractVector{T} Tuple{T,S})\n \n-    @test !issub(Tuple{Float32,Array{Float64,1}},\n-                 @UnionAll T<:Real @UnionAll S<:AbstractArray{T,1} Tuple{T,S})\n+    @test !issub(Tuple{Float32,Vector{Float64}},\n+                 @UnionAll T<:Real @UnionAll S<:AbstractVector{T} Tuple{T,S})\n \n-    @test issub(Tuple{Float32,Array{Real,1}},\n-                @UnionAll T<:Real @UnionAll S<:AbstractArray{T,1} Tuple{T,S})\n+    @test issub(Tuple{Float32,Vector{Real}},\n+                @UnionAll T<:Real @UnionAll S<:AbstractVector{T} Tuple{T,S})\n \n-    @test !issub(Tuple{Number,Array{Real,1}},\n-                 @UnionAll T<:Real @UnionAll S<:AbstractArray{T,1} Tuple{T,S})\n+    @test !issub(Tuple{Number,Vector{Real}},\n+                 @UnionAll T<:Real @UnionAll S<:AbstractVector{T} Tuple{T,S})\n \n     @test issub((@UnionAll Int<:T<:Integer T), @UnionAll T<:Real T)\n-    @test issub((@UnionAll Int<:T<:Integer Array{T,1}),\n-                (@UnionAll T<:Real Array{T,1}))\n+    @test issub((@UnionAll Int<:T<:Integer Vector{T}),\n+                (@UnionAll T<:Real Vector{T}))\n \n     @test  issub((@UnionAll Int<:T<:Integer T), (@UnionAll Integer<:T<:Real T))\n-    @test !issub((@UnionAll Int<:T<:Integer Array{T,1}), (@UnionAll Integer<:T<:Real Array{T,1}))\n+    @test !issub((@UnionAll Int<:T<:Integer Vector{T}), (@UnionAll Integer<:T<:Real Vector{T}))\n \n-    X = (@UnionAll T<:Real @UnionAll S<:AbstractArray{T,1} Tuple{T,S})\n-    Y = (@UnionAll A<:Real @UnionAll B<:AbstractArray{A,1} Tuple{A,B})\n+    X = (@UnionAll T<:Real @UnionAll S<:AbstractVector{T} Tuple{T,S})\n+    Y = (@UnionAll A<:Real @UnionAll B<:AbstractVector{A} Tuple{A,B})\n     @test isequal_type(X,Y)\n-    Z = (@UnionAll A<:Real @UnionAll B<:AbstractArray{A,1} Tuple{Real,B})\n+    Z = (@UnionAll A<:Real @UnionAll B<:AbstractVector{A} Tuple{Real,B})\n     @test issub_strict(X,Z)\n \n     @test issub_strict((@UnionAll T @UnionAll S<:T Pair{T,S}),\n@@ -329,7 +329,7 @@ function test_3()\n     @test !issub((Type{AbstractArray{Array{T}} where T}), Type{AbstractArray{S}} where S)\n     @test !issub((Val{AbstractArray{Array{T}} where T}), Val{AbstractArray{T}} where T)\n     @test !issub((Array{Array{Array{T}} where T}), Array{Array{T}} where T)\n-    @test !issub((Array{Array{T, 1}, 1} where T), AbstractArray{Vector})\n+    @test !issub((Vector{Vector{T}} where T), AbstractArray{Vector})\n \n     @test !issub((Ref{Pair{Pair{T, R}, R} where R} where T),\n                  (Ref{Pair{A,          B} where B} where A))\n@@ -390,36 +390,36 @@ end\n function test_5()\n     u = Union{Int8,Int}\n \n-    @test issub(Tuple{String,Array{Int,1}},\n-                (@UnionAll T Union{Tuple{T,Array{T,1}}, Tuple{T,Array{Int,1}}}))\n+    @test issub(Tuple{String,Vector{Int}},\n+                (@UnionAll T Union{Tuple{T,Vector{T}}, Tuple{T,Vector{Int}}}))\n \n     @test issub(Tuple{Union{Vector{Int},Vector{Int8}}},\n-                @UnionAll T Tuple{Array{T,1}})\n+                @UnionAll T Tuple{Vector{T}})\n \n     @test !issub(Tuple{Union{Vector{Int},Vector{Int8}},Vector{Int}},\n-                 @UnionAll T Tuple{Array{T,1}, Array{T,1}})\n+                 @UnionAll T Tuple{Vector{T}, Vector{T}})\n \n     @test !issub(Tuple{Union{Vector{Int},Vector{Int8}},Vector{Int8}},\n-                 @UnionAll T Tuple{Array{T,1}, Array{T,1}})\n+                 @UnionAll T Tuple{Vector{T}, Vector{T}})\n \n-    @test !issub(Vector{Int}, @UnionAll T>:u Array{T,1})\n-    @test  issub(Vector{Integer}, @UnionAll T>:u Array{T,1})\n-    @test  issub(Vector{Union{Int,Int8}}, @UnionAll T>:u Array{T,1})\n+    @test !issub(Vector{Int}, @UnionAll T>:u Vector{T})\n+    @test  issub(Vector{Integer}, @UnionAll T>:u Vector{T})\n+    @test  issub(Vector{Union{Int,Int8}}, @UnionAll T>:u Vector{T})\n \n-    @test issub((@UnionAll Int<:T<:u Array{T,1}), (@UnionAll Int<:T<:u Array{T,1}))\n+    @test issub((@UnionAll Int<:T<:u Vector{T}), (@UnionAll Int<:T<:u Vector{T}))\n \n     # with varargs\n     @test !issub(Array{Tuple{Array{Int},Array{Vector{Int16}},Array{Vector{Int}},Array{Int}}},\n-                 @UnionAll T<:(@UnionAll S Tuple{Vararg{Union{Array{S}, Array{Array{S,1}}}}}) Array{T})\n+                 @UnionAll T<:(@UnionAll S Tuple{Vararg{Union{Array{S}, Array{Vector{S}}}}}) Array{T})\n \n     @test  issub(Array{Tuple{Array{Int},Array{Vector{Int}},Array{Vector{Int}},Array{Int}}},\n-                 @UnionAll T<:(@UnionAll S Tuple{Vararg{Union{Array{S}, Array{Array{S,1}}}}}) Array{T})\n+                 @UnionAll T<:(@UnionAll S Tuple{Vararg{Union{Array{S}, Array{Vector{S}}}}}) Array{T})\n \n     @test !issub(Tuple{Array{Int},Array{Vector{Int16}},Array{Vector{Int}},Array{Int}},\n-                 @UnionAll S Tuple{Vararg{Union{Array{S},Array{Array{S,1}}}}})\n+                 @UnionAll S Tuple{Vararg{Union{Array{S},Array{Vector{S}}}}})\n \n     @test  issub(Tuple{Array{Int},Array{Vector{Int}},Array{Vector{Int}},Array{Int}},\n-                 @UnionAll S Tuple{Vararg{Union{Array{S},Array{Array{S,1}}}}})\n+                 @UnionAll S Tuple{Vararg{Union{Array{S},Array{Vector{S}}}}})\n \n     B = @UnionAll S<:u Tuple{S, Tuple{Any,Any,Any}, Ref{S}}\n     # these tests require renaming in issub_unionall\n@@ -428,8 +428,8 @@ function test_5()\n \n     # the `convert(Type{T},T)` pattern, where T is a Union\n     # required changing priority of unions and vars\n-    @test issub(Tuple{Array{u,1},Int}, @UnionAll T Tuple{Array{T,1}, T})\n-    @test issub(Tuple{Array{u,1},Int}, @UnionAll T @UnionAll S<:T Tuple{Array{T,1}, S})\n+    @test issub(Tuple{Vector{u},Int}, @UnionAll T Tuple{Vector{T}, T})\n+    @test issub(Tuple{Vector{u},Int}, @UnionAll T @UnionAll S<:T Tuple{Vector{T}, S})\n \n     @test !issub(Ref{Union{Ref{Int},Ref{Int8}}}, @UnionAll T Ref{Ref{T}})\n     @test  issub(Tuple{Union{Ref{Int},Ref{Int8}}}, @UnionAll T Tuple{Ref{T}})\n@@ -449,10 +449,10 @@ end\n # tricky type variable lower bounds\n function test_6()\n     @test  issub((@UnionAll S<:Int (@UnionAll R<:String Tuple{S,R,Vector{Any}})),\n-                 (@UnionAll T Tuple{T, T, Array{T,1}}))\n+                 (@UnionAll T Tuple{T, T, Vector{T}}))\n \n     @test !issub((@UnionAll S<:Int (@UnionAll R<:String Tuple{S,R,Vector{Integer}})),\n-                 (@UnionAll T Tuple{T, T, Array{T,1}}))\n+                 (@UnionAll T Tuple{T, T, Vector{T}}))\n \n     t = @UnionAll T Tuple{T,T,Ref{T}}\n     @test isequal_type(t, @UnionAll S Tuple{S,S,Ref{S}})\n@@ -561,8 +561,8 @@ function test_old()\n     @test Int8 <: Integer\n     @test Int32 <: Integer\n     @test Tuple{Int8,Int8} <: Tuple{Integer,Integer}\n-    @test !(AbstractArray{Float64,2} <: AbstractArray{Number,2})\n-    @test !(AbstractArray{Float64,1} <: AbstractArray{Float64,2})\n+    @test !(AbstractMatrix{Float64} <: AbstractMatrix{Number})\n+    @test !(AbstractVector{Float64} <: AbstractMatrix{Float64})\n     @test Tuple{Integer,Vararg{Integer}} <: Tuple{Integer,Vararg{Real}}\n     @test Tuple{Integer,Float64,Vararg{Integer}} <: Tuple{Integer,Vararg{Number}}\n     @test Tuple{Integer,Float64} <: Tuple{Integer,Vararg{Number}}\n@@ -571,9 +571,9 @@ function test_old()\n     @test !(Tuple{Vararg{Int32}} <: Tuple{Int32,})\n     @test !(Tuple{Vararg{Int32}} <: Tuple{Number,Integer})\n     @test !(Tuple{Vararg{Integer}} <: Tuple{Integer,Integer,Vararg{Integer}})\n-    @test !(Array{Int8,1} <: Array{Any,1})\n-    @test !(Array{Any,1} <: Array{Int8,1})\n-    @test Array{Int8,1} <: Array{Int8,1}\n+    @test !(Vector{Int8} <: Vector{Any})\n+    @test !(Vector{Any} <: Vector{Int8})\n+    @test Vector{Int8} <: Vector{Int8}\n     @test !(Type{Bottom} <: Type{Int32})\n     @test !(Vector{Float64} <: Vector{Union{Float64,Float32}})\n \n@@ -604,10 +604,10 @@ end\n \n const easy_menagerie =\n     Any[Any, Int, Int8, Integer, Real,\n-        Array{Int,1}, AbstractArray{Int,1},\n+        Vector{Int}, AbstractVector{Int},\n         Tuple{Int,Vararg{Integer}}, Tuple{Integer,Vararg{Int}}, Tuple{},\n         Union{Int,Int8},\n-        (@UnionAll T Array{T,1}),\n+        (@UnionAll T Vector{T}),\n         (@UnionAll T Pair{T,T}),\n         (@UnionAll T @UnionAll S Pair{T,S}),\n         Pair{Int,Int8},\n@@ -617,15 +617,15 @@ const easy_menagerie =\n         (@UnionAll T @UnionAll S Tuple{T,S}),\n         (@UnionAll T<:Integer @UnionAll S<:Number Tuple{T,S}),\n         (@UnionAll T<:Integer @UnionAll S<:Number Tuple{S,T}),\n-        Array{(@UnionAll T Array{T,1}),1},\n-        (@UnionAll T Array{Array{T,1},1}),\n-        Array{(@UnionAll T<:Int T), 1},\n-        (@UnionAll T<:Real @UnionAll S<:AbstractArray{T,1} Tuple{T,S}),\n+        Vector{(@UnionAll T Vector{T})},\n+        (@UnionAll T Vector{Vector{T}}),\n+        Vector{(@UnionAll T<:Int T)},\n+        (@UnionAll T<:Real @UnionAll S<:AbstractVector{T} Tuple{T,S}),\n         Union{Int,Ref{Union{Int,Int8}}},\n         ]\n \n const hard_menagerie =\n-    Any[(@UnionAll T Union{Tuple{T,Array{T,1}}, Tuple{T,Array{Int,1}}})]\n+    Any[(@UnionAll T Union{Tuple{T,Vector{T}}, Tuple{T,Vector{Int}}})]\n \n function add_variants!(types)\n     new = Any[]\n@@ -769,11 +769,11 @@ function test_intersection()\n     @testintersect((@UnionAll T<:Number Array{T}), (@UnionAll T<:String Array{T}),\n                    Array{Bottom})\n \n-    @testintersect((@UnionAll T Tuple{T, AbstractArray{T}}), Tuple{Number, Array{Int,1}},\n-                   Tuple{Int, Array{Int,1}})\n+    @testintersect((@UnionAll T Tuple{T, AbstractArray{T}}), Tuple{Number, Vector{Int}},\n+                   Tuple{Int, Vector{Int}})\n \n-    @testintersect((@UnionAll T Tuple{T, AbstractArray{T}}), Tuple{Int, Array{Number,1}},\n-                   Tuple{Int, Array{Number,1}})\n+    @testintersect((@UnionAll T Tuple{T, AbstractArray{T}}), Tuple{Int, Vector{Number}},\n+                   Tuple{Int, Vector{Number}})\n \n     # TODO: improve this result\n     #@testintersect((@UnionAll S Tuple{S,Vector{S}}), (@UnionAll T<:Real Tuple{T,AbstractVector{T}}),\n@@ -784,10 +784,10 @@ function test_intersection()\n     # typevar corresponding to a type it will end up being neither greater than nor\n     # less than\n     @testintersect((@UnionAll T Tuple{T, Ref{T}}), Tuple{Array{Int}, Ref{AbstractVector}},\n-                   Tuple{Array{Int,1}, Ref{AbstractVector}})\n+                   Tuple{Vector{Int}, Ref{AbstractVector}})\n \n-    @testintersect((@UnionAll T Tuple{T, AbstractArray{T}}), Tuple{Any, Array{Number,1}},\n-                   Tuple{Number, Array{Number,1}})\n+    @testintersect((@UnionAll T Tuple{T, AbstractArray{T}}), Tuple{Any, Vector{Number}},\n+                   Tuple{Number, Vector{Number}})\n     @testintersect((@UnionAll T Tuple{Array{T}, Array{T}}), Tuple{Array, Array{Any}}, !Bottom)\n \n     @testintersect((@UnionAll T Tuple{T,T}), Tuple{Real, Real}, (@UnionAll T<:Real Tuple{T,T}))\n@@ -800,9 +800,9 @@ function test_intersection()\n                    @UnionAll Z<:Integer Pair{Z,Z})\n \n     @testintersect((@UnionAll T<:Vector Type{T}), (@UnionAll N Type{@UnionAll S<:Number Array{S,N}}),\n-                   Type{@UnionAll S<:Number Array{S,1}})\n+                   Type{@UnionAll S<:Number Vector{S}})\n \n-    @testintersect((@UnionAll T Tuple{Type{Array{T,1}},Array{T,1}}),\n+    @testintersect((@UnionAll T Tuple{Type{Vector{T}},Vector{T}}),\n                    Tuple{Type{AbstractVector},Vector{Int}}, Bottom)\n \n     @testintersect(Tuple{Type{Vector{ComplexF64}}, AbstractVector},\n@@ -843,8 +843,8 @@ function test_intersection()\n                        @UnionAll N Tuple{Tuple{Int,Vararg{Int}},Array{Int,N}})\n \n     @testintersect((@UnionAll N Tuple{NTuple{N,Any},Array{Int,N}}),\n-                   Tuple{Tuple{Int,Vararg{Int}},Array{Int,2}},\n-                   Tuple{Tuple{Int,Int}, Array{Int,2}})\n+                   Tuple{Tuple{Int,Vararg{Int}},Matrix{Int}},\n+                   Tuple{Tuple{Int,Int}, Matrix{Int}})\n     @testintersect(Type{Any},Type{Complex}, Bottom)\n     @testintersect(Type{Any},(@UnionAll T<:Real Type{T}), Bottom)\n \n@@ -867,7 +867,7 @@ function test_intersection()\n     @testintersect((@UnionAll N Tuple{Array{Int,N},Vararg{Int,N}}), Tuple{Vector{Int},Real,Real,Real}, Bottom)\n \n     @testintersect((@UnionAll N Tuple{Array{Int,N},Vararg{Int,N}}), Tuple{Array{Int,0}}, Tuple{Array{Int,0}})\n-    @testintersect((@UnionAll N Tuple{Array{Int,N},Vararg{Int,N}}), Tuple{Array{Int,2}}, Bottom)\n+    @testintersect((@UnionAll N Tuple{Array{Int,N},Vararg{Int,N}}), Tuple{Matrix{Int}}, Bottom)\n \n     @testintersect(Tuple{Int,Vararg{Int}}, Tuple{Int,Int,Int,Vararg{Float64}}, Tuple{Int,Int,Int})\n     @testintersect(Tuple{Int,Vararg{Int}}, Tuple{Int,Vararg{Float64}}, Tuple{Int})\n@@ -877,11 +877,11 @@ function test_intersection()\n     @testintersect((@UnionAll N Tuple{Array{Int,N},Vararg{Int,N}}),\n                    Tuple{Matrix{Int},Int,Vararg{Float64}}, Bottom)\n \n-    @testintersect(Tuple{Array{Any,1}, Tuple{Int64, Int64, Vararg{Int64}}},\n+    @testintersect(Tuple{Vector{Any}, Tuple{Int64, Int64, Vararg{Int64}}},\n                    Tuple{Array{T,N}, Tuple{Vararg{Int64,N}}} where N where T,\n                    Bottom)\n \n-    @testintersect((@UnionAll T<:Union{Float64,Array{Float64,1}} T), Real, Float64)\n+    @testintersect((@UnionAll T<:Union{Float64,Vector{Float64}} T), Real, Float64)\n \n     # issue #4805\n     @testintersect((@UnionAll T<:Int Type{IT4805_2{1,T}}),\n@@ -955,20 +955,20 @@ function test_intersection()\n                    Tuple{Type{S}, Tuple{Any, Vararg{Any}}} where S<:Tuple{Any, Vararg{Any}})\n \n     # part of issue #20450\n-    @testintersect(Tuple{Array{Ref{T}, 1}, Array{Pair{M, V}, 1}} where V where T where M,\n-                   Tuple{Array{Ref{T}, 1}, Array{Pair{M, T}, 1}, SS} where T where M where SS,\n+    @testintersect(Tuple{Vector{Ref{T}}, Vector{Pair{M, V}}} where V where T where M,\n+                   Tuple{Vector{Ref{T}}, Vector{Pair{M, T}}, SS} where T where M where SS,\n                    Union{})\n \n-    @testintersect(Tuple{Array{Ref{T}, 1}, Array{Pair{M, V}, 1}, Int} where V where T where M,\n-                   Tuple{Array{Ref{T}, 1}, Array{Pair{M, T}, 1}, Any} where T where M,\n-                   Tuple{Array{Ref{T}, 1}, Array{Pair{M, T}, 1}, Int} where T where M)\n+    @testintersect(Tuple{Vector{Ref{T}}, Vector{Pair{M, V}}, Int} where V where T where M,\n+                   Tuple{Vector{Ref{T}}, Vector{Pair{M, T}}, Any} where T where M,\n+                   Tuple{Vector{Ref{T}}, Vector{Pair{M, T}}, Int} where T where M)\n \n     @testintersect(Tuple{Int, Ref{Pair{K,V}}} where V where K,\n                    Tuple{Any, Ref{Pair{T,T}} where T },\n                    Tuple{Int, Ref{Pair{T,T}} where T })\n \n     @test_broken isequal_type(_type_intersect(Tuple{T,T} where T,\n-                                              Union{Tuple{S,Array{Int64,1}},Tuple{S,Array{S,1}}} where S),\n+                                              Union{Tuple{S,Vector{Int64}},Tuple{S,Vector{S}}} where S),\n                               Union{Tuple{Vector{Int64},Vector{Int64}},\n                                     Tuple{Vector{T},Vector{T}} where T>:Vector})\n \n@@ -1046,8 +1046,8 @@ function test_intersection()\n                    Tuple{Ref{T}, Ref{T}} where T,\n                    Tuple{Ref{Ref{Int}}, Ref{Ref{Int}}})\n     @testintersect(Tuple{Vector{Pair{K,V}}, Vector{Pair{K,V}}} where K where V,\n-                   Tuple{(Array{Pair{Ref{_2},_1},1} where _2 where _1),\n-                         Array{Pair{Ref{Int64},Rational{Int64}},1}},\n+                   Tuple{(Vector{Pair{Ref{_2},_1}} where _2 where _1),\n+                         Vector{Pair{Ref{Int64},Rational{Int64}}}},\n                    Tuple{Vector{Pair{Ref{Int64},Rational{Int64}}},\n                          Vector{Pair{Ref{Int64},Rational{Int64}}}})\n     @testintersect(Vector{>:Missing}, Vector{Int}, Union{})\n@@ -1135,7 +1135,7 @@ let S = ccall(:jl_new_structv, Any, (Any, Ptr{Cvoid}, UInt32), UnionAll, [TypeVa\n end\n \n # issue #20121\n-@test NTuple{170,Matrix{Int}} <: (Tuple{Vararg{Union{Array{T,1},Array{T,2},Array{T,3}}}} where T)\n+@test NTuple{170,Matrix{Int}} <: (Tuple{Vararg{Union{Vector{T},Matrix{T},Array{T,3}}}} where T)\n \n # Issue #12580\n abstract type AbstractMyType12580{T} end\n@@ -1412,24 +1412,24 @@ end\n let\n     triangular(::Type{<:AbstractArray{T}}) where {T} = T\n     triangular(::Type{<:AbstractArray}) = Any\n-    @test triangular(Array{Array{T, 1}, 1} where T) === Any\n+    @test triangular(Vector{Vector{T}} where T) === Any\n end\n \n # issue #23908\n-@test Array{Union{Int128, Int16, Int32, Int8}, 1} <: Array{Union{Int128, Int32, Int8, _1}, 1} where _1\n-let A = Pair{Nothing, Pair{Array{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}, 1}, Nothing}},\n-    B = Pair{Nothing, Pair{Array{Union{Int8, UInt128, UInt16, UInt32, UInt64, UInt8, _1}, 1}, Nothing}} where _1\n+@test Vector{Union{Int128, Int16, Int32, Int8}} <: Vector{Union{Int128, Int32, Int8, _1}} where _1\n+let A = Pair{Nothing, Pair{Vector{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}, Nothing}},\n+    B = Pair{Nothing, Pair{Vector{Union{Int8, UInt128, UInt16, UInt32, UInt64, UInt8, _1}}, Nothing}} where _1\n     @test A <: B\n     @test !(B <: A)\n end\n \n # issue #22688\n-let X = Ref{Tuple{Array{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}, 1}}}\n+let X = Ref{Tuple{Vector{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}}}\n     @test !(X <: Ref{Tuple{Array{Union{Int8, UInt128, UInt16, UInt32, UInt64, UInt8, S}}}} where S)\n-    @test X <: Ref{Tuple{Array{Union{Int8, UInt128, UInt16, UInt32, UInt64, UInt8, S}, 1}}} where S\n+    @test X <: Ref{Tuple{Vector{Union{Int8, UInt128, UInt16, UInt32, UInt64, UInt8, S}}}} where S\n end\n-let X = Ref{Tuple{Array{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}, 1}, Array{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}, 1}}},\n-    Y = Ref{Tuple{Array{Union{Int8, UInt128, UInt16, UInt32, UInt64, UInt8, S}, 1}, Array{Union{Int8, UInt128, UInt16, UInt32, UInt64, UInt8, T}, 1}}} where S where T\n+let X = Ref{Tuple{Vector{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}, Vector{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}}},\n+    Y = Ref{Tuple{Vector{Union{Int8, UInt128, UInt16, UInt32, UInt64, UInt8, S}}, Vector{Union{Int8, UInt128, UInt16, UInt32, UInt64, UInt8, T}}}} where S where T\n     @test X <: Y\n end\n \n@@ -1591,9 +1591,9 @@ let A = Tuple{Any, Type{Union{Nothing, Int64}}},\n     @test I >: Tuple{Int64,Type{Union{Nothing, Int64}}}\n     @test J >: Tuple{Int64,Type{Union{Nothing, Int64}}}\n end\n-@testintersect(Union{Array{T,1},Array{T,2}} where T<:Union{Float32,Float64},\n+@testintersect(Union{Vector{T},Matrix{T}} where T<:Union{Float32,Float64},\n                Union{AbstractMatrix{Float32},AbstractVector{Float32}},\n-               Union{Array{Float32,2}, Array{Float32,1}})\n+               Union{Matrix{Float32}, Vector{Float32}})\n let A = Tuple{Type{Union{Missing,T}},Any} where T,\n     B = Tuple{Type{Union{Nothing,T}},Any} where T\n     I = typeintersect(A, B)\n@@ -1607,16 +1607,16 @@ struct M29955{T, TV<:AbstractVector{T}}\n end\n @testintersect(M29955,\n                M29955{<:Any,TV} where TV>:Vector{Float64},\n-               M29955{Float64,TV} where Array{Float64,1}<:TV<:AbstractArray{Float64,1})\n+               M29955{Float64,TV} where Vector{Float64}<:TV<:AbstractVector{Float64})\n \n struct A29955{T, TV<:AbstractVector{T}, TModel<:M29955{T,TV}}\n end\n-@testintersect(Tuple{Type{A29955{Float64,Array{Float64,1},_1}} where _1,\n+@testintersect(Tuple{Type{A29955{Float64,Vector{Float64},_1}} where _1,\n                      Any},\n                Tuple{Type{A29955{T,TV,TM}},\n                      TM} where {T,TV<:AbstractVector{T},TM<:M29955{T,TV}},\n-               Tuple{Type{A29955{Float64,Array{Float64,1},TM}},\n-                   M29955{Float64,Vector{Float64}}} where TM<:M29955{Float64,Array{Float64,1}})\n+               Tuple{Type{A29955{Float64,Vector{Float64},TM}},\n+                   M29955{Float64,Vector{Float64}}} where TM<:M29955{Float64,Vector{Float64}})\n let M = M29955{T,Vector{Float64}} where T\n     @test M == (M29955{T,Vector{Float64}} where T)\n     @test M{Float64} == M29955{Float64,Vector{Float64}}\n@@ -1689,11 +1689,11 @@ f31082(::Pair{B, C}, ::C, ::C) where {B, C} = 1\n                Tuple{Type{Val{T}},Int,Int} where T>:Integer)\n \n # issue #31496\n-CovType{T} = Union{AbstractArray{T,2},\n+CovType{T} = Union{AbstractMatrix{T},\n                    Vector{UpperTriangular{T,Matrix{T}}}}\n @testintersect(Pair{<:Any, <:AbstractMatrix},\n                Pair{T,     <:CovType{T}} where T<:AbstractFloat,\n-               Pair{T,S} where S<:AbstractArray{T,2} where T<:AbstractFloat)\n+               Pair{T,S} where S<:AbstractMatrix{T} where T<:AbstractFloat)\n \n # issue #31703\n @testintersect(Pair{<:Any, Ref{Tuple{Ref{Ref{Tuple{Int}}},Ref{Float64}}}},\n@@ -1722,11 +1722,11 @@ const RadialOperator{T,B,M<:AbstractMatrix{T}} = Mul{<:Any,<:Tuple{<:BasisOrRest\n const HFPotentialOperator{T,B} = RadialOperator{T,B,Diagonal{T,Vector{T}}}\n struct HFPotential{kind,T,B,RO<:HFPotentialOperator{T,B},P<:Integer} end\n \n-T = HFPotential{_A,Float64,Any,Applied{Int,Tuple{ApplyQuasiArray{Float64,2,Applied{Int,Tuple{Any,BandedMatrix{Int,Ones{Int,2,Tuple{OneTo{Int},OneTo{Int}}},OneTo{Int}}}}},Diagonal{Float64,Array{Float64,1}},ApplyQuasiArray{Float64,2,Applied{Int,Tuple{Adjoint{Int,BandedMatrix{Int,Ones{Int,2,Tuple{OneTo{Int},OneTo{Int}}},OneTo{Int}}},QuasiAdjoint{Float64,Any}}}}}},_B} where _B where _A\n+T = HFPotential{_A,Float64,Any,Applied{Int,Tuple{ApplyQuasiArray{Float64,2,Applied{Int,Tuple{Any,BandedMatrix{Int,Ones{Int,2,Tuple{OneTo{Int},OneTo{Int}}},OneTo{Int}}}}},Diagonal{Float64,Vector{Float64}},ApplyQuasiArray{Float64,2,Applied{Int,Tuple{Adjoint{Int,BandedMatrix{Int,Ones{Int,2,Tuple{OneTo{Int},OneTo{Int}}},OneTo{Int}}},QuasiAdjoint{Float64,Any}}}}}},_B} where _B where _A\n \n let A = typeintersect(HFPotential, T),\n     B = typeintersect(T, HFPotential)\n-    @test A == B == HFPotential{kind,Float64,Any,Applied{Int,Tuple{ApplyQuasiArray{Float64,2,Applied{Int,Tuple{Any,BandedMatrix{Int,Ones{Int,2,Tuple{OneTo{Int},OneTo{Int}}},OneTo{Int}}}}},Diagonal{Float64,Array{Float64,1}},ApplyQuasiArray{Float64,2,Applied{Int,Tuple{Adjoint{Int,BandedMatrix{Int,Ones{Int,2,Tuple{OneTo{Int},OneTo{Int}}},OneTo{Int}}},QuasiAdjoint{Float64,Any}}}}}},P} where P<:Integer where kind\n+    @test A == B == HFPotential{kind,Float64,Any,Applied{Int,Tuple{ApplyQuasiArray{Float64,2,Applied{Int,Tuple{Any,BandedMatrix{Int,Ones{Int,2,Tuple{OneTo{Int},OneTo{Int}}},OneTo{Int}}}}},Diagonal{Float64,Vector{Float64}},ApplyQuasiArray{Float64,2,Applied{Int,Tuple{Adjoint{Int,BandedMatrix{Int,Ones{Int,2,Tuple{OneTo{Int},OneTo{Int}}},OneTo{Int}}},QuasiAdjoint{Float64,Any}}}}}},P} where P<:Integer where kind\n end\n end\n \n@@ -1759,9 +1759,9 @@ end\n @testintersect(Tuple{Type{<:AbstractVector{T}}, Int} where T,\n                Tuple{Type{Vector{T} where Int<:T<:Int}, Any},\n                Tuple{Type{Vector{Int}}, Int})\n-let X = LinearAlgebra.Symmetric{T, S} where S<:(AbstractArray{U, 2} where U<:T) where T,\n-    Y = Union{LinearAlgebra.Hermitian{T, S} where S<:(AbstractArray{U, 2} where U<:T) where T,\n-              LinearAlgebra.Symmetric{T, S} where S<:(AbstractArray{U, 2} where U<:T) where T}\n+let X = LinearAlgebra.Symmetric{T, S} where S<:(AbstractMatrix{U} where U<:T) where T,\n+    Y = Union{LinearAlgebra.Hermitian{T, S} where S<:(AbstractMatrix{U} where U<:T) where T,\n+              LinearAlgebra.Symmetric{T, S} where S<:(AbstractMatrix{U} where U<:T) where T}\n     @test X <: Y\n end\n \n@@ -1799,9 +1799,9 @@ let T31805 = Tuple{Type{Tuple{}}, Tuple{Vararg{Int8, A}}} where A,\n end\n \n @testintersect(\n-    Tuple{Array{Tuple{Vararg{Int64,N}},N},Tuple{Vararg{Array{Int64,1},N}}} where N,\n-    Tuple{Array{Tuple{Int64},1}, Tuple},\n-    Tuple{Array{Tuple{Int64},1},Tuple{Array{Int64,1}}})\n+    Tuple{Array{Tuple{Vararg{Int64,N}},N},Tuple{Vararg{Vector{Int64},N}}} where N,\n+    Tuple{Vector{Tuple{Int64}}, Tuple},\n+    Tuple{Vector{Tuple{Int64}},Tuple{Vector{Int64}}})\n \n @test !isequal_type(Tuple{Int, Vararg{T, 3}} where T<:Real, Tuple{Int, Real, Vararg{T, 2}} where T<:Integer)\n \n@@ -1857,7 +1857,7 @@ c32703(::Type{<:Str{C}}, str::Str{C}) where {C<:CSE} = str\n @test c32703(UTF16Str, ASCIIStr()) == 42\n @testintersect(Tuple{Vector{Vector{Float32}},Matrix,Matrix},\n                Tuple{Vector{V},Matrix{Int},Matrix{S}} where {S, V<:AbstractVector{S}},\n-               Tuple{Array{Array{Float32,1},1},Array{Int,2},Array{Float32,2}})\n+               Tuple{Vector{Vector{Float32}},Matrix{Int},Matrix{Float32}})\n \n @testintersect(Tuple{Pair{Int, DataType}, Any},\n                Tuple{Pair{A, B} where B<:Type, Int} where A,\n@@ -1896,7 +1896,7 @@ s26065 = Ref{Tuple{T,Ref{Union{Ref{Tuple{Ref{Union{Ref{Ref{Tuple{Ref{Tuple{Union\n       Val{Tuple{Missing, Vararg{Union{}}}} === Val{Tuple{Missing}}\n \n # issue #36869\n-struct F36869{T, V} <: AbstractArray{Union{T, V}, 1}\n+struct F36869{T, V} <: AbstractVector{Union{T, V}}\n end\n @testintersect(Tuple{Type{T}, AbstractVector{T}} where T,\n                Tuple{Union, F36869{Int64, Missing}},\n@@ -2019,9 +2019,9 @@ end\n     Type{S} where {N, S<:(Base.IteratorsMD.CartesianIndices{N, B} where B<:Tuple{Vararg{Any, N}})})\n \n # issue #39948\n-@testintersect(Tuple{Array{Pair{T, JT} where JT<:Ref{T}, 1} where T, Vector},\n+@testintersect(Tuple{Vector{Pair{T, JT} where JT<:Ref{T}} where T, Vector},\n     Tuple{Vararg{Vector{T}}} where T,\n-    Tuple{Array{Pair{T, JT} where JT<:Ref{T}, 1}, Array{Pair{T, JT} where JT<:Ref{T}, 1}} where T)\n+    Tuple{Vector{Pair{T, JT} where JT<:Ref{T}}, Vector{Pair{T, JT} where JT<:Ref{T}}} where T)\n \n # issue #8915\n struct D8915{T<:Union{Float32,Float64}}\n@@ -2102,8 +2102,8 @@ end\n                Bottom)\n \n # issue #42409\n-@testintersect(Tuple{Type{Pair{_A, S} where S<:AbstractArray{<:_A, 2}}, Dict} where _A,\n-               Tuple{Type{Pair{_A, S} where S<:AbstractArray{<:_A, 2}} where _A, Union{Array, Pair}},\n+@testintersect(Tuple{Type{Pair{_A, S} where S<:AbstractMatrix{<:_A}}, Dict} where _A,\n+               Tuple{Type{Pair{_A, S} where S<:AbstractMatrix{<:_A}} where _A, Union{Array, Pair}},\n                Bottom)\n \n # https://github.com/JuliaLang/julia/issues/44735\n@@ -2494,7 +2494,7 @@ abstract type P47654{A} end\n     @test_broken !(A <: B)\n \n     #issue 35698\n-    @test_broken typeintersect(Type{Tuple{Array{T,1} where T}}, UnionAll) != Union{}\n+    @test_broken typeintersect(Type{Tuple{Vector{T} where T}}, UnionAll) != Union{}\n \n     #issue 33137\n     @test (Tuple{Q,Int} where Q<:Int) <: Tuple{T,T} where T"
    }
  ]
}