{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60373",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60373/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60373/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60373/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60373",
  "id": 3724700112,
  "node_id": "PR_kwDOABkWpM64optu",
  "number": 60373,
  "title": "`Expr`/`SyntaxTree` parity: trivial conversions",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9763847389,
      "node_id": "LA_kwDOABkWpM8AAAACRfh83Q",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/JuliaLowering",
      "name": "JuliaLowering",
      "color": "144fbf",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 3,
  "created_at": "2025-12-12T20:11:04Z",
  "updated_at": "2025-12-24T17:54:45Z",
  "closed_at": "2025-12-16T23:39:38Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60373",
    "html_url": "https://github.com/JuliaLang/julia/pull/60373",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60373.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60373.patch",
    "merged_at": "2025-12-16T23:39:38Z"
  },
  "body": "As discussed on slack with @c42f and @topolarity, I gave expansion-time conversions an honest try, but couldn't see the end of the tunnel in terms of correctness.  The equivalence between SyntaxNode and Expr is only defined on surface syntax or fully-macro-expanded syntax, and not the steps in between, or if errors occur.  We have a plan for syntax evolution now, too, so there compelling reasons not to lump changes to AST layout into JuliaLowering's macro expansion.\r\n\r\nLet `EST` be the \"new\" Expr-like SyntaxTree I'm working on and `CST` be the current SyntaxNode-like version. PRs planned:\r\n1. https://github.com/JuliaLang/julia/pull/60370\r\n2. (this PR) Trivial `EST`<->`Expr` conversion, tested by parsing code in bulk and round-tripping\r\n3. `RawGreenNode`->`EST` (identical logic to existing `RawGreenNode`->`Expr`, and testable with this PR's `Expr`->`EST`)\r\n4. `EST`->`CST*`: This would just be a simplification of our existing `Expr`->`CST`, and prevents us from needing to make huge changes in desugaring (which understands `CST*`).  Macro expansion will become `EST`->`EST` rather than `CST`->`CST*`.\r\n5. Before one or both of the above, I may try and merge a basic SyntaxTree pattern-matching macro so operating on these things is less tedious.  This is already written, but needs tests.\r\n\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60373/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60373/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "3c7e15f619a0da0e2fc76fd309c2f91ffe683013",
      "filename": "JuliaLowering/src/compat.jl",
      "status": "modified",
      "additions": 118,
      "deletions": 0,
      "changes": 118,
      "blob_url": "https://github.com/JuliaLang/julia/blob/88a99778fdfc820b14fc90012b3d1941031cff48/JuliaLowering%2Fsrc%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/88a99778fdfc820b14fc90012b3d1941031cff48/JuliaLowering%2Fsrc%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fcompat.jl?ref=88a99778fdfc820b14fc90012b3d1941031cff48",
      "patch": "@@ -626,3 +626,121 @@ function JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, head::SyntaxHead,\n end\n \n Base.Expr(ex::SyntaxTree) = JuliaSyntax.to_expr(ex)\n+\n+#-------------------------------------------------------------------------------\n+# WIP: Expr<->EST\n+\n+function expr_to_est(@nospecialize(e), lnn::LineNumberNode=LineNumberNode(0, :none))\n+    graph = ensure_attributes!(\n+        SyntaxGraph(),\n+        kind=Kind, syntax_flags=UInt16,\n+        source=SourceAttrType, var_id=Int, value=Any,\n+        name_val=String, is_toplevel_thunk=Bool,\n+        scope_layer=LayerId, meta=CompileHints,\n+        toplevel_pure=Bool)\n+    SyntaxTree(graph, _expr_to_est(graph, e, lnn)[1])\n+end\n+\n+function _get_inner_lnn(e::Expr, default::LineNumberNode)\n+    e.head in (:function, :macro, :module) || return default\n+    length(e.args) >= 2 || return default\n+    b = e.args[end]\n+    b isa Expr && b.head === :block || return default\n+    length(b.args) >= 1 && b.args[1] isa LineNumberNode || return default\n+    return b.args[1]\n+end\n+\n+# List of Expr-AST forms that are always converted to some SyntaxTree form and\n+# never inserted as an opaque `K\"Value\"`. Note no LineNumberNode, which appears\n+# unwrapped in a macrocall (possibly generated functions too, TODO check)\n+isa_lowering_ast_node(@nospecialize(e)) =\n+    e isa Symbol || e isa QuoteNode || e isa Expr # || e isa GlobalRef\n+\n+function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)\n+    st = if e === Core.nothing\n+        # e.value can't be nothing in `K\"Value\"`, so represent with K\"core\"\n+        setattr!(makeleaf(graph, src, K\"core\"), :name_val, \"nothing\")\n+    elseif e isa Symbol\n+        setattr!(makeleaf(graph, src, K\"Identifier\"), :name_val, String(e))\n+    elseif e isa QuoteNode\n+        cid, _ = _expr_to_est(graph, e.value, src)\n+        makenode(graph, src, K\"inert\", NodeId[cid])\n+    elseif e isa Expr && e.head === :scope_layer\n+        @assert length(e.args) === 2 && e.args[1] isa Symbol\n+        ident = makeleaf(graph, src, K\"Identifier\")\n+        setattr!(ident, :name_val, String(e.args[1]))\n+        setattr!(ident, :scope_layer, e.args[2])\n+    elseif e isa Expr\n+        head_s = string(e.head)\n+        st_k = find_kind(head_s)\n+        old_src = _get_inner_lnn(e, src)\n+        cs = NodeId[]\n+        rm_linenodes = e.head in (:block, :toplevel)\n+        for arg in e.args\n+            if rm_linenodes && arg isa LineNumberNode\n+                src = arg\n+            else\n+                cid, src = _expr_to_est(graph, arg, src)\n+                push!(cs, cid)\n+            end\n+        end\n+        if isnothing(st_k)\n+            setattr!(makenode(graph, src, K\"unknown_head\", cs), :name_val, head_s)\n+        else\n+            makenode(graph, old_src, st_k, cs)\n+        end\n+    # elseif e isa GlobalRef\n+        # TODO: Better-behaved as K\"globalref\", but lowering doesn't know this\n+    else\n+        @assert !isa_lowering_ast_node(e)\n+        # We may want additional special cases for other types where\n+        # `Base.isa_ast_node(e)`, but `K\"Value\"` should be fine for most, since\n+        # most are produced in or after lowering\n+        if e isa LineNumberNode\n+            # linenode oustside of block or toplevel\n+            src = e\n+        end\n+        setattr!(makeleaf(graph, src, K\"Value\"), :value, e)\n+    end\n+\n+    return st._id, src\n+end\n+\n+function est_to_expr(st::SyntaxTree)\n+    k = kind(st)\n+    return if k === K\"Identifier\"\n+        n = Symbol(st.name_val)\n+        hasattr(st, :scope_layer) ? Expr(:scope_layer, n, st.scope_layer) : n\n+    elseif k === K\"Value\"\n+        v = st.value\n+        # Let `kind(st) === K\"Value\"` with `st.value isa Symbol` (or other AST\n+        # node).  Since we enforce that this is never produced by the reverse\n+        # Expr->SyntaxTree transformation, there is no lonely Expr for which\n+        # `st` is the only SyntaxTree representation.  This means we can pick\n+        # some other expr this represents, namely Expr(`(inert ,st.value))\n+        # rather than Expr(st.value).\n+        isa_lowering_ast_node(v) ? QuoteNode(v) : v\n+    elseif k === K\"core\" && numchildren(st) === 0 && st.name_val === \"nothing\"\n+        nothing\n+    elseif k === K\"inert\"\n+        QuoteNode(est_to_expr(st[1]))\n+    else\n+        @assert !is_leaf(st)\n+        # In a partially-expanded or quoted AST, there may be heads with no\n+        # corresponding kind\n+        head = Symbol(k === K\"unknown_head\" ? st.name_val : untokenize(k))\n+        need_lnns = head in (:block, :toplevel)\n+        out = Expr(head)\n+        for c in children(st)\n+            need_lnns && push!(out.args, source_location(LineNumberNode, c))\n+            push!(out.args, est_to_expr(c))\n+        end\n+        # extra linenodes\n+        n = length(out.args)\n+        if (k === K\"module\" && 3 <= n <= 4 && kind(st[end]) === K\"block\") ||\n+            (k in KSet\"function macro\" && n === 2 && kind(st[end]) === K\"block\")\n+            pushfirst!(out.args[end].args, source_location(LineNumberNode, st))\n+        end\n+        out\n+    end\n+end"
    },
    {
      "sha": "ef84e0327f8e55310dfa7f2285b9dd803fad9034",
      "filename": "JuliaLowering/src/kinds.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/88a99778fdfc820b14fc90012b3d1941031cff48/JuliaLowering%2Fsrc%2Fkinds.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/88a99778fdfc820b14fc90012b3d1941031cff48/JuliaLowering%2Fsrc%2Fkinds.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fkinds.jl?ref=88a99778fdfc820b14fc90012b3d1941031cff48",
      "patch": "@@ -21,6 +21,7 @@ function _register_kinds()\n             \"Symbol\"\n             # QuoteNode; not quasiquote\n             \"inert\"\n+            \"unknown_head\"\n             # TODO: Use `meta` for inbounds and loopinfo etc?\n             \"inbounds\"\n             \"boundscheck\""
    },
    {
      "sha": "41875e154ae266adacc682310b2e27639c37af2a",
      "filename": "JuliaLowering/test/compat.jl",
      "status": "modified",
      "additions": 142,
      "deletions": 0,
      "changes": 142,
      "blob_url": "https://github.com/JuliaLang/julia/blob/88a99778fdfc820b14fc90012b3d1941031cff48/JuliaLowering%2Ftest%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/88a99778fdfc820b14fc90012b3d1941031cff48/JuliaLowering%2Ftest%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fcompat.jl?ref=88a99778fdfc820b14fc90012b3d1941031cff48",
      "patch": "@@ -632,3 +632,145 @@ const JL = JuliaLowering\n     @test JuliaLowering.expr_to_syntaxtree(Expr(:block, Expr(:softscope, true))) \u2248\n         @ast_ [K\"block\" [K\"softscope\" true::K\"Bool\"]]\n end\n+\n+@testset \"Expr<->EST\" begin\n+\n+    local roundtrip = e->JuliaLowering.est_to_expr(JuliaLowering.expr_to_est(e))\n+    local roundtrip_eq = x->x==roundtrip(x)\n+\n+    local expr_syntax = Any[\n+        LineNumberNode(1)\n+        :foo\n+        Expr(:foo, 1)\n+        GlobalRef(Core, :nothing)\n+        nothing\n+    ]\n+\n+    local expr_wrappers = Function[\n+        identity\n+        x->QuoteNode(x)\n+        x->Expr(:function, x)\n+        x->Expr(:dummy, x)\n+    ]\n+\n+    local st_wrappers = Function[\n+        x->(@assert(!isnothing(x)); @ast _ast_test_graph() @__LINE__() (x::K\"Value\"))\n+        x->(@assert(!isnothing(x)); @ast _ast_test_graph() @__LINE__() [K\"inert\" x::K\"Value\"])\n+        x->(@assert(!isnothing(x)); @ast _ast_test_graph() @__LINE__() [K\"function\" x::K\"Value\"])\n+    ]\n+\n+    @testset \"every basic case\" begin\n+        for e in expr_syntax, w1 in expr_wrappers, w2 in expr_wrappers\n+            e_wrapped = w2(w1(e))\n+            @test roundtrip(e_wrapped) == e_wrapped\n+        end\n+\n+        for e in expr_syntax, st_w in st_wrappers, e_w in expr_wrappers\n+            isnothing(e) && continue\n+            e_wrapped = st_w(e_w(e))\n+            @test roundtrip(e_wrapped) == e_wrapped\n+            e_wrapped = e_w(st_w(e))\n+            @test roundtrip(e_wrapped) == e_wrapped\n+        end\n+    end\n+\n+    @testset \"special cases: Value implicitly quotes AST nodes\" begin\n+        @test JL.est_to_expr(@ast_ :foo::K\"Value\") ==\n+            JL.est_to_expr(@ast_ [K\"inert\" \"foo\"::K\"Identifier\"]) ==\n+            QuoteNode(:foo)\n+        @test JL.est_to_expr(@ast_ Expr(:call, 1)::K\"Value\") ==\n+            JL.est_to_expr(@ast_ [K\"inert\" [K\"call\" 1::K\"Value\"]]) ==\n+            QuoteNode(Expr(:call, 1))\n+        @test JL.est_to_expr(@ast_ QuoteNode(Expr(:call, 1))::K\"Value\") ==\n+            JL.est_to_expr(@ast_ [K\"inert\" [K\"inert\" [K\"call\" 1::K\"Value\"]]]) ==\n+            QuoteNode(QuoteNode(Expr(:call, 1)))\n+    end\n+\n+    # copied from JuliaSyntax/test/parse_packages.jl\n+    function find_source_in_path(basedir)\n+        src_list = String[]\n+        for (root, dirs, files) in walkdir(basedir)\n+            append!(src_list, (joinpath(root, f) for f in files\n+                                   if endswith(f, \".jl\") && (p = joinpath(root,f); !islink(p) && isfile(p))))\n+        end\n+        src_list\n+    end\n+\n+    function find_diff(e1, e2, indices=Int[])\n+        if expr_equal_forgiving(e1, e2)\n+            return nothing\n+        elseif !(e1 isa Expr && e2 isa Expr) ||\n+            e1.head !== e2.head ||\n+            length(e1.args) !== length(e2.args)\n+            return (e1, e2, indices)\n+        else\n+            for i in 1:length(e1.args)\n+                push!(indices, i)\n+                d = find_diff(e1.args[i], e2.args[i], indices)\n+                isnothing(d) || return d\n+                pop!(indices)\n+            end\n+        end\n+    end\n+\n+    function test_each_in_path(f::Function, basedir)\n+        for filepath in find_source_in_path(basedir)\n+            @testset \"$(relpath(filepath, basedir))\" begin\n+                e = try\n+                    JuliaSyntax.parseall(Expr, read(filepath, String))\n+                catch\n+                    continue\n+                end\n+                e2 = f(e)\n+                pass = expr_equal_forgiving(e, e2)\n+                @test pass\n+                if !pass\n+                    (parsed, roundtripped, indices) = find_diff(e, e2)\n+                    @info \"diff:\" outpath parsed roundtripped e e2\n+                end\n+            end\n+        end\n+    end\n+\n+    # ignore_linenums=false is good for checking, but too noisy to use much\n+    function expr_equal_forgiving(e1, e2; ignore_linenums=true)\n+        !(e1 isa Expr && e2 isa Expr) && return e1 == e2\n+        if ignore_linenums\n+            e1, e2 = let e1b = Expr(e1.head), e2b = Expr(e2.head)\n+                e1b.args = filter(x->!(x isa LineNumberNode), e1.args)\n+                e2b.args = filter(x->!(x isa LineNumberNode), e2.args)\n+                e1b, e2b\n+            end\n+        end\n+\n+        e1.head === e2.head && length(e1.args) === length(e2.args) &&\n+            all(expr_equal_forgiving(a1, a2; ignore_linenums) for (a1, a2) in\n+                    zip(e1.args, e2.args))\n+    end\n+\n+    @testset \"bulk parsed code, no linenodes\" begin\n+        jl_dir = joinpath(@__DIR__, \"..\")\n+        test_each_in_path(roundtrip, jl_dir)\n+    end\n+\n+    @testset \"linenodes equal (modules and functions have extra)\" begin\n+        e = JuliaSyntax.parseall(Expr, \"\"\"\n+        module M\n+        function f()\n+            if x\n+                j\n+            elseif y\n+                let\n+                    y\n+                end\n+            end\n+        end\n+        begin\n+            1\n+        end\n+        end\n+        \"\"\"; filename=\"foo\")\n+\n+        @test e == roundtrip(e)\n+    end\n+end"
    }
  ]
}