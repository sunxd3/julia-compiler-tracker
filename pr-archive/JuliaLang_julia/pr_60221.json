{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60221",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60221/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60221/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60221/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60221",
  "id": 3656895507,
  "node_id": "PR_kwDOABkWpM61GDrO",
  "number": 60221,
  "title": "JuliaSyntax: fix anonymous function parsing",
  "user": {
    "login": "IanButterworth",
    "id": 1694067,
    "node_id": "MDQ6VXNlcjE2OTQwNjc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1694067?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/IanButterworth",
    "html_url": "https://github.com/IanButterworth",
    "followers_url": "https://api.github.com/users/IanButterworth/followers",
    "following_url": "https://api.github.com/users/IanButterworth/following{/other_user}",
    "gists_url": "https://api.github.com/users/IanButterworth/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/IanButterworth/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/IanButterworth/subscriptions",
    "organizations_url": "https://api.github.com/users/IanButterworth/orgs",
    "repos_url": "https://api.github.com/users/IanButterworth/repos",
    "events_url": "https://api.github.com/users/IanButterworth/events{/privacy}",
    "received_events_url": "https://api.github.com/users/IanButterworth/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 163368715,
      "node_id": "MDU6TGFiZWwxNjMzNjg3MTU=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/parser",
      "name": "parser",
      "color": "bfdadc",
      "default": false,
      "description": "Language parsing and surface syntax"
    },
    {
      "id": 414648058,
      "node_id": "MDU6TGFiZWw0MTQ2NDgwNTg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/bugfix",
      "name": "bugfix",
      "color": "15ff91",
      "default": false,
      "description": "This change fixes an existing bug"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 6,
  "created_at": "2025-11-24T03:05:09Z",
  "updated_at": "2025-12-19T12:35:29Z",
  "closed_at": "2025-12-19T12:34:45Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60221",
    "html_url": "https://github.com/JuliaLang/julia/pull/60221",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60221.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60221.patch",
    "merged_at": "2025-12-19T12:34:45Z"
  },
  "body": "Fixes https://github.com/JuliaLang/julia/issues/60202\r\n\r\n```\r\njulia> function zip_missing(::Tuple{}, longer)\r\n\t\t      map(function (second_one)\r\n\t\t          (missing, second_one)\r\n\t\t      end, longer)\r\n\t\t  end\r\nzip_missing (generic function with 1 method)\r\n```\r\n\r\nWritten by Claude",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60221/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60221/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "163f811b293565a32a83e81522b4f67e80df3ddf",
      "filename": "JuliaSyntax/src/julia/parser.jl",
      "status": "modified",
      "additions": 17,
      "deletions": 4,
      "changes": 21,
      "blob_url": "https://github.com/JuliaLang/julia/blob/28bf44bd0a9c4d87660e523115705f2e8533a8a0/JuliaSyntax%2Fsrc%2Fjulia%2Fparser.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/28bf44bd0a9c4d87660e523115705f2e8533a8a0/JuliaSyntax%2Fsrc%2Fjulia%2Fparser.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fparser.jl?ref=28bf44bd0a9c4d87660e523115705f2e8533a8a0",
      "patch": "@@ -2218,10 +2218,23 @@ function parse_function_signature(ps::ParseState, is_function::Bool)\n             opts = parse_brackets(ps, K\")\") do had_commas, had_splat, num_semis, num_subexprs\n                 _parsed_call = was_eventually_call(ps)\n                 _maybe_grouping_parens = !had_commas && !had_splat && num_semis == 0 && num_subexprs == 1\n-                # Skip intervening newlines only when the parentheses hold a single\n-                # expression, which is the ambiguous case between a name like (::T)\n-                # and an anonymous function parameter list.\n-                next_kind = peek(ps, 2, skip_newlines=_maybe_grouping_parens)\n+                # Check if there's a newline between `)` and the next `(` or `.`.\n+                # We need to find where `)` is and check what immediately follows it.\n+                # If peek(1, skip_newlines=false) is `)`, we're directly before it.\n+                # Otherwise there's whitespace/newline before `)`.\n+                next_token_pos = if peek(ps, 1, skip_newlines=false) == K\")\"\n+                    # Directly before ), token after ) is at 2\n+                    2\n+                else\n+                    # There's whitespace before ), so ) is at 2\n+                    # and what follows ) is at 3\n+                    3\n+                end\n+                token_after_paren = peek(ps, next_token_pos, skip_newlines=false)\n+                # If token_after_paren is a newline, this is an anonymous function\n+                has_newline_after_paren = _maybe_grouping_parens && token_after_paren == K\"NewlineWs\"\n+                # Get the next significant token to determine if we need to parse a call\n+                next_kind = peek(ps, 2, skip_newlines=_maybe_grouping_parens && !has_newline_after_paren)\n                 _needs_parse_call = next_kind \u2208 KSet\"( .\"\n                 _is_anon_func = (!_needs_parse_call && !_parsed_call) || had_commas\n                 return (needs_parameters      = _is_anon_func,"
    },
    {
      "sha": "a4057ba81a42a5b240379a8a383419c33e8c18a3",
      "filename": "JuliaSyntax/test/parser.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/28bf44bd0a9c4d87660e523115705f2e8533a8a0/JuliaSyntax%2Ftest%2Fparser.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/28bf44bd0a9c4d87660e523115705f2e8533a8a0/JuliaSyntax%2Ftest%2Fparser.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fparser.jl?ref=28bf44bd0a9c4d87660e523115705f2e8533a8a0",
      "patch": "@@ -611,6 +611,8 @@ tests = [\n         \"macro \\$f()    end\"   =>  \"(macro (call (\\$ f)) (block))\"\n         \"macro (\\$f)()  end\"   =>  \"(macro (call (parens (\\$ f))) (block))\"\n         \"function (x) body end\"=>  \"(function (tuple-p x) (block body))\"\n+        \"function (x)\\n    body\\nend\"=>  \"(function (tuple-p x) (block body))\"\n+        \"function (x)\\n() end\" =>  \"(function (tuple-p x) (block (tuple-p)))\"\n         \"function (x,y) end\"   =>  \"(function (tuple-p x y) (block))\"\n         \"function (x,y,) end\"  =>  \"(function (tuple-p-, x y) (block))\"\n         \"function (x=1) end\"   =>  \"(function (tuple-p (= x 1)) (block))\""
    }
  ]
}