{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60254",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60254/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60254/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60254/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60254",
  "id": 3668286910,
  "node_id": "PR_kwDOABkWpM61sNqw",
  "number": 60254,
  "title": "Avoid using `fork()` when probing system `libstdc++`",
  "user": {
    "login": "topolarity",
    "id": 84105208,
    "node_id": "MDQ6VXNlcjg0MTA1MjA4",
    "avatar_url": "https://avatars.githubusercontent.com/u/84105208?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/topolarity",
    "html_url": "https://github.com/topolarity",
    "followers_url": "https://api.github.com/users/topolarity/followers",
    "following_url": "https://api.github.com/users/topolarity/following{/other_user}",
    "gists_url": "https://api.github.com/users/topolarity/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/topolarity/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/topolarity/subscriptions",
    "organizations_url": "https://api.github.com/users/topolarity/orgs",
    "repos_url": "https://api.github.com/users/topolarity/repos",
    "events_url": "https://api.github.com/users/topolarity/events{/privacy}",
    "received_events_url": "https://api.github.com/users/topolarity/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9329042,
      "node_id": "MDU6TGFiZWw5MzI5MDQy",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/system:linux",
      "name": "system:linux",
      "color": "117766",
      "default": false,
      "description": "Affects only Linux"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 2,
  "created_at": "2025-11-26T16:48:53Z",
  "updated_at": "2026-01-09T13:31:58Z",
  "closed_at": "2025-12-03T14:00:59Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60254",
    "html_url": "https://github.com/JuliaLang/julia/pull/60254",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60254.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60254.patch",
    "merged_at": "2025-12-03T14:00:59Z"
  },
  "body": "Somewhat of a companion to https://github.com/JuliaLang/julia/pull/60248.\r\n\r\nFor a small application that has just started up `fork()` is not a huge concern, but it's quite heavy-handed for Julia- as-a-library scenarios where resident memory may already be large. Many soft-embedded targets also do not support fork() well, so it is good for our compatibility to adjust this.\r\n\r\nRather than relying on the linker to do all of the heavy lifting, this changes our `libstdcxx` probe sequence to directly parse the `ld.so.cache` and `libstdc++.so.6` files. As long as we can expect `/etc/ld.so.cache` to be the same path on all Linux systems, this seems to be a reliable way to locate system libraries.\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60254/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60254/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "7e3e5c604c13890df513e69e7858e88ac1e0f4b4",
      "filename": "THIRDPARTY.md",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/THIRDPARTY.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/THIRDPARTY.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/THIRDPARTY.md?ref=6b10c56efaf19dde8b87f2e75ad5093af70ddb54",
      "patch": "@@ -4,6 +4,7 @@ and some utilities (most of the rest of the files in this repository). See below\n for exceptions.\n \n - [crc32c.c](https://stackoverflow.com/questions/17645167/implementing-sse-4-2s-crc32c-in-software) (CRC-32c checksum code by Mark Adler) [[ZLib](https://opensource.org/licenses/Zlib)].\n+- [dl-cache.h](https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html) (for reading ld-cache files on startup) [LGPL2.1+]\n - [LDC](https://github.com/ldc-developers/ldc/blob/master/LICENSE) (for ccall/cfunction ABI definitions) [BSD-3]. The portion of code that Julia uses from LDC is [BSD-3] licensed.\n - [LLVM](https://releases.llvm.org/3.9.0/LICENSE.TXT) (for parts of src/disasm.cpp) [UIUC]\n - [NetBSD](https://www.netbsd.org/about/redistribution.html) (for setjmp, longjmp, and strptime implementations on Windows) [BSD-3]"
    },
    {
      "sha": "4602f759a476858ed3996ccfff81311e2069dae1",
      "filename": "cli/Makefile",
      "status": "modified",
      "additions": 11,
      "deletions": 3,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2FMakefile",
      "raw_url": "https://github.com/JuliaLang/julia/raw/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2FMakefile",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2FMakefile?ref=6b10c56efaf19dde8b87f2e75ad5093af70ddb54",
      "patch": "@@ -5,7 +5,7 @@ include $(JULIAHOME)/Make.inc\n include $(JULIAHOME)/deps/llvm-ver.make\n \n \n-HEADERS := $(addprefix $(SRCDIR)/,jl_exports.h loader.h) $(addprefix $(JULIAHOME)/src/,julia_fasttls.h support/platform.h support/dirpath.h jl_exported_data.inc jl_exported_funcs.inc)\n+HEADERS := $(addprefix $(SRCDIR)/,jl_exports.h loader.h dl-cache.h) $(addprefix $(JULIAHOME)/src/,julia_fasttls.h support/platform.h support/dirpath.h jl_exported_data.inc jl_exported_funcs.inc)\n \n LOADER_CFLAGS = $(JCFLAGS) -I$(BUILDROOT)/src -I$(JULIAHOME)/src -I$(JULIAHOME)/src/support -I$(build_includedir) -ffreestanding\n LOADER_LDFLAGS = $(JLDFLAGS) -ffreestanding -L$(build_shlibdir) -L$(build_libdir)\n@@ -46,8 +46,8 @@ endif # USE_RT_STATIC_LIBSTDCXX\n \n EXE_OBJS := $(BUILDDIR)/loader_exe.o\n EXE_DOBJS := $(BUILDDIR)/loader_exe.dbg.obj\n-LIB_OBJS := $(BUILDDIR)/loader_lib.o\n-LIB_DOBJS := $(BUILDDIR)/loader_lib.dbg.obj\n+LIB_OBJS := $(BUILDDIR)/loader_lib.o $(BUILDDIR)/loader_symbol_probe.o $(BUILDDIR)/loader_library_probe.o\n+LIB_DOBJS := $(BUILDDIR)/loader_lib.dbg.obj $(BUILDDIR)/loader_symbol_probe.dbg.obj $(BUILDDIR)/loader_library_probe.dbg.obj\n \n # If this is an architecture that supports dynamic linking, link in a trampoline definition\n ifneq (,$(wildcard $(SRCDIR)/trampolines/trampolines_$(ARCH).S))\n@@ -71,6 +71,14 @@ $(BUILDDIR)/loader_trampolines.o : $(SRCDIR)/trampolines/trampolines_$(ARCH).S $\n \t@$(call PRINT_CC, $(CC) $(SHIPFLAGS) $(LOADER_CFLAGS) $< -c -o $@)\n $(BUILDDIR)/loader_trampolines.dbg.obj : $(SRCDIR)/trampolines/trampolines_$(ARCH).S $(HEADERS) $(SRCDIR)/trampolines/common.h\n \t@$(call PRINT_CC, $(CC) $(DEBUGFLAGS) $(LOADER_CFLAGS) $< -c -o $@)\n+$(BUILDDIR)/loader_library_probe.o : $(SRCDIR)/loader_library_probe.c $(HEADERS) $(JULIAHOME)/VERSION\n+\t@$(call PRINT_CC, $(CC) -DJL_LIBRARY_EXPORTS $(SHIPFLAGS) $(LOADER_CFLAGS) -c $< -o $@)\n+$(BUILDDIR)/loader_library_probe.dbg.obj : $(SRCDIR)/loader_library_probe.c $(HEADERS) $(JULIAHOME)/VERSION\n+\t@$(call PRINT_CC, $(CC) -DJL_LIBRARY_EXPORTS $(DEBUGFLAGS) $(LOADER_CFLAGS) -c $< -o $@)\n+$(BUILDDIR)/loader_symbol_probe.o : $(SRCDIR)/loader_symbol_probe.c $(HEADERS) $(JULIAHOME)/VERSION\n+\t@$(call PRINT_CC, $(CC) -DJL_LIBRARY_EXPORTS $(SHIPFLAGS) $(LOADER_CFLAGS) -c $< -o $@)\n+$(BUILDDIR)/loader_symbol_probe.dbg.obj : $(SRCDIR)/loader_symbol_probe.c $(HEADERS) $(JULIAHOME)/VERSION\n+\t@$(call PRINT_CC, $(CC) -DJL_LIBRARY_EXPORTS $(DEBUGFLAGS) $(LOADER_CFLAGS) -c $< -o $@)\n \n # Debugging target to help us see what kind of code is being generated for our trampolines\n dump-trampolines: $(SRCDIR)/trampolines/trampolines_$(ARCH).S"
    },
    {
      "sha": "eddaad088e979b92c1511a7f34247f04b26bc2f3",
      "filename": "cli/dl-cache.h",
      "status": "added",
      "additions": 184,
      "deletions": 0,
      "changes": 184,
      "blob_url": "https://github.com/JuliaLang/julia/blob/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2Fdl-cache.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2Fdl-cache.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2Fdl-cache.h?ref=6b10c56efaf19dde8b87f2e75ad5093af70ddb54",
      "patch": "@@ -0,0 +1,184 @@\n+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.\n+   Copyright (C) 1999-2019 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <stdint.h>\n+\n+#define FLAG_ANY                        -1\n+#define FLAG_TYPE_MASK                  0x00ff\n+#define FLAG_LIBC4                      0x0000\n+#define FLAG_ELF                        0x0001\n+#define FLAG_ELF_LIBC5                  0x0002\n+#define FLAG_ELF_LIBC6                  0x0003\n+#define FLAG_REQUIRED_MASK              0xff00\n+#define FLAG_SPARC_LIB64                0x0100\n+#define FLAG_IA64_LIB64                 0x0200\n+#define FLAG_X8664_LIB64                0x0300\n+#define FLAG_S390_LIB64                 0x0400\n+#define FLAG_POWERPC_LIB64              0x0500\n+#define FLAG_MIPS64_LIBN32              0x0600\n+#define FLAG_MIPS64_LIBN64              0x0700\n+#define FLAG_X8664_LIBX32               0x0800\n+#define FLAG_ARM_LIBHF                  0x0900\n+#define FLAG_AARCH64_LIB64              0x0a00\n+#define FLAG_ARM_LIBSF                  0x0b00\n+#define FLAG_MIPS_LIB32_NAN2008         0x0c00\n+#define FLAG_MIPS64_LIBN32_NAN2008      0x0d00\n+#define FLAG_MIPS64_LIBN64_NAN2008      0x0e00\n+#define FLAG_RISCV_FLOAT_ABI_SOFT       0x0f00\n+#define FLAG_RISCV_FLOAT_ABI_DOUBLE     0x1000\n+\n+#if defined(_CPU_X86_64_)\n+\n+#define _DL_CACHE_DEFAULT_ID    0x303\n+#define _dl_cache_check_flags(flags)    ((flags) == _DL_CACHE_DEFAULT_ID)\n+\n+#elif defined(_CPU_AARCH64_)\n+\n+#ifdef __LP64__\n+# define _DL_CACHE_DEFAULT_ID    (FLAG_AARCH64_LIB64 | FLAG_ELF_LIBC6)\n+#else\n+# define _DL_CACHE_DEFAULT_ID    (FLAG_AARCH64_LIB32 | FLAG_ELF_LIBC6)\n+#endif\n+\n+#define _dl_cache_check_flags(flags)    ((flags) == _DL_CACHE_DEFAULT_ID)\n+\n+#elif defined(_CPU_RISCV64_)\n+\n+/* For now we only support the natural XLEN ABI length on all targets, so the\n+   only bits that need to go into ld.so.cache are the flags for ABI length.  */\n+#if defined __riscv_float_abi_double\n+# define _DL_CACHE_DEFAULT_ID    (FLAG_RISCV_FLOAT_ABI_DOUBLE | FLAG_ELF_LIBC6)\n+#else\n+# define _DL_CACHE_DEFAULT_ID    (FLAG_RISCV_FLOAT_ABI_SOFT | FLAG_ELF_LIBC6)\n+#endif\n+\n+#define _dl_cache_check_flags(flags)    ((flags) == _DL_CACHE_DEFAULT_ID)\n+\n+#elif defined(_CPU_ARM_)\n+\n+/* In order to support the transition from unmarked objects\n+   to marked objects we must treat unmarked objects as\n+   compatible with either FLAG_ARM_LIBHF or FLAG_ARM_LIBSF.  */\n+#ifdef __ARM_PCS_VFP\n+# define _dl_cache_check_flags(flags) \\\n+  ((flags) == (FLAG_ARM_LIBHF | FLAG_ELF_LIBC6) \\\n+   || (flags) == FLAG_ELF_LIBC6)\n+#else\n+# define _dl_cache_check_flags(flags) \\\n+  ((flags) == (FLAG_ARM_LIBSF | FLAG_ELF_LIBC6) \\\n+   || (flags) == FLAG_ELF_LIBC6)\n+#endif\n+\n+#elif defined(_CPU_X86_)\n+\n+/* Defined as (FLAG_ELF_LIBC6 | FLAG_X8664_LIBX32).  */\n+#undef _DL_CACHE_DEFAULT_ID\n+#define _DL_CACHE_DEFAULT_ID    0x803\n+\n+#elif defined(_CPU_PPC64_)\n+\n+#define _DL_CACHE_DEFAULT_ID    0x503\n+\n+#define _dl_cache_check_flags(flags)                    \\\n+  ((flags) == _DL_CACHE_DEFAULT_ID)\n+\n+#else\n+\n+#error \"Missing CPU arch-specific definitions in dl-cache.h\"\n+\n+#endif\n+\n+#ifndef _DL_CACHE_DEFAULT_ID\n+# define _DL_CACHE_DEFAULT_ID   3\n+#endif\n+\n+#ifndef _dl_cache_check_flags\n+# define _dl_cache_check_flags(flags)                   \\\n+  ((flags) == 1 || (flags) == _DL_CACHE_DEFAULT_ID)\n+#endif\n+\n+#ifndef LD_SO_CACHE\n+# define LD_SO_CACHE SYSCONFDIR \"/ld.so.cache\"\n+#endif\n+\n+#define CACHEMAGIC \"ld.so-1.7.0\"\n+\n+/* libc5 and glibc 2.0/2.1 use the same format.  For glibc 2.2 another\n+   format has been added in a compatible way:\n+   The beginning of the string table is used for the new table:\n+        old_magic\n+        nlibs\n+        libs[0]\n+        ...\n+        libs[nlibs-1]\n+        pad, new magic needs to be aligned\n+             - this is string[0] for the old format\n+        new magic - this is string[0] for the new format\n+        newnlibs\n+        ...\n+        newlibs[0]\n+        ...\n+        newlibs[newnlibs-1]\n+        string 1\n+        string 2\n+        ...\n+*/\n+struct file_entry\n+{\n+  int flags;            /* This is 1 for an ELF library.  */\n+  unsigned int key, value; /* String table indices.  */\n+};\n+\n+struct cache_file\n+{\n+  char magic[sizeof CACHEMAGIC - 1];\n+  unsigned int nlibs;\n+  struct file_entry libs[0];\n+};\n+\n+#define CACHEMAGIC_NEW \"glibc-ld.so.cache\"\n+#define CACHE_VERSION \"1.1\"\n+#define CACHEMAGIC_VERSION_NEW CACHEMAGIC_NEW CACHE_VERSION\n+\n+\n+struct file_entry_new\n+{\n+  int32_t flags;                /* This is 1 for an ELF library.  */\n+  uint32_t key, value;          /* String table indices.  */\n+  uint32_t osversion;           /* Required OS version.  */\n+  uint64_t hwcap;               /* Hwcap entry.  */\n+};\n+\n+struct cache_file_new\n+{\n+  char magic[sizeof CACHEMAGIC_NEW - 1];\n+  char version[sizeof CACHE_VERSION - 1];\n+  uint32_t nlibs;               /* Number of entries.  */\n+  uint32_t len_strings;         /* Size of string table. */\n+  uint32_t unused[5];           /* Leave space for future extensions\n+                                   and align to 8 byte boundary.  */\n+  struct file_entry_new libs[0]; /* Entries describing libraries.  */\n+  /* After this the string table of size len_strings is found.  */\n+};\n+\n+/* Used to align cache_file_new.  */\n+#define ALIGN_CACHE(addr)                               \\\n+(((addr) + __alignof__ (struct cache_file_new) -1)      \\\n+ & (~(__alignof__ (struct cache_file_new) - 1)))\n+\n+// extern int _dl_cache_libcmp (const char *p1, const char *p2) attribute_hidden;"
    },
    {
      "sha": "62e4f3d3e4b52dba6c611fde8f3e799fac55d948",
      "filename": "cli/loader.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2Floader.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2Floader.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2Floader.h?ref=6b10c56efaf19dde8b87f2e75ad5093af70ddb54",
      "patch": "@@ -70,7 +70,10 @@\n JL_DLLEXPORT extern int jl_load_repl(int, char **);\n JL_DLLEXPORT void jl_loader_print_stderr(const char * msg);\n void jl_loader_print_stderr3(const char * msg1, const char * msg2, const char * msg3);\n+void *jl_loader_open_via_mmap(const char *filepath, size_t *size);\n static void * lookup_symbol(const void * lib_handle, const char * symbol_name);\n+const char *jl_loader_probe_system_library(const char *libname, const char *symbol);\n+int jl_loader_locate_symbol(const char *library, const char *symbol);\n \n #ifdef _OS_WINDOWS_\n LPWSTR *CommandLineToArgv(LPWSTR lpCmdLine, int *pNumArgs);"
    },
    {
      "sha": "78c7d42d9ecc389d82b8d4880024aba6e05ec7d7",
      "filename": "cli/loader_lib.c",
      "status": "modified",
      "additions": 7,
      "deletions": 156,
      "changes": 163,
      "blob_url": "https://github.com/JuliaLang/julia/blob/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2Floader_lib.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2Floader_lib.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2Floader_lib.c?ref=6b10c56efaf19dde8b87f2e75ad5093af70ddb54",
      "patch": "@@ -222,166 +222,17 @@ JL_DLLEXPORT const char * jl_get_libdir()\n #include <link.h>\n #include <sys/wait.h>\n \n-// write(), but handle errors and avoid EINTR\n-static void write_wrapper(int fd, const char *str, size_t len)\n-{\n-    size_t written_sofar = 0;\n-    while (len) {\n-        ssize_t bytes_written = write(fd, str + written_sofar, len);\n-        if (bytes_written == -1 && errno == EINTR) continue;\n-        if (bytes_written == -1 && errno != EINTR) {\n-            perror(\"(julia) child libstdcxxprobe write\");\n-            _exit(1);\n-        }\n-        len -= bytes_written;\n-        written_sofar += bytes_written;\n-    }\n-}\n-\n-// read(), but handle errors and avoid EINTR\n-static void read_wrapper(int fd, char **ret, size_t *ret_len)\n-{\n-    // Allocate an initial buffer\n-    size_t len = JL_PATH_MAX;\n-    char *buf = (char *)malloc(len + 1);\n-    if (!buf) {\n-        perror(\"(julia) malloc\");\n-        exit(1);\n-    }\n-\n-    // Read into it, reallocating as necessary\n-    size_t have_read = 0;\n-    while (1) {\n-        ssize_t n = read(fd, buf + have_read, len - have_read);\n-        if (n == 0) break;\n-        if (n == -1 && errno != EINTR) {\n-            perror(\"(julia) libstdcxxprobe read\");\n-            exit(1);\n-        }\n-        if (n == -1 && errno == EINTR) continue;\n-        have_read += n;\n-        if (have_read == len) {\n-            buf = (char *)realloc(buf, 1 + (len *= 2));\n-            if (!buf) {\n-                perror(\"(julia) realloc\");\n-                exit(1);\n-            }\n-        }\n-    }\n-\n-    *ret = buf;\n-    *ret_len = have_read;\n-}\n-\n // Return the path to the libstdcxx to load.\n // If the path is found, return it.\n // Otherwise, print the error and exit.\n // The path returned must be freed.\n-static char *libstdcxxprobe(void)\n+static const char *libstdcxxprobe(void)\n {\n-    // Create the pipe and child process.\n-    int fork_pipe[2];\n-    int ret = pipe(fork_pipe);\n-    if (ret == -1) {\n-        perror(\"(julia) Error during libstdcxxprobe: pipe\");\n-        exit(1);\n-    }\n-    pid_t pid = fork();\n-    if (pid == -1)  {\n-        perror(\"Error during libstdcxxprobe:\\nfork\");\n-        exit(1);\n-    }\n-    if (pid == (pid_t) 0) { // Child process.\n-        close(fork_pipe[0]);\n-\n-        // Open the first available libstdc++.so.\n-        // If it can't be found, report so by exiting zero.\n-        // The star is there to prevent the compiler from merging constants\n-        // with \"\\0*libstdc++.so.6\", which we string replace inside the .so during\n-        // make install.\n-        void *handle = dlopen(\"libstdc++.so.6\\0*\", RTLD_LAZY);\n-        if (!handle) {\n-            _exit(0);\n-        }\n-\n-        // See if the version is compatible\n-        char *dlerr = dlerror(); // clear out dlerror\n-        void *sym = dlsym(handle, GLIBCXX_LEAST_VERSION_SYMBOL);\n-        (void)sym;\n-        dlerr = dlerror();\n-        if (dlerr) {\n-            // We can't use the library that was found, so don't write anything.\n-            // The main process will see that nothing was written,\n-            // then exit the function and return null.\n-            _exit(0);\n-        }\n-\n-        // No error means the symbol was found, we can use this library.\n-        // Get the path to it, and write it to the parent process.\n-        struct link_map *lm;\n-        ret = dlinfo(handle, RTLD_DI_LINKMAP, &lm);\n-        if (ret == -1) {\n-            char *errbuf = dlerror();\n-            char *errdesc = (char*)\"Error during libstdcxxprobe in child process:\\ndlinfo: \";\n-            write_wrapper(STDERR_FILENO, errdesc, strlen(errdesc));\n-            write_wrapper(STDERR_FILENO, errbuf, strlen(errbuf));\n-            write_wrapper(STDERR_FILENO, \"\\n\", 1);\n-            _exit(1);\n-        }\n-        char *libpath = lm->l_name;\n-        write_wrapper(fork_pipe[1], libpath, strlen(libpath));\n-        _exit(0);\n-    }\n-    else { // Parent process.\n-        close(fork_pipe[1]);\n-\n-        // Read the absolute path to the lib from the child process.\n-        char *path;\n-        size_t pathlen;\n-        read_wrapper(fork_pipe[0], &path, &pathlen);\n-\n-        // Close the read end of the pipe\n-        close(fork_pipe[0]);\n-\n-        // Wait for the child to complete.\n-        while (1) {\n-            int wstatus;\n-            pid_t npid = waitpid(pid, &wstatus, 0);\n-            if (npid == -1) {\n-                if (errno == EINTR) continue;\n-                if (errno == ECHILD) {\n-                    // SIGCHLD is set to SIG_IGN or has flag SA_NOCLDWAIT, so the child\n-                    // did not become a zombie and wait for `waitpid` - it just exited.\n-                    //\n-                    // Assume that it exited successfully and use whatever libpath we\n-                    // got out of the pipe, if any.\n-                    break;\n-                }\n-                perror(\"Error during libstdcxxprobe in parent process:\\nwaitpid\");\n-                exit(1);\n-            }\n-            else if (!WIFEXITED(wstatus)) {\n-                const char *err_str = \"Error during libstdcxxprobe in parent process:\\n\"\n-                                      \"The child process did not exit normally.\\n\";\n-                size_t err_strlen = strlen(err_str);\n-                write_wrapper(STDERR_FILENO, err_str, err_strlen);\n-                exit(1);\n-            }\n-            else if (WEXITSTATUS(wstatus)) {\n-                // The child has printed an error and exited, so the parent should exit too.\n-                exit(1);\n-            }\n-            break;\n-        }\n+    void *handle = dlopen(\"libstdc++.so.6\\0*\", RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD);\n+    if (handle != NULL)\n+        return NULL; // libstdc++ already loaded - nothing we can do\n \n-        if (!pathlen) {\n-            free(path);\n-            return NULL;\n-        }\n-        // Ensure that `path` is zero-terminated.\n-        path[pathlen] = '\\0';\n-        return path;\n-    }\n+    return jl_loader_probe_system_library(\"libstdc++.so.6\", GLIBCXX_LEAST_VERSION_SYMBOL);\n }\n #endif\n \n@@ -480,7 +331,7 @@ __attribute__((constructor)) void jl_load_libjulia_internal(void) {\n                         do_probe = 0;\n                 }\n                 if (do_probe) {\n-                    char *cxxpath = libstdcxxprobe();\n+                    const char *cxxpath = libstdcxxprobe();\n                     if (cxxpath) {\n                         void *cxx_handle = dlopen(cxxpath, RTLD_LAZY);\n                         (void)cxx_handle;\n@@ -490,7 +341,7 @@ __attribute__((constructor)) void jl_load_libjulia_internal(void) {\n                             jl_loader_print_stderr3(\"Message: \", dlr, \"\\n\");\n                             exit(1);\n                         }\n-                        free(cxxpath);\n+                        free((void *)cxxpath);\n                         probe_successful = 1;\n                     }\n                 }"
    },
    {
      "sha": "e9b88b1c3ffb69f6bf6432d7e969a34e5db462f5",
      "filename": "cli/loader_library_probe.c",
      "status": "added",
      "additions": 216,
      "deletions": 0,
      "changes": 216,
      "blob_url": "https://github.com/JuliaLang/julia/blob/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2Floader_library_probe.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2Floader_library_probe.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2Floader_library_probe.c?ref=6b10c56efaf19dde8b87f2e75ad5093af70ddb54",
      "patch": "@@ -0,0 +1,216 @@\n+#include \"../src/support/platform.h\"\n+#include \"loader.h\"\n+\n+#ifdef _OS_LINUX_\n+\n+#include <stdio.h>\n+#include <assert.h>\n+\n+#include <stddef.h>\n+#include <fcntl.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <sys/stat.h>\n+#include <sys/mman.h>\n+#include <linux/limits.h>\n+\n+#include \"dl-cache.h\"\n+\n+void *jl_loader_open_via_mmap(const char *filepath, size_t *size)\n+{\n+    int fd;\n+    while (1) {\n+        fd = open(filepath, O_CLOEXEC | O_RDONLY);\n+        if (fd >= 0) {\n+            break;\n+        } else if (errno != EINTR) {\n+            return NULL;\n+        }\n+    }\n+\n+    struct stat info;\n+    while (1) {\n+        int err = fstat(fd, &info);\n+        if (err >= 0) {\n+            break;\n+        } else if (errno != EINTR) {\n+            close(fd);\n+            return NULL;\n+        }\n+    }\n+\n+    void *buffer = mmap(\n+        NULL, info.st_size, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, fd, /* offset */ 0\n+    );\n+    close(fd);\n+\n+    if (MAP_FAILED == buffer)\n+        return NULL;\n+\n+    *size = info.st_size;\n+    return buffer;\n+}\n+\n+static const char *search_ldcache_new(struct cache_file_new *cache, const char *libname, size_t *index)\n+{\n+    if (strncmp(cache->magic, CACHEMAGIC_NEW, sizeof(CACHEMAGIC_NEW) - 1) != 0)\n+        return NULL;\n+\n+    for (; *index < cache->nlibs; (*index)++) {\n+        struct file_entry_new *lib = &cache->libs[*index];\n+\n+        const char *strtab = (const char *)cache;\n+        const char *key = &strtab[lib->key];\n+        const char *value = &strtab[lib->value];\n+\n+        if (!_dl_cache_check_flags(lib->flags))\n+            continue;\n+        if (strcmp(key, libname) != 0)\n+            continue;\n+        (*index)++;\n+        return value;\n+    }\n+\n+    return NULL;\n+}\n+\n+static const char *search_ldcache(struct cache_file *cache, size_t cachesize, const char *libname, size_t *index)\n+{\n+    if (strncmp(cache->magic, CACHEMAGIC, sizeof(CACHEMAGIC) - 1) != 0)\n+        return search_ldcache_new((struct cache_file_new *)cache, libname, index);\n+\n+    // check for an embedded / hybrid 'new'-style cache\n+    size_t offset = ALIGN_CACHE(sizeof(struct cache_file) + cache->nlibs * sizeof(struct file_entry));\n+    if (cachesize >= offset + sizeof(struct cache_file_new)) {\n+        struct cache_file_new *new_cache = (struct cache_file_new *)((void *)cache + offset);\n+        if (strncmp(new_cache->magic, CACHEMAGIC_NEW, sizeof(CACHEMAGIC_NEW) - 1) == 0)\n+            return search_ldcache_new(new_cache, libname, index);\n+    }\n+\n+    for (; *index < cache->nlibs; (*index)++) {\n+        struct file_entry *lib = &cache->libs[*index];\n+\n+        const char *strtab = (const char *)&cache->libs[cache->nlibs];\n+        const char *key = &strtab[lib->key];\n+        const char *value = &strtab[lib->value];\n+\n+        if (!_dl_cache_check_flags(lib->flags))\n+            continue;\n+        if (strcmp(key, libname) != 0)\n+            continue;\n+        (*index)++;\n+        return value;\n+    }\n+\n+    return NULL;\n+}\n+\n+const char *ldcache_dirs[] = {\n+    \"/etc/ld.so.cache\",\n+};\n+\n+const char *default_libdirs[] = {\n+    \"/lib/\",\n+    \"/usr/lib/\",\n+#ifdef _P64\n+    \"/lib64/\",\n+    \"/usr/lib64/\",\n+#endif\n+};\n+\n+/**\n+ * Search for a system library with the filename `libname` containing `symbol`.\n+ * Return NULL if no matching library could be found.\n+ *\n+ * To emulate the Linux dynamic linker search behavior, this function scans for\n+ * system libraries in:\n+ *   1. LD_LIBRARY_PATH\n+ *   2. `/etc/ld.so.cache`\n+ *   3. \"default\" system libdirs (/lib, /usr/lib, etc.)\n+ *\n+ * This function does not consider any DT_RPATH or DT_RUNPATH entries.\n+ * (see `ld.so(8)` manpage)\n+ **/\n+const char *jl_loader_probe_system_library(const char *libname, const char *symbol)\n+{\n+    char buf[PATH_MAX];\n+\n+    // Make a best-effort attempt to emulate the linker's use of LD_LIBRARY_PATH\n+    char *LD_LIBRARY_PATH = getenv(\"LD_LIBRARY_PATH\");\n+    if (LD_LIBRARY_PATH != NULL) {\n+        LD_LIBRARY_PATH = strdup(LD_LIBRARY_PATH);\n+        char *path = LD_LIBRARY_PATH;\n+\n+        int last = 0;\n+        while (!last) {\n+            // walk to next ':' or '\\0'\n+            char *ch = path;\n+            while (1) {\n+                if (*ch == '\\0')\n+                    last = 1;\n+                if (*ch == ':' || *ch == '\\0')\n+                    break;\n+                ch += 1;\n+            }\n+            *ch = '\\0';\n+\n+            if (ch == path) {\n+                path += 1;\n+                continue;\n+            }\n+\n+            int bytes = snprintf(buf, sizeof(buf), (ch[-1] == '/' ? \"%s%s\" : \"%s/%s\"), path, libname);\n+            path = ch + 1;\n+            if (bytes < 0 || sizeof(buf) < (size_t) bytes)\n+                continue;\n+\n+            if (jl_loader_locate_symbol(buf, symbol)) {\n+                free(LD_LIBRARY_PATH);\n+                return strdup(buf);\n+            }\n+        }\n+        free(LD_LIBRARY_PATH);\n+    }\n+\n+    // Check the ld.so.cache for the library. Assuming we can find the cache,\n+    // this is by far our best chance to locate the lib successfully.\n+    size_t npaths = sizeof(ldcache_dirs) / sizeof(const char *);\n+    for (size_t i = 0; i < npaths; i++) {\n+        size_t sz;\n+        struct cache_file *cache =\n+            (struct cache_file *)jl_loader_open_via_mmap(ldcache_dirs[i], &sz);\n+\n+        if (cache == NULL)\n+            continue; // ld.so.cache was not found (could be NixOS)\n+\n+        size_t iter = 0;\n+        const char *library;\n+        while ((library = search_ldcache(cache, sz, libname, &iter)) != NULL) {\n+            if (jl_loader_locate_symbol(library, symbol)) {\n+                library = strdup(library);\n+                munmap((void *)cache, sz);\n+                return library;\n+            }\n+        }\n+\n+        munmap((void *)cache, sz);\n+    }\n+\n+    // As a last-ditch effort, try to emulate / search the \"default\" libdirs used\n+    // by the GLIBC dynamic linker.\n+    size_t ndirs = sizeof(default_libdirs) / sizeof(const char *);\n+    for (size_t i = 0; i < ndirs; i++) {\n+        int bytes = snprintf(buf, sizeof(buf), \"%s%s\", default_libdirs[i], libname);\n+        if (bytes < 0 || sizeof(buf) < (size_t) bytes)\n+            continue;\n+        if (jl_loader_locate_symbol(buf, symbol))\n+            return strdup(buf);\n+    }\n+\n+    return NULL;\n+}\n+\n+#endif"
    },
    {
      "sha": "de4598eb6a89e2e2f3dd4ef2df842f6ac0664ace",
      "filename": "cli/loader_symbol_probe.c",
      "status": "added",
      "additions": 123,
      "deletions": 0,
      "changes": 123,
      "blob_url": "https://github.com/JuliaLang/julia/blob/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2Floader_symbol_probe.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/6b10c56efaf19dde8b87f2e75ad5093af70ddb54/cli%2Floader_symbol_probe.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2Floader_symbol_probe.c?ref=6b10c56efaf19dde8b87f2e75ad5093af70ddb54",
      "patch": "@@ -0,0 +1,123 @@\n+#include \"../src/support/platform.h\"\n+#include \"loader.h\"\n+\n+#ifdef _OS_LINUX_\n+\n+#include <stdio.h>\n+\n+#include <assert.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string.h>\n+#include <sys/mman.h>\n+#include <linux/elf.h>\n+\n+static Elf64_Shdr *Elf64_get_section(Elf64_Ehdr *hdr, size_t i)\n+{\n+    size_t section_header_sz = hdr->e_shentsize;\n+    size_t byte_offset = hdr->e_shoff + i * section_header_sz;\n+    return (Elf64_Shdr *)&((char *)hdr)[byte_offset];\n+}\n+\n+static const char *Elf64_get_strtab(Elf64_Ehdr *hdr, Elf64_Shdr *section)\n+{\n+    return &((const char *)hdr)[section->sh_offset];\n+}\n+\n+static Elf64_Sym *Elf64_get_symbol(Elf64_Ehdr *hdr, Elf64_Shdr *section, size_t i)\n+{\n+    size_t byte_offset = section->sh_offset + i * section->sh_entsize;\n+    return (Elf64_Sym *)&((char *)hdr)[byte_offset];\n+}\n+\n+static int Elf64_locate_symbol(Elf64_Ehdr *hdr, const char *symbol)\n+{\n+    if (hdr->e_type != ET_DYN)\n+        return 0;\n+\n+    for (size_t sect_idx = 0; sect_idx < hdr->e_shnum; sect_idx++) {\n+        Elf64_Shdr *shdr = Elf64_get_section(hdr, sect_idx);\n+        if (shdr->sh_type != SHT_DYNSYM)\n+            continue;\n+\n+        Elf64_Shdr *strtab_shdr = Elf64_get_section(hdr, shdr->sh_link);\n+        const char *strtab = Elf64_get_strtab(hdr, strtab_shdr);\n+\n+        size_t nsymbols = shdr->sh_size / shdr->sh_entsize;\n+        for (size_t i = 0; i < nsymbols; i++) {\n+            Elf64_Sym *sym = Elf64_get_symbol(hdr, shdr, i);\n+            const char *name = &strtab[sym->st_name];\n+            if (strcmp(name, symbol) == 0)\n+                return 1;\n+        }\n+    }\n+    return 0;\n+}\n+\n+static Elf32_Shdr *Elf32_get_section(Elf32_Ehdr *hdr, size_t i)\n+{\n+    size_t section_header_sz = hdr->e_shentsize;\n+    size_t byte_offset = hdr->e_shoff + i * section_header_sz;\n+    return (Elf32_Shdr *)&((char *)hdr)[byte_offset];\n+}\n+\n+static const char *Elf32_get_strtab(Elf32_Ehdr *hdr, Elf32_Shdr *section)\n+{\n+    return &((const char *)hdr)[section->sh_offset];\n+}\n+\n+static Elf32_Sym *Elf32_get_symbol(Elf32_Ehdr *hdr, Elf32_Shdr *section, size_t i)\n+{\n+    size_t byte_offset = section->sh_offset + i * section->sh_entsize;\n+    return (Elf32_Sym *)&((char *)hdr)[byte_offset];\n+}\n+\n+static int Elf32_locate_symbol(Elf32_Ehdr *hdr, const char *symbol)\n+{\n+    if (hdr->e_type != ET_DYN)\n+        return 0;\n+\n+    for (size_t sect_idx = 0; sect_idx < hdr->e_shnum; sect_idx++) {\n+        Elf32_Shdr *shdr = Elf32_get_section(hdr, sect_idx);\n+        if (shdr->sh_type != SHT_DYNSYM)\n+            continue;\n+\n+        Elf32_Shdr *strtab_shdr = Elf32_get_section(hdr, shdr->sh_link);\n+        const char *strtab = Elf32_get_strtab(hdr, strtab_shdr);\n+\n+        size_t nsymbols = shdr->sh_size / shdr->sh_entsize;\n+        for (size_t i = 0; i < nsymbols; i++) {\n+            Elf32_Sym *sym = Elf32_get_symbol(hdr, shdr, i);\n+            const char *name = &strtab[sym->st_name];\n+            if (strcmp(name, symbol) == 0)\n+                return 1;\n+        }\n+    }\n+    return 0;\n+}\n+\n+int jl_loader_locate_symbol(const char *library, const char *symbol)\n+{\n+    size_t library_sz;\n+    void *elf_file = jl_loader_open_via_mmap(library, &library_sz);\n+    if (elf_file == NULL)\n+        return 0;\n+\n+    int found = 0;\n+    const char *hdr = (const char *)elf_file;\n+    if (strncmp(hdr, ELFMAG, SELFMAG) != 0)\n+        goto bail;\n+\n+    assert(hdr[5] == ELFDATA2LSB);\n+    if (hdr[4] == ELFCLASS32) {\n+        found = Elf32_locate_symbol((Elf32_Ehdr *)hdr, symbol);\n+    } else if (hdr[4] == ELFCLASS64) {\n+        found = Elf64_locate_symbol((Elf64_Ehdr *)hdr, symbol);\n+    }\n+\n+bail:\n+    munmap(elf_file, library_sz);\n+    return found;\n+}\n+\n+#endif"
    }
  ]
}