{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60431",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60431/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60431/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60431/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60431",
  "id": 3748378417,
  "node_id": "PR_kwDOABkWpM653ogo",
  "number": 60431,
  "title": "Document and further clean up node creation functions",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9763847389,
      "node_id": "LA_kwDOABkWpM8AAAACRfh83Q",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/JuliaLowering",
      "name": "JuliaLowering",
      "color": "144fbf",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-12-19T18:17:43Z",
  "updated_at": "2025-12-26T17:21:47Z",
  "closed_at": "2025-12-26T17:19:54Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60431",
    "html_url": "https://github.com/JuliaLang/julia/pull/60431",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60431.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60431.patch",
    "merged_at": "2025-12-26T17:19:54Z"
  },
  "body": "This is cleanup separated from another change where I needed\r\nto call these by hand without `@ast` to help me.\r\n\r\nThe only significant diff is in syntax_graph.jl, where I've addressed a TODO I\r\nleft earlier.  Instead of changing `makenode`/`makeleaf`'s behaviour based on\r\nwhether `proto` is a SyntaxTree or Kind (there isn't any situation where we\r\ndon't know this), split \"new node with kind and provenance\" functions\r\n`newnode`/`newleaf` and \"copy attributes and transform existing node\" functions\r\n`mknode`/`mkleaf`.  I will accept some function name bikeshedding if anyone has\r\nsuggestions.\r\n\r\nOther tweaks:\r\n- Remove the attribute-vector parameter since most of the arbitrary attribute\r\n  stuff happens in `@ast`, where we just produce `setattr!` calls\r\n- Tighten up some signatures, mostly for documentation purposes, and because\r\n  these things are less up-in-the-air than when JL was a new project\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60431/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60431/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "575ee1648dffd8f4aca5aef3c676479301aee9dc",
      "filename": "JuliaLowering/src/JuliaLowering.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2FJuliaLowering.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2FJuliaLowering.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2FJuliaLowering.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -17,10 +17,11 @@ using .JuliaSyntax: highlight, Kind, @KSet_str, is_leaf, children, numchildren,\n     sourcefile, source_location, span, sourcetext, is_literal, is_infix_op_call,\n     is_postfix_op_call, @isexpr, SyntaxHead, is_syntactic_operator,\n     SyntaxGraph, SyntaxTree, SyntaxList, NodeId, SourceRef, SourceAttrType,\n-    ensure_attributes, ensure_attributes!, delete_attributes, newnode!, hasattr,\n+    ensure_attributes, ensure_attributes!, delete_attributes, new_id!, hasattr,\n     setattr, setattr!, syntax_graph, is_compatible_graph,\n     check_compatible_graph, copy_node, copy_ast, provenance, sourceref,\n-    reparent, makeleaf, makenode, mapchildren, mapleaf, flattened_provenance\n+    reparent, mapchildren, flattened_provenance, mkleaf, mknode, newleaf,\n+    newnode, tree_ids\n \n _include(\"kinds.jl\")\n _register_kinds()"
    },
    {
      "sha": "a4840cdfa93af29da2e3225b03df32846ad00d89",
      "filename": "JuliaLowering/src/ast.jl",
      "status": "modified",
      "additions": 34,
      "deletions": 19,
      "changes": 53,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fast.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fast.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fast.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -90,12 +90,14 @@ Lexical scope ID\n \"\"\"\n const ScopeId = Int\n \n-function JuliaSyntax.makeleaf(ctx::AbstractLoweringContext, srcref, proto)\n-    makeleaf(syntax_graph(ctx), srcref, proto)\n+function JuliaSyntax.newleaf(ctx::AbstractLoweringContext,\n+                    prov::Union{SyntaxTree, SourceAttrType},\n+                    k::Kind)\n+    newleaf(syntax_graph(ctx), prov, k)\n end\n \n-function newleaf(ctx, srcref, k::Kind, @nospecialize(value))\n-    leaf = makeleaf(ctx, srcref, k)\n+function JuliaSyntax.newleaf(ctx, prov, k, @nospecialize(value))\n+    leaf = newleaf(ctx, prov, k)\n     if k == K\"Identifier\" || k == K\"core\" || k == K\"top\" || k == K\"Symbol\" ||\n             k == K\"globalref\" || k == K\"Placeholder\"\n         setattr!(leaf._graph, leaf._id, :name_val, value)\n@@ -122,19 +124,21 @@ function newleaf(ctx, srcref, k::Kind, @nospecialize(value))\n     leaf\n end\n \n+JuliaSyntax.newnode(ctx::AbstractLoweringContext,\n+                    prov::Union{SyntaxTree, SourceAttrType},\n+                    k::Kind, cs) =\n+    newnode(syntax_graph(ctx), prov, k, cs)\n+\n # Convenience functions to create leaf nodes referring to identifiers within\n # the Core and Top modules.\n core_ref(ctx, ex, name) = newleaf(ctx, ex, K\"core\", name)\n-svec_type(ctx, ex) = core_ref(ctx, ex, \"svec\")\n nothing_(ctx, ex) = core_ref(ctx, ex, \"nothing\")\n \n-top_ref(ctx, ex, name) = makeleaf(ctx, ex, K\"top\", name)\n-\n # Assign `ex` to an SSA variable.\n # Return (variable, assignment_node)\n function assign_tmp(ctx::AbstractLoweringContext, ex, name=\"tmp\")\n     var = ssavar(ctx, ex, name)\n-    assign_var = makenode(ctx, ex, K\"=\", NodeId[var._id, ex._id])\n+    assign_var = newnode(ctx, ex, K\"=\", tree_ids(var, ex))\n     var, assign_var\n end\n \n@@ -143,24 +147,35 @@ function emit_assign_tmp(stmts::SyntaxList, ctx, ex, name=\"tmp\")\n         return ex\n     end\n     var = ssavar(ctx, ex, name)\n-    push!(stmts, makenode(ctx, ex, K\"=\", NodeId[var._id, ex._id]))\n+    push!(stmts, newnode(ctx, ex, K\"=\", tree_ids(var, ex)))\n     var\n end\n \n #-------------------------------------------------------------------------------\n # @ast macro\n \n-function JuliaSyntax._node_id(graph::SyntaxGraph, ex)\n+_node_id(graph::SyntaxGraph, ex::SyntaxTree) = (check_compatible_graph(graph, ex); ex._id)\n+\n+_node_ids(graph::SyntaxGraph) = ()\n+_node_ids(graph::SyntaxGraph, ::Nothing, cs...) = _node_ids(graph, cs...)\n+_node_ids(graph::SyntaxGraph, c, cs...) = (_node_id(graph, c), _node_ids(graph, cs...)...)\n+_node_ids(graph::SyntaxGraph, cs::SyntaxList, cs1...) = (_node_ids(graph, cs...)..., _node_ids(graph, cs1...)...)\n+function _node_ids(graph::SyntaxGraph, cs::SyntaxList)\n+    check_compatible_graph(graph, cs)\n+    cs.ids\n+end\n+\n+function _node_id(graph::SyntaxGraph, ex)\n     # Fallback to give a comprehensible error message for use with the @ast macro\n     error(\"Attempt to use `$(repr(ex))` of type `$(typeof(ex))` as an AST node. Try annotating with `::K\\\"your_intended_kind\\\"?`\")\n end\n-function JuliaSyntax._node_id(graph::SyntaxGraph, ex::AbstractVector{<:SyntaxTree})\n+function _node_id(graph::SyntaxGraph, ex::AbstractVector{<:SyntaxTree})\n     # Fallback to give a comprehensible error message for use with the @ast macro\n     error(\"Attempt to use vector as an AST node. Did you mean to splat this? (content: `$(repr(ex))`)\")\n end\n \n function _push_nodeid!(graph::SyntaxGraph, ids::Vector{NodeId}, val)\n-    push!(ids, JuliaSyntax._node_id(graph, val))\n+    push!(ids, _node_id(graph, val))\n end\n function _push_nodeid!(graph::SyntaxGraph, ids::Vector{NodeId}, val::Nothing)\n     nothing\n@@ -238,7 +253,7 @@ function _expand_ast_tree(ctx, srcref, tree)\n         # Leaf node with copied attributes\n         kind = esc(tree.args[3])\n         srcref = esc(tree.args[2])\n-        :(mapleaf($ctx, $srcref, $kind))\n+        :(setattr!(mkleaf($srcref), :kind, $kind))\n     elseif Meta.isexpr(tree, (:vcat, :hcat, :vect))\n         # Interior node\n         flatargs = []\n@@ -262,7 +277,7 @@ function _expand_ast_tree(ctx, srcref, tree)\n         end\n         push!(child_stmts, :(child_ids))\n         let (kind, srcref, kws) = _match_kind(srcref, flatargs[1])\n-            n = :(makenode($ctx, $srcref, $kind, $children_ex))\n+            n = :(newnode($ctx, $srcref, $kind, $children_ex))\n             for (attr, val) in kws\n                 n = :(setattr!($n, $attr, $val))\n             end\n@@ -340,7 +355,7 @@ to indicate that the \"primary\" location of the source is the location where\n macro ast(ctx, srcref, tree)\n     quote\n         ctx = $(esc(ctx))\n-        srcref = $(_match_srcref(srcref))\n+        srcref::$SyntaxTree = $(_match_srcref(srcref))\n         $(_expand_ast_tree(:ctx, :srcref, tree))\n     end\n end\n@@ -351,14 +366,14 @@ function set_scope_layer(ctx, ex, layer_id, force)\n     new_layer = force ? layer_id : get(ex, :scope_layer, layer_id)\n \n     ex2 = if k == K\"module\" || k == K\"toplevel\" || k == K\"inert\"\n-        makenode(ctx, ex, ex, children(ex))\n+        mknode(ex, children(ex))\n     elseif k == K\".\"\n-        children = NodeId[set_scope_layer(ctx, ex[1], layer_id, force), ex[2]]\n-        makenode(ctx, ex, ex, children)\n+        cs = tree_ids(set_scope_layer(ctx, ex[1], layer_id, force), ex[2])\n+        mknode(ex, cs)\n     elseif !is_leaf(ex)\n         mapchildren(e->set_scope_layer(ctx, e, layer_id, force), ctx, ex)\n     else\n-        makeleaf(ctx, ex, ex)\n+        mkleaf(ex)\n     end\n     setattr!(ex2, :scope_layer, new_layer)\n end"
    },
    {
      "sha": "34d25503da398f20a12e642952877da20e4de8c2",
      "filename": "JuliaLowering/src/bindings.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 6,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fbindings.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fbindings.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fbindings.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -122,8 +122,7 @@ end\n \n # Create a new SSA binding\n function ssavar(ctx::AbstractLoweringContext, srcref, name=\"tmp\")\n-    nameref = makeleaf(ctx, srcref, K\"Identifier\")\n-    nameref.name_val = name\n+    nameref = newleaf(ctx, srcref, K\"Identifier\", name)\n     binding_ex(ctx, _new_binding(ctx, nameref, name, :local;\n                                  is_ssa=true, is_internal=true))\n end\n@@ -132,8 +131,7 @@ end\n function new_local_binding(ctx::AbstractLoweringContext, srcref, name;\n                            kind=:local, kws...)\n     @assert kind === :local || kind === :argument\n-    nameref = makeleaf(ctx, srcref, K\"Identifier\")\n-    nameref.name_val = name\n+    nameref = newleaf(ctx, srcref, K\"Identifier\", name)\n     b = _new_binding(ctx, nameref, name, kind; is_internal=true, kws...)\n     lbindings = current_lambda_bindings(ctx)\n     if !isnothing(lbindings)\n@@ -143,8 +141,7 @@ function new_local_binding(ctx::AbstractLoweringContext, srcref, name;\n end\n \n function new_global_binding(ctx::AbstractLoweringContext, srcref, name, mod; kws...)\n-    nameref = makeleaf(ctx, srcref, K\"Identifier\")\n-    nameref.name_val = name\n+    nameref = newleaf(ctx, srcref, K\"Identifier\", name)\n     binding_ex(ctx, _new_binding(\n         ctx, nameref, name, :global; is_internal=true, mod=mod, kws...))\n end"
    },
    {
      "sha": "e42ca2df59ccc7227e619b5e4b0dd32231d8a4a7",
      "filename": "JuliaLowering/src/closure_conversion.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fclosure_conversion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fclosure_conversion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fclosure_conversion.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -387,7 +387,7 @@ function _convert_closures(ctx::ClosureConversionCtx, ex)\n             # [K\"assert\" \"toplevel_only\"::K\"Symbol\" [K\"inert\" ex]]\n             make_globaldecl(ctx, ex, binfo.mod, binfo.name, true, _convert_closures(ctx, ex[2]))\n         else\n-            makeleaf(ctx, ex, K\"TOMBSTONE\")\n+            newleaf(ctx, ex, K\"TOMBSTONE\")\n         end\n     elseif k == K\"global\"\n         # Leftover `global` forms become weak globals.\n@@ -409,7 +409,7 @@ function _convert_closures(ctx::ClosureConversionCtx, ex)\n         elseif !binfo.is_always_defined\n             @ast ctx ex [K\"newvar\" var]\n         else\n-            makeleaf(ctx, ex, K\"TOMBSTONE\")\n+            newleaf(ctx, ex, K\"TOMBSTONE\")\n         end\n     elseif k == K\"lambda\"\n         closure_convert_lambda(ctx, ex)\n@@ -592,7 +592,7 @@ function closure_convert_lambda(ctx, ex)\n         push!(lambda_children, _convert_closures(ctx2, ex[4]))\n     end\n \n-    lam = makenode(ctx, ex, ex, lambda_children, [:lambda_bindings=>lambda_bindings])\n+    lam = setattr!(mknode(ex, lambda_children), :lambda_bindings, lambda_bindings)\n     if !isnothing(interpolations) && !isempty(interpolations)\n         @ast ctx ex [K\"call\"\n             replace_captured_locals!::K\"Value\""
    },
    {
      "sha": "0b475355a603719f2b347c487ed4ba8d0afc425a",
      "filename": "JuliaLowering/src/compat.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fcompat.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -2,7 +2,7 @@ const JS = JuliaSyntax\n \n function _insert_tree_node(graph::SyntaxGraph, k::Kind, src::SourceAttrType,\n                            attrs=[], flags::UInt16=0x0000)\n-    id = newnode!(graph)\n+    id = new_id!(graph)\n     setattr!(graph, id, :kind, k)\n     flags !== 0 && setattr!(graph, id, :syntax_flags, flags)\n     setattr!(graph, id, :source, src)\n@@ -659,15 +659,15 @@ isa_lowering_ast_node(@nospecialize(e)) =\n function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)\n     st = if e === Core.nothing\n         # e.value can't be nothing in `K\"Value\"`, so represent with K\"core\"\n-        setattr!(makeleaf(graph, src, K\"core\"), :name_val, \"nothing\")\n+        setattr!(newleaf(graph, src, K\"core\"), :name_val, \"nothing\")\n     elseif e isa Symbol\n-        setattr!(makeleaf(graph, src, K\"Identifier\"), :name_val, String(e))\n+        setattr!(newleaf(graph, src, K\"Identifier\"), :name_val, String(e))\n     elseif e isa QuoteNode\n         cid, _ = _expr_to_est(graph, e.value, src)\n-        makenode(graph, src, K\"inert\", NodeId[cid])\n+        newnode(graph, src, K\"inert\", NodeId[cid])\n     elseif e isa Expr && e.head === :scope_layer\n         @assert length(e.args) === 2 && e.args[1] isa Symbol\n-        ident = makeleaf(graph, src, K\"Identifier\")\n+        ident = newleaf(graph, src, K\"Identifier\")\n         setattr!(ident, :name_val, String(e.args[1]))\n         setattr!(ident, :scope_layer, e.args[2])\n     elseif e isa Expr\n@@ -685,9 +685,9 @@ function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)\n             end\n         end\n         if isnothing(st_k)\n-            setattr!(makenode(graph, src, K\"unknown_head\", cs), :name_val, head_s)\n+            setattr!(newnode(graph, src, K\"unknown_head\", cs), :name_val, head_s)\n         else\n-            makenode(graph, old_src, st_k, cs)\n+            newnode(graph, old_src, st_k, cs)\n         end\n     # elseif e isa GlobalRef\n         # TODO: Better-behaved as K\"globalref\", but lowering doesn't know this\n@@ -700,7 +700,7 @@ function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)\n             # linenode oustside of block or toplevel\n             src = e\n         end\n-        setattr!(makeleaf(graph, src, K\"Value\"), :value, e)\n+        setattr!(newleaf(graph, src, K\"Value\"), :value, e)\n     end\n \n     return st._id, src"
    },
    {
      "sha": "bb468e83679539d5e7b6a798c1e38a93fbf0f2c4",
      "filename": "JuliaLowering/src/desugaring.jl",
      "status": "modified",
      "additions": 11,
      "deletions": 10,
      "changes": 21,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fdesugaring.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -268,7 +268,7 @@ function lower_tuple_assignment(ctx, assignment_srcref, lhss, rhs)\n             [K\"call\" \"getfield\"::K\"core\" tmp i::K\"Integer\"]\n         ])\n     end\n-    makenode(ctx, assignment_srcref, K\"block\", stmts)\n+    newnode(ctx, assignment_srcref, K\"block\", stmts)\n end\n \n # Implement destructuring with `lhs` a tuple expression (possibly with\n@@ -403,7 +403,7 @@ function expand_property_destruct(ctx, ex, is_const)\n         ]))\n     end\n     push!(stmts, @ast ctx rhs1 [K\"removable\" rhs1])\n-    makenode(ctx, ex, K\"block\", stmts)\n+    newnode(ctx, ex, K\"block\", stmts)\n end\n \n # Expands all cases of general tuple destructuring, eg\n@@ -444,7 +444,7 @@ function expand_tuple_destruct(ctx, ex, is_const)\n     end\n     _destructure(ctx, ex, stmts, lhs, rhs1, is_const)\n     push!(stmts, @ast ctx rhs1 [K\"removable\" rhs1])\n-    makenode(ctx, ex, K\"block\", stmts)\n+    newnode(ctx, ex, K\"block\", stmts)\n end\n \n #-------------------------------------------------------------------------------\n@@ -1481,7 +1481,7 @@ function expand_condition(ctx, ex)\n         # jumps rather than first computing a bool and then jumping.\n         cs = expand_cond_children(ctx, test)\n         @assert length(cs) > 1\n-        test = makenode(ctx, test, k, cs)\n+        test = newnode(ctx, test, k, cs)\n     else\n         test = expand_forms_2(ctx, test)\n     end\n@@ -2167,9 +2167,10 @@ function make_lhs_decls(ctx, stmts, declkind, declmeta, ex, type_decls=true)\n         # other Exprs that cannot be produced by the parser (tested by\n         # test/precompile.jl #50538).\n         if !isnothing(declmeta)\n-            push!(stmts, makenode(ctx, ex, declkind, NodeId[ex._id], [:meta=>declmeta]))\n+            push!(stmts, setattr!(newnode(ctx, ex, declkind, tree_ids(ex)),\n+                                  :meta, declmeta))\n         else\n-            push!(stmts, makenode(ctx, ex, declkind, NodeId[ex._id]))\n+            push!(stmts, newnode(ctx, ex, declkind, tree_ids(ex)))\n         end\n     elseif k == K\"Placeholder\"\n         nothing\n@@ -2178,7 +2179,7 @@ function make_lhs_decls(ctx, stmts, declkind, declmeta, ex, type_decls=true)\n             @chk numchildren(ex) == 2\n             name = ex[1]\n             if kind(name) == K\"Identifier\"\n-                push!(stmts, makenode(ctx, ex, K\"decl\", NodeId[name._id, ex[2]._id]))\n+                push!(stmts, newnode(ctx, ex, K\"decl\", tree_ids(name, ex[2])))\n             else\n                 # TODO: Currently, this ignores the LHS in `_::T = val`.\n                 # We should probably do one of the following:\n@@ -2222,7 +2223,7 @@ function expand_decls(ctx, ex)\n             throw(LoweringError(ex, \"invalid syntax in variable declaration\"))\n         end\n     end\n-    makenode(ctx, ex, K\"block\", stmts)\n+    newnode(ctx, ex, K\"block\", stmts)\n end\n \n # Iterate over the variable names assigned to from a \"fancy assignment left hand\n@@ -3352,7 +3353,7 @@ end\n function _make_macro_name(ctx, ex)\n     k = kind(ex)\n     if k == K\"Identifier\" || k == K\"Symbol\"\n-        name = mapleaf(ctx, ex, k)\n+        name = setattr!(mkleaf(ex), :kind, k)\n         name.name_val = \"@$(ex.name_val)\"\n         name\n     elseif is_valid_modref(ex)\n@@ -4422,7 +4423,7 @@ function expand_forms_2(ctx::DesugaringContext, ex::SyntaxTree, docs=nothing)\n         # structure. For now we attribute to the parent node.\n         cond = length(cs) == 2 ?\n             cs[1] :\n-            makenode(ctx, ex, k, cs[1:end-1])\n+            newnode(ctx, ex, k, cs[1:end-1])\n         # This transformation assumes the type assertion `cond::Bool` will be\n         # added by a later compiler pass (currently done in codegen)\n         if k == K\"&&\""
    },
    {
      "sha": "4c9de8cade17fbf26c211fe0bf52f59db650b46d",
      "filename": "JuliaLowering/src/linear_ir.jl",
      "status": "modified",
      "additions": 12,
      "deletions": 11,
      "changes": 23,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Flinear_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Flinear_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Flinear_ir.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -345,7 +345,7 @@ end\n function make_label(ctx, srcref)\n     id = ctx.next_label_id[]\n     ctx.next_label_id[] += 1\n-    makeleaf(ctx, srcref, K\"label\", [:id=>id])\n+    setattr!(newleaf(ctx, srcref, K\"label\"), :id, id)\n end\n \n # flisp: make&mark-label\n@@ -364,7 +364,7 @@ end\n \n function emit_latestworld(ctx, srcref)\n     (isempty(ctx.code) || kind(last(ctx.code)) != K\"latestworld\") &&\n-        emit(ctx, makeleaf(ctx, srcref, K\"latestworld\"))\n+        emit(ctx, newleaf(ctx, srcref, K\"latestworld\"))\n end\n \n function compile_condition_term(ctx, ex)\n@@ -596,7 +596,7 @@ function compile(ctx::LinearIRContext, ex, needs_value, in_tail_pos)\n         nothing\n     elseif k == K\"call\" || k == K\"new\" || k == K\"splatnew\" || k == K\"foreigncall\" ||\n             k == K\"new_opaque_closure\" || k == K\"cfunction\"\n-        callex = makenode(ctx, ex, k, compile_args(ctx, children(ex)))\n+        callex = newnode(ctx, ex, k, compile_args(ctx, children(ex)))\n         if in_tail_pos\n             emit_return(ctx, ex, callex)\n         elseif needs_value\n@@ -687,9 +687,9 @@ function compile(ctx::LinearIRContext, ex, needs_value, in_tail_pos)\n         end\n     elseif k == K\"symbolic_goto\"\n         push!(ctx.symbolic_jump_origins, JumpOrigin(ex, length(ctx.code)+1, ctx))\n-        emit(ctx, makeleaf(ctx, ex, K\"TOMBSTONE\")) # ? pop_exception\n-        emit(ctx, makeleaf(ctx, ex, K\"TOMBSTONE\")) # ? leave\n-        emit(ctx, makeleaf(ctx, ex, K\"TOMBSTONE\")) # ? goto\n+        emit(ctx, newleaf(ctx, ex, K\"TOMBSTONE\")) # ? pop_exception\n+        emit(ctx, newleaf(ctx, ex, K\"TOMBSTONE\")) # ? leave\n+        emit(ctx, newleaf(ctx, ex, K\"TOMBSTONE\")) # ? goto\n         nothing\n     elseif k == K\"return\"\n         compile(ctx, ex[1], true, true)\n@@ -791,7 +791,7 @@ function compile(ctx::LinearIRContext, ex, needs_value, in_tail_pos)\n             emit(ctx, lam)\n         end\n     elseif k == K\"gc_preserve_begin\"\n-        makenode(ctx, ex, k, compile_args(ctx, children(ex)))\n+        newnode(ctx, ex, k, compile_args(ctx, children(ex)))\n     elseif k == K\"gc_preserve_end\" || k == K\"loopinfo\"\n         if needs_value\n             throw(LoweringError(ex, \"misplaced kind $k in value position\"))\n@@ -964,21 +964,22 @@ function _renumber(ctx, ssa_rewrites, slot_rewrites, label_table, ex)\n     if k == K\"BindingId\"\n         id = ex.var_id\n         if haskey(ssa_rewrites, id)\n-            makeleaf(ctx, ex, K\"SSAValue\", [:var_id=>ssa_rewrites[id]])\n+            setattr!(newleaf(ctx, ex, K\"SSAValue\"), :var_id, ssa_rewrites[id])\n         else\n             new_id = get(slot_rewrites, id, nothing)\n             binfo = get_binding(ctx, id)\n             if !isnothing(new_id)\n                 sk = binfo.kind == :local || binfo.kind == :argument ? K\"slot\"             :\n                      binfo.kind == :static_parameter                 ? K\"static_parameter\" :\n                      throw(LoweringError(ex, \"Found unexpected binding of kind $(binfo.kind)\"))\n-                makeleaf(ctx, ex, sk, [:var_id=>new_id])\n+                setattr!(newleaf(ctx, ex, sk), :var_id, new_id)\n             else\n                 if binfo.kind !== :global\n                     throw(LoweringError(ex, \"Found unexpected binding of kind $(binfo.kind)\"))\n                 end\n-                makeleaf(ctx, ex, K\"globalref\",\n-                         [:name_val=>binfo.name, :mod=>binfo.mod])\n+                out = newleaf(ctx, ex, K\"globalref\")\n+                setattr!(out, :name_val, binfo.name)\n+                setattr!(out, :mod, binfo.mod)\n             end\n         end\n     elseif k == K\"meta\" || k == K\"static_eval\""
    },
    {
      "sha": "d19c3f24a6c5d369a66d3ef490405c1be1d2a9a4",
      "filename": "JuliaLowering/src/macro_expansion.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 6,
      "changes": 19,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fmacro_expansion.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -195,7 +195,7 @@ function set_macro_arg_hygiene(ctx, ex, layer_ids, layer_idx)\n     k = kind(ex)\n     scope_layer = get(ex, :scope_layer, layer_ids[layer_idx])\n     if is_leaf(ex)\n-        makeleaf(ctx, ex, ex, [:scope_layer=>scope_layer])\n+        setattr!(copy_node(ex), :scope_layer, scope_layer)\n     else\n         inner_layer_idx = layer_idx\n         if k == K\"escape\"\n@@ -356,19 +356,24 @@ function expand_macro(ctx, ex)\n     return expanded\n end\n \n+_unpack_srcref(graph, srcref::SyntaxTree) = _node_id(graph, srcref)\n+_unpack_srcref(graph, srcref::Tuple)      = _node_ids(graph, srcref...)\n+_unpack_srcref(graph, srcref)             = srcref\n+\n # Add a secondary source of provenance to each expression in the tree `ex`.\n function append_sourceref(ctx, ex, secondary_prov)\n     srcref = (ex, secondary_prov)\n-    if !is_leaf(ex)\n+    out = if !is_leaf(ex)\n         if kind(ex) == K\"macrocall\"\n-            makenode(ctx, srcref, ex, children(ex))\n+            copy_node(ex)\n         else\n             cs = map(e->append_sourceref(ctx, e, secondary_prov)._id, children(ex))\n-            makenode(ctx, srcref, ex, cs)\n+            mknode(ex, cs)\n         end\n     else\n-        makeleaf(ctx, srcref, ex)\n+        copy_node(ex)\n     end\n+    setattr!(out, :source, _unpack_srcref(syntax_graph(ctx), srcref))\n end\n \n function remove_scope_layer!(ex)\n@@ -410,7 +415,9 @@ function expand_forms_1(ctx::MacroExpansionContext, ex::SyntaxTree)\n         else\n             k = all(==('_'), name_str) ? K\"Placeholder\" : K\"Identifier\"\n             scope_layer = get(ex, :scope_layer, current_layer_id(ctx))\n-            makeleaf(ctx, ex, ex, [:kind=>k, :scope_layer=>scope_layer])\n+            out = mkleaf(ex)\n+            setattr!(out, :kind, k)\n+            setattr!(out, :scope_layer, scope_layer)\n         end\n     elseif k == K\"var\" || k == K\"char\" || k == K\"parens\"\n         # Strip \"container\" nodes"
    },
    {
      "sha": "e4fa5d5cb8655694d71ad2503f0ff6f389456da9",
      "filename": "JuliaLowering/src/runtime.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fruntime.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fruntime.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fruntime.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -45,7 +45,7 @@ _numchildren(@nospecialize(ex)) = ex isa Expr ? length(ex.args) : 0\n _syntax_list(ctx::InterpolationContext) = SyntaxList(ctx)\n _syntax_list(ctx::ExprInterpolationContext) = Any[]\n \n-_interp_makenode(ctx::InterpolationContext, ex, args) = makenode(ctx, ex, ex, args)\n+_interp_makenode(ctx::InterpolationContext, ex, args) = mknode(ex, args)\n _interp_makenode(ctx::ExprInterpolationContext, ex, args) = Expr((ex::Expr).head, args...)\n \n _is_leaf(ex::SyntaxTree) = is_leaf(ex)\n@@ -292,7 +292,7 @@ end\n struct GeneratedFunctionStub\n     expr_compat_mode::Bool\n     gen::Function\n-    srcref::Union{SyntaxTree,LineNumberNode,SourceRef}\n+    srcref::Union{LineNumberNode,SourceRef}\n     argnames::Core.SimpleVector\n     spnames::Core.SimpleVector\n end\n@@ -343,7 +343,7 @@ function (g::GeneratedFunctionStub)(world::UInt, source::Method, @nospecialize a\n             ex0 = copy_ast(ctx1, ex0)\n         end\n     else\n-        ex0 = @ast ctx1 g.srcref ex0::K\"Value\"\n+        ex0 = newleaf(syntax_graph(ctx1), g.srcref, K\"Value\", ex0)\n     end\n     # Expand any macros emitted by the generator\n     ex1 = expand_forms_1(ctx1, reparent(ctx1, ex0))"
    },
    {
      "sha": "3f51356edf3da557b62ebbd84cee99a1ad74e32b",
      "filename": "JuliaLowering/src/scope_analysis.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fscope_analysis.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Fsrc%2Fscope_analysis.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fscope_analysis.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -338,7 +338,7 @@ function _resolve_scopes(ctx, ex::SyntaxTree,\n         record_lambda_var!(ctx, scope, get_binding(ctx, ex), capt=true)\n         ex\n     elseif k == K\"softscope\"\n-        makeleaf(ctx, ex, K\"TOMBSTONE\")\n+        newleaf(ctx, ex, K\"TOMBSTONE\")\n     elseif !needs_resolution(ex)\n         ex\n     elseif k == K\"local\"\n@@ -366,7 +366,7 @@ function _resolve_scopes(ctx, ex::SyntaxTree,\n         ex_out\n     elseif k == K\"always_defined\"\n         resolve_name(ctx, ex[1]).is_always_defined = true\n-        makeleaf(ctx, ex, K\"TOMBSTONE\")\n+        newleaf(ctx, ex, K\"TOMBSTONE\")\n     elseif k == K\"lambda\"\n         newscope = enter_scope!(ctx, ex)\n         arg_bindings = _resolve_scopes(ctx, ex[1], newscope)\n@@ -452,7 +452,7 @@ function _resolve_scopes(ctx, ex::SyntaxTree,\n                 end\n             end\n             push!(stmts, locals_dict)\n-            makenode(ctx, ex, K\"block\", stmts)\n+            newnode(ctx, ex, K\"block\", stmts)\n         end\n     elseif k == K\"assert\"\n         etype = extension_type(ex)\n@@ -476,7 +476,7 @@ function _resolve_scopes(ctx, ex::SyntaxTree,\n         else\n             throw(LoweringError(ex, \"Unknown syntax assertion\"))\n         end\n-        makeleaf(ctx, ex, K\"TOMBSTONE\")\n+        newleaf(ctx, ex, K\"TOMBSTONE\")\n     elseif k == K\"function_decl\"\n         resolved = mapchildren(e->_resolve_scopes(ctx, e, scope), ctx, ex)\n         name = resolved[1]"
    },
    {
      "sha": "13e12e881ef426169eb8e6813c604ae1b2228d9d",
      "filename": "JuliaLowering/test/compat.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Ftest%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Ftest%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fcompat.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -662,10 +662,12 @@ end\n         x->Expr(:dummy, x)\n     ]\n \n+    # TODO: `@ast_` escaping is broken\n+    unused = JuliaSyntax.parsestmt(JuliaSyntax.SyntaxTree, \"foo\")\n     local st_wrappers = Function[\n-        x->(@assert(!isnothing(x)); @ast _ast_test_graph() @__LINE__() (x::K\"Value\"))\n-        x->(@assert(!isnothing(x)); @ast _ast_test_graph() @__LINE__() [K\"inert\" x::K\"Value\"])\n-        x->(@assert(!isnothing(x)); @ast _ast_test_graph() @__LINE__() [K\"function\" x::K\"Value\"])\n+        x->(@assert(!isnothing(x)); @ast unused._graph unused (x::K\"Value\"))\n+        x->(@assert(!isnothing(x)); @ast unused._graph unused [K\"inert\" x::K\"Value\"])\n+        x->(@assert(!isnothing(x)); @ast unused._graph unused [K\"function\" x::K\"Value\"])\n     ]\n \n     @testset \"every basic case\" begin"
    },
    {
      "sha": "1cc562c9c588227729b858308e254e7febf4e856",
      "filename": "JuliaLowering/test/macros.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Ftest%2Fmacros.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Ftest%2Fmacros.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmacros.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -498,7 +498,7 @@ end\n             $init\n             ($y, x)\n         end)\n-        @ast q q [K\"inert\" q]\n+        @ast q._graph q [K\"inert\" q]\n     end\n     \"\"\")\n     code = JuliaLowering.include_string(test_mod, \"\"\"@make_quoted_code(x=\"outer x\", x)\"\"\")"
    },
    {
      "sha": "448b0b02abed6e1d2006881920e5ede53e5ff7de",
      "filename": "JuliaLowering/test/scopes.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Ftest%2Fscopes.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Ftest%2Fscopes.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fscopes.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -149,7 +149,8 @@ end\n     function wrapscope(ex, scope_type)\n         g = JuliaLowering.ensure_attributes(ex._graph, scope_type=Symbol)\n         ex = JuliaLowering.reparent(g, ex)\n-        makenode(g, ex, K\"scope_block\", [ex._id], [:scope_type=>scope_type])\n+        out = JuliaLowering.newnode(g, ex, K\"scope_block\", [ex._id])\n+        setattr!(out, :scope_type, scope_type)\n     end\n     function use_soft(ex::SyntaxTree)\n         @ast ex._graph ex [K\"block\" (::K\"softscope\") ex]"
    },
    {
      "sha": "3545db1c8578702b8257ec77ae260c68759eff92",
      "filename": "JuliaLowering/test/utils.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Ftest%2Futils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering%2Ftest%2Futils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Futils.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -15,10 +15,9 @@ import REPL\n using .JuliaSyntax: sourcetext, set_numeric_flags\n \n using .JuliaLowering:\n-    SyntaxGraph, newnode!, ensure_attributes!,\n+    SyntaxGraph, new_id!, ensure_attributes!,\n     Kind, SourceRef, SyntaxTree, NodeId,\n-    makenode, makeleaf, setattr!,\n-    is_leaf, numchildren, children,\n+    setattr!, is_leaf, numchildren, children,\n     @ast, flattened_provenance, showprov, LoweringError, MacroExpansionError,\n     syntax_graph, Bindings, ScopeLayer, mapchildren\n \n@@ -32,7 +31,7 @@ function _ast_test_graph()\n end\n \n function _source_node(graph, src)\n-    id = newnode!(graph)\n+    id = new_id!(graph)\n     setattr!(graph, id, :kind, K\"None\")\n     setattr!(graph, id, :source, src)\n     SyntaxTree(graph, id)"
    },
    {
      "sha": "5766f9108e132e3eb2447a7c5b3abb587e13b314",
      "filename": "JuliaSyntax/src/porcelain/syntax_graph.jl",
      "status": "modified",
      "additions": 57,
      "deletions": 62,
      "changes": 119,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl?ref=7b92a2aa070bb4a15f9ec71292770737718206da",
      "patch": "@@ -94,7 +94,7 @@ function delete_attributes(graph::SyntaxGraph{<:NamedTuple}, attr_names::Symbol.\n     freeze_attrs(g)\n end\n \n-function newnode!(graph::SyntaxGraph)\n+function new_id!(graph::SyntaxGraph)\n     push!(graph.edge_ranges, 0:-1) # Invalid range start => leaf node\n     return length(graph.edge_ranges)\n end\n@@ -261,7 +261,7 @@ end\n \n function copy_node(ex::SyntaxTree)\n     graph = syntax_graph(ex)\n-    id = newnode!(graph)\n+    id = new_id!(graph)\n     if !is_leaf(ex)\n         setchildren!(graph, id, children(ex._graph, ex._id))\n     end\n@@ -460,6 +460,8 @@ end\n SyntaxList(graph::SyntaxGraph) = SyntaxList(graph, Vector{NodeId}())\n SyntaxList(ctx) = SyntaxList(syntax_graph(ctx))\n \n+tree_ids(sts::SyntaxTree...) = NodeId[st._id for st in sts]\n+\n syntax_graph(lst::SyntaxList) = lst.graph\n \n setchildren!(graph::SyntaxGraph, id::NodeId, children::SyntaxList) =\n@@ -523,6 +525,10 @@ function Base.pop!(v::SyntaxList)\n     SyntaxTree(v.graph, pop!(v.ids))\n end\n \n+function Base.popat!(v::SyntaxList, i::Integer)\n+    SyntaxTree(v.graph, popat!(v.ids, i))\n+end\n+\n function Base.resize!(v::SyntaxList, n)\n     resize!(v.ids, n)\n     v\n@@ -568,57 +574,45 @@ end\n #-------------------------------------------------------------------------------\n # AST creation utilities\n \n-# TODO: \"proto\", if SyntaxTree, is rarely different from srcref. reorganize to:\n-# newnode/newleaf(ctx, srcref, k::Kind[, attrs])\n-# makenode/makeleaf(ctx, old::SyntaxTree[, attrs])\n-\n-_node_id(graph::SyntaxGraph, ex::SyntaxTree) = (check_compatible_graph(graph, ex); ex._id)\n+\"\"\"\n+    newnode(graph::SyntaxGraph, prov::SourceAttrType, k::Kind, children)\n \n-_node_ids(graph::SyntaxGraph) = ()\n-_node_ids(graph::SyntaxGraph, ::Nothing, cs...) = _node_ids(graph, cs...)\n-_node_ids(graph::SyntaxGraph, c, cs...) = (_node_id(graph, c), _node_ids(graph, cs...)...)\n-_node_ids(graph::SyntaxGraph, cs::SyntaxList, cs1...) = (_node_ids(graph, cs...)..., _node_ids(graph, cs1...)...)\n-function _node_ids(graph::SyntaxGraph, cs::SyntaxList)\n-    check_compatible_graph(graph, cs)\n-    cs.ids\n+Add a new node to `graph` with reference to parsed source text `prov`.\n+\"\"\"\n+function newnode(graph::SyntaxGraph, prov::SourceAttrType, k::Kind, children)\n+    st = newleaf(graph, prov, k)\n+    setchildren!(graph, st._id, children)\n+    return st\n+end\n+function newleaf(graph::SyntaxGraph, prov::SourceAttrType, k::Kind)\n+    st = SyntaxTree(graph, new_id!(graph))\n+    setattr!(st, :kind, k)\n+    setattr!(st, :source, prov)\n end\n \n-_unpack_srcref(graph, srcref::SyntaxTree) = _node_id(graph, srcref)\n-_unpack_srcref(graph, srcref::Tuple)      = _node_ids(graph, srcref...)\n-_unpack_srcref(graph, srcref)             = srcref\n+newnode(graph::SyntaxGraph, prov::SyntaxTree, k::Kind, children) =\n+    newnode(graph, prov._id, k, children)\n \n-function makeleaf(graph::SyntaxGraph, srcref, proto::Union{Kind, SyntaxTree})\n-    id = newnode!(graph)\n-    ex = SyntaxTree(graph, id)\n-    copy_attrs!(ex, proto, true)\n-    ex.source = _unpack_srcref(graph, srcref)\n-    return ex\n-end\n+newleaf(graph::SyntaxGraph, prov::SyntaxTree, k::Kind) =\n+    newleaf(graph, prov._id, k)\n \n-function makeleaf(ctx, srcref, proto, @nospecialize(attrs::AbstractVector))\n-    graph = syntax_graph(ctx)\n-    ex = makeleaf(graph, srcref, proto)\n-    for (k, v) in attrs\n-        setattr!(graph, ex._id, k, v)\n-    end\n-    return ex\n-end\n+\"\"\"\n+    mknode(old::SyntaxTree, children)\n \n-function makenode(ctx, srcref, proto, children, attrs=nothing)\n-    graph = syntax_graph(ctx)\n-    ex = isnothing(attrs) ? makeleaf(graph, srcref, proto) :\n-        makeleaf(graph, srcref, proto, attrs)\n-    setchildren!(graph, ex._id, children isa SyntaxList ? children.ids : children)\n-    return ex\n-end\n-\n-# TODO: Replace this with makeleaf variant?\n-function mapleaf(ctx, src, kind)\n-    ex = makeleaf(syntax_graph(ctx), src, kind)\n-    # TODO: Value coercion might be broken here due to use of `name_val` vs\n-    # `value` vs ... ?\n-    copy_attrs!(ex, src)\n-    ex\n+Create a node in `old`'s graph that is an immutable update of `old`, but setting\n+`old` as its provenance.  This is the main operation used by syntax\n+transformations such as lowering.\n+\"\"\"\n+function mknode(old::SyntaxTree, children)\n+    st = mkleaf(old)\n+    setchildren!(st._graph, st._id, children)\n+    return st\n+end\n+function mkleaf(old::SyntaxTree)\n+    graph = syntax_graph(old)\n+    st = SyntaxTree(graph, new_id!(graph))\n+    copy_attrs!(st, old, true)\n+    setattr!(st, :source, old._id)\n end\n \n #-------------------------------------------------------------------------------\n@@ -667,7 +661,7 @@ function mapchildren(f::Function, ctx, ex::SyntaxTree, do_map_child::Function)\n         return ex\n     end\n     cs::SyntaxList\n-    ex2 = makenode(ctx, ex, ex, cs)\n+    ex2 = mknode(ex, cs)\n     return ex2\n end\n \n@@ -711,7 +705,7 @@ function _copy_ast(graph2::SyntaxGraph, graph1::SyntaxGraph,\n     let copied = get(seen, id1, nothing)\n         isnothing(copied) || return copied\n     end\n-    id2 = newnode!(graph2)\n+    id2 = new_id!(graph2)\n     seen[id1] = id2\n     src1 = get(SyntaxTree(graph1, id1), :source, nothing)\n     src2 = if !copy_source\n@@ -751,9 +745,10 @@ function build_tree(::Type{SyntaxTree}, stream::ParseStream;\n     end\n     # There may be multiple non-trivia toplevel nodes (e.g. parse error)\n     length(cs) === 1 && return only(cs)\n-    id = newnode!(graph)\n+    id = new_id!(graph)\n     setchildren!(graph, id, reverse(cs).ids)\n-    setattr!(graph, id; source, kind=K\"wrapper\")\n+    setattr!(graph, id, :source, source)\n+    setattr!(graph, id, :kind, K\"wrapper\")\n     return SyntaxTree(graph, id)\n end\n \n@@ -775,7 +770,7 @@ end\n function _insert_green(graph::SyntaxGraph, sf::SourceFile,\n                        txtbuf::Vector{UInt8}, offset::Int,\n                        cursor::RedTreeCursor)\n-    id = newnode!(graph)\n+    id = new_id!(graph)\n     setattr!(graph, id, :kind, kind(cursor))\n     setattr!(graph, id, :syntax_flags, flags(cursor))\n     setattr!(graph, id, :source, SourceRef(sf, first_byte(cursor), last_byte(cursor)))\n@@ -812,45 +807,45 @@ function _green_to_ast(parent::Kind, ex::SyntaxTree; eq_to_kw=false)\n             c2 = _green_to_ast(k, c; eq_to_kw=length(cs)>0)\n             !isnothing(c2) && push!(cs, c2)\n         end\n-        makenode(graph, ex, ex, cs)\n+        mknode(ex, cs)\n     elseif k === K\"parameters\"\n         eq_to_kw = parent != K\"vect\"   && parent != K\"curly\" &&\n                    parent != K\"braces\" && parent != K\"ref\"\n-        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex); eq_to_kw))\n+        mknode(ex, _map_green_to_ast(k, children(ex); eq_to_kw))\n     elseif k === K\"parens\"\n         cs = _map_green_to_ast(parent, children(ex); eq_to_kw)\n-        length(cs) === 1 ? cs[1] : makenode(graph, ex, ex, cs)\n+        length(cs) === 1 ? cs[1] : mknode(ex, cs)\n     elseif k in KSet\"var char\"\n         cs = _map_green_to_ast(parent, children(ex))\n-        length(cs) === 1 ? cs[1] : makenode(graph, ex, ex, cs)\n+        length(cs) === 1 ? cs[1] : mknode(ex, cs)\n     elseif k === K\"=\" && eq_to_kw\n-        setattr!(makenode(graph, ex, ex, _map_green_to_ast(k, children(ex))),\n+        setattr!(mknode(ex, _map_green_to_ast(k, children(ex))),\n                  :kind, K\"kw\")\n     elseif k === K\"CmdMacroName\" || k === K\"StrMacroName\"\n         name = lower_identifier_name(ex.name_val, k)\n-        setattr!(makeleaf(graph, ex, K\"Identifier\"),\n+        setattr!(newleaf(graph, ex, K\"Identifier\"),\n                  :name_val, name)\n     elseif k === K\"macro_name\"\n         # M.@x parses to (. M (macro_name x))\n         # @M.x parses to (macro_name (. M x))\n         # We want (. M @x) (both identifiers) in either case\n         cs = _map_green_to_ast(k, children(ex))\n         if length(cs) !== 1 || !(kind(cs[1]) in KSet\". Identifier\")\n-            return makenode(graph, ex, ex, cs)\n+            return mknode(ex, cs)\n         end\n         id = cs[1]\n         mname_raw = (kind(id) === K\".\" ? id[2] : id).name_val\n-        mac_id = setattr!(makeleaf(graph, ex, K\"Identifier\"), :name_val,\n+        mac_id = setattr!(newleaf(graph, ex, K\"Identifier\"), :name_val,\n                           lower_identifier_name(mname_raw, K\"macro_name\"))\n         if kind(id) === K\".\"\n-            makenode(graph, ex, ex, NodeId[id[1]._id, mac_id._id])\n+            mknode(ex, tree_ids(id[1], mac_id))\n         else\n             mac_id\n         end\n     elseif is_leaf(ex)\n         return ex\n     else\n-        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex)))\n+        mknode(ex, _map_green_to_ast(k, children(ex)))\n     end\n end\n "
    }
  ]
}