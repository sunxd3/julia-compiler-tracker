{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59877",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59877/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59877/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59877/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59877",
  "id": 3526896657,
  "node_id": "PR_kwDOABkWpM6uWcvi",
  "number": 59877,
  "title": "[Profile] further improvements for Windows-only",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 5669611,
      "node_id": "MDU6TGFiZWw1NjY5NjEx",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/system:windows",
      "name": "system:windows",
      "color": "0b02e1",
      "default": false,
      "description": "Affects only Windows"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 3,
  "created_at": "2025-10-17T17:09:43Z",
  "updated_at": "2025-10-18T06:17:20Z",
  "closed_at": "2025-10-18T01:19:06Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59877",
    "html_url": "https://github.com/JuliaLang/julia/pull/59877",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59877.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59877.patch",
    "merged_at": "2025-10-18T01:19:06Z"
  },
  "body": "- Instead of preventing profiling entirely (which might deadlock if DllInit accesses Julia in any way), use a suggestion by @gbaraldi to abort the profile if it takes too long (100ms), allowing the stopped thread to release any locks and free up both threads to continue all. Many, many other projects have encountered this same bug, including dotNet (closed as won't fix) and Firefox (uses a single stepping debugger to find the memory address of the offending locks), but those seem difficult responses for us.\r\n- Define correct ordering for taking profile-related locks\r\n- Profile all threads instead of just main thread\r\n- Refactor needsSymRefreshModuleList to use a modern API for doing so reliably. The API does not appear to implement the documented behaviors, but it seems to do what we need.\r\n- Make stack unwinding on Windows thread-safe so that using multiple threads that throw exceptions won't cause memory corruption anymore\r\n- Use condition variables for correctly controlling profiler start/stop, instead of volatile",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59877/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59877/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "b5cbe68c4643508d7e4ac9daf2d6cae451fc5a2e",
      "filename": "doc/src/devdocs/locks.md",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/21fade478f774a524dbe0d81337810baaac1e33f/doc%2Fsrc%2Fdevdocs%2Flocks.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/21fade478f774a524dbe0d81337810baaac1e33f/doc%2Fsrc%2Fdevdocs%2Flocks.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fdevdocs%2Flocks.md?ref=21fade478f774a524dbe0d81337810baaac1e33f",
      "patch": "@@ -51,12 +51,11 @@ exception frames, and taking/releasing locks.\n       `jl_ast_context_list_t` pool.  Likewise, the `ResourcePool<?>::mutexes`\n       just protect the associated resource pool.\n \n-* `jl_in_stackwalk` (`uv_mutex_t`, Win32 only)\n * `ResourcePool<?>.mutex` (`std::mutex`)\n * `RLST_mutex` (`std::mutex`)\n * `llvm_printing_mutex` (`std::mutex`)\n * `jl_locked_stream.mutex` (`std::mutex`)\n-* `debuginfo_asyncsafe` (`uv_rwlock_t`)\n+* `debuginfo_asyncsafe` (`uv_rwlock_t`) (can still acquire `jl_in_stackwalk` (`uv_mutex_t`, Win32 only))\n * `profile_show_peek_cond_lock` (`jl_mutex_t`)\n * `trampoline_lock` (`uv_mutex_t`)\n * `bt_data_prof_lock` (`uv_mutex_t`)"
    },
    {
      "sha": "c0f8c0d58838eb6922af455bf36f3d603a7da116",
      "filename": "src/debuginfo.cpp",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fdebuginfo.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fdebuginfo.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fdebuginfo.cpp?ref=21fade478f774a524dbe0d81337810baaac1e33f",
      "patch": "@@ -1076,7 +1076,6 @@ bool jl_dylib_DI_for_fptr(size_t pointer, object::SectionRef *Section, int64_t *\n     IMAGEHLP_MODULE64 ModuleInfo;\n     ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE64);\n     uv_mutex_lock(&jl_in_stackwalk);\n-    jl_refresh_dbg_module_list();\n     bool isvalid = SymGetModuleInfo64(GetCurrentProcess(), (DWORD64)pointer, &ModuleInfo);\n     uv_mutex_unlock(&jl_in_stackwalk);\n     if (!isvalid)\n@@ -1178,7 +1177,6 @@ static int jl_getDylibFunctionInfo(jl_frame_t **frames, size_t pointer, int skip\n     static IMAGEHLP_LINE64 frame_info_line;\n     DWORD dwDisplacement = 0;\n     uv_mutex_lock(&jl_in_stackwalk);\n-    jl_refresh_dbg_module_list();\n     DWORD64 dwAddress = pointer;\n     frame_info_line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n     if (SymGetLineFromAddr64(GetCurrentProcess(), dwAddress, &dwDisplacement, &frame_info_line)) {"
    },
    {
      "sha": "cc3bc4e73043a9710d150c7f81061cd6902e96df",
      "filename": "src/dlload.c",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fdlload.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fdlload.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fdlload.c?ref=21fade478f774a524dbe0d81337810baaac1e33f",
      "patch": "@@ -162,8 +162,6 @@ JL_DLLEXPORT void *jl_dlopen(const char *filename, unsigned flags) JL_NOTSAFEPOI\n     }\n     else {\n         lib = LoadLibraryExW(wfilename, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n-        if (lib)\n-            needsSymRefreshModuleList = 1;\n     }\n     return lib;\n }"
    },
    {
      "sha": "bb26eed00e94b882c4037303d420a9ccd1154596",
      "filename": "src/init.c",
      "status": "modified",
      "additions": 6,
      "deletions": 12,
      "changes": 18,
      "blob_url": "https://github.com/JuliaLang/julia/blob/21fade478f774a524dbe0d81337810baaac1e33f/src%2Finit.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/21fade478f774a524dbe0d81337810baaac1e33f/src%2Finit.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Finit.c?ref=21fade478f774a524dbe0d81337810baaac1e33f",
      "patch": "@@ -37,8 +37,8 @@ extern \"C\" {\n #endif\n \n #ifdef _OS_WINDOWS_\n-extern int needsSymRefreshModuleList;\n-extern BOOL (WINAPI *hSymRefreshModuleList)(HANDLE);\n+extern void jl_init_stackwalk(void);\n+extern void jl_fin_stackwalk(void);\n #else\n #include <sys/resource.h>\n #include <unistd.h>\n@@ -349,6 +349,9 @@ JL_DLLEXPORT void jl_atexit_hook(int exitcode) JL_NOTSAFEPOINT_ENTER\n     jl_print_timings();\n #endif\n     jl_teardown_codegen(); // prints stats\n+#ifdef _OS_WINDOWS_\n+    jl_fin_stackwalk();\n+#endif\n }\n \n JL_DLLEXPORT void jl_postoutput_hook(void)\n@@ -685,12 +688,7 @@ JL_DLLEXPORT void jl_init_(jl_image_buf_t sysimage)\n     // initialize backtraces\n     jl_init_profile_lock();\n #ifdef _OS_WINDOWS_\n-    uv_mutex_init(&jl_in_stackwalk);\n-    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES | SYMOPT_IGNORE_CVREC);\n-    if (!SymInitialize(GetCurrentProcess(), \"\", 1)) {\n-        jl_safe_printf(\"WARNING: failed to initialize stack walk info\\n\");\n-    }\n-    needsSymRefreshModuleList = 0;\n+    jl_init_stackwalk();\n #else\n     // nongnu libunwind initialization is only threadsafe on architecture where the\n     // author could access TSAN, per https://github.com/libunwind/libunwind/pull/109\n@@ -736,10 +734,6 @@ JL_DLLEXPORT void jl_init_(jl_image_buf_t sysimage)\n     jl_kernel32_handle = jl_dlopen(\"kernel32.dll\", JL_RTLD_NOLOAD);\n     jl_crtdll_handle = jl_dlopen(jl_crtdll_name, JL_RTLD_NOLOAD);\n     jl_winsock_handle = jl_dlopen(\"ws2_32.dll\", JL_RTLD_NOLOAD);\n-    HMODULE jl_dbghelp = (HMODULE) jl_dlopen(\"dbghelp.dll\", JL_RTLD_NOLOAD);\n-    needsSymRefreshModuleList = 0;\n-    if (jl_dbghelp)\n-        jl_dlsym(jl_dbghelp, \"SymRefreshModuleList\", (void **)&hSymRefreshModuleList, 1, 0);\n #else\n     /* macOS dlopen(3): If path is NULL and the option RTLD_FIRST is used, the\n        handle returned will only search the main executable. */"
    },
    {
      "sha": "39e49ae105f2917665a16118f9754c86dc0bf771",
      "filename": "src/julia_internal.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fjulia_internal.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fjulia_internal.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia_internal.h?ref=21fade478f774a524dbe0d81337810baaac1e33f",
      "patch": "@@ -271,6 +271,9 @@ extern uv_mutex_t bt_data_prof_lock;\n #define PROFILE_STATE_THREAD_SLEEPING (2)\n #define PROFILE_STATE_WALL_TIME_PROFILING (3)\n void jl_profile_task(void);\n+#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)\n+JL_DLLEXPORT void jl_set_profile_abort_ptr(_Atomic(int) *abort_ptr) JL_NOTSAFEPOINT;\n+#endif\n \n // number of cycles since power-on\n static inline uint64_t cycleclock(void) JL_NOTSAFEPOINT\n@@ -1529,9 +1532,6 @@ JL_DLLEXPORT void jl_gdblookup(void* ip) JL_NOTSAFEPOINT;\n JL_DLLEXPORT void jl_print_task_backtraces(int show_done) JL_NOTSAFEPOINT;\n void jl_fprint_native_codeloc(ios_t *s, uintptr_t ip) JL_NOTSAFEPOINT;\n void jl_fprint_bt_entry_codeloc(ios_t *s, jl_bt_element_t *bt_data) JL_NOTSAFEPOINT;\n-#ifdef _OS_WINDOWS_\n-JL_DLLEXPORT void jl_refresh_dbg_module_list(void);\n-#endif\n void jl_thread_resume(int tid) JL_NOTSAFEPOINT;\n int jl_thread_suspend(int16_t tid, bt_context_t *ctx) JL_NOTSAFEPOINT;\n "
    },
    {
      "sha": "1da687654dd81e8569719ce54def7e52299411fe",
      "filename": "src/signal-handling.c",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fsignal-handling.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fsignal-handling.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignal-handling.c?ref=21fade478f774a524dbe0d81337810baaac1e33f",
      "patch": "@@ -178,7 +178,6 @@ void jl_unlock_profile_wr(void)\n }\n \n \n-#ifndef _OS_WINDOWS_\n static uint64_t profile_cong_rng_seed = 0;\n static int *profile_round_robin_thread_order = NULL;\n static int profile_round_robin_thread_order_size = 0;\n@@ -209,7 +208,6 @@ static int *profile_get_randperm(int size)\n     jl_shuffle_int_array_inplace(profile_round_robin_thread_order, size, &profile_cong_rng_seed);\n     return profile_round_robin_thread_order;\n }\n-#endif\n \n \n JL_DLLEXPORT int jl_profile_is_buffer_full(void)"
    },
    {
      "sha": "c52c53d4ea58e0ded3f537b0ebb5321bb8fdec2d",
      "filename": "src/signals-win.c",
      "status": "modified",
      "additions": 107,
      "deletions": 45,
      "changes": 152,
      "blob_url": "https://github.com/JuliaLang/julia/blob/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fsignals-win.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fsignals-win.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-win.c?ref=21fade478f774a524dbe0d81337810baaac1e33f",
      "patch": "@@ -409,9 +409,33 @@ JL_DLLEXPORT void jl_install_sigint_handler(void)\n     SetConsoleCtrlHandler((PHANDLER_ROUTINE)sigint_handler,1);\n }\n \n-static volatile HANDLE hBtThread = 0;\n+static TIMECAPS timecaps;\n+static HANDLE hBtThread = 0;\n+static uv_cond_t bt_data_prof_cond = CONDITION_VARIABLE_INIT;\n+\n+#ifdef _CPU_X86_64_\n+// Callback data structure for profile timeout\n+typedef struct {\n+    _Atomic(int) *abort_ptr;\n+    int tid;\n+} profile_timeout_data_t;\n+\n+static void CALLBACK profile_timeout_cb(PVOID lpParam, BOOLEAN TimerOrWaitFired)\n+{\n+    profile_timeout_data_t *data = (profile_timeout_data_t*)lpParam;\n+    if (TimerOrWaitFired && data != NULL && data->abort_ptr != NULL) {\n+        // Timeout reached, signal an abort should occur\n+        // jl_safe_fprintf(ios_safe_stderr, \"profile_timeout_cb called.\\n\");\n+        if (jl_atomic_exchange(data->abort_ptr, 2) == 1) {\n+            // jl_safe_fprintf(ios_safe_stderr, \"profile_timeout_cb jl_thread_resume.\\n\");\n+            jl_thread_resume(data->tid);\n+            data->tid = -1;\n+        }\n+    }\n+}\n+#endif\n \n-int jl_thread_suspend_and_get_state(int tid, int timeout, bt_context_t *ctx)\n+static int jl_thread_suspend_and_get_state(int tid, int timeout, bt_context_t *ctx)\n {\n     (void)timeout;\n     jl_ptls_t ptls2 = jl_atomic_load_relaxed(&jl_all_tls_states)[tid];\n@@ -421,8 +445,10 @@ int jl_thread_suspend_and_get_state(int tid, int timeout, bt_context_t *ctx)\n     if (ct2 == NULL) // this thread is already dead\n         return 0;\n     HANDLE hThread = ptls2->system_id;\n-    if ((DWORD)-1 == SuspendThread(hThread))\n+    if ((DWORD)-1 == SuspendThread(hThread)) {\n+        // jl_safe_fprintf(ios_safe_stderr, \"failed to suspend thread %d: %lu\\n\", tid, GetLastError());\n         return 0;\n+    }\n     assert(sizeof(*ctx) == sizeof(CONTEXT));\n     memset(ctx, 0, sizeof(CONTEXT));\n     ctx->ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;\n@@ -439,90 +465,127 @@ void jl_thread_resume(int tid)\n     jl_ptls_t ptls2 = jl_atomic_load_relaxed(&jl_all_tls_states)[tid];\n     HANDLE hThread = ptls2->system_id;\n     if ((DWORD)-1 == ResumeThread(hThread)) {\n-        fputs(\"failed to resume main thread! aborting.\", stderr);\n+        jl_safe_fprintf(ios_safe_stderr, \"failed to resume main thread! aborting.\\n\");\n         abort();\n     }\n }\n \n int jl_thread_suspend(int16_t tid, bt_context_t *ctx)\n {\n-    uv_mutex_lock(&jl_in_stackwalk);\n-    jl_lock_profile();\n-    ULONG_PTR lock_cookie = 0;\n-    LdrLockLoaderLock(0x1, NULL, &lock_cookie);\n+    jl_lock_profile(); // prevent concurrent mutation\n+    uv_mutex_lock(&jl_in_stackwalk); // prevent multi-threaded dbghelp calls\n     int success = jl_thread_suspend_and_get_state(tid, 0, ctx);\n-    LdrUnlockLoaderLock(0x1, lock_cookie);\n-    jl_unlock_profile();\n     uv_mutex_unlock(&jl_in_stackwalk);\n+    jl_unlock_profile();\n     return success;\n }\n \n static DWORD WINAPI profile_bt( LPVOID lparam )\n {\n     // Note: illegal to use jl_* functions from this thread except for profiling-specific functions\n+    // Dummy event for RegisterWaitForSingleObject (to use timeout callback)\n+    HANDLE hProfileEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n+    if (hProfileEvent == NULL) {\n+        jl_safe_fprintf(ios_safe_stderr, \"failed to create profile event.\\n\");\n+        abort();\n+    }\n     while (1) {\n         DWORD timeout_ms = nsecprof / (GIGA / 1000);\n         Sleep(timeout_ms > 0 ? timeout_ms : 1);\n-        if (profile_running) {\n-            if (jl_profile_is_buffer_full()) {\n-                jl_profile_stop_timer(); // does not change the thread state\n-                SuspendThread(GetCurrentThread());\n-                continue;\n-            }\n-            else if (profile_all_tasks) {\n-                // Don't take the stackwalk lock here since it's already taken in `jl_rec_backtrace`\n-                jl_profile_task();\n-            }\n-            else {\n-                // TODO: bring this up to parity with other OS by adding loop over tid here\n-                bt_context_t c;\n-                if (!jl_thread_suspend(0, &c)) {\n-                    fputs(\"failed to suspend main thread. aborting profiling.\", stderr);\n+        if (jl_profile_is_buffer_full())\n+            jl_profile_stop_timer(); // does not change the thread state\n+        if (!profile_running) {\n+            uv_mutex_lock(&bt_data_prof_lock);\n+            while (!profile_running)\n+                uv_cond_wait(&bt_data_prof_cond, &bt_data_prof_lock);\n+            uv_mutex_unlock(&bt_data_prof_lock);\n+        }\n+        else if (profile_all_tasks) {\n+            // Don't take the stackwalk lock here since it's already taken in `jl_rec_backtrace`\n+            jl_profile_task();\n+        }\n+        else {\n+            // Profile all threads, similar to Unix implementation\n+            bt_context_t c;\n+            int nthreads = jl_atomic_load_acquire(&jl_n_threads);\n+            int *randperm = profile_get_randperm(nthreads);\n+            for (int idx = nthreads; idx-- > 0; ) {\n+                int tid = randperm[idx];\n+                if (!profile_running)\n+                    break;\n+                if (jl_profile_is_buffer_full()) {\n                     jl_profile_stop_timer();\n                     break;\n                 }\n+                if (!jl_thread_suspend(tid, &c))\n+                    continue;\n+                jl_ptls_t ptls = jl_atomic_load_relaxed(&jl_all_tls_states)[tid];\n+                jl_task_t *t2 = jl_atomic_load_relaxed(&ptls->current_task);\n+                int state = jl_atomic_load_relaxed(&ptls->sleep_check_state) == 0 ? PROFILE_STATE_THREAD_NOT_SLEEPING : PROFILE_STATE_THREAD_SLEEPING;\n+\n+                // Set up timeout handler for stackwalk\n+#ifdef _CPU_X86_64_\n+                _Atomic(int) abort_profiling = 0;\n+                profile_timeout_data_t timeout_data;\n+                timeout_data.abort_ptr = &abort_profiling;\n+                timeout_data.tid = tid;\n+                jl_set_profile_abort_ptr(&abort_profiling);\n+                HANDLE hWaitHandle = NULL;\n+                if (!RegisterWaitForSingleObject(&hWaitHandle, hProfileEvent, profile_timeout_cb,\n+                                                 &timeout_data, 100, WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD)) {\n+                    // Failed to register wait, proceed without timeout protection\n+                    hWaitHandle = NULL;\n+                }\n+#endif\n                 // Get backtrace data\n                 profile_bt_size_cur += rec_backtrace_ctx((jl_bt_element_t*)profile_bt_data_prof + profile_bt_size_cur,\n                         profile_bt_size_max - profile_bt_size_cur - 1, &c, NULL);\n-\n-                jl_ptls_t ptls = jl_atomic_load_relaxed(&jl_all_tls_states)[0]; // given only profiling hMainThread\n+#ifdef _CPU_X86_64_\n+                // Clear abort pointer from TLS\n+                jl_set_profile_abort_ptr(NULL);\n+                // Wait for callback to complete or cancel before continuing\n+                if (hWaitHandle != NULL)\n+                    UnregisterWaitEx(hWaitHandle, INVALID_HANDLE_VALUE);\n+                if (timeout_data.tid != -1)\n+#endif\n+                    jl_thread_resume(tid);\n \n                 // META_OFFSET_THREADID store threadid but add 1 as 0 is preserved to indicate end of block\n-                profile_bt_data_prof[profile_bt_size_cur++].uintptr = ptls->tid + 1;\n+                profile_bt_data_prof[profile_bt_size_cur++].uintptr = tid + 1;\n \n                 // META_OFFSET_TASKID store task id (never null)\n-                profile_bt_data_prof[profile_bt_size_cur++].jlvalue = (jl_value_t*)jl_atomic_load_relaxed(&ptls->current_task);\n+                profile_bt_data_prof[profile_bt_size_cur++].jlvalue = (jl_value_t*)t2;\n \n                 // META_OFFSET_CPUCYCLECLOCK store cpu cycle clock\n                 profile_bt_data_prof[profile_bt_size_cur++].uintptr = cycleclock();\n \n                 // store whether thread is sleeping (don't ever encode a state as `0` since is preserved to indicate end of block)\n-                int state = jl_atomic_load_relaxed(&ptls->sleep_check_state) == 0 ? PROFILE_STATE_THREAD_NOT_SLEEPING : PROFILE_STATE_THREAD_SLEEPING;\n                 profile_bt_data_prof[profile_bt_size_cur++].uintptr = state;\n \n                 // Mark the end of this block with two 0's\n                 profile_bt_data_prof[profile_bt_size_cur++].uintptr = 0;\n                 profile_bt_data_prof[profile_bt_size_cur++].uintptr = 0;\n-                jl_thread_resume(0);\n-                jl_check_profile_autostop();\n             }\n+            jl_check_profile_autostop();\n         }\n     }\n-    uv_mutex_unlock(&jl_in_stackwalk);\n-    jl_profile_stop_timer();\n+    // this is unreachable, but would be the relevant cleanup\n+    uv_mutex_lock(&bt_data_prof_lock);\n     hBtThread = NULL;\n+    uv_mutex_unlock(&bt_data_prof_lock);\n+    jl_profile_stop_timer();\n+    CloseHandle(hProfileEvent);\n     return 0;\n }\n \n-static volatile TIMECAPS timecaps;\n-\n JL_DLLEXPORT int jl_profile_start_timer(uint8_t all_tasks)\n {\n+    uv_mutex_lock(&bt_data_prof_lock);\n     if (hBtThread == NULL) {\n-\n         TIMECAPS _timecaps;\n         if (MMSYSERR_NOERROR != timeGetDevCaps(&_timecaps, sizeof(_timecaps))) {\n-            fputs(\"failed to get timer resolution\", stderr);\n+            uv_mutex_unlock(&bt_data_prof_lock);\n+            jl_safe_fprintf(ios_safe_stderr, \"failed to get timer resolution.\\n\");\n             return -2;\n         }\n         timecaps = _timecaps;\n@@ -534,15 +597,12 @@ JL_DLLEXPORT int jl_profile_start_timer(uint8_t all_tasks)\n             0,                      // argument to thread function\n             0,                      // use default creation flags\n             0);                     // returns the thread identifier\n-        if (hBtThread == NULL)\n+        if (hBtThread == NULL) {\n+            uv_mutex_unlock(&bt_data_prof_lock);\n+            jl_safe_fprintf(ios_safe_stderr, \"failed to allocate profile thread.\\n\");\n             return -1;\n-        (void)SetThreadPriority(hBtThread, THREAD_PRIORITY_ABOVE_NORMAL);\n-    }\n-    else {\n-        if ((DWORD)-1 == ResumeThread(hBtThread)) {\n-            fputs(\"failed to resume profiling thread.\", stderr);\n-            return -2;\n         }\n+        (void)SetThreadPriority(hBtThread, THREAD_PRIORITY_ABOVE_NORMAL);\n     }\n     if (profile_running == 0) {\n         // Failure to change the timer resolution is not fatal. However, it is important to\n@@ -552,6 +612,8 @@ JL_DLLEXPORT int jl_profile_start_timer(uint8_t all_tasks)\n     }\n     profile_all_tasks = all_tasks;\n     profile_running = 1; // set `profile_running` finally\n+    uv_cond_broadcast(&bt_data_prof_cond);\n+    uv_mutex_unlock(&bt_data_prof_lock);\n     return 0;\n }\n JL_DLLEXPORT void jl_profile_stop_timer(void)"
    },
    {
      "sha": "782a699d9b0cea50b5da06bd785c1dabd543c3f7",
      "filename": "src/stackwalk.c",
      "status": "modified",
      "additions": 134,
      "deletions": 33,
      "changes": 167,
      "blob_url": "https://github.com/JuliaLang/julia/blob/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fstackwalk.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fstackwalk.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fstackwalk.c?ref=21fade478f774a524dbe0d81337810baaac1e33f",
      "patch": "@@ -14,6 +14,7 @@\n // define `jl_unw_get` as a macro, since (like setjmp)\n // returning from the callee function will invalidate the context\n #ifdef _OS_WINDOWS_\n+#include <winternl.h>\n uv_mutex_t jl_in_stackwalk;\n #define jl_unw_get(context) (RtlCaptureContext(context), 0)\n #elif !defined(JL_DISABLE_LIBUNWIND)\n@@ -75,13 +76,15 @@ static int jl_unw_stepn(bt_cursor_t *cursor, jl_bt_element_t *bt_data, size_t *b\n     volatile int need_more_space = 0;\n     uintptr_t return_ip = 0;\n     uintptr_t thesp = 0;\n-#if defined(_OS_WINDOWS_) && !defined(_CPU_X86_64_)\n-    uv_mutex_lock(&jl_in_stackwalk);\n+#if defined(_OS_WINDOWS_)\n+#if !defined(_CPU_X86_64_)\n     if (!from_signal_handler) {\n         // Workaround 32-bit windows bug missing top frame\n         // See for example https://bugs.chromium.org/p/crashpad/issues/detail?id=53\n         skip--;\n     }\n+#endif\n+    jl_lock_profile();\n #endif\n #if !defined(_OS_WINDOWS_) // no point on windows, since RtlVirtualUnwind won't give us a second chance if the segfault happens in ntdll\n     jl_jmp_buf *old_buf = jl_get_safe_restore();\n@@ -188,9 +191,8 @@ static int jl_unw_stepn(bt_cursor_t *cursor, jl_bt_element_t *bt_data, size_t *b\n         if (n > 0) n -= 1;\n     }\n     jl_set_safe_restore(old_buf);\n-#endif\n-#if defined(_OS_WINDOWS_) && !defined(_CPU_X86_64_)\n-    uv_mutex_unlock(&jl_in_stackwalk);\n+#else\n+    jl_unlock_profile();\n #endif\n     *bt_size = n;\n     return need_more_space;\n@@ -402,21 +404,16 @@ JL_DLLEXPORT jl_value_t *jl_get_excstack(jl_task_t* task, int include_bt, int ma\n }\n \n #if defined(_OS_WINDOWS_)\n+\n // XXX: these caches should be per-thread\n #ifdef _CPU_X86_64_\n-static UNWIND_HISTORY_TABLE HistoryTable;\n-#else\n-static struct {\n-    DWORD64 dwAddr;\n-    DWORD64 ImageBase;\n-} HistoryTable;\n-#endif\n+static __thread UNWIND_HISTORY_TABLE HistoryTable;\n+static __thread _Atomic(int) *abort_profile_ptr = NULL;\n+\n static PVOID CALLBACK JuliaFunctionTableAccess64(\n         _In_  HANDLE hProcess,\n         _In_  DWORD64 AddrBase)\n {\n-    //jl_printf(JL_STDOUT, \"lookup %d\\n\", AddrBase);\n-#ifdef _CPU_X86_64_\n     DWORD64 ImageBase;\n     PRUNTIME_FUNCTION fn = RtlLookupFunctionEntry(AddrBase, &ImageBase, &HistoryTable);\n     if (fn)\n@@ -425,16 +422,11 @@ static PVOID CALLBACK JuliaFunctionTableAccess64(\n     PVOID ftable = SymFunctionTableAccess64(hProcess, AddrBase);\n     uv_mutex_unlock(&jl_in_stackwalk);\n     return ftable;\n-#else\n-    return SymFunctionTableAccess64(hProcess, AddrBase);\n-#endif\n }\n static DWORD64 WINAPI JuliaGetModuleBase64(\n         _In_  HANDLE hProcess,\n         _In_  DWORD64 dwAddr)\n {\n-    //jl_printf(JL_STDOUT, \"lookup base %d\\n\", dwAddr);\n-#ifdef _CPU_X86_64_\n     DWORD64 ImageBase;\n     PRUNTIME_FUNCTION fn = RtlLookupFunctionEntry(dwAddr, &ImageBase, &HistoryTable);\n     if (fn)\n@@ -443,7 +435,22 @@ static DWORD64 WINAPI JuliaGetModuleBase64(\n     DWORD64 fbase = SymGetModuleBase64(hProcess, dwAddr);\n     uv_mutex_unlock(&jl_in_stackwalk);\n     return fbase;\n+}\n #else\n+static __thread struct {\n+    DWORD64 dwAddr;\n+    DWORD64 ImageBase;\n+} HistoryTable;\n+static PVOID CALLBACK JuliaFunctionTableAccess64(\n+        _In_  HANDLE hProcess,\n+        _In_  DWORD64 AddrBase)\n+{\n+    return SymFunctionTableAccess64(hProcess, AddrBase);\n+}\n+static DWORD64 WINAPI JuliaGetModuleBase64(\n+        _In_  HANDLE hProcess,\n+        _In_  DWORD64 dwAddr)\n+{\n     if (dwAddr == HistoryTable.dwAddr)\n         return HistoryTable.ImageBase;\n     DWORD64 ImageBase = jl_getUnwindInfo(dwAddr);\n@@ -453,25 +460,105 @@ static DWORD64 WINAPI JuliaGetModuleBase64(\n         return ImageBase;\n     }\n     return SymGetModuleBase64(hProcess, dwAddr);\n-#endif\n }\n+#endif\n \n // Might be called from unmanaged thread.\n-volatile int needsSymRefreshModuleList;\n-BOOL (WINAPI *hSymRefreshModuleList)(HANDLE);\n+static PVOID dll_notification_cookie;\n+\n+// Structure definitions for LdrDllNotification\n+typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {\n+    ULONG Flags;\n+    PCUNICODE_STRING FullDllName;\n+    PCUNICODE_STRING BaseDllName;\n+    PVOID DllBase;\n+    ULONG SizeOfImage;\n+} LDR_DLL_LOADED_NOTIFICATION_DATA;\n+typedef const LDR_DLL_LOADED_NOTIFICATION_DATA *PCLDR_DLL_LOADED_NOTIFICATION_DATA;\n+\n+typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {\n+    ULONG Flags;\n+    PCUNICODE_STRING FullDllName;\n+    PCUNICODE_STRING BaseDllName;\n+    PVOID DllBase;\n+    ULONG SizeOfImage;\n+} LDR_DLL_UNLOADED_NOTIFICATION_DATA;\n+typedef const LDR_DLL_UNLOADED_NOTIFICATION_DATA *PCLDR_DLL_UNLOADED_NOTIFICATION_DATA;\n+\n+typedef union _LDR_DLL_NOTIFICATION_DATA {\n+    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;\n+    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;\n+} LDR_DLL_NOTIFICATION_DATA;\n+typedef const LDR_DLL_NOTIFICATION_DATA *PCLDR_DLL_NOTIFICATION_DATA;\n+\n+#define LDR_DLL_NOTIFICATION_REASON_LOADED   1\n+#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2\n+\n+// Forward declarations for ntdll functions\n+typedef VOID CALLBACK (*PLDR_DLL_NOTIFICATION_FUNCTION)(\n+  ULONG                       NotificationReason,\n+  PCLDR_DLL_NOTIFICATION_DATA NotificationData,\n+  PVOID                       Context\n+);\n+NTSTATUS NTAPI LdrRegisterDllNotification(ULONG Flags, PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction, PVOID Context, PVOID *Cookie);\n+NTSTATUS NTAPI LdrUnregisterDllNotification(PVOID Cookie);\n+\n+// Callback for LdrRegisterDllNotification\n+static VOID CALLBACK dll_notification_callback(\n+    ULONG NotificationReason,\n+    PCLDR_DLL_NOTIFICATION_DATA NotificationData,\n+    PVOID Context)\n+{\n+    (void)Context;\n+    uv_mutex_lock(&jl_in_stackwalk);\n+    // Store DLL information and update symbol handler based on notification reason\n+    if (NotificationReason == LDR_DLL_NOTIFICATION_REASON_LOADED) {\n+        const LDR_DLL_LOADED_NOTIFICATION_DATA *data = &NotificationData->Loaded;\n+        SymLoadModuleExW(GetCurrentProcess(), NULL,\n+                         data->FullDllName->Buffer,\n+                         data->BaseDllName->Buffer,\n+                         (uintptr_t)data->DllBase,\n+                         data->SizeOfImage,\n+                         NULL,\n+                         0);\n+    }\n+    else if (NotificationReason == LDR_DLL_NOTIFICATION_REASON_UNLOADED) {\n+        const LDR_DLL_UNLOADED_NOTIFICATION_DATA *data = &NotificationData->Unloaded;\n+        SymUnloadModule64(GetCurrentProcess(), (uintptr_t)data->DllBase);\n+    }\n+    uv_mutex_unlock(&jl_in_stackwalk);\n+}\n \n-JL_DLLEXPORT void jl_refresh_dbg_module_list(void)\n+// Initialize stackwalk infrastructure (DLL tracking and profiling)\n+void jl_init_stackwalk(void)\n {\n-    if (needsSymRefreshModuleList && hSymRefreshModuleList != NULL) {\n-        hSymRefreshModuleList(GetCurrentProcess());\n-        needsSymRefreshModuleList = 0;\n+    uv_mutex_init(&jl_in_stackwalk);\n+    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES | SYMOPT_IGNORE_CVREC);\n+    if (!SymInitialize(GetCurrentProcess(), \"\", 1))\n+        jl_safe_printf(\"WARNING: failed to initialize stack walk info\\n\");\n+    LdrRegisterDllNotification(0, dll_notification_callback, NULL, &dll_notification_cookie);\n+}\n+\n+// Finalize stackwalk infrastructure\n+void jl_fin_stackwalk(void)\n+{\n+    if (dll_notification_cookie) {\n+        LdrUnregisterDllNotification(dll_notification_cookie);\n+        dll_notification_cookie = NULL;\n     }\n }\n+\n+// Set the abort_profile_ptr in TLS\n+#ifdef _CPU_X86_64_\n+JL_DLLEXPORT void jl_set_profile_abort_ptr(_Atomic(int) *abort_ptr) JL_NOTSAFEPOINT\n+{\n+    abort_profile_ptr = abort_ptr;\n+}\n+#endif\n+\n static int jl_unw_init(bt_cursor_t *cursor, bt_context_t *Context)\n {\n     int result;\n-    uv_mutex_lock(&jl_in_stackwalk);\n-    jl_refresh_dbg_module_list();\n #if !defined(_CPU_X86_64_)\n     memset(&cursor->stackframe, 0, sizeof(cursor->stackframe));\n     cursor->stackframe.AddrPC.Offset = Context->Eip;\n@@ -481,14 +568,15 @@ static int jl_unw_init(bt_cursor_t *cursor, bt_context_t *Context)\n     cursor->stackframe.AddrStack.Mode = AddrModeFlat;\n     cursor->stackframe.AddrFrame.Mode = AddrModeFlat;\n     cursor->context = *Context;\n+    uv_mutex_lock(&jl_in_stackwalk);\n     result = StackWalk64(IMAGE_FILE_MACHINE_I386, GetCurrentProcess(), hMainThread,\n             &cursor->stackframe, &cursor->context, NULL, JuliaFunctionTableAccess64,\n             JuliaGetModuleBase64, NULL);\n+    uv_mutex_unlock(&jl_in_stackwalk);\n #else\n     *cursor = *Context;\n     result = 1;\n #endif\n-    uv_mutex_unlock(&jl_in_stackwalk);\n     return result;\n }\n \n@@ -520,8 +608,10 @@ static int jl_unw_step(bt_cursor_t *cursor, int from_signal_handler, uintptr_t *\n         return cursor->stackframe.AddrPC.Offset != 0;\n     }\n \n+    uv_mutex_lock(&jl_in_stackwalk);\n     BOOL result = StackWalk64(IMAGE_FILE_MACHINE_I386, GetCurrentProcess(), hMainThread,\n         &cursor->stackframe, &cursor->context, NULL, JuliaFunctionTableAccess64, JuliaGetModuleBase64, NULL);\n+    uv_mutex_unlock(&jl_in_stackwalk);\n     return result;\n #else\n     *ip = (uintptr_t)cursor->Rip;\n@@ -534,12 +624,23 @@ static int jl_unw_step(bt_cursor_t *cursor, int from_signal_handler, uintptr_t *\n         return cursor->Rip != 0;\n     }\n \n+    // Set can-abort flag\n+    _Atomic(int) *abort_ptr = abort_profile_ptr;\n+    if (abort_ptr && jl_atomic_exchange_relaxed(abort_ptr, 1) != 0) {\n+        jl_atomic_store_relaxed(abort_ptr, 3);\n+        return 0; // aborted\n+    }\n+\n     DWORD64 ImageBase = JuliaGetModuleBase64(GetCurrentProcess(), cursor->Rip - !from_signal_handler);\n-    if (!ImageBase)\n-        return 0;\n+    PRUNTIME_FUNCTION FunctionEntry = ImageBase ? (PRUNTIME_FUNCTION)JuliaFunctionTableAccess64(\n+        GetCurrentProcess(), cursor->Rip - !from_signal_handler) : NULL;\n+\n+    // Check if can-abort flag was removed, or remove it\n+    if (abort_ptr && jl_atomic_exchange_relaxed(abort_ptr, 0) != 1) {\n+        jl_atomic_store_relaxed(abort_ptr, 3);\n+        return 0; // abort\n+    }\n \n-    PRUNTIME_FUNCTION FunctionEntry = (PRUNTIME_FUNCTION)JuliaFunctionTableAccess64(\n-        GetCurrentProcess(), cursor->Rip - !from_signal_handler);\n     if (!FunctionEntry) {\n         // Not code or bad unwind?\n         return 0;"
    },
    {
      "sha": "9a3143f72666ef18b478a3241ccd37ec9b51db1e",
      "filename": "src/threading.c",
      "status": "modified",
      "additions": 3,
      "deletions": 10,
      "changes": 13,
      "blob_url": "https://github.com/JuliaLang/julia/blob/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fthreading.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/21fade478f774a524dbe0d81337810baaac1e33f/src%2Fthreading.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fthreading.c?ref=21fade478f774a524dbe0d81337810baaac1e33f",
      "patch": "@@ -345,18 +345,12 @@ jl_ptls_t jl_init_threadtls(int16_t tid)\n #endif\n     ptls->system_id = uv_thread_self();\n     ptls->rngseed = jl_rand();\n-    if (tid == 0)\n+    if (tid == 0) {\n         ptls->disable_gc = 1;\n #ifdef _OS_WINDOWS_\n-    if (tid == 0) {\n-        if (!DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),\n-                             GetCurrentProcess(), &hMainThread, 0,\n-                             FALSE, DUPLICATE_SAME_ACCESS)) {\n-            jl_printf(JL_STDERR, \"WARNING: failed to access handle to main thread\\n\");\n-            hMainThread = INVALID_HANDLE_VALUE;\n-        }\n-    }\n+        hMainThread = ptls->system_id;\n #endif\n+    }\n     jl_atomic_store_relaxed(&ptls->gc_state, JL_GC_STATE_UNSAFE); // GC unsafe\n     // Conditionally initialize the safepoint address. See comment in\n     // `safepoint.c`\n@@ -879,7 +873,6 @@ void jl_start_threads(void)\n             uv_thread_setaffinity(&uvtid, mask, NULL, cpumasksize);\n             mask[i - ninteractive_threads] = 0;\n         }\n-        uv_thread_detach(&uvtid);\n     }\n }\n "
    }
  ]
}