{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/55045",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/55045/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/55045/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/55045/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/55045",
  "id": 2392972122,
  "node_id": "PR_kwDOABkWpM50jsdf",
  "number": 55045,
  "title": "implement `sret_union` ABI for pointer-ful types",
  "user": {
    "login": "topolarity",
    "id": 84105208,
    "node_id": "MDQ6VXNlcjg0MTA1MjA4",
    "avatar_url": "https://avatars.githubusercontent.com/u/84105208?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/topolarity",
    "html_url": "https://github.com/topolarity",
    "followers_url": "https://api.github.com/users/topolarity/followers",
    "following_url": "https://api.github.com/users/topolarity/following{/other_user}",
    "gists_url": "https://api.github.com/users/topolarity/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/topolarity/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/topolarity/subscriptions",
    "organizations_url": "https://api.github.com/users/topolarity/orgs",
    "repos_url": "https://api.github.com/users/topolarity/repos",
    "events_url": "https://api.github.com/users/topolarity/events{/privacy}",
    "received_events_url": "https://api.github.com/users/topolarity/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 115858,
      "node_id": "MDU6TGFiZWwxMTU4NTg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/performance",
      "name": "performance",
      "color": "d7e102",
      "default": false,
      "description": "Must go faster"
    },
    {
      "id": 183231688,
      "node_id": "MDU6TGFiZWwxODMyMzE2ODg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:codegen",
      "name": "compiler:codegen",
      "color": "d4c5f9",
      "default": false,
      "description": "Generation of LLVM IR and native code"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 13,
  "created_at": "2024-07-05T18:01:49Z",
  "updated_at": "2025-12-08T16:29:05Z",
  "closed_at": "2025-12-08T16:29:02Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/55045",
    "html_url": "https://github.com/JuliaLang/julia/pull/55045",
    "diff_url": "https://github.com/JuliaLang/julia/pull/55045.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/55045.patch",
    "merged_at": "2025-12-08T16:29:02Z"
  },
  "body": "This effectively expands our existing `union` ABI to cover both of these existing cases:\r\n - `sret`  ABI (which can stack-allocate a _single pointer-ful_ type)\r\n - `union` ABI (which can stack-allocate _many pointer-free_ types)\r\n\r\nThis provides some nice speed-ups for temporary \"wrappers\":\r\n```julia\r\nconst v = Any[]\r\n@noinline maybe_wrapped(i) = (i % 32 != 0) ? Some(v) : nothing\r\nfunction foo()\r\n    count = 0\r\n    for i = 1:1_000_000\r\n        count += (maybe_wrapped(i) !== nothing) ? 1 : 0\r\n    end\r\n    return count\r\nend\r\n```\r\n\r\nOn this PR this gives:\r\n```julia\r\njulia> @btime foo()\r\n  1.675 ms (0 allocations: 0 bytes)\r\n968750\r\n```\r\n\r\ncompared to current master:\r\n```julia\r\njulia> @btime foo()\r\n  6.877 ms (968750 allocations: 14.78 MiB)\r\n968750\r\n```\r\n\r\nTODO:\r\n - [x] Figure out what to do about PHI nodes\r\n - [x] Figure out why https://github.com/JuliaLang/julia/issues/53584 is not fixed, if not the \u03d5-node issue\r\n\r\nThe most outstanding TODO here is what to do about \u03d5-nodes. Right now, if the incoming `Union{...}` type has a pointer-containing type then this change forces the incoming object to be boxed, even if the object at run-time is actually pointer-free.\r\n\r\nBut that's just a band-aid so the code works - it introduces new boxes where we didn't have them before, which is a regression that almost certainly needs to be fixed before landing this.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/55045/reactions",
    "total_count": 22,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 13,
    "confused": 0,
    "heart": 0,
    "rocket": 9,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/55045/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "96a662e920495ba4b703f8d8d50daaa35fdb871d",
      "filename": "doc/src/devdocs/compiler.md",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/95c412a8058d723d2f1632fba005ed6dfbd5901f/doc%2Fsrc%2Fdevdocs%2Fcompiler.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/95c412a8058d723d2f1632fba005ed6dfbd5901f/doc%2Fsrc%2Fdevdocs%2Fcompiler.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fdevdocs%2Fcompiler.md?ref=95c412a8058d723d2f1632fba005ed6dfbd5901f",
      "patch": "@@ -36,16 +36,6 @@ determine how to assign or pass it somewhere.\n They are created via one of the helper constructors, usually:\n `mark_julia_type` (for immediate values) and `mark_julia_slot` (for pointers to values).\n \n-The function `convert_julia_type` can transform between any two types.\n-It returns an R-value with `cgval.typ` set to `typ`.\n-It'll cast the object to the requested representation,\n-making heap boxes, allocating stack copies, and computing tagged unions as\n-needed to change the representation.\n-\n-By contrast `update_julia_type` will change `cgval.typ` to `typ`,\n-only if it can be done at zero-cost (i.e. without emitting any code).\n-\n-\n ## Union representation\n \n Inferred union types may be stack allocated via a tagged type representation."
    },
    {
      "sha": "464054805cd6ecddafa25369356c24e587fe0f81",
      "filename": "src/ccall.cpp",
      "status": "modified",
      "additions": 38,
      "deletions": 22,
      "changes": 60,
      "blob_url": "https://github.com/JuliaLang/julia/blob/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fccall.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fccall.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fccall.cpp?ref=95c412a8058d723d2f1632fba005ed6dfbd5901f",
      "patch": "@@ -523,16 +523,33 @@ static const std::string make_errmsg(const char *fname, int n, const char *err)\n     return msg.str();\n }\n \n+// bitcast whatever Ptr kind x might be (even if it is part of a union) into Ptr{Cvoid}\n+// given that the caller already had emit_cpointercheck on this branch, so that\n+// the conversion is guaranteed to be valid on this runtime branch\n+static jl_cgval_t voidpointer_update(jl_codectx_t &ctx, const jl_cgval_t &x)\n+{\n+    if (x.typ == (jl_value_t*)jl_voidpointer_type)\n+        return x;\n+    if (jl_type_intersection(x.typ, (jl_value_t*)jl_pointer_type) == jl_bottom_type)\n+        return jl_cgval_t();\n+    if (x.constant)\n+        return mark_julia_type(ctx, julia_const_to_llvm(ctx, x.constant), false, jl_voidpointer_type);\n+    if (x.V == nullptr)\n+        return jl_cgval_t();\n+    if (!x.inline_roots.empty() || x.ispointer())\n+        return mark_julia_slot(x.V, (jl_value_t*)jl_voidpointer_type, NULL, x.tbaa);\n+    return mark_julia_type(ctx, x.V, false, jl_voidpointer_type);\n+}\n+\n static jl_cgval_t typeassert_input(jl_codectx_t &ctx, const jl_cgval_t &jvinfo, jl_value_t *jlto, jl_unionall_t *jlto_env, int argn)\n {\n     if (jlto != (jl_value_t*)jl_any_type && !jl_subtype(jvinfo.typ, jlto)) {\n         if (jlto == (jl_value_t*)jl_voidpointer_type) {\n             // allow a bit more flexibility for what can be passed to (void*) due to Ref{T} conversion behavior in input\n-            if (!jl_is_cpointer_type(jvinfo.typ)) {\n+            if (!jl_is_cpointer_type(jvinfo.typ))\n                 // emit a typecheck, if not statically known to be correct\n                 emit_cpointercheck(ctx, jvinfo, make_errmsg(\"ccall\", argn + 1, \"\"));\n-                return update_julia_type(ctx, jvinfo, (jl_value_t*)jl_pointer_type);\n-            }\n+            return voidpointer_update(ctx, jvinfo);\n         }\n         else {\n             // emit a typecheck, if not statically known to be correct\n@@ -581,7 +598,7 @@ static Value *julia_to_native(\n \n     jvinfo = typeassert_input(ctx, jvinfo, jlto, jlto_env, argn);\n     if (!byRef)\n-        return emit_unbox(ctx, to, jvinfo, jlto);\n+        return emit_unbox(ctx, to, jvinfo);\n \n     // pass the address of an alloca'd thing, not a box\n     // since those are immutable.\n@@ -740,8 +757,7 @@ static void interpret_ccall_symbol_arg(jl_codectx_t &ctx, native_sym_arg_t &out,\n             const char *errmsg = \"ccall: first argument not a pointer or valid constant expression\";\n             emit_cpointercheck(ctx, arg1, errmsg);\n         }\n-        arg1 = update_julia_type(ctx, arg1, (jl_value_t*)jl_voidpointer_type);\n-        out.jl_ptr = emit_unbox(ctx, ctx.types().T_ptr, arg1, (jl_value_t*)jl_voidpointer_type);\n+        out.jl_ptr = emit_unbox(ctx, ctx.types().T_ptr, voidpointer_update(ctx, arg1));\n     }\n \n     // Handle Julia internal symbol lookup for static function names\n@@ -804,8 +820,7 @@ static jl_cgval_t emit_cglobal(jl_codectx_t &ctx, jl_value_t **args, size_t narg\n             argv[1] = emit_expr(ctx, args[2]);\n         if (!jl_is_cpointer_type(argv[0].typ))\n             return emit_runtime_call(ctx, nargs == 1 ? JL_I::cglobal_auto : JL_I::cglobal, argv, nargs);\n-        argv[0] = update_julia_type(ctx, argv[0], (jl_value_t*)jl_voidpointer_type);\n-        sym.jl_ptr = emit_unbox(ctx, ctx.types().T_ptr, argv[0], (jl_value_t*)jl_voidpointer_type);\n+        sym.jl_ptr = emit_unbox(ctx, ctx.types().T_ptr, voidpointer_update(ctx, argv[0]));\n         res = sym.jl_ptr;\n     }\n \n@@ -1668,8 +1683,11 @@ static jl_cgval_t emit_ccall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n             retval = boxed(ctx, argv[0]);\n             retval = emit_pointer_from_objref(ctx, retval /*T_prjlvalue*/);\n         }\n+        else if (tti == (jl_value_t*)jl_voidpointer_type) {\n+            retval = emit_unbox(ctx, largty, voidpointer_update(ctx, argv[0]));\n+        }\n         else {\n-            retval = emit_unbox(ctx, largty, argv[0], tti);\n+            retval = emit_unbox(ctx, largty, update_julia_type(ctx, argv[0], tti));\n         }\n         // retval is now an untracked jl_value_t*\n         if (retboxed)\n@@ -1788,7 +1806,7 @@ static jl_cgval_t emit_ccall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n         const int rng_offset = offsetof(jl_tls_states_t, rngseed);\n         Value *rng_ptr = ctx.builder.CreateInBoundsGEP(getInt8Ty(ctx.builder.getContext()), ptls_p, ConstantInt::get(ctx.types().T_size, rng_offset / sizeof(int8_t)));\n         setName(ctx.emission_context, rng_ptr, \"rngseed_ptr\");\n-        Value *val64 = emit_unbox(ctx, getInt64Ty(ctx.builder.getContext()), argv[0], (jl_value_t*)jl_uint64_type);\n+        Value *val64 = emit_unbox(ctx, getInt64Ty(ctx.builder.getContext()), update_julia_type(ctx, argv[0], (jl_value_t*)jl_uint64_type));\n         auto store = ctx.builder.CreateAlignedStore(val64, rng_ptr, Align(sizeof(void*)));\n         jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n         ai.decorateInst(store);\n@@ -1962,14 +1980,13 @@ static jl_cgval_t emit_ccall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n         const jl_cgval_t &dst = argv[0];\n         const jl_cgval_t &src = argv[1];\n         const jl_cgval_t &n = argv[2];\n-        Value *destp = emit_unbox(ctx, ctx.types().T_ptr, dst, (jl_value_t*)jl_voidpointer_type);\n-\n+        Value *destp = emit_unbox(ctx, ctx.types().T_ptr, voidpointer_update(ctx, dst));\n         ctx.builder.CreateMemCpy(\n                 destp,\n                 MaybeAlign(1),\n-                emit_unbox(ctx, ctx.types().T_ptr, src, (jl_value_t*)jl_voidpointer_type),\n+                emit_unbox(ctx, ctx.types().T_ptr, voidpointer_update(ctx, src)),\n                 MaybeAlign(1),\n-                emit_unbox(ctx, ctx.types().T_size, n, (jl_value_t*)jl_ulong_type),\n+                emit_unbox(ctx, ctx.types().T_size, update_julia_type(ctx, n, (jl_value_t*)jl_ulong_type)),\n                 false);\n         JL_GC_POP();\n         return rt == (jl_value_t*)jl_nothing_type ? ghostValue(ctx, jl_nothing_type) :\n@@ -1980,13 +1997,13 @@ static jl_cgval_t emit_ccall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n         const jl_cgval_t &dst = argv[0];\n         const jl_cgval_t &val = argv[1];\n         const jl_cgval_t &n = argv[2];\n-        Value *destp = emit_unbox(ctx, ctx.types().T_ptr, dst, (jl_value_t*)jl_voidpointer_type);\n-        Value *val32 = emit_unbox(ctx, getInt32Ty(ctx.builder.getContext()), val, (jl_value_t*)jl_uint32_type);\n+        Value *destp = emit_unbox(ctx, ctx.types().T_ptr, voidpointer_update(ctx, dst));\n+        Value *val32 = emit_unbox(ctx, getInt32Ty(ctx.builder.getContext()), update_julia_type(ctx, val, (jl_value_t*)jl_int32_type));\n         Value *val8 = ctx.builder.CreateTrunc(val32, getInt8Ty(ctx.builder.getContext()), \"memset_val\");\n         ctx.builder.CreateMemSet(\n             destp,\n             val8,\n-            emit_unbox(ctx, ctx.types().T_size, n, (jl_value_t*)jl_ulong_type),\n+            emit_unbox(ctx, ctx.types().T_size, update_julia_type(ctx, n, (jl_value_t*)jl_ulong_type)),\n             MaybeAlign(1)\n         );\n         JL_GC_POP();\n@@ -1998,14 +2015,14 @@ static jl_cgval_t emit_ccall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n         const jl_cgval_t &dst = argv[0];\n         const jl_cgval_t &src = argv[1];\n         const jl_cgval_t &n = argv[2];\n-        Value *destp = emit_unbox(ctx, ctx.types().T_ptr, dst, (jl_value_t*)jl_voidpointer_type);\n+        Value *destp = emit_unbox(ctx, ctx.types().T_ptr, voidpointer_update(ctx, dst));\n \n         ctx.builder.CreateMemMove(\n                 destp,\n                 MaybeAlign(0),\n-                emit_unbox(ctx, ctx.types().T_ptr, src, (jl_value_t*)jl_voidpointer_type),\n+                emit_unbox(ctx, ctx.types().T_ptr, update_julia_type(ctx, src, (jl_value_t*)jl_voidpointer_type)),\n                 MaybeAlign(0),\n-                emit_unbox(ctx, ctx.types().T_size, n, (jl_value_t*)jl_ulong_type),\n+                emit_unbox(ctx, ctx.types().T_size, update_julia_type(ctx, n, (jl_value_t*)jl_ulong_type)),\n                 false);\n         JL_GC_POP();\n         return rt == (jl_value_t*)jl_nothing_type ? ghostValue(ctx, jl_nothing_type) :\n@@ -2099,8 +2116,7 @@ jl_cgval_t function_sig_t::emit_a_ccall(\n         if (jl_is_abstract_ref_type(jargty)) {\n             if (!jl_is_cpointer_type(arg.typ)) {\n                 emit_cpointercheck(ctx, arg, \"ccall: argument to Ref{T} is not a pointer\");\n-                arg.typ = (jl_value_t*)jl_voidpointer_type;\n-                arg.isboxed = false;\n+                arg = voidpointer_update(ctx, arg);\n             }\n             jargty_in_env = (jl_value_t*)jl_voidpointer_type;\n         }"
    },
    {
      "sha": "3af3826613fb292a80308cbe0c50dcc49ee46502",
      "filename": "src/cgutils.cpp",
      "status": "modified",
      "additions": 339,
      "deletions": 178,
      "changes": 517,
      "blob_url": "https://github.com/JuliaLang/julia/blob/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fcgutils.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fcgutils.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcgutils.cpp?ref=95c412a8058d723d2f1632fba005ed6dfbd5901f",
      "patch": "@@ -81,6 +81,30 @@ static Value *mark_callee_rooted(jl_codectx_t &ctx, Value *V)\n         PointerType::get(V->getContext(), AddressSpace::CalleeRooted));\n }\n \n+static Constant *julia_const_to_llvm(jl_codectx_t &ctx, jl_value_t *e);\n+\n+static Value *data_pointer(jl_codectx_t &ctx, const jl_cgval_t &x)\n+{\n+    assert(x.ispointer());\n+    Value *data;\n+    if (x.constant) {\n+        Constant *val = julia_const_to_llvm(ctx, x.constant);\n+        if (val && !type_is_ghost(val->getType()))\n+            data = get_pointer_to_constant(ctx.emission_context, val, Align(julia_alignment(jl_typeof(x.constant))), \"_j_const\", *jl_Module);\n+        else\n+            data = literal_pointer_val(ctx, x.constant);\n+    }\n+    else if (x.V == NULL) {\n+        // might be a ghost union with tindex but no actual pointer\n+        // could use Undef here, but harder to debug if something goes wrong\n+        data = ConstantPointerNull::get(ctx.types().T_ptr);\n+    }\n+    else {\n+        data = maybe_decay_tracked(ctx, x.V);\n+    }\n+    return data;\n+}\n+\n AtomicOrdering get_llvm_atomic_order(enum jl_memory_order order)\n {\n     switch (order) {\n@@ -117,7 +141,7 @@ static Value *stringConstPtr(\n     ctxt.pop_back();\n     // We use this for the name of the gv, so cap its size to avoid memory blowout\n     if (ctxt.size() > 28) {\n-        ctxt.resize(28);\n+        ctxt.truncate(28);\n         ctxt[25] = ctxt[26] = ctxt[27] = '.';\n     }\n     // Doesn't need to be aligned, we shouldn't operate on these like julia objects\n@@ -300,7 +324,7 @@ static Value *emit_pointer_from_objref(jl_codectx_t &ctx, Value *V)\n     return Call;\n }\n \n-static Value *emit_unbox(jl_codectx_t &ctx, Type *to, const jl_cgval_t &x, jl_value_t *jt);\n+static Value *emit_unbox(jl_codectx_t &ctx, Type *to, const jl_cgval_t &x);\n static void emit_unbox_store(jl_codectx_t &ctx, const jl_cgval_t &x, Value* dest, MDNode *tbaa_dest, MaybeAlign align_src, Align align_dst, bool isVolatile=false);\n \n static bool type_is_permalloc(jl_value_t *typ)\n@@ -340,16 +364,154 @@ static void find_perm_offsets(jl_datatype_t *typ, SmallVectorImpl<unsigned> &res\n     }\n }\n \n+static Value *CreateSimplifiedExtractValue(jl_codectx_t &ctx, Value *Agg, ArrayRef<unsigned> Idxs)\n+{\n+    // aka IRBuilder<InstSimplifyFolder>\n+    SimplifyQuery SQ(jl_Module->getDataLayout()); // not actually used, but required by API\n+    if (Value *Inst = simplifyExtractValueInst(Agg, Idxs, SQ))\n+        return Inst;\n+    return ctx.builder.CreateExtractValue(Agg, Idxs);\n+}\n+\n+static Value *CreateSimplifiedExtractElement(jl_codectx_t &ctx, Value *Agg, unsigned Idx)\n+{\n+    // aka IRBuilder<InstSimplifyFolder>\n+    Constant *I = ConstantInt::get(Type::getInt32Ty(Agg->getContext()), Idx);\n+    SimplifyQuery SQ(jl_Module->getDataLayout()); // not actually used, but required by API\n+    if (Value *Inst = simplifyExtractElementInst(Agg, I, SQ))\n+        return Inst;\n+    return ctx.builder.CreateExtractElement(Agg, I);\n+}\n+\n+static Value *ExtractScalar(jl_codectx_t &ctx, Value *V, Type *VTy, ArrayRef<unsigned> Idxs) {\n+    if (isa<PointerType>(V->getType())) {\n+        assert(Idxs.empty());\n+    }\n+    else if (!Idxs.empty()) {\n+        auto IdxsNotVec = Idxs.slice(0, Idxs.size() - 1);\n+        Type *FinalT = ExtractValueInst::getIndexedType(V->getType(), IdxsNotVec);\n+        bool IsVector = isa<VectorType>(FinalT);\n+        if (Idxs.size() > IsVector)\n+            V = CreateSimplifiedExtractValue(ctx, V, IsVector ? IdxsNotVec : Idxs);\n+        if (IsVector)\n+            V = CreateSimplifiedExtractElement(ctx, V, Idxs.back());\n+    }\n+    return V;\n+}\n+\n+static unsigned getFieldOffset(const DataLayout &DL, Type *STy, ArrayRef<unsigned> Idxs)\n+{\n+    SmallVector<Value*,4> IdxList{Idxs.size() + 1};\n+    Type *T_int32 = Type::getInt32Ty(STy->getContext());\n+    IdxList[0] = ConstantInt::get(T_int32, 0);\n+    for (unsigned j = 0; j < Idxs.size(); ++j)\n+        IdxList[j + 1] = ConstantInt::get(T_int32, Idxs[j]);\n+    auto offset = DL.getIndexedOffsetInType(STy, IdxList);\n+    assert(offset >= 0);\n+    return (unsigned)offset;\n+}\n+\n+static bool isTrackedValue(Value *V) {\n+    PointerType *PT = dyn_cast<PointerType>(V->getType()->getScalarType());\n+    return PT && PT->getAddressSpace() == AddressSpace::Tracked;\n+}\n+\n+static SmallVector<Value*, 0> ExtractTrackedValues(jl_codectx_t &ctx, Value *Src, ArrayRef<unsigned> perm_offsets={}) {\n+    Type *STy = Src->getType();\n+    auto Tracked = TrackCompositeType(STy);\n+    SmallVector<Value*, 0> Ptrs;\n+    unsigned perm_idx = 0;\n+    auto ignore_field = [&] (ArrayRef<unsigned> Idxs) {\n+        if (perm_idx >= perm_offsets.size())\n+            return false;\n+        // Assume the indices returned from `TrackCompositeType` is ordered and do a\n+        // single pass over `perm_offsets`.\n+        auto offset = getFieldOffset(ctx.builder.GetInsertBlock()->getModule()->getDataLayout(),\n+                                     STy, Idxs);\n+        do {\n+            auto perm_offset = perm_offsets[perm_idx];\n+            if (perm_offset > offset)\n+                return false;\n+            perm_idx++;\n+            if (perm_offset == offset) {\n+                return true;\n+            }\n+        } while (perm_idx < perm_offsets.size());\n+        return false;\n+    };\n+    for (unsigned i = 0; i < Tracked.size(); ++i) {\n+        auto Idxs = ArrayRef<unsigned>(Tracked[i]);\n+        if (ignore_field(Idxs))\n+            continue;\n+        Value *Elem = ExtractScalar(ctx, Src, STy, Idxs);\n+        if (isTrackedValue(Elem)) // ignore addrspace Loaded when it appears\n+            Ptrs.push_back(Elem);\n+    }\n+    return Ptrs;\n+}\n+\n+static llvm::SmallVector<Value*,0> extract_gc_roots(jl_codectx_t &ctx, Value *data_pointer, jl_datatype_t *typ, size_t npointers, MDNode *tbaa, bool isVolatile=false)\n+{\n+    SmallVector<Value*,0> gcroots(npointers);\n+    if (npointers) {\n+        Type *T_prjlvalue = ctx.types().T_prjlvalue;\n+        auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n+        bool isstack = isa<AllocaInst>(data_pointer->stripInBoundsOffsets()) || tbaa == ctx.tbaa().tbaa_stack || tbaa == ctx.tbaa().tbaa_gcframe || tbaa == ctx.tbaa().tbaa_const;\n+        for (size_t i = 0; i < npointers; i++) {\n+            Value *field_ptr = emit_ptrgep(ctx, data_pointer, jl_ptr_offset(typ, i) * sizeof(jl_value_t*));\n+            LoadInst *root = ctx.builder.CreateAlignedLoad(T_prjlvalue, field_ptr, Align(sizeof(void*)), isVolatile);\n+            if (!isstack)\n+                root->setOrdering(AtomicOrdering::Unordered);\n+            roots_ai.decorateInst(root);\n+            gcroots[i] = root;\n+        }\n+    }\n+    return gcroots;\n+}\n+\n+static llvm::SmallVector<Value*,0> extract_gc_roots(jl_codectx_t &ctx, const jl_cgval_t &val, size_t npointers)\n+{\n+    SmallVector<Value*,0> gcroots;\n+    if (npointers) {\n+        if (!val.inline_roots.empty()) {\n+            gcroots = val.inline_roots;\n+        }\n+        else if (val.ispointer()) {\n+            Type *T_prjlvalue = ctx.types().T_prjlvalue;\n+            auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, val.tbaa);\n+            Value *p = maybe_decay_tracked(ctx, data_pointer(ctx, val));\n+            auto tbaa = val.tbaa;\n+            bool isstack = isa<AllocaInst>(p->stripInBoundsOffsets()) || tbaa == ctx.tbaa().tbaa_stack || tbaa == ctx.tbaa().tbaa_gcframe || tbaa == ctx.tbaa().tbaa_const;\n+            gcroots.resize(npointers, nullptr);\n+            for (size_t i = 0; i < npointers; i++) {\n+                Value *field_ptr = emit_ptrgep(ctx, p, jl_ptr_offset((jl_datatype_t*)val.typ, i) * sizeof(jl_value_t*));\n+                LoadInst *root = ctx.builder.CreateAlignedLoad(T_prjlvalue, field_ptr, Align(sizeof(void*)));\n+                if (!isstack)\n+                    root->setOrdering(AtomicOrdering::Unordered);\n+                roots_ai.decorateInst(root);\n+                gcroots[i] = root;\n+            }\n+        }\n+        else if (val.V) {\n+            gcroots = ExtractTrackedValues(ctx, val.V);\n+        }\n+    }\n+    return gcroots;\n+}\n+\n+\n // load a pointer to N inlined_roots into registers (as a SmallVector)\n static llvm::SmallVector<Value*,0> load_gc_roots(jl_codectx_t &ctx, Value *inline_roots_ptr, size_t npointers, MDNode *tbaa, bool isVolatile=false)\n {\n     SmallVector<Value*,0> gcroots(npointers);\n-    Type *T_prjlvalue = ctx.types().T_prjlvalue;\n-    auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-    for (size_t i = 0; i < npointers; i++) {\n-        auto *ptr = ctx.builder.CreateAlignedLoad(T_prjlvalue, emit_ptrgep(ctx, inline_roots_ptr, i * sizeof(jl_value_t*)), Align(sizeof(void*)), isVolatile);\n-        roots_ai.decorateInst(ptr);\n-        gcroots[i] = ptr;\n+    if (npointers) {\n+        Type *T_prjlvalue = ctx.types().T_prjlvalue;\n+        auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n+        for (size_t i = 0; i < npointers; i++) {\n+            LoadInst *ptr = ctx.builder.CreateAlignedLoad(T_prjlvalue, emit_ptrgep(ctx, inline_roots_ptr, i * sizeof(jl_value_t*)), Align(sizeof(void*)), isVolatile);\n+            roots_ai.decorateInst(ptr);\n+            gcroots[i] = ptr;\n+        }\n     }\n     return gcroots;\n }\n@@ -378,10 +540,10 @@ static llvm::SmallVector<Value*,0> get_gc_roots_for(jl_codectx_t &ctx, const jl_\n     else if (jl_is_concrete_immutable(x.typ) && !jl_is_pointerfree(x.typ)) {\n         jl_value_t *jltype = x.typ;\n         Type *T = julia_type_to_llvm(ctx, jltype);\n-        Value *agg = emit_unbox(ctx, T, x, jltype);\n+        Value *agg = emit_unbox(ctx, T, x);\n         SmallVector<unsigned,4> perm_offsets;\n         find_perm_offsets((jl_datatype_t*)jltype, perm_offsets, 0);\n-        return ExtractTrackedValues(agg, agg->getType(), false, ctx.builder, perm_offsets);\n+        return ExtractTrackedValues(ctx, agg, perm_offsets);\n     }\n     // nothing here to root, move along\n     return {};\n@@ -934,7 +1096,7 @@ static bool for_each_uniontype_small(\n     else if (ty == (jl_value_t*)jl_typeofbottom_type->super) {\n         f(++counter, jl_typeofbottom_type); // treat Tuple{union{}} as identical to typeof(Union{})\n     }\n-    else if (jl_is_pointerfree(ty)) {\n+    else if (!deserves_unionbox(ty)) {\n         f(++counter, (jl_datatype_t*)ty);\n         return true;\n     }\n@@ -947,13 +1109,23 @@ static bool is_uniontype_allunboxed(jl_value_t *typ)\n     return for_each_uniontype_small([&](unsigned, jl_datatype_t*) {}, typ, counter);\n }\n \n+static bool is_uniontype_anyunboxed(jl_value_t *typ)\n+{\n+    unsigned counter = 0;\n+    for_each_uniontype_small([&](unsigned, jl_datatype_t*) {}, typ, counter);\n+    return counter != 0;\n+}\n+\n+\n static Value *emit_typeof(jl_codectx_t &ctx, Value *v, bool maybenull, bool justtag, bool notag=false);\n static Value *emit_typeof(jl_codectx_t &ctx, const jl_cgval_t &p, bool maybenull=false, bool justtag=false);\n \n static unsigned get_box_tindex(jl_datatype_t *jt, jl_value_t *ut)\n {\n     unsigned new_idx = 0;\n     unsigned new_counter = 0;\n+    if (jt == jl_typeofbottom_type->super)\n+        jt = jl_typeofbottom_type; // treat Tuple{union{}} as identical to typeof(Union{})\n     for_each_uniontype_small(\n             // find the corresponding index in the new union-type\n             [&](unsigned new_idx_, jl_datatype_t *new_jt) {\n@@ -968,29 +1140,6 @@ static unsigned get_box_tindex(jl_datatype_t *jt, jl_value_t *ut)\n \n // --- generating various field accessors ---\n \n-static Constant *julia_const_to_llvm(jl_codectx_t &ctx, jl_value_t *e);\n-\n-static Value *data_pointer(jl_codectx_t &ctx, const jl_cgval_t &x)\n-{\n-    assert(x.ispointer());\n-    Value *data;\n-    if (x.constant) {\n-        Constant *val = julia_const_to_llvm(ctx, x.constant);\n-        if (val)\n-            data = get_pointer_to_constant(ctx.emission_context, val, Align(julia_alignment(jl_typeof(x.constant))), \"_j_const\", *jl_Module);\n-        else\n-            data = literal_pointer_val(ctx, x.constant);\n-    }\n-    else if (x.V == NULL) {\n-        // might be a ghost union with tindex but no actual pointer\n-        data = NULL;\n-    }\n-    else {\n-        data = maybe_decay_tracked(ctx, x.V);\n-    }\n-    return data;\n-}\n-\n static void emit_memcpy_llvm(jl_codectx_t &ctx, Value *dst, jl_aliasinfo_t const &dst_ai, Value *src,\n                              jl_aliasinfo_t const &src_ai, uint64_t sz, Align align_dst, Align align_src, bool is_volatile)\n {\n@@ -1013,20 +1162,6 @@ static void emit_memcpy_llvm(jl_codectx_t &ctx, Value *dst, jl_aliasinfo_t const\n                              merged_ai.tbaa, merged_ai.tbaa_struct, merged_ai.scope, merged_ai.noalias);\n }\n \n-static void emit_memcpy_llvm(jl_codectx_t &ctx, Value *dst, jl_aliasinfo_t const &dst_ai, Value *src,\n-                             jl_aliasinfo_t const &src_ai, Value *sz, Align align_dst, Align align_src, bool is_volatile)\n-{\n-    if (auto const_sz = dyn_cast<ConstantInt>(sz)) {\n-        emit_memcpy_llvm(ctx, dst, dst_ai, src, src_ai, const_sz->getZExtValue(), align_dst, align_src, is_volatile);\n-        return;\n-    }\n-    ++EmittedMemcpys;\n-\n-    auto merged_ai = dst_ai.merge(src_ai);\n-    ctx.builder.CreateMemCpy(dst, align_dst, src, align_src, sz, is_volatile,\n-                             merged_ai.tbaa, merged_ai.tbaa_struct, merged_ai.scope, merged_ai.noalias);\n-}\n-\n template<typename T1>\n static void emit_memcpy(jl_codectx_t &ctx, Value *dst, jl_aliasinfo_t const &dst_ai, Value *src,\n                         jl_aliasinfo_t const &src_ai, T1 &&sz, Align align_dst, Align align_src, bool is_volatile=false)\n@@ -1042,11 +1177,6 @@ static void emit_memcpy(jl_codectx_t &ctx, Value *dst, jl_aliasinfo_t const &dst\n     emit_memcpy_llvm(ctx, dst, dst_ai, data_pointer(ctx, src), src_ai, sz, align_dst, align_src, is_volatile);\n }\n \n-static bool allpointers(jl_datatype_t *typ)\n-{\n-    return jl_datatype_size(typ) == typ->layout->npointers * sizeof(void*);\n-}\n-\n // compute the space required by split_value_into, by simulating it\n // returns (sizeof(split_value), n_pointers)\n static std::pair<size_t,size_t> split_value_size(jl_datatype_t *typ)\n@@ -1056,14 +1186,15 @@ static std::pair<size_t,size_t> split_value_size(jl_datatype_t *typ)\n     bool hasptr = typ->layout->first_ptr >= 0;\n     size_t npointers = hasptr ? typ->layout->npointers : 0;\n     // drop the data pointer if the entire structure is just pointers\n-    // TODO: eventually we could drop the slots for the pointers from inside the\n+    // n.b.: eventually we could sometimes drop the slots for the pointers from inside the\n     //       types to pack it together, but this can change the alignment of the bits\n     //       in the fields inside, even if those bits have no pointers themselves. So\n     //       we would actually need to compute, for each pointer, whether any\n     //       subsequent field needed the extra alignment (for example, we can\n-    //       drop space for any runs of two/four pointer).  Some of these\n-    //       functions are already written in a way to support that, but not\n-    //       fully implemented yet.\n+    //       drop space for any runs of two/four pointer). But it would also\n+    //       require always copying the type, and not just extracting the\n+    //       inline_roots, which can be challenging and inefficient for the type\n+    //       to have multiple representations (even though more compact).\n     bool nodata = allpointers(typ);\n     if (nodata)\n         dst_off = 0;\n@@ -1072,27 +1203,37 @@ static std::pair<size_t,size_t> split_value_size(jl_datatype_t *typ)\n     return std::make_pair(dst_off, npointers);\n }\n \n+static void store_all_roots(jl_codectx_t &ctx, ArrayRef<Value*> inline_roots, Value *inline_roots_ptr, jl_aliasinfo_t const &roots_ai, bool isVolatileStore)\n+{\n+    // TODO: often we could skip stores of NULL\n+    for (size_t i = 0; i < inline_roots.size(); i++) {\n+        Value *unbox = inline_roots[i];\n+        roots_ai.decorateInst(ctx.builder.CreateAlignedStore(unbox, emit_ptrgep(ctx, inline_roots_ptr, i * sizeof(void*)), Align(sizeof(void*)), isVolatileStore));\n+    }\n+}\n+\n // take a value `x` and split its bits into dst and the roots into inline_roots\n static void split_value_into(jl_codectx_t &ctx, const jl_cgval_t &x, Align align_src, Value *dst, Align align_dst, jl_aliasinfo_t const &dst_ai, Value *inline_roots_ptr, jl_aliasinfo_t const &roots_ai, bool isVolatileStore=false)\n {\n+    if (x.isghost)\n+        return;\n     jl_datatype_t *typ = (jl_datatype_t*)x.typ;\n     assert(jl_is_concrete_type(x.typ));\n     auto src_ai = jl_aliasinfo_t::fromTBAA(ctx, x.tbaa);\n     Type *T_prjlvalue = ctx.types().T_prjlvalue;\n+    if (inline_roots_ptr == nullptr) {\n+        emit_unbox_store(ctx, x, dst, ctx.tbaa().tbaa_stack, align_src, align_dst, isVolatileStore);\n+        return;\n+    }\n     if (!x.inline_roots.empty()) {\n         auto sizes = split_value_size(typ);\n         if (sizes.first > 0)\n             emit_memcpy(ctx, dst, dst_ai, x.V, src_ai, sizes.first, align_dst, align_src, isVolatileStore);\n-        for (size_t i = 0; i < sizes.second; i++) {\n-            Value *unbox = x.inline_roots[i];\n-            roots_ai.decorateInst(ctx.builder.CreateAlignedStore(unbox, emit_ptrgep(ctx, inline_roots_ptr, i * sizeof(void*)), Align(sizeof(void*)), isVolatileStore));\n-        }\n+        store_all_roots(ctx, ArrayRef(x.inline_roots).slice(0, sizes.second), inline_roots_ptr, roots_ai, isVolatileStore);\n         return;\n     }\n-    if (inline_roots_ptr == nullptr) {\n-        emit_unbox_store(ctx, x, dst, ctx.tbaa().tbaa_stack, align_src, align_dst, isVolatileStore);\n+    if (x.V == nullptr && x.constant == nullptr)\n         return;\n-    }\n     Value *src = data_pointer(ctx, value_to_pointer(ctx, x));\n     bool isstack = isa<AllocaInst>(src->stripInBoundsOffsets()) || src_ai.tbaa == ctx.tbaa().tbaa_stack;\n     size_t dst_off = 0;\n@@ -1137,26 +1278,22 @@ static void split_value_into(jl_codectx_t &ctx, const jl_cgval_t &x, Align align\n     }\n }\n \n-static void split_value_into(jl_codectx_t &ctx, const jl_cgval_t &x, Align align_src, Value *dst, Align align_dst, jl_aliasinfo_t const &dst_ai, MutableArrayRef<Value*> inline_roots)\n+static void split_value_into(jl_codectx_t &ctx, const jl_cgval_t &x, Align align_src, Value *dst, Align align_dst, jl_aliasinfo_t const &dst_ai, bool isVolatileStore)\n {\n+    if (x.isghost)\n+        return;\n     jl_datatype_t *typ = (jl_datatype_t*)x.typ;\n     assert(jl_is_concrete_type(x.typ));\n     auto src_ai = jl_aliasinfo_t::fromTBAA(ctx, x.tbaa);\n-    Type *T_prjlvalue = ctx.types().T_prjlvalue;\n     if (!x.inline_roots.empty()) {\n         auto sizes = split_value_size(typ);\n         if (sizes.first > 0)\n-            emit_memcpy(ctx, dst, dst_ai, x.V, src_ai, sizes.first, align_dst, align_src);\n-        for (size_t i = 0; i < sizes.second; i++)\n-            inline_roots[i] = x.inline_roots[i];\n+            emit_memcpy(ctx, dst, dst_ai, x.V, src_ai, sizes.first, align_dst, align_src, isVolatileStore);\n         return;\n     }\n-    if (inline_roots.empty()) {\n-        emit_unbox_store(ctx, x, dst, ctx.tbaa().tbaa_stack, align_src, align_dst, false);\n+    if (x.V == nullptr && x.constant == nullptr)\n         return;\n-    }\n     Value *src = data_pointer(ctx, value_to_pointer(ctx, x));\n-    bool isstack = isa<AllocaInst>(src->stripInBoundsOffsets()) || src_ai.tbaa == ctx.tbaa().tbaa_stack;\n     size_t dst_off = 0;\n     size_t src_off = 0;\n     bool hasptr = typ->layout->first_ptr >= 0;\n@@ -1173,24 +1310,21 @@ static void split_value_into(jl_codectx_t &ctx, const jl_cgval_t &x, Align align\n                 src_ai,\n                 ptr - src_off,\n                 align_dst,\n-                align_src);\n+                align_src,\n+                isVolatileStore);\n             dst_off += ptr - src_off;\n         }\n         if (last)\n             break;\n-        auto *load = ctx.builder.CreateAlignedLoad(T_prjlvalue, emit_ptrgep(ctx, src, ptr), Align(sizeof(void*)));\n-        if (!isstack)\n-            load->setOrdering(AtomicOrdering::Unordered);\n-        src_ai.decorateInst(load);\n-        inline_roots[i] = load;\n         align_src = align_dst = Align(sizeof(void*));\n         src_off = ptr + sizeof(void*);\n         if (!nodata) {\n             // store an undef pointer here, to make sure nobody looks at this\n             dst_ai.decorateInst(ctx.builder.CreateAlignedStore(\n                 ctx.builder.getIntN(sizeof(void*) * 8, (uint64_t)-1),\n                 emit_ptrgep(ctx, dst, dst_off),\n-                align_src));\n+                align_src,\n+                isVolatileStore));\n             dst_off += sizeof(void*);\n             assert(dst_off == src_off);\n         }\n@@ -1202,10 +1336,18 @@ static std::pair<AllocaInst*, SmallVector<Value*,0>> split_value(jl_codectx_t &c\n     jl_datatype_t *typ = (jl_datatype_t*)x.typ;\n     auto sizes = split_value_size(typ);\n     Align align_dst(julia_alignment((jl_value_t*)typ));\n-    AllocaInst *bits = sizes.first > 0 ? emit_static_alloca(ctx, sizes.first, align_dst) : nullptr;\n-    SmallVector<Value*,0> roots(sizes.second);\n-    auto stack_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack);\n-    split_value_into(ctx, x, x_alignment, bits, align_dst, stack_ai, MutableArrayRef(roots));\n+    AllocaInst *bits = nullptr;\n+    if (sizes.first) {\n+        bits = emit_static_alloca(ctx, sizes.first, align_dst);\n+        auto stack_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack);\n+        split_value_into(ctx, x, x_alignment, bits, align_dst, stack_ai, false);\n+    }\n+    SmallVector<Value*,0> roots;\n+    if (sizes.second) {\n+        roots = extract_gc_roots(ctx, x, sizes.second);\n+        if (roots.size() < sizes.second)\n+            roots.resize(sizes.second, Constant::getNullValue(ctx.types().T_prjlvalue));\n+    }\n     return std::make_pair(bits, roots);\n }\n \n@@ -1223,7 +1365,8 @@ static std::pair<ssize_t,ssize_t> split_value_field(jl_datatype_t *typ, unsigned\n         if (ptr >= fldoff) {\n             if (ptr >= fldoff + jl_field_size(typ, idx))\n                 break;\n-            bool onlyptr = jl_field_isptr(typ, idx) || allpointers((jl_datatype_t*)jl_field_type(typ, idx));\n+            jl_value_t *ft = jl_field_type(typ, idx);\n+            bool onlyptr = jl_field_isptr(typ, idx) || (jl_is_datatype(ft) && allpointers((jl_datatype_t*)ft));\n             return std::make_pair(onlyptr ? -1 : dst_off + fldoff - src_off, i);\n         }\n         dst_off += ptr - src_off;\n@@ -1241,7 +1384,7 @@ static std::pair<ssize_t,ssize_t> split_value_field(jl_datatype_t *typ, unsigned\n static void recombine_value(jl_codectx_t &ctx, const jl_cgval_t &x, Value *dst, jl_aliasinfo_t const &dst_ai, Align alignment, bool isVolatileStore)\n {\n     jl_datatype_t *typ = (jl_datatype_t*)x.typ;\n-    assert(jl_is_concrete_type(x.typ));\n+    assert(jl_is_concrete_type(x.typ) && !x.isghost);\n     assert(typ->layout->first_ptr >= 0 && !x.inline_roots.empty());\n     Align align_dst = alignment;\n     Align align_src(julia_alignment(x.typ));\n@@ -1333,7 +1476,7 @@ static Value *emit_typeof(jl_codectx_t &ctx, const jl_cgval_t &p, bool maybenull\n     if (p.isboxed)\n         return emit_typeof(ctx, p.V, maybenull, justtag, notag(p.typ));\n     if (p.TIndex) {\n-        Value *tindex = ctx.builder.CreateAnd(p.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0x7f));\n+        Value *tindex = ctx.builder.CreateAnd(p.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER));\n         bool allunboxed = is_uniontype_allunboxed(p.typ);\n         Type *expr_type = justtag ? ctx.types().T_size : ctx.types().T_pjlvalue;\n         Value *datatype_or_p = Constant::getNullValue(PointerType::getUnqual(expr_type->getContext()));\n@@ -1650,6 +1793,8 @@ static void null_load_check(jl_codectx_t &ctx, Value *v, jl_module_t *scope, jl_\n         raise_exception_unless(ctx, notnull, literal_pointer_val(ctx, jl_undefref_exception));\n }\n \n+// ifnot == nullptr && return func()\n+// return (ifnot ? func() : defval)\n template<typename Func>\n static void emit_guarded_test(jl_codectx_t &ctx, Value *ifnot, MutableArrayRef<Value*> defval, Func &&func)\n {\n@@ -1818,9 +1963,11 @@ static bool can_optimize_isa_union(jl_uniontype_t *type)\n }\n \n // a simple case of emit_isa that is obvious not to include a safe-point\n-static Value *emit_exactly_isa(jl_codectx_t &ctx, const jl_cgval_t &arg, jl_datatype_t *dt, bool could_be_null=false)\n+static Value *emit_exactly_isa(jl_codectx_t &ctx, const jl_cgval_t &arg, jl_datatype_t *dt, bool could_be_null)\n {\n     assert(jl_is_concrete_type((jl_value_t*)dt) || is_uniquerep_Type((jl_value_t*)dt));\n+    if (arg.constant)\n+        return ConstantInt::get(getInt1Ty(ctx.builder.getContext()), jl_isa(arg.constant, (jl_value_t*)dt));\n     if (arg.TIndex) {\n         unsigned tindex = get_box_tindex(dt, arg.typ);\n         if (tindex > 0) {\n@@ -2115,15 +2262,6 @@ static Value *emit_bounds_check(jl_codectx_t &ctx, const jl_cgval_t &ainfo, jl_v\n     return im1;\n }\n \n-static Value *CreateSimplifiedExtractValue(jl_codectx_t &ctx, Value *Agg, ArrayRef<unsigned> Idxs)\n-{\n-    // aka IRBuilder<InstSimplifyFolder>\n-    SimplifyQuery SQ(jl_Module->getDataLayout()); // not actually used, but required by API\n-    if (Value *Inst = simplifyExtractValueInst(Agg, Idxs, SQ))\n-        return Inst;\n-    return ctx.builder.CreateExtractValue(Agg, Idxs);\n-}\n-\n static void emit_write_barrier(jl_codectx_t&, Value*, ArrayRef<Value*>);\n static void emit_write_barrier(jl_codectx_t&, Value*, Value*);\n static void emit_write_multibarrier(jl_codectx_t&, Value*, Value*, jl_value_t*);\n@@ -2227,11 +2365,12 @@ static jl_cgval_t typed_load(jl_codectx_t &ctx, Value *ptr, Value *idx_0based, j\n         }\n     }\n     Value *instr = nullptr;\n-    if (!isboxed && jl_is_genericmemoryref_type(jltype)) {\n+    if (Order == AtomicOrdering::NotAtomic && !isboxed && jl_is_genericmemoryref_type(jltype)) {\n         //We don't specify the stronger expected memory ordering here because of fears it may interfere with vectorization and other optimizations\n         //if (Order == AtomicOrdering::NotAtomic)\n         //    Order = AtomicOrdering::Monotonic;\n         // load these FCA as individual fields, so LLVM does not need to split them later\n+        // and doesn't go on the stack (which may thwart gc_loaded later)\n         Value *fld0 = ctx.builder.CreateStructGEP(elty, ptr, 0);\n         LoadInst *load0 = ctx.builder.CreateAlignedLoad(elty->getStructElementType(0), fld0, Align(alignment), false);\n         load0->setOrdering(Order);\n@@ -2247,6 +2386,9 @@ static jl_cgval_t typed_load(jl_codectx_t &ctx, Value *ptr, Value *idx_0based, j\n         instr = Constant::getNullValue(elty);\n         instr = ctx.builder.CreateInsertValue(instr, load0, 0);\n         instr = ctx.builder.CreateInsertValue(instr, load1, 1);\n+        if (maybe_null_if_boxed)\n+            null_pointer_check(ctx, load1, nullcheck);\n+        return jl_cgval_t(instr, jltype, NULL);\n     }\n     else {\n         LoadInst *load = ctx.builder.CreateAlignedLoad(elty, ptr, Align(alignment), false);\n@@ -2299,7 +2441,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n         bool maybe_null_if_boxed, const jl_cgval_t *modifyop, const Twine &fname,\n         jl_module_t *mod, jl_sym_t *var)\n {\n-    auto newval = [&](const jl_cgval_t &lhs) {\n+    auto newval = [&](const jl_cgval_t &lhs) { // for ismodifyfield\n         const jl_cgval_t argv[3] = { cmpop, lhs, rhs };\n         jl_cgval_t ret;\n         if (modifyop) {\n@@ -2380,7 +2522,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n             r = ctx.builder.CreateLoad(realelty, intcast);\n         }\n         else if (aliasscope || Order != AtomicOrdering::NotAtomic || (tracked_pointers && rhs.inline_roots.empty())) {\n-            r = emit_unbox(ctx, realelty, rhs, jltype);\n+            r = emit_unbox(ctx, realelty, rhs);\n         }\n         if (realelty != elty)\n             r = ctx.builder.CreateZExt(r, elty);\n@@ -2451,7 +2593,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n             // if this value can be loaded from memory, do that now so that it is sequenced before the atomicmodify\n             // and the IR is less dependent on what was emitted before now to create this rhs.\n             // Inlining should do okay to clean this up later if there are parts we don't need.\n-            rhs = jl_cgval_t(emit_unbox(ctx, julia_type_to_llvm(ctx, rhs.typ), rhs, rhs.typ), rhs.typ, NULL);\n+            rhs = jl_cgval_t(emit_unbox(ctx, julia_type_to_llvm(ctx, rhs.typ), rhs), rhs.typ, NULL);\n         }\n         bool gcstack_arg = JL_FEAT_TEST(ctx,gcstack_arg);\n         Function *op = emit_modifyhelper(ctx, cmpop, *modifyop, jltype, elty, rhs, fname, gcstack_arg);\n@@ -2522,7 +2664,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n                     Compare = ctx.builder.CreateLoad(realelty, intcast);\n                 }\n                 else {\n-                    Compare = emit_unbox(ctx, realelty, cmpop, jltype);\n+                    Compare = emit_unbox(ctx, realelty, cmpop);\n                 }\n                 if (realelty != elty)\n                     Compare = ctx.builder.CreateZExt(Compare, elty);\n@@ -2595,7 +2737,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n                     ctx.builder.CreateStore(realCompare, intcast);\n             }\n             else if (Order != AtomicOrdering::NotAtomic || (tracked_pointers && rhs.inline_roots.empty())) {\n-                r = emit_unbox(ctx, realelty, rhs, jltype);\n+                r = emit_unbox(ctx, realelty, rhs);\n             }\n             if (realelty != elty)\n                 r = ctx.builder.CreateZExt(r, elty);\n@@ -2726,7 +2868,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n             else if (!isboxed && intcast_eltyp) {\n                 assert(issetfield);\n                 // issetfield doesn't use intcast, so need to reload rhs with the correct type\n-                r = emit_unbox(ctx, intcast_eltyp, rhs, jltype);\n+                r = emit_unbox(ctx, intcast_eltyp, rhs);\n             }\n             if (!isboxed)\n                 emit_write_multibarrier(ctx, parent, r, rhs.typ);\n@@ -3532,7 +3674,7 @@ static Value *call_with_attrs(jl_codectx_t &ctx, JuliaFunction<TypeFn_t> *intr,\n static Value *as_value(jl_codectx_t &ctx, Type *to, const jl_cgval_t &v)\n {\n     assert(!v.isboxed);\n-    return emit_unbox(ctx, to, v, v.typ);\n+    return emit_unbox(ctx, to, v);\n }\n \n static Value *load_i8box(jl_codectx_t &ctx, Value *v, jl_datatype_t *ty)\n@@ -3612,20 +3754,28 @@ static Value *_boxed_special(jl_codectx_t &ctx, const jl_cgval_t &vinfo, Type *t\n     return box;\n }\n \n-static Value *compute_box_tindex(jl_codectx_t &ctx, Value *datatype_tag, jl_value_t *supertype, jl_value_t *ut)\n+static Value *compute_box_tindex(jl_codectx_t &ctx, const jl_cgval_t &val, jl_value_t *ut, bool maybenull=false)\n {\n+    jl_value_t *supertype = val.typ;\n+    Value *datatype_tag = NULL;\n+    auto maybe_setup_union_isa = [&]() {\n+        if (datatype_tag == nullptr)\n+            datatype_tag = emit_typeof(ctx, val, maybenull, true);\n+    };\n     Value *tindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0);\n     unsigned counter = 0;\n     for_each_uniontype_small(\n             [&](unsigned idx, jl_datatype_t *jt) {\n                 if (jl_subtype((jl_value_t*)jt, supertype)) {\n+                    maybe_setup_union_isa();\n                     Value *cmp = ctx.builder.CreateICmpEQ(emit_tagfrom(ctx, jt), datatype_tag);\n                     tindex = ctx.builder.CreateSelect(cmp, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), idx), tindex);\n                 }\n             },\n             ut,\n             counter);\n-    setName(ctx.emission_context, tindex, datatype_tag->getName() + \".tindex\");\n+    if (datatype_tag)\n+        setName(ctx.emission_context, tindex, datatype_tag->getName() + \".tindex\");\n     return tindex;\n }\n \n@@ -3638,30 +3788,35 @@ static Value *compute_tindex_unboxed(jl_codectx_t &ctx, const jl_cgval_t &val, j\n         return ConstantInt::get(getInt8Ty(ctx.builder.getContext()), get_box_tindex((jl_datatype_t*)jl_typeof(val.constant), typ));\n     if (val.TIndex)\n         return ctx.builder.CreateAnd(val.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0x7f));\n-    Value *typof = emit_typeof(ctx, val, maybenull, true);\n-    return compute_box_tindex(ctx, typof, val.typ, typ);\n+    return compute_box_tindex(ctx, val, typ, maybenull);\n }\n \n \n static void union_alloca_type(jl_uniontype_t *ut,\n-        bool &allunbox, size_t &nbytes, size_t &align, size_t &min_align)\n+        bool &allunbox, size_t &nbytes, size_t &align, size_t &min_align, size_t &inline_roots)\n {\n     nbytes = 0;\n     align = 0;\n     min_align = MAX_ALIGN;\n+    inline_roots = 0;\n     // compute the size of the union alloca that could hold this type\n     unsigned counter = 0;\n     allunbox = for_each_uniontype_small(\n             [&](unsigned idx, jl_datatype_t *jt) {\n                 if (!jl_is_datatype_singleton(jt)) {\n+                    //size_t nb1, n_roots;\n+                    //std::tie(nb1, n_roots) = split_value_size(jt); // TODO: deal with using this later\n                     size_t nb1 = jl_datatype_size(jt);\n+                    size_t n_roots = jl_datatype_layout(jt)->npointers;\n                     size_t align1 = julia_alignment((jl_value_t*)jt);\n                     if (nb1 > nbytes)\n                         nbytes = nb1;\n                     if (align1 > align)\n                         align = align1;\n                     if (align1 < min_align)\n                         min_align = align1;\n+                    if (n_roots > inline_roots)\n+                        inline_roots = n_roots;\n                 }\n             },\n             (jl_value_t*)ut,\n@@ -3670,10 +3825,10 @@ static void union_alloca_type(jl_uniontype_t *ut,\n         align = JL_HEAP_ALIGNMENT;\n }\n \n-static AllocaInst *try_emit_union_alloca(jl_codectx_t &ctx, jl_uniontype_t *ut, bool &allunbox, size_t &min_align, size_t &nbytes)\n+static AllocaInst *try_emit_union_alloca(jl_codectx_t &ctx, jl_uniontype_t *ut, bool &allunbox, size_t &min_align, size_t &nbytes, size_t &inline_roots)\n {\n     size_t align;\n-    union_alloca_type(ut, allunbox, nbytes, align, min_align);\n+    union_alloca_type(ut, allunbox, nbytes, align, min_align, inline_roots);\n     if (nbytes > 0) {\n         // at least some of the values can live on the stack\n         assert(align % min_align == 0);\n@@ -3729,7 +3884,11 @@ static Value *box_union(jl_codectx_t &ctx, const jl_cgval_t &vinfo, const SmallB\n                     box = track_pjlvalue(ctx, literal_pointer_val(ctx, jt->instance));\n                 }\n                 else {\n-                    jl_cgval_t vinfo_r = jl_cgval_t(vinfo, (jl_value_t*)jt, NULL);\n+                    jl_cgval_t vinfo_r = update_julia_type(ctx, vinfo, (jl_value_t*)jt);\n+                    if (vinfo_r.typ == jl_bottom_type) {\n+                        ctx.builder.CreateUnreachable();\n+                        return;\n+                    }\n                     box = _boxed_special(ctx, vinfo_r, t);\n                     if (!box) {\n                         box = emit_allocobj(ctx, jt, true);\n@@ -3893,40 +4052,43 @@ static Value *boxed(jl_codectx_t &ctx, const jl_cgval_t &vinfo, bool is_promotab\n }\n \n // copy src to dest, if src is justbits. if skip is true, the value of dest is undefined\n-static void emit_unionmove(jl_codectx_t &ctx, Value *dest, MDNode *tbaa_dst, const jl_cgval_t &src, Value *skip, bool isVolatile=false)\n+// TODO: rename this to just `emit_typed_move`\n+static void emit_unionmove(jl_codectx_t &ctx, Value *dest, jl_value_t *desttype,\n+        MDNode *tbaa_dst, const jl_cgval_t &src, Value *skip, bool isVolatile=false)\n {\n     if (AllocaInst *ai = dyn_cast<AllocaInst>(dest))\n         // TODO: make this a lifetime_end & dereferenceable annotation?\n         ctx.builder.CreateAlignedStore(UndefValue::get(ai->getAllocatedType()), ai, ai->getAlign());\n+    auto dest_ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa_dst);\n     if (src.constant) {\n         jl_value_t *typ = jl_typeof(src.constant);\n-        assert(skip || jl_is_pointerfree(typ));\n-        if (jl_is_pointerfree(typ)) {\n-            emit_guarded_test(ctx, skip, nullptr, [&] {\n+        assert(skip || deserves_stack(typ));\n+        if (jl_is_concrete_immutable(typ)) {\n+            emit_guarded_test(ctx, skip ? ctx.builder.CreateNot(skip) : nullptr, nullptr, [&] {\n                 unsigned alignment = julia_alignment(typ);\n-                emit_unbox_store(ctx, mark_julia_const(ctx, src.constant), dest, tbaa_dst, Align(alignment), Align(alignment), isVolatile);\n+                split_value_into(ctx, mark_julia_const(ctx, src.constant), Align(alignment), dest, Align(alignment), dest_ai, isVolatile);\n                 return nullptr;\n             });\n         }\n     }\n     else if (jl_is_concrete_type(src.typ)) {\n-        assert(skip || jl_is_pointerfree(src.typ));\n-        if (jl_is_pointerfree(src.typ)) {\n-            emit_guarded_test(ctx, skip, nullptr, [&] {\n+        assert(skip || deserves_stack(src.typ));\n+        if (jl_is_concrete_immutable(src.typ)) {\n+            emit_guarded_test(ctx, skip ? ctx.builder.CreateNot(skip) : nullptr, nullptr, [&] {\n                 unsigned alignment = julia_alignment(src.typ);\n-                emit_unbox_store(ctx, src, dest, tbaa_dst, Align(alignment), Align(alignment), isVolatile);\n+                split_value_into(ctx, src, Align(alignment), dest, Align(alignment), dest_ai, isVolatile);\n                 return nullptr;\n             });\n         }\n     }\n-    else if (src.TIndex) {\n-        Value *tindex = ctx.builder.CreateAnd(src.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0x7f));\n+    else {\n+        Value *tindex = compute_tindex_unboxed(ctx, src, desttype, skip != nullptr);\n         if (skip)\n             tindex = ctx.builder.CreateSelect(skip, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0), tindex);\n-        Value *src_ptr = data_pointer(ctx, src);\n         BasicBlock *defaultBB = BasicBlock::Create(ctx.builder.getContext(), \"union_move_skip\", ctx.f);\n         SwitchInst *switchInst = ctx.builder.CreateSwitch(tindex, defaultBB);\n         BasicBlock *postBB = BasicBlock::Create(ctx.builder.getContext(), \"post_union_move\", ctx.f);\n+        ctx.builder.SetInsertPoint(postBB);\n         unsigned counter = 0;\n         bool allunboxed = for_each_uniontype_small(\n                 [&](unsigned idx, jl_datatype_t *jt) {\n@@ -3936,21 +4098,13 @@ static void emit_unionmove(jl_codectx_t &ctx, Value *dest, MDNode *tbaa_dst, con\n                     ctx.builder.SetInsertPoint(tempBB);\n                     switchInst->addCase(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), idx), tempBB);\n                     if (nb > 0) {\n-                        if (!src_ptr) {\n-                            Function *trap_func =\n-#if JL_LLVM_VERSION >= 200000\n-                                Intrinsic::getOrInsertDeclaration(ctx.f->getParent(), Intrinsic::trap);\n-#else\n-                                Intrinsic::getDeclaration(ctx.f->getParent(), Intrinsic::trap);\n-#endif\n-                            ctx.builder.CreateCall(trap_func);\n-                            ctx.builder.CreateUnreachable();\n-                            return;\n-                        } else {\n-                            emit_memcpy(ctx, dest, jl_aliasinfo_t::fromTBAA(ctx, tbaa_dst), src_ptr,\n-                                        jl_aliasinfo_t::fromTBAA(ctx, src.tbaa), nb, Align(alignment), Align(alignment), isVolatile);\n+                        jl_cgval_t src_pi = update_julia_type(ctx, src, (jl_value_t*)jt);\n+                        if (src_pi.typ != jl_bottom_type) {\n+                            split_value_into(ctx, src_pi, Align(alignment), dest, Align(alignment), dest_ai, isVolatile);\n                         }\n                     }\n+                    tempBB = ctx.builder.GetInsertBlock();\n+\n                     ctx.builder.CreateBr(postBB);\n                 },\n                 src.typ,\n@@ -3968,20 +4122,11 @@ static void emit_unionmove(jl_codectx_t &ctx, Value *dest, MDNode *tbaa_dst, con\n             ctx.builder.CreateUnreachable();\n         }\n         else {\n+\n             ctx.builder.CreateBr(postBB);\n         }\n         ctx.builder.SetInsertPoint(postBB);\n     }\n-    else {\n-        assert(src.isboxed && \"expected boxed value for sizeof/alignment computation\");\n-        emit_guarded_test(ctx, skip, nullptr, [&] {\n-            Value *datatype = emit_typeof(ctx, src, false, false);\n-            Value *copy_bytes = emit_datatype_size(ctx, datatype);\n-            emit_memcpy(ctx, dest, jl_aliasinfo_t::fromTBAA(ctx, tbaa_dst), data_pointer(ctx, src),\n-                        jl_aliasinfo_t::fromTBAA(ctx, src.tbaa), copy_bytes, Align(1), Align(1), isVolatile);\n-            return nullptr;\n-        });\n-    }\n }\n \n \n@@ -4065,7 +4210,7 @@ static void emit_write_multibarrier(jl_codectx_t &ctx, Value *parent, Value *agg\n     SmallVector<unsigned,4> perm_offsets;\n     if (jltype && jl_is_datatype(jltype) && ((jl_datatype_t*)jltype)->layout)\n         find_perm_offsets((jl_datatype_t*)jltype, perm_offsets, 0);\n-    auto ptrs = ExtractTrackedValues(agg, agg->getType(), false, ctx.builder, perm_offsets);\n+    auto ptrs = ExtractTrackedValues(ctx, agg, perm_offsets);\n     emit_write_barrier(ctx, parent, ptrs);\n }\n \n@@ -4085,11 +4230,26 @@ static jl_cgval_t union_store(jl_codectx_t &ctx,\n     assert(Order == AtomicOrdering::NotAtomic);\n     if (issetfieldonce)\n         return mark_julia_const(ctx, jl_false);\n+    auto newval = [&](const jl_cgval_t &lhs) { // for ismodifyfield\n+        const jl_cgval_t argv[3] = { cmp, lhs, rhs };\n+        jl_cgval_t ret;\n+        if (modifyop) {\n+            ret = emit_invoke(ctx, *modifyop, argv, 3, (jl_value_t*)jl_any_type, true);\n+        }\n+        else {\n+            Value *callval = emit_jlcall(ctx, jlapplygeneric_func, nullptr, argv, 3, julia_call);\n+            ret = mark_julia_type(ctx, callval, true, jl_any_type);\n+        }\n+        emit_typecheck(ctx, ret, jltype, fname);\n+        ret = update_julia_type(ctx, ret, jltype);\n+        return ret;\n+    };\n     size_t fsz = 0, al = 0;\n     int union_max = jl_islayout_inline(jltype, &fsz, &al);\n     assert(union_max > 0);\n-    // compute tindex from rhs\n-    jl_cgval_t rhs_union = convert_julia_type(ctx, rhs, jltype);\n+    jl_cgval_t rhs_union = rhs;\n+    if (!ismodifyfield)\n+        rhs_union = convert_julia_type_to_union(ctx, rhs_union, jltype, false);\n     if (rhs_union.typ == jl_bottom_type)\n         return jl_cgval_t();\n     if (needlock)\n@@ -4100,7 +4260,7 @@ static jl_cgval_t union_store(jl_codectx_t &ctx,\n         ctx.builder.CreateBr(ModifyBB);\n         ctx.builder.SetInsertPoint(ModifyBB);\n     }\n-    jl_cgval_t oldval = rhs;\n+    jl_cgval_t oldval = rhs; // issetfield returns rhs\n     if (!issetfield)\n         oldval = emit_unionload(ctx, ptr, ptindex, jltype, fsz, al, tbaa, true, union_max, tbaa_tindex);\n     Value *Success = NULL;\n@@ -4109,17 +4269,8 @@ static jl_cgval_t union_store(jl_codectx_t &ctx,\n         if (ismodifyfield) {\n             if (needlock)\n                 emit_lockstate_value(ctx, needlock, false);\n-            const jl_cgval_t argv[3] = { cmp, oldval, rhs };\n-            if (modifyop) {\n-                rhs = emit_invoke(ctx, *modifyop, argv, 3, (jl_value_t*)jl_any_type, true);\n-            }\n-            else {\n-                Value *callval = emit_jlcall(ctx, jlapplygeneric_func, nullptr, argv, 3, julia_call);\n-                rhs = mark_julia_type(ctx, callval, true, jl_any_type);\n-            }\n-            emit_typecheck(ctx, rhs, jltype, fname);\n-            rhs = update_julia_type(ctx, rhs, jltype);\n-            rhs_union = convert_julia_type(ctx, rhs, jltype);\n+            rhs = newval(oldval);\n+            rhs_union = convert_julia_type_to_union(ctx, rhs, jltype, false);\n             if (rhs_union.typ == jl_bottom_type)\n                 return jl_cgval_t();\n             if (needlock)\n@@ -4133,13 +4284,13 @@ static jl_cgval_t union_store(jl_codectx_t &ctx,\n         ctx.builder.CreateCondBr(Success, XchgBB, ismodifyfield ? ModifyBB : DoneBB);\n         ctx.builder.SetInsertPoint(XchgBB);\n     }\n-    Value *tindex = compute_tindex_unboxed(ctx, rhs_union, jltype);\n+    Value *tindex = ctx.builder.CreateAnd(rhs_union.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER));\n     tindex = ctx.builder.CreateNUWSub(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 1));\n     jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa_tindex);\n     ai.decorateInst(ctx.builder.CreateAlignedStore(tindex, ptindex, Align(1)));\n     // copy data\n     if (!rhs.isghost) {\n-        emit_unionmove(ctx, ptr, tbaa, rhs, nullptr);\n+        emit_unionmove(ctx, ptr, jltype, tbaa, rhs, /*skip*/nullptr);\n     }\n     if (isreplacefield || ismodifyfield) {\n         ctx.builder.CreateBr(DoneBB);\n@@ -4203,7 +4354,6 @@ static jl_cgval_t emit_setfield(jl_codectx_t &ctx,\n static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t nargs, ArrayRef<jl_cgval_t> argv, bool is_promotable)\n {\n     ++EmittedNewStructs;\n-    assert(jl_is_datatype(ty));\n     assert(jl_is_concrete_type(ty));\n     jl_datatype_t *sty = (jl_datatype_t*)ty;\n     auto arg_typename = [&] JL_NOTSAFEPOINT {\n@@ -4319,14 +4469,15 @@ static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t narg\n                         else {\n                             roots[0] = fval;\n                         }\n+                        roots = roots.slice(0, 0);\n                     }\n                 }\n                 else if (jl_is_uniontype(jtype)) {\n                     // compute tindex from rhs\n-                    jl_cgval_t rhs_union = convert_julia_type(ctx, fval_info, jtype);\n+                    jl_cgval_t rhs_union = convert_julia_type_to_union(ctx, fval_info, jtype, false);\n                     if (rhs_union.typ == jl_bottom_type)\n                         return jl_cgval_t();\n-                    Value *tindex = compute_tindex_unboxed(ctx, rhs_union, jtype);\n+                    Value *tindex = ctx.builder.CreateAnd(rhs_union.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER));\n                     tindex = ctx.builder.CreateNUWSub(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 1));\n                     size_t fsz = 0, al = 0;\n                     bool isptr = !jl_islayout_inline(jtype, &fsz, &al);\n@@ -4343,7 +4494,7 @@ static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t narg\n                             assert(lt->getStructElementType(llvm_idx) == ET);\n                             AllocaInst *lv = emit_static_alloca(ctx, fsz1, Align(al));\n                             setName(ctx.emission_context, lv, \"unioninit\");\n-                            emit_unionmove(ctx, lv, ctx.tbaa().tbaa_stack, fval_info, nullptr);\n+                            emit_unionmove(ctx, lv, jtype, ctx.tbaa().tbaa_stack, fval_info, /*skip*/nullptr);\n                             // emit all of the align-sized words\n                             unsigned i = 0;\n                             for (; i < fsz1 / al; i++) {\n@@ -4373,24 +4524,30 @@ static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t narg\n                         jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_unionselbyte);\n                         ai.decorateInst(ctx.builder.CreateAlignedStore(tindex, ptindex, Align(1)));\n                         if (!rhs_union.isghost)\n-                            emit_unionmove(ctx, dest, ctx.tbaa().tbaa_stack, fval_info, nullptr);\n+                            emit_unionmove(ctx, dest, jtype, ctx.tbaa().tbaa_stack, fval_info, /*skip*/nullptr);\n                     }\n+                    assert(roots.empty());\n                 }\n                 else {\n+                    assert(jl_is_concrete_type(jtype) && fval_info.typ == jtype);\n                     Align align_dst(jl_field_align(sty, i));\n                     Align align_src(julia_alignment(jtype));\n                     if (field_promotable) {\n                         fval_info.V->replaceAllUsesWith(dest);\n                         cast<Instruction>(fval_info.V)->eraseFromParent();\n                     }\n                     else if (init_as_value) {\n-                        fval = emit_unbox(ctx, fty, fval_info, jtype);\n-                    }\n-                    else if (!roots.empty()) {\n-                        split_value_into(ctx, fval_info, align_src, dest, align_dst, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack), roots);\n+                        fval = emit_unbox(ctx, fty, fval_info);\n                     }\n                     else {\n-                        emit_unbox_store(ctx, fval_info, dest, ctx.tbaa().tbaa_stack, align_src, align_dst);\n+                        if (!roots.empty() && fval_info.inline_roots.empty())\n+                            fval_info = value_to_pointer(ctx, fval_info);\n+                        split_value_into(ctx, fval_info, align_src, dest, align_dst, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack), false);\n+                        if (!roots.empty()) {\n+                            auto inline_roots = extract_gc_roots(ctx, fval_info, roots.size());\n+                            for (size_t i = 0; i < inline_roots.size(); i++)\n+                                roots[i] = inline_roots[i];\n+                        }\n                     }\n                 }\n                 if (init_as_value) {\n@@ -4637,7 +4794,7 @@ static jl_cgval_t emit_memorynew(jl_codectx_t &ctx, jl_datatype_t *typ, jl_cgval\n     emptymemBB = BasicBlock::Create(ctx.builder.getContext(), \"emptymem\");\n     nonemptymemBB = BasicBlock::Create(ctx.builder.getContext(), \"nonemptymem\");\n     retvalBB = BasicBlock::Create(ctx.builder.getContext(), \"retval\");\n-    auto nel_unboxed = emit_unbox(ctx, ctx.types().T_size, nel, (jl_value_t*)jl_long_type);\n+    auto nel_unboxed = emit_unbox(ctx, ctx.types().T_size, nel);\n     Value *memorynew_empty = ctx.builder.CreateICmpEQ(nel_unboxed, ConstantInt::get(T_size, 0));\n     setName(ctx.emission_context, memorynew_empty, \"memorynew_empty\");\n     ctx.builder.CreateCondBr(memorynew_empty, emptymemBB, nonemptymemBB);\n@@ -4724,7 +4881,11 @@ static jl_cgval_t emit_memoryref_direct(jl_codectx_t &ctx, const jl_cgval_t &mem\n     bool isunion = layout->flags.arrayelem_isunion;\n     bool isghost = layout->size == 0;\n     Value *boxmem = boxed(ctx, mem);\n-    Value *i = emit_unbox(ctx, ctx.types().T_size, idx, (jl_value_t*)jl_long_type);\n+    emit_typecheck(ctx, idx, (jl_value_t*)jl_long_type, \"memoryrefnew\");\n+    idx = update_julia_type(ctx, idx, (jl_value_t*)jl_long_type);\n+    if (idx.typ == jl_bottom_type)\n+        return jl_cgval_t();\n+    Value *i = emit_unbox(ctx, ctx.types().T_size, idx);\n     Value *idx0 = ctx.builder.CreateSub(i, ConstantInt::get(ctx.types().T_size, 1));\n     bool bc = bounds_check_enabled(ctx, inbounds);\n     if (bc) {\n@@ -4798,7 +4959,7 @@ static jl_cgval_t emit_memoryref(jl_codectx_t &ctx, const jl_cgval_t &ref, jl_cg\n     maybeSetName(ctx.emission_context, data, \"memoryref_data\");\n     Value *mem = CreateSimplifiedExtractValue(ctx, V, 1);\n     maybeSetName(ctx.emission_context, mem, \"memoryref_mem\");\n-    Value *i = emit_unbox(ctx, ctx.types().T_size, idx, (jl_value_t*)jl_long_type);\n+    Value *i = emit_unbox(ctx, ctx.types().T_size, idx);\n     Value *offset = ctx.builder.CreateSub(i, ConstantInt::get(ctx.types().T_size, 1));\n     setName(ctx.emission_context, offset, \"memoryref_offset\");\n     Value *elsz = emit_genericmemoryelsize(ctx, mem, ref.typ, false);"
    },
    {
      "sha": "6cf32a9d34bbabfe55d4afb8618eccc58d7eb590",
      "filename": "src/codegen.cpp",
      "status": "modified",
      "additions": 548,
      "deletions": 389,
      "changes": 937,
      "blob_url": "https://github.com/JuliaLang/julia/blob/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fcodegen.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fcodegen.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcodegen.cpp?ref=95c412a8058d723d2f1632fba005ed6dfbd5901f",
      "patch": "@@ -1598,6 +1598,19 @@ static bool jl_is_pointerfree(jl_value_t* t)\n     return layout && layout->npointers == 0;\n }\n \n+static bool allpointers(size_t size, size_t npointers)\n+{\n+    return size == npointers * sizeof(void*);\n+}\n+\n+static bool allpointers(jl_datatype_t *typ)\n+{\n+    return allpointers(jl_datatype_size(typ), typ->layout->npointers);\n+}\n+\n+static unsigned get_box_tindex(jl_datatype_t *jt, jl_value_t *ut);\n+\n+\n // these queries are usually related, but we split them out here\n // for convenience and clarity (and because it changes the calling convention)\n // n.b. this must include jl_is_datatype_singleton (ghostType) and primitive types\n@@ -1606,7 +1619,7 @@ static bool deserves_stack(jl_value_t* t)\n     if (!jl_is_concrete_immutable(t))\n         return false;\n     jl_datatype_t *dt = (jl_datatype_t*)t;\n-    return jl_is_datatype_singleton(dt) || jl_datatype_isinlinealloc(dt, 0);\n+    return jl_is_datatype_singleton(dt) || jl_datatype_isinlinealloc(dt, /* (require) pointerfree */ 0);\n }\n static bool deserves_argbox(jl_value_t* t)\n {\n@@ -1616,11 +1629,17 @@ static bool deserves_retbox(jl_value_t* t)\n {\n     return deserves_argbox(t);\n }\n+static bool deserves_unionbox(jl_value_t* t)\n+{\n+    return !deserves_stack(t);\n+}\n static bool deserves_sret(jl_value_t *dt, Type *T)\n {\n     assert(jl_is_datatype(dt));\n     return (size_t)jl_datatype_size(dt) > sizeof(void*) && !T->isFloatingPointTy() && !T->isVectorTy();\n }\n+static void union_alloca_type(jl_uniontype_t *ut,\n+        bool &allunbox, size_t &nbytes, size_t &align, size_t &min_align, size_t &inline_roots);\n \n // Alias Analysis Info (analogous to llvm::AAMDNodes)\n struct jl_aliasinfo_t {\n@@ -1758,7 +1777,6 @@ struct jl_cgval_t {\n         if (Vboxed)\n             assert(Vboxed->getType() == JuliaType::get_prjlvalue_ty(Vboxed->getContext()));\n         assert(tbaa != nullptr);\n-        assert(!(isboxed && TIndex != nullptr));\n         assert(TIndex == nullptr || TIndex->getType() == getInt8Ty(TIndex->getContext()));\n     }\n     explicit jl_cgval_t(jl_value_t *typ) : // ghost value constructor\n@@ -1801,6 +1819,38 @@ struct jl_cgval_t {\n         else {\n             assert(isboxed || v.typ == typ || tindex);\n         }\n+        // discard roots that do not apply anymore\n+        // or drop this whole value if there are not enough roots to populate it\n+        if (!inline_roots.empty()) {\n+            size_t inline_roots_count;\n+            bool justpointers = false;\n+            if (tindex) {\n+                bool allunbox;\n+                size_t nbytes, align, min_align;\n+                union_alloca_type((jl_uniontype_t*)typ, allunbox, nbytes, align, min_align, inline_roots_count);\n+                justpointers = allpointers(nbytes, inline_roots_count);\n+                if (inline_roots_count > inline_roots.size())\n+                    inline_roots_count = inline_roots.size();\n+            }\n+            else if (!deserves_stack(typ)) {\n+                inline_roots_count = 0;\n+            }\n+            else {\n+                const jl_datatype_layout_t *layout = ((jl_datatype_t*)typ)->layout;\n+                inline_roots_count = layout ? layout->npointers : 0;\n+                justpointers = layout ? allpointers((jl_datatype_t*)typ) : 0;\n+            }\n+            assert(v.TIndex || inline_roots.size() == inline_roots_count);\n+            if (V == nullptr && constant == nullptr && !isghost && (inline_roots_count == 0 || (!tindex && !justpointers)))\n+                *this = jl_cgval_t(); // no data to populate this value\n+            else if (inline_roots_count < inline_roots.size())\n+                inline_roots.truncate(inline_roots_count);\n+            else if (inline_roots_count > inline_roots.size())\n+                *this = jl_cgval_t(); // not enough roots to populate this value\n+            // drop data if all of the content is in the roots\n+            if (inline_roots_count > 0 && justpointers && Vboxed == nullptr)\n+                V = nullptr;\n+        }\n     }\n     explicit jl_cgval_t() : // undef / unreachable constructor\n         V(nullptr),\n@@ -1824,6 +1874,7 @@ struct jl_varinfo_t {\n     jl_cgval_t value; // a stack slot or constant value\n     Value *pTIndex; // i8* stack slot for the value.TIndex tag describing `value.V`\n     AllocaInst *inline_roots; // stack roots for the inline_roots array, if needed\n+    size_t inline_roots_count;\n     DILocalVariable *dinfo;\n     // if the variable might be used undefined and is not boxed\n     // this i1 flag is true when it is defined\n@@ -1838,6 +1889,7 @@ struct jl_varinfo_t {\n                      value(jl_cgval_t()),\n                      pTIndex(nullptr),\n                      inline_roots(nullptr),\n+                     inline_roots_count(0),\n                      dinfo(nullptr),\n                      defFlag(nullptr),\n                      isSA(false),\n@@ -2243,6 +2295,7 @@ static bool valid_as_globalinit(const Value *v) {\n }\n \n static Value *zext_struct(jl_codectx_t &ctx, Value *V);\n+static std::pair<AllocaInst*, SmallVector<Value*,0>> split_value(jl_codectx_t &ctx, const jl_cgval_t &x, Align x_alignment);\n \n // TODO: in the future, assume all callers will handle the interior pointers separately, and have\n // have zext_struct strip them out, so we aren't saving those to the stack here causing shadow stores\n@@ -2279,7 +2332,7 @@ static inline jl_cgval_t value_to_pointer(jl_codectx_t &ctx, const jl_cgval_t &v\n         recombine_value(ctx, v, loc, stack_ai, align, false);\n         return mark_julia_slot(loc, v.typ, v.TIndex, tbaa);\n     }\n-    if (v.ispointer())\n+    if (v.ispointer() || v.V == nullptr)\n         return v;\n     return value_to_pointer(ctx, v.V, v.typ, v.TIndex);\n }\n@@ -2297,17 +2350,21 @@ static inline jl_cgval_t mark_julia_type(jl_codectx_t &ctx, Value *v, bool isbox\n         return ghostValue(ctx, typ);\n     }\n     Type *T = julia_type_to_llvm(ctx, typ);\n-    if (type_is_ghost(T)) {\n+    if (type_is_ghost(T))\n         return ghostValue(ctx, typ);\n-    }\n-    if (v && !isboxed && v->getType()->isAggregateType()) {\n+    if (isboxed)\n+        return jl_cgval_t(v, isboxed, typ, NULL, best_tbaa(ctx.tbaa(), typ), None);\n+    if (v && v->getType()->isAggregateType()) {\n         // eagerly put this back onto the stack\n         // llvm mem2reg pass will remove this if unneeded\n         if (CountTrackedPointers(v->getType()).count == 0)\n             return value_to_pointer(ctx, v, typ, NULL);\n+        // TODO: move (split) pointers to stack also\n+        //if (!jl_is_genericmemoryref_type(typ)) {\n+        //    auto copy = split_value(ctx, jl_cgval_t(v, typ, NULL), Align(julia_alignment(typ)));\n+        //    return mark_julia_slot(copy.first, typ, NULL, ctx.tbaa().tbaa_stack, copy.second);\n+        //}\n     }\n-    if (isboxed)\n-        return jl_cgval_t(v, isboxed, typ, NULL, best_tbaa(ctx.tbaa(), typ), None);\n     return jl_cgval_t(v, typ, NULL);\n }\n \n@@ -2316,57 +2373,62 @@ static inline jl_cgval_t mark_julia_type(jl_codectx_t &ctx, Value *v, bool isbox\n     return mark_julia_type(ctx, v, isboxed, (jl_value_t*)typ);\n }\n \n-// see if it might be profitable (and cheap) to change the type of v to typ\n-static inline jl_cgval_t update_julia_type(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ)\n+static Value *emit_exactly_isa(jl_codectx_t &ctx, const jl_cgval_t &arg, jl_datatype_t *dt, bool could_be_null=false);\n+static jl_cgval_t convert_julia_type_to_union(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ, bool allow_mismatch);\n+\n+// see if it might be profitable (and cheap) to change the type of v to typ,\n+static inline jl_cgval_t update_julia_type(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ, bool allow_mismatch=false)\n {\n+    if (typ == (jl_value_t*)jl_typeofbottom_type)\n+        return ghostValue(ctx, typ); // normalize TypeofBottom to Type{Union{}}\n     if (v.typ == jl_bottom_type || typ == (jl_value_t*)jl_any_type || jl_egal(v.typ, typ))\n         return v; // fast-path\n     if (v.constant)\n         return jl_isa(v.constant, typ) ? v : jl_cgval_t();\n-    if (jl_is_concrete_type(v.typ) && !jl_is_kind(v.typ)) {\n-        if (jl_is_concrete_type(typ) && !jl_is_kind(typ)) {\n+    if (jl_is_concrete_type(typ)) {\n+        if (jl_is_concrete_type(v.typ)) {\n             // type mismatch: changing from one leaftype to another\n-            CreateTrap(ctx.builder);\n+            if (!allow_mismatch)\n+                CreateTrap(ctx.builder);\n             return jl_cgval_t();\n         }\n-        return v; // doesn't improve type info\n+        Type *T = julia_type_to_llvm(ctx, typ);\n+        if (type_is_ghost(T))\n+            return ghostValue(ctx, typ);\n+    }\n+    else if (jl_is_concrete_type(v.typ) && !jl_is_kind(v.typ)) {\n+        return v;\n     }\n     if (v.TIndex) {\n         jl_value_t *utyp = jl_unwrap_unionall(typ);\n         if (jl_is_datatype(utyp)) {\n             bool alwaysboxed;\n             if (jl_is_concrete_type(utyp))\n-                alwaysboxed = !jl_is_pointerfree(utyp);\n+                alwaysboxed = deserves_unionbox(utyp) || get_box_tindex((jl_datatype_t*)utyp, v.typ) == 0;\n             else\n                 alwaysboxed = !((jl_datatype_t*)utyp)->name->abstract && ((jl_datatype_t*)utyp)->name->mutabl;\n-            if (alwaysboxed) {\n-                // discovered that this union-split type must actually be isboxed\n-                if (v.Vboxed) {\n-                    return jl_cgval_t(v.Vboxed, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), v.inline_roots);\n-                }\n-                else {\n-                    // type mismatch (there weren't any boxed values in the union)\n+            if (!v.Vboxed && alwaysboxed) {\n+                // type mismatch (there weren't any boxed values in the union)\n+                if (!allow_mismatch)\n                     CreateTrap(ctx.builder);\n-                    return jl_cgval_t();\n-                }\n+                return jl_cgval_t();\n+            }\n+            if (v.Vboxed && (v.isboxed || alwaysboxed)) {\n+                return jl_cgval_t(v.Vboxed, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), None);\n             }\n         }\n         if (!jl_is_concrete_type(typ))\n             return v; // not generally worth trying to change type info (which would require recomputing tindex)\n-    }\n-    Type *T = julia_type_to_llvm(ctx, typ);\n-    if (type_is_ghost(T))\n-        return ghostValue(ctx, typ);\n-    else if (v.TIndex && v.V == NULL) {\n-        // type mismatch (there weren't any non-ghost values in the union)\n-        CreateTrap(ctx.builder);\n-        return jl_cgval_t();\n+        if (v.V == NULL && v.inline_roots.empty()) {\n+            // type mismatch (there weren't any non-ghost values in the union)\n+            if (!allow_mismatch)\n+                CreateTrap(ctx.builder);\n+            return jl_cgval_t();\n+        }\n     }\n     return jl_cgval_t(v, typ, NULL);\n }\n \n-static jl_cgval_t convert_julia_type(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ, Value **skip=nullptr);\n-\n // --- allocating local variables ---\n \n static jl_sym_t *slot_symbol(jl_codectx_t &ctx, int s)\n@@ -2441,14 +2503,52 @@ static void CreateConditionalAbort(IRBuilder<> &irbuilder, Value *test)\n \n #include \"cgutils.cpp\"\n \n-static jl_cgval_t convert_julia_type_union(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ, Value **skip)\n+// new value is a split union and needs to be converted to that format\n+// this always sets TIndex (or returns unreachable)\n+static jl_cgval_t convert_julia_type_to_union(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ, bool allow_mismatch)\n {\n-    // previous value was a split union, compute new index, or box\n-    Value *new_tindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER);\n-    SmallBitVector skip_box(1, true);\n-    Value *tindex = ctx.builder.CreateAnd(v.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0x7f));\n-    if (jl_is_uniontype(typ)) {\n-        // compute the TIndex mapping from v.typ -> typ\n+    if (v.typ == jl_bottom_type || (v.TIndex && jl_egal(v.typ, typ)))\n+        return v; // fast-path\n+    assert(jl_is_uniontype(typ));\n+\n+    Value *union_box_tindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER);\n+    Value *new_tindex = union_box_tindex;\n+    bool computed_new_index_early = v.TIndex == nullptr;\n+    if (computed_new_index_early) {\n+        if (jl_is_concrete_type(v.typ) || v.constant) {\n+            unsigned new_idx = get_box_tindex((jl_datatype_t*)(v.constant ? jl_typeof(v.constant) : v.typ), typ);\n+            if (new_idx) {\n+                new_tindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), new_idx);\n+                if (!v.isboxed && v.V && v.inline_roots.empty() && !v.ispointer()) {\n+                    // previous value was unboxed (leaftype) and hoisted (!pointer) with statically computed union tindex\n+                    // TODO: remove this branch once all consumers of v.TIndex understand how to handle a non-ispointer value\n+                    jl_cgval_t ret(value_to_pointer(ctx, v), typ, new_tindex);\n+                    ret.inline_roots = ExtractTrackedValues(ctx, v.V);\n+                    return ret;\n+                }\n+            }\n+            else if (jl_subtype(v.typ, typ)) {\n+                // convert to a simple isboxed value, since it must be boxed in the new union\n+                return jl_cgval_t(boxed(ctx, v), true, typ, new_tindex, best_tbaa(ctx.tbaa(), typ), None);\n+            }\n+            else {\n+                if (!allow_mismatch)\n+                    CreateTrap(ctx.builder);\n+                return jl_cgval_t();\n+            }\n+        }\n+        else {\n+            // previous value was boxed, compute union tindex at runtime\n+            assert(v.isboxed);\n+            new_tindex = compute_box_tindex(ctx, v, typ, allow_mismatch);\n+        }\n+    }\n+\n+    jl_cgval_t ret(v);\n+    if (!computed_new_index_early) {\n+        SmallBitVector skip_box(1, true);\n+        Value *tindex = ctx.builder.CreateAnd(v.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0x7f));\n+        // compute the TIndex mapping from v.typ -> typ to compute what to do with each unboxed item\n         unsigned counter = 0;\n         for_each_uniontype_small(\n             // for each old union-split value\n@@ -2466,10 +2566,6 @@ static jl_cgval_t convert_julia_type_union(jl_codectx_t &ctx, const jl_cgval_t &\n                     // new value doesn't need to be boxed\n                     // since it isn't part of the new union\n                     t = true;\n-                    if (skip) {\n-                        Value *skip1 = ctx.builder.CreateICmpEQ(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), idx));\n-                        *skip = *skip ? ctx.builder.CreateOr(*skip, skip1) : skip1;\n-                    }\n                 }\n                 else {\n                     // will actually need to box this element\n@@ -2481,194 +2577,229 @@ static jl_cgval_t convert_julia_type_union(jl_codectx_t &ctx, const jl_cgval_t &\n             },\n             v.typ,\n             counter);\n-    }\n-    setName(ctx.emission_context, new_tindex, \"tindex\");\n-\n-    // some of the values are still unboxed\n-    if (!isa<Constant>(new_tindex)) {\n         Value *wasboxed = NULL;\n-        // If the old value was boxed and unknown (type tag UNION_BOX_MARKER),\n-        // it is possible that the tag was actually one of the types\n-        // that are now explicitly represented. To find out, we need\n-        // to compare typeof(v.Vboxed) (i.e. the type of the unknown\n-        // value) against all the types that are now explicitly\n-        // selected and select the appropriate one as our new tindex.\n-        if (v.Vboxed) {\n-            wasboxed = ctx.builder.CreateAnd(v.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER));\n-            new_tindex = ctx.builder.CreateOr(wasboxed, new_tindex);\n-            wasboxed = ctx.builder.CreateICmpNE(wasboxed, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n+        if (v.isboxed) {\n+            wasboxed = union_box_tindex;\n+        }\n+        else if (v.Vboxed) {\n+            wasboxed = ctx.builder.CreateAnd(v.TIndex, union_box_tindex);\n             setName(ctx.emission_context, wasboxed, \"wasboxed\");\n+            new_tindex = ctx.builder.CreateOr(wasboxed, new_tindex);\n+        }\n+        if (!skip_box.all()) {\n+            // some values weren't unboxed in the new union\n+            // but are in the new, so box them now\n+            Value *boxv = box_union(ctx, v, skip_box);\n+            if (v.Vboxed) {\n+                // If the value is boxed both before and after, we don't need\n+                // to touch it at all. Otherwise we're either transitioning\n+                // unboxed->boxed, or leaving an unboxed value in place.\n+                assert(wasboxed); // needed for clang-sa\n+                Value *boxedbefore = ctx.builder.CreateICmpNE(wasboxed, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n+                Value *boxedafter = ctx.builder.CreateICmpNE(\n+                    ctx.builder.CreateAnd(new_tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER)),\n+                    ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n+                boxv = ctx.builder.CreateSelect(\n+                    ctx.builder.CreateAnd(boxedbefore, boxedafter), v.Vboxed, boxv);\n+                // boxedbefore OR new_tindex == 0 might be clearer to use (albeit equivalent)?\n+            }\n+            Value *slotv;\n+            MDNode *tbaa;\n+            if (v.V == nullptr) {\n+                // v.V might be NULL if it was all constants before\n+                slotv = nullptr;\n+                tbaa = ctx.tbaa().tbaa_const;\n+            }\n+            else if (!v.inline_roots.empty() || v.ispointer()) {\n+                Value *isboxv = ctx.builder.CreateIsNotNull(boxv);\n+                slotv = v.V;\n+                tbaa = v.tbaa;\n+                slotv = ctx.builder.CreateSelect(isboxv,\n+                            decay_derived(ctx, boxv),\n+                            decay_derived(ctx, slotv));\n+            }\n+            else {\n+                jl_cgval_t oldv = value_to_pointer(ctx, v.V, v.typ, v.TIndex);\n+                slotv = oldv.V;\n+                tbaa = oldv.tbaa;\n+            }\n+            // recreate ret with new representation (except boxed bit of TIndex isn't set correctly but new_tindex isn't fully computed yet either)\n+            ret = jl_cgval_t(slotv, false, typ, v.TIndex, tbaa, ret.inline_roots);\n+            assert(boxv->getType() == ctx.types().T_prjlvalue);\n+            ret.Vboxed = boxv;\n+            ret.constant = v.constant;\n+        }\n+    }\n+    else if (v.isboxed || v.Vboxed) {\n+        if (!v.isboxed) {\n+            union_box_tindex = ctx.builder.CreateSelect(ctx.builder.CreateIsNull(v.Vboxed),\n+                    ConstantInt::get(union_box_tindex->getType(), 0x00),\n+                    union_box_tindex);\n+        }\n+        new_tindex = ctx.builder.CreateOr(new_tindex, union_box_tindex);\n+    }\n \n-            BasicBlock *currBB = ctx.builder.GetInsertBlock();\n-\n+    // Now reverse the scan to compute if any boxed items should now be tagged:\n+    //\n+    // If the old value was boxed and unknown (type tag UNION_BOX_MARKER),\n+    // it is possible that the tag was actually one of the types\n+    // that are now explicitly represented. To find out, we need\n+    // to compare typeof(v.Vboxed) (i.e. the type of the unknown\n+    // value) against all the types that are now explicitly\n+    // selected and select the appropriate one as our new tindex.\n+    if (v.Vboxed || v.isboxed) {\n+        BasicBlock *currBB = ctx.builder.GetInsertBlock();\n+\n+        BasicBlock *union_isaBB = NULL;\n+        if (computed_new_index_early) {\n+            union_isaBB = BasicBlock::Create(ctx.builder.getContext(), \"union_isa\", ctx.f);\n+            ctx.builder.SetInsertPoint(union_isaBB);\n+            union_box_tindex = new_tindex;\n+        }\n+        else {\n             // We lazily create a BB for this, once we decide that we\n-            // actually need it.\n+            // actually need it. (similar to compute_box_tindex)\n             Value *union_box_dt = NULL;\n-            BasicBlock *union_isaBB = NULL;\n-            BasicBlock *post_union_isaBB = NULL;\n             auto maybe_setup_union_isa = [&]() {\n                 if (!union_isaBB) {\n                     union_isaBB = BasicBlock::Create(ctx.builder.getContext(), \"union_isa\", ctx.f);\n                     ctx.builder.SetInsertPoint(union_isaBB);\n-                    union_box_dt = emit_typeof(ctx, v.Vboxed, skip != NULL, true);\n-                    post_union_isaBB = ctx.builder.GetInsertBlock();\n+                    union_box_dt = emit_typeof(ctx, v.Vboxed, /*maybe_null*/allow_mismatch, true);\n                 }\n             };\n-\n             // If we don't find a match. The type remains unknown\n             // (UNION_BOX_MARKER). We could use `v.Tindex`, here, since we know\n             // it has to be UNION_BOX_MARKER, but it seems likely the backend\n             // will like the explicit constant better.\n-            Value *union_box_tindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER);\n             unsigned counter = 0;\n             for_each_uniontype_small(\n                 // for each new union-split value\n                 [&](unsigned idx, jl_datatype_t *jt) {\n-                    unsigned old_idx = get_box_tindex(jt, v.typ);\n-                    if (old_idx == 0) {\n-                        // didn't handle this item before, select its new union index\n+                    unsigned old_idx = v.TIndex ? get_box_tindex(jt, v.typ) : 0;\n+                    if (old_idx == 0 && jl_subtype((jl_value_t*)jt, v.typ)) {\n+                        // present, but didn't handle this item before, select its new union index\n                         maybe_setup_union_isa();\n                         Value *cmp = ctx.builder.CreateICmpEQ(emit_tagfrom(ctx, jt), union_box_dt);\n                         union_box_tindex = ctx.builder.CreateSelect(cmp, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER | idx), union_box_tindex);\n                     }\n                 },\n                 typ,\n                 counter);\n-            setName(ctx.emission_context, union_box_tindex, \"union_box_tindex\");\n-            if (union_box_dt) {\n-                BasicBlock *postBB = BasicBlock::Create(ctx.builder.getContext(), \"post_union_isa\", ctx.f);\n-                ctx.builder.CreateBr(postBB);\n-                ctx.builder.SetInsertPoint(currBB);\n+        }\n+\n+        // if anything did change from boxed to unboxed which has new roots, load roots for it\n+        BasicBlock *post_union_isaBB = ctx.builder.GetInsertBlock();\n+        if (union_isaBB) {\n+            uint32_t add_roots_count = 0;\n+            uint32_t add_roots_inline = 0;\n+            unsigned counter = 0;\n+            for_each_uniontype_small(\n+                // for each new union-split value\n+                [&](unsigned idx, jl_datatype_t *jt) {\n+                    unsigned old_idx = v.TIndex ? get_box_tindex(jt, v.typ) : 0;\n+                    if (old_idx == 0) {\n+                        if (jl_datatype_layout(jt)->npointers) {\n+                            if (!jl_subtype((jl_value_t*)jt, v.typ))\n+                                return;\n+                            add_roots_count += 1;\n+                            add_roots_inline = std::max(add_roots_inline, jl_datatype_layout(jt)->npointers);\n+                        }\n+                    }\n+                },\n+                typ,\n+                counter);\n+            BasicBlock *postBB = BasicBlock::Create(ctx.builder.getContext(), \"post_union_isa\", ctx.f);\n+            ctx.builder.SetInsertPoint(currBB);\n+            if (v.TIndex) {\n                 Value *wasunknown = ctx.builder.CreateICmpEQ(v.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER));\n                 ctx.builder.CreateCondBr(wasunknown, union_isaBB, postBB);\n-                ctx.builder.SetInsertPoint(postBB);\n-                PHINode *tindex_phi = ctx.builder.CreatePHI(getInt8Ty(ctx.builder.getContext()), 2);\n+            }\n+            else {\n+                ctx.builder.CreateBr(union_isaBB);\n+            }\n+            ctx.builder.SetInsertPoint(postBB);\n+            PHINode *tindex_phi = nullptr;\n+            if (v.TIndex) {\n+                tindex_phi = ctx.builder.CreatePHI(getInt8Ty(ctx.builder.getContext()), 2 + add_roots_count);\n                 tindex_phi->addIncoming(new_tindex, currBB);\n                 tindex_phi->addIncoming(union_box_tindex, post_union_isaBB);\n                 new_tindex = tindex_phi;\n-                setName(ctx.emission_context, new_tindex, \"tindex\");\n-            }\n-        }\n-        if (!skip_box.all()) {\n-            // some values weren't unboxed in the new union\n-            // box them now (tindex above already selected UNION_BOX_MARKER = box for them)\n-            Value *boxv = box_union(ctx, v, skip_box);\n-            if (v.Vboxed) {\n-                // If the value is boxed both before and after, we don't need\n-                // to touch it at all. Otherwise we're either transitioning\n-                // unboxed->boxed, or leaving an unboxed value in place.\n-                Value *isboxed = ctx.builder.CreateICmpNE(\n-                    ctx.builder.CreateAnd(new_tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER)),\n-                    ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n-                boxv = ctx.builder.CreateSelect(\n-                    ctx.builder.CreateAnd(wasboxed, isboxed), v.Vboxed, boxv);\n             }\n-            Value *slotv;\n-            MDNode *tbaa;\n-            if (v.V == NULL) {\n-                // v.V might be NULL if it was all ghost objects before\n-                slotv = NULL;\n-                tbaa = ctx.tbaa().tbaa_const;\n+            else {\n+                new_tindex = union_box_tindex;\n+            }\n+            setName(ctx.emission_context, new_tindex, \"tindex\");\n+            // if adding new roots to the union, load those now\n+            if (add_roots_count && (v.TIndex || v.isboxed)) {\n+                Value *Vnull = Constant::getNullValue(ctx.types().T_prjlvalue);\n+                if (ret.inline_roots.size() < add_roots_inline)\n+                    ret.inline_roots.resize(add_roots_inline, Vnull);\n+                // replace new ret.inline_roots with PHI\n+                for (size_t i = 0; i < add_roots_inline; i++) {\n+                    Value *rooti = ret.inline_roots[i];\n+                    PHINode *phi = ctx.builder.CreatePHI(rooti->getType(), 2 + add_roots_count);\n+                    if (v.TIndex)\n+                        phi->addIncoming(rooti, currBB);\n+                    phi->addIncoming(rooti, post_union_isaBB);\n+                    ret.inline_roots[i] = phi;\n+                }\n+                ctx.builder.SetInsertPoint(post_union_isaBB);\n+                Value *Vboxed = v.Vboxed ? decay_derived(ctx, v.Vboxed) : nullptr;\n+                SwitchInst *SW = ctx.builder.CreateSwitch(union_box_tindex, postBB, add_roots_count);\n+                unsigned counter = 0;\n+                for_each_uniontype_small(\n+                    // for each new union-split value\n+                    // n.b. this assumes that split_union_into has the same on-stack format (minus roots) as the un-split value\n+                    [&](unsigned idx, jl_datatype_t *jt) {\n+                        unsigned old_idx = v.TIndex ? get_box_tindex(jt, v.typ) : 0;\n+                        if (old_idx == 0) {\n+                            auto npointers = jl_datatype_layout(jt)->npointers;\n+                            if (npointers) {\n+                                if (!jl_subtype((jl_value_t*)jt, v.typ))\n+                                    return;\n+                                BasicBlock *splitunboxBB = BasicBlock::Create(ctx.builder.getContext(), \"split_unbox_union\", ctx.f);\n+                                SW->addCase(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER | idx), splitunboxBB);\n+                                ctx.builder.SetInsertPoint(splitunboxBB);\n+                                auto newroots = Vboxed ? extract_gc_roots(ctx, Vboxed, jt, npointers, v.tbaa) : extract_gc_roots(ctx, v, npointers);\n+                                ctx.builder.CreateBr(postBB);\n+                                splitunboxBB = ctx.builder.GetInsertBlock();\n+                                if (tindex_phi)\n+                                    tindex_phi->addIncoming(union_box_tindex, splitunboxBB);\n+                                for (size_t i = 0; i < add_roots_inline; i++) {\n+                                    Value *rooti = i < newroots.size() ? newroots[i] : Vnull;\n+                                    cast<PHINode>(ret.inline_roots[i])->addIncoming(rooti, splitunboxBB);\n+                                }\n+                            }\n+                        }\n+                    },\n+                    typ,\n+                    counter);\n             }\n             else {\n-                Value *isboxv = ctx.builder.CreateIsNotNull(boxv);\n-                jl_cgval_t oldv = value_to_pointer(ctx, v);\n-                slotv = oldv.V;\n-                tbaa = oldv.tbaa;\n-                slotv = ctx.builder.CreateSelect(isboxv,\n-                            decay_derived(ctx, boxv),\n-                            decay_derived(ctx, slotv));\n+                ctx.builder.SetInsertPoint(post_union_isaBB);\n+                ctx.builder.CreateBr(postBB);\n             }\n-            jl_cgval_t newv = jl_cgval_t(slotv, false, typ, new_tindex, tbaa, v.inline_roots);\n-            assert(boxv->getType() == ctx.types().T_prjlvalue);\n-            newv.Vboxed = boxv;\n-            return newv;\n+            ctx.builder.SetInsertPoint(postBB);\n         }\n     }\n-    else {\n-        return jl_cgval_t(boxed(ctx, v), true, typ, NULL, best_tbaa(ctx.tbaa(), typ), None);\n+    else if (computed_new_index_early && v.inline_roots.empty() && jl_is_concrete_type(v.typ)) {\n+        jl_datatype_t *jt = (jl_datatype_t*)v.typ;\n+        auto npointers = jl_datatype_layout(jt)->npointers;\n+        if (npointers)\n+            ret.inline_roots = extract_gc_roots(ctx, v, npointers);\n     }\n-    return jl_cgval_t(v, typ, new_tindex);\n-}\n \n-// given a value marked with type `v.typ`, compute the mapping and/or boxing to return a value of type `typ`\n-// TODO: should this set TIndex when trivial (such as UNION_BOX_MARKER or concrete types) ?\n-static jl_cgval_t convert_julia_type(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ, Value **skip)\n-{\n-    if (typ == (jl_value_t*)jl_typeofbottom_type)\n-        return ghostValue(ctx, typ); // normalize TypeofBottom to Type{Union{}}\n-    if (v.typ == jl_bottom_type || jl_egal(v.typ, typ))\n-        return v; // fast-path\n-    Type *T = julia_type_to_llvm(ctx, typ);\n-    if (type_is_ghost(T))\n-        return ghostValue(ctx, typ);\n-    Value *new_tindex = NULL;\n-    if (jl_is_concrete_type(typ)) {\n-        if (jl_is_concrete_type(v.typ)) {\n-            // type mismatch: changing from one leaftype to another\n-            if (skip)\n-                *skip = ConstantInt::get(getInt1Ty(ctx.builder.getContext()), 1);\n-            else\n-                CreateTrap(ctx.builder);\n-            return jl_cgval_t();\n-        }\n-        bool mustbox_union = v.TIndex && !jl_is_pointerfree(typ);\n-        if (v.Vboxed && (v.isboxed || mustbox_union)) {\n-            if (skip) {\n-                *skip = ctx.builder.CreateNot(emit_exactly_isa(ctx, v, (jl_datatype_t*)typ, true));\n-            }\n-            return jl_cgval_t(v.Vboxed, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), v.inline_roots);\n-        }\n-        if (mustbox_union) {\n-            // type mismatch: there weren't any boxed values in the union\n-            if (skip)\n-                *skip = ConstantInt::get(getInt1Ty(ctx.builder.getContext()), 1);\n-            else\n-                CreateTrap(ctx.builder);\n-            return jl_cgval_t();\n-        }\n-    }\n-    else {\n-        bool makeboxed = false;\n-        if (v.TIndex) {\n-            return convert_julia_type_union(ctx, v, typ, skip);\n-        }\n-        else if (!v.isboxed && jl_is_uniontype(typ)) {\n-            // previous value was unboxed (leaftype), statically compute union tindex\n-            assert(jl_is_concrete_type(v.typ));\n-            unsigned new_idx = get_box_tindex((jl_datatype_t*)v.typ, typ);\n-            if (new_idx) {\n-                new_tindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), new_idx);\n-                if (v.V && v.inline_roots.empty() && !v.ispointer()) {\n-                    // TODO: remove this branch once all consumers of v.TIndex understand how to handle a non-ispointer value\n-                    return jl_cgval_t(value_to_pointer(ctx, v), typ, new_tindex);\n-                }\n-            }\n-            else if (jl_subtype(v.typ, typ)) {\n-                makeboxed = true;\n-            }\n-            else if (skip) {\n-                // undef\n-                *skip = ConstantInt::get(getInt1Ty(ctx.builder.getContext()), 1);\n-                return jl_cgval_t();\n-            }\n-            else {\n-                // unreachable\n-                CreateTrap(ctx.builder);\n-                return jl_cgval_t();\n-            }\n-        }\n-        else if (!v.isboxed) {\n-            makeboxed = true;\n-        }\n-        if (makeboxed) {\n-            // convert to a simple isboxed value\n-            return mark_julia_type(ctx, boxed(ctx, v), true, typ);\n-        }\n+    if (!computed_new_index_early && isa<Constant>(new_tindex)) {\n+        // no new tindex (it is set to UNION_BOX_MARKER), so the new value must be something boxed in the new union\n+        // TODO: use ret.Vboxed or box_union directly to set skip instead of emitting a trap?\n+        return jl_cgval_t(boxed(ctx, v), true, typ, new_tindex, best_tbaa(ctx.tbaa(), typ), None);\n     }\n-    return jl_cgval_t(v, typ, new_tindex);\n+    // some of the values are still unboxed\n+    setName(ctx.emission_context, new_tindex, \"tindex\");\n+    return jl_cgval_t(ret, typ, new_tindex);\n }\n \n+\n std::unique_ptr<Module> jl_create_llvm_module(StringRef name, LLVMContext &context, const DataLayout &DL, const Triple &triple) JL_NOTSAFEPOINT\n {\n     ++ModulesCreated;\n@@ -2763,8 +2894,8 @@ static bool uses_specsig(jl_value_t *sig, bool needsparams, jl_value_t *rettype,\n         return true;\n     if (jl_is_uniontype(rettype)) {\n         bool allunbox;\n-        size_t nbytes, align, min_align;\n-        union_alloca_type((jl_uniontype_t*)rettype, allunbox, nbytes, align, min_align);\n+        size_t nbytes, align, min_align, return_roots;\n+        union_alloca_type((jl_uniontype_t*)rettype, allunbox, nbytes, align, min_align, return_roots);\n         if (nbytes > 0)\n             return true; // some elements of the union could be returned unboxed avoiding allocation\n     }\n@@ -3320,7 +3451,7 @@ static Value *emit_box_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1, const\n     });\n }\n \n-static Value *emit_bits_compare(jl_codectx_t &ctx, jl_cgval_t arg1, jl_cgval_t arg2);\n+static Value *emit_bits_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2);\n \n static Value *emit_bitsunion_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2)\n {\n@@ -3371,7 +3502,7 @@ static Value *emit_bitsunion_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1,\n     return phi;\n }\n \n-static Value *emit_bits_compare(jl_codectx_t &ctx, jl_cgval_t arg1, jl_cgval_t arg2)\n+static Value *emit_bits_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2)\n {\n     ++EmittedBitsCompares;\n     jl_value_t *argty = (arg1.constant ? jl_typeof(arg1.constant) : arg1.typ);\n@@ -3384,16 +3515,16 @@ static Value *emit_bits_compare(jl_codectx_t &ctx, jl_cgval_t arg1, jl_cgval_t a\n \n     if (at->isIntegerTy() || at->isPointerTy() || at->isFloatingPointTy()) {\n         Type *at_int = INTT(at, ctx.emission_context.DL);\n-        Value *varg1 = emit_unbox(ctx, at_int, arg1, argty);\n-        Value *varg2 = emit_unbox(ctx, at_int, arg2, argty);\n+        Value *varg1 = emit_unbox(ctx, at_int, arg1);\n+        Value *varg2 = emit_unbox(ctx, at_int, arg2);\n         return ctx.builder.CreateICmpEQ(varg1, varg2);\n     }\n \n     if (at->isVectorTy()) {\n         jl_svec_t *types = ((jl_datatype_t*)argty)->types;\n         Value *answer = ConstantInt::get(getInt1Ty(ctx.builder.getContext()), 1);\n-        Value *varg1 = emit_unbox(ctx, at, arg1, argty);\n-        Value *varg2 = emit_unbox(ctx, at, arg2, argty);\n+        Value *varg1 = emit_unbox(ctx, at, arg1);\n+        Value *varg2 = emit_unbox(ctx, at, arg2);\n         for (size_t i = 0, l = jl_svec_len(types); i < l; i++) {\n             jl_value_t *fldty = jl_svecref(types, i);\n             Value *subAns, *fld1, *fld2;\n@@ -4474,7 +4605,7 @@ static bool emit_builtin_call(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                         jl_cgval_t va_ary( // fake instantiation of a cgval, in order to call emit_bounds_check (it only checks the `.V` field)\n                                 emit_ptrgep(ctx, ctx.argArray, ctx.nReqArgs * sizeof(jl_value_t*)),\n                                 NULL, NULL);\n-                        Value *idx = emit_unbox(ctx, ctx.types().T_size, fld, (jl_value_t*)jl_long_type);\n+                        Value *idx = emit_unbox(ctx, ctx.types().T_size, fld);\n                         idx = emit_bounds_check(ctx, va_ary, NULL, idx, valen, boundscheck);\n                         idx = ctx.builder.CreateAdd(idx, ConstantInt::get(ctx.types().T_size, ctx.nReqArgs));\n                         Instruction *v = ctx.builder.CreateAlignedLoad(ctx.types().T_prjlvalue, ctx.builder.CreateInBoundsGEP(ctx.types().T_prjlvalue, ctx.argArray, idx), Align(sizeof(void*)));\n@@ -4502,13 +4633,13 @@ static bool emit_builtin_call(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                     }\n                     else {\n                         // unknown index\n-                        Value *vidx = emit_unbox(ctx, ctx.types().T_size, fld, (jl_value_t*)jl_long_type);\n+                        Value *vidx = emit_unbox(ctx, ctx.types().T_size, fld);\n                         if (emit_getfield_unknownidx(ctx, ret, obj, vidx, utt, boundscheck, order)) {\n                             return true;\n                         }\n                     }\n                 }\n-                Value *vidx = emit_unbox(ctx, ctx.types().T_size, fld, (jl_value_t*)jl_long_type);\n+                Value *vidx = emit_unbox(ctx, ctx.types().T_size, fld);\n                 if (jl_is_tuple_type(utt) && is_tupletype_homogeneous(utt->parameters, true)) {\n                     // For tuples, we can emit code even if we don't know the exact\n                     // type (e.g. because we don't know the length). This is possible\n@@ -4678,7 +4809,7 @@ static bool emit_builtin_call(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                 Value *tyv = boxed(ctx, typ);\n                 Value *types_svec = emit_datatype_types(ctx, tyv);\n                 Value *types_len = emit_datatype_nfields(ctx, tyv);\n-                Value *idx = emit_unbox(ctx, ctx.types().T_size, fld, (jl_value_t*)jl_long_type);\n+                Value *idx = emit_unbox(ctx, ctx.types().T_size, fld);\n                 jl_value_t *boundscheck = (nargs == 3 ? argv[3].constant : jl_true);\n                 if (nargs == 3)\n                     emit_typecheck(ctx, argv[3], (jl_value_t*)jl_bool_type, \"fieldtype\");\n@@ -4819,7 +4950,7 @@ static bool emit_builtin_call(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n isdefined_unknown_idx:\n             if (nargs == 3 || fld.typ != (jl_value_t*)jl_long_type)\n                 return false;\n-            Value *vidx = emit_unbox(ctx, ctx.types().T_size, fld, (jl_value_t*)jl_long_type);\n+            Value *vidx = emit_unbox(ctx, ctx.types().T_size, fld);\n             vidx = ctx.builder.CreateSub(vidx, ConstantInt::get(ctx.types().T_size, 1));\n             Value *isd = ctx.builder.CreateCall(prepare_call(jlfieldisdefinedchecked_func), { boxed(ctx, obj), vidx });\n             isd = ctx.builder.CreateTrunc(isd, getInt8Ty(ctx.builder.getContext()));\n@@ -5001,8 +5132,8 @@ static jl_cgval_t emit_call_specfun_other(jl_codectx_t &ctx, bool is_opaque_clos\n \n     AllocaInst *return_roots = nullptr;\n     if (returninfo.return_roots) {\n-        assert(returninfo.cc == jl_returninfo_t::SRet);\n         return_roots = emit_static_roots(ctx, returninfo.return_roots);\n+        setName(ctx.emission_context, return_roots, \"return_roots\");\n         argvals[idx] = return_roots;\n         idx++;\n     }\n@@ -5069,7 +5200,7 @@ static jl_cgval_t emit_call_specfun_other(jl_codectx_t &ctx, bool is_opaque_clos\n                 }\n             }\n             else {\n-                Value *val = emit_unbox(ctx, et, arg, jt);\n+                Value *val = emit_unbox(ctx, et, arg);\n                 if (!val) {\n                     // There was a type mismatch of some sort - exit early\n                     emit_error(ctx, \"(INTERNAL ERROR - IR Validity): Argument type mismatch in Expr(:invoke)\");\n@@ -5096,7 +5227,11 @@ static jl_cgval_t emit_call_specfun_other(jl_codectx_t &ctx, bool is_opaque_clos\n             break;\n         case jl_returninfo_t::SRet:\n             assert(result);\n-            retval = mark_julia_slot(result, jlretty, NULL, ctx.tbaa().tbaa_gcframe, load_gc_roots(ctx, return_roots, returninfo.return_roots, ctx.tbaa().tbaa_gcframe));\n+            retval = mark_julia_slot(result,\n+                                     jlretty,\n+                                     NULL,\n+                                     ctx.tbaa().tbaa_gcframe,\n+                                     load_gc_roots(ctx, return_roots, returninfo.return_roots, ctx.tbaa().tbaa_gcframe));\n             break;\n         case jl_returninfo_t::Union: {\n             Value *box = ctx.builder.CreateExtractValue(call, 0);\n@@ -5111,7 +5246,8 @@ static jl_cgval_t emit_call_specfun_other(jl_codectx_t &ctx, bool is_opaque_clos\n             retval = mark_julia_slot(derived,\n                                      jlretty,\n                                      tindex,\n-                                     ctx.tbaa().tbaa_stack);\n+                                     ctx.tbaa().tbaa_stack,\n+                                     load_gc_roots(ctx, return_roots, returninfo.return_roots, ctx.tbaa().tbaa_gcframe));\n             retval.Vboxed = box;\n             break;\n         }\n@@ -5421,7 +5557,7 @@ static jl_cgval_t emit_specsig_oc_call(jl_codectx_t &ctx, jl_value_t *oc_type, j\n     // Load specptr\n     jl_cgval_t &theArg = argv[0];\n     jl_cgval_t closure_specptr = emit_getfield_knownidx(ctx, theArg, 4, (jl_datatype_t*)oc_type, jl_memory_order_notatomic);\n-    Value *specptr = emit_unbox(ctx, ctx.types().T_size, closure_specptr, (jl_value_t*)jl_long_type);\n+    Value *specptr = emit_unbox(ctx, ctx.types().T_size, update_julia_type(ctx, closure_specptr, (jl_value_t*)jl_voidpointer_type));\n     specptr = emit_inttoptr(ctx, specptr, ctx.types().T_ptr);\n     JL_GC_PUSH1(&sigtype);\n     jl_cgval_t r = emit_call_specfun_other(ctx, true, sigtype, oc_rett, specptr, \"\", NULL, argv, nargs,\n@@ -5638,7 +5774,7 @@ static jl_cgval_t emit_varinfo(jl_codectx_t &ctx, jl_varinfo_t &vi, jl_sym_t *va\n         }\n         if (vi.inline_roots) {\n             AllocaInst *varslot = vi.inline_roots;\n-            size_t nroots = cast<ConstantInt>(varslot->getArraySize())->getZExtValue();\n+            size_t nroots = vi.inline_roots_count;\n             auto T_prjlvalue = varslot->getAllocatedType();\n             if (auto AT = dyn_cast<ArrayType>(T_prjlvalue)) {\n                 nroots *= AT->getNumElements();\n@@ -5699,17 +5835,15 @@ static jl_cgval_t emit_local(jl_codectx_t &ctx, jl_value_t *slotload)\n     return emit_varinfo(ctx, vi, sym);\n }\n \n-static void emit_vi_assignment_unboxed(jl_codectx_t &ctx, jl_varinfo_t &vi, Value *isboxed, jl_cgval_t rval_info)\n+static void emit_vi_assignment_unboxed(jl_codectx_t &ctx, jl_varinfo_t &vi, Value *isboxed, const jl_cgval_t &rval_info)\n {\n     if (vi.usedUndef)\n         store_def_flag(ctx, vi, true);\n \n     if (!vi.value.constant) { // check that this is not a virtual store\n         assert(vi.inline_roots || vi.value.ispointer() || (vi.pTIndex && vi.value.V == NULL));\n+        assert(jl_egal(vi.value.typ, rval_info.typ));\n         // store value\n-        rval_info = update_julia_type(ctx, rval_info, vi.value.typ);\n-        if (rval_info.typ == jl_bottom_type)\n-            return;\n         if (vi.pTIndex && vi.value.V) // TODO: use lifetime-end here instead\n             ctx.builder.CreateStore(UndefValue::get(cast<AllocaInst>(vi.value.V)->getAllocatedType()), vi.value.V);\n         // Sometimes we can get into situations where the LHS and RHS\n@@ -5718,14 +5852,18 @@ static void emit_vi_assignment_unboxed(jl_codectx_t &ctx, jl_varinfo_t &vi, Valu\n         // This check should probably mostly catch the relevant situations.\n         if (vi.value.V != nullptr ? vi.value.V != rval_info.V : vi.inline_roots != nullptr) {\n             MDNode *tbaa = ctx.tbaa().tbaa_stack; // Use vi.value.tbaa ?\n-            if (rval_info.TIndex)\n-                emit_unionmove(ctx, vi.value.V, tbaa, rval_info, /*skip*/isboxed, vi.isVolatile);\n+            auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n+            if (rval_info.TIndex) {\n+                Value *Vnull = Constant::getNullValue(ctx.types().T_prjlvalue);\n+                emit_unionmove(ctx, vi.value.V, vi.value.typ, tbaa, rval_info, /*skip*/isboxed, vi.isVolatile);\n+                SmallVector<Value*,0> inline_roots(vi.inline_roots_count, Vnull);\n+                for (size_t i = 0; i < std::min(rval_info.inline_roots.size(), inline_roots.size()); ++i)\n+                    inline_roots[i] = rval_info.inline_roots[i];\n+                store_all_roots(ctx, inline_roots, vi.inline_roots, roots_ai, vi.isVolatile);\n+            }\n             else {\n                 Align align(julia_alignment(rval_info.typ));\n-                if (vi.inline_roots)\n-                    split_value_into(ctx, rval_info, align, vi.value.V, align, jl_aliasinfo_t::fromTBAA(ctx, tbaa), vi.inline_roots, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe), vi.isVolatile);\n-                else\n-                    emit_unbox_store(ctx, rval_info, vi.value.V, tbaa, align, align, vi.isVolatile);\n+                split_value_into(ctx, rval_info, align, vi.value.V, align, jl_aliasinfo_t::fromTBAA(ctx, tbaa), vi.inline_roots, roots_ai, vi.isVolatile);\n             }\n         }\n     }\n@@ -5759,8 +5897,17 @@ static void emit_phinode_assign(jl_codectx_t &ctx, ssize_t idx, jl_value_t *r)\n     // used. Hopefully LLVM will be able to fold this back where legal.\n     if (jl_is_uniontype(phiType)) {\n         bool allunbox;\n-        size_t min_align, nbytes;\n-        dest = try_emit_union_alloca(ctx, ((jl_uniontype_t*)phiType), allunbox, min_align, nbytes);\n+        size_t min_align, nbytes, inline_roots;\n+        dest = try_emit_union_alloca(ctx, ((jl_uniontype_t*)phiType), allunbox, min_align, nbytes, inline_roots);\n+        if (inline_roots) {\n+            assert(dest || allunbox);\n+            roots.resize(inline_roots);\n+            for (size_t nr = 0; nr < inline_roots; nr++) {\n+                auto root_phi = PHINode::Create(ctx.types().T_prjlvalue, jl_array_nrows(edges), \"root_phi\");\n+                root_phi->insertInto(BB, InsertPt);\n+                roots[nr] = root_phi;\n+            }\n+        }\n         if (dest) {\n             AllocaInst *phi = cast<AllocaInst>(dest->clone());\n             phi->insertAfter(dest);\n@@ -5776,7 +5923,8 @@ static void emit_phinode_assign(jl_codectx_t &ctx, ssize_t idx, jl_value_t *r)\n             Value *ptr = ctx.builder.CreateSelect(isboxed,\n                 decay_derived(ctx, ptr_phi),\n                 decay_derived(ctx, phi));\n-            jl_cgval_t val = mark_julia_slot(ptr, phiType, Tindex_phi, best_tbaa(ctx.tbaa(), phiType));\n+            jl_cgval_t val = mark_julia_slot(ptr, phiType, Tindex_phi, best_tbaa(ctx.tbaa(), phiType),\n+                roots.empty() ? ArrayRef<Value*>() : ArrayRef((Value *const *)&roots.front(), roots.size()));\n             val.Vboxed = ptr_phi;\n             ctx.PhiNodes.push_back(std::make_tuple(val, BB, dest, ptr_phi, roots, r));\n             ctx.SAvalues[idx] = val;\n@@ -5786,7 +5934,8 @@ static void emit_phinode_assign(jl_codectx_t &ctx, ssize_t idx, jl_value_t *r)\n         else if (allunbox) {\n             PHINode *Tindex_phi = PHINode::Create(getInt8Ty(ctx.builder.getContext()), jl_array_nrows(edges), \"tindex_phi\");\n             Tindex_phi->insertInto(BB, InsertPt);\n-            jl_cgval_t val = mark_julia_slot(NULL, phiType, Tindex_phi, ctx.tbaa().tbaa_stack);\n+            jl_cgval_t val = mark_julia_slot(NULL, phiType, Tindex_phi, ctx.tbaa().tbaa_stack,\n+                roots.empty() ? ArrayRef<Value*>() : ArrayRef((Value *const *)&roots.front(), roots.size()));\n             ctx.PhiNodes.push_back(std::make_tuple(val, BB, dest, (PHINode*)nullptr, roots, r));\n             ctx.SAvalues[idx] = val;\n             ctx.ssavalue_assigned[idx] = true;\n@@ -5880,72 +6029,66 @@ static void emit_ssaval_assign(jl_codectx_t &ctx, ssize_t ssaidx_0based, jl_valu\n     ctx.ssavalue_assigned[ssaidx_0based] = true;\n }\n \n-static void emit_varinfo_assign(jl_codectx_t &ctx, jl_varinfo_t &vi, jl_cgval_t rval_info, jl_value_t *l=NULL, bool allow_mismatch=false)\n+static void emit_varinfo_assign(jl_codectx_t &ctx, jl_varinfo_t &vi, const jl_cgval_t &rhs, jl_value_t *l=NULL, bool allow_mismatch=false)\n {\n     if (!vi.used || vi.value.typ == jl_bottom_type)\n         return;\n \n     // convert rval-type to lval-type\n     jl_value_t *slot_type = vi.value.typ;\n-    // If allow_mismatch is set, type mismatches will not result in traps.\n+    // If allow_mismatch is set, type mismatches (or null values) will not result in traps.\n     // This is used for upsilon nodes, where the destination can have a narrower\n     // type than the store, if inference determines that the store is never read.\n-    Value *skip = NULL;\n-    rval_info = convert_julia_type(ctx, rval_info, slot_type, &skip);\n-    if (!allow_mismatch && skip) {\n-        CreateTrap(ctx.builder);\n-        return;\n-    }\n-\n+    jl_cgval_t rval_info = update_julia_type(ctx, rhs, slot_type, allow_mismatch);\n     if (rval_info.typ == jl_bottom_type)\n         return;\n \n     // compute / store tindex info\n     if (vi.pTIndex) {\n-        Value *tindex;\n-        if (rval_info.TIndex) {\n-            tindex = rval_info.TIndex;\n-            if (!vi.boxroot)\n-                tindex = ctx.builder.CreateAnd(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER));\n-        }\n-        else {\n-            assert(rval_info.isboxed || rval_info.constant);\n-            tindex = compute_tindex_unboxed(ctx, rval_info, vi.value.typ);\n-            if (vi.boxroot)\n-                tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER));\n-            else\n-                rval_info.TIndex = tindex;\n-        }\n+        rval_info = convert_julia_type_to_union(ctx, rval_info, slot_type, allow_mismatch);\n+        if (rval_info.typ == jl_bottom_type)\n+            return;\n+        Value *tindex = rval_info.TIndex;\n+        if (!vi.boxroot)\n+            tindex = ctx.builder.CreateAnd(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER));\n         ctx.builder.CreateStore(tindex, vi.pTIndex, vi.isVolatile);\n     }\n \n     // store boxed variables\n     Value *isboxed = NULL;\n     if (vi.boxroot) {\n         Value *rval;\n-        if (vi.pTIndex && rval_info.TIndex) {\n-            ctx.builder.CreateStore(rval_info.TIndex, vi.pTIndex, vi.isVolatile);\n+        if (vi.pTIndex && !rval_info.isboxed) {\n             isboxed = ctx.builder.CreateICmpNE(\n                     ctx.builder.CreateAnd(rval_info.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER)),\n                     ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n             rval = rval_info.Vboxed ? rval_info.Vboxed : Constant::getNullValue(ctx.types().T_prjlvalue);\n-            assert(rval->getType() == ctx.types().T_prjlvalue);\n-            assert(!vi.value.constant);\n         }\n         else {\n-            assert(!vi.pTIndex || rval_info.isboxed || rval_info.constant);\n             rval = boxed(ctx, rval_info);\n         }\n         ctx.builder.CreateStore(rval, vi.boxroot, vi.isVolatile);\n     }\n \n     // store unboxed variables\n-    if (!vi.boxroot || (vi.pTIndex && rval_info.TIndex)) {\n-        emit_guarded_test(ctx, skip ? ctx.builder.CreateNot(skip) : nullptr, nullptr, [&]{\n+    if (!vi.boxroot || (vi.pTIndex && !rval_info.isboxed)) {\n+        Value *skip = nullptr;\n+        if (allow_mismatch) {\n+            if (vi.pTIndex)\n+                skip = ctx.builder.CreateIsNull(ctx.builder.CreateAnd(rval_info.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER)));\n+            else\n+                skip = ctx.builder.CreateNot(emit_exactly_isa(ctx, rhs, (jl_datatype_t *)vi.value.typ, true));\n+        }\n+        emit_guarded_test(ctx, skip ? ctx.builder.CreateNot(skip) : nullptr, nullptr, [&] {\n+            // internally this skips assignment if isboxed is true\n             emit_vi_assignment_unboxed(ctx, vi, isboxed, rval_info);\n             return nullptr;\n         });\n     }\n+    else if (vi.pTIndex && !rval_info.inline_roots.empty()) {\n+        auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n+        store_all_roots(ctx, rval_info.inline_roots, vi.inline_roots, roots_ai, vi.isVolatile);\n+    }\n \n     return;\n }\n@@ -6026,7 +6169,7 @@ static void emit_upsilonnode(jl_codectx_t &ctx, ssize_t phic, jl_value_t *val)\n             if (vi.inline_roots) {\n                 // memory optimization: make gc pointers re-initialized to NULL\n                 AllocaInst *ssaroots = vi.inline_roots;\n-                size_t nroots = cast<ConstantInt>(ssaroots->getArraySize())->getZExtValue();\n+                size_t nroots = vi.inline_roots_count;\n                 auto T_prjlvalue = ssaroots->getAllocatedType();\n                 if (auto AT = dyn_cast<ArrayType>(T_prjlvalue)) {\n                     nroots *= AT->getNumElements();\n@@ -6058,7 +6201,7 @@ static Value *emit_condition(jl_codectx_t &ctx, const jl_cgval_t &condV, const T\n         emit_typecheck(ctx, condV, (jl_value_t*)jl_bool_type, msg);\n     }\n     if (isbool) {\n-        Value *cond = emit_unbox(ctx, getInt1Ty(ctx.builder.getContext()), condV, (jl_value_t*)jl_bool_type);\n+        Value *cond = emit_unbox(ctx, getInt1Ty(ctx.builder.getContext()), update_julia_type(ctx, condV, (jl_value_t*)jl_bool_type));\n         return ctx.builder.CreateNot(cond);\n     }\n     if (condV.isboxed) {\n@@ -6317,8 +6460,7 @@ static jl_cgval_t emit_expr(jl_codectx_t &ctx, jl_value_t *expr, ssize_t ssaidx_\n         jl_error(\"GotoIfNot in value position\");\n     }\n     if (jl_is_pinode(expr)) {\n-        Value *skip = NULL;\n-        return convert_julia_type(ctx, emit_expr(ctx, jl_fieldref_noalloc(expr, 0)), jl_fieldref_noalloc(expr, 1), &skip);\n+        return update_julia_type(ctx, emit_expr(ctx, jl_fieldref_noalloc(expr, 0)), jl_fieldref_noalloc(expr, 1), true);\n     }\n     if (!jl_is_expr(expr)) {\n         jl_value_t *val = expr;\n@@ -6349,7 +6491,7 @@ static jl_cgval_t emit_expr(jl_codectx_t &ctx, jl_value_t *expr, ssize_t ssaidx_\n     else if (head == jl_throw_undef_if_not_sym) {\n         assert(nargs == 2);\n         jl_sym_t *var = (jl_sym_t*)args[0];\n-        Value *cond = ctx.builder.CreateTrunc(emit_unbox(ctx, getInt8Ty(ctx.builder.getContext()), emit_expr(ctx, args[1]), (jl_value_t*)jl_bool_type), getInt1Ty(ctx.builder.getContext()));\n+        Value *cond = emit_unbox(ctx, getInt1Ty(ctx.builder.getContext()), update_julia_type(ctx, emit_expr(ctx, args[1]), (jl_value_t*)jl_bool_type));\n         if (var == jl_getfield_undefref_sym) {\n             raise_exception_unless(ctx, cond,\n                 literal_pointer_val(ctx, jl_undefref_exception));\n@@ -6808,7 +6950,7 @@ static Function *emit_modifyhelper(jl_codectx_t &ctx2, const jl_cgval_t &op, con\n     jl_cgval_t ret = emit_invoke(ctx, modifyop, argv, 3, (jl_value_t*)jl_any_type, true);\n     emit_typecheck(ctx, ret, jltype, fname);\n     ret = update_julia_type(ctx, ret, jltype);\n-    ctx.builder.CreateRet(emit_unbox(ctx, elty, ret, jltype));\n+    ctx.builder.CreateRet(emit_unbox(ctx, elty, ret));\n     if (ctx.topalloca->use_empty()) {\n       ctx.topalloca->eraseFromParent();\n       ctx.topalloca = nullptr;\n@@ -6971,28 +7113,41 @@ static void emit_specsig_to_specsig(\n             ctx.builder.CreateRetVoid();\n         }\n         else {\n-            ctx.builder.CreateRet(emit_unbox(ctx, gfrt, gf_retval, rettype));\n+            ctx.builder.CreateRet(emit_unbox(ctx, gfrt, gf_retval));\n         }\n         break;\n     }\n     case jl_returninfo_t::SRet: {\n         Value *sret = &*gf_thunk->arg_begin();\n         Align align(julia_alignment(rettype));\n-        if (return_roots) {\n-            Value *roots = gf_thunk->arg_begin() + 1; // root1 has type [n x {}*]*\n-            split_value_into(ctx, gf_retval, align, sret, align, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack), roots, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe));\n-        }\n-        else {\n-            emit_unbox_store(ctx, gf_retval, sret, ctx.tbaa().tbaa_stack, align, align);\n-        }\n+        Value *roots = return_roots ? gf_thunk->arg_begin() + 1 : nullptr; // root1 has type [n x {}*]*\n+        split_value_into(ctx, gf_retval, align, sret, align, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack), roots, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe));\n         ctx.builder.CreateRetVoid();\n         break;\n     }\n     case jl_returninfo_t::Union: {\n-        Value *gf_ret = boxed(ctx, gf_retval); // TODO: this is not the most optimal way to emit this\n         Type *retty = gf_thunk->getReturnType();\n-        Value *retval = UndefValue::get(retty);\n-        Value *tindex = compute_box_tindex(ctx, emit_typeof(ctx, gf_retval, false, true), (jl_value_t*)jl_any_type, rettype);\n+        jl_cgval_t retvalinfo = convert_julia_type_to_union(ctx, gf_retval, rettype, false);\n+        if (retvalinfo.typ == jl_bottom_type) {\n+            CreateTrap(ctx.builder, false);\n+            break;\n+        }\n+        Value *tindex = retvalinfo.TIndex;\n+        Value *gf_ret = boxed(ctx, gf_retval); // TODO: this is not the most optimal way to emit this\n+        if (!retvalinfo.inline_roots.empty()) {\n+            auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n+            ArrayRef<Value*> inline_roots(retvalinfo.inline_roots);\n+            Argument *roots;\n+            if (return_roots) {\n+                roots = gf_thunk->arg_begin() + 1; // root1 has type [n x {}*]*\n+                inline_roots = inline_roots.slice(0, std::min(inline_roots.size(), (size_t)return_roots)); // TODO: unreachable?\n+            }\n+            else {\n+                roots = gf_thunk->arg_begin(); // root1 has type [n x {}*]*\n+            }\n+            store_all_roots(ctx, inline_roots, roots, roots_ai, false);\n+        }\n+        Value *retval = Constant::getNullValue(retty);\n         tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER));\n         retval = ctx.builder.CreateInsertValue(retval, gf_ret, 0);\n         retval = ctx.builder.CreateInsertValue(retval, tindex, 1);\n@@ -7513,7 +7668,7 @@ static Function *gen_cfun_wrapper(\n     else if (!type_is_ghost(sig.lrt)) {\n         Type *prt = sig.prt;\n         bool issigned = jl_signed_type && jl_subtype(declrt, (jl_value_t*)jl_signed_type);\n-        Value *v = emit_unbox(ctx, sig.lrt, retval, retval.typ);\n+        Value *v = emit_unbox(ctx, sig.lrt, retval);\n         r = llvm_type_rewrite(ctx, v, prt, issigned);\n         if (sig.sret) {\n             ctx.builder.CreateStore(r, sretPtr);\n@@ -7876,6 +8031,8 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n     Type *rt = NULL;\n     Type *srt = NULL;\n     Type *T_prjlvalue = PointerType::get(M->getContext(), AddressSpace::Tracked);\n+    bool all_roots = false;\n+    uint64_t tracked_count = 0;\n     if (jlrettype == (jl_value_t*)jl_bottom_type) {\n         rt = getVoidTy(M->getContext());\n         props.cc = jl_returninfo_t::Register;\n@@ -7886,13 +8043,18 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n     }\n     else if (jl_is_uniontype(jlrettype)) {\n         bool allunbox;\n-        union_alloca_type((jl_uniontype_t*)jlrettype, allunbox, props.union_bytes, props.union_align, props.union_minalign);\n-        if (props.union_bytes) {\n+        // TODO: optimize for case where sret is exactly the needed set of return_roots\n+        size_t return_roots;\n+        union_alloca_type((jl_uniontype_t*)jlrettype, allunbox, props.union_bytes, props.union_align,\n+                props.union_minalign, return_roots);\n+        props.return_roots = (int) return_roots;\n+        if (props.union_bytes || props.return_roots) {\n             props.cc = jl_returninfo_t::Union;\n             fsig.push_back(PointerType::getUnqual(M->getContext()));\n             argnames.push_back(\"union_bytes_return\");\n             Type *pair[] = { T_prjlvalue, getInt8Ty(M->getContext()) };\n             rt = StructType::get(M->getContext(), ArrayRef<Type*>(pair));\n+            tracked_count = props.return_roots;\n         }\n         else if (allunbox) {\n             props.cc = jl_returninfo_t::Ghosts;\n@@ -7909,6 +8071,8 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n         if (rt != getVoidTy(M->getContext()) && deserves_sret(jlrettype, rt)) {\n             auto tracked = CountTrackedPointers(rt, true);\n             assert(!tracked.derived);\n+            all_roots = tracked.all;\n+            tracked_count = tracked.count;\n             if (tracked.count && !tracked.all) {\n                 props.return_roots = tracked.count;\n                 assert(props.return_roots == ((jl_datatype_t*)jlrettype)->layout->npointers);\n@@ -7936,6 +8100,10 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n         assert(srt);\n         AttrBuilder param(M->getContext());\n         param.addStructRetAttr(srt);\n+        if (all_roots) {\n+            assert(!props.return_roots);\n+            param.addAttribute(\"julia.return_roots\", std::to_string(tracked_count));\n+        }\n         param.addAttribute(Attribute::NoAlias);\n         param.addAttribute(Attribute::NoCapture);\n         param.addAttribute(Attribute::NoUndef);\n@@ -7956,6 +8124,7 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n         param.addAttribute(Attribute::NoAlias);\n         param.addAttribute(Attribute::NoCapture);\n         param.addAttribute(Attribute::NoUndef);\n+        param.addAttribute(\"julia.return_roots\", std::to_string(props.return_roots));\n         attrs.push_back(AttributeSet::get(M->getContext(), param));\n         fsig.push_back(getPointerTy(M->getContext()));\n         argnames.push_back(\"return_roots\");\n@@ -8596,8 +8765,8 @@ static jl_llvm_functions_t\n         }\n         else if (jl_is_uniontype(jt)) {\n             bool allunbox;\n-            size_t align, nbytes;\n-            Value *lv = try_emit_union_alloca(ctx, (jl_uniontype_t*)jt, allunbox, align, nbytes);\n+            size_t align, nbytes, inline_roots;\n+            Value *lv = try_emit_union_alloca(ctx, (jl_uniontype_t*)jt, allunbox, align, nbytes, inline_roots);\n             if (lv) {\n                 lv->setName(jl_symbol_name(s));\n                 varinfo.value = mark_julia_slot(lv, jt, NULL, ctx.tbaa().tbaa_stack);\n@@ -8616,6 +8785,11 @@ static jl_llvm_functions_t\n             }\n             if (lv || allunbox)\n                 alloc_def_flag(ctx, varinfo);\n+            if (inline_roots) {\n+                AllocaInst *roots = emit_static_roots(ctx, inline_roots);\n+                varinfo.inline_roots = roots;\n+                varinfo.inline_roots_count = inline_roots;\n+            }\n             if (allunbox)\n                 return;\n         }\n@@ -8627,6 +8801,7 @@ static jl_llvm_functions_t\n             if (roots) roots->setName(StringRef(\".roots.\") + jl_symbol_name(s));\n             varinfo.value = mark_julia_slot(bits, jt, NULL, ctx.tbaa().tbaa_stack, None);\n             varinfo.inline_roots = roots;\n+            varinfo.inline_roots_count = sizes.second;\n             alloc_def_flag(ctx, varinfo);\n             if (debug_enabled && varinfo.dinfo) {\n                 assert((Metadata*)varinfo.dinfo->getType() != debugcache.jl_pvalue_dillvmt);\n@@ -8999,7 +9174,7 @@ static jl_llvm_functions_t\n                 func = NULL;\n             }\n         };\n-        prev_lineinfo.resize(0);\n+        prev_lineinfo.truncate(0);\n         std::swap(prev_lineinfo, new_lineinfo);\n         bool updated = append_lineinfo(src->debuginfo, (jl_value_t*)lam, 0, pc + 1);\n         if (!updated)\n@@ -9204,7 +9379,7 @@ static jl_llvm_functions_t\n                 emit_typecheck(ctx, retvalinfo, jlrettype, \"OpaqueClosure\");\n             }\n \n-            retvalinfo = convert_julia_type(ctx, retvalinfo, jlrettype);\n+            retvalinfo = update_julia_type(ctx, retvalinfo, jlrettype);\n             if (retvalinfo.typ == jl_bottom_type) {\n                 CreateTrap(ctx.builder, false);\n                 find_next_stmt(-1);\n@@ -9214,6 +9389,7 @@ static jl_llvm_functions_t\n             Value *isboxed_union = NULL;\n             Value *retval = NULL;\n             Value *sret = has_sret ? f->arg_begin() : NULL;\n+            SmallVector<Value*,0> inline_roots;\n             Type *retty = f->getReturnType();\n             switch (returninfo.cc) {\n             case jl_returninfo_t::Boxed:\n@@ -9223,75 +9399,69 @@ static jl_llvm_functions_t\n                 if (type_is_ghost(retty))\n                     retval = NULL;\n                 else\n-                    retval = emit_unbox(ctx, retty, retvalinfo, jlrettype);\n+                    retval = emit_unbox(ctx, retty, retvalinfo);\n                 break;\n-            case jl_returninfo_t::SRet:\n+            case jl_returninfo_t::SRet: {\n                 retval = NULL;\n+                jl_datatype_t *jt = (jl_datatype_t*)jlrettype;\n+                assert(jl_is_concrete_type(jlrettype) && jlrettype == retvalinfo.typ);\n+                auto npointers = jl_datatype_layout(jt)->npointers;\n+                if (npointers)\n+                    inline_roots = extract_gc_roots(ctx, retvalinfo, npointers);\n                 break;\n+            }\n             case jl_returninfo_t::Union: {\n-                Value *data, *tindex;\n-                if (retvalinfo.TIndex) {\n-                    tindex = retvalinfo.TIndex;\n-                    data = Constant::getNullValue(ctx.types().T_prjlvalue);\n-                    if (retvalinfo.V == NULL) {\n-                        // treat this as a simple Ghosts\n-                        sret = NULL;\n-                    }\n-                    else if (retvalinfo.Vboxed) {\n-                        // also need to account for the possibility the return object is boxed\n-                        // and avoid / skip copying it to the stack\n-                        isboxed_union = ctx.builder.CreateICmpNE(\n-                            ctx.builder.CreateAnd(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER)),\n-                            ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n-                        data = ctx.builder.CreateSelect(isboxed_union, retvalinfo.Vboxed, data);\n-                    }\n+                retvalinfo = convert_julia_type_to_union(ctx, retvalinfo, jlrettype, false);\n+                if (retvalinfo.typ == jl_bottom_type) {\n+                    CreateTrap(ctx.builder, false);\n+                    find_next_stmt(-1);\n+                    continue;\n                 }\n-                else {\n-                    // treat this as a simple boxed returninfo\n-                    //assert(retvalinfo.isboxed);\n-                    tindex = compute_tindex_unboxed(ctx, retvalinfo, jlrettype);\n-                    tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER));\n-                    data = boxed(ctx, retvalinfo);\n-                    sret = NULL;\n+                inline_roots = retvalinfo.inline_roots;\n+                Value *tindex = retvalinfo.TIndex;\n+                if (retvalinfo.isboxed || retvalinfo.V == NULL) { // includes isboxed || isconstant || isghost\n+                    sret = NULL; // skip copy\n+                }\n+                else if (retvalinfo.Vboxed) {\n+                    // also need to account for the possibility the return object is boxed\n+                    // and avoid / skip attempting to copy it to the stack\n+                    isboxed_union = ctx.builder.CreateICmpNE(\n+                        ctx.builder.CreateAnd(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER)),\n+                        ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n                 }\n-                retval = UndefValue::get(retty);\n-                retval = ctx.builder.CreateInsertValue(retval, data, 0);\n+                Value *data = retvalinfo.isboxed ? boxed(ctx, retvalinfo) : retvalinfo.Vboxed;\n+                retval = Constant::getNullValue(retty);\n+                if (data)\n+                    retval = ctx.builder.CreateInsertValue(retval, data, 0);\n                 retval = ctx.builder.CreateInsertValue(retval, tindex, 1);\n                 break;\n             }\n             case jl_returninfo_t::Ghosts:\n                 retval = compute_tindex_unboxed(ctx, retvalinfo, jlrettype);\n                 break;\n             }\n+            auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n             if (sret) {\n-                Align align(returninfo.union_align);\n-                if (!returninfo.return_roots && !retvalinfo.inline_roots.empty()) {\n-                    assert(retvalinfo.V == nullptr);\n-                    assert(returninfo.cc == jl_returninfo_t::SRet);\n-                    split_value_into(ctx, retvalinfo, align, nullptr, align,\n-                            jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack), sret, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe));\n-                }\n-                else if (returninfo.return_roots) {\n-                    assert(returninfo.cc == jl_returninfo_t::SRet);\n-                    Value *return_roots = f->arg_begin() + 1;\n-                    split_value_into(ctx, retvalinfo, align, sret, align,\n-                            jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack), return_roots, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe));\n-                }\n-                else if (retvalinfo.ispointer()) {\n-                    if (returninfo.cc == jl_returninfo_t::SRet) {\n-                        assert(jl_is_concrete_type(jlrettype));\n-                        emit_memcpy(ctx, sret, jl_aliasinfo_t::fromTBAA(ctx, nullptr), retvalinfo,\n-                                    jl_datatype_size(jlrettype), align, align);\n-                    }\n-                    else { // must be jl_returninfo_t::Union\n-                        emit_unionmove(ctx, sret, nullptr, retvalinfo, /*skip*/isboxed_union);\n-                    }\n+                if (returninfo.return_roots || !inline_roots.empty() || retvalinfo.ispointer()) {\n+                    emit_unionmove(ctx, sret, jlrettype, ctx.tbaa().tbaa_stack, retvalinfo, /*skip*/isboxed_union);\n                 }\n-                else {\n+                else if (retvalinfo.V) {\n+                    Align align(returninfo.union_align);\n                     ctx.builder.CreateAlignedStore(retvalinfo.V, sret, align);\n                     assert(retvalinfo.TIndex == NULL && \"unreachable\"); // unimplemented representation\n                 }\n             }\n+            // If we have consecutive roots in `V`, should we use a memcpy instead?\n+            if (returninfo.return_roots) {\n+                assert(inline_roots.size() <= returninfo.return_roots);\n+                Value *return_roots = f->arg_begin() + 1;\n+                store_all_roots(ctx, inline_roots, return_roots, roots_ai, false);\n+            }\n+            else if (!inline_roots.empty()) {\n+                assert(inline_roots.size() <= (size_t)returninfo.union_bytes / sizeof(void*));\n+                Value *return_roots = f->arg_begin();\n+                store_all_roots(ctx, inline_roots, return_roots, roots_ai, false);\n+            }\n \n             mallocVisitStmt(sync_bytes, have_dbg_update);\n             // N.B.: For toplevel thunks, we expect world age restore to be handled\n@@ -9492,32 +9662,31 @@ static jl_llvm_functions_t\n             jl_cgval_t val = emit_expr(ctx, value);\n             if (val.constant)\n                 val = mark_julia_const(ctx, val.constant); // be over-conservative at making sure `.typ` is set concretely, not tindex\n-            if (!jl_is_uniontype(phiType) || !TindexN) {\n+            if (!TindexN) {\n                 if (VN) {\n                     assert(roots.empty() && !dest);\n                     Value *V;\n                     if (val.typ == (jl_value_t*)jl_bottom_type) {\n                         V = undef_value_for_type(VN->getType());\n                     }\n                     else if (VN->getType() == ctx.types().T_prjlvalue) {\n-                        // Includes the jl_is_uniontype(phiType) && !TindexN case\n-                        // TODO: if convert_julia_type says it is wasted effort and to skip it, is it worth using Constant::getNullValue(ctx.types().T_prjlvalue) (dynamically)?\n+                        // TODO: if emit_isa_and_defined says it is wasted effort and to skip it, is it worth using Constant::getNullValue(ctx.types().T_prjlvalue) (dynamically)?\n                         V = boxed(ctx, val);\n                     }\n                     else {\n                         // must be careful to emit undef here (rather than a bitcast or\n                         // load of val) if the runtime type of val isn't phiType\n                         Value *isvalid = emit_isa_and_defined(ctx, val, phiType);\n                         V = emit_guarded_test(ctx, isvalid, undef_value_for_type(VN->getType()), [&] {\n-                            return emit_unbox(ctx, VN->getType(), val, phiType);\n+                            return emit_unbox(ctx, VN->getType(), update_julia_type(ctx, val, phiType));\n                         });\n                     }\n                     VN->addIncoming(V, ctx.builder.GetInsertBlock());\n-                    assert(!TindexN);\n                 }\n                 else if ((dest || !roots.empty()) && val.typ != (jl_value_t*)jl_bottom_type) {\n                     // must be careful to emit undef here (rather than a bitcast or\n                     // load of val) if the runtime type of val isn't phiType\n+                    assert(jl_is_concrete_type(phiType));\n                     auto tracked = split_value_size((jl_datatype_t*)phiType).second;\n                     Value *isvalid = emit_isa_and_defined(ctx, val, phiType);\n                     assert(roots.size() == tracked && isvalid != nullptr);\n@@ -9526,86 +9695,76 @@ static jl_llvm_functions_t\n                         incomingroots.resize(tracked, Constant::getNullValue(ctx.types().T_prjlvalue));\n                     emit_guarded_test(ctx, isvalid, incomingroots, [&] {\n                         jl_cgval_t typedval = update_julia_type(ctx, val, phiType);\n-                        SmallVector<Value*,0> mayberoots(tracked, Constant::getNullValue(ctx.types().T_prjlvalue));\n+                        SmallVector<Value*,0> mayberoots;\n                         if (typedval.typ != jl_bottom_type) {\n                             Align align(julia_alignment(phiType));\n-                            if (tracked)\n-                                split_value_into(ctx, typedval, align, dest, align, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack), mayberoots);\n-                            else\n-                                emit_unbox_store(ctx, typedval, dest, ctx.tbaa().tbaa_stack, align, align);\n+                            assert(typedval.typ == phiType);\n+                            split_value_into(ctx, typedval, align, dest, align, jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack), false);\n+                            if (tracked) {\n+                                mayberoots = extract_gc_roots(ctx, typedval, tracked);\n+                            }\n                         }\n+                        mayberoots.resize(tracked, Constant::getNullValue(ctx.types().T_prjlvalue));\n                         return mayberoots;\n                     });\n                     for (size_t nr = 0; nr < tracked; nr++)\n                         roots[nr]->addIncoming(incomingroots[nr], ctx.builder.GetInsertBlock());\n                 }\n                 else if (!roots.empty()) {\n-                    Value *V = Constant::getNullValue(ctx.types().T_prjlvalue);\n+                    Value *Vnull = Constant::getNullValue(ctx.types().T_prjlvalue);\n                     for (size_t nr = 0; nr < roots.size(); nr++)\n-                        roots[nr]->addIncoming(V, ctx.builder.GetInsertBlock());\n+                        roots[nr]->addIncoming(Vnull, ctx.builder.GetInsertBlock());\n                 }\n             }\n-            else {\n-                Value *RTindex;\n-                // The branch below is a bit too complex for GCC to realize that\n-                // `V` is always initialized when it is used.\n-                // Ref https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96629\n+            else { // TIndexN union\n+                assert(jl_is_uniontype(phiType));\n+                // must compute skip here, since the runtime type of val might not be in phiType\n+                // caution: only Phi and PhiC are allowed to do this (and maybe sometimes Pi)\n+                jl_cgval_t new_union = convert_julia_type_to_union(ctx, val, phiType, true);\n+                Value *Vnull = Constant::getNullValue(ctx.types().T_prjlvalue);\n+                SmallVector<Value*,0> lroots(roots.size(), Vnull);\n+                Value *RTindex = new_union.TIndex;\n                 Value *V = nullptr;\n-                assert(roots.empty());\n-                if (val.typ == (jl_value_t*)jl_bottom_type) {\n-                    if (VN)\n-                        V = undef_value_for_type(VN->getType());\n-                    RTindex = UndefValue::get(getInt8Ty(ctx.builder.getContext()));\n+                if (VN) {\n+                    if (new_union.Vboxed)\n+                        V = new_union.Vboxed;\n+                    else if (new_union.constant)\n+                        V = boxed(ctx, new_union);\n+                    else\n+                        V = Constant::getNullValue(ctx.types().T_prjlvalue);\n+                }\n+                if (new_union.typ == (jl_value_t*)jl_bottom_type) {\n+                    RTindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER);\n                 }\n                 else if (jl_is_concrete_type(val.typ) || val.constant) {\n                     size_t tindex = get_box_tindex((jl_datatype_t*)(val.constant ? jl_typeof(val.constant) : val.typ), phiType);\n-                    if (tindex == 0) {\n-                        if (VN)\n-                            V = boxed(ctx, val);\n-                        RTindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER);\n-                    }\n-                    else {\n-                        if (VN)\n-                            V = Constant::getNullValue(ctx.types().T_prjlvalue);\n-                        if (dest) {\n-                            Align align(julia_alignment(val.typ));\n-                            emit_unbox_store(ctx, val, dest, ctx.tbaa().tbaa_stack, align, align);\n-                        }\n-                        RTindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), tindex);\n+                    if (tindex && dest && (!VN || !val.isboxed)) {\n+                        emit_unionmove(ctx, dest, phiType, ctx.tbaa().tbaa_stack, val, nullptr);\n                     }\n                 }\n                 else {\n-                    Value *skip = NULL;\n-                    // must compute skip here, since the runtime type of val might not be in phiType\n-                    // caution: only Phi and PhiC are allowed to do this (and maybe sometimes Pi)\n-                    jl_cgval_t new_union = convert_julia_type(ctx, val, phiType, &skip);\n-                    RTindex = new_union.TIndex;\n-                    if (!RTindex) {\n-                        assert(new_union.isboxed && new_union.Vboxed && \"convert_julia_type failed\");\n-                        RTindex = compute_tindex_unboxed(ctx, new_union, phiType, true);\n-                        if (dest) {\n-                            // If dest is not set, this is a ghost union, the recipient of which\n-                            // is often not prepared to handle a boxed representation of the ghost.\n-                            RTindex = ctx.builder.CreateOr(RTindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER));\n-                        }\n-                        new_union.TIndex = RTindex;\n-                    }\n-                    if (VN)\n-                        V = new_union.Vboxed ? new_union.Vboxed : Constant::getNullValue(ctx.types().T_prjlvalue);\n-                    if (dest) { // basically, if !ghost union\n-                        if (new_union.Vboxed != nullptr) {\n-                            Value *isboxed = ctx.builder.CreateICmpNE( // if UNION_BOX_MARKER is set, we won't select this slot anyways\n-                                    ctx.builder.CreateAnd(RTindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER)),\n-                                    ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n-                            skip = skip ? ctx.builder.CreateOr(isboxed, skip) : isboxed;\n+                    Value *tindex = ctx.builder.CreateAnd(RTindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER));\n+                    if (!VN)\n+                        RTindex = tindex; // strip UNION_BOX_MARKER\n+                    if (dest && (!VN || !val.isboxed)) {\n+                        Value *skip = ctx.builder.CreateIsNull(tindex); // skip entirely if old value isn't part of the new union\n+                        if (new_union.Vboxed != nullptr && roots.empty()) {\n+                            // if UNION_BOX_MARKER is set, we won't select this slot anyways, so skip it also\n+                            Value *isboxed = ctx.builder.CreateICmpNE(\n+                                ctx.builder.CreateAnd(RTindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER)),\n+                                ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n+                            skip = ctx.builder.CreateOr(isboxed, skip);\n                         }\n-                        emit_unionmove(ctx, dest, ctx.tbaa().tbaa_arraybuf, new_union, skip);\n+                        emit_unionmove(ctx, dest, phiType, ctx.tbaa().tbaa_arraybuf, new_union, skip);\n                     }\n                 }\n+                for (size_t i = 0; i < std::min(new_union.inline_roots.size(), lroots.size()); ++i)\n+                    lroots[i] = new_union.inline_roots[i];\n+                for (size_t nr = 0; nr < roots.size(); nr++)\n+                    roots[nr]->addIncoming(lroots[nr], ctx.builder.GetInsertBlock());\n                 if (VN)\n                     VN->addIncoming(V, ctx.builder.GetInsertBlock());\n-                if (TindexN)\n-                    TindexN->addIncoming(RTindex, ctx.builder.GetInsertBlock());\n+                TindexN->addIncoming(RTindex, ctx.builder.GetInsertBlock());\n             }\n             // put the branch back at the end of our current basic block\n             ctx.builder.Insert(terminator);"
    },
    {
      "sha": "04c0929a8a895cefebaa6eb9080b4340b6de0d4f",
      "filename": "src/intrinsics.cpp",
      "status": "modified",
      "additions": 72,
      "deletions": 51,
      "changes": 123,
      "blob_url": "https://github.com/JuliaLang/julia/blob/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fintrinsics.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fintrinsics.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fintrinsics.cpp?ref=95c412a8058d723d2f1632fba005ed6dfbd5901f",
      "patch": "@@ -436,10 +436,9 @@ static Value *emit_unboxed_coercion(jl_codectx_t &ctx, Type *to, Value *unboxed)\n }\n \n // emit code to unpack a raw value from a box into registers\n-static Value *emit_unbox(jl_codectx_t &ctx, Type *to, const jl_cgval_t &x, jl_value_t *jt)\n+static Value *emit_unbox(jl_codectx_t &ctx, Type *to, const jl_cgval_t &x)\n {\n     assert(to != getVoidTy(ctx.builder.getContext()));\n-    // TODO: fully validate that x.typ == jt?\n     if (x.isghost) {\n         // this can happen when a branch yielding a different type ends\n         // up being dead code, and type inference knows that the other\n@@ -461,12 +460,12 @@ static Value *emit_unbox(jl_codectx_t &ctx, Type *to, const jl_cgval_t &x, jl_va\n     // bools stored as int8, so an extra Trunc is needed to get an int1\n     Value *p = x.constant ? literal_pointer_val(ctx, x.constant) : x.V;\n \n-    if (jt == (jl_value_t*)jl_bool_type || to->isIntegerTy(1)) {\n+    if (x.typ == (jl_value_t*)jl_bool_type || to->isIntegerTy(1)) {\n         assert(p && x.inline_roots.empty()); // clang-sa doesn't know that x.ispointer() implied these are true\n         jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, x.tbaa);\n         Instruction *unbox_load = ai.decorateInst(ctx.builder.CreateLoad(getInt8Ty(ctx.builder.getContext()), p));\n         setName(ctx.emission_context, unbox_load, p->getName() + \".unbox\");\n-        if (jt == (jl_value_t*)jl_bool_type)\n+        if (x.typ == (jl_value_t*)jl_bool_type)\n             unbox_load->setMetadata(LLVMContext::MD_range, MDNode::get(ctx.builder.getContext(), {\n                 ConstantAsMetadata::get(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0)),\n                 ConstantAsMetadata::get(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 2)) }));\n@@ -478,10 +477,9 @@ static Value *emit_unbox(jl_codectx_t &ctx, Type *to, const jl_cgval_t &x, jl_va\n         return unboxed;\n     }\n \n-    unsigned alignment = julia_alignment(jt);\n+    unsigned alignment = julia_alignment(x.typ);\n     jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, x.tbaa);\n     if (!x.inline_roots.empty()) {\n-        assert(x.typ == jt);\n         AllocaInst *combined = emit_static_alloca(ctx, to, Align(alignment));\n         auto combined_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack);\n         recombine_value(ctx, x, combined, combined_ai, Align(alignment), false);\n@@ -698,7 +696,7 @@ static jl_cgval_t generic_cast(\n     if (!to || !vt)\n         return emit_runtime_call(ctx, f, argv, 2);\n \n-    Value *from = emit_unbox(ctx, vt, v, v.typ);\n+    Value *from = emit_unbox(ctx, vt, v);\n     if (!CastInst::castIsValid(Op, from, to))\n         return emit_runtime_call(ctx, f, argv, 2);\n     if (Op == Instruction::FPExt) {\n@@ -762,12 +760,12 @@ static jl_cgval_t emit_pointerref(jl_codectx_t &ctx, ArrayRef<jl_cgval_t> argv)\n         return jl_cgval_t();\n     }\n \n-    Value *idx = emit_unbox(ctx, ctx.types().T_size, i, (jl_value_t*)jl_long_type);\n+    Value *idx = emit_unbox(ctx, ctx.types().T_size, i);\n     Value *im1 = ctx.builder.CreateSub(idx, ConstantInt::get(ctx.types().T_size, 1));\n     setName(ctx.emission_context, im1, \"pointerref_idx\");\n \n     if (ety == (jl_value_t*)jl_any_type) {\n-        Value *thePtr = emit_unbox(ctx, ctx.types().T_pprjlvalue, e, e.typ);\n+        Value *thePtr = emit_unbox(ctx, ctx.types().T_pprjlvalue, e);\n         if (isa<Instruction>(thePtr) && !thePtr->hasName())\n             setName(ctx.emission_context, thePtr, \"unbox_any_ptr\");\n         LoadInst *load = ctx.builder.CreateAlignedLoad(ctx.types().T_prjlvalue, ctx.builder.CreateInBoundsGEP(ctx.types().T_prjlvalue, thePtr, im1), Align(align_nb));\n@@ -784,7 +782,7 @@ static jl_cgval_t emit_pointerref(jl_codectx_t &ctx, ArrayRef<jl_cgval_t> argv)\n         im1 = ctx.builder.CreateMul(im1, ConstantInt::get(ctx.types().T_size,\n                     LLT_ALIGN(size, jl_datatype_align(ety))));\n         setName(ctx.emission_context, im1, \"pointerref_offset\");\n-        Value *thePtr = emit_unbox(ctx, getPointerTy(ctx.builder.getContext()), e, e.typ);\n+        Value *thePtr = emit_unbox(ctx, getPointerTy(ctx.builder.getContext()), e);\n         thePtr = emit_ptrgep(ctx, thePtr, im1);\n         setName(ctx.emission_context, thePtr, \"pointerref_src\");\n         MDNode *tbaa = best_tbaa(ctx.tbaa(), ety);\n@@ -796,7 +794,7 @@ static jl_cgval_t emit_pointerref(jl_codectx_t &ctx, ArrayRef<jl_cgval_t> argv)\n         Type *ptrty = julia_type_to_llvm(ctx, ety, &isboxed);\n         assert(!isboxed);\n         if (!type_is_ghost(ptrty)) {\n-            Value *thePtr = emit_unbox(ctx, PointerType::getUnqual(ptrty->getContext()), e, e.typ);\n+            Value *thePtr = emit_unbox(ctx, PointerType::getUnqual(ptrty->getContext()), e);\n             thePtr = ctx.builder.CreateInBoundsGEP(ptrty, thePtr, im1);\n             auto load = typed_load(ctx, thePtr, nullptr, ety, ctx.tbaa().tbaa_data, nullptr, isboxed, AtomicOrdering::NotAtomic, false, align_nb);\n             setName(ctx.emission_context, load.V, \"pointerref\");\n@@ -844,11 +842,11 @@ static jl_cgval_t emit_pointerset(jl_codectx_t &ctx, ArrayRef<jl_cgval_t> argv)\n     if (x.typ == jl_bottom_type)\n         return jl_cgval_t();\n \n-    Value *idx = emit_unbox(ctx, ctx.types().T_size, i, (jl_value_t*)jl_long_type);\n+    Value *idx = emit_unbox(ctx, ctx.types().T_size, i);\n     Value *im1 = ctx.builder.CreateSub(idx, ConstantInt::get(ctx.types().T_size, 1));\n     setName(ctx.emission_context, im1, \"pointerset_idx\");\n \n-    Value *thePtr = emit_unbox(ctx, getPointerTy(ctx.builder.getContext()), e, e.typ);\n+    Value *thePtr = emit_unbox(ctx, getPointerTy(ctx.builder.getContext()), e);\n     if (ety == (jl_value_t*)jl_any_type) {\n         // unsafe_store to Ptr{Any} is allowed to implicitly drop GC roots.\n         auto gep = ctx.builder.CreateInBoundsGEP(ctx.types().T_size, thePtr, im1);\n@@ -895,8 +893,8 @@ static jl_cgval_t emit_pointerarith(jl_codectx_t &ctx, intrinsic f,\n         return emit_runtime_call(ctx, f, argv, argv.size());\n     assert(f == add_ptr || f == sub_ptr);\n \n-    Value *ptr = emit_unbox(ctx, ctx.types().T_ptr, argv[0], ptrtyp);\n-    Value *off = emit_unbox(ctx, ctx.types().T_size, argv[1], offtyp);\n+    Value *ptr = emit_unbox(ctx, ctx.types().T_ptr, argv[0]);\n+    Value *off = emit_unbox(ctx, ctx.types().T_size, argv[1]);\n     if (f == sub_ptr)\n         off = ctx.builder.CreateNeg(off);\n     Value *ans = ctx.builder.CreateGEP(getInt8Ty(ctx.builder.getContext()), ptr, off);\n@@ -946,7 +944,7 @@ static jl_cgval_t emit_atomic_pointerref(jl_codectx_t &ctx, ArrayRef<jl_cgval_t>\n     AtomicOrdering llvm_order = get_llvm_atomic_order(order);\n \n     if (ety == (jl_value_t*)jl_any_type) {\n-        Value *thePtr = emit_unbox(ctx, ctx.types().T_pprjlvalue, e, e.typ);\n+        Value *thePtr = emit_unbox(ctx, ctx.types().T_pprjlvalue, e);\n         LoadInst *load = ctx.builder.CreateAlignedLoad(ctx.types().T_prjlvalue, thePtr, Align(sizeof(jl_value_t*)));\n         setName(ctx.emission_context, load, \"atomic_pointerref\");\n         jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_data);\n@@ -970,7 +968,7 @@ static jl_cgval_t emit_atomic_pointerref(jl_codectx_t &ctx, ArrayRef<jl_cgval_t>\n         assert(jl_is_datatype(ety));\n         Value *strct = emit_allocobj(ctx, (jl_datatype_t*)ety, true);\n         setName(ctx.emission_context, strct, \"atomic_pointerref_box\");\n-        Value *thePtr = emit_unbox(ctx, getPointerTy(ctx.builder.getContext()), e, e.typ);\n+        Value *thePtr = emit_unbox(ctx, getPointerTy(ctx.builder.getContext()), e);\n         Type *loadT = Type::getIntNTy(ctx.builder.getContext(), nb * 8);\n         MDNode *tbaa = best_tbaa(ctx.tbaa(), ety);\n         LoadInst *load = ctx.builder.CreateAlignedLoad(loadT, thePtr, Align(nb));\n@@ -988,7 +986,7 @@ static jl_cgval_t emit_atomic_pointerref(jl_codectx_t &ctx, ArrayRef<jl_cgval_t>\n         Type *ptrty = julia_type_to_llvm(ctx, ety, &isboxed);\n         assert(!isboxed);\n         if (!type_is_ghost(ptrty)) {\n-            Value *thePtr = emit_unbox(ctx, PointerType::getUnqual(ptrty->getContext()), e, e.typ);\n+            Value *thePtr = emit_unbox(ctx, PointerType::getUnqual(ptrty->getContext()), e);\n             auto load = typed_load(ctx, thePtr, nullptr, ety, ctx.tbaa().tbaa_data, nullptr, isboxed, llvm_order, false, nb);\n             setName(ctx.emission_context, load.V, \"atomic_pointerref\");\n             return load;\n@@ -1040,7 +1038,7 @@ static jl_cgval_t emit_atomic_pointerop(jl_codectx_t &ctx, intrinsic f, ArrayRef\n     if (ety == (jl_value_t*)jl_any_type) {\n         // unsafe_store to Ptr{Any} is allowed to implicitly drop GC roots.\n         // n.b.: the expected value (y) must be rooted, but not the others\n-        Value *thePtr = emit_unbox(ctx, ctx.types().T_pprjlvalue, e, e.typ);\n+        Value *thePtr = emit_unbox(ctx, ctx.types().T_pprjlvalue, e);\n         bool isboxed = true;\n         jl_cgval_t ret = typed_store(ctx, thePtr, x, y, ety, ctx.tbaa().tbaa_data, nullptr, nullptr, isboxed,\n                     llvm_order, llvm_failorder, sizeof(jl_value_t*), nullptr, issetfield, isreplacefield, isswapfield, ismodifyfield, false, false, modifyop, \"atomic_pointermodify\", nullptr, nullptr);\n@@ -1072,7 +1070,7 @@ static jl_cgval_t emit_atomic_pointerop(jl_codectx_t &ctx, intrinsic f, ArrayRef\n \n     if (!jl_isbits(ety)) {\n         //if (!deserves_stack(ety))\n-        //Value *thePtr = emit_unbox(ctx, getPointerTy(ctx.builder.getContext()), e, e.typ);\n+        //Value *thePtr = emit_unbox(ctx, getPointerTy(ctx.builder.getContext()), e);\n         //uint64_t size = jl_datatype_size(ety);\n         return emit_runtime_call(ctx, f, argv, nargs); // TODO: optimizations\n     }\n@@ -1082,7 +1080,7 @@ static jl_cgval_t emit_atomic_pointerop(jl_codectx_t &ctx, intrinsic f, ArrayRef\n         assert(!isboxed);\n         Value *thePtr;\n         if (!type_is_ghost(ptrty))\n-            thePtr = emit_unbox(ctx, PointerType::getUnqual(ptrty->getContext()), e, e.typ);\n+            thePtr = emit_unbox(ctx, PointerType::getUnqual(ptrty->getContext()), e);\n         else\n             thePtr = nullptr; // could use any value here, since typed_store will not use it\n         jl_cgval_t ret = typed_store(ctx, thePtr, x, y, ety, ctx.tbaa().tbaa_data, nullptr, nullptr, isboxed,\n@@ -1156,29 +1154,37 @@ static jl_cgval_t emit_ifelse(jl_codectx_t &ctx, jl_cgval_t c, jl_cgval_t x, jl_\n     setName(ctx.emission_context, isfalse, \"ifelse_cond\");\n     jl_value_t *t1 = x.typ;\n     jl_value_t *t2 = y.typ;\n-    // handle cases where the condition is irrelevant based on type info\n-    if (t1 == jl_bottom_type && t2 == jl_bottom_type)\n-        return jl_cgval_t(); // undefined\n+   if (t1 != t2) {\n+        // if they aren't the same type, use the expr type\n+        // to instantiate a union-split optimization\n+        x = update_julia_type(ctx, x, rt_hint);\n+        y = update_julia_type(ctx, y, rt_hint);\n+        t1 = x.typ;\n+        t2 = y.typ;\n+        if (t1 == jl_bottom_type)\n+            return y;\n+        if (t2 == jl_bottom_type)\n+            return x;\n+        if (t1 != t2 && jl_is_uniontype(rt_hint) && is_uniontype_anyunboxed(rt_hint)) {\n+            x = convert_julia_type_to_union(ctx, x, rt_hint, false);\n+            y = convert_julia_type_to_union(ctx, y, rt_hint, false);\n+            t1 = x.typ;\n+            t2 = y.typ;\n+        }\n+    }\n     if (t1 == jl_bottom_type)\n         return y;\n     if (t2 == jl_bottom_type)\n         return x;\n-\n     if (t1 != t2) {\n-        // type inference may know something we don't, in which case it may\n-        // be illegal for us to convert to rt_hint. Check first if either\n-        // of the types have empty intersection with the result type,\n-        // in which case, we may use the other one.\n-        if (jl_type_intersection(t1, rt_hint) == jl_bottom_type)\n-            return y;\n-        else if (jl_type_intersection(t2, rt_hint) == jl_bottom_type)\n-            return x;\n-        // if they aren't the same type, consider using the expr type\n-        // to instantiate a union-split optimization\n-        x = convert_julia_type(ctx, x, rt_hint);\n-        y = convert_julia_type(ctx, y, rt_hint);\n+        x = mark_julia_type(ctx, boxed(ctx, x), true, rt_hint);\n+        y = mark_julia_type(ctx, boxed(ctx, y), true, rt_hint);\n         t1 = x.typ;\n         t2 = y.typ;\n+        if (t1 == jl_bottom_type)\n+            return y;\n+        if (t2 == jl_bottom_type)\n+            return x;\n     }\n \n     Value *ifelse_result;\n@@ -1188,26 +1194,41 @@ static jl_cgval_t emit_ifelse(jl_codectx_t &ctx, jl_cgval_t c, jl_cgval_t x, jl_\n         if (type_is_ghost(llt1))\n             return x;\n         ifelse_result = ctx.builder.CreateSelect(isfalse,\n-                emit_unbox(ctx, llt1, y, t1),\n-                emit_unbox(ctx, llt1, x, t1));\n+                emit_unbox(ctx, llt1, y),\n+                emit_unbox(ctx, llt1, x));\n     }\n     else {\n         Value *x_tindex = x.TIndex;\n         Value *y_tindex = y.TIndex;\n         if (x_tindex || y_tindex) {\n-            if (!x.isghost)\n-                x = value_to_pointer(ctx, x);\n-            if (!y.isghost)\n-                y = value_to_pointer(ctx, y);\n             Value *x_vboxed = x.Vboxed;\n             Value *y_vboxed = y.Vboxed;\n-            Value *x_ptr = (x.isghost ? NULL : data_pointer(ctx, x));\n-            Value *y_ptr = (y.isghost ? NULL : data_pointer(ctx, y));\n-            MDNode *ifelse_tbaa;\n-            if (!x.isghost && x.constant)\n+            Value *x_ptr = NULL;\n+            Value *y_ptr = NULL;\n+            if (!x.isghost && x.constant) {\n+                x_ptr = data_pointer(ctx, x);\n                 x_vboxed = boxed(ctx, x);\n-            if (!y.isghost && y.constant)\n+            } else if (!x.isghost && x.V != NULL) {\n+                x_ptr = maybe_decay_tracked(ctx, x.V);\n+            }\n+            if (!y.isghost && y.constant) {\n+                y_ptr = data_pointer(ctx, y);\n                 y_vboxed = boxed(ctx, y);\n+            } else if (!y.isghost && y.V != NULL) {\n+                y_ptr = maybe_decay_tracked(ctx, y.V);\n+            }\n+            auto nroots = std::max(x.inline_roots.size(), y.inline_roots.size());\n+            Value *Vnull = Constant::getNullValue(ctx.types().T_prjlvalue);\n+            SmallVector<Value *, 0> ifelse_roots(nroots, Vnull);\n+            for (size_t i = 0; i < nroots; i++) {\n+                Value *x_root = Vnull, *y_root = Vnull;\n+                if (i < x.inline_roots.size())\n+                    x_root = x.inline_roots[i];\n+                if (i < y.inline_roots.size())\n+                    y_root = y.inline_roots[i];\n+                ifelse_roots[i] = ctx.builder.CreateSelect(isfalse, y_root, x_root);\n+            }\n+            MDNode *ifelse_tbaa;\n             if (!x_ptr && !y_ptr) { // both ghost\n                 ifelse_result = NULL;\n                 ifelse_tbaa = ctx.tbaa().tbaa_stack;\n@@ -1271,7 +1292,7 @@ static jl_cgval_t emit_ifelse(jl_codectx_t &ctx, jl_cgval_t c, jl_cgval_t x, jl_\n                 tindex = ret;\n                 setName(ctx.emission_context, tindex, \"ifelse_tindex\");\n             }\n-            jl_cgval_t ret = mark_julia_slot(ifelse_result, rt_hint, tindex, ifelse_tbaa);\n+            jl_cgval_t ret = mark_julia_slot(ifelse_result, rt_hint, tindex, ifelse_tbaa, ifelse_roots);\n             if (x_vboxed || y_vboxed) {\n                 if (!x_vboxed)\n                     x_vboxed = ConstantPointerNull::get(cast<PointerType>(y_vboxed->getType()));\n@@ -1399,7 +1420,7 @@ static jl_cgval_t emit_intrinsic(jl_codectx_t &ctx, intrinsic f, jl_value_t **ar\n         if (!jl_is_primitivetype(x.typ))\n             return emit_runtime_call(ctx, f, argv, nargs);\n         Type *xt = INTT(bitstype_to_llvm(x.typ, ctx.builder.getContext(), true), DL);\n-        Value *from = emit_unbox(ctx, xt, x, x.typ);\n+        Value *from = emit_unbox(ctx, xt, x);\n         Value *ans = ctx.builder.CreateNot(from);\n         return mark_julia_type(ctx, ans, false, x.typ);\n     }\n@@ -1472,7 +1493,7 @@ static jl_cgval_t emit_intrinsic(jl_codectx_t &ctx, intrinsic f, jl_value_t **ar\n         // unbox the arguments\n         SmallVector<Value *, 0> argvalues(nargs);\n         for (size_t i = 0; i < nargs; ++i) {\n-            argvalues[i] = emit_unbox(ctx, argt[i], argv[i], argv[i].typ);\n+            argvalues[i] = emit_unbox(ctx, argt[i], argv[i]);\n         }\n \n         // call the intrinsic"
    },
    {
      "sha": "6840d7100e5ff66d4953a52708e23c08692df691",
      "filename": "src/llvm-codegen-shared.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fllvm-codegen-shared.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fllvm-codegen-shared.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fllvm-codegen-shared.h?ref=95c412a8058d723d2f1632fba005ed6dfbd5901f",
      "patch": "@@ -103,7 +103,7 @@ struct CountTrackedPointers {\n     CountTrackedPointers(llvm::Type *T, bool ignore_loaded=false);\n };\n \n-llvm::SmallVector<llvm::Value*, 0> ExtractTrackedValues(llvm::Value *Src, llvm::Type *STy, bool isptr, llvm::IRBuilder<> &irbuilder, llvm::ArrayRef<unsigned> perm_offsets={});\n+llvm::SmallVector<llvm::SmallVector<unsigned, 0>, 0> TrackCompositeType(llvm::Type *T);\n \n static inline void llvm_dump(llvm::Value *v)\n {"
    },
    {
      "sha": "4511c30924ddc12d22a462124d55dd52cc1a71b8",
      "filename": "src/llvm-late-gc-lowering.cpp",
      "status": "modified",
      "additions": 34,
      "deletions": 127,
      "changes": 161,
      "blob_url": "https://github.com/JuliaLang/julia/blob/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fllvm-late-gc-lowering.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/95c412a8058d723d2f1632fba005ed6dfbd5901f/src%2Fllvm-late-gc-lowering.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fllvm-late-gc-lowering.cpp?ref=95c412a8058d723d2f1632fba005ed6dfbd5901f",
      "patch": "@@ -78,7 +78,7 @@ unsigned getCompositeNumElements(Type *T) {\n }\n \n // Walk through a Type, and record the element path to every tracked value inside\n-void TrackCompositeType(Type *T, SmallVector<unsigned, 0> &Idxs, SmallVector<SmallVector<unsigned, 0>, 0> &Numberings) {\n+static void TrackCompositeType(Type *T, SmallVector<unsigned, 0> &Idxs, SmallVector<SmallVector<unsigned, 0>, 0> &Numberings) {\n     if (isa<PointerType>(T)) {\n         if (isSpecialPtr(T))\n             Numberings.push_back(Idxs);\n@@ -1149,43 +1149,49 @@ void LateLowerGCFrame::FixUpRefinements(ArrayRef<int> PHINumbers, State &S)\n }\n \n // Look through instructions to find all possible allocas that might become the sret argument\n-static std::optional<SmallSetVector<AllocaInst *, 8>> FindSretAllocas(Value* SRetArg) {\n-    SmallSetVector<AllocaInst *, 8> allocas;\n+static SmallSetVector<AllocaInst *, 1> FindSretAllocas(Value* SRetArg) {\n+    SmallSetVector<AllocaInst *, 1> allocas;\n     if (AllocaInst *OneSRet = dyn_cast<AllocaInst>(SRetArg)) {\n         allocas.insert(OneSRet); // Found it directly\n-    } else {\n+    }\n+    else {\n         SmallSetVector<Value *, 8> worklist;\n         worklist.insert(SRetArg);\n         while (!worklist.empty()) {\n             Value *V = worklist.pop_back_val();\n             if (AllocaInst *Alloca = dyn_cast<AllocaInst>(V->stripInBoundsOffsets())) {\n                 allocas.insert(Alloca); // Found a candidate\n-            } else if (PHINode *Phi = dyn_cast<PHINode>(V)) {\n+            }\n+            else if (PHINode *Phi = dyn_cast<PHINode>(V)) {\n                 for (Value *Incoming : Phi->incoming_values()) {\n                     worklist.insert(Incoming);\n                 }\n-            } else if (SelectInst *SI = dyn_cast<SelectInst>(V)) {\n+            }\n+            else if (SelectInst *SI = dyn_cast<SelectInst>(V)) {\n                 auto TrueBranch = SI->getTrueValue();\n                 auto FalseBranch = SI->getFalseValue();\n                 if (TrueBranch && FalseBranch) {\n                     worklist.insert(TrueBranch);\n                     worklist.insert(FalseBranch);\n-                } else {\n+                }\n+                else {\n                     llvm_dump(SI);\n                     dbgs() << \"Malformed Select\\n\";\n-                    return {};\n+                    allocas.clear();\n+                    return allocas;\n                 }\n-            } else {\n+            }\n+            else {\n                 llvm_dump(V);\n                 dbgs() << \"Unexpected SRet argument\\n\";\n-                return {};\n+                allocas.clear();\n+                return allocas;\n             }\n         }\n     }\n-    assert(allocas.size() > 0);\n     assert(std::all_of(allocas.begin(), allocas.end(), [&] (AllocaInst* SRetAlloca) JL_NOTSAFEPOINT {\n             return (SRetAlloca->getArraySize() == allocas[0]->getArraySize() &&\n-            SRetAlloca->getAllocatedType() == allocas[0]->getAllocatedType());\n+                SRetAlloca->getAllocatedType() == allocas[0]->getAllocatedType());\n         }\n     ));\n     return allocas;\n@@ -1245,48 +1251,28 @@ State LateLowerGCFrame::LocalScan(Function &F) {\n                         BBS.FirstSafepointAfterFirstDef = BBS.FirstSafepoint;\n                 }\n                 bool HasDefBefore = false;\n-                if (CI->hasStructRetAttr()) {\n-                    Type *ElT = getAttributeAtIndex(CI->getAttributes(), 1, Attribute::StructRet).getValueAsType();\n-                    auto tracked = CountTrackedPointers(ElT, true);\n-                    if (tracked.count) {\n+                // Loop over all arguments to find those with \"julia.return_roots\" attribute\n+                AttributeList Attrs = CI->getAttributes();\n+                for (unsigned i = 0; i < CI->arg_size(); ++i) {\n+                    Attribute RetRootsAttr = Attrs.getParamAttr(i, \"julia.return_roots\");\n+                    if (RetRootsAttr.isValid()) {\n+                        size_t return_roots = atol(RetRootsAttr.getValueAsString().data());\n+                        assert(return_roots);\n                         HasDefBefore = true;\n-                        auto allocas_opt = FindSretAllocas((CI->arg_begin()[0])->stripInBoundsOffsets());\n+                        auto gc_allocas = FindSretAllocas(CI->getArgOperand(i)->stripInBoundsOffsets());\n                         // We know that with the right optimizations we can forward a sret directly from an argument\n                         // This hasn't been seen without adding IPO effects to julia functions but it's possible we need to handle that too\n-                        // If they are tracked.all we can just pass through but if they have a roots bundle it's possible we need to emit some copies \u00af\\_(\u30c4)_/\u00af\n-                        if (!allocas_opt.has_value()) {\n+                        if (gc_allocas.size() == 0) {\n                             llvm_dump(&F);\n                             abort();\n                         }\n-                        auto allocas = allocas_opt.value();\n-                        for (AllocaInst *SRet : allocas) {\n-                            if (!(SRet->isStaticAlloca() && isa<PointerType>(ElT) && ElT->getPointerAddressSpace() == AddressSpace::Tracked)) {\n-                                assert(!tracked.derived);\n-                                if (tracked.all) {\n-                                    S.ArrayAllocas[SRet] = tracked.count * cast<ConstantInt>(SRet->getArraySize())->getZExtValue();\n-                                }\n-                                else {\n-                                    Value *arg1 = (CI->arg_begin()[1])->stripInBoundsOffsets();\n-                                    auto gc_allocas_opt = FindSretAllocas(arg1);\n-                                    if (!gc_allocas_opt.has_value()) {\n-                                        llvm_dump(&F);\n-                                        abort();\n-                                    }\n-                                    auto gc_allocas = gc_allocas_opt.value();\n-                                    if (gc_allocas.size() == 0) {\n-                                        llvm_dump(CI);\n-                                        errs() << \"Expected one Alloca at least\\n\";\n-                                        abort();\n-                                    }\n-                                    else {\n-                                        for (AllocaInst* SRet_gc : gc_allocas) {\n-                                            Type *ElT = SRet_gc->getAllocatedType();\n-                                            if (!(SRet_gc->isStaticAlloca() && isa<PointerType>(ElT) && ElT->getPointerAddressSpace() == AddressSpace::Tracked)) {\n-                                                S.ArrayAllocas[SRet_gc] = tracked.count * cast<ConstantInt>(SRet_gc->getArraySize())->getZExtValue();\n-                                            }\n-                                        }\n-                                    }\n-                                }\n+                        for (AllocaInst *SRet_gc : gc_allocas) {\n+                            Type *ElT = SRet_gc->getAllocatedType();\n+                            if (!(SRet_gc->isStaticAlloca() && isa<PointerType>(ElT) && ElT->getPointerAddressSpace() == AddressSpace::Tracked)) {\n+                                // this is a umax operation since we sometimes see the calls cloned, although we don't see these reused for different sizes\n+                                auto &live_roots = S.ArrayAllocas[SRet_gc];\n+                                if (live_roots < return_roots)\n+                                    live_roots = return_roots;\n                             }\n                         }\n                     }\n@@ -1486,85 +1472,6 @@ State LateLowerGCFrame::LocalScan(Function &F) {\n \n \n \n-static Value *ExtractScalar(Value *V, Type *VTy, bool isptr, ArrayRef<unsigned> Idxs, IRBuilder<> &irbuilder) {\n-    Type *T_int32 = Type::getInt32Ty(V->getContext());\n-    if (isptr) {\n-        SmallVector<Value*, 0> IdxList{Idxs.size() + 1};\n-        IdxList[0] = ConstantInt::get(T_int32, 0);\n-        for (unsigned j = 0; j < Idxs.size(); ++j) {\n-            IdxList[j + 1] = ConstantInt::get(T_int32, Idxs[j]);\n-        }\n-        Value *GEP = irbuilder.CreateInBoundsGEP(VTy, V, IdxList);\n-        Type *T = GetElementPtrInst::getIndexedType(VTy, IdxList);\n-        assert(T->isPointerTy());\n-        V = irbuilder.CreateAlignedLoad(T, GEP, Align(sizeof(void*)));\n-        // since we're doing stack operations, it should be safe do this non-atomically\n-        cast<LoadInst>(V)->setOrdering(AtomicOrdering::NotAtomic);\n-    }\n-    else if (isa<PointerType>(V->getType())) {\n-        assert(Idxs.empty());\n-    }\n-    else if (!Idxs.empty()) {\n-        auto IdxsNotVec = Idxs.slice(0, Idxs.size() - 1);\n-        Type *FinalT = ExtractValueInst::getIndexedType(V->getType(), IdxsNotVec);\n-        bool IsVector = isa<VectorType>(FinalT);\n-        IRBuilder<InstSimplifyFolder> foldbuilder(irbuilder.getContext(), InstSimplifyFolder(irbuilder.GetInsertBlock()->getModule()->getDataLayout()));\n-        foldbuilder.restoreIP(irbuilder.saveIP());\n-        foldbuilder.SetCurrentDebugLocation(irbuilder.getCurrentDebugLocation());\n-        if (Idxs.size() > IsVector)\n-            V = foldbuilder.CreateExtractValue(V, IsVector ? IdxsNotVec : Idxs);\n-        if (IsVector)\n-            V = foldbuilder.CreateExtractElement(V, ConstantInt::get(Type::getInt32Ty(V->getContext()), Idxs.back()));\n-    }\n-    return V;\n-}\n-\n-static unsigned getFieldOffset(const DataLayout &DL, Type *STy, ArrayRef<unsigned> Idxs)\n-{\n-    SmallVector<Value*,4> IdxList{Idxs.size() + 1};\n-    Type *T_int32 = Type::getInt32Ty(STy->getContext());\n-    IdxList[0] = ConstantInt::get(T_int32, 0);\n-    for (unsigned j = 0; j < Idxs.size(); ++j)\n-        IdxList[j + 1] = ConstantInt::get(T_int32, Idxs[j]);\n-    auto offset = DL.getIndexedOffsetInType(STy, IdxList);\n-    assert(offset >= 0);\n-    return (unsigned)offset;\n-}\n-\n-SmallVector<Value*, 0> ExtractTrackedValues(Value *Src, Type *STy, bool isptr, IRBuilder<> &irbuilder, ArrayRef<unsigned> perm_offsets) {\n-    auto Tracked = TrackCompositeType(STy);\n-    SmallVector<Value*, 0> Ptrs;\n-    unsigned perm_idx = 0;\n-    auto ignore_field = [&] (ArrayRef<unsigned> Idxs) {\n-        if (perm_idx >= perm_offsets.size())\n-            return false;\n-        // Assume the indices returned from `TrackCompositeType` is ordered and do a\n-        // single pass over `perm_offsets`.\n-        assert(!isptr);\n-        auto offset = getFieldOffset(irbuilder.GetInsertBlock()->getModule()->getDataLayout(),\n-                                     STy, Idxs);\n-        do {\n-            auto perm_offset = perm_offsets[perm_idx];\n-            if (perm_offset > offset)\n-                return false;\n-            perm_idx++;\n-            if (perm_offset == offset) {\n-                return true;\n-            }\n-        } while (perm_idx < perm_offsets.size());\n-        return false;\n-    };\n-    for (unsigned i = 0; i < Tracked.size(); ++i) {\n-        auto Idxs = ArrayRef<unsigned>(Tracked[i]);\n-        if (ignore_field(Idxs))\n-            continue;\n-        Value *Elem = ExtractScalar(Src, STy, isptr, Idxs, irbuilder);\n-        if (isTrackedValue(Elem)) // ignore addrspace Loaded when it appears\n-            Ptrs.push_back(Elem);\n-    }\n-    return Ptrs;\n-}\n-\n //static unsigned TrackWithShadow(Value *Src, Type *STy, bool isptr, Value *Dst, IRBuilder<> &irbuilder) {\n //    auto Ptrs = ExtractTrackedValues(Src, STy, isptr, irbuilder);\n //    for (unsigned i = 0; i < Ptrs.size(); ++i) {"
    },
    {
      "sha": "af246d6801d9ef039bfdf58427aca9d4756387a4",
      "filename": "test/llvmpasses/late-lower-gc-sret.ll",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/95c412a8058d723d2f1632fba005ed6dfbd5901f/test%2Fllvmpasses%2Flate-lower-gc-sret.ll",
      "raw_url": "https://github.com/JuliaLang/julia/raw/95c412a8058d723d2f1632fba005ed6dfbd5901f/test%2Fllvmpasses%2Flate-lower-gc-sret.ll",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fllvmpasses%2Flate-lower-gc-sret.ll?ref=95c412a8058d723d2f1632fba005ed6dfbd5901f",
      "patch": "@@ -4,7 +4,7 @@\n \n declare ptr @julia.get_pgcstack()\n \n-declare swiftcc void @sret_call(ptr noalias nocapture noundef nonnull sret([3 x ptr addrspace(10)]), ptr nonnull swiftself, ptr addrspace(10) nonnull)\n+declare swiftcc void @sret_call(ptr noalias nocapture noundef nonnull \"julia.return_roots\"=\"3\" sret([3 x ptr addrspace(10)]), ptr nonnull swiftself, ptr addrspace(10) nonnull)\n \n define hidden swiftcc nonnull ptr addrspace(10) @sret_select(ptr nonnull swiftself \"gcstack\" %0, ptr addrspace(10) noundef nonnull align 8 dereferenceable(88) %1, i1 %unpredictable) {\n   ; CHECK-LABEL: @sret_select\n@@ -17,7 +17,7 @@ define hidden swiftcc nonnull ptr addrspace(10) @sret_select(ptr nonnull swiftse\n   %3 = alloca [3 x i64], align 8\n   %4 = alloca [3 x i64], align 8\n   %5 = select i1 %unpredictable, ptr %3, ptr %4\n-  call swiftcc void @sret_call(ptr noalias nocapture noundef nonnull sret([3 x ptr addrspace(10)]) %5, ptr nonnull swiftself \"gcstack\" %0, ptr addrspace(10) nonnull %1)\n+  call swiftcc void @sret_call(ptr noalias nocapture noundef nonnull \"julia.return_roots\"=\"3\" sret([3 x ptr addrspace(10)]) %5, ptr nonnull swiftself \"gcstack\" %0, ptr addrspace(10) nonnull %1)\n   ; CHECK: call void @julia.pop_gc_frame(ptr %gcframe)\n   ret ptr addrspace(10) %1\n }\n@@ -43,12 +43,12 @@ false:                                            ; preds = %top\n \n ret:                                              ; preds = %false, %true\n   %4 = phi ptr [ %2, %true ], [ %3, %false ]\n-  call swiftcc void @sret_call(ptr noalias nocapture noundef nonnull sret([3 x ptr addrspace(10)]) %4, ptr nonnull swiftself \"gcstack\" %0, ptr addrspace(10) nonnull %1)\n+  call swiftcc void @sret_call(ptr noalias nocapture noundef nonnull \"julia.return_roots\"=\"3\" sret([3 x ptr addrspace(10)]) %4, ptr nonnull swiftself \"gcstack\" %0, ptr addrspace(10) nonnull %1)\n   ; CHECK: call void @julia.pop_gc_frame(ptr %gcframe)\n   ret ptr addrspace(10) %1\n }\n \n-declare swiftcc void @sret_call_gc(ptr noalias nocapture noundef sret({ ptr addrspace(10), i64, i64 }), ptr noalias nocapture noundef, ptr nonnull swiftself)\n+declare swiftcc void @sret_call_gc(ptr noalias nocapture noundef sret({ ptr addrspace(10), i64, i64 }), ptr noalias nocapture noundef \"julia.return_roots\"=\"1\", ptr nonnull swiftself)\n \n define hidden swiftcc void @sret_gc_root_phi(ptr nonnull swiftself \"gcstack\" %0, i1 %unpredictable) {\n top:\n@@ -75,7 +75,7 @@ false:                                            ; preds = %top\n \n ret:                                              ; preds = %false, %true\n   %4 = phi ptr [ %2, %true ], [ %3, %false ]\n-  call swiftcc void @sret_call_gc(ptr noalias nocapture noundef sret({ ptr addrspace(10), i64, i64 }) %1, ptr noalias nocapture noundef %4, ptr nonnull swiftself \"gcstack\" %0)\n+  call swiftcc void @sret_call_gc(ptr noalias nocapture noundef sret({ ptr addrspace(10), i64, i64 }) %1, ptr noalias nocapture noundef \"julia.return_roots\"=\"1\" %4, ptr nonnull swiftself \"gcstack\" %0)\n    ; CHECK: call void @julia.pop_gc_frame(ptr %gcframe)\n   ret void\n }\n@@ -110,7 +110,7 @@ false:                                            ; preds = %top\n ret:                                              ; preds = %false, %true\n   %5 = phi ptr [ %2, %true ], [ %3, %false ]\n   %6 = select i1 %unpredictable2, ptr %4, ptr %5\n-  call swiftcc void @sret_call_gc(ptr noalias nocapture noundef sret({ ptr addrspace(10), i64, i64 }) %1, ptr noalias nocapture noundef %6, ptr nonnull swiftself \"gcstack\" %0)\n+  call swiftcc void @sret_call_gc(ptr noalias nocapture noundef sret({ ptr addrspace(10), i64, i64 }) %1, ptr noalias nocapture noundef \"julia.return_roots\"=\"1\" %6, ptr nonnull swiftself \"gcstack\" %0)\n    ; CHECK: call void @julia.pop_gc_frame(ptr %gcframe)\n   ret void\n }\n@@ -145,7 +145,7 @@ false:                                            ; preds = %top\n ret:                                              ; preds = %false, %true\n   %6 = phi ptr [ %2, %true ], [ %5, %false ]\n \n-  call swiftcc void @sret_call_gc(ptr noalias nocapture noundef sret({ ptr addrspace(10), i64, i64 }) %1, ptr noalias nocapture noundef %6, ptr nonnull swiftself \"gcstack\" %0)\n+  call swiftcc void @sret_call_gc(ptr noalias nocapture noundef sret({ ptr addrspace(10), i64, i64 }) %1, ptr noalias nocapture noundef \"julia.return_roots\"=\"1\" %6, ptr nonnull swiftself \"gcstack\" %0)\n    ; CHECK: call void @julia.pop_gc_frame(ptr %gcframe)\n   ret void\n }"
    },
    {
      "sha": "f78e0b0186abeb9c173357358e2ebaea318d339d",
      "filename": "test/llvmpasses/late-lower-gc.ll",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/95c412a8058d723d2f1632fba005ed6dfbd5901f/test%2Fllvmpasses%2Flate-lower-gc.ll",
      "raw_url": "https://github.com/JuliaLang/julia/raw/95c412a8058d723d2f1632fba005ed6dfbd5901f/test%2Fllvmpasses%2Flate-lower-gc.ll",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fllvmpasses%2Flate-lower-gc.ll?ref=95c412a8058d723d2f1632fba005ed6dfbd5901f",
      "patch": "@@ -205,7 +205,7 @@ define swiftcc ptr addrspace(10) @insert_element(ptr swiftself \"gcstack\" %0) {\n ; CHECK: %gcframe = call ptr @julia.new_gc_frame(i32 10)\n ; CHECK: [[gc_slot_addr_:%.*]] = call ptr @julia.get_gc_frame_slot(ptr %gcframe, i32 0)\n ; CHECK: call void @julia.push_gc_frame(ptr %gcframe, i32 10)\n-  call void null(ptr sret([2 x [5 x ptr addrspace(10)]]) %2, ptr null, ptr addrspace(11) null, ptr null)\n+  call void null(ptr sret([2 x [5 x ptr addrspace(10)]]) \"julia.return_roots\"=\"10\" %2, ptr null, ptr addrspace(11) null, ptr null)\n   %4 = insertelement <4 x ptr> zeroinitializer, ptr %2, i32 0\n ; CHECK: [[gc_slot_addr_:%.*]] = insertelement <4 x ptr> zeroinitializer, ptr [[gc_slot_addr_:%.*]], i32 0\n ; CHECK: call void @julia.pop_gc_frame(ptr %gcframe)"
    }
  ]
}