{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60475",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60475/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60475/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60475/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60475",
  "id": 3761068709,
  "node_id": "PR_kwDOABkWpM66hK2S",
  "number": 60475,
  "title": "Add `@stm` \"SyntaxTree match\" macro",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9763847389,
      "node_id": "LA_kwDOABkWpM8AAAACRfh83Q",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/JuliaLowering",
      "name": "JuliaLowering",
      "color": "144fbf",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 7,
  "created_at": "2025-12-24T21:50:15Z",
  "updated_at": "2026-01-13T09:13:08Z",
  "closed_at": "2026-01-11T00:09:41Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60475",
    "html_url": "https://github.com/JuliaLang/julia/pull/60475",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60475.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60475.patch",
    "merged_at": "2026-01-11T00:09:41Z"
  },
  "body": "Separated from https://github.com/JuliaLang/JuliaLowering.jl/pull/93 with some tweaks and tests.  This will make life much easier in writing `EST`->`CST`, and in writing lowering code in general.  Matching on trees is at least half of lowering's job!\r\n\r\nIncludes a checker for correct usage and the option to print a trace while matching.  See the docstring for usage and see the original PR for some examples.  ",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60475/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60475/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "d47ce59b7717681a17fb04865cb465805ab8135b",
      "filename": "JuliaSyntax/src/porcelain/syntax_graph.jl",
      "status": "modified",
      "additions": 262,
      "deletions": 0,
      "changes": 262,
      "blob_url": "https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl?ref=a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a",
      "patch": "@@ -740,6 +740,268 @@ function _copy_ast(graph2::SyntaxGraph, graph1::SyntaxGraph,\n     return id2\n end\n \n+#-------------------------------------------------------------------------------\n+# AST destructuring utilities\n+\n+raw\"\"\"\n+Simple `SyntaxTree` pattern matching\n+\n+Returns the first result where its corresponding pattern matches `syntax_tree`\n+and each extra `cond` is true.  Throws an error if no match is found.\n+\n+## Patterns\n+\n+A pattern is used as both a conditional (does this syntax tree have a certain\n+structure?) and a `let` (bind trees to these names if so).  Each pattern uses a\n+limited version of the @ast syntax:\n+\n+```\n+<pattern> = <tree_identifier>\n+          | [K\"<kind>\" <pattern>*]\n+          | [K\"<kind>\" <pattern>* <list_identifier>... <pattern>*]\n+\n+# note \"*\" is the meta-operator meaning one or more, and \"...\" is literal\n+```\n+\n+where a `[K\"k\" p1 p2 ps...]` form matches any tree with kind `k` and >=2\n+children (bound to `p1` and `p2`), and `ps` is bound to the possibly-empty\n+SyntaxList of children `3:end`.  Identifiers (except `_`) can't be re-used, but\n+may check for some form of tree equivalence in a future implementation.\n+\n+## Extra condition: `when`\n+\n+Like an escape hatch to the structure-matching mechanism.  `when=cond` requires\n+`cond` to evaluate to `true` for this branch to be taken.  `cond` may also bind\n+variables or printf-debug the matching process, as it runs only when its pattern\n+matches and no previous branch was taken.  `cond` may not mutate the object\n+being matched.\n+\n+## Scope of variables\n+\n+Every `(pattern, when=cond) -> result` introduces a local scope.  Identifiers in\n+the pattern are let-bound when evaluating `cond` and `result`. `cond` can\n+introduce variables for use in `result`.  User code in `cond` and `result` (but\n+not `pattern`) can refer to outer variables.\n+\n+## Example\n+\n+```\n+julia> st = JuliaSyntax.parsestmt(\n+    JuliaSyntax.SyntaxTree, \"function foo(x,y,z); x; end\")\n+\n+julia> JuliaSyntax.@stm st begin\n+    [K\"function\" [K\"call\" fname [K\"parameters\" kws...]] body] ->\n+        \"no positional args, only kwargs: $(kws)\"\n+    [K\"function\" fname] ->\n+        \"zero-method function $fname\"\n+    [K\"function\" [K\"call\" fname args...] body] ->\n+        \"normal function $fname\"\n+    ([K\"=\" [K\"call\" _...] _...], when=(args=if_valid_get_args(st[1]); !isnothing(args))) ->\n+        \"deprecated call-equals form with args $args\"\n+    (_, when=(show(\"printf debugging is great\"); true)) -> \"something else\"\n+    _ -> \"unreachable due to the case above\"\n+end\n+\"normal function foo\"\n+```\n+\n+See [Racket `match`](https://docs.racket-lang.org/reference/match.html) for the\n+inspiration for this macro and an example of a much more featureful pattern\n+language.\n+\"\"\"\n+macro stm(st, pats)\n+    _stm(__source__, st, pats; debug=false)\n+end\n+\n+\"Like `@stm`, but prints a trace during matching.\"\n+macro stm_debug(st, pats)\n+    _stm(__source__, st, pats; debug=true)\n+end\n+\n+# TODO: SyntaxList pattern matching could take similar syntax and use most of\n+# the same machinery\n+\n+function _stm(line::LineNumberNode, st, pats; debug=false)\n+    _stm_check_usage(pats)\n+    # We leave most code untouched, so the user probably wants esc(output)\n+    st_gs, result_gs, k_gs, nc_gs = gensym.(\"st\", \"result\", \"k\", \"nc\")\n+    out_blk = Expr(:let, Expr(:block, :($st_gs = $st::SyntaxTree),\n+                              :($result_gs = nothing),\n+                              :($k_gs = $kind($st_gs)),\n+                              :($nc_gs = $numchildren($st_gs))),\n+                   Expr(:if, false, nothing))\n+    case_list_tail = out_blk.args[2].args\n+    for pcr in pats.args\n+        pcr isa LineNumberNode && (line = pcr; continue)\n+        p, cond, result = _stm_destruct_pat(pcr)\n+        pat_ok = p isa Symbol ? true : _stm_matches(p, st_gs, k_gs, nc_gs, debug)\n+        # We need to let-bind patvars in both cond and the result, so result\n+        # needs to live in the first argument of :if with the extra conditions.\n+        case = Expr(:elseif,\n+                    Expr(:&&, pat_ok,\n+                         Expr(:let, _stm_assigns(p, st_gs),\n+                              Expr(:&&, cond,\n+                                   Expr(:block, line,\n+                                        :($result_gs = $result), true)))),\n+                    result_gs)\n+        push!(case_list_tail, case)\n+        case_list_tail = case_list_tail[3].args\n+    end\n+    push!(case_list_tail,\n+          :(throw(ErrorException(string(\n+              \"No match found for `\", $st_gs, \"` at \", $(string(line)))))))\n+    return esc(out_blk)\n+end\n+\n+# recursively flatten `vcat` expressions\n+function _stm_vcat_to_hcat(p::Expr)\n+    if Meta.isexpr(p, :vcat)\n+        out = Expr(:hcat)\n+        for a in p.args\n+            Meta.isexpr(a, :row) ? append!(out.args, a.args) : push!(out.args, a)\n+        end\n+    else\n+        out = Expr(p.head, p.args...)\n+    end\n+    for i in eachindex(out.args)\n+        out.args[i] = _stm_vcat_to_hcat(out.args[i])\n+    end\n+    return out\n+end\n+_stm_vcat_to_hcat(x) = x\n+\n+# return (pat_expr, when_expr|nothing, res_expr)\n+function _stm_destruct_pat(pcr::Expr)\n+    pc, r = pcr.args[1:2]\n+    Base.remove_linenums!(pc) # errors in lhs of `->` are caught in usage check\n+    (p_vcat, c) = Meta.isexpr(pc, :tuple) ?\n+        (pc.args[1], pc.args[2].args[2]) : (pc, true)\n+    return (_stm_vcat_to_hcat(p_vcat), c, r)\n+end\n+\n+function _stm_matches_wrapper(p::Expr, st_ex, debug)\n+    st_gs, k_gs, nc_gs = gensym.(\"st\", \"k\", \"nc\")\n+    Expr(:let, Expr(:block, :($st_gs = $st_ex),\n+                          :($k_gs = $kind($st_gs)),\n+                          :($nc_gs = $numchildren($st_gs))),\n+               _stm_matches(p, st_gs, k_gs, nc_gs, debug))\n+end\n+\n+function _stm_matches(p::Expr, st_gs::Symbol, k_gs::Symbol, nc_gs::Symbol, debug)\n+    pat_k = Kind(p.args[1].args[3])\n+    out = Expr(:&&, :($pat_k === $k_gs))\n+    debug && push!(out.args, Expr(:block, :(printstyled(\n+        string(\"[kind]: \", $k_gs, \"\\n\"); color=:yellow)), true))\n+\n+    p_args = p.args[2:end]\n+    dots_i = findfirst(x->Meta.isexpr(x, :(...)), p_args)\n+    dots_start = something(dots_i, length(p_args) + 1)\n+    n_after_dots = length(p_args) - dots_start # -1 if no dots\n+\n+    push!(out.args, isnothing(dots_i) ?\n+        :($nc_gs === $(length(p_args))) :\n+        :($nc_gs >= $(length(p_args) - 1)))\n+    debug && push!(out.args, Expr(:block, :(printstyled(\n+        string(\"[numc]: \", $nc_gs, \"\\n\"); color=:yellow)), true))\n+\n+    for i in 1:dots_start-1\n+        p_args[i] isa Symbol && continue\n+        push!(out.args,\n+              _stm_matches_wrapper(p_args[i], :($st_gs[$i]), debug))\n+    end\n+    for i in n_after_dots-1:-1:0\n+        p_args[end-i] isa Symbol && continue\n+        push!(out.args,\n+              _stm_matches_wrapper(p_args[end-i], :($st_gs[end-$i]), debug))\n+    end\n+    debug && push!(out.args, Expr(:block, :(printstyled(\n+        string(\"matched: \", $st_gs, \" with \", $(QuoteNode(p)), \"\\n\");\n+        color=:green)), true))\n+    return out\n+end\n+\n+# Assuming _stm_matches, construct an Expr that assigns syms to SyntaxTrees.\n+# Note st_rhs_expr is a ref-expr with a SyntaxTree/List value (in context).\n+function _stm_assigns(p, st_rhs_expr; assigns=Expr(:block))\n+    if p isa Symbol\n+        p != :_ && push!(assigns.args, Expr(:(=), p, st_rhs_expr))\n+        return assigns\n+    elseif p isa Expr\n+        p_args = p.args[2:end]\n+        dots_i = findfirst(x->Meta.isexpr(x, :(...)), p_args)\n+        dots_start = something(dots_i, length(p_args) + 1)\n+        n_after_dots = length(p_args) - dots_start\n+        for i in 1:dots_start-1\n+            _stm_assigns(p_args[i], :($st_rhs_expr[$i]); assigns)\n+        end\n+        if !isnothing(dots_i)\n+            _stm_assigns(p_args[dots_i].args[1],\n+                         :($st_rhs_expr[$dots_i:end-$n_after_dots]); assigns)\n+            for i in n_after_dots-1:-1:0\n+                _stm_assigns(p_args[end-i], :($st_rhs_expr[end-$i]); assigns)\n+            end\n+        end\n+        return assigns\n+    end\n+    @assert false \"unexpected syntax; enable or fix `_stm_check_usage`\"\n+end\n+\n+# Check for correct pattern syntax.  Not needed outside of development.\n+function _stm_check_usage(pats::Expr)\n+    function _stm_check_pattern(p; syms=Set{Symbol}())\n+        if Meta.isexpr(p, :(...), 1)\n+            p = p.args[1]\n+            @assert(p isa Symbol, \"Expected symbol before `...` in $p\")\n+        end\n+        if p isa Symbol\n+            # No support for duplicate syms for now (user is either looking for\n+            # some form of equality we don't implement, or they made a mistake)\n+            dup = p in syms && p !== :_\n+            push!(syms, p)\n+            @assert(!dup, \"invalid duplicate non-underscore identifier $p\")\n+            return nothing\n+        elseif Meta.isexpr(p, :vect)\n+            @assert(length(p.args) === 1,\n+                    \"use spaces, not commas, in @stm []-patterns\")\n+        elseif Meta.isexpr(p, :hcat)\n+            @assert(length(p.args) >= 2)\n+        elseif Meta.isexpr(p, :vcat)\n+            p = _stm_vcat_to_hcat(p)\n+            @assert(length(p.args) >= 2)\n+        else\n+            @assert(false, \"malformed pattern $p\")\n+        end\n+        @assert(count(x->Meta.isexpr(x, :(...)), p.args[2:end]) <= 1,\n+                \"Multiple `...` in a pattern is ambiguous\")\n+\n+        # This exact `K\"kind\"` syntax is not necessary since the kind can't be\n+        # provided by a variable, but requiring [K\"kinds\"] is consistent with\n+        # `@ast` and allows us to implement list matching later.\n+        @assert(Meta.isexpr(p.args[1], :macrocall, 3) &&\n+            p.args[1].args[1] === Symbol(\"@K_str\") &&\n+            p.args[1].args[3] isa String, \"first pattern elt must be K\\\"\\\"\")\n+\n+        for subp in p.args[2:end]\n+            _stm_check_pattern(subp; syms)\n+        end\n+    end\n+\n+    @assert Meta.isexpr(pats, :block) \"Usage: @stm st begin; ...; end\"\n+    for pcr in filter(e->!isa(e, LineNumberNode), pats.args)\n+        @assert(Meta.isexpr(pcr, :(->), 2), \"Expected pat -> res, got malformed case: $pcr\")\n+        if Meta.isexpr(pcr.args[1], :tuple)\n+            @assert(length(pcr.args[1].args) === 2,\n+                    \"Expected `pat` or `(pat, when=cond)`, got $(pcr.args[1])\")\n+            p = pcr.args[1].args[1]\n+            c = pcr.args[1].args[2]\n+            @assert(Meta.isexpr(c, :(=), 2) && c.args[1] === :when,\n+                    \"Expected `(when=cond)` in tuple pattern, got $(c)\")\n+        else\n+            p = pcr.args[1]\n+        end\n+        _stm_check_pattern(p)\n+    end\n+end\n+\n #-------------------------------------------------------------------------------\n # RawGreenNode->SyntaxTree\n # WIP: expr_structure param will be deleted"
    },
    {
      "sha": "7d7a6776a70abeae590a10a7d47e7b4aa08b04d7",
      "filename": "JuliaSyntax/test/syntax_graph.jl",
      "status": "modified",
      "additions": 213,
      "deletions": 1,
      "changes": 214,
      "blob_url": "https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax%2Ftest%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax%2Ftest%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fsyntax_graph.jl?ref=a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a",
      "patch": "@@ -1,4 +1,4 @@\n-using .JuliaSyntax: SyntaxGraph, SyntaxTree, SyntaxList, freeze_attrs, unfreeze_attrs, ensure_attributes, ensure_attributes!, delete_attributes, copy_ast, attrdefs\n+using .JuliaSyntax: SyntaxGraph, SyntaxTree, SyntaxList, freeze_attrs, unfreeze_attrs, ensure_attributes, ensure_attributes!, delete_attributes, copy_ast, attrdefs, @stm\n \n @testset \"SyntaxGraph attrs\" begin\n     st = parsestmt(SyntaxTree, \"function foo end\")\n@@ -100,3 +100,215 @@ end\n         @test_throws ErrorException copy_ast(new_g, st; copy_source=false)\n     end\n end\n+\n+@testset \"@stm SyntaxTree pattern-matching\" begin\n+    st = parsestmt(SyntaxTree, \"foo(a,b=1,c(d=2))\")\n+    # (call foo a (kw b 1) (call c (kw d 2)))\n+\n+    @testset \"basic functionality\" begin\n+        @test @stm st begin\n+            _ -> true\n+        end\n+\n+        @test @stm st begin\n+            x -> x isa SyntaxTree\n+        end\n+\n+        @test @stm st begin\n+            [K\"function\" f a b c] -> false\n+            [K\"call\" f a b c] -> true\n+        end\n+\n+        @test @stm st begin\n+            [K\"function\" _ _ _ _] -> false\n+            [K\"call\" _ _ _ _] -> true\n+        end\n+\n+        @test @stm st begin\n+            [K\"call\" f a b] -> false\n+            [K\"call\" f a b c d] -> false\n+            [K\"call\" f a b c] -> true\n+        end\n+\n+        @test @stm st begin\n+            [K\"call\" f a b c] ->\n+                kind(f) === K\"Identifier\" &&\n+                kind(b) === K\"kw\" &&\n+                kind(c) === K\"call\"\n+        end\n+    end\n+\n+    @testset \"errors\" begin\n+        # no match\n+        @test_throws ErrorException @stm st begin\n+            [K\"Identifier\"] -> false\n+        end\n+\n+        # assuming we run this checker by default\n+        @testset \"_stm_check_usage\" begin\n+            bad = Expr[\n+                :(@stm st begin\n+                      [a] -> false\n+                  end)\n+                :(@stm st begin\n+                      [K\"None\",a] -> false\n+                  end)\n+                :(@stm st begin\n+                      [K\"None\" a a] -> false\n+                  end)\n+                :(@stm st begin\n+                      x\n+                  end)\n+                :(@stm st begin\n+                      x() -> false\n+                  end)\n+                :(@stm st begin\n+                      (a, b=1) -> false\n+                  end)\n+                :(@stm st begin\n+                      [K\"None\" a... b...] -> false\n+                  end)\n+            ]\n+            for e in bad\n+                Base.remove_linenums!(e)\n+                @testset \"$(string(e))\" begin\n+                @test_throws AssertionError macroexpand(@__MODULE__, e)\n+                end\n+            end\n+        end\n+    end\n+\n+    @testset \"nested patterns\" begin\n+        @test 1 === @stm st begin\n+            [K\"call\" [K\"Identifier\"] [K\"Identifier\"] [K\"kw\" [K\"Identifier\"] k1] [K\"call\" [K\"Identifier\"] [K\"kw\" [K\"Identifier\"] k2]]] -> 1\n+            [K\"call\" [K\"Identifier\"] [K\"Identifier\"] [K\"kw\" [K\"Identifier\"] k1] [K\"call\" [K\"Identifier\"] [K\"kw\" _ k2]]] -> 2\n+            [K\"call\" [K\"Identifier\"] [K\"Identifier\"] [K\"kw\" _ k1] [K\"call\" _ _]] -> 3\n+            [K\"call\" [K\"Identifier\"] [K\"Identifier\"] _ _ ] -> 4\n+            [K\"call\" _ _ _ _] -> 5\n+        end\n+        @test 1 === @stm st begin\n+            [K\"call\" _ _ [K\"None\" [K\"Identifier\"] k1] [K\"None\" [K\"Identifier\"] [K\"None\" [K\"None\"] k2]]] -> 5\n+            [K\"call\" _ _ [K\"kw\" [K\"Identifier\"] k1] [K\"None\" [K\"Identifier\"] [K\"None\" [K\"None\"] k2]]] -> 4\n+            [K\"call\" _ _ [K\"kw\" [K\"Identifier\"] k1] [K\"call\" [K\"Identifier\"] [K\"None\" [K\"None\"] k2]]] -> 3\n+            [K\"call\" _ _ [K\"kw\" [K\"Identifier\"] k1] [K\"call\" [K\"Identifier\"] [K\"kw\" [K\"None\"] k2]]] -> 2\n+            [K\"call\" _ _ [K\"kw\" [K\"Identifier\"] k1] [K\"call\" [K\"Identifier\"] [K\"kw\" [K\"Identifier\"] k2]]] -> 1\n+        end\n+        @test 1 === @stm st begin\n+            [K\"call\" _ _ [K\"kw\" [K\"Identifier\"] k1] [K\"call\" [K\"Identifier\"] [K\"kw\" [K\"Identifier\"] k2] bad]] -> 4\n+            [K\"call\" _ _ [K\"kw\" [K\"Identifier\"] k1] [K\"call\" [K\"Identifier\"] [K\"kw\" [K\"Identifier\"] k2 bad]]] -> 3\n+            [K\"call\" _ _ [K\"kw\" [K\"Identifier\"] k1] [K\"call\" [K\"Identifier\"] [K\"kw\" [K\"Identifier\" bad] k2]]] -> 2\n+            [K\"call\" _ _ [K\"kw\" [K\"Identifier\"] k1] [K\"call\" [K\"Identifier\"] [K\"kw\" [K\"Identifier\"] k2]]] -> 1\n+        end\n+    end\n+\n+    @testset \"vcat form (newlines in pattern)\" begin\n+        @test @stm st begin\n+            [K\"call\"\n+             f\n+             a\n+             b\n+             c] -> true\n+        end\n+        @test @stm st begin\n+            [K\"call\"\n+             f a b c] -> true\n+        end\n+        @test @stm st begin\n+            [K\"call\"\n+\n+\n+             f a b c] -> true\n+        end\n+        @test @stm st begin\n+            [K\"call\"\n+             [K\"Identifier\"] [K\"Identifier\"]\n+             [K\"kw\" [K\"Identifier\"] k1]\n+             [K\"call\"\n+              [K\"Identifier\"]\n+              [K\"kw\"\n+               [K\"Identifier\"]\n+               k2]]] -> true\n+        end\n+    end\n+\n+    @testset \"SyntaxList splat matching\" begin\n+        # trailing splat\n+        @test @stm st begin\n+            [K\"call\" f _...] -> true\n+        end\n+        @test @stm st begin\n+            [K\"call\" f args...] -> kind(f) === K\"Identifier\"\n+        end\n+        @test @stm st begin\n+            [K\"call\" f args...] -> args isa SyntaxList && length(args) === 3\n+        end\n+        @test @stm st begin\n+            [K\"call\" f args...] -> kind(args[1]) === K\"Identifier\" &&\n+                kind(args[2]) === K\"kw\" &&\n+                kind(args[3]) === K\"call\"\n+        end\n+        @test @stm st begin\n+            [K\"call\" f a b c empty...] -> empty isa SyntaxList && length(empty) === 0\n+        end\n+\n+        # binds after splat\n+        @test @stm st begin\n+            [K\"call\" f args... last] ->\n+                args isa SyntaxList &&\n+                length(args) === 2\n+        end\n+        @test @stm st begin\n+            [K\"call\" f args... last] ->\n+                kind(f) === K\"Identifier\" &&\n+                kind(args[1]) === K\"Identifier\" &&\n+                kind(args[2]) === K\"kw\" &&\n+                kind(last) === K\"call\"\n+        end\n+        @test @stm st begin\n+            [K\"call\" empty... f a b c] -> empty isa SyntaxList && length(empty) === 0\n+        end\n+    end\n+\n+    @testset \"`when` clauses affect matching\" begin\n+        @test @stm st begin\n+            (_, when=false) -> false\n+            (_, when=true) -> true\n+        end\n+        @test @stm st begin\n+            ([K\"call\" _...], when=false) -> false\n+            ([K\"call\" _...], when=true) -> true\n+        end\n+        @test @stm st begin\n+            ([K\"call\" _ _...], when=kind(st[1])===K\"Identifier\") -> true\n+        end\n+        @test @stm st begin\n+            ([K\"call\" f _...], when=kind(f)===K\"Identifier\") -> true\n+        end\n+    end\n+\n+    @testset \"effects of when=cond\" begin\n+        let x = Int[]\n+            @test @stm st begin\n+                (_, when=(push!(x, 1); true)) -> x == [1]\n+            end\n+            empty!(x)\n+\n+            @test @stm st begin\n+                (_, when=(push!(x, 1); false)) -> false\n+                (_, when=(push!(x, 2); false)) -> false\n+                (_, when=(push!(x, 3); true)) -> x == [1, 2, 3]\n+            end\n+            empty!(x)\n+\n+            @test @stm st begin\n+                ([K\"block\"], when=(push!(x, 123); false)) -> false\n+                (_, when=(push!(x, 1); true)) -> x == [1]\n+            end\n+            empty!(x)\n+\n+            @test @stm st begin\n+                (x_pat, when=((x_when = x_pat); true)) -> x_pat == x_when\n+            end\n+        end\n+    end\n+end"
    }
  ]
}