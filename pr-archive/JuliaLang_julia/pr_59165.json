{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59165",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59165/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59165/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59165/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59165",
  "id": 3278854283,
  "node_id": "PR_kwDOABkWpM6hc-O_",
  "number": 59165,
  "title": "ccall: make distinction of pointer vs name a syntactic distinction",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1056009044,
      "node_id": "MDU6TGFiZWwxMDU2MDA5MDQ0",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/minor%20change",
      "name": "minor change",
      "color": "a05255",
      "default": false,
      "description": "Marginal behavior change acceptable for a minor release"
    },
    {
      "id": 2873907667,
      "node_id": "MDU6TGFiZWwyODczOTA3NjY3",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/ffi",
      "name": "ffi",
      "color": "75AF91",
      "default": false,
      "description": "foreign function interfaces, ccall, etc."
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 35,
  "created_at": "2025-07-31T01:30:35Z",
  "updated_at": "2025-10-15T14:09:51Z",
  "closed_at": "2025-10-09T20:00:40Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59165",
    "html_url": "https://github.com/JuliaLang/julia/pull/59165",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59165.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59165.patch",
    "merged_at": "2025-10-09T20:00:40Z"
  },
  "body": "We have long expected users to be explicit about the library name for `ccall`, and the `@ccall` macro has even always enforced that. That means users should have already been using explicit syntax, even though it wasn't strictly enforced. And indeed, the other syntax forms weren't handled reliably anyways (since doing so would require linearizing IR if and only if the runtime values required it, which is not something that is computable, and thus was often done wrong). This now intends to align the runtime and compiler to expect only those syntax forms that we could reliably handle in the past without errors, and adds explicit errors for other cases, most of which we previously knew would be unreliable due to reliance upon inference in making particular decisions for the semantics. The `ccall` function is already very special since it is more like a actual macro (it does not exist as a binding or value), so we can make unusual syntax decisions like this, mirroring `@ccall` also.\r\n\r\nThis fixes #57931, mostly by restricting the set of things that are allowed to the set of things that have an obvious and pre-existing behavior to be guaranteed to do that behavior. The hope is to PkgEval this to check if any packages are doing something unusual and see if we even need to allow anything else.\r\n\r\nThis drops support for https://github.com/JuliaLang/julia/pull/37123, since we were going to use that for LazyLibraries, be we decided that approach was quite buggy and that PR would make static compilation quite impossible to support, so we instead actually implemented LazyLibraries with a different approach. It could be re-enabled, but we never had correct lowering or inference support for it, so it is presumably still unused.\r\n\r\nThe goal is to cause breakage only where the package authors really failed to express intent with syntax, and otherwise to explicitly maintain support by adding cases to normalize the given syntax into one of the supported cases. All existing functionality (and more) can be accessed by explicit management of a pointer or by a LazyLibrary-like type, so this shouldn't cause any reduction in possible functionality, just possibly altered syntax.\r\n\r\nIn followup work, we may want to apply some similar improvements to the cglobal semantics, though not nearly as urgent, since cglobal on a pointer is permitted as a complicated bitcast right now, which doesn't make sense and probably should be deprecated, so that there is no ambiguity with that function's meaning.\r\n\r\nMostly written by Claude",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59165/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59165/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "f755d8f02dab2d230fb0dbe5d97f49d4c8e2b567",
      "filename": "Compiler/src/abstractinterpretation.jl",
      "status": "modified",
      "additions": 15,
      "deletions": 51,
      "changes": 66,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fabstractinterpretation.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -3480,65 +3480,29 @@ function refine_partial_type(@nospecialize t)\n     return t\n end\n \n-abstract_eval_nonlinearized_foreigncall_name(\n-        ::AbstractInterpreter, @nospecialize(e), ::StatementState, ::IRInterpretationState\n-    ) = nothing\n-\n-function abstract_eval_nonlinearized_foreigncall_name(\n-        interp::AbstractInterpreter, @nospecialize(e), sstate::StatementState, sv::InferenceState\n-    )\n-    if isexpr(e, :call)\n-        n = length(e.args)\n-        argtypes = Vector{Any}(undef, n)\n-        callresult = Future{CallMeta}()\n-        i::Int = 1\n-        nextstate::UInt8 = 0x0\n-        local ai, res\n-        function evalargs(interp, sv)\n-            if nextstate === 0x1\n-                @goto state1\n-            elseif nextstate === 0x2\n-                @goto state2\n-            end\n-            while i <= n\n-                ai = abstract_eval_nonlinearized_foreigncall_name(interp, e.args[i], sstate, sv)\n-                if !isready(ai)\n-                    nextstate = 0x1\n-                    return false\n-                    @label state1\n-                end\n-                argtypes[i] = ai[].rt\n-                i += 1\n-            end\n-            res = abstract_call(interp, ArgInfo(e.args, argtypes), sstate, sv)\n-            if !isready(res)\n-                nextstate = 0x2\n-                return false\n-                @label state2\n-            end\n-            callresult[] = res[]\n-            return true\n-        end\n-        evalargs(interp, sv) || push!(sv.tasks, evalargs)\n-        return callresult\n-    else\n-        return Future(abstract_eval_basic_statement(interp, e, sstate, sv))\n-    end\n-end\n-\n function abstract_eval_foreigncall(interp::AbstractInterpreter, e::Expr, sstate::StatementState, sv::AbsIntState)\n     callee = e.args[1]\n-    if isexpr(callee, :call) && length(callee.args) > 1 && callee.args[1] == GlobalRef(Core, :tuple)\n-        # NOTE these expressions are not properly linearized\n-        abstract_eval_nonlinearized_foreigncall_name(interp, callee.args[2], sstate, sv)\n-        if length(callee.args) > 2\n-            abstract_eval_nonlinearized_foreigncall_name(interp, callee.args[3], sstate, sv)\n+    if isexpr(callee, :tuple)\n+        if length(callee.args) >= 1\n+            abstract_eval_value(interp, callee.args[1], sstate, sv)\n+            if length(callee.args) >= 2\n+                abstract_eval_value(interp, callee.args[2], sstate, sv)\n+                #TODO: implement abstract_eval_nonlinearized_foreigncall_name correctly?\n+                # lib_effects = abstract_call(interp, ArgInfo(e.args, Any[typeof(Libdl.dlopen), lib]), sstate, sv)::Future\n+            end\n         end\n     else\n         abstract_eval_value(interp, callee, sstate, sv)\n     end\n     mi = frame_instance(sv)\n     t = sp_type_rewrap(e.args[2], mi, true)\n+    let fptr = e.args[1]\n+        if !isexpr(fptr, :tuple)\n+            if !hasintersect(widenconst(abstract_eval_value(interp, fptr, sstate, sv)), Ptr)\n+                return RTEffects(Bottom, Any, EFFECTS_THROWS)\n+            end\n+        end\n+    end\n     for i = 3:length(e.args)\n         if abstract_eval_value(interp, e.args[i], sstate, sv) === Bottom\n             return RTEffects(Bottom, Any, EFFECTS_THROWS)"
    },
    {
      "sha": "3a7eda26346397f7d55c317dfc7594f5beeb218c",
      "filename": "Compiler/src/optimize.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Foptimize.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Foptimize.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Foptimize.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -1439,8 +1439,11 @@ function statement_cost(ex::Expr, line::Int, src::Union{CodeInfo, IRCode}, sptyp\n         return params.inline_nonleaf_penalty\n     elseif head === :foreigncall\n         foreigncall = ex.args[1]\n-        if foreigncall isa QuoteNode && foreigncall.value === :jl_string_ptr\n-            return 1\n+        if isexpr(foreigncall, :tuple, 1)\n+            foreigncall = foreigncall.args[1]\n+            if foreigncall isa QuoteNode && foreigncall.value === :jl_string_ptr\n+                return 1\n+            end\n         end\n         return 20\n     elseif head === :invoke || head === :invoke_modify"
    },
    {
      "sha": "d78ec529cbd9f2650880e162f090fa5adbf66619",
      "filename": "Compiler/src/ssair/EscapeAnalysis.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Fssair%2FEscapeAnalysis.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Fssair%2FEscapeAnalysis.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2FEscapeAnalysis.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -1037,8 +1037,10 @@ function escape_foreigncall!(astate::AnalysisState, pc::Int, args::Vector{Any})\n     # NOTE array allocations might have been proven as nothrow (https://github.com/JuliaLang/julia/pull/43565)\n     nothrow = is_nothrow(astate.ir, pc)\n     name_info = nothrow ? \u22a5 : ThrownEscape(pc)\n-    add_escape_change!(astate, name, name_info)\n-    add_liveness_change!(astate, name, pc)\n+    if !isexpr(name, :tuple)\n+        add_escape_change!(astate, name, name_info)\n+        add_liveness_change!(astate, name, pc)\n+    end\n     for i = 1:nargs\n         # we should escape this argument if it is directly called,\n         # otherwise just impose ThrownEscape if not nothrow"
    },
    {
      "sha": "9ef8a993dc818cb1b91e271fa4801ee0ff8cee92",
      "filename": "Compiler/src/ssair/inlining.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Fssair%2Finlining.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Fssair%2Finlining.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2Finlining.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -1753,7 +1753,7 @@ function late_inline_special_case!(ir::IRCode, idx::Int, stmt::Expr, flag::UInt3\n             length(stmt.args) == 2 ? Any : stmt.args[end])\n         return SomeCase(typevar_call)\n     elseif f === UnionAll && length(argtypes) == 3 && \u2291(optimizer_lattice(state.interp), argtypes[2], TypeVar)\n-        unionall_call = Expr(:foreigncall, QuoteNode(:jl_type_unionall), Any, svec(Any, Any),\n+        unionall_call = Expr(:foreigncall, Expr(:tuple, QuoteNode(:jl_type_unionall)), Any, svec(Any, Any),\n             0, QuoteNode(:ccall), stmt.args[2], stmt.args[3])\n         return SomeCase(unionall_call)\n     elseif is_return_type(f)"
    },
    {
      "sha": "e190ae7a8438f82e6b494d9cae7af96e8296a4fa",
      "filename": "Compiler/src/ssair/verify.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Fssair%2Fverify.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Fssair%2Fverify.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2Fverify.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -77,10 +77,10 @@ function check_op(ir::IRCode, domtree::DomTree, @nospecialize(op), use_bb::Int,\n         end\n     elseif isa(op, Expr)\n         # Only Expr(:boundscheck) is allowed in value position\n-        if isforeigncall && arg_idx == 1 && op.head === :call\n-            # Allow a tuple in symbol position for foreigncall - this isn't actually\n-            # a real call - it's interpreted in global scope by codegen. However,\n-            # we do need to keep this a real use, because it could also be a pointer.\n+        if isforeigncall && arg_idx == 1 && op.head === :tuple\n+            # Allow a tuple literal in symbol position for foreigncall - this\n+            # is syntax for a literal value or globalref - it is interpreted in\n+            # global scope by codegen.\n         elseif !is_value_pos_expr_head(op.head)\n             if !allow_frontend_forms || op.head !== :opaque_closure_method\n                 @verify_error \"Expr not allowed in value position\""
    },
    {
      "sha": "eef2f15d43e860777f5e80f5e0d4b895e8d07fb0",
      "filename": "Compiler/src/verifytrim.jl",
      "status": "modified",
      "additions": 11,
      "deletions": 3,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Fverifytrim.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Fsrc%2Fverifytrim.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fverifytrim.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -279,9 +279,17 @@ function verify_codeinstance!(interp::NativeInterpreter, codeinst::CodeInstance,\n             error = \"unresolved cfunction\"\n         elseif isexpr(stmt, :foreigncall)\n             foreigncall = stmt.args[1]\n-            if foreigncall isa QuoteNode\n-                if foreigncall.value in runtime_functions\n-                    error = \"disallowed ccall into a runtime function\"\n+            if isexpr(foreigncall, :tuple, 1)\n+                foreigncall = foreigncall.args[1]\n+                if foreigncall isa String\n+                    foreigncall = QuoteNode(Symbol(foreigncall))\n+                end\n+                if foreigncall isa QuoteNode\n+                    if foreigncall.value in runtime_functions\n+                        error = \"disallowed ccall into a runtime function\"\n+                    end\n+                else\n+                    error = \"disallowed ccall with non-constant name and no library\"\n                 end\n             end\n         elseif isexpr(stmt, :new_opaque_closure)"
    },
    {
      "sha": "3ae787e108cf0ecc849bcd86a5bd139943b71134",
      "filename": "Compiler/test/inference.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Ftest%2Finference.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Ftest%2Finference.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Finference.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -5219,11 +5219,11 @@ end\n @testset \"#45956: non-linearized cglobal needs special treatment for stmt effects\" begin\n     function foo()\n         cglobal((a, ))\n-        ccall(0, Cvoid, (Nothing,), b)\n+        ccall(C_NULL, Cvoid, (Nothing,), b)\n     end\n     @test only(code_typed() do\n         cglobal((a, ))\n-        ccall(0, Cvoid, (Nothing,), b)\n+        ccall(C_NULL, Cvoid, (Nothing,), b)\n     end)[2] === Nothing\n end\n "
    },
    {
      "sha": "86567440e9fb496d7421e638f73ea702afbefbb5",
      "filename": "Compiler/test/irpasses.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Ftest%2Firpasses.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/Compiler%2Ftest%2Firpasses.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Firpasses.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -1071,7 +1071,7 @@ let # Test for https://github.com/JuliaLang/julia/issues/43402\n     end\n \n     refs = map(Core.SSAValue, findall(@nospecialize(x)->Meta.isexpr(x, :new), src.code))\n-    some_ccall = findfirst(@nospecialize(x) -> Meta.isexpr(x, :foreigncall) && x.args[1] == :(:some_ccall), src.code)\n+    some_ccall = findfirst(@nospecialize(x) -> Meta.isexpr(x, :foreigncall) && x.args[1] == Expr(:tuple, :(:some_ccall)), src.code)\n     @assert some_ccall !== nothing\n     stmt = src.code[some_ccall]\n     nccallargs = length(stmt.args[3]::Core.SimpleVector)"
    },
    {
      "sha": "6e9633ccb230156754a86e10986039b93828edce",
      "filename": "base/c.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 25,
      "changes": 34,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/base%2Fc.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/base%2Fc.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fc.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -313,11 +313,15 @@ function ccall_macro_parse(exprs)\n     # get the function symbols\n     func = let f = call.args[1]\n         if isexpr(f, :.)\n-            :(($(f.args[2]), $(f.args[1])))\n+            Expr(:tuple, f.args[2], f.args[1])\n         elseif isexpr(f, :$)\n-            f\n+            func = f.args[1]\n+            if isa(func, String) || (isa(func, QuoteNode) && !isa(func.value, Ptr)) || isa(func, Tuple) || isexpr(func, :tuple)\n+                throw(ArgumentError(\"interpolated value should be a variable or expression, not a literal name or tuple\"))\n+            end\n+            func\n         elseif f isa Symbol\n-            QuoteNode(f)\n+            Expr(:tuple, QuoteNode(f))\n         else\n             throw(ArgumentError(\"@ccall function name must be a symbol, a `.` node (e.g. `libc.printf`) or an interpolated function pointer (with `\\$`)\"))\n         end\n@@ -363,33 +367,13 @@ end\n \n \n function ccall_macro_lower(convention, func, rettype, types, args, gc_safe, nreq)\n-    statements = []\n-\n-    # if interpolation was used, ensure the value is a function pointer at runtime.\n-    if isexpr(func, :$)\n-        push!(statements, Expr(:(=), :func, esc(func.args[1])))\n-        name = QuoteNode(func.args[1])\n-        func = :func\n-        check = quote\n-            if !isa(func, Ptr{Cvoid})\n-                name = $name\n-                throw(ArgumentError(LazyString(\"interpolated function `\", name, \"` was not a Ptr{Cvoid}, but \", typeof(func))))\n-            end\n-        end\n-        push!(statements, check)\n-    else\n-        func = esc(func)\n-    end\n-    cconv = nothing\n     if convention isa Tuple\n         cconv = Expr(:cconv, (convention..., gc_safe), nreq)\n     else\n         cconv = Expr(:cconv, (convention, UInt16(0), gc_safe), nreq)\n     end\n-\n-    return Expr(:block, statements...,\n-                Expr(:call, :ccall, func, cconv, esc(rettype),\n-                     Expr(:tuple, map!(esc, types, types)...), map!(esc, args, args)...))\n+    return Expr(:call, :ccall, esc(func), cconv, esc(rettype),\n+                 Expr(:tuple, map!(esc, types, types)...), map!(esc, args, args)...)\n end\n \n \"\"\""
    },
    {
      "sha": "088c77b3cbabbbf67768562575a6bcf2596c2499",
      "filename": "base/deprecated.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/base%2Fdeprecated.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/base%2Fdeprecated.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fdeprecated.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -24,9 +24,10 @@ const __internal_changes_list = (\n     :invertedlinetables,\n     :codeinforefactor,\n     :miuninferredrm,\n-    :codeinfonargs,  # #54341\n+    :codeinfonargs, #54341\n     :ocnopartial,\n     :printcodeinfocalls,\n+    :syntacticccall, #59165\n     # Add new change names above this line\n )\n "
    },
    {
      "sha": "ee8e620603e9d2d86c3d92ba5a3bdffd329d2a1a",
      "filename": "base/gmp.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/base%2Fgmp.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/base%2Fgmp.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fgmp.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -151,7 +151,7 @@ using ..GMP: BigInt, Limb, BITS_PER_LIMB, libgmp\n const mpz_t = Ref{BigInt}\n const bitcnt_t = Culong\n \n-gmpz(op::Symbol) = (Symbol(:__gmpz_, op), libgmp)\n+gmpz(op::Symbol) = Expr(:tuple, QuoteNode(Symbol(:__gmpz_, op)), GlobalRef(MPZ, :libgmp))\n \n init!(x::BigInt) = (ccall((:__gmpz_init, libgmp), Cvoid, (mpz_t,), x); x)\n init2!(x::BigInt, a) = (ccall((:__gmpz_init2, libgmp), Cvoid, (mpz_t, bitcnt_t), x, a); x)\n@@ -955,7 +955,7 @@ module MPQ\n import .Base: unsafe_rational, __throw_rational_argerror_zero\n import ..GMP: BigInt, MPZ, Limb, libgmp\n \n-gmpq(op::Symbol) = (Symbol(:__gmpq_, op), libgmp)\n+gmpq(op::Symbol) = Expr(:tuple, QuoteNode(Symbol(:__gmpq_, op)), GlobalRef(MPZ, :libgmp))\n \n mutable struct _MPQ\n     num_alloc::Cint"
    },
    {
      "sha": "3db57a59deb06650a9d2dc46263d19d7a2476f66",
      "filename": "doc/src/devdocs/llvm.md",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/doc%2Fsrc%2Fdevdocs%2Fllvm.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/doc%2Fsrc%2Fdevdocs%2Fllvm.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fdevdocs%2Fllvm.md?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -346,7 +346,7 @@ need to make sure that the array does stay alive while we're doing the\n [`ccall`](@ref). To understand how this is done, lets look at a hypothetical\n approximate possible lowering of the above code:\n ```julia\n-return $(Expr(:foreigncall, :(:foo), Cvoid, svec(Ptr{Float64}), 0, :(:ccall), Expr(:foreigncall, :(:jl_array_ptr), Ptr{Float64}, svec(Any), 0, :(:ccall), :(A)), :(A)))\n+return $(Expr(:foreigncall, Expr(:tuple, :(:foo)), Cvoid, svec(Ptr{Float64}), 0, :(:ccall), Expr(:foreigncall, Expr(:tuple, :(:jl_array_ptr)), Ptr{Float64}, svec(Any), 0, :(:ccall), :(A)), :(A)))\n ```\n The last `:(A)`, is an extra argument list inserted during lowering that informs\n the code generator which Julia level values need to be kept alive for the"
    },
    {
      "sha": "bf0429fdff3f0b501b9589d7d36376ee5b547958",
      "filename": "doc/src/manual/calling-c-and-fortran-code.md",
      "status": "modified",
      "additions": 52,
      "deletions": 17,
      "changes": 69,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/doc%2Fsrc%2Fmanual%2Fcalling-c-and-fortran-code.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/doc%2Fsrc%2Fmanual%2Fcalling-c-and-fortran-code.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fmanual%2Fcalling-c-and-fortran-code.md?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -32,11 +32,15 @@ The syntax for [`@ccall`](@ref) to generate a call to the library function is:\n @ccall $function_pointer(argvalue1::argtype1, ...)::returntype\n ```\n \n-where `library` is a string constant or literal (but see [Non-constant Function\n-Specifications](@ref) below). The library may be omitted, in which case the\n-function name is resolved in the current process. This form can be used to call\n-C library functions, functions in the Julia runtime, or functions in an\n-application linked to Julia. The full path to the library may also be specified.\n+where `library` is a string constant or global variable name (see [Non-constant\n+Function -Specifications](@ref) below). The library can be just a name, or it\n+can specify a full path to the library. The library may be omitted, in which\n+case the function name is resolved in the current executable, the current libc,\n+or libjulia(-internal). This form can be used to call C library functions,\n+functions in the Julia runtime, or functions in an application linked to Julia.\n+Omitting the library *cannot* be used to call a function in any library (like\n+specifying `RTLD_DEFAULT` to `dlsym`) as such behavior is slow, complicated,\n+and not implemented on all platforms.\n Alternatively, `@ccall` may also be used to call a function pointer\n `$function_pointer`, such as one returned by `Libdl.dlsym`. The `argtype`s\n corresponds to the C-function signature and the `argvalue`s are the actual\n@@ -848,13 +852,17 @@ it must be handled in other ways.\n \n ## Non-constant Function Specifications\n \n-In some cases, the exact name or path of the needed library is not known in advance and must\n-be computed at run time. To handle such cases, the library component\n-specification can be a function call, e.g. `find_blas().dgemm`. The call expression will\n-be executed when the `ccall` itself is executed. However, it is assumed that the library\n-location does not change once it is determined, so the result of the call can be cached and\n-reused. Therefore, the number of times the expression executes is unspecified, and returning\n-different values for multiple calls results in unspecified behavior.\n+In some cases, the exact name or path of the needed library is not known in\n+advance and must be computed at run time. To handle such cases, the library\n+component specification can be a value such as `Libdl.LazyLibrary`. For\n+example, in `@ccall blas.dgemm()`, there can be a global defined as `const blas\n+= LazyLibrary(\"libblas\")`. The runtime will call `dlsym(:dgemm, dlopen(blas))`\n+when the `@ccall` itself is executed. The `Libdl.dlopen` function can be\n+overloaded for custom types to provide alternate behaviors. However, it is\n+assumed that the library location does not change once it is determined, so the\n+result of the call can be cached and reused. Therefore, the number of times the\n+expression executes is unspecified, and returning different values for multiple\n+calls results in unspecified behavior.\n \n If even more flexibility is needed, it is possible\n to use computed values as function names by staging through [`eval`](@ref) as follows:\n@@ -990,11 +998,38 @@ The arguments to [`ccall`](@ref) are:\n \n \n !!! note\n-    The `(:function, \"library\")` pair, return type, and input types must be literal constants\n-    (i.e., they can't be variables, but see [Non-constant Function Specifications](@ref)).\n-\n-    The remaining parameters are evaluated at compile-time, when the containing method is defined.\n-\n+    The `(:function, \"library\")` pair and the input type list must be syntactic tuples\n+    (i.e., they can't be variables or values with a type of Tuple.\n+\n+    The rettype and argument type values are evaluated at when the containing method is\n+    defined, not runtime.\n+\n+!!! note \"Function Name vs Pointer Syntax\"\n+    The syntax of the first argument to `ccall` determines whether you're calling by **name** or by **pointer**:\n+    * **Name-based calls** (tuple literal syntax):\n+    - Both the function and library names can be a quoted Symbol, a String, a\n+      variable name (a GlobalRef), or a dotted expression ending with a variable\n+      name.\n+    - Single name: `(:function_name,)` or `\"function_name\"` - uses default library lookup.\n+    - Name with library: `(:function_name, \"library\")` - specifies both function and library.\n+    - Symbol, string, and tuple literal constants (not expressions that evaluate to those constants,\n+      but actual literals) are automatically normalized to tuple form.\n+    * **Pointer-based calls** (non-tuple syntax):\n+    - Anything that is not a literal tuple expression specified above is assumed to be an\n+      expression that evaluates to a function pointers at runtime.\n+    - Function pointer variables: `fptr` where `fptr` is a runtime pointer value.\n+    - Function pointer computations: `dlsym(:something)` where the result is computed at\n+      runtime every time (usually along with some caching logic).\n+    * **Library name expressions**:\n+    - When given as a variable, the library name can resolve to a `Symbol`, a `String`, or\n+      any other value. The runtime will call `Libdl.dlopen(name)` on the value an\n+      unspecified number of times, caching the result. The result is not invalidated if the\n+      value of the binding changes or if it becomes undefined, as long as there exists any\n+      value for that binding in any past or future worlds, that value may be used.\n+    - Dot expressions, such as `A.B().c`, will be executed at method definition\n+      time up to the final `c`. The first part must resolve to a Module, and the\n+      second part to a quoted symbol. The value of that global will be resolved at\n+      runtime when the `ccall` is first executed.\n \n A table of translations between the macro and function interfaces is given below.\n "
    },
    {
      "sha": "43b40f7ad0205581dfdd25e3d2b3f0e843861473",
      "filename": "src/ccall.cpp",
      "status": "modified",
      "additions": 255,
      "deletions": 189,
      "changes": 444,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fccall.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fccall.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fccall.cpp?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -54,13 +54,43 @@ GlobalVariable *jl_emit_RTLD_DEFAULT_var(Module *M)\n     return prepare_global_in(M, jlRTLD_DEFAULT_var);\n }\n \n+typedef struct {\n+    jl_value_t *gcroot[2];     // GC roots for strings [f_name, f_lib]\n+\n+    // Static name resolution (compile-time known)\n+    const char *f_name;        // static function name\n+    const char *f_lib;         // static library name\n+\n+    // Dynamic name resolution (simple runtime expressions)\n+    jl_value_t *f_name_expr;   // expression for function name\n+    jl_value_t *f_lib_expr;    // expression for library name\n+\n+    // Runtime pointer\n+    Value *jl_ptr;             // callable pointer expression result\n+} native_sym_arg_t;\n \n // Find or create the GVs for the library and symbol lookup.\n-// Return `runtime_lib` (whether the library name is a string)\n+// Return `runtime_lib` (whether the library name is a string) if it returns `lib`.\n // The `lib` and `sym` GV returned may not be in the current module.\n-static bool runtime_sym_gvs(jl_codectx_t &ctx, const char *f_lib, const char *f_name,\n+static bool runtime_sym_gvs(jl_codectx_t &ctx, const native_sym_arg_t &symarg,\n                             GlobalVariable *&lib, GlobalVariable *&sym)\n {\n+    const auto &f_lib = symarg.f_lib;\n+    const auto &f_name = symarg.f_name;\n+    // If f_name isn't constant or f_lib_expr is present but not present,\n+    // emit a local cache for sym, but do not cache lib\n+    if (!((f_lib || symarg.f_lib_expr == NULL) && f_name)) {\n+        std::string name = \"dynccall_\";\n+        name += std::to_string(jl_atomic_fetch_add_relaxed(&globalUniqueGeneratedNames, 1));\n+        Module *M = jl_Module;\n+        auto T_pvoidfunc = getPointerTy(M->getContext());\n+        lib = nullptr;\n+        sym = new GlobalVariable(*M, T_pvoidfunc, false,\n+                                 GlobalVariable::InternalLinkage,\n+                                 Constant::getNullValue(T_pvoidfunc), name);\n+        return false;\n+    }\n+\n     auto M = &ctx.emission_context.shared_module();\n     bool runtime_lib = false;\n     GlobalVariable *libptrgv;\n@@ -119,27 +149,29 @@ static bool runtime_sym_gvs(jl_codectx_t &ctx, const char *f_lib, const char *f_\n static Value *runtime_sym_lookup(\n         jl_codegen_params_t &emission_context,\n         IRBuilder<> &irbuilder,\n-        jl_codectx_t *ctx,\n-        PointerType *funcptype, const char *f_lib, jl_value_t *lib_expr,\n-        const char *f_name, Function *f,\n+        jl_codectx_t *pctx,\n+        const native_sym_arg_t &symarg, Function *f,\n         GlobalVariable *libptrgv,\n         GlobalVariable *llvmgv, bool runtime_lib)\n {\n     ++RuntimeSymLookups;\n-    // in pseudo-code, this function emits the following:\n+    // in pseudo-code, this function emits the following if libptrgv is set:\n     //   global HMODULE *libptrgv\n     //   global void **llvmgv\n-    //   if (*llvmgv == NULL) {\n+    //   if (*llvmgv == NULL)\n     //       *llvmgv = jl_load_and_lookup(f_lib, f_name, libptrgv);\n-    //   }\n+    //   return (*llvmgv)\n+    // otherwise it emits:\n+    //   global void **llvmgv\n+    //   if (*llvmgv == NULL)\n+    //       *llvmgv = jl_lazy_load_and_lookup(f_lib_expr, f_name_expr);\n     //   return (*llvmgv)\n     auto T_pvoidfunc = getPointerTy(irbuilder.getContext());\n     BasicBlock *enter_bb = irbuilder.GetInsertBlock();\n     BasicBlock *dlsym_lookup = BasicBlock::Create(irbuilder.getContext(), \"dlsym\");\n     BasicBlock *ccall_bb = BasicBlock::Create(irbuilder.getContext(), \"ccall\");\n     Constant *initnul = ConstantPointerNull::get(T_pvoidfunc);\n     LoadInst *llvmf_orig = irbuilder.CreateAlignedLoad(T_pvoidfunc, llvmgv, Align(sizeof(void*)));\n-    setName(emission_context, llvmf_orig, f_name + StringRef(\".cached\"));\n     // This in principle needs a consume ordering so that load from\n     // this pointer sees a valid value. However, this is not supported by\n     // LLVM (or agreed on in the C/C++ standard FWIW) and should be\n@@ -159,26 +191,42 @@ static Value *runtime_sym_lookup(\n     dlsym_lookup->insertInto(f);\n     irbuilder.SetInsertPoint(dlsym_lookup);\n     Instruction *llvmf;\n-    Value *nameval = stringConstPtr(emission_context, irbuilder, f_name);\n-    if (lib_expr) {\n-        jl_cgval_t libval = emit_expr(*ctx, lib_expr);\n-        llvmf = irbuilder.CreateCall(prepare_call_in(jl_builderModule(irbuilder), jllazydlsym_func),\n-                    { boxed(*ctx, libval), nameval });\n-    }\n-    else {\n+    if (libptrgv) {\n+        // Call jl_load_and_lookup\n+        assert(symarg.f_name);\n         Value *libname;\n-        if (runtime_lib) {\n-            libname = stringConstPtr(emission_context, irbuilder, f_lib);\n-        }\n-        else {\n+        if (runtime_lib)\n+            libname = stringConstPtr(emission_context, irbuilder, symarg.f_lib);\n+        else\n             // f_lib is actually one of the special sentinel values\n-            libname = ConstantExpr::getIntToPtr(ConstantInt::get(emission_context.DL.getIntPtrType(irbuilder.getContext()), (uintptr_t)f_lib), getPointerTy(irbuilder.getContext()));\n-        }\n+            libname = ConstantExpr::getIntToPtr(ConstantInt::get(emission_context.DL.getIntPtrType(irbuilder.getContext()), (uintptr_t)symarg.f_lib), getPointerTy(irbuilder.getContext()));\n+        Value *nameval = stringConstPtr(emission_context, irbuilder, symarg.f_name);\n         auto lookup = irbuilder.CreateCall(prepare_call_in(jl_builderModule(irbuilder), jldlsym_func),\n                     { libname, nameval, libptrgv });\n         llvmf = lookup;\n+        setName(emission_context, llvmf, symarg.f_name + StringRef(\".found\"));\n+    }\n+    else {\n+        // Call jl_lazy_load_and_lookup\n+        assert(pctx);\n+        jl_codectx_t &ctx = *pctx;\n+        Value *fname_val;\n+        if (symarg.f_name)\n+            fname_val = track_pjlvalue(ctx, literal_pointer_val(ctx, (jl_value_t*)jl_symbol(symarg.f_name)));\n+        else\n+            fname_val = boxed(ctx, emit_expr(ctx, symarg.f_name_expr));\n+        Value *lib_val;\n+        if (symarg.f_lib)\n+            lib_val = track_pjlvalue(ctx, literal_pointer_val(ctx, (jl_value_t*)jl_symbol(symarg.f_lib)));\n+        else if (symarg.f_lib_expr)\n+            // n.b. f_lib_expr is required to be something simple here (from\n+            // resolve_definition_effects validation) such as a globalref or a\n+            // quote node for example, not a general expression\n+            lib_val = boxed(ctx, emit_expr(ctx, symarg.f_lib_expr));\n+        else\n+            lib_val = ConstantPointerNull::get(ctx.types().T_prjlvalue);\n+        llvmf = irbuilder.CreateCall(prepare_call(jllazydlsym_func), {lib_val, fname_val});\n     }\n-    setName(emission_context, llvmf, f_name + StringRef(\".found\"));\n     StoreInst *store = irbuilder.CreateAlignedStore(llvmf, llvmgv, Align(sizeof(void*)));\n     store->setAtomic(AtomicOrdering::Release);\n     irbuilder.CreateBr(ccall_bb);\n@@ -188,56 +236,46 @@ static Value *runtime_sym_lookup(\n     PHINode *p = irbuilder.CreatePHI(T_pvoidfunc, 2);\n     p->addIncoming(llvmf_orig, enter_bb);\n     p->addIncoming(llvmf, llvmf->getParent());\n-    setName(emission_context, p, f_name);\n     return p;\n }\n \n static Value *runtime_sym_lookup(\n         jl_codectx_t &ctx,\n-        PointerType *funcptype, const char *f_lib, jl_value_t *lib_expr,\n-        const char *f_name, Function *f)\n+        const native_sym_arg_t &symarg, Function *f)\n {\n-    auto T_pvoidfunc = getPointerTy(ctx.builder.getContext());\n     GlobalVariable *libptrgv;\n     GlobalVariable *llvmgv;\n-    bool runtime_lib;\n-    if (lib_expr) {\n-        // for computed library names, generate a global variable to cache the function\n-        // pointer just for this call site.\n-        runtime_lib = true;\n-        libptrgv = NULL;\n-        std::string gvname = \"libname_\";\n-        gvname += f_name;\n-        gvname += \"_\";\n-        gvname += std::to_string(jl_atomic_fetch_add_relaxed(&globalUniqueGeneratedNames, 1));\n-        llvmgv = new GlobalVariable(*jl_Module, T_pvoidfunc, false,\n-                                    GlobalVariable::ExternalLinkage,\n-                                    Constant::getNullValue(T_pvoidfunc), gvname);\n-    }\n-    else {\n-        runtime_lib = runtime_sym_gvs(ctx, f_lib, f_name, libptrgv, llvmgv);\n+    bool runtime_lib = runtime_sym_gvs(ctx, symarg, libptrgv, llvmgv);\n+    if (libptrgv) {\n         libptrgv = prepare_global_in(jl_Module, libptrgv);\n+        llvmgv = prepare_global_in(jl_Module, llvmgv);\n     }\n-    llvmgv = prepare_global_in(jl_Module, llvmgv);\n-    return runtime_sym_lookup(ctx.emission_context, ctx.builder, &ctx, funcptype, f_lib, lib_expr, f_name, f, libptrgv, llvmgv, runtime_lib);\n+    return runtime_sym_lookup(ctx.emission_context, ctx.builder, &ctx, symarg, f, libptrgv, llvmgv, runtime_lib);\n }\n \n // Emit a \"PLT\" entry that will be lazily initialized\n // when being called the first time.\n static GlobalVariable *emit_plt_thunk(\n         jl_codectx_t &ctx,\n         FunctionType *functype, const AttributeList &attrs,\n-        CallingConv::ID cc, const char *f_lib, const char *f_name,\n+        CallingConv::ID cc, const native_sym_arg_t &symarg,\n         GlobalVariable *libptrgv, GlobalVariable *llvmgv,\n         bool runtime_lib)\n {\n     ++PLTThunks;\n-    auto M = &ctx.emission_context.shared_module();\n-    PointerType *funcptype = PointerType::get(functype, 0);\n-    libptrgv = prepare_global_in(M, libptrgv);\n-    llvmgv = prepare_global_in(M, llvmgv);\n+    bool shared = libptrgv != nullptr;\n+    assert(shared && \"not yet supported by runtime_sym_lookup\");\n+    Module *M = shared ? &ctx.emission_context.shared_module() : jl_Module;\n+    if (shared) {\n+        assert(symarg.f_name);\n+        libptrgv = prepare_global_in(M, libptrgv);\n+        llvmgv = prepare_global_in(M, llvmgv);\n+    }\n     std::string fname;\n-    raw_string_ostream(fname) << \"jlplt_\" << f_name << \"_\" << jl_atomic_fetch_add_relaxed(&globalUniqueGeneratedNames, 1);\n+    if (symarg.f_name)\n+        raw_string_ostream(fname) << \"jlplt_\" << symarg.f_name << \"_\" << jl_atomic_fetch_add_relaxed(&globalUniqueGeneratedNames, 1);\n+    else\n+        raw_string_ostream(fname) << \"jldynplt_\" << jl_atomic_fetch_add_relaxed(&globalUniqueGeneratedNames, 1);\n     Function *plt = Function::Create(functype,\n                                      GlobalVariable::PrivateLinkage,\n                                      fname, M);\n@@ -246,18 +284,19 @@ static GlobalVariable *emit_plt_thunk(\n         plt->setCallingConv(cc);\n     auto T_pvoidfunc = getPointerTy(M->getContext());\n     GlobalVariable *got = new GlobalVariable(*M, T_pvoidfunc, false,\n-                                             GlobalVariable::ExternalLinkage,\n+                                             shared ? GlobalVariable::ExternalLinkage : GlobalVariable::PrivateLinkage,\n                                              plt,\n                                              fname + \"_got\");\n-    if (runtime_lib) {\n-        got->addAttribute(\"julia.libname\", f_lib);\n-    } else {\n-        got->addAttribute(\"julia.libidx\", std::to_string((uintptr_t) f_lib));\n+    if (shared) {\n+        if (runtime_lib)\n+            got->addAttribute(\"julia.libname\", symarg.f_lib);\n+        else\n+            got->addAttribute(\"julia.libidx\", std::to_string((uintptr_t) symarg.f_lib));\n+        got->addAttribute(\"julia.fname\", symarg.f_name);\n     }\n-    got->addAttribute(\"julia.fname\", f_name);\n     BasicBlock *b0 = BasicBlock::Create(M->getContext(), \"top\", plt);\n     IRBuilder<> irbuilder(b0);\n-    Value *ptr = runtime_sym_lookup(ctx.emission_context, irbuilder, NULL, funcptype, f_lib, NULL, f_name, plt, libptrgv,\n+    Value *ptr = runtime_sym_lookup(ctx.emission_context, irbuilder, NULL, symarg, plt, libptrgv,\n                                     llvmgv, runtime_lib);\n     StoreInst *store = irbuilder.CreateAlignedStore(ptr, got, Align(sizeof(void*)));\n     store->setAtomic(AtomicOrdering::Release);\n@@ -302,26 +341,28 @@ static Value *emit_plt(\n         jl_codectx_t &ctx,\n         FunctionType *functype,\n         const AttributeList &attrs,\n-        CallingConv::ID cc, const char *f_lib, const char *f_name)\n+        CallingConv::ID cc, const native_sym_arg_t &symarg)\n {\n     ++PLT;\n     // Don't do this for vararg functions so that the `musttail` is only\n     // an optimization and is not required to function correctly.\n     assert(!functype->isVarArg());\n     GlobalVariable *libptrgv;\n     GlobalVariable *llvmgv;\n-    bool runtime_lib = runtime_sym_gvs(ctx, f_lib, f_name, libptrgv, llvmgv);\n+    bool runtime_lib = runtime_sym_gvs(ctx, symarg, libptrgv, llvmgv);\n+    if (!libptrgv)\n+        return runtime_sym_lookup(ctx, symarg, ctx.f);\n \n     auto &pltMap = ctx.emission_context.allPltMap[attrs];\n     auto key = std::make_tuple(llvmgv, functype, cc);\n     GlobalVariable *&sharedgot = pltMap[key];\n     if (!sharedgot) {\n         sharedgot = emit_plt_thunk(ctx,\n-                functype, attrs, cc, f_lib, f_name, libptrgv, llvmgv, runtime_lib);\n+                functype, attrs, cc, symarg, libptrgv, llvmgv, runtime_lib);\n     }\n     GlobalVariable *got = prepare_global_in(jl_Module, sharedgot);\n     LoadInst *got_val = ctx.builder.CreateAlignedLoad(got->getValueType(), got, Align(sizeof(void*)));\n-    setName(ctx.emission_context, got_val, f_name);\n+    setName(ctx.emission_context, got_val, symarg.f_name);\n     // See comment in `runtime_sym_lookup` above. This in principle needs a\n     // consume ordering too. This is even less likely to cause issues though\n     // since the only thing we do to this loaded pointer is to call it\n@@ -551,68 +592,42 @@ static Value *julia_to_native(\n     return slot;\n }\n \n-typedef struct {\n-    Value *jl_ptr;  // if the argument is a run-time computed pointer\n-    void (*fptr)(void);     // if the argument is a constant pointer\n-    const char *f_name;   // if the symbol name is known\n-    const char *f_lib;    // if a library name is specified\n-    jl_value_t *lib_expr; // expression to compute library path lazily\n-    jl_value_t *gcroot;\n-} native_sym_arg_t;\n-\n-static inline const char *invalid_symbol_err_msg(bool ccall)\n-{\n-    return ccall ?\n-        \"ccall: first argument not a pointer or valid constant expression\" :\n-        \"cglobal: first argument not a pointer or valid constant expression\";\n-}\n-\n // --- parse :sym or (:sym, :lib) argument into address info ---\n-static void interpret_symbol_arg(jl_codectx_t &ctx, native_sym_arg_t &out, jl_value_t *arg, bool ccall, bool llvmcall)\n+static void interpret_cglobal_symbol_arg(jl_codectx_t &ctx, native_sym_arg_t &out, jl_value_t *arg)\n {\n     Value *&jl_ptr = out.jl_ptr;\n-    void (*&fptr)(void) = out.fptr;\n     const char *&f_name = out.f_name;\n     const char *&f_lib = out.f_lib;\n-\n     jl_value_t *ptr = static_eval(ctx, arg);\n     if (ptr == NULL) {\n         if (jl_is_expr(arg) && ((jl_expr_t*)arg)->head == jl_call_sym && jl_expr_nargs(arg) == 3 &&\n             jl_is_globalref(jl_exprarg(arg,0)) && jl_globalref_mod(jl_exprarg(arg,0)) == jl_core_module &&\n             jl_globalref_name(jl_exprarg(arg,0)) == jl_symbol(\"tuple\")) {\n-            // attempt to interpret a non-constant 2-tuple expression as (func_name, lib_name()), where\n-            // `lib_name()` will be executed when first used.\n-            jl_value_t *name_val = static_eval(ctx, jl_exprarg(arg,1));\n-            if (name_val && jl_is_symbol(name_val)) {\n-                f_name = jl_symbol_name((jl_sym_t*)name_val);\n-                out.lib_expr = jl_exprarg(arg, 2);\n-                return;\n+            // attempt to interpret a non-constant 2-tuple expression as (func_name, lib_name)\n+            out.f_name_expr = jl_exprarg(arg, 1);\n+            out.f_lib_expr = jl_exprarg(arg, 2);\n+            jl_value_t *name_val = static_eval(ctx, out.f_name_expr);\n+            out.gcroot[0] = name_val;\n+            if (name_val) {\n+                if (jl_is_symbol(name_val))\n+                    f_name = jl_symbol_name((jl_sym_t*)name_val);\n+                else if (jl_is_string(name_val))\n+                    f_name = jl_string_data(name_val);\n             }\n-            else if (name_val && jl_is_string(name_val)) {\n-                f_name = jl_string_data(name_val);\n-                out.gcroot = name_val;\n-                out.lib_expr = jl_exprarg(arg, 2);\n-                return;\n+            jl_value_t *lib_val = static_eval(ctx, out.f_lib_expr);\n+            out.gcroot[1] = lib_val;\n+            if (lib_val) {\n+                if (jl_is_symbol(lib_val))\n+                    f_lib = jl_symbol_name((jl_sym_t*)lib_val);\n+                else if (jl_is_string(lib_val))\n+                    f_lib = jl_string_data(lib_val);\n             }\n         }\n-        jl_cgval_t arg1 = emit_expr(ctx, arg);\n-        jl_value_t *ptr_ty = arg1.typ;\n-        if (!jl_is_cpointer_type(ptr_ty)) {\n-            if (!ccall)\n-                return;\n-            const char *errmsg = invalid_symbol_err_msg(ccall);\n-            emit_cpointercheck(ctx, arg1, errmsg);\n-        }\n-        arg1 = update_julia_type(ctx, arg1, (jl_value_t*)jl_voidpointer_type);\n-        jl_ptr = emit_unbox(ctx, ctx.types().T_ptr, arg1, (jl_value_t*)jl_voidpointer_type);\n-    }\n-    else if (jl_is_cpointer_type(jl_typeof(ptr))) {\n-        fptr = *(void(**)(void))jl_data_ptr(ptr);\n     }\n     else {\n-        out.gcroot = ptr;\n         if (jl_is_tuple(ptr) && jl_nfields(ptr) == 1) {\n             ptr = jl_fieldref(ptr, 0);\n+            out.gcroot[0] = ptr;\n         }\n \n         if (jl_is_symbol(ptr))\n@@ -623,20 +638,15 @@ static void interpret_symbol_arg(jl_codectx_t &ctx, native_sym_arg_t &out, jl_va\n         if (f_name != NULL) {\n             // just symbol, default to JuliaDLHandle\n             // will look in process symbol table\n-            if (!llvmcall) {\n-                void *symaddr;\n-                std::string iname(\"i\");\n-                iname += f_name;\n-                if (jl_dlsym(jl_libjulia_internal_handle, iname.c_str(), &symaddr, 0, 0)) {\n-                    f_lib = JL_LIBJULIA_INTERNAL_DL_LIBNAME;\n-                    f_name = jl_symbol_name(jl_symbol(iname.c_str()));\n-                }\n-                else {\n-                    f_lib = jl_dlfind(f_name);\n-                }\n-            }\n+            f_lib = jl_dlfind(f_name);\n+            out.f_name_expr = jl_new_struct(jl_quotenode_type, ptr);\n+            out.gcroot[0] = out.f_name_expr;\n+        }\n+        else if (jl_is_cpointer_type(jl_typeof(ptr))) {\n+            uint64_t fptr = (uintptr_t)*(void(**)(void))jl_data_ptr(ptr);\n+            jl_ptr = ConstantExpr::getIntToPtr(ConstantInt::get(ctx.types().T_size, fptr), ctx.types().T_ptr);\n         }\n-        else if (jl_is_tuple(ptr) && jl_nfields(ptr) > 1) {\n+        else if (jl_is_tuple(ptr) && jl_nfields(ptr) == 2) {\n             jl_value_t *t0 = jl_fieldref(ptr, 0);\n             if (jl_is_symbol(t0))\n                 f_name = jl_symbol_name((jl_sym_t*)t0);\n@@ -648,9 +658,103 @@ static void interpret_symbol_arg(jl_codectx_t &ctx, native_sym_arg_t &out, jl_va\n                 f_lib = jl_symbol_name((jl_sym_t*)t1);\n             else if (jl_is_string(t1))\n                 f_lib = jl_string_data(t1);\n-            else {\n-                out.lib_expr = t1;\n+\n+            out.f_name_expr = jl_new_struct(jl_quotenode_type, t0);\n+            out.gcroot[0] = out.f_name_expr;\n+            out.f_lib_expr = jl_new_struct(jl_quotenode_type, t1);\n+            out.gcroot[1] = out.f_lib_expr;\n+        }\n+    }\n+}\n+\n+static void interpret_ccall_symbol_arg(jl_codectx_t &ctx, native_sym_arg_t &out, jl_value_t *arg)\n+{\n+    // Initialize all fields to safe defaults\n+    out.f_name = nullptr;\n+    out.f_lib = nullptr;\n+    out.f_name_expr = nullptr;\n+    out.f_lib_expr = nullptr;\n+    out.jl_ptr = nullptr;\n+    out.gcroot[0] = nullptr;\n+    out.gcroot[1] = nullptr;\n+\n+    // Check if this is a tuple (normalized by julia-syntax.scm)\n+    if (jl_is_expr(arg) && ((jl_expr_t*)arg)->head == jl_symbol(\"tuple\")) {\n+        size_t nargs = jl_expr_nargs(arg);\n+        jl_array_t *tuple_args = ((jl_expr_t*)arg)->args;\n+\n+        if (nargs == 1) {\n+            // Single element tuple: (func_name,) - use default library\n+            jl_value_t *fname_arg = jl_array_ptr_ref(tuple_args, 0);\n+            jl_value_t *fname_val = static_eval(ctx, fname_arg);\n+            // Dynamic resolution - single function name expression, will use default library at runtime\n+            out.f_name_expr = fname_arg;\n+\n+            if (fname_val != nullptr) {\n+                // Static resolution succeeded\n+                out.gcroot[0] = fname_val;\n+                if (jl_is_symbol(fname_val)) {\n+                    out.f_name = jl_symbol_name((jl_sym_t*)fname_val);\n+                }\n+                else if (jl_is_string(fname_val)) {\n+                    out.f_name = jl_string_data(fname_val);\n+                }\n+             }\n+        }\n+        else if (nargs == 2) {\n+            // Two element tuple: (func_name, lib_name)\n+            jl_value_t *fname_arg = jl_array_ptr_ref(tuple_args, 0);\n+            jl_value_t *lib_arg = jl_array_ptr_ref(tuple_args, 1);\n+            out.f_name_expr = fname_arg;\n+            out.f_lib_expr = lib_arg;\n+\n+            jl_value_t *fname_val = static_eval(ctx, fname_arg);\n+            jl_value_t *lib_val = static_eval(ctx, lib_arg);\n+            if (fname_val != nullptr) {\n+                // Static resolution for both\n+                out.gcroot[0] = fname_val; // Keep function name for GC\n+                if (jl_is_symbol(fname_val)) {\n+                    out.f_name = jl_symbol_name((jl_sym_t*)fname_val);\n+                }\n+                else if (jl_is_string(fname_val)) {\n+                    out.f_name = jl_string_data(fname_val);\n+                }\n             }\n+\n+            if (lib_val != nullptr) {\n+                out.gcroot[1] = lib_val;   // Keep library name for GC\n+                if (jl_is_symbol(lib_val)) {\n+                    out.f_lib = jl_symbol_name((jl_sym_t*)lib_val);\n+                }\n+                else if (jl_is_string(lib_val)) {\n+                    out.f_lib = jl_string_data(lib_val);\n+                }\n+            }\n+        }\n+    }\n+    else {\n+        // Not a tuple - pointer expression\n+        jl_cgval_t arg1 = emit_expr(ctx, arg);\n+        jl_value_t *ptr_ty = arg1.typ;\n+        if (!jl_is_cpointer_type(ptr_ty)) {\n+            const char *errmsg = \"ccall: first argument not a pointer or valid constant expression\";\n+            emit_cpointercheck(ctx, arg1, errmsg);\n+        }\n+        arg1 = update_julia_type(ctx, arg1, (jl_value_t*)jl_voidpointer_type);\n+        out.jl_ptr = emit_unbox(ctx, ctx.types().T_ptr, arg1, (jl_value_t*)jl_voidpointer_type);\n+    }\n+\n+    // Handle Julia internal symbol lookup for static function names\n+    if (out.f_name != nullptr && out.f_lib_expr == nullptr) {\n+        void *symaddr;\n+        std::string iname(\"i\");\n+        iname += out.f_name;\n+        if (jl_dlsym(jl_libjulia_internal_handle, iname.c_str(), &symaddr, 0, 0)) {\n+            out.f_lib = JL_LIBJULIA_INTERNAL_DL_LIBNAME;\n+            out.f_name = jl_symbol_name(jl_symbol(iname.c_str()));\n+        }\n+        else {\n+            out.f_lib = jl_dlfind(out.f_name);\n         }\n     }\n }\n@@ -666,7 +770,7 @@ static jl_cgval_t emit_cglobal(jl_codectx_t &ctx, jl_value_t **args, size_t narg\n     jl_value_t *rt = NULL;\n     Value *res;\n     native_sym_arg_t sym = {};\n-    JL_GC_PUSH2(&rt, &sym.gcroot);\n+    JL_GC_PUSH3(&rt, &sym.gcroot[0], &sym.gcroot[1]);\n \n     if (nargs == 2) {\n         rt = static_eval(ctx, args[2]);\n@@ -684,32 +788,25 @@ static jl_cgval_t emit_cglobal(jl_codectx_t &ctx, jl_value_t **args, size_t narg\n     else {\n         rt = (jl_value_t*)jl_voidpointer_type;\n     }\n-    Type *lrt = ctx.types().T_ptr;\n-    assert(lrt == julia_type_to_llvm(ctx, rt));\n-\n-    interpret_symbol_arg(ctx, sym, args[1], /*ccall=*/false, false);\n-\n+    interpret_cglobal_symbol_arg(ctx, sym, args[1]);\n     if (sym.jl_ptr != NULL) {\n         res = sym.jl_ptr;\n     }\n-    else if (sym.fptr != NULL) {\n-        res = ConstantInt::get(lrt, (uint64_t)sym.fptr);\n+    else if (sym.f_name_expr != NULL) {\n+        res = runtime_sym_lookup(ctx, sym, ctx.f);\n     }\n-    else if (sym.f_name != NULL) {\n-        if (sym.lib_expr) {\n-            res = runtime_sym_lookup(ctx, getPointerTy(ctx.builder.getContext()), NULL, sym.lib_expr, sym.f_name, ctx.f);\n-        }\n-        else {\n-            res = runtime_sym_lookup(ctx, getPointerTy(ctx.builder.getContext()), sym.f_lib, NULL, sym.f_name, ctx.f);\n-        }\n-    } else {\n+    else {\n         // Fall back to runtime intrinsic\n         JL_GC_POP();\n         jl_cgval_t argv[2];\n         argv[0] = emit_expr(ctx, args[1]);\n         if (nargs == 2)\n             argv[1] = emit_expr(ctx, args[2]);\n-        return emit_runtime_call(ctx, nargs == 1 ? JL_I::cglobal_auto : JL_I::cglobal, argv, nargs);\n+        if (!jl_is_cpointer_type(argv[0].typ))\n+            return emit_runtime_call(ctx, nargs == 1 ? JL_I::cglobal_auto : JL_I::cglobal, argv, nargs);\n+        argv[0] = update_julia_type(ctx, argv[0], (jl_value_t*)jl_voidpointer_type);\n+        sym.jl_ptr = emit_unbox(ctx, ctx.types().T_ptr, argv[0], (jl_value_t*)jl_voidpointer_type);\n+        res = sym.jl_ptr;\n     }\n \n     JL_GC_POP();\n@@ -1436,33 +1533,17 @@ static jl_cgval_t emit_ccall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n     }\n     assert(jl_is_symbol(cc_sym));\n     native_sym_arg_t symarg = {};\n-    JL_GC_PUSH3(&rt, &at, &symarg.gcroot);\n+    JL_GC_PUSH4(&rt, &at, &symarg.gcroot[0], &symarg.gcroot[1]);\n \n     CallingConv::ID cc = CallingConv::C;\n     bool llvmcall = false;\n     std::tie(cc, llvmcall) = convert_cconv(cc_sym);\n \n-    interpret_symbol_arg(ctx, symarg, args[1], /*ccall=*/true, llvmcall);\n-    Value *&jl_ptr = symarg.jl_ptr;\n-    void (*&fptr)(void) = symarg.fptr;\n+    interpret_ccall_symbol_arg(ctx, symarg, args[1]);\n     const char *&f_name = symarg.f_name;\n     const char *&f_lib = symarg.f_lib;\n \n-    if (f_name == NULL && fptr == NULL && jl_ptr == NULL) {\n-        if (symarg.gcroot != NULL) { // static_eval(ctx, args[1]) could not be interpreted to a function pointer\n-            const char *errmsg = invalid_symbol_err_msg(/*ccall=*/true);\n-            jl_cgval_t arg1 = emit_expr(ctx, args[1]);\n-            emit_type_error(ctx, arg1, literal_pointer_val(ctx, (jl_value_t *)jl_pointer_type), errmsg);\n-        } else {\n-            emit_error(ctx, \"ccall: null function pointer\");\n-        }\n-        JL_GC_POP();\n-        return jl_cgval_t();\n-    }\n-\n-    auto _is_libjulia_func = [&] (uintptr_t ptr, StringRef name) {\n-        if ((uintptr_t)fptr == ptr)\n-            return true;\n+    auto _is_libjulia_func = [&f_lib, &f_name] (StringRef name) {\n         if (f_lib) {\n             if ((f_lib == JL_EXE_LIBNAME) || // preventing invalid pointer access\n                 (f_lib == JL_LIBJULIA_INTERNAL_DL_LIBNAME) ||\n@@ -1480,7 +1561,7 @@ static jl_cgval_t emit_ccall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n         }\n         return f_name && f_name == name;\n     };\n-#define is_libjulia_func(name) _is_libjulia_func((uintptr_t)&(name), StringRef(XSTR(name)))\n+#define is_libjulia_func(name) _is_libjulia_func(StringRef(XSTR(name)))\n \n     // emit arguments\n     SmallVector<jl_cgval_t, 4> argv(nccallargs);\n@@ -2075,20 +2156,16 @@ jl_cgval_t function_sig_t::emit_a_ccall(\n     Value *llvmf;\n     if (llvmcall) {\n         ++EmittedLLVMCalls;\n-        if (symarg.jl_ptr != NULL) {\n-            emit_error(ctx, \"llvmcall doesn't support dynamic pointers\");\n+        if (symarg.f_name == NULL) {\n+            // TODO: this should be checked/enforced a bit better (less dynamically)\n+            emit_error(ctx, \"llvmcall doesn't support dynamic names\");\n             return jl_cgval_t();\n         }\n-        else if (symarg.fptr != NULL) {\n-            emit_error(ctx, \"llvmcall doesn't support static pointers\");\n-            return jl_cgval_t();\n-        }\n-        else if (symarg.f_lib != NULL) {\n+        else if (symarg.f_lib_expr != NULL) {\n             emit_error(ctx, \"llvmcall doesn't support dynamic libraries\");\n             return jl_cgval_t();\n         }\n         else {\n-            assert(symarg.f_name != NULL);\n             StringRef f_name(symarg.f_name);\n             bool f_extern = f_name.consume_front(\"extern \");\n             llvmf = NULL;\n@@ -2138,36 +2215,25 @@ jl_cgval_t function_sig_t::emit_a_ccall(\n         null_pointer_check(ctx, symarg.jl_ptr, nullptr);\n         llvmf = symarg.jl_ptr;\n     }\n-    else if (symarg.fptr != NULL) {\n-        ++LiteralCCalls;\n-        Type *funcptype = PointerType::getUnqual(functype->getContext());\n-        llvmf = literal_static_pointer_val((void*)(uintptr_t)symarg.fptr, funcptype);\n-        setName(ctx.emission_context, llvmf, \"ccall_fptr\");\n-    }\n     else if (!ctx.params->use_jlplt) {\n         if ((symarg.f_lib && !((symarg.f_lib == JL_EXE_LIBNAME) ||\n               (symarg.f_lib == JL_LIBJULIA_INTERNAL_DL_LIBNAME) ||\n-              (symarg.f_lib == JL_LIBJULIA_DL_LIBNAME))) || symarg.lib_expr) {\n+              (symarg.f_lib == JL_LIBJULIA_DL_LIBNAME))) || symarg.f_lib_expr) {\n+            // n.b. this is not semantically valid, but use_jlplt=1 when semantic correctness is desired\n             emit_error(ctx, \"ccall: Had library expression, but symbol lookup was disabled\");\n         }\n+        if (symarg.f_name == nullptr)\n+            emit_error(ctx, \"ccall: Had name expression, but symbol lookup was disabled\");\n         llvmf = jl_Module->getOrInsertFunction(symarg.f_name, functype).getCallee();\n     }\n     else {\n-        assert(symarg.f_name != NULL);\n-        PointerType *funcptype = PointerType::get(functype, 0);\n-        if (symarg.lib_expr) {\n-            ++DeferredCCallLookups;\n-            llvmf = runtime_sym_lookup(ctx, funcptype, NULL, symarg.lib_expr, symarg.f_name, ctx.f);\n-        }\n-        else {\n-            ++DeferredCCallLookups;\n-            // vararg requires musttail,\n-            // but musttail is incompatible with noreturn.\n-            if (functype->isVarArg())\n-                llvmf = runtime_sym_lookup(ctx, funcptype, symarg.f_lib, NULL, symarg.f_name, ctx.f);\n-            else\n-                llvmf = emit_plt(ctx, functype, attributes, cc, symarg.f_lib, symarg.f_name);\n-        }\n+        ++DeferredCCallLookups;\n+        // vararg requires musttail,\n+        // but musttail is incompatible with noreturn.\n+        if (functype->isVarArg())\n+            llvmf = runtime_sym_lookup(ctx, symarg, ctx.f);\n+        else\n+            llvmf = emit_plt(ctx, functype, attributes, cc, symarg);\n     }\n \n     // Potentially we could add gc_uses to `gc-transition`, instead of emitting them separately as jl_roots"
    },
    {
      "sha": "71dd815548358cfa5e9d997936af1e148cbc629c",
      "filename": "src/codegen.cpp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fcodegen.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fcodegen.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcodegen.cpp?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -1280,7 +1280,7 @@ static const auto jldlsym_func = new JuliaFunction<>{\n static const auto jllazydlsym_func = new JuliaFunction<>{\n     XSTR(jl_lazy_load_and_lookup),\n     [](LLVMContext &C) { return FunctionType::get(getPointerTy(C),\n-            {JuliaType::get_prjlvalue_ty(C), getPointerTy(C)}, false); },\n+            {JuliaType::get_prjlvalue_ty(C), JuliaType::get_prjlvalue_ty(C)}, false); },\n     nullptr,\n };\n static const auto jltypeassert_func = new JuliaFunction<>{"
    },
    {
      "sha": "6bfb3ff5a7a7e7ccca4102f693be271b05e6b3a0",
      "filename": "src/julia-syntax.scm",
      "status": "modified",
      "additions": 41,
      "deletions": 17,
      "changes": 58,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fjulia-syntax.scm",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fjulia-syntax.scm",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia-syntax.scm?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -1087,6 +1087,15 @@\n                        (values name params super)) ex)\n       (error \"invalid type signature\")))\n \n+;; normalize ccall first argument to tuple form with basic error checking\n+(define (normalize-ccall-name raw-name)\n+  (cond\n+   ;; Already a tuple - keep as-is, validation will happen in C\n+   ((tuple-syntax? raw-name)\n+    raw-name)\n+   ;; Otherwise it is an atom or pointer expression, which will be validated later in C\n+   (else (expand-forms raw-name))))\n+\n ;; insert calls to convert() in ccall, and pull out expressions that might\n ;; need to be rooted before conversion.\n (define (lower-ccall name RT atypes args cconv nreq)\n@@ -1106,7 +1115,7 @@\n       (if (null? A)\n           `(block\n             ,.(reverse! stmts)\n-            (foreigncall ,(expand-forms name) ,(expand-forms RT) (call (core svec) ,@(reverse! T))\n+            (foreigncall ,(normalize-ccall-name name) ,(expand-forms RT) (call (core svec) ,@(reverse! T))\n                          ;; 0 or number of arguments before ... in definition\n                          ,(or nreq\n                               (if isseq (- (length atypes) 1) 0))\n@@ -1150,7 +1159,7 @@\n         (error (string \"invalid argument destructuring syntax \\\"\" (deparse a) \"\\\"\"))\n         a))\n   (define (transform-arg a)\n-    (cond ((and (pair? a) (eq? (car a) 'tuple))\n+    (cond ((tuple-syntax? a)\n            (let ((a2 (gensy)))\n              (cons a2 `(local (= ,(check-lhs a) ,a2)))))\n           ((or (and (decl? a) (length= a 3)) (kwarg? a))\n@@ -1321,8 +1330,7 @@\n                                           (= ,vname ,tmp)\n                                           ,blk)))))))\n                ;; (a, b, c, ...) = rhs\n-               ((and (pair? (cadar binds))\n-                     (eq? (caadar binds) 'tuple))\n+               ((tuple-syntax? (cadar binds))\n                 (let ((vars (lhs-vars (cadar binds))))\n                   (loop (cdr binds)\n                         (let ((tmp (make-ssavalue)))\n@@ -1861,7 +1869,7 @@\n                      (cons temp (append (cdr e) (list `(= ,temp ,newlhs))))\n                      e))\n          (newlhs (or temp newlhs)))\n-    (if (and (pair? lhs) (eq? (car lhs) 'tuple))\n+    (if (tuple-syntax? lhs)\n         (let loop ((a (cdr newlhs))\n                    (b (cdr lhs)))\n           (if (pair? a)\n@@ -2491,7 +2499,7 @@\n           ((null? r)          #f)\n           ((vararg? (car r))  (null? (cdr r)))\n           (else               (sides-match? (cdr l) (cdr r)))))\n-  (if (and (pair? x) (pair? lhss) (eq? (car x) 'tuple) (not (any assignment? (cdr x)))\n+  (if (and (tuple-syntax? x) (pair? lhss) (not (any assignment? (cdr x)))\n            (not (has-parameters? (cdr x)))\n            (sides-match? lhss (cdr x)))\n       ;; (a, b, ...) = (x, y, ...)\n@@ -2720,13 +2728,12 @@\n                          (argtypes (cadr after-cconv))\n                          (args (cddr after-cconv)))\n                         (begin\n-                          (if (not (and (pair? argtypes)\n-                                        (eq? (car argtypes) 'tuple)))\n-                              (if (and (pair? RT)\n-                                       (eq? (car RT) 'tuple))\n+                          (if (not (tuple-syntax? argtypes))\n+                              (if (tuple-syntax? RT)\n                                   (error \"ccall argument types must be a tuple; try \\\"(T,)\\\" and check if you specified a correct return type\")\n                                   (error \"ccall argument types must be a tuple; try \\\"(T,)\\\"\")))\n-                          (lower-ccall name RT (cdr argtypes) args\n+                          (lower-ccall name\n+                                       RT (cdr argtypes) args\n                                        (if have-cconv\n                                            (if have-cconv-expr\n                                                (cadr cconv)\n@@ -2771,6 +2778,20 @@\n                   (map expand-forms e))))\n          (map expand-forms e)))\n \n+   'foreigncall\n+   (lambda (e)\n+     (if (not (length> e 5)) (error \"too few arguments to foreigncall\"))\n+     (let* ((name (car (list-tail e 1)))\n+            (RT (car (list-tail e 2)))\n+            (atypes (car (list-tail e 3)))\n+            (nreq (car (list-tail e 4)))\n+            (cconv (car (list-tail e 5)))\n+            (args-and-roots (list-tail e 6)))\n+       (begin\n+         ;; Return expanded foreigncall\n+         `(foreigncall ,(normalize-ccall-name name) ,(expand-forms RT) ,(expand-forms atypes)\n+                       ,nreq ,cconv ,@(map expand-forms args-and-roots)))))\n+\n    'do\n    (lambda (e)\n      (let* ((call (cadr e))\n@@ -4500,6 +4521,9 @@ f(x) = yt(x)\n       (else #f))\n     #t))\n \n+(define (tuple-syntax? fptr)\n+  (and (pair? fptr) (eq? (car fptr) 'tuple)))\n+\n ;; this pass behaves like an interpreter on the given code.\n ;; to perform stateful operations, it calls `emit` to record that something\n ;; needs to be done. in value position, it returns an expression computing\n@@ -4772,10 +4796,10 @@ f(x) = yt(x)\n              (let* ((args\n                      (cond ((eq? (car e) 'foreigncall)\n                             ;; NOTE: 2nd to 5th arguments of ccall must be left in place\n-                            ;;       the 1st should be compiled if an atom.\n-                            (append (if (atom-or-not-tuple-call? (cadr e))\n-                                        (compile-args (list (cadr e)) break-labels)\n-                                        (list (cadr e)))\n+                            ;;       the 1st should be compiled unless it is a syntactic tuple from earlier\n+                            (append (if (tuple-syntax? (cadr e))\n+                                        (list (cadr e))\n+                                        (compile-args (list (cadr e)) break-labels))\n                                     (list-head (cddr e) 4)\n                                     (compile-args (list-tail e 6) break-labels)))\n                            ;; NOTE: arguments of cfunction must be left in place\n@@ -5427,8 +5451,8 @@ f(x) = yt(x)\n              (let ((e (cons (car e)\n                             (map renumber-stuff (cdr e)))))\n                (if (and (eq? (car e) 'foreigncall)\n-                        (tuple-call? (cadr e))\n-                        (expr-contains-p (lambda (x) (or (ssavalue? x) (slot? x))) (cadr e)))\n+                        (tuple-syntax? (cadr e))\n+                        (expr-contains-p (lambda (x) (or (ssavalue? x) (slot? x))) (cadr e))) ;; TODO: use allow-list here\n                    (error \"ccall function name and library expression cannot reference local variables\"))\n                e))))\n     (let ((body (renumber-stuff (lam:body lam)))"
    },
    {
      "sha": "ebf9f3690062f7d6db9789e5be3ab223cf053589",
      "filename": "src/julia_internal.h",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fjulia_internal.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fjulia_internal.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia_internal.h?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -943,6 +943,7 @@ jl_value_t *jl_interpret_toplevel_expr_in(jl_module_t *m, jl_value_t *e,\n JL_DLLEXPORT int jl_is_toplevel_only_expr(jl_value_t *e) JL_NOTSAFEPOINT;\n jl_value_t *jl_call_scm_on_ast_and_loc(const char *funcname, jl_value_t *expr,\n                                        jl_module_t *inmodule, const char *file, int line);\n+int jl_isa_ast_node(jl_value_t *e) JL_NOTSAFEPOINT;\n \n JL_DLLEXPORT jl_value_t *jl_method_lookup_by_tt(jl_tupletype_t *tt, size_t world, jl_value_t *_mt);\n JL_DLLEXPORT jl_method_instance_t *jl_method_lookup(jl_value_t **args, size_t nargs, size_t world);\n@@ -1654,7 +1655,7 @@ JL_DLLEXPORT void *jl_get_library_(const char *f_lib, int throw_err);\n void *jl_find_dynamic_library_by_addr(void *symbol, int throw_err, int close) JL_NOTSAFEPOINT;\n #define jl_get_library(f_lib) jl_get_library_(f_lib, 1)\n JL_DLLEXPORT void *jl_load_and_lookup(const char *f_lib, const char *f_name, _Atomic(void*) *hnd);\n-JL_DLLEXPORT void *jl_lazy_load_and_lookup(jl_value_t *lib_val, const char *f_name);\n+JL_DLLEXPORT void *jl_lazy_load_and_lookup(jl_value_t *lib_val, jl_value_t *f_name);\n JL_DLLEXPORT jl_value_t *jl_get_cfunction_trampoline(\n     jl_value_t *fobj, jl_datatype_t *result, htable_t *cache, jl_svec_t *fill,\n     void *(*init_trampoline)(void *tramp, void **nval),"
    },
    {
      "sha": "cee941ae77ddb65d71b6c8e71a35862d40eae2d2",
      "filename": "src/method.c",
      "status": "modified",
      "additions": 80,
      "deletions": 0,
      "changes": 80,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fmethod.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fmethod.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fmethod.c?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -162,6 +162,86 @@ static jl_value_t *resolve_definition_effects(jl_value_t *expr, jl_module_t *mod\n     if (e->head == jl_foreigncall_sym) {\n         JL_NARGSV(ccall method definition, 5); // (fptr, rt, at, nreq, (cc, effects, gc_safe))\n         jl_task_t *ct = jl_current_task;\n+        jl_value_t *fptr = jl_exprarg(e, 0);\n+        // Handle dot expressions in tuple arguments for ccall by converting to GlobalRef eagerly\n+        jl_sym_t *tuple_sym = jl_symbol(\"tuple\");\n+        if (jl_is_quotenode(fptr)) {\n+            if (jl_is_string(jl_quotenode_value(fptr)) || jl_is_tuple(jl_quotenode_value(fptr)))\n+                fptr = jl_quotenode_value(fptr);\n+        }\n+        if (jl_is_tuple(fptr)) {\n+            // convert literal Tuple to Expr tuple\n+            jl_expr_t *tupex = jl_exprn(tuple_sym, jl_nfields(fptr));\n+            jl_value_t *v = NULL;\n+            JL_GC_PUSH2(&tupex, &v);\n+            for (long i = 0; i < jl_nfields(fptr); i++) {\n+                v = jl_fieldref(fptr, i);\n+                if (!jl_is_string(v))\n+                    v = jl_new_struct(jl_quotenode_type, v);\n+                jl_exprargset(tupex, i, v);\n+            }\n+            jl_exprargset(e, 0, tupex);\n+            fptr = (jl_value_t*)tupex;\n+            JL_GC_POP();\n+        }\n+        if (jl_is_expr(fptr) && ((jl_expr_t*)fptr)->head == tuple_sym) {\n+            // verify Expr tuple can be interpreted and handle\n+            jl_expr_t *tuple_expr = (jl_expr_t*)fptr;\n+            size_t nargs_tuple = jl_expr_nargs(tuple_expr);\n+            if (nargs_tuple == 0)\n+                jl_error(\"ccall function name cannot be empty tuple\");\n+            if (nargs_tuple > 2)\n+                jl_error(\"ccall function name tuple can have at most 2 elements\");\n+            // Validate tuple elements are not more complicated than inference/codegen can safely handle\n+            for (size_t i = 0; i < nargs_tuple; i++) {\n+                jl_value_t *arg = jl_exprarg(tuple_expr, i);\n+                // Handle dot expressions by converting to a GlobalRef\n+                if (jl_is_expr(arg) && ((jl_expr_t*)arg)->head == jl_dot_sym) {\n+                    jl_expr_t *dot_expr = (jl_expr_t*)arg;\n+                    if (jl_expr_nargs(dot_expr) != 2)\n+                        jl_error(\"ccall function name: invalid dot expression\");\n+                    jl_value_t *mod_expr = jl_exprarg(dot_expr, 0);\n+                    jl_value_t *sym_expr = jl_exprarg(dot_expr, 1);\n+                    if (!(jl_is_quotenode(sym_expr) && jl_is_symbol(jl_quotenode_value(sym_expr))))\n+                        jl_type_error(\"ccall name dot expression\", (jl_value_t*)jl_symbol_type, sym_expr);\n+                    JL_TRY {\n+                        // Evaluate the module expression\n+                        jl_value_t *mod_val = jl_toplevel_eval(module, mod_expr);\n+                        JL_TYPECHK(ccall name dot expression, module, mod_val);\n+                        JL_GC_PROMISE_ROOTED(mod_val);\n+                        // Create GlobalRef from evaluated module and quoted symbol\n+                        jl_sym_t *sym = (jl_sym_t*)jl_quotenode_value(sym_expr);\n+                        jl_value_t *globalref = jl_module_globalref((jl_module_t*)mod_val, sym);\n+                        jl_exprargset(tuple_expr, i, globalref);\n+                    }\n+                    JL_CATCH {\n+                        if (jl_typetagis(jl_current_exception(ct), jl_errorexception_type))\n+                            jl_error(\"could not evaluate ccall function/library name (it might depend on a local variable)\");\n+                        else\n+                            jl_rethrow();\n+                    }\n+                }\n+                else if (jl_is_quotenode(arg)) {\n+                    if (i == 0) {\n+                        // function name must be a symbol or string, library can be anything\n+                        jl_value_t *quoted_val = jl_quotenode_value(arg);\n+                        if (!jl_is_symbol(quoted_val) && !jl_is_string(quoted_val))\n+                            jl_type_error(\"ccall function name\", (jl_value_t*)jl_symbol_type, jl_quotenode_value(arg));\n+                    }\n+                }\n+                else if (!jl_is_globalref(arg) && jl_isa_ast_node(arg)) {\n+                    jl_type_error(i == 0 ? \"ccall function name\" : \"ccall library name\", (jl_value_t*)jl_symbol_type, arg);\n+                }\n+            }\n+        }\n+        else if (jl_is_string(fptr) || (jl_is_quotenode(fptr) && jl_is_symbol(jl_quotenode_value(fptr)))) {\n+            // convert String to Expr (String,)\n+            // convert QuoteNode(Symbol) to Expr (QuoteNode(Symbol),)\n+            jl_expr_t *tupex = jl_exprn(tuple_sym, 1);\n+            jl_exprargset(tupex, 0, fptr);\n+            jl_exprargset(e, 0, tupex);\n+            fptr = (jl_value_t*)tupex;\n+        }\n         jl_value_t *rt = jl_exprarg(e, 1);\n         jl_value_t *at = jl_exprarg(e, 2);\n         if (!jl_is_type(rt)) {"
    },
    {
      "sha": "4c787348f6f1b0addf5972b234de36c3b673dbdc",
      "filename": "src/runtime_ccall.cpp",
      "status": "modified",
      "additions": 25,
      "deletions": 12,
      "changes": 37,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fruntime_ccall.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fruntime_ccall.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fruntime_ccall.cpp?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -65,22 +65,35 @@ void *jl_load_and_lookup(const char *f_lib, const char *f_name, _Atomic(void*) *\n \n // jl_load_and_lookup, but with library computed at run time on first call\n extern \"C\" JL_DLLEXPORT\n-void *jl_lazy_load_and_lookup(jl_value_t *lib_val, const char *f_name)\n+void *jl_lazy_load_and_lookup(jl_value_t *lib_val, jl_value_t *f_name)\n {\n     void *lib_ptr;\n+    const char *fname_str;\n+\n+    if (jl_is_symbol(f_name))\n+        fname_str = jl_symbol_name((jl_sym_t*)f_name);\n+    else if (jl_is_string(f_name))\n+        fname_str = jl_string_data(f_name);\n+    else\n+        jl_type_error(\"ccall function name\", (jl_value_t*)jl_symbol_type, f_name);\n+\n+    if (lib_val) {\n+        if (jl_is_symbol(lib_val))\n+            lib_ptr = jl_get_library(jl_symbol_name((jl_sym_t*)lib_val));\n+        else if (jl_is_string(lib_val))\n+            lib_ptr = jl_get_library(jl_string_data(lib_val));\n+        else if (jl_libdl_dlopen_func != NULL) {\n+            lib_ptr = jl_unbox_voidpointer(jl_apply_generic(jl_libdl_dlopen_func, &lib_val, 1));\n+        } else\n+            jl_type_error(\"ccall\", (jl_value_t*)jl_symbol_type, lib_val);\n+    }\n+    else {\n+        // If the user didn't supply a library name, try to find it now from the runtime value of f_name\n+        lib_ptr = jl_get_library(jl_dlfind(fname_str));\n+    }\n \n-    if (jl_is_symbol(lib_val))\n-        lib_ptr = jl_get_library(jl_symbol_name((jl_sym_t*)lib_val));\n-    else if (jl_is_string(lib_val))\n-        lib_ptr = jl_get_library(jl_string_data(lib_val));\n-    else if (jl_libdl_dlopen_func != NULL) {\n-        // Call `dlopen(lib_val)`; this is the correct path for the `LazyLibrary` case,\n-        // but it also takes any other value, and so we define `dlopen(x::Any) = throw(TypeError(...))`.\n-        lib_ptr = jl_unbox_voidpointer(jl_apply_generic(jl_libdl_dlopen_func, &lib_val, 1));\n-    } else\n-        jl_type_error(\"ccall\", (jl_value_t*)jl_symbol_type, lib_val);\n     void *ptr;\n-    jl_dlsym(lib_ptr, f_name, &ptr, 1, 1);\n+    jl_dlsym(lib_ptr, fname_str, &ptr, 1, 1);\n     return ptr;\n }\n "
    },
    {
      "sha": "31dd3e085033ccdfae5baf5dd86a9f99d419c2e3",
      "filename": "src/runtime_intrinsics.c",
      "status": "modified",
      "additions": 1,
      "deletions": 18,
      "changes": 19,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fruntime_intrinsics.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/src%2Fruntime_intrinsics.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fruntime_intrinsics.c?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -654,25 +654,8 @@ JL_DLLEXPORT jl_value_t *jl_cglobal(jl_value_t *v, jl_value_t *ty)\n         f_lib = jl_fieldref(v, 1);\n         v = jl_fieldref(v, 0);\n     }\n-\n-    char *f_name = NULL;\n-    if (jl_is_symbol(v))\n-        f_name = jl_symbol_name((jl_sym_t*)v);\n-    else if (jl_is_string(v))\n-        f_name = jl_string_data(v);\n-    else\n-        JL_TYPECHK(cglobal, symbol, v)\n-\n-    void *ptr;\n-    if (f_lib) {\n-        ptr = jl_lazy_load_and_lookup(f_lib, f_name);\n-    }\n-    else {\n-        void *handle = jl_get_library((char*)jl_dlfind(f_name));\n-        jl_dlsym(handle, f_name, &ptr, 1, 0);\n-    }\n+    void *ptr = jl_lazy_load_and_lookup(f_lib, v);\n     JL_GC_POP();\n-\n     jl_value_t *jv = jl_gc_alloc(jl_current_task->ptls, sizeof(void*), rt);\n     *(void**)jl_data_ptr(jv) = ptr;\n     return jv;"
    },
    {
      "sha": "633af8e6a8495be500798c7a588b8f60234aafd0",
      "filename": "test/ccall.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 11,
      "changes": 24,
      "blob_url": "https://github.com/JuliaLang/julia/blob/8441383e4d2a0af629abd8493010647e150e1b75/test%2Fccall.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/8441383e4d2a0af629abd8493010647e150e1b75/test%2Fccall.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fccall.jl?ref=8441383e4d2a0af629abd8493010647e150e1b75",
      "patch": "@@ -1537,6 +1537,14 @@ fn45187() = nothing\n @test Expr(:error, \"only the trailing ccall argument type should have \\\"...\\\"\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (A, B..., C...), a, x, y, z)))\n @test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B, C...), )))\n \n+# test for ccall first argument tuple validation errors\n+@test_throws \"ccall function name cannot be empty tuple\" eval(:(f() = ccall((), A, (), )))\n+@test_throws \"ccall function name tuple can have at most 2 elements\" eval(:(f() = ccall((:a, :b, :c), A, (), )))\n+@test_throws \"ccall function name tuple can have at most 2 elements\" eval(:(f() = ccall((:a, :b, :c, :d), A, (), )))\n+@test_throws TypeError eval(:(f() = ccall((1 + 2,), A, (), )))\n+@test_throws TypeError eval(:(f() = ccall((:a, 1 + 2), A, (), )))\n+@test_throws TypeError eval(:(ccall_lazy_lib_name(x) = ccall((:testUcharX, compute_lib_name()), Int32, (UInt8,), x % UInt8)))\n+\n # cfunction on non-function singleton\n struct CallableSingleton\n end\n@@ -1751,18 +1759,16 @@ using Base: ccall_macro_parse, ccall_macro_lower\n end\n \n @testset \"ensure the base-case of @ccall works, including library name and pointer interpolation\" begin\n-    call = ccall_macro_lower(:ccall, ccall_macro_parse( :( libstring.func(\n+    ccallmacro = ccall_macro_lower(:ccall, ccall_macro_parse( :( libstring.func(\n         str::Cstring,\n         num1::Cint,\n         num2::Cint\n     )::Cstring))...)\n-    @test call == Base.remove_linenums!(\n-        quote\n-        ccall($(Expr(:escape, :((:func, libstring)))), $(Expr(:cconv, (:ccall, UInt16(0), false), 0)), $(Expr(:escape, :Cstring)), ($(Expr(:escape, :Cstring)), $(Expr(:escape, :Cint)), $(Expr(:escape, :Cint))), $(Expr(:escape, :str)), $(Expr(:escape, :num1)), $(Expr(:escape, :num2)))\n-        end)\n+    ccallfunction = :(ccall($(Expr(:escape, :((:func, libstring)))), $(Expr(:cconv, (:ccall, UInt16(0), false), 0)), $(Expr(:escape, :Cstring)), ($(Expr(:escape, :Cstring)), $(Expr(:escape, :Cint)), $(Expr(:escape, :Cint))), $(Expr(:escape, :str)), $(Expr(:escape, :num1)), $(Expr(:escape, :num2))))\n+    @test ccallmacro == ccallfunction\n \n     local fptr = :x\n-    @test_throws ArgumentError(\"interpolated function `fptr` was not a Ptr{Cvoid}, but Symbol\") @ccall $fptr()::Cvoid\n+    @test_throws TypeError @ccall $fptr()::Cvoid\n end\n \n @testset \"check error paths\" begin\n@@ -1777,7 +1783,7 @@ end\n     # no required args on varargs call\n     @test_throws ArgumentError(\"C ABI prohibits vararg without one required argument\") ccall_macro_parse(:( foo(; x::Cint)::Cint ))\n     # not a function pointer\n-    @test_throws ArgumentError(\"interpolated function `PROGRAM_FILE` was not a Ptr{Cvoid}, but String\") @ccall $PROGRAM_FILE(\"foo\"::Cstring)::Cvoid\n+    @test_throws TypeError @ccall $PROGRAM_FILE(\"foo\"::Cstring)::Cvoid\n end\n \n @testset \"check error path for @cfunction\" begin\n@@ -1834,10 +1840,6 @@ end\n end\n \n # issue #36458\n-compute_lib_name() = \"libcc\" * \"alltest\"\n-ccall_lazy_lib_name(x) = ccall((:testUcharX, compute_lib_name()), Int32, (UInt8,), x % UInt8)\n-@test ccall_lazy_lib_name(0) == 0\n-@test ccall_lazy_lib_name(3) == 1\n ccall_with_undefined_lib() = ccall((:time, xx_nOt_DeFiNeD_xx), Cint, (Ptr{Cvoid},), C_NULL)\n @test_throws UndefVarError(:xx_nOt_DeFiNeD_xx, @__MODULE__) ccall_with_undefined_lib()\n "
    }
  ]
}