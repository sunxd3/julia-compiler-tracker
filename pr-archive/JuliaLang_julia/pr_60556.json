{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60556",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60556/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60556/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60556/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60556",
  "id": 3783490450,
  "node_id": "PR_kwDOABkWpM67otvF",
  "number": 60556,
  "title": "Clean up testing of lowering errors",
  "user": {
    "login": "c42f",
    "id": 601473,
    "node_id": "MDQ6VXNlcjYwMTQ3Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/601473?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/c42f",
    "html_url": "https://github.com/c42f",
    "followers_url": "https://api.github.com/users/c42f/followers",
    "following_url": "https://api.github.com/users/c42f/following{/other_user}",
    "gists_url": "https://api.github.com/users/c42f/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/c42f/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/c42f/subscriptions",
    "organizations_url": "https://api.github.com/users/c42f/orgs",
    "repos_url": "https://api.github.com/users/c42f/repos",
    "events_url": "https://api.github.com/users/c42f/events{/privacy}",
    "received_events_url": "https://api.github.com/users/c42f/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2026-01-06T02:24:05Z",
  "updated_at": "2026-01-07T23:03:10Z",
  "closed_at": "2026-01-07T23:03:07Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60556",
    "html_url": "https://github.com/JuliaLang/julia/pull/60556",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60556.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60556.patch",
    "merged_at": "2026-01-07T23:03:07Z"
  },
  "body": "Introduce `@test_loweringerror` so that testing lowering errors is more systematic. This helps with porting the test suite to JuliaLowering especially if we have a transition period if we want syntax.jl tests to pass with both lowering implementations.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60556/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60556/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "4b9148fabffad9741fa5d948b93622e1a2977dfb",
      "filename": "test/syntax.jl",
      "status": "modified",
      "additions": 129,
      "deletions": 121,
      "changes": 250,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ba1485037413496f1574bde476ac894fa454d977/test%2Fsyntax.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ba1485037413496f1574bde476ac894fa454d977/test%2Fsyntax.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fsyntax.jl?ref=ba1485037413496f1574bde476ac894fa454d977",
      "patch": "@@ -18,6 +18,14 @@ macro test_parseerror(str, msg)\n     return ex\n end\n \n+macro test_loweringerror(ex, msg, opt=nothing)\n+    code = :(@test Meta.lower(@__MODULE__, $(esc(ex))) == Expr(:error, $msg))\n+    code.args[2] = __source__\n+    if opt === :broken\n+        code.args[1] = :var\"@test_broken\"\n+    end\n+end\n+\n macro test_parseerror(str)\n     ex = :(@test_throws Meta.ParseError Meta.parse($(esc(str))))\n     ex.args[2] = __source__\n@@ -343,14 +351,14 @@ end\n @test_parseerror(\"if false\\nelseif\\nend\", \"missing condition in \\\"elseif\\\" at none:2\")\n \n # issue #15828\n-@test Meta.lower(Main, Meta.parse(\"x...\")) == Expr(:error, \"\\\"...\\\" expression outside call\")\n+@test_loweringerror(Meta.parse(\"x...\"), \"\\\"...\\\" expression outside call\")\n \n # issue #57153 - malformed \"...\" expr\n-@test Meta.lower(@__MODULE__, :(identity($(Expr(:(...), 1, 2, 3))))) ==\n-    (Expr(:error, \"wrong number of expressions following \\\"...\\\"\"))\n+@test_loweringerror(:(identity($(Expr(:(...), 1, 2, 3)))),\n+                    \"wrong number of expressions following \\\"...\\\"\")\n \n # issue #15830\n-@test Meta.lower(Main, Meta.parse(\"foo(y = (global x)) = y\")) == Expr(:error, \"misplaced \\\"global\\\" declaration\")\n+@test_loweringerror(Meta.parse(\"foo(y = (global x)) = y\"), \"misplaced \\\"global\\\" declaration\")\n \n # Using the value of a `global` declaration is allowed, provided that value came\n # from something that isn't another `global` declaration:\n@@ -387,11 +395,14 @@ add_method_to_glob_fn!()\n @test_parseerror \"function finally() end\"\n \n # PR #16170\n-@test Meta.lower(Main, Meta.parse(\"true(x) = x\")) == Expr(:error, \"\\\"true\\\" is not a valid function argument name\")\n-@test Meta.lower(Main, Meta.parse(\"false(x) = x\")) == Expr(:error, \"\\\"false\\\" is not a valid function argument name\")\n+@test_loweringerror(Meta.parse(\"true(x) = x\"),\n+                    \"\\\"true\\\" is not a valid function argument name\")\n+@test_loweringerror(Meta.parse(\"false(x) = x\"),\n+                    \"\\\"false\\\" is not a valid function argument name\")\n \n # issue #16355\n-@test Meta.lower(Main, :(f(d:Int...) = nothing)) == Expr(:error, \"\\\"d:Int\\\" is not a valid function argument name\")\n+@test_loweringerror(:(f(d:Int...) = nothing),\n+                    \"\\\"d:Int\\\" is not a valid function argument name\")\n \n # issue #16517\n @test (try error(); catch; 0; end) === 0\n@@ -518,31 +529,31 @@ let m_error, error_out, filename = Base.source_path()\n end\n \n # issue #7272\n-@test Meta.lower(Main, Meta.parse(\"let\n-              global x = 2\n-              local x = 1\n-              end\")) == Expr(:error, \"variable \\\"x\\\" declared both local and global\")\n+@test_loweringerror(Meta.parse(\"\"\"\n+                        let\n+                            global x = 2\n+                            local x = 1\n+                        end\"\"\"), \"variable \\\"x\\\" declared both local and global\")\n #=\n-@test Meta.lower(Main, Meta.parse(\"let\n+@test_loweringerror(Meta.parse(\"let\n               local x = 2\n               local x = 1\n-              end\")) == Expr(:error, \"local \\\"x\\\" declared twice\")\n+              end\"), \"local \\\"x\\\" declared twice\")\n \n-@test Meta.lower(Main, Meta.parse(\"let x\n+@test_loweringerror(Meta.parse(\"let x\n                   local x = 1\n-              end\")) == Expr(:error, \"local \\\"x\\\" declared twice\")\n+              end\"), \"local \\\"x\\\" declared twice\")\n \n-@test Meta.lower(Main, Meta.parse(\"let x = 2\n+@test_loweringerror(Meta.parse(\"let x = 2\n                   local x = 1\n-              end\")) == Expr(:error, \"local \\\"x\\\" declared twice\")\n+              end\"), \"local \\\"x\\\" declared twice\")\n =#\n # issue #23673\n @test :(let $([:(x=1),:(y=2)]...); x+y end) == :(let x = 1, y = 2; x+y end)\n \n # make sure front end can correctly print values to error messages\n-let ex = Meta.lower(Main, Meta.parse(\"\\\"a\\\"=1\"))\n-    @test ex == Expr(:error, \"invalid assignment location \\\"\\\"a\\\"\\\"\")\n-end\n+@test_loweringerror(Meta.parse(\"\\\"a\\\"=1\"),\n+                    \"invalid assignment location \\\"\\\"a\\\"\\\"\")\n \n # make sure that incomplete tags are detected correctly\n # (i.e. error messages in src/julia-parser.scm must be matched correctly\n@@ -654,11 +665,11 @@ for op in [\"+\", \"-\", \"\\$\", \"|\", \".+\", \".-\", \"*\", \".*\"]\n end\n \n # issue #17701\n-@test Meta.lower(Main, :(i==3 && i+=1)) == Expr(:error, \"invalid assignment location \\\"(i == 3) && i\\\"\")\n+@test_loweringerror(:(i==3 && i+=1), \"invalid assignment location \\\"(i == 3) && i\\\"\")\n \n # issue #18667\n-@test Meta.lower(Main, :(true = 1)) == Expr(:error, \"invalid assignment location \\\"true\\\"\")\n-@test Meta.lower(Main, :(false = 1)) == Expr(:error, \"invalid assignment location \\\"false\\\"\")\n+@test_loweringerror(:(true = 1), \"invalid assignment location \\\"true\\\"\")\n+@test_loweringerror(:(false = 1), \"invalid assignment location \\\"false\\\"\")\n \n # PR #15592\n let str = \"[1] [2]\"\n@@ -887,8 +898,8 @@ end)(Tuple{Int8, Int16}) == Int16\n # issue #20541\n @test Meta.parse(\"[a .!b]\") == Expr(:hcat, :a, Expr(:call, :.!, :b))\n \n-@test Meta.lower(Main, :(a{1} = b)) == Expr(:error, \"invalid type parameter name \\\"1\\\"\")\n-@test Meta.lower(Main, :(a{2<:Any} = b)) == Expr(:error, \"invalid type parameter name \\\"2\\\"\")\n+@test_loweringerror(:(a{1} = b), \"invalid type parameter name \\\"1\\\"\")\n+@test_loweringerror(:(a{2<:Any} = b), \"invalid type parameter name \\\"2\\\"\")\n \n # issue #20653\n @test_throws UndefVarError Base.call(::Int) = 1\n@@ -910,13 +921,13 @@ macro m20729()\n end\n \n @test_throws ErrorException Core.eval(@__MODULE__, :(@m20729))\n-@test Meta.lower(@__MODULE__, :(@m20729)) == Expr(:error, \"undefined reference in AST\")\n+@test_loweringerror(:(@m20729), \"undefined reference in AST\")\n \n macro err20000()\n     return Expr(:error, \"oops!\")\n end\n \n-@test Meta.lower(@__MODULE__, :(@err20000)) == Expr(:error, \"oops!\")\n+@test_loweringerror(:(@err20000), \"oops!\")\n \n # issue #20000\n @test Meta.parse(\"@m(a; b=c)\") == Expr(:macrocall, Symbol(\"@m\"), LineNumberNode(1, :none),\n@@ -934,8 +945,9 @@ g21054(>:) = >:2\n @test g21054(-) == -2\n \n # issue #21168\n-@test_broken Meta.lower(Main, :(a.[1])) == Expr(:error, \"invalid syntax \\\"a.[1]\\\"\")\n-@test_broken Meta.lower(Main, :(a.{1})) == Expr(:error, \"invalid syntax \\\"a.{1}\\\"\")\n+@test_loweringerror(:(a.[1]), \"invalid syntax \\\"a.[1]\\\"\", broken)\n+@test_loweringerror(:(a.[1]), \"invalid syntax \\\"a.[1]\\\"\", broken)\n+@test_loweringerror(:(a.{1}), \"invalid syntax \\\"a.{1}\\\"\", broken)\n \n # Issue #21225\n let abstr = Meta.parse(\"abstract type X end\")\n@@ -1045,8 +1057,8 @@ module Test21607\n end\n \n # issue #16937\n-@test Meta.lower(Main, :(f(2, a=1, w=3, c=3, w=4, b=2))) ==\n-    Expr(:error, \"keyword argument \\\"w\\\" repeated in call to \\\"f\\\"\")\n+@test_loweringerror(:(f(2, a=1, w=3, c=3, w=4, b=2)),\n+                    \"keyword argument \\\"w\\\" repeated in call to \\\"f\\\"\")\n \n let f(x) =\n       g(x) = 1\n@@ -1098,10 +1110,10 @@ end\n @test_parseerror \"@ time\"\n \n # issue #7479\n-@test Meta.lower(Main, Meta.parse(\"(true &&& false)\")) == Expr(:error, \"invalid syntax &false\")\n+@test_loweringerror(Meta.parse(\"(true &&& false)\"), \"invalid syntax &false\")\n \n # issue #34748\n-@test Meta.lower(Main, :(&(1, 2))) == Expr(:error, \"invalid syntax &(1, 2)\")\n+@test_loweringerror(:(&(1, 2)), \"invalid syntax &(1, 2)\")\n \n # if an indexing expression becomes a cat expression, `end` is not special\n @test_parseerror \"a[end end]\"\n@@ -1143,12 +1155,15 @@ let\n end\n \n # issue #18730\n-@test Meta.lower(Main, quote\n+@test_loweringerror(\n+    quote\n         function f()\n             local Int\n             x::Int -> 2\n         end\n-    end) == Expr(:error, \"local variable Int cannot be used in closure declaration\")\n+    end,\n+    \"local variable Int cannot be used in closure declaration\"\n+)\n \n # some issues with backquote\n # preserve QuoteNode and LineNumberNode\n@@ -1206,11 +1221,11 @@ M24289.@m24289\n \n # misplaced top-level expressions\n @test_throws ErrorException(\"syntax: \\\"\\$\\\" expression outside quote\") Core.eval(@__MODULE__, Meta.parse(\"x->\\$x\"))\n-@test Meta.lower(@__MODULE__, Expr(:$, :x)) == Expr(:error, \"\\\"\\$\\\" expression outside quote\")\n-@test Meta.lower(@__MODULE__, :(x->import Foo)) == Expr(:error, \"\\\"import\\\" expression not at top level\")\n-@test Meta.lower(@__MODULE__, :(x->module Foo end)) == Expr(:error, \"\\\"module\\\" expression not at top level\")\n-@test Meta.lower(@__MODULE__, :(x->struct Foo end)) == Expr(:error, \"\\\"struct\\\" expression not at top level\")\n-@test Meta.lower(@__MODULE__, :(x->abstract type Foo end)) == Expr(:error, \"\\\"abstract type\\\" expression not at top level\")\n+@test_loweringerror(Expr(:$, :x), \"\\\"\\$\\\" expression outside quote\")\n+@test_loweringerror(:(x->import Foo), \"\\\"import\\\" expression not at top level\")\n+@test_loweringerror(:(x->module Foo end), \"\\\"module\\\" expression not at top level\")\n+@test_loweringerror(:(x->struct Foo end), \"\\\"struct\\\" expression not at top level\")\n+@test_loweringerror(:(x->abstract type Foo end), \"\\\"abstract type\\\" expression not at top level\")\n \n # caused by #24538. forms that lower to `call` should wrap with `call` before\n # recursively calling expand-forms.\n@@ -1269,7 +1284,7 @@ end\n                  \"expected \\\"]\\\" or separator in arguments to \\\"[ ]\\\"; got \\\"1)\\\"\")\n \n # issue #9972\n-@test Meta.lower(@__MODULE__, :(f(;3))) == Expr(:error, \"invalid keyword argument syntax \\\"3\\\"\")\n+@test_loweringerror(:(f(;3)), \"invalid keyword argument syntax \\\"3\\\"\")\n \n # issue #25055, make sure quote makes new Exprs\n function f25055()\n@@ -1433,57 +1448,49 @@ end\n # Module name cannot be a reserved word.\n @test_parseerror \"module module end\"\n \n-@test Meta.lower(@__MODULE__, :(global true)) == Expr(:error, \"invalid syntax in \\\"global\\\" declaration\")\n-@test Meta.lower(@__MODULE__, :(let ccall end)) == Expr(:error, \"invalid identifier name \\\"ccall\\\"\")\n-@test Meta.lower(@__MODULE__, :(cglobal = 0)) == Expr(:error, \"invalid assignment location \\\"cglobal\\\"\")\n+@test_loweringerror(:(global true), \"invalid syntax in \\\"global\\\" declaration\")\n+@test_loweringerror(:(let ccall end), \"invalid identifier name \\\"ccall\\\"\")\n+@test_loweringerror(:(cglobal = 0), \"invalid assignment location \\\"cglobal\\\"\")\n \n # issue #26507\n @test Meta.parse(\"@try x\") == Expr(:macrocall, Symbol(\"@try\"), LineNumberNode(1,:none), :x)\n @test Meta.parse(\"@catch x\") == Expr(:macrocall, Symbol(\"@catch\"), LineNumberNode(1,:none), :x)\n @test Meta.parse(\"@\\$x\") == Expr(:macrocall, Symbol(\"@\\$\"), LineNumberNode(1,:none), :x)\n \n # issue #26717\n-@test Meta.lower(@__MODULE__, :( :(:) = 2 )) == Expr(:error, \"invalid assignment location \\\":(:)\\\"\")\n+@test_loweringerror(:( :(:) = 2 ), \"invalid assignment location \\\":(:)\\\"\")\n \n # issue #27690\n # previously, this was allowed since it thought `end` was being used for indexing.\n # however the quote should disable that context.\n @test_parseerror \"Any[:(end)]\"\n \n # issue #17781\n-let ex = Meta.lower(@__MODULE__, Meta.parse(\"\n+@test_loweringerror(Meta.parse(\"\n     A = function (s, o...)\n         f(a, b) do\n         end\n     end,\n     B = function (s, o...)\n         f(a, b) do\n         end\n-    end\"))\n-    @test isa(ex, Expr) && ex.head === :error\n-    @test ex.args[1] == \"\"\"\n+    end\"), \"\"\"\n invalid assignment location \"function (s, o...)\n     # none, line 2\n     # none, line 3\n     f(a, b) do\n         # none, line 4\n     end\n-end\\\"\"\"\"\n-end\n-\n-let ex = Meta.lower(@__MODULE__, :(function g end = 1))\n-    @test isa(ex, Expr) && ex.head === :error\n-    @test ex.args[1] == \"\"\"\n-invalid assignment location \"function g\n-end\\\"\"\"\"\n-end\n+end\\\"\"\"\")\n \n+@test_loweringerror(:(function g end = 1),\n+                    \"invalid assignment location \\\"function g\\nend\\\"\")\n \n # issue #15229\n-@test Meta.lower(@__MODULE__, :(function f(x); local x; 0; end)) ==\n-    Expr(:error, \"local variable name \\\"x\\\" conflicts with an argument\")\n-@test Meta.lower(@__MODULE__, :(function f(x); begin; local x; 0; end; end)) ==\n-    Expr(:error, \"local variable name \\\"x\\\" conflicts with an argument\")\n+@test_loweringerror(:(function f(x); local x; 0; end),\n+                    \"local variable name \\\"x\\\" conflicts with an argument\")\n+@test_loweringerror(:(function f(x); begin; local x; 0; end; end),\n+                    \"local variable name \\\"x\\\" conflicts with an argument\")\n \n # issue #27964\n a27964(x) = Any[x for x in []]\n@@ -1523,17 +1530,17 @@ catch e\n     @test e.error isa MethodError\n end\n \n-@test Meta.lower(@__MODULE__, :(if true; break; end for i = 1:1)) == Expr(:error, \"break or continue outside loop\")\n-@test Meta.lower(@__MODULE__, :([if true; break; end for i = 1:1])) == Expr(:error, \"break or continue outside loop\")\n-@test Meta.lower(@__MODULE__, :(Int[if true; break; end for i = 1:1])) == Expr(:error, \"break or continue outside loop\")\n-@test Meta.lower(@__MODULE__, :([if true; continue; end for i = 1:1])) == Expr(:error, \"break or continue outside loop\")\n-@test Meta.lower(@__MODULE__, :(Int[if true; continue; end for i = 1:1])) == Expr(:error, \"break or continue outside loop\")\n+@test_loweringerror(:(if true; break; end for i = 1:1), \"break or continue outside loop\")\n+@test_loweringerror(:([if true; break; end for i = 1:1]), \"break or continue outside loop\")\n+@test_loweringerror(:(Int[if true; break; end for i = 1:1]), \"break or continue outside loop\")\n+@test_loweringerror(:([if true; continue; end for i = 1:1]), \"break or continue outside loop\")\n+@test_loweringerror(:(Int[if true; continue; end for i = 1:1]), \"break or continue outside loop\")\n \n-@test Meta.lower(@__MODULE__, :(return 0 for i=1:2)) == Expr(:error, \"\\\"return\\\" not allowed inside comprehension or generator\")\n-@test Meta.lower(@__MODULE__, :([ return 0 for i=1:2 ])) == Expr(:error, \"\\\"return\\\" not allowed inside comprehension or generator\")\n-@test Meta.lower(@__MODULE__, :(Int[ return 0 for i=1:2 ])) == Expr(:error, \"\\\"return\\\" not allowed inside comprehension or generator\")\n-@test Meta.lower(@__MODULE__, :([ $(Expr(:thisfunction)) for i=1:2 ])) == Expr(:error, \"\\\"@__FUNCTION__\\\" not allowed inside comprehension or generator\")\n-@test Meta.lower(@__MODULE__, :($(Expr(:thisfunction)) for i=1:2)) == Expr(:error, \"\\\"@__FUNCTION__\\\" not allowed inside comprehension or generator\")\n+@test_loweringerror(:(return 0 for i=1:2), \"\\\"return\\\" not allowed inside comprehension or generator\")\n+@test_loweringerror(:([ return 0 for i=1:2 ]), \"\\\"return\\\" not allowed inside comprehension or generator\")\n+@test_loweringerror(:(Int[ return 0 for i=1:2 ]), \"\\\"return\\\" not allowed inside comprehension or generator\")\n+@test_loweringerror(:([ $(Expr(:thisfunction)) for i=1:2 ]), \"\\\"@__FUNCTION__\\\" not allowed inside comprehension or generator\")\n+@test_loweringerror(:($(Expr(:thisfunction)) for i=1:2), \"\\\"@__FUNCTION__\\\" not allowed inside comprehension or generator\")\n @test [ ()->return 42 for i = 1:1 ][1]() == 42\n @test Function[ identity() do x; return 2x; end for i = 1:1 ][1](21) == 42\n @test @eval let f=[ ()->$(Expr(:thisfunction)) for i = 1:1 ][1]; f() === f; end\n@@ -1635,20 +1642,20 @@ end\n @test A27807.@m()(1,1.0) === (1, 0.0)\n \n # issue #27896 / #29429\n-@test Meta.lower(@__MODULE__, quote\n+@test_loweringerror(quote\n     function foo(a::A, b::B) where {A,B}\n         B = eltype(A)\n         return convert(B, b)\n     end\n-end) == Expr(:error, \"local variable name \\\"B\\\" conflicts with a static parameter\")\n+end, \"local variable name \\\"B\\\" conflicts with a static parameter\")\n # issue #32620\n-@test Meta.lower(@__MODULE__, quote\n+@test_loweringerror(quote\n     function foo(a::T) where {T}\n         for i = 1:1\n             T = 0\n         end\n     end\n-end) == Expr(:error, \"local variable name \\\"T\\\" conflicts with a static parameter\")\n+end, \"local variable name \\\"T\\\" conflicts with a static parameter\")\n function f32620(x::T) where T\n     local y\n     let T = 3\n@@ -1678,7 +1685,7 @@ macro foo28244(sym)\n end\n @test @macroexpand(@foo28244(kw)) == Expr(:call, :bar, Expr(:kw))\n let x = @macroexpand @foo28244(var\"let\")\n-    @test Meta.lower(@__MODULE__, x) == Expr(:error, \"malformed expression\")\n+    @test_loweringerror(x, \"malformed expression\")\n end\n \n # #16356\n@@ -1731,18 +1738,18 @@ end\n @test M22314.i == 0\n \n # #6080\n-@test Meta.lower(@__MODULE__, :(ccall(:a, Cvoid, (Cint,), &x))) == Expr(:error, \"invalid syntax &x\")\n+@test_loweringerror(:(ccall(:a, Cvoid, (Cint,), &x)), \"invalid syntax &x\")\n \n-@test Meta.lower(@__MODULE__, :(f(x) = (y = x + 1; ccall((:a, y), Cvoid, ())))) == Expr(:error, \"ccall function name and library expression cannot reference local variables\")\n+@test_loweringerror(:(f(x) = (y = x + 1; ccall((:a, y), Cvoid, ()))), \"ccall function name and library expression cannot reference local variables\")\n \n @test_parseerror \"x.'\"\n @test_parseerror \"0.+1\"\n \n # #24221\n-@test Meta.isexpr(Meta.lower(@__MODULE__, :(a=_)), :error)\n+@test_loweringerror(:(a=_), \"all-underscore identifiers are write-only and their values cannot be used in expressions\")\n \n for ex in [:([x=1]), :(T{x=1})]\n-    @test Meta.lower(@__MODULE__, ex) == Expr(:error, string(\"misplaced assignment statement in \\\"\", ex, \"\\\"\"))\n+    @test_loweringerror(ex, \"misplaced assignment statement in \\\"$ex\\\"\")\n end\n \n # issue #28576\n@@ -1893,10 +1900,8 @@ end\n @test_throws LoadError include_string(@__MODULE__, \"1,\\n\")\n \n # issue #30062\n-let er = Meta.lower(@__MODULE__, quote if false end, b+=2 end)\n-    @test Meta.isexpr(er, :error)\n-    @test startswith(er.args[1], \"invalid multiple assignment location \\\"if\")\n-end\n+@test_loweringerror(Base.remove_linenums!(quote if false end, b+=2 end),\n+                    \"invalid multiple assignment location \\\"if false\\nend\\\"\")\n \n # issue #30030\n let x = 0\n@@ -1981,11 +1986,11 @@ f31404(a, b; kws...) = (a, b, values(kws))\n # issue #28992\n macro id28992(x) x end\n @test @id28992(1 .+ 2) == 3\n-@test Meta.@lower(.+(a,b) = 0) == Expr(:error, \"invalid function name \\\".+\\\"\")\n-@test Meta.@lower((.+)(a,b) = 0) == Expr(:error, \"invalid function name \\\"(.+)\\\"\")\n+@test_loweringerror(:(.+(a,b) = 0), \"invalid function name \\\".+\\\"\")\n+@test_loweringerror(:((.+)(a,b) = 0), \"invalid function name \\\"(.+)\\\"\")\n let m = @__MODULE__\n-    @test Meta.lower(m, :($m.@id28992(.+(a,b) = 0))) == Expr(:error, \"invalid function name \\\"$(nameof(m)).:.+\\\" around $(@__FILE__):$(@__LINE__)\")\n-    @test Meta.lower(m, :($m.@id28992((.+)(a,b) = 0))) == Expr(:error, \"invalid function name \\\"(.$(nameof(m)).+)\\\" around $(@__FILE__):$(@__LINE__)\")\n+    @test_loweringerror(:($m.@id28992(.+(a,b) = 0)), \"invalid function name \\\"$(nameof(m)).:.+\\\" around $(@__FILE__):$(@__LINE__)\")\n+    @test_loweringerror(:($m.@id28992((.+)(a,b) = 0)), \"invalid function name \\\"(.$(nameof(m)).+)\\\" around $(@__FILE__):$(@__LINE__)\")\n end\n @test @id28992([1] .< [2] .< [3]) == [true]\n @test @id28992(2 ^ -2) == 0.25\n@@ -2008,8 +2013,10 @@ let\n end\n @test a32325(0) === a32325()\n \n-@test Meta.lower(Main, :(struct A; A() = new{Int}(); end)) == Expr(:error, \"too many type parameters specified in \\\"new{...}\\\"\")\n-@test Meta.lower(Main, :(struct A{T, S}; A() = new{Int}(); end)) == Expr(:error, \"too few type parameters specified in \\\"new{...}\\\"\")\n+@test_loweringerror(:(struct A; A() = new{Int}(); end),\n+                    \"too many type parameters specified in \\\"new{...}\\\"\")\n+@test_loweringerror(:(struct A{T, S}; A() = new{Int}(); end),\n+                    \"too few type parameters specified in \\\"new{...}\\\"\")\n \n # issue #32467\n let f = identity(identity() do\n@@ -2072,14 +2079,14 @@ end\n @test Meta.isexpr(Meta.lower(Main, :((@label a; @goto a))), :thunk)\n \n # issue #33250\n-@test Meta.lower(Main, :(f(b=b...))) == Expr(:error, \"\\\"...\\\" expression cannot be used as keyword argument value\")\n-@test Meta.lower(Main, :(f(;a=a,b=b...))) == Expr(:error, \"\\\"...\\\" expression cannot be used as keyword argument value\")\n-@test Meta.lower(Main, :((a=a,b=b...))) == Expr(:error, \"\\\"...\\\" expression cannot be used as named tuple field value\")\n-@test Meta.lower(Main, :(f(;a...,b...)=0)) == Expr(:error, \"invalid \\\"...\\\" on non-final keyword argument\")\n-@test Meta.lower(Main, :(f(;a...,b=0)=0)) == Expr(:error, \"invalid \\\"...\\\" on non-final keyword argument\")\n+@test_loweringerror(:(f(b=b...)), \"\\\"...\\\" expression cannot be used as keyword argument value\")\n+@test_loweringerror(:(f(;a=a,b=b...)), \"\\\"...\\\" expression cannot be used as keyword argument value\")\n+@test_loweringerror(:((a=a,b=b...)), \"\\\"...\\\" expression cannot be used as named tuple field value\")\n+@test_loweringerror(:(f(;a...,b...)=0), \"invalid \\\"...\\\" on non-final keyword argument\")\n+@test_loweringerror(:(f(;a...,b=0)=0), \"invalid \\\"...\\\" on non-final keyword argument\")\n \n # issue #31547\n-@test Meta.lower(Main, :(a := 1)) == Expr(:error, \"unsupported assignment operator \\\":=\\\"\")\n+@test_loweringerror(:(a := 1), \"unsupported assignment operator \\\":=\\\"\")\n \n # issue #33841\n let a(; b) = b\n@@ -2342,9 +2349,6 @@ end\n         @test Meta.isexpr(Meta.parse(\"$imprt A, B\"), imprt)\n         @test Meta.isexpr(Meta.parse(\"$imprt A: x, y, z\"), imprt)\n \n-        err = Expr(\n-            :error,\n-        )\n         @test_parseerror(\"$imprt A, B: x, y\",\n                          \"\\\":\\\" in \\\"$imprt\\\" syntax can only be used when importing a single module. Split imports into multiple lines.\")\n         @test_parseerror(\"$imprt A: x, B: y\",\n@@ -2353,14 +2357,14 @@ end\n end\n \n # Syntax desugaring pass errors contain line numbers\n-@test Meta.lower(@__MODULE__, Expr(:block, LineNumberNode(101, :some_file), :(f(x,x)=1))) ==\n-    Expr(:error, \"function argument name not unique: \\\"x\\\" around some_file:101\")\n+@test_loweringerror(Expr(:block, LineNumberNode(101, :some_file), :(f(x,x)=1)),\n+                    \"function argument name not unique: \\\"x\\\" around some_file:101\")\n \n-@test Meta.lower(@__MODULE__, Expr(:block, LineNumberNode(102, :some_file), :(function f(x) where T where T; x::T; end))) ==\n-    Expr(:error, \"function static parameter name not unique: \\\"T\\\" around some_file:102\")\n+@test_loweringerror(Expr(:block, LineNumberNode(102, :some_file), :(function f(x) where T where T; x::T; end)),\n+                    \"function static parameter name not unique: \\\"T\\\" around some_file:102\")\n \n-@test Meta.lower(@__MODULE__, Expr(:block, LineNumberNode(103, :some_file), :(function f(t) where t; x; end))) ==\n-    Expr(:error, \"function argument and static parameter name not distinct: \\\"t\\\" around some_file:103\")\n+@test_loweringerror(Expr(:block, LineNumberNode(103, :some_file), :(function f(t) where t; x; end)),\n+                    \"function argument and static parameter name not distinct: \\\"t\\\" around some_file:103\")\n \n # Ensure file names don't leak between `eval`s\n eval(LineNumberNode(11, :incorrect_file))\n@@ -2445,20 +2449,22 @@ end\n @test !@isdefined(_x_this_remains_undefined)\n \n module GlobalContainment\n+import ..@test_loweringerror\n using Test\n @testset \"scope of global declarations\" begin\n \n     # global declarations from the top level are not inherited by functions.\n     # don't allow such a declaration to override an outer local, since it's not\n     # clear what it should do.\n-    @test Meta.lower(\n-        Main,\n+    @test_loweringerror(\n         :(let\n               x = 1\n               let\n                   global x\n               end\n-          end)) == Expr(:error, \"`global x`: x is a local variable in its enclosing scope\")\n+          end),\n+        \"`global x`: x is a local variable in its enclosing scope\"\n+    )\n \n     # a declared global can shadow a local in an outer scope\n     @test let\n@@ -2892,13 +2898,13 @@ end\n end\n \n @testset \"issue #33460\" begin\n-    err = Expr(:error, \"more than one semicolon in argument list\")\n-    @test Meta.lower(Main, :(f(a; b=1; c=2) = 2))  == err\n-    @test Meta.lower(Main, :(f( ; b=1; c=2)))      == err\n-    @test Meta.lower(Main, :(f(a; b=1; c=2)))      == err\n-    @test Meta.lower(Main, :(f(a; b=1, c=2; d=3))) == err\n-    @test Meta.lower(Main, :(f(a; b=1; c=2, d=3))) == err\n-    @test Meta.lower(Main, :(f(a; b=1; c=2; d=3))) == err\n+    err = \"more than one semicolon in argument list\"\n+    @test_loweringerror(:(f(a; b=1; c=2) = 2),  err)\n+    @test_loweringerror(:(f( ; b=1; c=2)),      err)\n+    @test_loweringerror(:(f(a; b=1; c=2)),      err)\n+    @test_loweringerror(:(f(a; b=1, c=2; d=3)), err)\n+    @test_loweringerror(:(f(a; b=1; c=2, d=3)), err)\n+    @test_loweringerror(:(f(a; b=1; c=2; d=3)), err)\n end\n \n @test eval(Expr(:if, Expr(:block, Expr(:&&, true, Expr(:call, :(===), 1, 1))), 1, 2)) == 1\n@@ -3052,9 +3058,9 @@ Base.dotgetproperty(::A, ::Symbol) = [0, 0, 0]\n     @test b == [1, 2, 3]\n end\n \n-@test Meta.@lower((::T) = x) == Expr(:error, \"invalid assignment location \\\"::T\\\"\")\n-@test Meta.@lower((::T,) = x) == Expr(:error, \"invalid assignment location \\\"::T\\\"\")\n-@test Meta.@lower((; ::T) = x) == Expr(:error, \"invalid assignment location \\\"::T\\\"\")\n+@test_loweringerror(:((::T) = x), \"invalid assignment location \\\"::T\\\"\")\n+@test_loweringerror(:((::T,) = x), \"invalid assignment location \\\"::T\\\"\")\n+@test_loweringerror(:((; ::T) = x), \"invalid assignment location \\\"::T\\\"\")\n \n # flisp conversion for quoted SSAValues\n @test eval(:(x = $(QuoteNode(Core.SSAValue(1))))) == Core.SSAValue(1)\n@@ -3609,8 +3615,10 @@ f45162_2(f) = f([]...)\n @test_parseerror \"const x::Int\" \"expected assignment after \\\"const\\\"\"\n # these cases have always been caught during lowering, since (const (global x)) is not\n # ambiguous with the lowered form (const x), but that could probably be changed.\n-@test Meta.lower(@__MODULE__, Expr(:const, Expr(:global, :x))) == Expr(:error, \"expected assignment after \\\"const\\\"\")\n-@test Meta.lower(@__MODULE__, Expr(:const, Expr(:global, Expr(:(::), :x, :Int)))) == Expr(:error, \"expected assignment after \\\"const\\\"\")\n+@test_loweringerror(Expr(:const, Expr(:global, :x)),\n+                    \"expected assignment after \\\"const\\\"\")\n+@test_loweringerror(Expr(:const, Expr(:global, Expr(:(::), :x, :Int))),\n+                    \"expected assignment after \\\"const\\\"\")\n \n @testset \"issue 25072\" begin\n     @test '\\xc0\\x80' == reinterpret(Char, 0xc0800000)"
    }
  ]
}