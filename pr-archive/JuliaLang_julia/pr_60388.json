{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60388",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60388/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60388/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60388/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60388",
  "id": 3732155282,
  "node_id": "PR_kwDOABkWpM65A9og",
  "number": 60388,
  "title": "codegen: improve codegen size layout of on-stack format for pointer-ful types",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 183231688,
      "node_id": "MDU6TGFiZWwxODMyMzE2ODg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:codegen",
      "name": "compiler:codegen",
      "color": "d4c5f9",
      "default": false,
      "description": "Generation of LLVM IR and native code"
    },
    {
      "id": 4232017300,
      "node_id": "LA_kwDOABkWpM78P3WU",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/don't%20squash",
      "name": "don't squash",
      "color": "ff4500",
      "default": false,
      "description": "Don't squash merge"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 4,
  "created_at": "2025-12-15T21:17:07Z",
  "updated_at": "2025-12-31T05:36:35Z",
  "closed_at": "2025-12-17T15:22:29Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60388",
    "html_url": "https://github.com/JuliaLang/julia/pull/60388",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60388.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60388.patch",
    "merged_at": "2025-12-17T15:22:28Z"
  },
  "body": "This makes a few related improvements to on-stack struct layout:\r\n - Declaring that the on-stack format is the same layout as the on-heap format, allowing more zero-copy uses (esp of arguments)\r\n - Removing trailing pointers from the on-stack format, since they don't change the pointer or layout\r\n - Lazily load roots from where they already live on the stack in some frame. This is particularly impactful when calling a method and just forwarding the arguments, as it avoids an intermediate stack copy.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60388/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60388/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "c1fa6f58ba7d3fc84fc0dc6a7a1e0f0370a39c49",
      "filename": "src/cgutils.cpp",
      "status": "modified",
      "additions": 105,
      "deletions": 117,
      "changes": 222,
      "blob_url": "https://github.com/JuliaLang/julia/blob/28e922e1e55bcb9e6b7e818f34105aba4567f68c/src%2Fcgutils.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/28e922e1e55bcb9e6b7e818f34105aba4567f68c/src%2Fcgutils.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcgutils.cpp?ref=28e922e1e55bcb9e6b7e818f34105aba4567f68c",
      "patch": "@@ -78,7 +78,6 @@ static Value *decay_derived(jl_codectx_t &ctx, Value *V)\n     Type *T = V->getType();\n     if (T->getPointerAddressSpace() == AddressSpace::Derived)\n         return V;\n-    // Once llvm deletes pointer element types, we won't need it here any more either.\n     Type *NewT = PointerType::get(T->getContext(), AddressSpace::Derived);\n     return ctx.builder.CreateAddrSpaceCast(V, NewT);\n }\n@@ -493,7 +492,10 @@ static llvm::SmallVector<Value*,0> extract_gc_roots(jl_codectx_t &ctx, const jl_\n     SmallVector<Value*,0> gcroots;\n     if (npointers) {\n         if (!val.inline_roots.empty()) {\n-            gcroots = val.inline_roots;\n+            const jl_gc_roots_t &roots_copy = val.inline_roots;\n+            gcroots.resize(roots_copy.size());\n+            for (size_t i = 0; i < roots_copy.size(); i++)\n+                gcroots[i] = roots_copy.get(ctx, i);\n         }\n         else if (val.ispointer()) {\n             Type *T_prjlvalue = ctx.types().T_prjlvalue;\n@@ -519,20 +521,11 @@ static llvm::SmallVector<Value*,0> extract_gc_roots(jl_codectx_t &ctx, const jl_\n }\n \n \n-// load a pointer to N inlined_roots into registers (as a SmallVector)\n-static llvm::SmallVector<Value*,0> load_gc_roots(jl_codectx_t &ctx, Value *inline_roots_ptr, size_t npointers, MDNode *tbaa, bool isVolatile=false)\n+static jl_gc_roots_t make_lazy_gc_roots(Value *inline_roots_ptr, size_t npointers, MDNode *tbaa)\n {\n-    SmallVector<Value*,0> gcroots(npointers);\n-    if (npointers) {\n-        Type *T_prjlvalue = ctx.types().T_prjlvalue;\n-        auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-        for (size_t i = 0; i < npointers; i++) {\n-            LoadInst *ptr = ctx.builder.CreateAlignedLoad(T_prjlvalue, emit_ptrgep(ctx, inline_roots_ptr, i * sizeof(jl_value_t*)), Align(sizeof(void*)), isVolatile);\n-            roots_ai.decorateInst(ptr);\n-            gcroots[i] = ptr;\n-        }\n-    }\n-    return gcroots;\n+    if (npointers == 0)\n+        return jl_gc_roots_t();\n+    return jl_gc_roots_t(inline_roots_ptr, npointers, tbaa);\n }\n \n // inlined bool indicates whether this must return the inlined roots inside x separately, or whether x itself may be used as the root (if x is already isboxed)\n@@ -549,7 +542,12 @@ static llvm::SmallVector<Value*,0> get_gc_roots_for(jl_codectx_t &ctx, const jl_\n         //     find_perm_offsets(typ, perm_offsets, 0);\n         //     return filter(!in(perm_offsets), x.inline_roots)\n         // }\n-        return x.inline_roots;\n+        // Copy and load roots via get()\n+        const jl_gc_roots_t &roots_copy = x.inline_roots;\n+        SmallVector<Value*,0> result(roots_copy.size());\n+        for (size_t i = 0; i < roots_copy.size(); i++)\n+            result[i] = roots_copy.get(ctx, i);\n+        return result;\n     }\n     if (!inlined && x.ispointer()) {\n         assert(x.V);\n@@ -1206,32 +1204,27 @@ static void emit_memcpy(jl_codectx_t &ctx, Value *dst, jl_aliasinfo_t const &dst\n static std::pair<size_t,size_t> split_value_size(jl_datatype_t *typ)\n {\n     assert(jl_is_datatype(typ));\n-    size_t dst_off = 0;\n     bool hasptr = typ->layout->first_ptr >= 0;\n     size_t npointers = hasptr ? typ->layout->npointers : 0;\n-    // drop the data pointer if the entire structure is just pointers\n-    // n.b.: eventually we could sometimes drop the slots for the pointers from inside the\n-    //       types to pack it together, but this can change the alignment of the bits\n-    //       in the fields inside, even if those bits have no pointers themselves. So\n-    //       we would actually need to compute, for each pointer, whether any\n-    //       subsequent field needed the extra alignment (for example, we can\n-    //       drop space for any runs of two/four pointer). But it would also\n-    //       require always copying the type, and not just extracting the\n-    //       inline_roots, which can be challenging and inefficient for the type\n-    //       to have multiple representations (even though more compact).\n-    bool nodata = allpointers(typ);\n-    if (nodata)\n-        dst_off = 0;\n-    else\n-        dst_off = jl_datatype_size(typ);\n-    return std::make_pair(dst_off, npointers);\n+    // shrink wrap away trailing pointers (but not interior pointers, which\n+    // would change alignment of fields containing non-pointer data)\n+    size_t size = jl_datatype_size(typ);\n+    for (ssize_t i = npointers - 1; i >= 0; i--) {\n+        size_t ptr_end = jl_ptr_offset(typ, i) * sizeof(void*) + sizeof(void*);\n+        if (ptr_end == size) {\n+            size = jl_ptr_offset(typ, i) * sizeof(void*);\n+        } else {\n+            break;\n+        }\n+    }\n+    return std::make_pair(size, npointers);\n }\n \n-static void store_all_roots(jl_codectx_t &ctx, ArrayRef<Value*> inline_roots, Value *inline_roots_ptr, jl_aliasinfo_t const &roots_ai, bool isVolatileStore)\n+static void store_all_roots(jl_codectx_t &ctx, const jl_gc_roots_t &inline_roots, Value *inline_roots_ptr, jl_aliasinfo_t const &roots_ai, bool isVolatileStore)\n {\n     // TODO: often we could skip stores of NULL\n     for (size_t i = 0; i < inline_roots.size(); i++) {\n-        Value *unbox = inline_roots[i];\n+        Value *unbox = inline_roots.get(ctx, i);\n         roots_ai.decorateInst(ctx.builder.CreateAlignedStore(unbox, emit_ptrgep(ctx, inline_roots_ptr, i * sizeof(void*)), Align(sizeof(void*)), isVolatileStore));\n     }\n }\n@@ -1253,32 +1246,32 @@ static void split_value_into(jl_codectx_t &ctx, const jl_cgval_t &x, Align align\n         auto sizes = split_value_size(typ);\n         if (sizes.first > 0)\n             emit_memcpy(ctx, dst, dst_ai, x.V, src_ai, sizes.first, align_dst, align_src, isVolatileStore);\n-        store_all_roots(ctx, ArrayRef(x.inline_roots).slice(0, sizes.second), inline_roots_ptr, roots_ai, isVolatileStore);\n+        assert(x.inline_roots.size() <= sizes.second);\n+        store_all_roots(ctx, x.inline_roots, inline_roots_ptr, roots_ai, isVolatileStore);\n         return;\n     }\n     if (x.V == nullptr && x.constant == nullptr)\n         return;\n     Value *src = data_pointer(ctx, value_to_pointer(ctx, x));\n     bool isstack = isa<AllocaInst>(src->stripInBoundsOffsets()) || src_ai.tbaa == ctx.tbaa().tbaa_stack;\n-    size_t dst_off = 0;\n-    size_t src_off = 0;\n     bool hasptr = typ->layout->first_ptr >= 0;\n     size_t npointers = hasptr ? typ->layout->npointers : 0;\n-    bool nodata = allpointers(typ);\n+    size_t shrunken_size = split_value_size(typ).first;\n+    size_t off = 0;\n     for (size_t i = 0; true; i++) {\n         bool last = i == npointers;\n         size_t ptr = last ? jl_datatype_size(typ) : (jl_ptr_offset(typ, i) * sizeof(void*));\n-        if (ptr > src_off) {\n+        if (ptr > off) {\n+            assert(off < shrunken_size && ptr <= shrunken_size);\n             emit_memcpy(ctx,\n-                emit_ptrgep(ctx, dst, dst_off),\n+                emit_ptrgep(ctx, dst, off),\n                 dst_ai,\n-                emit_ptrgep(ctx, src, src_off),\n+                emit_ptrgep(ctx, src, off),\n                 src_ai,\n-                ptr - src_off,\n+                ptr - off,\n                 align_dst,\n                 align_src,\n                 isVolatileStore);\n-            dst_off += ptr - src_off;\n         }\n         if (last)\n             break;\n@@ -1288,16 +1281,14 @@ static void split_value_into(jl_codectx_t &ctx, const jl_cgval_t &x, Align align\n         src_ai.decorateInst(load);\n         roots_ai.decorateInst(ctx.builder.CreateAlignedStore(load, emit_ptrgep(ctx, inline_roots_ptr, i * sizeof(void*)), Align(sizeof(void*)), isVolatileStore));\n         align_src = align_dst = Align(sizeof(void*));\n-        src_off = ptr + sizeof(void*);\n-        if (!nodata) {\n+        off = ptr + sizeof(void*);\n+        if (off < shrunken_size) {\n             // store an undef pointer here, to make sure nobody looks at this\n             dst_ai.decorateInst(ctx.builder.CreateAlignedStore(\n                 ctx.builder.getIntN(sizeof(void*) * 8, (uint64_t)-1),\n-                emit_ptrgep(ctx, dst, dst_off),\n-                align_src,\n+                emit_ptrgep(ctx, dst, ptr),\n+                Align(sizeof(void*)),\n                 isVolatileStore));\n-            dst_off += sizeof(void*);\n-            assert(dst_off == src_off);\n         }\n     }\n }\n@@ -1318,89 +1309,83 @@ static void split_value_into(jl_codectx_t &ctx, const jl_cgval_t &x, Align align\n     if (x.V == nullptr && x.constant == nullptr)\n         return;\n     Value *src = data_pointer(ctx, value_to_pointer(ctx, x));\n-    size_t dst_off = 0;\n-    size_t src_off = 0;\n     bool hasptr = typ->layout->first_ptr >= 0;\n     size_t npointers = hasptr ? typ->layout->npointers : 0;\n-    bool nodata = allpointers(typ);\n+    size_t shrunken_size = split_value_size(typ).first;\n+    size_t off = 0;\n     for (size_t i = 0; true; i++) {\n         bool last = i == npointers;\n         size_t ptr = last ? jl_datatype_size(typ) : (jl_ptr_offset(typ, i) * sizeof(void*));\n-        if (ptr > src_off) {\n+        if (ptr > off) {\n+            assert(off < shrunken_size && ptr <= shrunken_size);\n             emit_memcpy(ctx,\n-                emit_ptrgep(ctx, dst, dst_off),\n+                emit_ptrgep(ctx, dst, off),\n                 dst_ai,\n-                emit_ptrgep(ctx, src, src_off),\n+                emit_ptrgep(ctx, src, off),\n                 src_ai,\n-                ptr - src_off,\n+                ptr - off,\n                 align_dst,\n                 align_src,\n                 isVolatileStore);\n-            dst_off += ptr - src_off;\n         }\n         if (last)\n             break;\n         align_src = align_dst = Align(sizeof(void*));\n-        src_off = ptr + sizeof(void*);\n-        if (!nodata) {\n+        off = ptr + sizeof(void*);\n+        if (off < shrunken_size) {\n             // store an undef pointer here, to make sure nobody looks at this\n             dst_ai.decorateInst(ctx.builder.CreateAlignedStore(\n                 ctx.builder.getIntN(sizeof(void*) * 8, (uint64_t)-1),\n-                emit_ptrgep(ctx, dst, dst_off),\n-                align_src,\n+                emit_ptrgep(ctx, dst, ptr),\n+                Align(sizeof(void*)),\n                 isVolatileStore));\n-            dst_off += sizeof(void*);\n-            assert(dst_off == src_off);\n         }\n     }\n }\n \n-static std::pair<AllocaInst*, SmallVector<Value*,0>> split_value(jl_codectx_t &ctx, const jl_cgval_t &x, Align x_alignment)\n+static std::tuple<Value*, jl_gc_roots_t, MDNode*> split_value(jl_codectx_t &ctx, const jl_cgval_t &x, Align x_alignment, bool copy_required)\n {\n     jl_datatype_t *typ = (jl_datatype_t*)x.typ;\n     auto sizes = split_value_size(typ);\n-    Align align_dst(julia_alignment((jl_value_t*)typ));\n-    AllocaInst *bits = nullptr;\n+    jl_gc_roots_t roots;\n+    if (sizes.second) {\n+        roots = copy_required || x.inline_roots.empty() ? jl_gc_roots_t(extract_gc_roots(ctx, x, sizes.second)) : x.inline_roots;\n+        assert(roots.size() == sizes.second);\n+    }\n+    Value *bits = nullptr;\n     if (sizes.first) {\n-        bits = emit_static_alloca(ctx, sizes.first, align_dst);\n+        if (!copy_required) {\n+            if (!x.inline_roots.empty())\n+                return std::make_tuple(x.V, std::move(roots), x.tbaa);\n+            else if (x.ispointer())\n+                return std::make_tuple(data_pointer(ctx, x), std::move(roots), x.tbaa);\n+        }\n+        Align align_dst(julia_alignment((jl_value_t*)typ));\n+        AllocaInst *alloca = emit_static_alloca(ctx, sizes.first, align_dst);\n         auto stack_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_stack);\n-        split_value_into(ctx, x, x_alignment, bits, align_dst, stack_ai, false);\n+        split_value_into(ctx, x, x_alignment, alloca, align_dst, stack_ai, false);\n+        bits = alloca;\n     }\n-    SmallVector<Value*,0> roots;\n-    if (sizes.second) {\n-        roots = extract_gc_roots(ctx, x, sizes.second);\n-        if (roots.size() < sizes.second)\n-            roots.resize(sizes.second, Constant::getNullValue(ctx.types().T_prjlvalue));\n-    }\n-    return std::make_pair(bits, roots);\n+    return std::make_tuple(bits, std::move(roots), ctx.tbaa().tbaa_stack);\n }\n \n // Return the offset values corresponding to jl_field_offset, but into the two buffers for a split value (or -1)\n static std::pair<ssize_t,ssize_t> split_value_field(jl_datatype_t *typ, unsigned idx)\n {\n     size_t fldoff = jl_field_offset(typ, idx);\n-    size_t src_off = 0;\n-    size_t dst_off = 0;\n     assert(typ->layout->first_ptr >= 0);\n     size_t npointers = typ->layout->npointers;\n-    bool nodata = allpointers(typ);\n     for (size_t i = 0; i < npointers; i++) {\n         size_t ptr = jl_ptr_offset(typ, i) * sizeof(void*);\n         if (ptr >= fldoff) {\n             if (ptr >= fldoff + jl_field_size(typ, idx))\n                 break;\n             jl_value_t *ft = jl_field_type(typ, idx);\n             bool onlyptr = jl_field_isptr(typ, idx) || (jl_is_datatype(ft) && allpointers((jl_datatype_t*)ft));\n-            return std::make_pair(onlyptr ? -1 : dst_off + fldoff - src_off, i);\n-        }\n-        dst_off += ptr - src_off;\n-        src_off = ptr + sizeof(void*);\n-        if (!nodata) {\n-            assert(dst_off + sizeof(void*) == src_off);\n-            dst_off = src_off;\n+            return std::make_pair(onlyptr ? -1 : (ssize_t)fldoff, (ssize_t)i);\n         }\n     }\n-    return std::make_pair(dst_off + fldoff - src_off, -1);\n+    return std::make_pair((ssize_t)fldoff, (ssize_t)-1);\n }\n \n // Copy `x` to `dst`, where `x` was a split value and dst needs to have a native layout, copying any inlined roots back into their native location.\n@@ -1409,44 +1394,40 @@ static void recombine_value(jl_codectx_t &ctx, const jl_cgval_t &x, Value *dst,\n {\n     jl_datatype_t *typ = (jl_datatype_t*)x.typ;\n     assert(jl_is_concrete_type(x.typ) && !x.isghost);\n-    assert(typ->layout->first_ptr >= 0 && !x.inline_roots.empty());\n+    const jl_gc_roots_t &inline_roots = x.inline_roots;\n+    assert(typ->layout->first_ptr >= 0 && !inline_roots.empty());\n     Align align_dst = alignment;\n     Align align_src(julia_alignment(x.typ));\n     Value *src = x.V;\n     auto src_ai = jl_aliasinfo_t::fromTBAA(ctx, x.tbaa);\n-    size_t dst_off = 0;\n-    size_t src_off = 0;\n     size_t npointers = typ->layout->npointers;\n-    bool nodata = allpointers(typ);\n+    size_t shrunken_size = split_value_size(typ).first;\n     bool isstack = isa<AllocaInst>(dst->stripInBoundsOffsets()) || dst_ai.tbaa == ctx.tbaa().tbaa_stack;\n+    size_t off = 0;\n     for (size_t i = 0; true; i++) {\n         bool last = i == npointers;\n         size_t ptr = last ? jl_datatype_size(typ) : (jl_ptr_offset(typ, i) * sizeof(void*));\n-        if (ptr > dst_off) {\n+        if (ptr > off && off < shrunken_size) {\n+            size_t copy_end = std::min(ptr, shrunken_size);\n             emit_memcpy(ctx,\n-                emit_ptrgep(ctx, dst, dst_off),\n+                emit_ptrgep(ctx, dst, off),\n                 dst_ai,\n-                emit_ptrgep(ctx, src, src_off),\n+                emit_ptrgep(ctx, src, off),\n                 src_ai,\n-                ptr - dst_off,\n+                copy_end - off,\n                 align_dst,\n                 align_src,\n                 isVolatileStore);\n-            src_off += ptr - dst_off;\n         }\n         if (last)\n             break;\n-        auto *root = x.inline_roots[i];\n+        auto *root = inline_roots.get(ctx, i);\n         auto *store = ctx.builder.CreateAlignedStore(root, emit_ptrgep(ctx, dst, ptr), Align(sizeof(void*)), isVolatileStore);\n         if (!isstack)\n             store->setOrdering(AtomicOrdering::Unordered);\n         dst_ai.decorateInst(store);\n         align_dst = align_src = Align(sizeof(void*));\n-        dst_off = ptr + sizeof(void*);\n-        if (!nodata) {\n-            assert(src_off + sizeof(void*) == dst_off);\n-            src_off = dst_off;\n-        }\n+        off = ptr + sizeof(void*);\n     }\n }\n \n@@ -2428,11 +2409,11 @@ static jl_cgval_t typed_load(jl_codectx_t &ctx, Value *ptr, Value *idx_0based, j\n     if (Order == AtomicOrdering::NotAtomic && !isboxed && !aliasscope && elty->isAggregateType() && !jl_is_genericmemoryref_type(jltype)) {\n         // use split_value to do this load\n         auto src = mark_julia_slot(ptr, jltype, NULL, tbaa);\n-        auto copy = split_value(ctx, src, Align(alignment));\n-        if (maybe_null_if_boxed && !copy.second.empty()) {\n-            null_pointer_check(ctx, copy.second[0], nullcheck);\n+        auto [val, roots, result_tbaa] = split_value(ctx, src, Align(alignment), /*copy_required*/true);\n+        if (maybe_null_if_boxed && !roots.empty()) {\n+            null_pointer_check(ctx, roots.get(ctx, 0), nullcheck);\n         }\n-        return mark_julia_slot(copy.first, jltype, NULL, ctx.tbaa().tbaa_stack, copy.second);\n+        return mark_julia_slot(val, jltype, NULL, result_tbaa, std::move(roots));\n     }\n     Type *realelty = elty;\n     if (Order != AtomicOrdering::NotAtomic) {\n@@ -2708,7 +2689,11 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n             Args.push_back(rhs.Vboxed);\n         if (rhs.TIndex)\n             Args.push_back(rhs.TIndex);\n-        Args.append(rhs.inline_roots);\n+        if (!rhs.inline_roots.empty()) {\n+            const jl_gc_roots_t &roots_copy = rhs.inline_roots;\n+            for (size_t i = 0; i < roots_copy.size(); i++)\n+                Args.push_back(roots_copy.get(ctx, i));\n+        }\n         if (gcstack_arg)\n             Args.push_back(ctx.pgcstack);\n         auto oldnew = ctx.builder.CreateCall(intr, Args);\n@@ -3410,32 +3395,35 @@ static jl_cgval_t emit_getfield_knownidx(jl_codectx_t &ctx, const jl_cgval_t &st\n         auto offsets = split_value_field(jt, idx);\n         bool hasptr = offsets.second >= 0;\n         assert(hasptr == jl_field_isptr(jt, idx) || jl_type_hasptr(jfty));\n-        ArrayRef<Value*> roots;\n+        jl_gc_roots_t roots;\n         if (hasptr) {\n-            roots = ArrayRef(strct.inline_roots).slice(offsets.second, jl_field_isptr(jt, idx) ? 1 : ((jl_datatype_t*)jfty)->layout->npointers);\n+            size_t nroots = jl_field_isptr(jt, idx) ? 1 : ((jl_datatype_t*)jfty)->layout->npointers;\n+            roots = strct.inline_roots.slice(ctx, offsets.second, nroots);\n+            if (jl_field_isptr(jt, idx))\n+                roots = jl_gc_roots_t(ArrayRef<Value*>(roots.get(ctx, 0)));\n             if (maybe_null)\n-                null_pointer_check(ctx, roots[0], nullcheck);\n+                null_pointer_check(ctx, roots.get(ctx, 0), nullcheck);\n         }\n         if (jl_field_isptr(jt, idx)) {\n-            return mark_julia_type(ctx, roots[0], true, jfty);\n+            return mark_julia_type(ctx, roots.get(ctx, 0), true, jfty);\n         }\n         Value *addr = offsets.first < 0 ? nullptr : offsets.first == 0 ? strct.V : emit_ptrgep(ctx, strct.V, offsets.first);\n         if (jl_is_uniontype(jfty)) {\n+            assert(roots.empty());\n             size_t fsz = 0, al = 0;\n             int union_max = jl_islayout_inline(jfty, &fsz, &al);\n             size_t fsz1 = jl_field_size(jt, idx) - 1;\n             Value *ptindex = emit_ptrgep(ctx, addr, fsz1);\n             Value *tindex = emit_load_tindex(ctx, ptindex, union_max, strct.tbaa);\n-            // inline_roots unions are always const - just compute the pointer\n-            return mark_julia_slot(fsz > 0 ? addr : nullptr, jfty, tindex, tbaa);\n+            return mark_julia_slot(fsz > 0 ? addr : nullptr, jfty, tindex, tbaa, std::move(roots));\n         }\n         if (jfty == (jl_value_t*)jl_bool_type) {\n             unsigned align = jl_field_align(jt, idx);\n             return typed_load(ctx, addr, NULL, jfty, tbaa, nullptr, false,\n                     AtomicOrdering::NotAtomic, maybe_null, align, nullcheck);\n         }\n         else {\n-            return mark_julia_slot(addr, jfty, nullptr, tbaa, roots);\n+            return mark_julia_slot(addr, jfty, nullptr, tbaa, std::move(roots));\n         }\n     }\n     else if (strct.ispointer()) {\n@@ -4449,7 +4437,7 @@ static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t narg\n                 if (!init_as_value) {\n                     // avoid unboxing the argument explicitly\n                     // and use memcpy instead\n-                    Instruction *inst = strct && offs >= 0 ? cast<Instruction>(emit_ptrgep(ctx, strct, offs)) : nullptr;\n+                    Instruction *inst = strct && offs >= 0 ? cast<Instruction>(ctx.builder.CreateConstInBoundsGEP1_32(getInt8Ty(ctx.builder.getContext()), strct, offs)) : nullptr;\n                     if (!inline_roots.empty() && ptrsoffs >= 0)\n                         roots = MutableArrayRef(inline_roots).slice(ptrsoffs, jl_field_isptr(sty, i) ? 1 : ((jl_datatype_t*)jtype)->layout->npointers);\n                     dest = inst;\n@@ -4606,7 +4594,7 @@ static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t narg\n             else if (init_as_value)\n                 return mark_julia_type(ctx, strct, false, ty);\n             else {\n-                jl_cgval_t ret = mark_julia_slot(strct, ty, NULL, ctx.tbaa().tbaa_stack, inline_roots);\n+                jl_cgval_t ret = mark_julia_slot(strct, ty, NULL, ctx.tbaa().tbaa_stack, jl_gc_roots_t(std::move(inline_roots)));\n                 if (is_promotable && promotion_point) {\n                     ret.promotion_point = promotion_point;\n                     ret.promotion_ssa = promotion_ssa;\n@@ -4937,7 +4925,7 @@ static Value *emit_memoryref_FCA(jl_codectx_t &ctx, const jl_cgval_t &ref, const\n         jl_aliasinfo_t ai0 = jl_aliasinfo_t::fromTBAA(ctx, ref.tbaa);\n         ai0.decorateInst(load0);\n         setName(ctx.emission_context, load0, \"memory_ref_FCA0\");\n-        Value *root = ctx.builder.CreateBitCast(ref.inline_roots[0], type->getElementType(1));\n+        Value *root = ctx.builder.CreateBitCast(ref.inline_roots.get(ctx, 0), type->getElementType(1));\n         Value *load = Constant::getNullValue(type);\n         load = ctx.builder.CreateInsertValue(load, load0, 0);\n         load = ctx.builder.CreateInsertValue(load, root, 1);"
    },
    {
      "sha": "b6bc7c9744f0ca16e15a8c4ea22a4184c9275955",
      "filename": "src/codegen.cpp",
      "status": "modified",
      "additions": 174,
      "deletions": 65,
      "changes": 239,
      "blob_url": "https://github.com/JuliaLang/julia/blob/28e922e1e55bcb9e6b7e818f34105aba4567f68c/src%2Fcodegen.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/28e922e1e55bcb9e6b7e818f34105aba4567f68c/src%2Fcodegen.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcodegen.cpp?ref=28e922e1e55bcb9e6b7e818f34105aba4567f68c",
      "patch": "@@ -1732,6 +1732,72 @@ struct jl_aliasinfo_t {\n     }\n };\n \n+// A class to hold GC roots that can be either:\n+// 1. Materialized: a SmallVector of Value* that have already been loaded\n+// 2. Lazy: a pointer + count + tbaa that allows loading on demand\n+// This allows deferring the load of GC roots until they are actually needed.\n+struct jl_gc_roots_t {\n+private:\n+    // Materialized roots (when ptr is null)\n+    SmallVector<Value*,0> roots;\n+    // Lazy loading state (when ptr is non-null)\n+    Value *ptr = nullptr;\n+    size_t count = 0;\n+    MDNode *tbaa = nullptr;\n+\n+public:\n+    // Default constructor - empty roots\n+    jl_gc_roots_t() = default;\n+\n+    // Constructor from ArrayRef\n+    template <typename U>\n+    explicit jl_gc_roots_t(ArrayRef<U*> roots) : roots(roots.begin(), roots.end()) {}\n+\n+    // Constructor from SmallVector (move)\n+    explicit jl_gc_roots_t(SmallVector<Value*,0> &&values) : roots(std::move(values)) {}\n+\n+    // Constructor for lazy loading\n+    jl_gc_roots_t(Value *ptr, size_t count, MDNode *tbaa)\n+        : ptr(ptr), count(count), tbaa(tbaa) {}\n+\n+    // Copy constructor\n+    jl_gc_roots_t(const jl_gc_roots_t &other) = default;\n+\n+    // Move constructor\n+    jl_gc_roots_t(jl_gc_roots_t &&other) = default;\n+\n+    // Copy assignment\n+    jl_gc_roots_t &operator=(const jl_gc_roots_t &other) = default;\n+\n+    // Move assignment\n+    jl_gc_roots_t &operator=(jl_gc_roots_t &&other) = default;\n+\n+    // Get the number of roots\n+    size_t size() const { return ptr ? count : roots.size(); }\n+\n+    // Check if empty\n+    bool empty() const { return size() == 0; }\n+\n+    // Get a pointer to roots (tbaa_gcframe)\n+    Value *get_ptr(jl_codectx_t &ctx) const;\n+\n+    // Get a single root at index i, loading lazily if needed\n+    Value *get(jl_codectx_t &ctx, size_t i) const;\n+\n+    // Truncate to n roots\n+    void truncate(size_t n) {\n+        if (ptr) {\n+            assert(n <= count);\n+            count = n;\n+        } else {\n+            roots.truncate(n);\n+        }\n+    }\n+\n+    // Extract roots from [first, first+numel), lazily\n+    jl_gc_roots_t slice(jl_codectx_t &ctx, size_t first, size_t numel) const;\n+};\n+\n // metadata tracking for a llvm Value* during codegen\n const uint8_t UNION_BOX_MARKER = 0x80;\n struct jl_cgval_t {\n@@ -1753,7 +1819,7 @@ struct jl_cgval_t {\n     Value *Vboxed;\n \n     Value *TIndex; // if `V` is an unboxed (tagged) Union described by `typ`, this gives the DataType index (1-based, small int) as an i8\n-    SmallVector<Value*,0> inline_roots; // if present, `V` is a pointer, but not in canonical layout\n+    jl_gc_roots_t inline_roots; // if present, `V` is a pointer, but not in canonical layout\n     jl_value_t *constant; // constant value (rooted in linfo.def.roots)\n     jl_value_t *typ; // the original type of V, never nullptr\n     bool isboxed; // whether this value is a jl_value_t* allocated on the heap with the right type tag\n@@ -1788,11 +1854,11 @@ struct jl_cgval_t {\n         assert(TIndex == nullptr || TIndex->getType() == getInt8Ty(TIndex->getContext()));\n     }\n     jl_cgval_t(Value *Vptr, bool isboxed, jl_value_t *typ, Value *tindex, MDNode *tbaa, Value* inline_roots) = delete;\n-    jl_cgval_t(Value *Vptr, bool isboxed, jl_value_t *typ, Value *tindex, MDNode *tbaa, ArrayRef<Value*> inline_roots) : // general pointer constructor\n+    jl_cgval_t(Value *Vptr, bool isboxed, jl_value_t *typ, Value *tindex, MDNode *tbaa, jl_gc_roots_t inline_roots) : // general pointer constructor\n         V(Vptr),\n         Vboxed(isboxed ? Vptr : nullptr),\n         TIndex(tindex),\n-        inline_roots(inline_roots),\n+        inline_roots(std::move(inline_roots)),\n         constant(nullptr),\n         typ(typ),\n         isboxed(isboxed),\n@@ -2161,6 +2227,8 @@ static inline GlobalVariable *prepare_global_in(Module *M, GlobalVariable *G)\n \n static Value *emit_ptrgep(jl_codectx_t &ctx, Value *base, size_t byte_offset, const Twine &Name=\"\")\n {\n+    if (byte_offset == 0)\n+        return base;\n     auto *gep = ctx.builder.CreateConstInBoundsGEP1_32(getInt8Ty(ctx.builder.getContext()), base, byte_offset);\n     setName(ctx.emission_context, gep, Name);\n     return gep;\n@@ -2283,7 +2351,7 @@ static inline jl_cgval_t ghostValue(jl_codectx_t &ctx, jl_value_t *typ)\n     if (jl_is_type_type(typ)) {\n         assert(is_uniquerep_Type(typ));\n         // replace T::Type{T} with T, by assuming that T must be a leaftype of some sort\n-        jl_cgval_t constant(NULL, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n+        jl_cgval_t constant(NULL, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), jl_gc_roots_t());\n         constant.constant = jl_tparam0(typ);\n         if (typ == (jl_value_t*)jl_typeofbottom_type->super)\n             constant.isghost = true;\n@@ -2307,16 +2375,16 @@ static inline jl_cgval_t mark_julia_const(jl_codectx_t &ctx, jl_value_t *jv)\n         if (jl_is_datatype_singleton((jl_datatype_t*)typ))\n             return ghostValue(ctx, typ);\n     }\n-    jl_cgval_t constant(NULL, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n+    jl_cgval_t constant(NULL, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), jl_gc_roots_t());\n     constant.constant = jv;\n     return constant;\n }\n \n \n-static inline jl_cgval_t mark_julia_slot(Value *v, jl_value_t *typ, Value *tindex, MDNode *tbaa, ArrayRef<Value*> inline_roots={})\n+static inline jl_cgval_t mark_julia_slot(Value *v, jl_value_t *typ, Value *tindex, MDNode *tbaa, jl_gc_roots_t &&inline_roots=jl_gc_roots_t())\n {\n     // this enables lazy-copying of immutable values and stack or argument slots\n-    jl_cgval_t tagval(v, false, typ, tindex, tbaa, inline_roots);\n+    jl_cgval_t tagval(v, false, typ, tindex, tbaa, std::move(inline_roots));\n     return tagval;\n }\n \n@@ -2357,12 +2425,8 @@ static inline jl_cgval_t value_to_pointer(jl_codectx_t &ctx, Value *v, jl_value_\n static inline jl_cgval_t value_to_pointer(jl_codectx_t &ctx, const jl_cgval_t &v)\n {\n     if (!v.inline_roots.empty()) {\n-        //if (v.V == nullptr) {\n-        //    AllocaInst *loc = emit_static_roots(ctx, v.inline_roots.size());\n-        //    for (size_t i = 0; i < v.inline_roots.counts(); i++)\n-        //        ctx.builder.CreateAlignedStore(v.inline_roots[i], emit_ptrgep(ctx, loc, i * sizeof(void*)), Align(sizeof(void*)));\n-        //    return mark_julia_slot(loc, v.typ, v.TIndex, ctx.tbaa().tbaa_gcframe);\n-        //}\n+        if (allpointers((jl_datatype_t*)v.typ))\n+            return mark_julia_slot(v.inline_roots.get_ptr(ctx), v.typ, v.TIndex, ctx.tbaa().tbaa_gcframe);\n         Align align(julia_alignment(v.typ));\n         Type *ty = julia_type_to_llvm(ctx, v.typ);\n         AllocaInst *loc = emit_static_alloca(ctx, ty, align);\n@@ -2392,7 +2456,7 @@ static inline jl_cgval_t mark_julia_type(jl_codectx_t &ctx, Value *v, bool isbox\n     if (type_is_ghost(T))\n         return ghostValue(ctx, typ);\n     if (isboxed)\n-        return jl_cgval_t(v, isboxed, typ, NULL, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n+        return jl_cgval_t(v, isboxed, typ, NULL, best_tbaa(ctx.tbaa(), typ), jl_gc_roots_t());\n     if (v && v->getType()->isAggregateType()) {\n         // eagerly put this back onto the stack\n         // llvm mem2reg pass will remove this if unneeded\n@@ -2453,7 +2517,7 @@ static inline jl_cgval_t update_julia_type(jl_codectx_t &ctx, const jl_cgval_t &\n                 return jl_cgval_t();\n             }\n             if (v.Vboxed && (v.isboxed || alwaysboxed)) {\n-                return jl_cgval_t(v.Vboxed, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n+                return jl_cgval_t(v.Vboxed, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), jl_gc_roots_t());\n             }\n         }\n         if (!jl_is_concrete_type(typ))\n@@ -2468,6 +2532,41 @@ static inline jl_cgval_t update_julia_type(jl_codectx_t &ctx, const jl_cgval_t &\n     return jl_cgval_t(v, typ, NULL);\n }\n \n+Value *jl_gc_roots_t::get(jl_codectx_t &ctx, size_t i) const\n+{\n+    if (ptr) {\n+        // Lazy mode - load the root on demand\n+        Type *T_prjlvalue = ctx.types().T_prjlvalue;\n+        auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n+        LoadInst *load = ctx.builder.CreateAlignedLoad(T_prjlvalue, emit_ptrgep(ctx, ptr, i * sizeof(jl_value_t*)), Align(sizeof(void*)));\n+        roots_ai.decorateInst(load);\n+        return load;\n+    }\n+    return roots[i];\n+}\n+\n+Value *jl_gc_roots_t::get_ptr(jl_codectx_t &ctx) const\n+{\n+    if (ptr)\n+        return ptr;\n+    auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n+    Value *copyptr = emit_static_roots(ctx, size());\n+    for (size_t i = 0; i < size(); i++) {\n+        StoreInst *SI = ctx.builder.CreateAlignedStore(get(ctx, i), emit_ptrgep(ctx, copyptr, i * sizeof(void*)), Align(sizeof(void*)));\n+        roots_ai.decorateInst(SI);\n+    }\n+    return copyptr;\n+}\n+\n+jl_gc_roots_t jl_gc_roots_t::slice(jl_codectx_t &ctx, size_t first, size_t numel) const {\n+    if (numel == 0)\n+        return jl_gc_roots_t();\n+    else if (ptr)\n+        return jl_gc_roots_t(emit_ptrgep(ctx, ptr, first * sizeof(void*)), numel, tbaa);\n+    else\n+        return jl_gc_roots_t(ArrayRef(roots).slice(first, numel));\n+}\n+\n // --- allocating local variables ---\n \n static jl_sym_t *slot_symbol(jl_codectx_t &ctx, int s)\n@@ -2562,13 +2661,13 @@ static jl_cgval_t convert_julia_type_to_union(jl_codectx_t &ctx, const jl_cgval_\n                     // previous value was unboxed (leaftype) and hoisted (!pointer) with statically computed union tindex\n                     // TODO: remove this branch once all consumers of v.TIndex understand how to handle a non-ispointer value\n                     jl_cgval_t ret(value_to_pointer(ctx, v), typ, new_tindex);\n-                    ret.inline_roots = ExtractTrackedValues(ctx, v.V);\n+                    ret.inline_roots = jl_gc_roots_t(ExtractTrackedValues(ctx, v.V));\n                     return ret;\n                 }\n             }\n             else if (jl_subtype(v.typ, typ)) {\n                 // convert to a simple isboxed value, since it must be boxed in the new union\n-                return jl_cgval_t(boxed(ctx, v), true, typ, new_tindex, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n+                return jl_cgval_t(boxed(ctx, v), true, typ, new_tindex, best_tbaa(ctx.tbaa(), typ), jl_gc_roots_t());\n             }\n             else {\n                 if (!allow_mismatch)\n@@ -2773,17 +2872,26 @@ static jl_cgval_t convert_julia_type_to_union(jl_codectx_t &ctx, const jl_cgval_\n             // if adding new roots to the union, load those now\n             if (add_roots_count && (v.TIndex || v.isboxed)) {\n                 Value *Vnull = Constant::getNullValue(ctx.types().T_prjlvalue);\n-                if (ret.inline_roots.size() < add_roots_inline)\n-                    ret.inline_roots.resize(add_roots_inline, Vnull);\n+                // Load existing roots into a local SmallVector - must be done at currBB\n+                // so the loaded values dominate the incoming edges for the PHI nodes\n+                assert(ret.inline_roots.size() <= (size_t)add_roots_inline);\n+                SmallVector<Value*,0> new_roots(add_roots_inline, Vnull);\n+                if (add_roots_inline) {\n+                    ctx.builder.SetInsertPoint(currBB->getTerminator());\n+                    for (size_t i = 0; i < ret.inline_roots.size(); i++)\n+                        new_roots[i] = ret.inline_roots.get(ctx, i);\n+                    ctx.builder.SetInsertPoint(postBB);\n+                }\n                 // replace new ret.inline_roots with PHI\n                 for (size_t i = 0; i < add_roots_inline; i++) {\n-                    Value *rooti = ret.inline_roots[i];\n+                    Value *rooti = new_roots[i];\n                     PHINode *phi = ctx.builder.CreatePHI(rooti->getType(), 2 + add_roots_count);\n                     if (v.TIndex)\n                         phi->addIncoming(rooti, currBB);\n                     phi->addIncoming(rooti, post_union_isaBB);\n-                    ret.inline_roots[i] = phi;\n+                    new_roots[i] = phi;\n                 }\n+                ret.inline_roots = jl_gc_roots_t(std::move(new_roots));\n                 ctx.builder.SetInsertPoint(post_union_isaBB);\n                 Value *Vboxed = v.Vboxed ? decay_derived(ctx, v.Vboxed) : nullptr;\n                 SwitchInst *SW = ctx.builder.CreateSwitch(union_box_tindex, postBB, add_roots_count);\n@@ -2808,7 +2916,7 @@ static jl_cgval_t convert_julia_type_to_union(jl_codectx_t &ctx, const jl_cgval_\n                                     tindex_phi->addIncoming(union_box_tindex, splitunboxBB);\n                                 for (size_t i = 0; i < add_roots_inline; i++) {\n                                     Value *rooti = i < newroots.size() ? newroots[i] : Vnull;\n-                                    cast<PHINode>(ret.inline_roots[i])->addIncoming(rooti, splitunboxBB);\n+                                    cast<PHINode>(ret.inline_roots.get(ctx, i))->addIncoming(rooti, splitunboxBB);\n                                 }\n                             }\n                         }\n@@ -2827,13 +2935,13 @@ static jl_cgval_t convert_julia_type_to_union(jl_codectx_t &ctx, const jl_cgval_\n         jl_datatype_t *jt = (jl_datatype_t*)v.typ;\n         auto npointers = jl_datatype_layout(jt)->npointers;\n         if (npointers)\n-            ret.inline_roots = extract_gc_roots(ctx, v, npointers);\n+            ret.inline_roots = jl_gc_roots_t(extract_gc_roots(ctx, v, npointers));\n     }\n \n     if (!computed_new_index_early && isa<Constant>(new_tindex)) {\n         // no new tindex (it is set to UNION_BOX_MARKER), so the new value must be something boxed in the new union\n         // TODO: use ret.Vboxed or box_union directly to set skip instead of emitting a trap?\n-        return jl_cgval_t(boxed(ctx, v), true, typ, new_tindex, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n+        return jl_cgval_t(boxed(ctx, v), true, typ, new_tindex, best_tbaa(ctx.tbaa(), typ), jl_gc_roots_t());\n     }\n     // some of the values are still unboxed\n     setName(ctx.emission_context, new_tindex, \"tindex\");\n@@ -5041,7 +5149,7 @@ static bool emit_builtin_call(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n             if (!obj.inline_roots.empty()) {\n                 auto offsets = split_value_field(stt, fieldidx);\n                 assert(offsets.second >= 0);\n-                fldv = obj.inline_roots[offsets.second];\n+                fldv = obj.inline_roots.get(ctx, offsets.second);\n             }\n             else if (obj.ispointer()) {\n                 auto tbaa = best_field_tbaa(ctx, obj, stt, fieldidx, offs);\n@@ -5223,16 +5331,11 @@ static jl_cgval_t emit_call_specfun_other(jl_codectx_t &ctx, bool is_opaque_clos\n             else if (et->isAggregateType()) {\n                 auto tracked = CountTrackedPointers(et);\n                 if (tracked.count && !tracked.all) {\n-                    Value *val = arg.V;\n-                    SmallVector<Value*,0> roots(arg.inline_roots);\n-                    if (roots.empty())\n-                        std::tie(val, roots) = split_value(ctx, arg, Align(julia_alignment(jt)));\n-                    AllocaInst *proots = emit_static_roots(ctx, roots.size());\n-                    for (size_t i = 0; i < roots.size(); i++)\n-                        ctx.builder.CreateAlignedStore(roots[i], emit_ptrgep(ctx, proots, i * sizeof(void*)), Align(sizeof(void*)));\n+                    auto [val, roots, result_tbaa] = split_value(ctx, arg, Align(julia_alignment(jt)), /*copy_required*/false);\n+                    Value *proots = roots.get_ptr(ctx);\n                     assert(val);\n-                    argvals[idx++] = decay_derived(ctx, val);\n-                    argvals[idx] = proots;\n+                    argvals[idx] = decay_derived(ctx, val);\n+                    argvals[++idx] = proots;\n                 }\n                 else {\n                     if (!arg.isboxed)\n@@ -5272,7 +5375,7 @@ static jl_cgval_t emit_call_specfun_other(jl_codectx_t &ctx, bool is_opaque_clos\n                                      jlretty,\n                                      NULL,\n                                      ctx.tbaa().tbaa_gcframe,\n-                                     load_gc_roots(ctx, return_roots, returninfo.return_roots, ctx.tbaa().tbaa_gcframe));\n+                                     make_lazy_gc_roots(return_roots, returninfo.return_roots, ctx.tbaa().tbaa_gcframe));\n             break;\n         case jl_returninfo_t::Union: {\n             Value *box = ctx.builder.CreateExtractValue(call, 0);\n@@ -5288,7 +5391,7 @@ static jl_cgval_t emit_call_specfun_other(jl_codectx_t &ctx, bool is_opaque_clos\n                                      jlretty,\n                                      tindex,\n                                      ctx.tbaa().tbaa_stack,\n-                                     load_gc_roots(ctx, return_roots, returninfo.return_roots, ctx.tbaa().tbaa_gcframe));\n+                                     make_lazy_gc_roots(return_roots, returninfo.return_roots, ctx.tbaa().tbaa_gcframe));\n             retval.Vboxed = box;\n             break;\n         }\n@@ -5811,7 +5914,7 @@ static jl_cgval_t emit_varinfo(jl_codectx_t &ctx, jl_varinfo_t &vi, jl_sym_t *va\n             Value *tindex = NULL;\n             if (vi.pTIndex)\n                 tindex = ctx.builder.CreateAlignedLoad(getInt8Ty(ctx.builder.getContext()), vi.pTIndex, Align(1), vi.isVolatile);\n-            v = mark_julia_slot(ssaslot, vi.value.typ, tindex, ctx.tbaa().tbaa_stack);\n+            v = mark_julia_slot(ssaslot, vi.value.typ, tindex, ctx.tbaa().tbaa_stack, jl_gc_roots_t());\n         }\n         if (vi.inline_roots) {\n             AllocaInst *varslot = vi.inline_roots;\n@@ -5822,7 +5925,13 @@ static jl_cgval_t emit_varinfo(jl_codectx_t &ctx, jl_varinfo_t &vi, jl_sym_t *va\n                 T_prjlvalue = AT->getElementType();\n             }\n             assert(T_prjlvalue == ctx.types().T_prjlvalue);\n-            v.inline_roots = load_gc_roots(ctx, varslot, nroots, ctx.tbaa().tbaa_gcframe, vi.isVolatile);\n+            SmallVector<Value*,0> gcroots(nroots);\n+            auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n+            for (size_t i = 0; i < nroots; i++) {\n+                Value *ptr = emit_ptrgep(ctx, varslot, i * sizeof(jl_value_t*));\n+                gcroots[i] = roots_ai.decorateInst(ctx.builder.CreateAlignedLoad(T_prjlvalue, ptr, Align(sizeof(void*)), vi.isVolatile));\n+            }\n+            v.inline_roots = jl_gc_roots_t(std::move(gcroots));\n         }\n         if (vi.usedUndef) {\n             assert(vi.defFlag);\n@@ -5895,13 +6004,10 @@ static void emit_vi_assignment_unboxed(jl_codectx_t &ctx, jl_varinfo_t &vi, Valu\n             MDNode *tbaa = ctx.tbaa().tbaa_stack; // Use vi.value.tbaa ?\n             auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n             if (rval_info.TIndex) {\n-                Value *Vnull = Constant::getNullValue(ctx.types().T_prjlvalue);\n                 if (vi.value.V)\n                     emit_unionmove(ctx, vi.value.V, vi.value.typ, tbaa, rval_info, rval_info.TIndex, /*skip*/isboxed, vi.isVolatile);\n-                SmallVector<Value*,0> inline_roots(vi.inline_roots_count, Vnull);\n-                for (size_t i = 0; i < std::min(rval_info.inline_roots.size(), inline_roots.size()); ++i)\n-                    inline_roots[i] = rval_info.inline_roots[i];\n-                store_all_roots(ctx, inline_roots, vi.inline_roots, roots_ai, vi.isVolatile);\n+                assert(rval_info.inline_roots.size() <= vi.inline_roots_count);\n+                store_all_roots(ctx, rval_info.inline_roots, vi.inline_roots, roots_ai, vi.isVolatile);\n             }\n             else {\n                 Align align(julia_alignment(rval_info.typ));\n@@ -5972,8 +6078,7 @@ static void emit_phinode_assign(jl_codectx_t &ctx, ssize_t idx, jl_value_t *r)\n                 }\n                 tbaa = best_tbaa(ctx.tbaa(), phiType);\n             }\n-            jl_cgval_t val = mark_julia_slot(ptr, phiType, Tindex_phi, tbaa,\n-                roots.empty() ? ArrayRef<Value*>() : ArrayRef((Value *const *)&roots.front(), roots.size()));\n+            jl_cgval_t val = mark_julia_slot(ptr, phiType, Tindex_phi, tbaa, jl_gc_roots_t(ArrayRef(roots)));\n             val.Vboxed = ptr_phi;\n             ctx.PhiNodes.push_back(std::make_tuple(val, BB, dest, ptr_phi, roots, r));\n             ctx.SAvalues[idx] = val;\n@@ -6021,8 +6126,7 @@ static void emit_phinode_assign(jl_codectx_t &ctx, ssize_t idx, jl_value_t *r)\n             ctx.builder.CreateMemCpy(phi, align, dest, align, nb, false);\n             ctx.builder.CreateLifetimeEnd(dest);\n         }\n-        slot = mark_julia_slot(phi, phiType, NULL, ctx.tbaa().tbaa_stack,\n-                roots.empty() ? ArrayRef<Value*>() : ArrayRef((Value *const *)&roots.front(), roots.size()));\n+        slot = mark_julia_slot(phi, phiType, NULL, ctx.tbaa().tbaa_stack, jl_gc_roots_t(ArrayRef(roots)));\n     }\n     else {\n         value_phi = PHINode::Create(vtype, jl_array_nrows(edges), \"value_phi\");\n@@ -6126,6 +6230,7 @@ static void emit_varinfo_assign(jl_codectx_t &ctx, jl_varinfo_t &vi, const jl_cg\n     }\n     else if (vi.pTIndex && !rval_info.inline_roots.empty()) {\n         auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n+        assert(rval_info.inline_roots.size() <= vi.inline_roots_count);\n         store_all_roots(ctx, rval_info.inline_roots, vi.inline_roots, roots_ai, vi.isVolatile);\n     }\n \n@@ -6942,8 +7047,8 @@ static Function *emit_modifyhelper(jl_codectx_t &ctx2, const jl_cgval_t &op, con\n         ArgTy.push_back(rhs.Vboxed->getType());\n     if (rhs.TIndex)\n         ArgTy.push_back(rhs.TIndex->getType());\n-    for (auto &root : rhs.inline_roots)\n-        ArgTy.push_back(root->getType());\n+    for (size_t i = 0; i < rhs.inline_roots.size(); i++)\n+        ArgTy.push_back(rhs.inline_roots.get(ctx2, i)->getType());\n     if (gcstack_arg)\n         ArgTy.push_back(ctx.builder.getPtrTy());\n     FunctionType *FT = FunctionType::get(elty, ArgTy, false);\n@@ -6960,8 +7065,12 @@ static Function *emit_modifyhelper(jl_codectx_t &ctx2, const jl_cgval_t &op, con\n         rhs.Vboxed = &*AI++;\n     if (rhs.TIndex)\n         rhs.TIndex = &*AI++;\n-    for (size_t i = 0; i < rhs.inline_roots.size(); i++)\n-        rhs.inline_roots[i] = &*AI++;\n+    if (!rhs.inline_roots.empty()) {\n+        SmallVector<Value*,0> new_roots(rhs.inline_roots.size());\n+        for (size_t i = 0; i < rhs.inline_roots.size(); i++)\n+            new_roots[i] = &*AI++;\n+        rhs.inline_roots = jl_gc_roots_t(std::move(new_roots));\n+    }\n     rhs.promotion_point = nullptr;\n     rhs.promotion_ssa = -1;\n     if (gcstack_arg) {\n@@ -7114,12 +7223,12 @@ static void emit_specsig_to_specsig(\n             ++AI;\n             if (!isboxed && et->isAggregateType()) {\n                 auto tracked = CountTrackedPointers(et);\n-                SmallVector<Value*,0> roots;\n+                jl_gc_roots_t roots;\n                 if (tracked.count && !tracked.all) {\n-                    roots = load_gc_roots(ctx, &*AI, tracked.count, ctx.tbaa().tbaa_const);\n+                    roots = make_lazy_gc_roots(&*AI, tracked.count, ctx.tbaa().tbaa_const);\n                     ++AI;\n                 }\n-                myargs[i] = mark_julia_slot(arg_v, jt, NULL, ctx.tbaa().tbaa_const, roots);\n+                myargs[i] = mark_julia_slot(arg_v, jt, NULL, ctx.tbaa().tbaa_const, std::move(roots));\n             }\n             else {\n                 assert(arg_v->getType() == et);\n@@ -7175,16 +7284,15 @@ static void emit_specsig_to_specsig(\n         Value *gf_ret = boxed(ctx, gf_retval); // TODO: this is not the most optimal way to emit this\n         if (!retvalinfo.inline_roots.empty()) {\n             auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n-            ArrayRef<Value*> inline_roots(retvalinfo.inline_roots);\n             Argument *roots;\n             if (return_roots) {\n                 roots = gf_thunk->arg_begin() + 1; // root1 has type [n x {}*]*\n-                inline_roots = inline_roots.slice(0, std::min(inline_roots.size(), (size_t)return_roots)); // TODO: unreachable?\n+                assert(retvalinfo.inline_roots.size() <= (size_t)return_roots);\n             }\n             else {\n                 roots = gf_thunk->arg_begin(); // root1 has type [n x {}*]*\n             }\n-            store_all_roots(ctx, inline_roots, roots, roots_ai, false);\n+            store_all_roots(ctx, retvalinfo.inline_roots, roots, roots_ai, false);\n         }\n         Value *retval = Constant::getNullValue(retty);\n         tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER));\n@@ -8849,7 +8957,7 @@ static jl_llvm_functions_t\n             AllocaInst *roots = sizes.second > 0 ? emit_static_roots(ctx, sizes.second) : nullptr;\n             if (bits) bits->setName(jl_symbol_name(s));\n             if (roots) roots->setName(StringRef(\".roots.\") + jl_symbol_name(s));\n-            varinfo.value = mark_julia_slot(bits, jt, NULL, ctx.tbaa().tbaa_stack, {});\n+            varinfo.value = mark_julia_slot(bits, jt, NULL, ctx.tbaa().tbaa_stack, jl_gc_roots_t());\n             varinfo.inline_roots = roots;\n             varinfo.inline_roots_count = sizes.second;\n             alloc_def_flag(ctx, varinfo);\n@@ -8949,11 +9057,11 @@ static jl_llvm_functions_t\n         jl_cgval_t theArg;\n         if (!isboxed && llvmArgType->isAggregateType()) {\n             maybe_mark_argument_dereferenceable(param, argType);\n-            SmallVector<Value*,0> roots;\n+            jl_gc_roots_t roots;\n             auto tracked = CountTrackedPointers(llvmArgType);\n             if (tracked.count && !tracked.all) {\n                 Argument *RootArg = &*AI;\n-                roots = load_gc_roots(ctx, RootArg, tracked.count, ctx.tbaa().tbaa_const);\n+                roots = make_lazy_gc_roots(RootArg, tracked.count, ctx.tbaa().tbaa_const);\n                 AttrBuilder param(ctx.builder.getContext(), f->getAttributes().getParamAttrs(Arg->getArgNo()));\n                 param.addAttribute(Attribute::NonNull);\n                 param.addAttribute(Attribute::NoUndef);\n@@ -8962,7 +9070,7 @@ static jl_llvm_functions_t\n                 attrs[RootArg->getArgNo()] = AttributeSet::get(Arg->getContext(), param);\n                 ++AI;\n             }\n-            theArg = mark_julia_slot(Arg, argType, NULL, ctx.tbaa().tbaa_const, roots); // this argument is by-pointer\n+            theArg = mark_julia_slot(Arg, argType, NULL, ctx.tbaa().tbaa_const, std::move(roots)); // this argument is by-pointer\n         }\n         else {\n             if (isboxed)\n@@ -9439,7 +9547,7 @@ static jl_llvm_functions_t\n             Value *isboxed_union = NULL;\n             Value *retval = NULL;\n             Value *sret = has_sret ? f->arg_begin() : NULL;\n-            SmallVector<Value*,0> inline_roots;\n+            jl_gc_roots_t inline_roots;\n             Type *retty = f->getReturnType();\n             switch (returninfo.cc) {\n             case jl_returninfo_t::Boxed:\n@@ -9457,7 +9565,7 @@ static jl_llvm_functions_t\n                 assert(jl_is_concrete_type(jlrettype) && jlrettype == retvalinfo.typ);\n                 auto npointers = jl_datatype_layout(jt)->npointers;\n                 if (npointers)\n-                    inline_roots = extract_gc_roots(ctx, retvalinfo, npointers);\n+                    inline_roots = jl_gc_roots_t(extract_gc_roots(ctx, retvalinfo, npointers));\n                 break;\n             }\n             case jl_returninfo_t::Union: {\n@@ -9809,8 +9917,9 @@ static jl_llvm_functions_t\n                         emit_unionmove(ctx, dest, phiType, ctx.tbaa().tbaa_stack, val, tindex, skip);\n                     }\n                 }\n-                for (size_t i = 0; i < std::min(new_union.inline_roots.size(), lroots.size()); ++i)\n-                    lroots[i] = new_union.inline_roots[i];\n+                assert(new_union.inline_roots.size() <= lroots.size());\n+                for (size_t i = 0; i < new_union.inline_roots.size(); ++i)\n+                    lroots[i] = new_union.inline_roots.get(ctx, i);\n                 for (size_t nr = 0; nr < roots.size(); nr++)\n                     roots[nr]->addIncoming(lroots[nr], ctx.builder.GetInsertBlock());\n                 if (VN)"
    },
    {
      "sha": "f64a71067847d6082fd38de2d878ec6b792ff770",
      "filename": "src/intrinsics.cpp",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/28e922e1e55bcb9e6b7e818f34105aba4567f68c/src%2Fintrinsics.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/28e922e1e55bcb9e6b7e818f34105aba4567f68c/src%2Fintrinsics.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fintrinsics.cpp?ref=28e922e1e55bcb9e6b7e818f34105aba4567f68c",
      "patch": "@@ -1234,15 +1234,17 @@ static jl_cgval_t emit_ifelse(jl_codectx_t &ctx, jl_cgval_t c, jl_cgval_t x, jl_\n             } else if (!y.isghost && y.V != NULL) {\n                 y_ptr = maybe_decay_tracked(ctx, y.V);\n             }\n-            auto nroots = std::max(x.inline_roots.size(), y.inline_roots.size());\n+            jl_gc_roots_t x_roots = x.inline_roots;\n+            jl_gc_roots_t y_roots = y.inline_roots;\n+            auto nroots = std::max(x_roots.size(), y_roots.size());\n             Value *Vnull = Constant::getNullValue(ctx.types().T_prjlvalue);\n             SmallVector<Value *, 0> ifelse_roots(nroots, Vnull);\n             for (size_t i = 0; i < nroots; i++) {\n                 Value *x_root = Vnull, *y_root = Vnull;\n-                if (i < x.inline_roots.size())\n-                    x_root = x.inline_roots[i];\n-                if (i < y.inline_roots.size())\n-                    y_root = y.inline_roots[i];\n+                if (i < x_roots.size())\n+                    x_root = x_roots.get(ctx, i);\n+                if (i < y_roots.size())\n+                    y_root = y_roots.get(ctx, i);\n                 ifelse_roots[i] = ctx.builder.CreateSelect(isfalse, y_root, x_root);\n             }\n             MDNode *ifelse_tbaa;\n@@ -1309,7 +1311,7 @@ static jl_cgval_t emit_ifelse(jl_codectx_t &ctx, jl_cgval_t c, jl_cgval_t x, jl_\n                 tindex = ret;\n                 setName(ctx.emission_context, tindex, \"ifelse_tindex\");\n             }\n-            jl_cgval_t ret = mark_julia_slot(ifelse_result, rt_hint, tindex, ifelse_tbaa, ifelse_roots);\n+            jl_cgval_t ret = mark_julia_slot(ifelse_result, rt_hint, tindex, ifelse_tbaa, jl_gc_roots_t(std::move(ifelse_roots)));\n             if (x_vboxed || y_vboxed) {\n                 if (!x_vboxed)\n                     x_vboxed = ConstantPointerNull::get(cast<PointerType>(y_vboxed->getType()));"
    }
  ]
}