{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59841",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59841/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59841/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59841/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59841",
  "id": 3514979682,
  "node_id": "PR_kwDOABkWpM6tuUyy",
  "number": 59841,
  "title": "Libdl: Add documentation for LazyLibrary and friends",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 115619,
      "node_id": "MDU6TGFiZWwxMTU2MTk=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/docs",
      "name": "docs",
      "color": "02d7e1",
      "default": false,
      "description": "This change adds or pertains to documentation"
    },
    {
      "id": 706812401,
      "node_id": "MDU6TGFiZWw3MDY4MTI0MDE=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/stdlib",
      "name": "stdlib",
      "color": "6F689E",
      "default": false,
      "description": "Julia's standard library"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 1,
  "created_at": "2025-10-14T18:10:23Z",
  "updated_at": "2025-10-17T19:12:04Z",
  "closed_at": "2025-10-17T19:12:02Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59841",
    "html_url": "https://github.com/JuliaLang/julia/pull/59841",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59841.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59841.patch",
    "merged_at": "2025-10-17T19:12:02Z"
  },
  "body": "Adds documentation for `Libdl.LazyLibrary` and related types.\r\n\r\nAlso extends the C calling manual with an expanded section on using `LazyLibrary` for lazy library loading, including practical examples of platform-specific libraries, dependency management, lazy path construction, and initialization callbacks. Remove a few oddly confusing or incorrect notes as well.\r\n\r\nAlso fix a `copy` oddly implemented as\r\n`convert(Vector{LazyLibrary}, convert(Vector{Any}, LazyLibrary[]))` from #59233 to just call `copy`.\r\n\r\n\ud83e\udd16 Generated with help by Claude Code.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59841/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59841/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "6b409f057eadff9e0903b745a1705dba32feddc5",
      "filename": "Compiler/src/abstractinterpretation.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/540145975d405f053bfae4ab622f8e1d3d94669e/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/540145975d405f053bfae4ab622f8e1d3d94669e/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fabstractinterpretation.jl?ref=540145975d405f053bfae4ab622f8e1d3d94669e",
      "patch": "@@ -3484,6 +3484,10 @@ function abstract_eval_foreigncall(interp::AbstractInterpreter, e::Expr, sstate:\n     callee = e.args[1]\n     if isexpr(callee, :tuple)\n         if length(callee.args) >= 1\n+            # Evaluate the arguments to constrain the world, effects, and other info for codegen,\n+            # but note there is an implied `if !=(C_NULL)` branch here that might read data\n+            # in a different world (the exact cache behavior is unspecified), so we do not use\n+            # these results to refine reachability of the subsequent foreigncall.\n             abstract_eval_value(interp, callee.args[1], sstate, sv)\n             if length(callee.args) >= 2\n                 abstract_eval_value(interp, callee.args[2], sstate, sv)"
    },
    {
      "sha": "d10434bb8c61083883415bd8f1be7fcad886a5d6",
      "filename": "base/libdl.jl",
      "status": "modified",
      "additions": 90,
      "deletions": 24,
      "changes": 114,
      "blob_url": "https://github.com/JuliaLang/julia/blob/540145975d405f053bfae4ab622f8e1d3d94669e/base%2Flibdl.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/540145975d405f053bfae4ab622f8e1d3d94669e/base%2Flibdl.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Flibdl.jl?ref=540145975d405f053bfae4ab622f8e1d3d94669e",
      "patch": "@@ -319,15 +319,22 @@ end\n \n \n \"\"\"\n-    LazyLibraryPath\n+    LazyLibraryPath(path_pieces...)\n \n-Helper type for lazily constructed library paths for use with `LazyLibrary`.\n-Arguments are passed to `joinpath()`.  Arguments must be able to have\n-`string()` called on them.\n+Helper type for lazily constructed library paths for use with [`LazyLibrary`](@ref).\n+Path pieces are stored unevaluated and joined with `joinpath()` when the library is first\n+accessed. Arguments must be able to have `string()` called on them.\n \n+# Example\n+\n+```julia\n+const mylib = LazyLibrary(LazyLibraryPath(artifact_dir, \"lib\", \"libmylib.so.1.2.3\"))\n ```\n-libfoo = LazyLibrary(LazyLibraryPath(prefix, \"lib/libfoo.so.1.2.3\"))\n-```\n+\n+!!! compat \"Julia 1.11\"\n+    `LazyLibraryPath` was added in Julia 1.11.\n+\n+See also [`LazyLibrary`](@ref), [`BundledLazyLibraryPath`](@ref).\n \"\"\"\n struct LazyLibraryPath\n     pieces::Tuple{Vararg{Any}}\n@@ -347,34 +354,76 @@ end\n Base.string(::PrivateShlibdirGetter) = private_shlibdir()\n \n \"\"\"\n-    BundledLazyLibraryPath\n+    BundledLazyLibraryPath(subpath)\n \n-Helper type for lazily constructed library paths that are stored within the\n-bundled Julia distribution, primarily for use by Base modules.\n+Helper type for lazily constructed library paths within the Julia distribution.\n+Constructs paths relative to Julia's private shared library directory.\n \n+Primarily used by Julia's standard library. For example:\n+```julia\n+const libgmp = LazyLibrary(BundledLazyLibraryPath(\"libgmp.so.10\"))\n ```\n-libfoo = LazyLibrary(BundledLazyLibraryPath(\"libfoo.so.1.2.3\"))\n-```\n+\n+!!! compat \"Julia 1.11\"\n+    `BundledLazyLibraryPath` was added in Julia 1.11.\n+\n+See also [`LazyLibrary`](@ref), [`LazyLibraryPath`](@ref).\n \"\"\"\n BundledLazyLibraryPath(subpath) = LazyLibraryPath(PrivateShlibdirGetter(), subpath)\n \n # Small helper struct to initialize a LazyLibrary with its initial set of dependencies\n-struct InitialDependencies\n-    dependencies::Vector{Any}\n+struct InitialDependencies{T}\n+    dependencies::Vector{T}\n end\n-(init::InitialDependencies)() = convert(Vector{LazyLibrary}, init.dependencies)\n+(init::InitialDependencies)() = copy(init.dependencies)\n \n \"\"\"\n-    LazyLibrary(name, flags = <default dlopen flags>,\n+    LazyLibrary(name; flags = <default dlopen flags>,\n                 dependencies = LazyLibrary[], on_load_callback = nothing)\n \n-Represents a lazily-loaded library that opens itself and its dependencies on first usage\n-in a `dlopen()`, `dlsym()`, or `ccall()` usage.  While this structure contains the\n-ability to run arbitrary code on first load via `on_load_callback`, we caution that this\n-should be used sparingly, as it is not expected that `ccall()` should result in large\n-amounts of Julia code being run.  You may call `ccall()` from within the\n-`on_load_callback` but only for the current library and its dependencies, and user should\n-not call `wait()` on any tasks within the on load callback.\n+Represents a lazily-loaded shared library that delays loading itself and its dependencies\n+until first use in a `ccall()`, `@ccall`, `dlopen()`, `dlsym()`, `dlpath()`, or `cglobal()`.\n+This is a thread-safe mechanism for on-demand library initialization.\n+\n+# Arguments\n+\n+- `name`: Library name (or lazy path computation) as a `String`,\n+  [`LazyLibraryPath`](@ref), or [`BundledLazyLibraryPath`](@ref).\n+- `flags`: Optional `dlopen` flags (default: `RTLD_LAZY | RTLD_DEEPBIND`). See [`dlopen`](@ref).\n+- `dependencies`: Vector of `LazyLibrary` object references to load before this one.\n+- `on_load_callback`: Optional function to run arbitrary code on first load (use sparingly,\n+  as it is not expected that `ccall()` should result in large amounts of Julia code being run.\n+  You may call `ccall()` from within the `on_load_callback` but only for the current library\n+  and its dependencies, and user should not call `wait()` on any tasks within the on load\n+  callback as they may deadlock).\n+\n+The dlopen operation is thread-safe: only one thread loads the library, acquired after the\n+release store of the reference to each dependency from loading of each dependency. Other\n+tasks block until loading completes. The handle is then cached and reused for all subsequent\n+calls (there is no dlclose for lazy library and dlclose should not be called on the returned\n+handled).\n+\n+# Examples\n+\n+```julia\n+# Basic usage\n+const mylib = LazyLibrary(\"libmylib\")\n+@ccall mylib.myfunc(42::Cint)::Cint\n+\n+# With dependencies\n+const libfoo = LazyLibrary(\"libfoo\")\n+const libbar = LazyLibrary(\"libbar\"; dependencies=[libfoo])\n+```\n+\n+For more examples including platform-specific libraries, lazy path construction, and\n+migration from `__init__()` patterns, see the manual section on\n+[Using LazyLibrary for Lazy Loading](@ref man-lazylibrary).\n+\n+!!! compat \"Julia 1.11\"\n+    `LazyLibrary` was added in Julia 1.11.\n+\n+See also [`LazyLibraryPath`](@ref), [`BundledLazyLibraryPath`](@ref), [`dlopen`](@ref),\n+[`dlsym`](@ref), [`add_dependency!`](@ref).\n \"\"\"\n mutable struct LazyLibrary\n     # Name and flags to open with\n@@ -386,7 +435,7 @@ mutable struct LazyLibrary\n     # The OncePerProcess is introduced here so that any registered dependencies are\n     # always ephemeral to a given process (instead of, e.g., persisting depending\n     # on whether they were added in the process where this LazyLibrary was created)\n-    dependencies::Base.OncePerProcess{Vector{LazyLibrary}, InitialDependencies}\n+    dependencies::Base.OncePerProcess{Vector{LazyLibrary}, InitialDependencies{LazyLibrary}}\n \n     # Function that get called once upon initial load\n     on_load_callback\n@@ -400,7 +449,7 @@ mutable struct LazyLibrary\n             path,\n             UInt32(flags),\n             Base.OncePerProcess{Vector{LazyLibrary}}(\n-                InitialDependencies(collect(dependencies))\n+                InitialDependencies{LazyLibrary}(dependencies)\n             ),\n             on_load_callback,\n             Base.ReentrantLock(),\n@@ -411,6 +460,23 @@ end\n \n # We support adding dependencies only because of very special situations\n # such as LBT needing to have OpenBLAS_jll added as a dependency dynamically.\n+\"\"\"\n+    add_dependency!(library::LazyLibrary, dependency::LazyLibrary)\n+\n+Dynamically add a dependency that must be loaded before `library`. Only needed when\n+dependencies cannot be determined at construction time.\n+\n+!!! warning\n+    Dependencies added with this function are **ephemeral** and only persist within the\n+    current process. They will not persist across precompilation boundaries.\n+\n+Prefer specifying dependencies in the `LazyLibrary` constructor when possible.\n+\n+!!! compat \"Julia 1.11\"\n+    `add_dependency!` was added in Julia 1.11.\n+\n+See also [`LazyLibrary`](@ref).\n+\"\"\"\n function add_dependency!(ll::LazyLibrary, dep::LazyLibrary)\n     @lock ll.lock begin\n         push!(ll.dependencies(), dep)"
    },
    {
      "sha": "2e6098864cabd19e7a2cc46c7f22649b77405caf",
      "filename": "doc/src/manual/calling-c-and-fortran-code.md",
      "status": "modified",
      "additions": 149,
      "deletions": 33,
      "changes": 182,
      "blob_url": "https://github.com/JuliaLang/julia/blob/540145975d405f053bfae4ab622f8e1d3d94669e/doc%2Fsrc%2Fmanual%2Fcalling-c-and-fortran-code.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/540145975d405f053bfae4ab622f8e1d3d94669e/doc%2Fsrc%2Fmanual%2Fcalling-c-and-fortran-code.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fmanual%2Fcalling-c-and-fortran-code.md?ref=540145975d405f053bfae4ab622f8e1d3d94669e",
      "patch": "@@ -854,18 +854,135 @@ it must be handled in other ways.\n \n In some cases, the exact name or path of the needed library is not known in\n advance and must be computed at run time. To handle such cases, the library\n-component specification can be a value such as `Libdl.LazyLibrary`. For\n-example, in `@ccall blas.dgemm()`, there can be a global defined as `const blas\n-= LazyLibrary(\"libblas\")`. The runtime will call `dlsym(:dgemm, dlopen(blas))`\n-when the `@ccall` itself is executed. The `Libdl.dlopen` function can be\n-overloaded for custom types to provide alternate behaviors. However, it is\n-assumed that the library location does not change once it is determined, so the\n-result of the call can be cached and reused. Therefore, the number of times the\n-expression executes is unspecified, and returning different values for multiple\n-calls results in unspecified behavior.\n-\n-If even more flexibility is needed, it is possible\n-to use computed values as function names by staging through [`eval`](@ref) as follows:\n+component specification can be a value such as `Libdl.LazyLibrary`. The runtime\n+will call `Libdl.dlopen` on that object when first used by a `ccall`.\n+\n+### [Using LazyLibrary for Lazy Loading](@id man-lazylibrary)\n+\n+[`Libdl.LazyLibrary`](@ref) provides a thread-safe mechanism for deferring library loading\n+until first use. This is the recommended approach for library initialization in modern Julia code.\n+\n+A `LazyLibrary` represents a library that opens itself (and its dependencies) automatically\n+on first use in a `ccall()`, `@ccall`, `dlopen()`, `dlsym()`, `dlpath()`, or `cglobal()`.\n+The library is loaded exactly once in a thread-safe manner, and subsequent calls reuse the\n+loaded library handle.\n+\n+#### Basic Usage\n+\n+```julia\n+using Libdl\n+\n+# Define a LazyLibrary as a const for optimal performance\n+const libz = LazyLibrary(\"libz\")\n+\n+# Use directly in @ccall - library loads automatically on first call\n+@ccall libz.deflate(strm::Ptr{Cvoid}, flush::Cint)::Cint\n+\n+# Also works with ccall\n+ccall((:inflate, libz), Cint, (Ptr{Cvoid}, Cint), strm, flush)\n+```\n+\n+#### Platform-Specific Libraries\n+\n+For code that needs to work across different platforms:\n+\n+```julia\n+const mylib = LazyLibrary(\n+    if Sys.iswindows()\n+        \"mylib.dll\"\n+    elseif Sys.isapple()\n+        \"libmylib.dylib\"\n+    else\n+        \"libmylib.so\"\n+    end\n+)\n+```\n+\n+#### Libraries with Dependencies\n+\n+When a library depends on other libraries, specify the dependencies to ensure\n+they load in the correct order:\n+\n+```julia\n+const libfoo = LazyLibrary(\"libfoo\")\n+const libbar = LazyLibrary(\"libbar\"; dependencies=[libfoo])\n+\n+# When libbar is first used, libfoo is loaded first automatically\n+@ccall libbar.bar_function(x::Cint)::Cint\n+```\n+\n+#### Lazy Path Construction\n+\n+For libraries whose paths are determined at runtime, use `LazyLibraryPath`:\n+\n+```julia\n+# Path is constructed when library is first accessed\n+const mylib = LazyLibrary(LazyLibraryPath(artifact_dir, \"lib\", \"libmylib.so\"))\n+```\n+\n+#### Initialization Callbacks\n+\n+If a library requires initialization after loading:\n+\n+```julia\n+const mylib = LazyLibrary(\"libmylib\";\n+    on_load_callback = () -> @ccall mylib.initialize()::Cvoid\n+)\n+```\n+\n+!!! warning\n+    The `on_load_callback` should be minimal and must not call `wait()` on any tasks.\n+    It is called exactly once by the thread that loads the library.\n+\n+#### Conversion from `__init__()` Pattern\n+\n+Before `LazyLibrary`, library paths were often computed in `__init__()` functions.\n+This pattern can be replaced with `LazyLibrary` for better performance and thread safety.\n+\n+Old pattern using `__init__()`:\n+\n+```julia\n+# Old: Library path computed in __init__()\n+libmylib_path = \"\"\n+\n+function __init__(\n+    # Loads library on startup, whether it is used or not\n+    global libmylib_path = find_library([\"libmylib\"])\n+end\n+\n+function myfunc(x)\n+    ccall((:cfunc, libmylib_path), Cint, (Cint,), x)\n+end\n+```\n+\n+New pattern using `LazyLibrary`:\n+\n+```julia\n+# New: Library as const, no __init__() needed\n+const libmylib = LazyLibrary(\"libmylib\")\n+\n+function myfunc(x)\n+    # Library loads automatically just before calling `cfunc`\n+    @ccall libmylib.cfunc(x::Cint)::Cint\n+end\n+```\n+\n+For more details, see the [`Libdl.LazyLibrary`](@ref) documentation.\n+\n+### Overloading `dlopen` for Custom Types\n+\n+The runtime will call `dlsym(:function, dlopen(library)::Ptr{Cvoid})` when a `@ccall` is executed.\n+The `Libdl.dlopen` function can be overloaded for custom types to provide alternate behaviors.\n+However, it is assumed that the library location and handle does not change\n+once it is determined, so the result of the call may be cached and reused.\n+Therefore, the number of times the `dlopen` expression executes is unspecified,\n+and returning different values for multiple calls will results in unspecified\n+(but valid) behavior.\n+\n+### Computed Function Names\n+\n+If even more flexibility is needed, it is possible to use computed values as\n+function names by staging through [`eval`](@ref) as follows:\n \n ```julia\n @eval @ccall \"lib\".$(string(\"a\", \"b\"))()::Cint\n@@ -876,38 +993,37 @@ expression, which is then evaluated. Keep in mind that `eval` only operates at t\n so within this expression local variables will not be available (unless their values are substituted\n with `$`). For this reason, `eval` is typically only used to form top-level definitions, for example\n when wrapping libraries that contain many similar functions.\n-A similar example can be constructed for [`@cfunction`](@ref).\n-\n-However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep\n-reading.\n-The next section discusses how to use indirect calls to efficiently achieve a similar effect.\n \n-## Indirect Calls\n+### Indirect Calls\n \n-The first argument to `@ccall` can also be an expression evaluated at run time. In this\n-case, the expression must evaluate to a `Ptr`, which will be used as the address of the native\n-function to call. This behavior occurs when the first `@ccall` argument contains references\n-to non-constants, such as local variables, function arguments, or non-constant globals.\n+The first argument to `@ccall` can also be an expression to be evaluated at run\n+time, each time it is used. In this case, the expression must evaluate to a\n+`Ptr`, which will be used as the address of the native function to call. This\n+behavior occurs when the first `@ccall` argument is marked with `$` and when\n+the first `ccall` argument is not a simple constant literal or expression in\n+`()`. The argument can be any expression and can use local variables and\n+arguments and can return a different value every time.\n \n-For example, you might look up the function via `dlsym`,\n-then cache it in a shared reference for that session. For example:\n+For example, you might implement a macro similar to `cglobal` that looks up the\n+function via `dlsym`, then caches the pointer in a shared reference (which is\n+auto reset to C_NULL during precompile saving).\n+For example:\n \n ```julia\n macro dlsym(lib, func)\n-    z = Ref{Ptr{Cvoid}}(C_NULL)\n+    z = Ref(C_NULL)\n     quote\n-        let zlocal = $z[]\n-            if zlocal == C_NULL\n-                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\n-                $z[] = zlocal\n-            end\n-            zlocal\n+        local zlocal = $z[]\n+        if zlocal == C_NULL\n+            zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\n+            $z[] = zlocal\n         end\n+        zlocal\n     end\n end\n \n-mylibvar = Libdl.dlopen(\"mylib\")\n-@ccall $(@dlsym(mylibvar, \"myfunc\"))()::Cvoid\n+const mylibvar = LazyLibrary(\"mylib\")\n+@ccall $(@dlsym(dlopen(mylibvar), \"myfunc\"))()::Cvoid\n ```\n \n ## Closure cfunctions"
    },
    {
      "sha": "3cd69486e5155d7eedf82f6617331fd4c4ea518a",
      "filename": "stdlib/Libdl/docs/src/index.md",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/540145975d405f053bfae4ab622f8e1d3d94669e/stdlib%2FLibdl%2Fdocs%2Fsrc%2Findex.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/540145975d405f053bfae4ab622f8e1d3d94669e/stdlib%2FLibdl%2Fdocs%2Fsrc%2Findex.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FLibdl%2Fdocs%2Fsrc%2Findex.md?ref=540145975d405f053bfae4ab622f8e1d3d94669e",
      "patch": "@@ -21,3 +21,12 @@ Libdl.dlpath\n Libdl.find_library\n Libdl.DL_LOAD_PATH\n ```\n+\n+# Lazy Library Loading\n+\n+```@docs\n+Libdl.LazyLibrary\n+Libdl.LazyLibraryPath\n+Libdl.BundledLazyLibraryPath\n+Libdl.add_dependency!\n+```"
    },
    {
      "sha": "8556387786571f69d6a695639a6128a4ccac7dcb",
      "filename": "stdlib/Libdl/src/Libdl.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/540145975d405f053bfae4ab622f8e1d3d94669e/stdlib%2FLibdl%2Fsrc%2FLibdl.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/540145975d405f053bfae4ab622f8e1d3d94669e/stdlib%2FLibdl%2Fsrc%2FLibdl.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FLibdl%2Fsrc%2FLibdl.jl?ref=540145975d405f053bfae4ab622f8e1d3d94669e",
      "patch": "@@ -11,6 +11,8 @@ export DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOC\n     RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n     dlpath, find_library, dlext, dllist, LazyLibrary, LazyLibraryPath, BundledLazyLibraryPath\n \n+public add_dependency!\n+\n import Base.Libc.Libdl: DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n                         RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n                         dlpath, find_library, dlext, dllist, LazyLibrary, LazyLibraryPath,"
    }
  ]
}