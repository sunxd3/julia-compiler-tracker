{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59819",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59819/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59819/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59819/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59819",
  "id": 3507715084,
  "node_id": "PR_kwDOABkWpM6tVyQQ",
  "number": 59819,
  "title": "The Fanciest REPL History in the Land",
  "user": {
    "login": "tecosaur",
    "id": 20903656,
    "node_id": "MDQ6VXNlcjIwOTAzNjU2",
    "avatar_url": "https://avatars.githubusercontent.com/u/20903656?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tecosaur",
    "html_url": "https://github.com/tecosaur",
    "followers_url": "https://api.github.com/users/tecosaur/followers",
    "following_url": "https://api.github.com/users/tecosaur/following{/other_user}",
    "gists_url": "https://api.github.com/users/tecosaur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tecosaur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tecosaur/subscriptions",
    "organizations_url": "https://api.github.com/users/tecosaur/orgs",
    "repos_url": "https://api.github.com/users/tecosaur/repos",
    "events_url": "https://api.github.com/users/tecosaur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tecosaur/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 42281298,
      "node_id": "MDU6TGFiZWw0MjI4MTI5OA==",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/REPL",
      "name": "REPL",
      "color": "c7def8",
      "default": false,
      "description": "Julia's REPL (Read Eval Print Loop)"
    },
    {
      "id": 269951426,
      "node_id": "MDU6TGFiZWwyNjk5NTE0MjY=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/strings",
      "name": "strings",
      "color": "006b75",
      "default": false,
      "description": "\"Strings!\""
    },
    {
      "id": 511192218,
      "node_id": "MDU6TGFiZWw1MTExOTIyMTg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/display%20and%20printing",
      "name": "display and printing",
      "color": "e5ff9e",
      "default": false,
      "description": "Aesthetics and correctness of printed representations of objects."
    },
    {
      "id": 706812401,
      "node_id": "MDU6TGFiZWw3MDY4MTI0MDE=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/stdlib",
      "name": "stdlib",
      "color": "6F689E",
      "default": false,
      "description": "Julia's standard library"
    },
    {
      "id": 4232017300,
      "node_id": "LA_kwDOABkWpM78P3WU",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/don't%20squash",
      "name": "don't squash",
      "color": "ff4500",
      "default": false,
      "description": "Don't squash merge"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 60,
  "created_at": "2025-10-12T18:58:03Z",
  "updated_at": "2025-10-31T15:01:11Z",
  "closed_at": "2025-10-25T11:00:49Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59819",
    "html_url": "https://github.com/JuliaLang/julia/pull/59819",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59819.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59819.patch",
    "merged_at": "2025-10-25T11:00:49Z"
  },
  "body": "## The Fanciest REPL History in the Land :sparkles: \r\n\r\nDo you dread typing out code for the second time? Are you a particular enjoyed of REPL history?\r\n\r\nWell, I know I am, and for years I have *yearned* for something better than the current `readline`-style completion, better than OhMyREPL.jl's fzf-driven completion, better than any REPL history I've seen before!\r\n\r\nIt's not quite finished baking, but we're onto the final stretch :grinning:\r\n\r\n[repl_history_demo.webm](https://github.com/user-attachments/assets/9cb0f4b1-7da4-43da-b6df-017972e1227e)\r\n\r\nThanks to @kdheepak, @jakobnissen, and @digital-carver for helping me design the UI and UX over on Zulip ([#repl > Revamped REPL history](https://julialang.zulipchat.com/#narrow/channel/404905-repl/topic/Revamped.20REPL.20history/with/544416134)).\r\n\r\n## Features\r\n\r\n- Zippy searching\r\n  - Event-driven asynchronous filtering UI\r\n  - Incremental, resumable searching with dynamic batch sizes\r\n  - Log-structured search checkpoints\r\n- Multi-selection\r\n- Faster histfile parsing (~2x)\r\n- Multiple search modes\r\n- A friendly help page\r\n- Syntax highlighting\r\n- Save multiple items to a file or your clipboard\r\n\r\n## TODO\r\n\r\n- [x] Introduce annotation-preserving `replace` method\r\n- [x] Thoroughly test the new `replace` method\r\n- [ ] Ask somebody more compiler-y about the performance pitfalls of the `replace` method (see: the `REVIEW: ...` code comments in `annotated_io.jl`)\r\n- [x] Implement flashy REPL history\r\n- [x] Restore up/down arrow history rotation in the REPL (collateral damage of over-zealous deleting)\r\n- [x] Create a new test set for the new history\r\n- [x] Make sure that enough is precompiled to be relatively snappy\r\n\r\n-----\r\n\r\nThis PR is on top of #59778, because I think I can safely assume that will be merged first.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59819/reactions",
    "total_count": 66,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 10,
    "confused": 0,
    "heart": 39,
    "rocket": 17,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59819/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "a18aacd81742d03bc312c40983611ebdaf3cca0a",
      "filename": "NEWS.md",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/NEWS.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/NEWS.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/NEWS.md?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -99,6 +99,7 @@ Standard library changes\n * The Julia REPL now support bracketed paste on Windows which should significantly speed up pasting large code blocks into the REPL ([#59825])\n * The REPL now provides syntax highlighting for input as you type. See the REPL docs for more info about customization.\n * The REPL now supports automatic insertion of closing brackets, parentheses, and quotes. See the REPL docs for more info about customization.\n+* History searching has been rewritten to use a new interactive modal dialogue, using a fzf-like style.\n * The display of `AbstractChar`s in the main REPL mode now includes LaTeX input information like what is shown in help mode ([#58181]).\n * Display of repeated frames and cycles in stack traces has been improved by bracketing them in the trace and treating them consistently ([#55841]).\n "
    },
    {
      "sha": "52db136cc66433837f0bf27cd3ab6e00c09b7db0",
      "filename": "base/regex.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/base%2Fregex.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/base%2Fregex.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fregex.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -649,17 +649,17 @@ replace_err(repl) = error(\"Bad replacement string: $repl\")\n function _write_capture(io::IO, group::Int, str, r, re::RegexAndMatchData)\n     len = PCRE.substring_length_bynumber(re.match_data, group)\n     # in the case of an optional group that doesn't match, len == 0\n-    len == 0 && return\n+    len == 0 && return len\n     ensureroom(io, len+1)\n     PCRE.substring_copy_bynumber(re.match_data, group,\n         pointer(io.data, io.ptr), len+1)\n     io.ptr += len\n     io.size = max(io.size, io.ptr - 1)\n-    nothing\n+    return len\n end\n function _write_capture(io::IO, group::Int, str, r, re)\n     group == 0 || replace_err(\"pattern is not a Regex\")\n-    return print(io, SubString(str, r))\n+    return write(io, SubString(str, r))\n end\n \n \n@@ -673,12 +673,13 @@ function _replace(io, repl_s::SubstitutionString, str, r, re)\n     repl = unescape_string(repl_s.string, KEEP_ESC)\n     i = firstindex(repl)\n     e = lastindex(repl)\n+    nb = 0\n     while i <= e\n         if repl[i] == SUB_CHAR\n             next_i = nextind(repl, i)\n             next_i > e && replace_err(repl)\n             if repl[next_i] == SUB_CHAR\n-                write(io, SUB_CHAR)\n+                nb += write(io, SUB_CHAR)\n                 i = nextind(repl, next_i)\n             elseif isdigit(repl[next_i])\n                 group = parse(Int, repl[next_i])\n@@ -691,7 +692,7 @@ function _replace(io, repl_s::SubstitutionString, str, r, re)\n                         break\n                     end\n                 end\n-                _write_capture(io, group, str, r, re)\n+                nb += _write_capture(io, group, str, r, re)\n             elseif repl[next_i] == GROUP_CHAR\n                 i = nextind(repl, next_i)\n                 if i > e || repl[i] != LBRACKET\n@@ -713,16 +714,17 @@ function _replace(io, repl_s::SubstitutionString, str, r, re)\n                 else\n                     group = -1\n                 end\n-                _write_capture(io, group, str, r, re)\n+                nb += _write_capture(io, group, str, r, re)\n                 i = nextind(repl, i)\n             else\n                 replace_err(repl)\n             end\n         else\n-            write(io, repl[i])\n+            nb += write(io, repl[i])\n             i = nextind(repl, i)\n         end\n     end\n+    nb\n end\n \n struct RegexMatchIterator{S <: AbstractString}"
    },
    {
      "sha": "60c91be24ebfb7642c8105aba020c5294f0bb312",
      "filename": "base/strings/annotated_io.jl",
      "status": "modified",
      "additions": 154,
      "deletions": 15,
      "changes": 169,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/base%2Fstrings%2Fannotated_io.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/base%2Fstrings%2Fannotated_io.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fstrings%2Fannotated_io.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -163,18 +163,18 @@ This is implemented so that one can say write an `AnnotatedString` to an\n `AnnotatedIOBuffer` one character at a time without needlessly producing a\n new annotation for each character.\n \"\"\"\n-function _insert_annotations!(io::AnnotatedIOBuffer, annotations::Vector{RegionAnnotation}, offset::Int = position(io))\n+function _insert_annotations!(annots::Vector{RegionAnnotation}, newannots::Vector{RegionAnnotation}, offset::Int = 0)\n     run = 0\n-    if !isempty(io.annotations) && last(last(io.annotations).region) == offset\n-        for i in reverse(axes(annotations, 1))\n-            annot = annotations[i]\n+    if !isempty(annots) && last(last(annots).region) == offset\n+        for i in reverse(axes(newannots, 1))\n+            annot = newannots[i]\n             first(annot.region) == 1 || continue\n-            i <= length(io.annotations) || continue\n-            if annot.label == last(io.annotations).label && annot.value == last(io.annotations).value\n+            i <= length(annots) || continue\n+            if annot.label == last(annots).label && annot.value == last(annots).value\n                 valid_run = true\n                 for runlen in 1:i\n-                    new = annotations[begin+runlen-1]\n-                    old = io.annotations[end-i+runlen]\n+                    new = newannots[begin+runlen-1]\n+                    old = annots[end-i+runlen]\n                     if last(old.region) != offset || first(new.region) != 1 || old.label != new.label || old.value != new.value\n                         valid_run = false\n                         break\n@@ -188,18 +188,157 @@ function _insert_annotations!(io::AnnotatedIOBuffer, annotations::Vector{RegionA\n         end\n     end\n     for runindex in 0:run-1\n-        old_index = lastindex(io.annotations) - run + 1 + runindex\n-        old = io.annotations[old_index]\n-        new = annotations[begin+runindex]\n-        io.annotations[old_index] = setindex(old, first(old.region):last(new.region)+offset, :region)\n+        old_index = lastindex(annots) - run + 1 + runindex\n+        old = annots[old_index]\n+        new = newannots[begin+runindex]\n+        extannot = (region = first(old.region):last(new.region)+offset,\n+                    label = old.label,\n+                    value = old.value)\n+        annots[old_index] = extannot\n     end\n-    for index in run+1:lastindex(annotations)\n-        annot = annotations[index]\n+    for index in run+1:lastindex(newannots)\n+        annot = newannots[index]\n         start, stop = first(annot.region), last(annot.region)\n-        push!(io.annotations, setindex(annotations[index], start+offset:stop+offset, :region))\n+        # REVIEW: For some reason, construction of `newannot`\n+        # can be a significant contributor to the overall runtime\n+        # of this function. For instance, executing:\n+        #\n+        #     replace(AnnotatedIOBuffer(), S\"apple\",\n+        #             'e' => S\"{red:x}\", 'p' => S\"{green:y}\")\n+        #\n+        # results in 3 calls to `_insert_annotations!`. It takes\n+        # ~570ns in total, compared to ~200ns if we push `annot`\n+        # instead of `newannot`. Commenting out the `_insert_annotations!`\n+        # line reduces the runtime to ~170ns, from which we can infer\n+        # that constructing `newannot` is somehow responsible for\n+        # a ~30ns -> ~400ns (~13x) increase in runtime!!\n+        # This also comes with a marginal increase in allocations\n+        # (compared to the commented out version) of 2 -> 14 (250b -> 720b).\n+        #\n+        # This seems quite strange, but I haven't dug into the generated\n+        # LLVM or ASM code. If anybody reading this is interested in checking\n+        # this out, that would be brilliant \ud83d\ude4f.\n+        #\n+        # What I have done is found that \"direct tuple reconstruction\"\n+        # (as below) is several times faster than using `setindex`.\n+        newannot = (region = start+offset:stop+offset,\n+                    label = annot.label,\n+                    value = annot.value)\n+        push!(annots, newannot)\n     end\n end\n \n+_insert_annotations!(io::AnnotatedIOBuffer, newannots::Vector{RegionAnnotation}, offset::Int = position(io)) =\n+    _insert_annotations!(io.annotations, newannots, offset)\n+\n+# String replacement\n+\n+# REVIEW: For some reason the `Core.kwcall` indirection seems to cause a\n+# substantial slowdown here. If we remove `; count` from the signature\n+# and run the sample code above in `_insert_annotations!`, the runtime\n+# drops from ~4400ns to ~580ns (~7x faster). I cannot guess why this is.\n+function replace(out::AnnotatedIOBuffer, str::AnnotatedString, pat_f::Pair...; count = typemax(Int))\n+    if count == 0 || isempty(pat_f)\n+        write(out, str)\n+        return out\n+    end\n+    e1, patterns, replacers, repspans, notfound = _replace_init(str.string, pat_f, count)\n+    if notfound\n+        foreach(_free_pat_replacer, patterns)\n+        write(out, str)\n+        return out\n+    end\n+    # Modelled after `Base.annotated_chartransform`, but needing\n+    # to handle a bit more complexity.\n+    isappending = eof(out)\n+    newannots = empty(out.annotations)\n+    bytepos = bytestart = firstindex(str.string)\n+    replacements = [(region = (bytestart - 1):(bytestart - 1), offset = position(out))]\n+    nrep = 1\n+    while nrep <= count\n+        repspans, ridx, xspan, newbytes, bytepos = @inline _replace_once(\n+            out.io, str.string, bytestart, e1, patterns, replacers, repspans, count, nrep, bytepos)\n+        first(xspan) >= e1 && break\n+        nrep += 1\n+        # NOTE: When the replaced pattern ends with a multi-codeunit character,\n+        # `xspan` only covers up to the start of that character. However,\n+        # for us to correctly account for the changes to the string we need\n+        # the /entire/ span of codeunits that were replaced.\n+        if !isempty(xspan) && codeunit(str.string, last(xspan)) > 0x80\n+            xspan = first(xspan):nextind(str.string, last(xspan))-1\n+        end\n+        drift = last(replacements).offset\n+        thisrep = (region = xspan, offset = drift + newbytes - length(xspan))\n+        destoff = first(xspan) - 1 + drift\n+        push!(replacements, thisrep)\n+        replacement = replacers[ridx]\n+        _isannotated(replacement) || continue\n+        annots = annotations(replacement)\n+        annots\u2032 = if eltype(annots) == Annotation # When it's a char not a string\n+            region = 1:newbytes\n+            [@NamedTuple{region::UnitRange{Int}, label::Symbol, value}((region, label, value))\n+             for (; label, value) in annots]\n+        else\n+            annots\n+        end::Vector{RegionAnnotation}\n+        _insert_annotations!(newannots, annots\u2032, destoff)\n+    end\n+    push!(replacements, (region = e1:(e1-1), offset = last(replacements).offset))\n+    foreach(_free_pat_replacer, patterns)\n+    write(out.io, SubString(str.string, bytepos))\n+    # NOTE: To enable more efficient annotation clearing,\n+    # we make use of the fact that `_replace_once` picks\n+    # replacements ordered by their match start position.\n+    # This means that the start of `.region`s in\n+    # `replacements` is monotonically increasing.\n+    isappending || _clear_annotations_in_region!(out.annotations, first(replacements).offset:position(out))\n+    for (; region, label, value) in str.annotations\n+        start, stop = first(region), last(region)\n+        prioridx = searchsortedlast(\n+            replacements, (region = start:start, offset = 0),\n+            by = r -> first(r.region))\n+        postidx = searchsortedfirst(\n+            replacements, (region = stop:stop, offset = 0),\n+            by = r -> first(r.region))\n+        priorrep, postrep = replacements[prioridx], replacements[postidx]\n+        if prioridx == postidx && start >= first(priorrep.region) && stop <= last(priorrep.region)\n+            # Region contained with a replacement\n+            continue\n+        elseif postidx - prioridx <= 1 && start > last(priorrep.region) && stop < first(postrep.region)\n+            # Lies between replacements\n+            shiftregion = (start + priorrep.offset):(stop + priorrep.offset)\n+            shiftann = (region = shiftregion, label, value)\n+            push!(out.annotations, shiftann)\n+        else\n+            # Split between replacements\n+            prevrep = replacements[max(begin, prioridx - 1)]\n+            for rep in @view replacements[max(begin, prioridx - 1):min(end, postidx + 1)]\n+                gap = max(start, last(prevrep.region)+1):min(stop, first(rep.region)-1)\n+                if !isempty(gap)\n+                    shiftregion = (first(gap) + prevrep.offset):(last(gap) + prevrep.offset)\n+                    shiftann = (; region = shiftregion, label, value)\n+                    push!(out.annotations, shiftann)\n+                end\n+                prevrep = rep\n+            end\n+        end\n+    end\n+    append!(out.annotations, newannots)\n+    out\n+end\n+\n+replace(out::IO, str::AnnotatedString, pat_f::Pair...; count=typemax(Int)) =\n+    replace(out, str.string, pat_f...; count)\n+\n+function replace(str::AnnotatedString, pat_f::Pair...; count=typemax(Int))\n+    isempty(pat_f) || iszero(count) && return str\n+    out = AnnotatedIOBuffer()\n+    replace(out, str, pat_f...; count)\n+    read(seekstart(out), AnnotatedString)\n+end\n+\n+# Printing\n+\n function printstyled end\n \n # NOTE: This is an interim solution to the invalidations caused"
    },
    {
      "sha": "eba0ed22aee4d92f4e72c9f4a2b3712cc41e0ca5",
      "filename": "base/strings/unicode.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/base%2Fstrings%2Funicode.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/base%2Fstrings%2Funicode.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fstrings%2Funicode.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -639,6 +639,7 @@ julia> uppercase(\"Julia\")\n \"\"\"\n uppercase(s::AbstractString) = map(uppercase, s)\n uppercase(s::AnnotatedString) = annotated_chartransform(uppercase, s)\n+uppercase(s::SubString{<:AnnotatedString}) = uppercase(AnnotatedString(s))\n \n \"\"\"\n     lowercase(s::AbstractString)\n@@ -655,6 +656,7 @@ julia> lowercase(\"STRINGS AND THINGS\")\n \"\"\"\n lowercase(s::AbstractString) = map(lowercase, s)\n lowercase(s::AnnotatedString) = annotated_chartransform(lowercase, s)\n+lowercase(s::SubString{<:AnnotatedString}) = lowercase(AnnotatedString(s))\n \n \"\"\"\n     titlecase(s::AbstractString; [wordsep::Function], strict::Bool=true)::String\n@@ -720,6 +722,9 @@ function titlecase(s::AnnotatedString; wordsep::Function = !isletter, strict::Bo\n     end\n end\n \n+titlecase(s::SubString{<:AnnotatedString}; wordsep::Function = !isletter, strict::Bool=true) =\n+    titlecase(AnnotatedString(s); wordsep=wordsep, strict=strict)\n+\n \"\"\"\n     uppercasefirst(s::AbstractString)::String\n \n@@ -754,6 +759,7 @@ function uppercasefirst(s::AnnotatedString)\n         end\n     end\n end\n+uppercasefirst(s::SubString{<:AnnotatedString}) = uppercasefirst(AnnotatedString(s))\n \n \"\"\"\n     lowercasefirst(s::AbstractString)\n@@ -787,6 +793,7 @@ function lowercasefirst(s::AnnotatedString)\n         end\n     end\n end\n+lowercasefirst(s::SubString{<:AnnotatedString}) = lowercasefirst(AnnotatedString(s))\n \n ############################################################################\n # iterators for grapheme segmentation"
    },
    {
      "sha": "d8cc95d9ec801cc40155882f5aa6bac08d803896",
      "filename": "base/strings/util.jl",
      "status": "modified",
      "additions": 57,
      "deletions": 35,
      "changes": 92,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/base%2Fstrings%2Futil.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/base%2Fstrings%2Futil.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fstrings%2Futil.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -975,11 +975,22 @@ rsplit(str::AbstractString;\n       limit::Integer=0, keepempty::Bool=false) =\n     rsplit(str, isspace; limit, keepempty)\n \n-_replace(io, repl, str, r, pattern) = print(io, repl)\n+_replace(io, repl::Union{<:AbstractString, <:AbstractChar}, str, r, pattern) =\n+    write(io, repl)\n+function _replace(io, repl, str, r, pattern)\n+    if applicable(position, io)\n+        p1 = position(io)\n+        print(io, repl)\n+        p2 = position(io)\n+        p2 - p1\n+    else\n+        write(io, repr(repl))\n+    end\n+end\n _replace(io, repl::Function, str, r, pattern) =\n-    print(io, repl(SubString(str, first(r), last(r))))\n+    _replace(io, repl(SubString(str, first(r), last(r))), str, r, pattern)\n _replace(io, repl::Function, str, r, pattern::Function) =\n-    print(io, repl(str[first(r)]))\n+    _replace(io, repl(str[first(r)]), str, r, pattern)\n \n _pat_replacer(x) = x\n _free_pat_replacer(x) = nothing\n@@ -1009,45 +1020,56 @@ end\n function _replace_finish(io::IO, str, count::Int,\n                          e1::Int, patterns::Tuple, replaces::Tuple, rs::Tuple)\n     n = 1\n-    i = a = firstindex(str)\n-    while true\n-        p = argmin(map(first, rs)) # TODO: or argmin(rs), to pick the shortest first match ?\n-        r = rs[p]\n-        j, k = first(r), last(r)\n-        j > e1 && break\n-        if i == a || i <= k\n-            # copy out preserved portion\n-            GC.@preserve str unsafe_write(io, pointer(str, i), UInt(j-i))\n-            # copy out replacement string\n-            _replace(io, replaces[p], str, r, patterns[p])\n-        end\n-        if k < j\n-            i = j\n-            j == e1 && break\n-            k = nextind(str, j)\n-        else\n-            i = k = nextind(str, k)\n-        end\n-        n == count && break\n-        let k = k\n-            rs = map(patterns, rs) do p, r\n-                if first(r) < k\n-                    r = findnext(p, str, k)\n-                    if r === nothing || first(r) == 0\n-                        return e1+1:0\n-                    end\n-                    r isa Int && (r = r:r) # findnext / performance fix\n-                end\n-                return r\n-            end\n-        end\n+    i = start = firstindex(str)\n+    while n <= count\n+        rs, _, r, _, i = @inline _replace_once(\n+            io, str, start, e1, patterns, replaces, rs, count, n, i)\n+        first(r) >= e1 && break\n         n += 1\n     end\n     foreach(_free_pat_replacer, patterns)\n     write(io, SubString(str, i))\n     return io\n end\n \n+function _replace_once(io::IO, str, start::Int, e1::Int,\n+                       patterns::Tuple, replaces::Tuple, rs::Tuple,\n+                       count::Int, n::Int, i::Int)\n+    x = argmin(map(first, rs)) # TODO: or argmin(rs), to pick the shortest first match ?\n+    r = rs[x]\n+    j, k = first(r), last(r)\n+    j > e1 && return rs, x, r, 0, i\n+    nb = if i == start || i <= k\n+        # copy out preserved portion\n+        GC.@preserve str unsafe_write(io, pointer(str, i), UInt(j-i))\n+        # copy out replacement string\n+        _replace(io, replaces[x], str, r, patterns[x])\n+    else\n+        0\n+    end\n+    if k < j\n+        i = j\n+        j == e1 && return rs, x, r, nb, i\n+        k = nextind(str, j)\n+    else\n+        i = k = nextind(str, k)\n+    end\n+    n == count && return rs, x, r, nb, i\n+    let k = k\n+        rs = map(patterns, rs) do p, r\n+            if first(r) < k\n+                r = findnext(p, str, k)\n+                if r === nothing || first(r) == 0\n+                    return e1+1:0\n+                end\n+                r isa Int && (r = r:r) # findnext / performance fix\n+            end\n+            return r\n+        end\n+    end\n+    return rs, x, r, nb, i\n+end\n+\n # note: leave str untyped here to make it easier for packages like StringViews to hook in\n function _replace_(io::IO, str, pat_repl::NTuple{N, Pair}, count::Int) where N\n     if count == 0"
    },
    {
      "sha": "6a1249aa21dbaa30d56c761af879da05862b1644",
      "filename": "stdlib/Manifest.toml",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FManifest.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FManifest.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FManifest.toml?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -195,7 +195,7 @@ uuid = \"9abbd945-dff8-562f-b5e8-e1ebf5ef1b79\"\n version = \"1.11.0\"\n \n [[deps.REPL]]\n-deps = [\"FileWatching\", \"InteractiveUtils\", \"JuliaSyntaxHighlighting\", \"Markdown\", \"Sockets\", \"StyledStrings\", \"Unicode\"]\n+deps = [\"Dates\", \"FileWatching\", \"InteractiveUtils\", \"JuliaSyntaxHighlighting\", \"Markdown\", \"Sockets\", \"StyledStrings\", \"Unicode\"]\n uuid = \"3fa0cd96-eef1-5676-8a61-b3b8758bbffb\"\n version = \"1.11.0\"\n "
    },
    {
      "sha": "6b37c892f8aa38cd9408187d21c69462bf656b83",
      "filename": "stdlib/REPL/Project.toml",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2FProject.toml?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -3,6 +3,7 @@ uuid = \"3fa0cd96-eef1-5676-8a61-b3b8758bbffb\"\n version = \"1.11.0\"\n \n [deps]\n+Dates = \"ade2ca70-3891-5945-98fb-dc099432e06a\"\n FileWatching = \"7b1f6079-737a-58dc-b8bc-7a2ca5c1b5ee\"\n InteractiveUtils = \"b77e0a4c-d291-57a0-90e8-8db25a27a240\"\n JuliaSyntaxHighlighting = \"ac6e5ff7-fb65-4e79-a425-ec3bc9c03011\""
    },
    {
      "sha": "fa36f8edb35ecdc90d0613faa905871a1df8f5e4",
      "filename": "stdlib/REPL/docs/src/index.md",
      "status": "modified",
      "additions": 88,
      "deletions": 64,
      "changes": 152,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fdocs%2Fsrc%2Findex.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fdocs%2Fsrc%2Findex.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fdocs%2Fsrc%2Findex.md?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -205,83 +205,92 @@ at the beginning of the line. The prompt for this mode is `pkg>`. It supports it\n entered by pressing `?` at the beginning  of the line of the `pkg>` prompt. The Package manager mode is\n documented in the Pkg manual, available at [https://julialang.github.io/Pkg.jl/v1/](https://julialang.github.io/Pkg.jl/v1/).\n \n-### Search modes\n+### History searching\n \n In all of the above modes, the executed lines get saved to a history file, which can be searched.\n- To initiate an incremental search through the previous history, type `^R` -- the control key\n-together with the `r` key. The prompt will change to ```(reverse-i-search)`':```, and as you\n-type the search query will appear in the quotes. The most recent result that matches the query\n-will dynamically update to the right of the colon as more is typed. To find an older result using\n-the same query, simply type `^R` again.\n+ To initiate an interactive search through the previous history, type `^R` -- the control key\n+together with the `r` key.\n \n-Just as `^R` is a reverse search, `^S` is a forward search, with the prompt ```(i-search)`':```.\n- The two may be used in conjunction with each other to move through the previous or next matching\n-results, respectively.\n+You will be presented with an interactive history viewer. As you type your search history will be filtered;\n+pressing enter will insert the selected history entry into the REPL. Detailed help for the history\n+searcher is available within the REPL with the special queries `?`  and `??`.\n \n All executed commands in the Julia REPL are logged into `~/.julia/logs/repl_history.jl` along with a timestamp of when it was executed\n-and the current REPL mode you were in. Search mode queries this log file in order to find the commands which you previously ran.\n-This can be disabled at startup by passing the `--history-file=no` flag to Julia.\n+and the current REPL mode you were in. The history searcher reads this log file in order to find the commands which you previously ran.\n+Multiple REPLs can write to this file at once, and every time you begin a search the newest history is fetched.\n+Use of this file can be disabled at startup by passing the `--history-file=no` flag to Julia.\n \n ## Key bindings\n \n The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced\n-above (`^D` to exit, `^R` and `^S` for searching), but there are many more. In addition to the\n+above (`^D` to exit, `^R` for searching), but there are many more. In addition to the\n control-key, there are also meta-key bindings. These vary more by platform, but most terminals\n default to using alt- or option- held down with a key to send the meta-key (or can be configured\n to do so), or pressing Esc and then the key.\n \n-| Keybinding          | Description                                                                                                |\n-|:------------------- |:---------------------------------------------------------------------------------------------------------- |\n-| **Program control** |                                                                                                            |\n-| `^D`                | Exit (when buffer is empty)                                                                                |\n-| `^C`                | Interrupt or cancel                                                                                        |\n-| `^L`                | Clear console screen                                                                                       |\n-| Return/Enter, `^J`  | New line, executing if it is complete                                                                      |\n-| meta-Return/Enter   | Insert new line without executing it                                                                       |\n-| `?` or `;`          | Enter help or shell mode (when at start of a line)                                                         |\n-| `^R`, `^S`          | Incremental history search, described above                                                                |\n-| **Cursor movement** |                                                                                                            |\n-| Right arrow, `^F`   | Move right one character                                                                                   |\n-| Left arrow, `^B`    | Move left one character                                                                                    |\n-| ctrl-Right, `meta-F`| Move right one word                                                                                        |\n-| ctrl-Left, `meta-B` | Move left one word                                                                                         |\n-| Home, `^A`          | Move to beginning of line                                                                                  |\n-| End, `^E`           | Move to end of line                                                                                        |\n-| Up arrow, `^P`      | Move up one line (or change to the previous history entry that matches the text before the cursor)         |\n-| Down arrow, `^N`    | Move down one line (or change to the next history entry that matches the text before the cursor)           |\n-| Shift-Arrow Key     | Move cursor according to the direction of the Arrow key, while activating the region (\"shift selection\")   |\n-| Page-up, `meta-P`   | Change to the previous history entry                                                                       |\n-| Page-down, `meta-N` | Change to the next history entry                                                                           |\n-| `meta-<`            | Change to the first history entry (of the current session if it is before the current position in history) |\n-| `meta->`            | Change to the last history entry                                                                           |\n-| `^-Space`           | Set the \"mark\" in the editing region (and de-activate the region if it's active)                           |\n-| `^-Space ^-Space`   | Set the \"mark\" in the editing region and make the region \"active\", i.e. highlighted                        |\n-| `^G`                | De-activate the region (i.e. make it not highlighted)                                                      |\n-| `^X^X`              | Exchange the current position with the mark                                                                |\n-| **Editing**         |                                                                                                            |\n-| Backspace, `^H`     | Delete the previous character, or the whole region when it's active                                        |\n-| Delete, `^D`        | Forward delete one character (when buffer has text)                                                        |\n-| meta-Backspace      | Delete the previous word                                                                                   |\n-| `meta-d`            | Forward delete the next word                                                                               |\n-| `^W`                | Delete previous text up to the nearest whitespace                                                          |\n-| `meta-w`            | Copy the current region in the kill ring                                                                   |\n-| `meta-W`            | \"Kill\" the current region, placing the text in the kill ring                                               |\n-| `^U`                | \"Kill\" to beginning of line, placing the text in the kill ring                                             |\n-| `^K`                | \"Kill\" to end of line, placing the text in the kill ring                                                   |\n-| `^Y`                | \"Yank\" insert the text from the kill ring                                                                  |\n-| `meta-y`            | Replace a previously yanked text with an older entry from the kill ring                                    |\n-| `^T`                | Transpose the characters about the cursor                                                                  |\n-| `meta-Up arrow`     | Transpose current line with line above                                                                     |\n-| `meta-Down arrow`   | Transpose current line with line below                                                                     |\n-| `meta-u`            | Change the next word to uppercase                                                                          |\n-| `meta-c`            | Change the next word to titlecase                                                                          |\n-| `meta-l`            | Change the next word to lowercase                                                                          |\n-| `^/`, `^_`          | Undo previous editing action                                                                               |\n-| `^Q`                | Write a number in REPL and press `^Q` to open editor at corresponding stackframe or method                 |\n-| `meta-Left Arrow`   | Indent the current line on the left                                                                        |\n-| `meta-Right Arrow`  | Indent the current line on the right                                                                       |\n-| `meta-.`            | Insert last word from previous history entry                                                               |\n-| `meta-e`            | Edit the current input in an editor                                                                        |\n+| Keybinding            | Description                                                                                                |\n+|:----------------------|:-----------------------------------------------------------------------------------------------------------|\n+| **Program control**   |                                                                                                            |\n+| `^D`                  | Exit (when buffer is empty)                                                                                |\n+| `^C`                  | Interrupt or cancel                                                                                        |\n+| `^L`                  | Clear console screen                                                                                       |\n+| Return/Enter, `^J`    | New line, executing if it is complete                                                                      |\n+| meta-Return/Enter     | Insert new line without executing it                                                                       |\n+| `?` or `;`            | Enter help or shell mode (when at start of a line)                                                         |\n+| `^R`, `^S`            | Interactive history search, described above                                                                |\n+| **Cursor movement**   |                                                                                                            |\n+| Right arrow, `^F`     | Move right one character                                                                                   |\n+| Left arrow, `^B`      | Move left one character                                                                                    |\n+| ctrl-Right, `meta-F`  | Move right one word                                                                                        |\n+| ctrl-Left, `meta-B`   | Move left one word                                                                                         |\n+| Home, `^A`            | Move to beginning of line                                                                                  |\n+| End, `^E`             | Move to end of line                                                                                        |\n+| Up arrow, `^P`        | Move up one line (or change to the previous history entry that matches the text before the cursor)         |\n+| Down arrow, `^N`      | Move down one line (or change to the next history entry that matches the text before the cursor)           |\n+| Shift-Arrow Key       | Move cursor according to the direction of the Arrow key, while activating the region (\"shift selection\")   |\n+| Page-up, `meta-P`     | Change to the previous history entry                                                                       |\n+| Page-down, `meta-N`   | Change to the next history entry                                                                           |\n+| `meta-<`              | Change to the first history entry (of the current session if it is before the current position in history) |\n+| `meta->`              | Change to the last history entry                                                                           |\n+| `^-Space`             | Set the \"mark\" in the editing region (and de-activate the region if it's active)                           |\n+| `^-Space ^-Space`     | Set the \"mark\" in the editing region and make the region \"active\", i.e. highlighted                        |\n+| `^G`                  | De-activate the region (i.e. make it not highlighted)                                                      |\n+| `^X^X`                | Exchange the current position with the mark                                                                |\n+| **Editing**           |                                                                                                            |\n+| Backspace, `^H`       | Delete the previous character, or the whole region when it's active                                        |\n+| Delete, `^D`          | Forward delete one character (when buffer has text)                                                        |\n+| meta-Backspace        | Delete the previous word                                                                                   |\n+| `meta-d`              | Forward delete the next word                                                                               |\n+| `^W`                  | Delete previous text up to the nearest whitespace                                                          |\n+| `meta-w`              | Copy the current region in the kill ring                                                                   |\n+| `meta-W`              | \"Kill\" the current region, placing the text in the kill ring                                               |\n+| `^U`                  | \"Kill\" to beginning of line, placing the text in the kill ring                                             |\n+| `^K`                  | \"Kill\" to end of line, placing the text in the kill ring                                                   |\n+| `^Y`                  | \"Yank\" insert the text from the kill ring                                                                  |\n+| `meta-y`              | Replace a previously yanked text with an older entry from the kill ring                                    |\n+| `^T`                  | Transpose the characters about the cursor                                                                  |\n+| `meta-Up arrow`       | Transpose current line with line above                                                                     |\n+| `meta-Down arrow`     | Transpose current line with line below                                                                     |\n+| `meta-u`              | Change the next word to uppercase                                                                          |\n+| `meta-c`              | Change the next word to titlecase                                                                          |\n+| `meta-l`              | Change the next word to lowercase                                                                          |\n+| `^/`, `^_`            | Undo previous editing action                                                                               |\n+| `^Q`                  | Write a number in REPL and press `^Q` to open editor at corresponding stackframe or method                 |\n+| `meta-Left Arrow`     | Indent the current line on the left                                                                        |\n+| `meta-Right Arrow`    | Indent the current line on the right                                                                       |\n+| `meta-.`              | Insert last word from previous history entry                                                               |\n+| `meta-e`              | Edit the current input in an editor                                                                        |\n+| **History search**    |                                                                                                            |\n+| Up arrow, `^P`, `^K`  | Move the focus one entry up                                                                                |\n+| Down arrow, `^P`, `^N`| Move the focus one entry down                                                                              |\n+| Page up, `^B`         | Move the focus one page up                                                                                 |\n+| Page down, `^F`       | Move the focus one page down                                                                               |\n+| `meta-<`              | Focus on the first (oldest) history entry                                                                  |\n+| `meta->`              | Focus on the last (most recent) history entry                                                              |\n+| Tab                   | Toggle selection of the currently focused entry                                                            |\n+| Enter                 | Accept the currently focused/selected entries                                                              |\n+| `^S`                  | Save the focused/selected entries to the clipboard or a file                                               |\n+| `^C`, `^D`, `^G`      | Abort the history search                                                                                   |\n \n ### Customizing keybindings\n \n@@ -732,6 +741,21 @@ inherit = \"julia_rainbow_curly_2\"\n \n For a complete list of customizable faces, see the [JuliaSyntaxHighlighting package documentation](https://julialang.github.io/JuliaSyntaxHighlighting.jl/dev/).\n \n+## Customising the history searcher\n+\n+The history searcher uses the following default faces, that can be customised:\n+\n+```toml\n+[REPL.History.search]\n+separator.fg  = \"blue\"\n+prefix.fg = \"magenta\"\n+selected.fg = \"blue\"\n+unselected.fg = \"grey\"\n+hint = { fg = \"magenta\", slant = \"italic\", weight =\"light\" }\n+results.inherit = \"shadow\"\n+match = { weight = \"bold\", underline = true }\n+```\n+\n ## Customizing Colors\n \n The colors used by Julia and the REPL can be customized, as well. To change the"
    },
    {
      "sha": "3a7ff9754368851db6accb744ae119b8822e9ad7",
      "filename": "stdlib/REPL/src/History/History.jl",
      "status": "added",
      "additions": 34,
      "deletions": 0,
      "changes": 34,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2FHistory.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2FHistory.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FHistory%2FHistory.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -0,0 +1,34 @@\n+# This file is a part of Julia. License is MIT: https://julialang.org/license\n+\n+module History\n+\n+using ..REPL: REPL\n+\n+using StyledStrings: @styled_str as @S_str, Face, addface!, face!, annotations, AnnotatedIOBuffer, AnnotatedString, AnnotatedChar\n+using JuliaSyntaxHighlighting: highlight\n+using Base.Threads\n+using Dates\n+using InteractiveUtils: clipboard\n+\n+export HistoryFile, HistEntry, update!, runsearch\n+\n+const FACES = (\n+    :REPL_History_search_separator   => Face(foreground=:blue),\n+    :REPL_History_search_prefix      => Face(foreground=:magenta),\n+    :REPL_History_search_selected    => Face(foreground=:blue),\n+    :REPL_History_search_unselected  => Face(foreground=:grey),\n+    # :REPL_History_search_preview_box => Face(foreground=:grey),\n+    :REPL_History_search_hint        => Face(foreground=:magenta, slant=:italic, weight=:light),\n+    :REPL_History_search_results     => Face(inherit=:shadow),\n+    :REPL_History_search_match       => Face(weight = :bold, underline = true),\n+)\n+\n+include(\"histfile.jl\")\n+include(\"resumablefiltering.jl\")\n+include(\"prompt.jl\")\n+include(\"display.jl\")\n+include(\"search.jl\")\n+\n+__init__() = foreach(addface!, FACES)\n+\n+end"
    },
    {
      "sha": "54397fa0e0545ca6968b0129d505e49a0802ef22",
      "filename": "stdlib/REPL/src/History/display.jl",
      "status": "added",
      "additions": 812,
      "deletions": 0,
      "changes": 812,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2Fdisplay.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2Fdisplay.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FHistory%2Fdisplay.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -0,0 +1,812 @@\n+# This file is a part of Julia. License is MIT: https://julialang.org/license\n+\n+struct SelectorState\n+    area::@NamedTuple{height::Int, width::Int}\n+    query::String\n+    filter::FilterSpec\n+    candidates::Vector{HistEntry}\n+    scroll::Int\n+    selection::@NamedTuple{active::Vector{Int}, gathered::Vector{HistEntry}}\n+    hover::Int\n+end\n+\n+SelectorState((height, width), query::String, filter::FilterSpec, candidates::Vector{HistEntry} = HistEntry[], gathered::Vector{HistEntry} = HistEntry[]) =\n+    SelectorState((height, width), query, filter, candidates, -length(gathered), (; active = Int[], gathered), 1)\n+\n+const EMPTY_STATE = SelectorState((0, 0), \"\", FilterSpec(), [], 0, (active = Int[], gathered = HistEntry[]), 0)\n+\n+STATES = Pair{SelectorState, SelectorState}[]\n+\n+const LABELS = (\n+    gatherdivider = S\"{italic:carried over}\",\n+    preview_suggestion = S\"Ctrl+S to save\",\n+    help_prompt = S\"{REPL_History_search_hint,shadow:try {REPL_History_search_hint,(slant=normal):?} for help} \",\n+)\n+\n+const SYNC_UPDATE_BEGIN = \"\\eP=1s\\e\\\\\"\n+const SYNC_UPDATE_END = \"\\eP=2s\\e\\\\\"\n+const CLEAR_BELOW = \"\\e[1G\\e[J\"\n+\n+\"\"\"\n+    redisplay_all(io::IO, oldstate::SelectorState, newstate::SelectorState, pstate::PromptState; buf)\n+\n+Diff and redraw the entire UI (candidates, preview, prompt).\n+\n+Uses ANSI sync sequences to update only changed regions between\n+`oldstate` and `newstate`, then reprints the prompt.\n+\"\"\"\n+function redisplay_all(io::IO, oldstate::SelectorState, newstate::SelectorState, pstate::REPL.LineEdit.PromptState;\n+                       buf::IOContext{IOBuffer} = IOContext(IOBuffer(), io))\n+    # Calculate dimensions\n+    oldrows = componentrows(oldstate)\n+    newrows = componentrows(newstate)\n+    # Redisplay components\n+    synccap = haskey(Base.current_terminfo(), :Sync)\n+    synccap && print(buf, SYNC_UPDATE_BEGIN)\n+    currentrow = 0\n+    if newstate.query == FILTER_SHORTHELP_QUERY\n+        print(buf, CLEAR_BELOW * '\\n', FILTER_SHORTHELP)\n+        currentrow += 1 + count('\\n', String(FILTER_SHORTHELP))\n+    elseif newstate.query == FILTER_LONGHELP_QUERY\n+        print(buf, CLEAR_BELOW * '\\n', FILTER_LONGHELP)\n+        currentrow += 1 + count('\\n', String(FILTER_LONGHELP))\n+    else\n+        println(buf) # Move to line under prompt\n+        currentrow += 1\n+        if oldstate.area.width > newstate.area.width || oldstate.query == FILTER_SHORTHELP_QUERY\n+            print(buf, CLEAR_BELOW)\n+            oldstate = EMPTY_STATE\n+        end\n+        refresh_cands = oldstate.query != newstate.query ||\n+            length(oldstate.candidates) != length(newstate.candidates) ||\n+            oldstate.area != newstate.area ||\n+            oldstate.scroll != newstate.scroll ||\n+            oldstate.selection.active != newstate.selection.active ||\n+            oldstate.hover != newstate.hover ||\n+            oldstate.filter != newstate.filter\n+        refresh_preview = refresh_cands ||\n+            oldstate.selection.gathered != newstate.selection.gathered ||\n+            gethover(oldstate) != gethover(newstate)\n+        if refresh_cands\n+            redisplay_candidates(buf, oldstate, oldrows.candidates, newstate, newrows.candidates)\n+            currentrow += newrows.candidates\n+        end\n+        if refresh_preview\n+            if !refresh_cands\n+                print(buf, '\\n' ^ newrows.candidates)\n+                currentrow += newrows.candidates\n+            end\n+            redisplay_preview(buf, oldstate, oldrows.preview, newstate, newrows.preview)\n+            currentrow += max(0, newrows.preview - 1)\n+        end\n+    end\n+    # Restore row pos\n+    print(buf, \"\\e[\", currentrow, \"A\\e[1G\")\n+    redisplay_prompt(buf, oldstate, newstate, pstate)\n+    # Restore column pos\n+    print(buf, \"\\e[\", textwidth(PROMPT_TEXT) + position(pstate.input_buffer) + 1, 'G')\n+    synccap && print(buf, SYNC_UPDATE_END)\n+    if Base.generating_output()\n+        # Write output in chunks seems to avoid a hang that happens here during precompilation\n+        # of the history on mac (io gets full without anything draining it?)\n+        seekstart(buf.io)\n+        data = read(buf.io)\n+        for chunk in Iterators.partition(data, 32)\n+            write(io, chunk)\n+            flush(io)\n+        end\n+    else\n+        write(io, seekstart(buf.io))\n+    end\n+    truncate(buf.io, 0)\n+    flush(io)\n+end\n+\n+\"\"\"\n+    componentrows(state::SelectorState) -> (; candidates::Int, preview::Int)\n+\n+Split available terminal rows into candidate list and preview panes.\n+\n+Clamps preview height between one-third and two-thirds of the usable area.\n+\"\"\"\n+function componentrows(state::SelectorState)\n+    available_rows = 2 * (state.area.height - 1) \u00f7 3 # REVIEW: maybe `min(height, ?)`\n+    preview_min, preview_max = available_rows \u00f7 3, 2 * available_rows \u00f7 3\n+    nlines_preview = countlines_selected(state)\n+    # To prevent jittering when key-repeat is happening with TAB at\n+    # the end of a list of multiple selected candidates, stop\n+    # the final candidate from affecting the size of the preview pane.\n+    if length(state.selection.active) > 2 &&\n+        last(state.selection.active) == lastindex(state.candidates)\n+        nlines_preview -= count('\\n', state.candidates[end].content) + 1\n+    end\n+    preview_rows = clamp(nlines_preview, preview_min, preview_max)\n+    if preview_min <= 2\n+        preview_rows = 0 # Not worth just showing the frame\n+    end\n+    candidate_rows = available_rows - preview_rows\n+    (; candidates = candidate_rows, preview = preview_rows)\n+end\n+\n+\"\"\"\n+    countlines_selected(state::SelectorState) -> Int\n+\n+Count display lines needed for active and gathered entries.\n+\n+Includes one line per entry plus extra lines for multi-line content\n+and a divider if any gathered entries exist.\n+\"\"\"\n+function countlines_selected((; candidates, selection)::SelectorState)\n+    (; active, gathered) = selection\n+    nlines = 0\n+    for idx in active\n+        entry = candidates[idx]\n+        nlines += 1 + count('\\n', entry.content)\n+    end\n+    if !isempty(gathered)\n+        nlines += 1 # The divider line\n+        for entry in gathered\n+            nlines += 1 + count('\\n', entry.content)\n+        end\n+    end\n+    nlines\n+end\n+\n+const BASE_MODE = :julia\n+\n+const MODE_FACES = Dict(\n+    :julia => :green,\n+    :shell => :red,\n+    :pkg => :blue,\n+    :help => :yellow,\n+)\n+\n+\"\"\"\n+    redisplay_prompt(io::IO, oldstate::SelectorState, newstate::SelectorState, pstate::PromptState)\n+\n+Redraw just the prompt line with updated query, separators, and hints.\n+\n+Styles prefixes, match-type indicators, and result counts based on cursor position in `pstate`.\n+\"\"\"\n+function redisplay_prompt(io::IO, oldstate::SelectorState, newstate::SelectorState, pstate::REPL.LineEdit.PromptState)\n+    # oldstate.query == newstate.query && return\n+    hov = gethover(newstate)\n+    query = newstate.query\n+    styquery = S\"$query\"\n+    styconds = ConditionSet(styquery)\n+    qpos = position(pstate.input_buffer)\n+    kindname = \"\"\n+    patend = 0\n+    for (name, substrs) in ((\"words\", styconds.words),\n+                            (\"exact\", styconds.exacts),\n+                            (\"negated\", styconds.negatives),\n+                            (\"initialism\", styconds.initialisms),\n+                            (\"regexp\", styconds.regexps),\n+                            (\"fuzzy\", styconds.fuzzy),\n+                            (\"mode\", styconds.modes))\n+        for substr in substrs\n+            start, len = substr.offset, substr.ncodeunits\n+            patend = max(patend, start + len)\n+            if start > 1\n+                if query[start] == FILTER_SEPARATOR\n+                    face!(styquery[start:start], :REPL_History_search_separator)\n+                else\n+                    face!(styquery[start:start], :REPL_History_search_prefix)\n+                    face!(styquery[start-1:start-1], :REPL_History_search_separator)\n+                end\n+            elseif start > 0\n+                face!(styquery[start:start],\n+                      if query[start] == FILTER_SEPARATOR\n+                          :REPL_History_search_separator\n+                      else\n+                          :REPL_History_search_prefix\n+                      end)\n+            end\n+            isempty(kindname) || continue\n+            if start <= qpos <= start + len\n+                kindname = name\n+                break\n+            end\n+        end\n+    end\n+    if patend < ncodeunits(query)\n+        if query[patend+1] == FILTER_SEPARATOR\n+            face!(styquery[patend+1:patend+1], :REPL_History_search_separator)\n+            if patend + 1 < ncodeunits(query) && query[patend+2] \u2208 FILTER_PREFIXES\n+                face!(styquery[patend+2:patend+2], :REPL_History_search_prefix)\n+            elseif isempty(kindname)\n+                kindname = \"separator\"\n+            end\n+        elseif ncodeunits(query) == 1 && query[1] \u2208 FILTER_PREFIXES\n+            face!(styquery[1:1], :REPL_History_search_prefix)\n+        end\n+    end\n+    prefix = S\"{bold:\u25aa:} \"\n+    ncand = length(newstate.candidates)\n+    resultnum = S\"{REPL_History_search_results:[$(ncand - newstate.hover + 1)/$ncand]}\"\n+    padspaces = newstate.area.width - sum(textwidth, (prefix, styquery, resultnum))\n+    suffix = if isempty(styquery)\n+        LABELS.help_prompt\n+    elseif newstate.query \u2208 (FILTER_SHORTHELP_QUERY, FILTER_LONGHELP_QUERY)\n+        S\"{REPL_History_search_hint:help} \"\n+    elseif kindname != \"\"\n+        S\"{REPL_History_search_hint:$kindname} \"\n+    else\n+        S\"\"\n+    end\n+    if textwidth(suffix) < padspaces\n+        padspaces -= textwidth(suffix)\n+    else\n+        suffix = S\"\"\n+    end\n+    # TODO: Replace with a face-based approach when possible\n+    print(io, pstate.p.prompt_prefix, prefix, \"\\e[0m\",\n+          styquery, ' ' ^ max(0, padspaces), suffix, resultnum)\n+end\n+\n+# Unicode circles:\n+# - large: \u25cf \u25cb\n+# - medium: \u23fa\ud83d\udf89\ud83d\udf88\ud83d\udf87\ud83d\udf86\ud83d\udf85\u26ac\ud83d\udf8a\u29bf\u29be\n+# - small: \u2022\u22c5\u2219\u2218\u25e6\n+# - dots: \ud83d\udf84\u2043\u00b7\n+\n+const LIST_MARKERS = if Sys.isapple()\n+    # '\ud83d\udf87' is not available by default, and '\u2b24' is oversized, so we must compromise.\n+    (selected = AnnotatedChar('\u23fa', [(:face, :REPL_History_search_selected)]),\n+     hover = AnnotatedChar('\u29bf', [(:face, :REPL_History_search_selected)]),\n+     unselected = AnnotatedChar('\u25e6', [(:face, :REPL_History_search_unselected)]),\n+     pending = AnnotatedChar('\u00b7', [(:face, :shadow)]))\n+else\n+    # Linux tends to have pretty fantastic OOTB Unicode support, with fonts\n+    # like Symbola installed by default, so we can go for the best symbols.\n+    (selected = AnnotatedChar('\u2b24', [(:face, :REPL_History_search_selected)]),\n+     hover = AnnotatedChar('\ud83d\udf87', [(:face, :REPL_History_search_selected)]),\n+     unselected = AnnotatedChar('\u25e6', [(:face, :REPL_History_search_unselected)]),\n+     pending = AnnotatedChar('\ud83d\udf84', [(:face, :shadow)]))\n+end\n+\n+const NEWLINE_MARKER = S\"{shadow:\u21a9 }\"\n+const LINE_ELLIPSIS = S\"{shadow:\u2026}\"\n+\n+\"\"\"\n+    hoveridx(state::SelectorState) -> Int\n+\n+Compute the signed index into `candidates` or `gathered` for hover.\n+\n+Positive values index `candidates`, negative values index `gathered`, zero is\n+invalid.\n+\"\"\"\n+function hoveridx(state::SelectorState)\n+    if state.hover > 0\n+        length(state.candidates) - state.hover + 1\n+    else\n+        state.hover\n+    end\n+end\n+\n+\"\"\"\n+    ishover(state::SelectorState, idx::Int) -> Bool\n+\n+Return true if `idx` matches the current hover position.\n+\n+Used to highlight the hovered line in the UI.\n+\"\"\"\n+ishover(state::SelectorState, idx::Int) = idx == hoveridx(state)\n+\n+\"\"\"\n+    gethover(state::SelectorState) -> Union{HistEntry, Nothing}\n+\n+Return the `HistEntry` under the cursor (hover position), or `nothing`.\n+\n+Handles positive hover for `candidates` and negative for `gathered`.\n+\"\"\"\n+function gethover(state::SelectorState)\n+    idx = hoveridx(state)\n+    if idx \u2208 axes(state.candidates, 1)\n+        state.candidates[idx]\n+    elseif idx < 0 && -idx \u2208 axes(state.selection.gathered, 1)\n+        state.selection.gathered[-idx]\n+    end\n+end\n+\n+struct CandsState{V<:AbstractVector{HistEntry}}\n+    search::FilterSpec\n+    entries::V\n+    selected::Vector{Int}\n+    hover::Int\n+    rows::Int\n+    width::Int\n+end\n+\n+\n+\"\"\"\n+    candidates(state::SelectorState, rows::Int) -> (; active::CandsState, gathered::CandsState)\n+\n+Compute visible slices of active and gathered entries for display.\n+\"\"\"\n+function candidates(state::SelectorState, rows::Int)\n+    gathshift = 0\n+    gathcount = clamp(-state.scroll, 0, length(state.selection.gathered))\n+    if gathcount >= rows\n+        gathshift = gathcount - rows + 1\n+        gathcount = rows - 1\n+    end\n+    actcount = rows - gathcount - sign(gathcount)\n+    offset = max(0, length(state.candidates) - actcount - max(0, state.scroll))\n+    candend = offset + actcount\n+    actcands = @view state.candidates[max(begin, begin+offset):min(end, candend)]\n+    actempty = actcount - length(actcands)\n+    actsel = Int[idx - offset for idx in state.selection.active]\n+    if !isempty(state.selection.gathered)\n+        append!(actsel, filter!(!isnothing, indexin(state.selection.gathered, actcands)))\n+    end\n+    active = CandsState(\n+        state.filter,\n+        actcands,\n+        actsel,\n+        rows + state.scroll - state.hover - actempty + gathshift + (state.scroll >= 0),\n+        actcount,\n+        state.area.width)\n+    gathcands = @view state.selection.gathered[begin+gathshift:min(end, gathshift+gathcount)]\n+    gathered = CandsState(\n+        state.filter,\n+        gathcands,\n+        collect(axes(gathcands, 1)),\n+        -state.hover - gathshift,\n+        gathcount,\n+        state.area.width)\n+    (; active, gathered)\n+end\n+\n+\"\"\"\n+    redisplay_candidates(io::IO, oldstate::SelectorState, oldrows::Int, newstate::SelectorState, newrows::Int)\n+\n+Diff and redraw the candidate list pane between two states.\n+\n+Only lines that changed (entry text, selection, hover, width) are reprinted;\n+unchanged lines remain.\n+\"\"\"\n+function redisplay_candidates(io::IO, oldstate::SelectorState, oldrows::Int, newstate::SelectorState, newrows::Int)\n+    danglingdivider = false\n+    if oldstate.scroll < 0 && newstate.scroll == 0\n+        newrows -= 1\n+        danglingdivider = true\n+    end\n+    oldcands = candidates(oldstate, oldrows)\n+    newcands = candidates(newstate, newrows)\n+    samefilter = oldstate.filter == newstate.filter\n+    # Redisplay active candidates\n+    update_candidates(io, oldcands.active, newcands.active,\n+                      !samefilter || oldstate.scroll == 0 && !isempty(oldstate.selection.gathered))\n+    # Redisplay gathered candidates\n+    gathchange = oldrows != newrows || length(oldcands.gathered.entries) != length(newcands.gathered.entries)\n+    if isempty(newcands.gathered.entries) && !danglingdivider\n+    elseif gathchange || danglingdivider || oldstate.area != newstate.area\n+        netlines = newstate.area.width - textwidth(LABELS.gatherdivider) - 6\n+        leftlines = netlines \u00f7 2\n+        rightlines = netlines - leftlines\n+        println(io, S\" {shadow:\u2576$('\u2500' ^ leftlines)\u2574$(LABELS.gatherdivider)\u2576$('\u2500' ^ rightlines)\u2574} \")\n+    else\n+        println(io)\n+    end\n+    update_candidates(io, oldcands.gathered, newcands.gathered, gathchange != 0)\n+end\n+\n+\"\"\"\n+    update_candidates(io::IO, oldcands::CandsState, newcands::CandsState, force::Bool = false)\n+\n+Write an update to `io` that changes the display from `oldcands` to `newcands`.\n+\n+Only changes are printed, and exactly `length(newcands.entries)` lines are printed.\n+\"\"\"\n+function update_candidates(io::IO, oldcands::CandsState, newcands::CandsState, force::Bool = false)\n+    thisline = 1\n+    for (i, (old, new)) in enumerate(zip(oldcands.entries, newcands.entries))\n+        oldsel, newsel = i \u2208 oldcands.selected, i \u2208 newcands.selected\n+        oldhov, newhov = i == oldcands.hover, i == newcands.hover\n+        if !force && old == new && oldsel == newsel && oldhov == newhov && oldcands.width == newcands.width\n+            println(io)\n+        else\n+            print_candidate(io, newcands.search, new, newcands.width;\n+                            selected = newsel, hover = newhov)\n+        end\n+        thisline = i + 1\n+    end\n+    for (i, new) in enumerate(newcands.entries)\n+        i <= length(oldcands.entries) && continue\n+        print_candidate(io, newcands.search, new, newcands.width;\n+                        selected = i \u2208 newcands.selected,\n+                        hover = i == newcands.hover)\n+        thisline = i + 1\n+    end\n+    for _ in thisline:newcands.rows\n+        print(io, \"\\e[K \", LIST_MARKERS.pending, '\\n')\n+    end\n+end\n+\n+const DURATIONS = (\n+    m = 60,\n+    h = 60 * 60,\n+    d = 24 * 60 * 60,\n+    w = 7 * 24 * 60 * 60,\n+    y = 365 * 24 * 60 * 60,\n+)\n+\n+\"\"\"\n+    humanage(seconds::Integer) -> String\n+\n+Convert `seconds` into a compact age string with largest unit.\n+\n+```julia-repl\n+julia> humanage(70)\n+\"1m\"\n+\n+julia> humanage(4000)\n+\"1h\"\n+```\n+\"\"\"\n+function humanage(seconds::Integer)\n+    unit, count = :s, seconds\n+    for (dunit, dsecs) in pairs(DURATIONS)\n+        n = seconds \u00f7 dsecs\n+        n == 0 && break\n+        unit, count = dunit, n\n+    end\n+    \"$count$unit\"\n+end\n+\n+\"\"\"\n+    print_candidate(io::IO, search::FilterSpec, cand::HistEntry, width::Int; selected::Bool, hover::Bool)\n+\n+Render one history entry line with markers, mode hint, age, and highlighted content.\n+\n+Truncates and focuses on matches to fit `width`.\n+\"\"\"\n+function print_candidate(io::IO, search::FilterSpec, cand::HistEntry, width::Int; selected::Bool, hover::Bool)\n+    print(io, ' ', if selected\n+              LIST_MARKERS.selected\n+          elseif hover\n+              LIST_MARKERS.hover\n+          else\n+              LIST_MARKERS.unselected\n+          end, ' ')\n+    age = humanage(floor(Int, ((now(UTC) - cand.date)::Millisecond).value \u00f7 1000))\n+    agedec = S\" {shadow,light,italic:$age}\"\n+    modehint = if cand.mode == BASE_MODE\n+        S\"\"\n+    else\n+        modeface = get(MODE_FACES, cand.mode, :grey)\n+        if hover\n+            S\"{region: {bold,inverse,$modeface: $(cand.mode) }}\"\n+        elseif ncodeunits(age) == 2\n+            S\" {$modeface:\u25fc}  \"\n+        else\n+            S\" {$modeface:\u25fc} \"\n+        end\n+    end\n+    decorationlen = 3 #= spc + marker + spc =# + textwidth(modehint) + textwidth(agedec) + 1 #= spc =#\n+    flatcand = replace(highlightcand(cand), r\"\\r?\\n\\s*\" => NEWLINE_MARKER)\n+    candstr = focus_matches(search, flatcand, width - decorationlen)\n+    if hover\n+        face!(candstr, :region)\n+        face!(agedec, :region)\n+    end\n+    println(io, candstr, modehint, agedec, ' ')\n+end\n+\n+\"\"\"\n+    highlightcand(cand::HistEntry) -> AnnotatedString\n+\n+Syntax-highlight Julia content or return raw content otherwise.\n+\"\"\"\n+function highlightcand(cand::HistEntry)\n+    if cand.mode === :julia\n+        highlight(cand.content)\n+    else\n+        S\"$(cand.content)\"\n+    end\n+end\n+\n+\"\"\"\n+    focus_matches(search::FilterSpec, content::AnnotatedString, targetwidth::Int) -> AnnotatedString\n+\n+Center and trim `content` around matching regions, adding ellipses.\n+\n+To best display matches, this function operates in multiple stages:\n+1. Find all matching character ranges in `content` via `matchregions(search, String(content))`.\n+2. Choose a primary match region that can be fully shown within `targetwidth`,\n+   preferring the first match.\n+3. Starting from the end of that region, expand a window leftwards up to\n+   `targetwidth`, accounting for character widths.\n+4. If the left bound exceeds the start of `content`, reserve space for a leading\n+   ellipsis (`LINE_ELLIPSIS`) and adjust the window.\n+5. Expand the window rightwards similarly, inserting a trailing ellipsis if\n+   there is remaining text.\n+6. Slice out the computed substring from `content`, preserving existing annotations.\n+7. Re-apply the match highlight face (`:REPL_History_search_match`) to any\n+   regions within the window.\n+8. Pad the result with spaces if its width is less than `targetwidth`.\n+\n+The returned `AnnotatedString` is exactly `targetwidth` columns wide,\n+guaranteeing at least one full match is visible and highlighted.\n+\"\"\"\n+function focus_matches(search::FilterSpec, content::AnnotatedString{String}, targetwidth::Int)\n+    cstr = String(content) # zero-cost\n+    mregions = matchregions(search, cstr)\n+    isempty(mregions) && return rpad(rtruncate(content, targetwidth, LINE_ELLIPSIS), targetwidth)\n+    mstart = first(first(mregions))\n+    mlast = first(mregions)\n+    ellipwidth = textwidth(LINE_ELLIPSIS)\n+    # Assume approximately one cell per character, and refine later\n+    for (i, region) in Iterators.reverse(enumerate(mregions))\n+        if first(region) - mstart <= targetwidth - 2 * ellipwidth\n+            mlast = region\n+            break\n+        end\n+    end\n+    # Start at the end of the last region, and extend backwards `targetwidth` characters\n+    left, right = let pos = thisind(cstr, last(mlast)); (pos, pos) end\n+    width = textwidth(cstr[left])\n+    while left > firstindex(cstr)\n+        lnext = prevind(cstr, left)\n+        lwidth = textwidth(cstr[lnext])\n+        if width + lwidth > targetwidth - 2 * ellipwidth\n+            break\n+        end\n+        width += lwidth\n+        left = lnext\n+    end\n+    # Check to see if we have reached the beginning of the first match,\n+    # if we haven't we want to shrink the region to the left until the\n+    # beginning of the first match is reached.\n+    if left > first(mstart)\n+        while left > first(mstart)\n+            left = prevind(cstr, left)\n+            lwidth = textwidth(cstr[left])\n+            width += lwidth\n+            # We'll move according to the assumption that each character\n+            # is one cell wide, but account for the width correctly and\n+            # adjust for any underestimate later.\n+            for _ in 1:lwidth\n+                width -= textwidth(cstr[right])\n+                right = prevind(cstr, right)\n+                right == left && break\n+            end\n+        end\n+    end\n+    isltrunc, isrtrunc = left > firstindex(cstr), right < lastindex(cstr)\n+    # Use any available space to extend to the left.\n+    if width < targetwidth - (isltrunc + isrtrunc) * ellipwidth && left < firstindex(cstr)\n+        while left < firstindex(cstr)\n+            lnext = prevind(cstr, left)\n+            lwidth = textwidth(cstr[lnext])\n+            isnextltrunc = lnext > firstindex(cstr)\n+            nellipsis = isnextltrunc + isrtrunc\n+            if width + lwidth > targetwidth - nellipsis * ellipwidth\n+                break\n+            end\n+            width += lwidth\n+            left = lnext\n+        end\n+        isltrunc = left > firstindex(cstr)\n+    end\n+    # Use any available space to extend to the right.\n+    if width < targetwidth - (isltrunc + isrtrunc) * ellipwidth && right < lastindex(cstr)\n+        while right < lastindex(cstr)\n+            rnext = nextind(cstr, right)\n+            rwidth = textwidth(cstr[rnext])\n+            isnextrtrunc = rnext < lastindex(cstr)\n+            nellipsis = isltrunc + isnextrtrunc\n+            if width + rwidth > targetwidth - nellipsis * ellipwidth\n+                break\n+            end\n+            width += rwidth\n+            right = rnext\n+        end\n+    end\n+    # Construct the new region\n+    regstr = AnnotatedString(content[left:right])\n+    # Emphasise matches\n+    for region in mregions\n+        (last(region) < left || first(region) > right) && continue\n+        adjregion = (max(left, first(region)) - left + 1):(min(right, last(region)) - left + 1)\n+        face!(regstr, adjregion, :REPL_History_search_match)\n+    end\n+    # Add ellipses\n+    ellipstr = if left > firstindex(cstr) && right < lastindex(cstr)\n+        width += 2 * ellipwidth\n+        LINE_ELLIPSIS * regstr * LINE_ELLIPSIS\n+    elseif left > firstindex(cstr)\n+        width += ellipwidth\n+        LINE_ELLIPSIS * regstr\n+    elseif right < lastindex(cstr)\n+        width += ellipwidth\n+        regstr * LINE_ELLIPSIS\n+    else\n+        regstr\n+    end\n+    # Pad (if necessary)\n+    if width < targetwidth\n+        rpad(ellipstr, targetwidth)\n+    else\n+        ellipstr\n+    end\n+end\n+\n+\"\"\"\n+    redisplay_preview(io::IO, oldstate::SelectorState, oldrows::Int, newstate::SelectorState, newrows::Int)\n+\n+Diff and redraw the preview pane (right side) with boxed content.\n+\n+Shows hover or gathered entries in a box.\n+\"\"\"\n+function redisplay_preview(io::IO, oldstate::SelectorState, oldrows::Int, newstate::SelectorState, newrows::Int)\n+    newrows == 0 && return\n+    function getcand(state::SelectorState, idx::Int)\n+        if idx \u2208 axes(state.candidates, 1)\n+            state.candidates[idx]\n+        elseif -idx \u2208 axes(state.selection.gathered, 1)\n+            state.selection.gathered[-idx]\n+        else\n+            throw(ArgumentError(\"Invalid candidate index: $idx\")) # Should never happen\n+        end\n+    end\n+    function getselidxs(state::SelectorState)\n+        idxs = collect(-1:-1:-length(state.selection.gathered))\n+        append!(idxs, state.selection.active)\n+        sort!(idxs, by = i -> getcand(state, i).index)\n+    end\n+    rtruncpad(s::AbstractString, width::Int) =\n+        rpad(rtruncate(s, width, LINE_ELLIPSIS), width)\n+    bar = S\"{shadow:\u2502}\"\n+    innerwidth = newstate.area.width - 2\n+    if oldstate.area != newstate.area || (oldstate.area.height - oldrows) != (newstate.area.height - newrows)\n+        println(io, S\"{shadow:\u256d$('\u2500' ^ innerwidth)\u256e}\")\n+    else\n+        println(io)\n+    end\n+    if newrows - 2 < 1\n+        # Well, this is awkward.\n+    elseif isempty(newstate.selection.active) && isempty(newstate.selection.gathered)\n+        linesprinted = if (gethover(newstate) != gethover(oldstate) ||\n+            oldstate.area != newstate.area ||\n+            oldrows != newrows ||\n+            oldstate.filter != newstate.filter)\n+            hovcand = gethover(newstate)\n+            if !isnothing(hovcand)\n+                hovcontent = highlightcand(hovcand)\n+                for region in matchregions(newstate.filter, String(hovcontent))\n+                    face!(hovcontent[region], :REPL_History_search_match)\n+                end\n+                if hovcand.mode !== BASE_MODE\n+                    mcolor = get(MODE_FACES, hovcand.mode, :grey)\n+                    hovcontent = S\"{bold,$mcolor:$(hovcand.mode)>} \" * hovcontent\n+                end\n+                boxedcontent(io, hovcontent, newstate.area.width, newrows - 2)\n+            else\n+                0\n+            end\n+        else\n+            print(io, '\\n' ^ (newrows - 2))\n+            newrows - 2\n+        end\n+        for _ in (linesprinted + 1):(newrows - 2)\n+            println(io, bar, ' '^innerwidth, bar)\n+        end\n+    else\n+        linesprinted = 0\n+        seltexts = AnnotatedString{String}[]\n+        for idx in getselidxs(newstate)\n+            entry = getcand(newstate, idx)\n+            content = highlightcand(entry)\n+            ishover(newstate, idx) && face!(content, :region)\n+            push!(seltexts, content)\n+        end\n+        linecount = sum(t -> 1 + count('\\n', String(t)), seltexts, init=0)\n+        for (i, content) in enumerate(seltexts)\n+            clines = 1 + count('\\n', String(content))\n+            if linesprinted + clines < newrows - 2 || (i == length(seltexts) && linesprinted + clines == newrows - 2)\n+                for line in eachsplit(content, '\\n')\n+                    println(io, bar, ' ', rtruncpad(line, innerwidth - 2), ' ', bar)\n+                end\n+                linesprinted += clines\n+            else\n+                remaininglines = newrows - 2 - linesprinted\n+                for (i, line) in enumerate(eachsplit(content, '\\n'))\n+                    i == remaininglines && break\n+                    println(io, bar, ' ', rtruncpad(line, innerwidth - 2), ' ', bar)\n+                end\n+                msg = S\"{julia_comment:\u22ee {italic:$(linecount - newrows + 3) lines hidden}}\"\n+                println(io, bar, ' ', rtruncpad(msg, innerwidth - 2), ' ', bar)\n+                linesprinted += remaininglines\n+                break\n+            end\n+        end\n+        for _ in (linesprinted + 1):(newrows - 2)\n+            println(io, bar, ' ' ^ innerwidth, bar)\n+        end\n+    end\n+    if oldstate.area != newstate.area || length(oldstate.selection.active) != length(newstate.selection.active)\n+        if textwidth(LABELS.preview_suggestion) < innerwidth\n+            line = '\u2500' ^ (innerwidth - textwidth(LABELS.preview_suggestion) - 2)\n+            print(io, S\"{shadow:\u2570$(line)\u2574$(LABELS.preview_suggestion)\u2576\u256f}\")\n+        else\n+            print(io, S\"{shadow:\u2570$('\u2500' ^ innerwidth)\u256f}\")\n+        end\n+    end\n+end\n+\n+\"\"\"\n+    boxedcontent(io::IO, content::AnnotatedString, width::Int, maxlines::Int) -> Int\n+\n+Draw `content` inside a Unicode box, wrapping or truncating to `width` and `maxlines`.\n+\n+Returns the number of printed lines.\n+\"\"\"\n+function boxedcontent(io::IO, content::AnnotatedString{String}, width::Int, maxlines::Int)\n+    function breaklines(content::AnnotatedString{String}, maxwidth::Int)\n+        textwidth(content) <= maxwidth && return [content]\n+        spans = AnnotatedString{String}[]\n+        basestr = String(content) # Because of expensive char iteration\n+        start, pos, linewidth = 1, 0, 0\n+        for char in basestr\n+            linewidth += textwidth(char)\n+            pos = nextind(basestr, pos)\n+            if linewidth > maxwidth\n+                spans = push!(spans, AnnotatedString(content[start:prevind(basestr, pos)]))\n+                start = pos\n+                linewidth = textwidth(char)\n+            end\n+        end\n+        if start <= length(basestr)\n+            spans = push!(spans, AnnotatedString(content[start:end]))\n+        end\n+        spans\n+    end\n+    left, right = S\"{shadow:\u2502} \", S\" {shadow:\u2502}\"\n+    leftcont, rightcont = S\"{shadow:\u250a\u25b8}\", S\"{shadow:\u25c2\u250a}\"\n+    if maxlines == 1\n+        println(io, left,\n+                rpad(rtruncate(content, width - 4, LINE_ELLIPSIS), width - 4),\n+                right)\n+        return 1\n+    end\n+    printedlines = 0\n+    if ncodeunits(content) > (width * maxlines)\n+        content = AnnotatedString(rtruncate(content, width * maxlines, ' '))\n+    end\n+    lines = split(content, '\\n')\n+    innerwidth = width - 4\n+    for (i, line) in enumerate(lines)\n+        printedlines >= maxlines && break\n+        if textwidth(line) <= innerwidth\n+            println(io, left, rpad(line, innerwidth), right)\n+            printedlines += 1\n+            continue\n+        end\n+        plainline = String(line)\n+        indent, ichars = 0, 1\n+        while isspace(plainline[ichars])\n+            indent += textwidth(plainline[ichars])\n+            ichars = nextind(plainline, ichars)\n+        end\n+        line = @view line[ichars:end]\n+        spans = breaklines(AnnotatedString(line), innerwidth - 2 - indent)\n+        for (i, span) in enumerate(spans)\n+            prefix, suffix = if i == 1\n+                S\"\", S\"$LINE_ELLIPSIS \"\n+            elseif i == length(spans)\n+                S\"$LINE_ELLIPSIS\", S\" \"\n+            else\n+                LINE_ELLIPSIS, LINE_ELLIPSIS\n+            end\n+            printedlines += 1\n+            println(io, ifelse(i == 1, left, leftcont), ' ' ^ indent,\n+                    prefix, rpad(span, innerwidth - 2 - indent), suffix,\n+                    ifelse(i == length(spans) || printedlines == maxlines,\n+                           right, rightcont))\n+            printedlines >= maxlines && break\n+        end\n+    end\n+    printedlines\n+end"
    },
    {
      "sha": "b62dfeae504e2b92c2fb1035726f1d047c843634",
      "filename": "stdlib/REPL/src/History/histfile.jl",
      "status": "added",
      "additions": 288,
      "deletions": 0,
      "changes": 288,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2Fhistfile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2Fhistfile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FHistory%2Fhistfile.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -0,0 +1,288 @@\n+# This file is a part of Julia. License is MIT: https://julialang.org/license\n+\n+\"\"\"\n+    REPL_DATE_FORMAT\n+\n+The `DateFormat` used to parse and format timestamps in the REPL history file.\n+\"\"\"\n+const REPL_DATE_FORMAT = dateformat\"yyyy-mm-dd HH:MM:SS\"\n+\n+const HIST_OPEN_FLAGS =\n+    Base.Filesystem.JL_O_APPEND |\n+    Base.Filesystem.JL_O_RDWR |\n+    Base.Filesystem.JL_O_CREAT |\n+    Base.Filesystem.JL_O_CLOEXEC\n+\n+struct HistEntry\n+    mode::Symbol\n+    date::DateTime\n+    # cwd::String\n+    content::String\n+    # resulttype::String\n+    # session::UInt64\n+    index::UInt32\n+    # sindex::UInt16\n+    # error::Bool\n+end\n+\n+\"\"\"\n+    HistoryFile(path::String) -> HistoryFile\n+\n+Create a handle to the history file at `path`, and store the `HistEntry` records.\n+\n+See also: `update!(::HistoryFile)`.\n+\"\"\"\n+struct HistoryFile <: AbstractVector{HistEntry}\n+    path::String\n+    file::Base.Filesystem.File\n+    lock::ReentrantLock\n+    records::Vector{HistEntry}\n+end\n+\n+HistoryFile(path::String) = HistoryFile(\n+    path, Base.Filesystem.open(path, HIST_OPEN_FLAGS, 0o640), ReentrantLock(), [])\n+\n+function HistoryFile()\n+    nofile = Base.Filesystem.File(Base.Filesystem.INVALID_OS_HANDLE)\n+    nofile.open = false\n+    HistoryFile(\"\", nofile, ReentrantLock(), [])\n+end\n+\n+Base.lock(hist::HistoryFile) = lock(hist.lock)\n+Base.trylock(hist::HistoryFile) = trylock(hist.lock)\n+Base.unlock(hist::HistoryFile) = unlock(hist.lock)\n+\n+Base.size(hist::HistoryFile) = @lock hist (length(hist.records),)\n+Base.getindex(hist::HistoryFile, i::Int) = hist.records[i]\n+\n+function ensureopen(hist::HistoryFile)\n+    isopen(hist.file) && return true\n+    isempty(hist.path) && return false\n+    try\n+        lock(hist)\n+        newfile = Base.Filesystem.open(hist.path, HIST_OPEN_FLAGS, 0o640)\n+        newfile.open || return false\n+        hist.file.handle = newfile.handle\n+        hist.file.open = true\n+    finally\n+        unlock(hist)\n+    end\n+end\n+\n+Base.close(hist::HistoryFile) = close(hist.file)\n+\n+\"\"\"\n+    update!(hist::HistoryFile) -> HistoryFile\n+\n+Read any new entries from the history file and record them as `HistEntry`s.\n+\n+Malformed entries are skipped, and if the last entry is incomplete the IO\n+position will be reset to the start of the entry.\n+\"\"\"\n+function update!(hist::HistoryFile)\n+    (; file, records) = hist\n+    # If the file has grown since the last read,\n+    # we need to trigger a synchronisation of the\n+    # stream state. This can be done with `fseek`,\n+    # but that can't easily be called from Julia.\n+    # Instead, we can use `filesize` to detect when\n+    # we need to do this, and then use `peek` to\n+    # trigger the synchronisation. This relies on\n+    # undocumented implementation details, but\n+    # there's not much to be done about that.\n+    ensureopen(hist) || return hist\n+    offset = position(file)\n+    offset == filesize(file) && return hist\n+    try\n+        lock(hist)\n+        bytes = read(file)\n+        function findnext(data::Vector{UInt8}, index::Int, byte::UInt8, limit::Int = length(data))\n+            for i in index:limit\n+                data[i] == byte && return i\n+            end\n+            limit\n+        end\n+        function isstrmatch(data::Vector{UInt8}, at::Int, str::String)\n+            at + ncodeunits(str) <= length(data) || return false\n+            for (i, byte) in enumerate(codeunits(str))\n+                data[at + i - 1] == byte || return false\n+            end\n+            true\n+        end\n+        histindex = if isempty(hist.records)\n+            0\n+        else\n+            hist.records[end].index\n+        end\n+        pos = firstindex(bytes)\n+        while true\n+            pos >= length(bytes) && break\n+            entrystart = pos\n+            if bytes[pos] != UInt8('#')\n+                @warn S\"Malformed history entry: expected meta-line starting with {success:'#'} at byte {emphasis:$(offset + pos - 1)} in \\\n+                       {(underline=grey),link=$(Base.Filesystem.uripath(hist.path)):$(contractuser(hist.path))}, but found \\\n+                       {error:$(sprint(show, Char(bytes[pos])))} instead\" _id=:invalid_history_entry maxlog=3 _file=nothing _line=nothing\n+                pos = findnext(bytes, pos, UInt8('\\n')) + 1\n+                continue\n+            end\n+            time, mode = zero(DateTime), :julia\n+            while pos < length(bytes) && bytes[pos] == UInt8('#')\n+                pos += 1\n+                while pos < length(bytes) && bytes[pos] == UInt8(' ')\n+                    pos += 1\n+                end\n+                metastart = pos\n+                metaend = findnext(bytes, pos, UInt8(':'))\n+                pos = metaend + 1\n+                while pos < length(bytes) && bytes[pos] == UInt8(' ')\n+                    pos += 1\n+                end\n+                valstart = pos\n+                valend = findnext(bytes, pos, UInt8('\\n'))\n+                pos = valend + 1\n+                if isstrmatch(bytes, metastart, \"mode:\")\n+                    mode = if isstrmatch(bytes, valstart, \"julia\") && bytes[valstart + ncodeunits(\"julia\")] \u2208 (UInt8('\\n'), UInt8('\\r'))\n+                        :julia\n+                    elseif isstrmatch(bytes, valstart, \"help\") && bytes[valstart + ncodeunits(\"help\")] \u2208 (UInt8('\\n'), UInt8('\\r'))\n+                        :help\n+                    elseif all(>(0x5a), view(bytes, valstart:valend-1))\n+                        Symbol(bytes[valstart:valend-1])\n+                    else\n+                        Symbol(lowercase(String(bytes[valstart:valend-1])))\n+                    end\n+                elseif isstrmatch(bytes, metastart, \"time:\")\n+                    valend = min(valend, valstart + ncodeunits(\"0000-00-00 00:00:00\"))\n+                    timestr = String(bytes[valstart:valend-1]) # It would be nice to avoid the string, but oh well\n+                    timeval = tryparse(DateTime, timestr, REPL_DATE_FORMAT)\n+                    if !isnothing(timeval)\n+                        time = timeval\n+                    end\n+                end\n+            end\n+            if pos >= length(bytes)\n+                # Potentially incomplete entry; roll back to start\n+                seek(file, offset + entrystart - 1)\n+                break\n+            elseif bytes[pos] == UInt8(' ')\n+                @warn S\"Malformed history content: expected line to start with {success:'\\\\t'} at byte {emphasis:$(offset + pos - 1)} in \\\n+                        {(underline=grey),link=$(Base.Filesystem.uripath(hist.path)):$(contractuser(hist.path))}, but found \\\n+                        space ({error:' '}) instead. A text editor may have converted tabs to spaces in the \\\n+                        history file.\" _id=:invalid_history_content_spc maxlog=1 _file=nothing _line=nothing\n+                continue\n+            elseif bytes[pos] != UInt8('\\t')\n+                @warn S\"Malformed history content: expected line to start with {success:'\\\\t'} at byte {emphasis:$(offset + pos - 1)} in \\\n+                        {(underline=grey),link=$(Base.Filesystem.uripath(hist.path)):$(contractuser(hist.path))}, but found \\\n+                        {error:$(sprint(show, Char(bytes[pos])))} instead\" _id=:invalid_history_content maxlog=3 _file=nothing _line=nothing\n+                continue\n+            end\n+            contentstart = pos\n+            nlines = 0\n+            while true\n+                pos = findnext(bytes, pos, UInt8('\\n'))\n+                nlines += 1\n+                if pos < length(bytes) && bytes[pos+1] == UInt8('\\t')\n+                    pos += 1\n+                else\n+                    break\n+                end\n+            end\n+            contentend, pos = pos, contentstart\n+            content = Vector{UInt8}(undef, contentend - contentstart - nlines)\n+            bytescopied = 0\n+            while pos < contentend\n+                lineend = findnext(bytes, pos, UInt8('\\n'))\n+                nbytes = lineend - pos - (lineend == contentend)\n+                copyto!(content, bytescopied + 1, bytes, pos + 1, nbytes)\n+                bytescopied += nbytes\n+                pos = lineend + 1\n+            end\n+            entry = HistEntry(mode, time, String(content), histindex += 1)\n+            push!(records, entry)\n+        end\n+        seek(file, offset + pos - 1)\n+    finally\n+        unlock(hist)\n+    end\n+    hist\n+end\n+\n+function Base.push!(hist::HistoryFile, entry::HistEntry)\n+    try\n+        lock(hist)\n+        update!(hist)\n+        entry = HistEntry(\n+            if all(islowercase, String(entry.mode))\n+                entry.mode\n+            else\n+                Symbol(lowercase(String(entry.mode)))\n+            end,\n+            round(entry.date, Dates.Second),\n+            entry.content,\n+            length(hist.records) + 1)\n+        push!(hist.records, entry)\n+        isopen(hist.file) || return hist\n+        content = IOBuffer()\n+        write(content, \"# time: \",\n+              Dates.format(entry.date, REPL_DATE_FORMAT), \"Z\\n\",\n+              \"# mode: \", String(entry.mode), '\\n')\n+        replace(content, entry.content, r\"^\"ms => \"\\t\")\n+        write(content, '\\n')\n+        # Short version:\n+        #\n+        # Libuv supports opening files with an atomic append flag,\n+        # and so if we pass the entire new entry to `uv_fs_write`\n+        # with an offset of `-1`, the OS will ensure that the write\n+        # is atomic. There are some caveats around this, but there's\n+        # no silver bullet.\n+        #\n+        # Long version:\n+        #\n+        # Normally, we would need to make sure we've got unique access to the file,\n+        # however because we opened it with `O_APPEND` the OS (as of POSIX.1-2017, and on:\n+        # Linux/FreeBSD/Darwin/Windows) guarantees that concurrent writes will not tear.\n+        #\n+        # This requires that a single `write` call be used to write the entire new entry.\n+        # This is not obvious, but if you look at `base/filesystem.jl` we can see that\n+        # the `unsafe_write` call below is turned into a `uv_fs_write` call.\n+        # Following this to `src/jl_uv.c` we can see this quickly turns into a `uv_fs_write`\n+        # call, which will produce a `uv__fs_write_all` call, and then calls `uv__fs_write`\n+        # in a loop until everything is written.\n+        #\n+        # This loop seems like it might allow writes to be interleaved, but since\n+        # we know that `nbufs = 1` and `off = -1` (from the parameters set in `unsafe_write`\n+        # and `jl_uv_write`), we can see that `uv__fs_write` will call the `write`\n+        # syscall directly, and so we get the `O_APPEND` semantics guaranteed by the OS.\n+        #\n+        # POSIX does mention that `write` may write less bytes than it is asked to,\n+        # but only when either:\n+        # 1. There is insufficient space on the device, or\n+        # 2. The size of the write exceeds `RLIMIT_FSIZE`, or\n+        # 3. The call is interrupted by a signal handler.\n+        #\n+        # Any of these would cause issues regardless.\n+        #\n+        # Over in Windows-land, `FILE_APPEND_DATA` has been around for a while (and is used\n+        # by libuv), and from reading `win/fs.c` we can see that a similar approach is taken\n+        # using `WriteFile` calls. Before Windows 10 (on NTFS), v10.0.14393 update atomicity\n+        # could be as small as 1 byte, but after that testing indicates that writes through\n+        # to 1MB are written in a single operation. Given that this is not an upper limit,\n+        # and it would be quite an extraordinary REPL entry, this seem safe enough.\n+        #\n+        # While in theory a split write may occur, in practice this seems exceptionally rare\n+        # (near non-existent), and the previous pidfile locking approach is no silver bullet\n+        # either, with its own set of \"reasonable assumptions\" like:\n+        # 1. PIDs not being rapidly recycled\n+        # 2. No process being able to delete and write a file faster than another\n+        #    process can do the same\n+        # 3. The PID number itself being written in one shot (see the above lack of\n+        #    formal guarantees around `write`, which also applies here)\n+        #\n+        # All in all, relying on kernel inode locking with `O_APPEND` and whole writes\n+        # seems like the sanest approach overall. Mutual exclusion isn't the priority\n+        # here, safe appending is.\n+        unsafe_write(hist.file, pointer(content.data), position(content) % UInt, Int64(-1))\n+    finally\n+        unlock(hist)\n+    end\n+    hist\n+end"
    },
    {
      "sha": "78b87e7868344b8aff5ae5973fe5009fea02f447",
      "filename": "stdlib/REPL/src/History/prompt.jl",
      "status": "added",
      "additions": 165,
      "deletions": 0,
      "changes": 165,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2Fprompt.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2Fprompt.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FHistory%2Fprompt.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -0,0 +1,165 @@\n+# This file is a part of Julia. License is MIT: https://julialang.org/license\n+\n+const PROMPT_TEXT = \"\u25aa: \"\n+\n+struct Event <: Function\n+    info::Channel{Symbol}\n+    name::Symbol\n+end\n+\n+function (e::Event)(_...)\n+    push!(e.info, e.name)\n+    :ignore\n+end\n+\n+\"\"\"\n+    select_keymap(events::Channel{Symbol})\n+\n+Build a REPL.LineEdit keymap that pushes symbols into `events`.\n+\n+Binds arrows, page keys, Tab, Ctrl-C/D/S, and meta-< / > to\n+`Event` or `Returns` actions for driving the prompt loop.\n+\"\"\"\n+function select_keymap(events::Channel{Symbol})\n+    REPL.LineEdit.keymap([\n+        Dict{Any, Any}(\n+            # Up Arrow\n+            \"\\e[A\" => Event(events, :up),\n+            \"^P\" => Event(events, :up),\n+            # Down Arrow\n+            \"\\e[B\" => Event(events, :down),\n+            \"^N\" => Event(events, :down),\n+            # Tab\n+            '\\t' => Event(events, :tab),\n+            # Page up\n+            \"\\e[5~\" => Event(events, :pageup),\n+            \"\\ev\" => Event(events, :pageup),\n+            # Page down\n+            \"\\e[6~\" => Event(events, :pagedown),\n+            \"^V\" => Event(events, :pagedown),\n+            # Meta + < / >\n+            \"\\e<\" => Event(events, :jumpfirst),\n+            \"\\e>\" => Event(events, :jumplast),\n+            #\n+            \"^L\" => Event(events, :clear),\n+            # Exits\n+            \"^C\" => Returns(:abort),\n+            \"^D\" => Returns(:abort),\n+            \"^G\" => Returns(:abort),\n+            \"\\e\\e\" => Returns(:abort),\n+            \"^S\" => Returns(:save),\n+            \"^Y\" => Returns(:copy),\n+        ),\n+        REPL.LineEdit.default_keymap,\n+        REPL.LineEdit.escape_defaults])\n+end\n+\n+\"\"\"\n+    create_prompt(events::Channel{Symbol}, term)\n+\n+Initialize a custom REPL prompt tied to `events` using the existing `term`.\n+\n+Returns a tuple `(term, prompt, istate, pstate)` ready for\n+input handling and display.\n+\"\"\"\n+function create_prompt(events::Channel{Symbol}, term, prefix::String = \"\\e[90m\")\n+    prompt = REPL.LineEdit.Prompt(\n+        PROMPT_TEXT, # prompt\n+        prefix, \"\\e[0m\", # prompt_prefix, prompt_suffix\n+        \"\", \"\", \"\", # output_prefix, output_prefix_prefix, output_prefix_suffix\n+        select_keymap(events), # keymap_dict\n+        nothing, # repl\n+        REPL.LatexCompletions(), # complete\n+        _ -> true, # on_enter\n+        () -> nothing, # on_done\n+        REPL.LineEdit.EmptyHistoryProvider(), # hist\n+        false, # sticky\n+        REPL.StylingPasses.StylingPass[]) # styling_passes\n+    interface = REPL.LineEdit.ModalInterface([prompt])\n+    istate = REPL.LineEdit.init_state(term, interface)\n+    pstate = istate.mode_state[prompt]\n+    (; term, prompt, istate, pstate)\n+end\n+\n+\"\"\"\n+    runprompt!((; term,prompt,pstate,istate), events::Channel{Symbol})\n+\n+Drive the prompt input loop until confirm, save, or abort.\n+\n+Emits `:edit`, `:confirm`, `:save`, or `:abort` into `events`,\n+manages raw mode and bracketed paste, and cleans up on exit.\n+\"\"\"\n+function runprompt!((; term, prompt, pstate, istate), events::Channel{Symbol})\n+    Base.reseteof(term)\n+    REPL.LineEdit.raw!(term, true)\n+    REPL.LineEdit.enable_bracketed_paste(term)\n+    try\n+        pstate.ias = REPL.LineEdit.InputAreaState(0, 0)\n+        REPL.LineEdit.refresh_multi_line(term, pstate)\n+        while true\n+            kmap = REPL.LineEdit.keymap(pstate, prompt)\n+            matchfn = REPL.LineEdit.match_input(kmap, istate)\n+            kdata = REPL.LineEdit.keymap_data(pstate, prompt)\n+            status = matchfn(istate, kdata)\n+            if status === :ok\n+                push!(events, :edit)\n+            elseif status === :ignore\n+                istate.last_action = istate.current_action\n+            elseif status === :done\n+                print(\"\\e[F\")\n+                push!(events, :confirm)\n+                break\n+            elseif status === :copy\n+                print(\"\\e[1G\\e[J\")\n+                push!(events, status)\n+                break\n+            elseif status === :save\n+                print(\"\\e[1G\\e[J\")\n+                dest = savedest(term)\n+                if isnothing(dest)\n+                    push!(events, :redraw)\n+                else\n+                    push!(events, dest)\n+                    break\n+                end\n+            else\n+                push!(events, :abort)\n+                break\n+            end\n+        end\n+    finally\n+        REPL.LineEdit.raw!(term, false) &&\n+            REPL.LineEdit.disable_bracketed_paste(term)\n+    end\n+end\n+\n+function savedest(term::Base.Terminals.TTYTerminal)\n+    out = term.out_stream\n+    print(out, \"\\e[1G\\e[J\")\n+    clipsave = true\n+    try\n+        print(out, get(Base.current_terminfo(), :cursor_invisible, \"\"))\n+        fclip, ffile = [:emphasis, :bold], [:grey]\n+        char = '\\0'\n+        while true\n+            print(out, S\"\\e[1G\\e[2K{bold,grey:history>} {bold,emphasis:save to} {$fclip,inverse: Clipboard } {$ffile,inverse: File }   {shadow:Tab to toggle \u22c5 \u23ce to select}\")\n+            ichar = read(term.in_stream, Char)\n+            if ichar \u2208 ('\\x03', '\\x18', '\\a') || char == ichar == '\\e'\n+                return\n+            elseif ichar == '\\r'\n+                break\n+            end\n+            char = ichar\n+            fclip, ffile = ffile, fclip\n+            clipsave = !clipsave\n+        end\n+    finally\n+        # NOTE: While it may look like `:cursor_visible` would be the\n+        # appropriate choice to reverse `:cursor_invisible`, unfortunately\n+        # tmux-256color declares a sequence that doesn't actually make\n+        # the cursor become visible again \ud83d\ude11.\n+        print(out, get(Base.current_terminfo(), :cursor_normal, \"\"))\n+        print(out, \"\\e[1G\\e[2K\")\n+    end\n+    if clipsave; :copy else :filesave end\n+end"
    },
    {
      "sha": "51a781550fc1f4c4df989847620b5cf5698440e9",
      "filename": "stdlib/REPL/src/History/resumablefiltering.jl",
      "status": "added",
      "additions": 332,
      "deletions": 0,
      "changes": 332,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2Fresumablefiltering.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2Fresumablefiltering.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FHistory%2Fresumablefiltering.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -0,0 +1,332 @@\n+# This file is a part of Julia. License is MIT: https://julialang.org/license\n+\n+struct ConditionSet{S}\n+    words::Vector{SubString{S}}\n+    exacts::Vector{SubString{S}}\n+    negatives::Vector{SubString{S}}\n+    initialisms::Vector{SubString{S}}\n+    fuzzy::Vector{SubString{S}}\n+    regexps::Vector{SubString{S}}\n+    modes::Vector{SubString{S}}\n+end\n+\n+ConditionSet{S}() where {S} = ConditionSet{S}([], [], [], [], [], [], [])\n+\n+\"\"\"\n+    FILTER_SEPARATOR\n+\n+Character used to separate multiple search conditions in a single query.\n+\"\"\"\n+const FILTER_SEPARATOR = ';'\n+\n+\"\"\"\n+    FILTER_PREFIXES\n+\n+List of single-character prefixes that set search modes.\n+\"\"\"\n+const FILTER_PREFIXES = ('!', '`', '=', '/', '~', '>')\n+\n+\"\"\"\n+    FILTER_SHORTHELP_QUERY\n+\n+The special single-character query that triggers display of `FILTER_SHORTHELP`.\n+\"\"\"\n+const FILTER_SHORTHELP_QUERY = \"?\"\n+\n+\"\"\"\n+    FILTER_LONGHELP_QUERY\n+\n+The special query that triggers display of `FILTER_LONGHELP`.\n+\"\"\"\n+const FILTER_LONGHELP_QUERY = \"??\"\n+\n+\"\"\"\n+    FILTER_SHORTHELP\n+\n+Annotated help text displayed when the user enters the help query (`$FILTER_SHORTHELP_QUERY`).\n+\"\"\"\n+const FILTER_SHORTHELP = S\"\"\"\n+ {bold,magenta:Interactive history search}\n+\n+ Enter a search term at the prompt, and see matching candidates.\n+ A search term that is {italic:just} '{REPL_History_search_prefix:?}' brings up this help page.\n+\n+ See more information on behaviour and keybindings with '{REPL_History_search_prefix:??}'.\n+\n+ Different search modes are available via prefixes, as follows:\n+ {emphasis:\u2022} {REPL_History_search_prefix:=} looks for exact matches\n+ {emphasis:\u2022} {REPL_History_search_prefix:!} {italic:excludes} exact matches\n+ {emphasis:\u2022} {REPL_History_search_prefix:/} performs a regexp search\n+ {emphasis:\u2022} {REPL_History_search_prefix:~} looks for fuzzy matches\n+ {emphasis:\u2022} {REPL_History_search_prefix:>} looks for a particular REPL mode\n+ {emphasis:\u2022} {REPL_History_search_prefix:`} looks for an initialism (text with matching initials)\n+\n+ You can also apply multiple restrictions with the separator '{REPL_History_search_separator:$FILTER_SEPARATOR}'.\n+\n+ For example, {region:{REPL_History_search_prefix:/}^foo{REPL_History_search_separator:$FILTER_SEPARATOR}\\\n+{REPL_History_search_prefix:`}bar{REPL_History_search_separator:$FILTER_SEPARATOR}\\\n+{REPL_History_search_prefix:>}shell} will look for history entries that start with \"{code:foo}\",\n+ contains \"{code:b... a... r...}\", {italic:and} is a shell history entry.\n+\"\"\"\n+\n+const FILTER_LONGHELP = S\"\"\"\n+ {bold,magenta:Interactive history search \u2014 behaviour and keybindings}\n+\n+ Search your REPL history interactively by constructing filters.\n+\n+ With no mode specified (see the basic help with '{REPL_History_search_prefix:?}'), entries are matched\n+ if they contain all of the words in the search string, in any order.\n+\n+ If the entire search string is lowercase, the search is case-insensitive.\n+\n+ If you want to include the filter separator '{REPL_History_search_separator:$FILTER_SEPARATOR}' in a query, or start\n+ a words filter with a prefix character, you may escape it with a backslash (e.g. {code:\\\\;}).\n+\n+ Search results can be navigated with:\n+ {emphasis:\u2022} {code:\u2191}, {code:Ctrl+P}, or {code:Ctrl+K} to move up\n+ {emphasis:\u2022} {code:\u2193}, {code:Ctrl+N}, or {code:Ctrl+J} to move down\n+ {emphasis:\u2022} {code:PageUp} or {code:Ctrl+B} to page up\n+ {emphasis:\u2022} {code:PageDown} or {code:Ctrl+F} to page down\n+ {emphasis:\u2022} {code:Alt+<} to jump to the first result\n+ {emphasis:\u2022} {code:Alt+>} to jump to the last result\n+\n+ Multiple search results can be selected with {code:Tab} and confirmed with {code:Enter}.\n+ You may use {code:Ctrl+S} to save selected entries to a file or the clipboard.\n+\n+ To abort the search, use {code:Ctrl+C}, {code:Ctrl+D}, {code:Ctrl+G}, or {code:Esc Esc}.\n+\"\"\"\n+\n+\"\"\"\n+    ConditionSet(spec::AbstractString) -> ConditionSet\n+\n+Parse the raw search string `spec` into a `ConditionSet`.\n+\n+Parsing is performed by splitting on unescaped `FILTER_SEPARATOR` and\n+dispatching each segment according to its leading prefix character.\n+\"\"\"\n+function ConditionSet(spec::S) where {S <: AbstractString}\n+    function addcond!(condset::ConditionSet, cond::SubString)\n+        isempty(cond) && return\n+        kind = first(cond)\n+        if kind \u2208 ('!', '=', '`', '/', '>', '~')\n+            value = @view cond[2:end]\n+            if kind \u2208 ('`', '>', '~')\n+                value = strip(value)\n+            elseif !all(isspace, value)\n+                value = if kind == '/'\n+                    rstrip(value)\n+                else # kind \u2208 ('!', '=')\n+                    strip(value)\n+                end\n+            end\n+            isempty(value) && return\n+            if startswith(cond, '!')\n+                push!(condset.negatives, value)\n+            elseif startswith(cond, '=')\n+                push!(condset.exacts, value)\n+            elseif startswith(cond, '`')\n+                push!(condset.initialisms, value)\n+            elseif startswith(cond, '/')\n+                push!(condset.regexps, value)\n+            elseif startswith(cond, '>')\n+                push!(condset.modes, SubString(lowercase(value)))\n+            elseif startswith(cond, '~')\n+                push!(condset.fuzzy, value)\n+            end\n+        else\n+            if startswith(cond, '\\\\') && !(length(cond) > 1 && cond[2] == '\\\\')\n+                cond = @view cond[2:end]\n+            end\n+            push!(condset.words, strip(cond))\n+        end\n+        nothing\n+    end\n+    cset = ConditionSet{S}()\n+    pos = firstindex(spec)\n+    mark = pos\n+    lastind = lastindex(spec)\n+    escaped = false\n+    dropbytes = Int[]\n+    while pos <= lastind\n+        chr = spec[pos]\n+        if escaped\n+            chr == FILTER_SEPARATOR && push!(dropbytes, pos - mark)\n+            escaped = false\n+        elseif chr == '\\\\'\n+            escaped = true\n+        elseif chr == FILTER_SEPARATOR\n+            str = SubString(spec, mark:pos - 1)\n+            if !isempty(dropbytes)\n+                str = SubString(convert(S, String(deleteat!(collect(codeunits(str)), dropbytes))))\n+                empty!(dropbytes)\n+            end\n+            addcond!(cset, lstrip(str))\n+            mark = pos + 1\n+        end\n+        pos = nextind(spec, pos)\n+    end\n+    if mark <= lastind\n+        str = SubString(spec, mark:pos - 1)\n+        if !isempty(dropbytes)\n+            str = SubString(convert(S, String(deleteat!(collect(codeunits(str)), dropbytes))))\n+        end\n+        addcond!(cset, lstrip(SubString(spec, mark:lastind)))\n+    end\n+    cset\n+end\n+\n+\"\"\"\n+    ismorestrict(a::ConditionSet, b::ConditionSet) -> Bool\n+\n+Whether `a` is at least as restrictive as `b`, across all conditions.\n+\"\"\"\n+function ismorestrict(a::ConditionSet, b::ConditionSet)\n+    length(a.fuzzy) == length(b.fuzzy) &&\n+        all(splat(==), zip(a.fuzzy, b.fuzzy)) || return false\n+    length(a.regexps) == length(b.regexps) &&\n+        all(splat(==), zip(a.regexps, b.regexps)) || return false\n+    length(a.modes) == length(b.modes) &&\n+        all(splat(==), zip(a.modes, b.modes)) || return false\n+    length(a.exacts) >= length(b.exacts) &&\n+        all(splat(occursin), zip(b.exacts, a.exacts)) || return false\n+    length(a.words) >= length(b.words) &&\n+        all(splat(occursin), zip(b.words, a.words)) || return false\n+    length(a.negatives) >= length(b.negatives) &&\n+        all(splat(occursin), zip(a.negatives, b.negatives)) || return false\n+    length(a.initialisms) >= length(b.initialisms) &&\n+        all(splat(occursin), zip(b.initialisms, a.initialisms)) || return false\n+    true\n+end\n+\n+struct FilterSpec\n+    exacts::Vector{String}\n+    negatives::Vector{String}\n+    regexps::Vector{Regex}\n+    modes::Vector{Symbol}\n+end\n+\n+FilterSpec() = FilterSpec([], [], [], [])\n+\n+function FilterSpec(cset::ConditionSet)\n+    spec = FilterSpec([], [], [], [])\n+    for term in cset.exacts\n+        push!(spec.exacts, String(term))\n+    end\n+    for words in cset.words\n+        casesensitive = any(isuppercase, words)\n+        for word in eachsplit(words)\n+            if casesensitive\n+                push!(spec.exacts, String(word))\n+            else\n+                push!(spec.regexps, Regex(string(\"\\\\Q\", word, \"\\\\E\"), \"i\"))\n+            end\n+        end\n+    end\n+    for term in cset.negatives\n+        push!(spec.negatives, String(term))\n+    end\n+    for rx in cset.regexps\n+        try\n+            push!(spec.regexps, Regex(rx))\n+        catch _\n+            # Regex error, skip\n+        end\n+    end\n+    for itlsm in cset.initialisms\n+        rx = Regex(join((string(\"(?:(?:\\\\b|_+)(?:\\\\Q\", ltr, \"\\\\E|\\\\Q\", uppercase(ltr),\n+                                \"\\\\E)\\\\w+|\\\\p{Ll}\\\\Q\", uppercase(ltr), \"\\\\E)\")\n+                         for ltr in itlsm), \"[\\\\W_]*?\"))\n+        push!(spec.regexps, rx)\n+    end\n+    for fuzz in cset.fuzzy\n+        for word in eachsplit(fuzz)\n+            rx = Regex(join((string(\"\\\\Q\", ltr, \"\\\\E\") for ltr in word), \"[^\\\\s\\\"#%&()*+,\\\\-\\\\/:;<=>?@[\\\\]^`{|}~]*?\"),\n+                       ifelse(any(isuppercase, fuzz), \"\", \"i\"))\n+            push!(spec.regexps, rx)\n+        end\n+    end\n+    for mode in cset.modes\n+        push!(spec.modes, Symbol(mode))\n+    end\n+    spec\n+end\n+\n+\n+\"\"\"\n+    filterchunkrev!(out, candidates, spec; idx, maxtime, maxresults) -> Int\n+\n+Incrementally filter `candidates[1:idx]` in reverse order.\n+\n+Pushes matches onto `out` until either `maxtime` is exceeded or `maxresults`\n+collected, then returns the new resume index.\n+\"\"\"\n+function filterchunkrev!(out::Vector{HistEntry}, candidates::DenseVector{HistEntry},\n+                         spec::FilterSpec, idx::Int = length(candidates);\n+                         maxtime::Float64 = Inf, maxresults::Int = length(candidates))\n+    batchsize = clamp(length(candidates) \u00f7 512, 10, 1000)\n+    for batch in Iterators.partition(idx:-1:1, batchsize)\n+        time() > maxtime && break\n+        for outer idx in batch\n+            entry = candidates[idx]\n+            if !isempty(spec.modes)\n+                entry.mode \u2208 spec.modes || continue\n+            end\n+            matchfail = false\n+            for text in spec.exacts\n+                if !occursin(text, entry.content)\n+                    matchfail = true\n+                    break\n+                end\n+            end\n+            matchfail && continue\n+            for text in spec.negatives\n+                if occursin(text, entry.content)\n+                    matchfail = true\n+                    break\n+                end\n+            end\n+            matchfail && continue\n+            for rx in spec.regexps\n+                if !occursin(rx, entry.content)\n+                    matchfail = true\n+                    break\n+                end\n+            end\n+            matchfail && continue\n+            pushfirst!(out, entry)\n+            length(out) == maxresults && break\n+        end\n+    end\n+    max(0, idx - 1)\n+end\n+\n+\"\"\"\n+    matchregions(spec::FilterSpec, candidate::AbstractString) -> Vector{UnitRange{Int}}\n+\n+Find all matching character ranges in `candidate` for `spec`.\n+\n+Collects exact-substring and regex matches, then returns them\n+sorted by start index (and longer matches first).\n+\"\"\"\n+function matchregions(spec::FilterSpec, candidate::AbstractString)\n+    matches = UnitRange{Int}[]\n+    for text in spec.exacts\n+        append!(matches, findall(text, candidate))\n+    end\n+    for rx in spec.regexps\n+        for (; match) in eachmatch(rx, candidate)\n+            push!(matches, 1+match.offset:thisind(candidate, match.offset + match.ncodeunits))\n+        end\n+    end\n+    sort!(matches, by = m -> (first(m), -last(m)))\n+    # Combine adjacent matches separated by a single space\n+    for (i, match) in enumerate(matches)\n+        i == length(matches) && break\n+        nextmatch = matches[i + 1]\n+        if last(match) + 1 == first(nextmatch) - 1 && candidate[last(match)+1] == ' '\n+            matches[i] = first(match):last(nextmatch)\n+            matches[i+1] = last(nextmatch)+1:last(nextmatch)\n+        end\n+    end\n+    filter!(!isempty, matches)\n+end"
    },
    {
      "sha": "8b5e20fc0385f98d52161375d25e8d21dc63c03e",
      "filename": "stdlib/REPL/src/History/search.jl",
      "status": "added",
      "additions": 375,
      "deletions": 0,
      "changes": 375,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2Fsearch.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FHistory%2Fsearch.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FHistory%2Fsearch.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -0,0 +1,375 @@\n+# This file is a part of Julia. License is MIT: https://julialang.org/license\n+\n+\"\"\"\n+    runsearch() -> (; mode::Union{Symbol, Nothing}, text::String)\n+\n+Launch the interactive REPL history search interface.\n+\n+Spawns prompt and display tasks, waits for user confirm or abort,\n+and returns the final selection (if any).\n+\"\"\"\n+function runsearch(histfile::HistoryFile, term, prefix::String = \"\\e[90m\")\n+    update!(histfile)\n+    events = Channel{Symbol}(Inf)\n+    pspec = create_prompt(events, term, prefix)\n+    ptask = @spawn runprompt!(pspec, events)\n+    dtask = @spawn run_display!(pspec, events, histfile.records)\n+    wait(ptask)\n+    fullselection(fetch(dtask))\n+end\n+\n+\"\"\"\n+    fullselection(state::SelectorState) -> (; mode::Symbol, text::String)\n+\n+Gather all selected and hovered entries and return them as joined text.\n+\"\"\"\n+function fullselection(state::SelectorState)\n+    text = IOBuffer()\n+    entries = copy(state.selection.gathered)\n+    for act in state.selection.active\n+        push!(entries, state.candidates[act])\n+    end\n+    if isempty(entries) && state.hover \u2208 axes(state.candidates, 1)\n+        push!(entries, state.candidates[end-state.hover+1])\n+    end\n+    sort!(entries, by = e -> e.index)\n+    mainmode = if !isempty(entries) first(entries).mode end\n+    join(text, Iterators.map(e -> e.content, entries), '\\n')\n+    (mode = mainmode, text = String(take!(text)))\n+end\n+\n+\"\"\"\n+    run_display!((; term,pstate), events::Channel{Symbol}, hist::Vector{HistEntry})\n+\n+Drive the display event loop until confirm or abort.\n+\n+Listens for navigation, edits, save, and abort events, re-filters history\n+incrementally, and re-renders via `redisplay_all`.\n+\"\"\"\n+function run_display!((; term, pstate), events::Channel{Symbol}, hist::Vector{HistEntry})\n+    # Output-related variables\n+    out = term.out_stream\n+    outsize = displaysize(out)\n+    buf = IOContext(IOBuffer(), out)\n+    # Main state variables\n+    state = SelectorState(outsize, \"\", FilterSpec(), hist)\n+    redisplay_all(out, EMPTY_STATE, state, pstate; buf)\n+    # Candidate cache\n+    cands_cache = Pair{ConditionSet{String}, Vector{HistEntry}}[]\n+    cands_cachestate = zero(UInt8)\n+    cands_current = HistEntry[]\n+    cands_cond = ConditionSet{String}()\n+    cands_temp = HistEntry[]\n+    # Filter state\n+    filter_idx = 0\n+    # Event loop\n+    while true\n+        event = @lock events if !isempty(events) take!(events) end\n+        if isnothing(event)\n+        elseif event === :abort\n+            print(out, \"\\e[1G\\e[J\")\n+            return EMPTY_STATE\n+        elseif event === :confirm\n+            print(out, \"\\e[1G\\e[J\")\n+            return state\n+        elseif event === :clear\n+            print(out, \"\\e[H\\e[2J\")\n+            redisplay_all(out, EMPTY_STATE, state, pstate; buf)\n+            continue\n+        elseif event === :redraw\n+            print(out, \"\\e[1G\\e[J\")\n+            redisplay_all(out, EMPTY_STATE, state, pstate; buf)\n+            continue\n+        elseif event \u2208 (:up, :down, :pageup, :pagedown)\n+            prevstate, state = state, movehover(state, event \u2208 (:up, :pageup), event \u2208 (:pageup, :pagedown))\n+            @lock events begin\n+                nextevent = if !isempty(events) first(events.data) end\n+                while nextevent \u2208 (:up, :down, :pageup, :pagedown)\n+                    take!(events)\n+                    state = movehover(state, nextevent \u2208 (:up, :pageup), event \u2208 (:pageup, :pagedown))\n+                    nextevent = if !isempty(events) first(events.data) end\n+                end\n+            end\n+            redisplay_all(out, prevstate, state, pstate; buf)\n+            continue\n+        elseif event === :jumpfirst\n+            prevstate = state\n+            state = SelectorState(\n+                state.area, state.query, state.filter, state.candidates,\n+                length(state.candidates) - componentrows(state).candidates,\n+                state.selection, length(state.candidates))\n+            redisplay_all(out, prevstate, state, pstate; buf)\n+            continue\n+        elseif event === :jumplast\n+            prevstate = state\n+            state = SelectorState(\n+                state.area, state.query, state.filter, state.candidates,\n+                0, state.selection, 1)\n+            redisplay_all(out, prevstate, state, pstate; buf)\n+            continue\n+        elseif event === :tab\n+            prevstate, state = state, toggleselection(state)\n+            redisplay_all(out, prevstate, state, pstate; buf)\n+            continue\n+        elseif event === :edit\n+            @lock events begin\n+                while !isempty(events) && first(events.data) === :edit\n+                    take!(events)\n+                end\n+            end\n+            query = REPL.LineEdit.input_string(pstate)\n+            if query === state.query\n+                redisplay_all(out, state, state, pstate; buf)\n+                continue\n+            end\n+            # Determine the conditions/filter spec\n+            cands_cond = ConditionSet(query)\n+            filter_spec = FilterSpec(cands_cond)\n+            # Construct a provisional new state\n+            prevstate, state = state, SelectorState(\n+                outsize, query, filter_spec, HistEntry[], state.selection.gathered)\n+            # Gather selected candidates\n+            if !isempty(prevstate.selection.active)\n+                for act in prevstate.selection.active\n+                    push!(state.selection.gathered, prevstate.candidates[act])\n+                end\n+                sort!(state.selection.gathered, by = e -> e.index)\n+                state = SelectorState(\n+                    state.area, state.query, state.filter, state.candidates,\n+                    -min(length(state.selection.gathered), state.area.height \u00f7 8),\n+                    state.selection, 1)\n+            end\n+            # Show help?\n+            if query \u2208 (FILTER_SHORTHELP_QUERY,FILTER_LONGHELP_QUERY)\n+                redisplay_all(out, prevstate, state, pstate; buf)\n+                continue\n+            end\n+            # Parse the conditions and find a good candidate list\n+            cands_current = hist\n+            for (cond, cands) in Iterators.reverse(cands_cache)\n+                if ismorestrict(cands_cond, cond)\n+                    cands_current = cands\n+                    break\n+                end\n+            end\n+            # Start filtering candidates\n+            filter_idx = filterchunkrev!(\n+                state, cands_current;\n+                maxtime = time() + 0.01,\n+                maxresults = outsize[1])\n+            if filter_idx == 0\n+                cands_cachestate = addcache!(\n+                    cands_cache, cands_cachestate, cands_cond => state.candidates)\n+            end\n+            redisplay_all(out, prevstate, state, pstate; buf)\n+            continue\n+        elseif event === :copy\n+            content = strip(fullselection(state).text)\n+            isempty(content) || saveclipboard(term.out_stream, content)\n+            return EMPTY_STATE\n+        elseif event === :filesave\n+            content = strip(fullselection(state).text)\n+            isempty(content) || savefile(term, content)\n+            return EMPTY_STATE\n+        else\n+            error(\"Unknown event: $event\")\n+        end\n+        if displaysize(out) != outsize\n+            outsize = displaysize(out)\n+            prevstate, state = state, SelectorState(\n+                outsize, state.query, state.filter, state.candidates,\n+                state.scroll, state.selection, state.hover)\n+            redisplay_all(out, prevstate, state, pstate; buf)\n+        elseif filter_idx != 0\n+            append!(empty!(cands_temp), state.candidates)\n+            prevstate = SelectorState(\n+                state.area, state.query, state.filter, cands_temp,\n+                state.scroll, state.selection, state.hover)\n+            filter_idx = filterchunkrev!(\n+                state, cands_current, filter_idx;\n+                maxtime = time() + 0.01)\n+            if filter_idx == 0\n+                cands_cachestate = addcache!(\n+                    cands_cache, cands_cachestate, cands_cond => state.candidates)\n+            end\n+            # If there are now new candidates in the view, update\n+            length(state.candidates) != length(prevstate.candidates) &&\n+                length(prevstate.candidates) - state.hover < outsize[1] &&\n+                redisplay_all(out, prevstate, state, pstate; buf)\n+        elseif isnothing(event)\n+            yield()\n+            sleep(0.01)\n+        end\n+    end\n+end\n+\n+function filterchunkrev!(state::SelectorState, candidates::DenseVector{HistEntry}, idx::Int = length(candidates);\n+                         maxtime::Float64 = Inf, maxresults::Int = length(candidates))\n+    oldlen = length(state.candidates)\n+    idx = filterchunkrev!(state.candidates, candidates, state.filter, idx;\n+                          maxtime = maxtime, maxresults = maxresults)\n+    newlen = length(state.candidates)\n+    newcands = view(state.candidates, (oldlen + 1):newlen)\n+    gfound = Int[]\n+    for (i, g) in enumerate(state.selection.gathered)\n+        cind = searchsorted(newcands, g, by = e -> e.index)\n+        isempty(cind) && continue\n+        push!(state.selection.active, oldlen + first(cind))\n+        push!(gfound, i)\n+    end\n+    isempty(gfound) || deleteat!(state.selection.gathered, gfound)\n+    idx\n+end\n+\n+\"\"\"\n+    movehover(state::SelectorState, backwards::Bool, page::Bool)\n+\n+Move the hover cursor in `state` by one row or one page.\n+\n+The direction and size of the move is determined by `backwards` and `page`.\n+\"\"\"\n+function movehover(state::SelectorState, backwards::Bool, page::Bool)\n+    candrows = componentrows(state).candidates\n+    shift = ifelse(backwards, 1, -1) * ifelse(page, max(1, candrows - 1), 1)\n+    # We need to adjust for the existence of the gathered selection,\n+    # and the division line depending on whether it will still be\n+    # visible after the move.\n+    if !isempty(state.selection.gathered) && state.scroll < 0 &&\n+        state.hover + shift + state.scroll <= candrows\n+        candrows -= 1\n+        shift -= page\n+    end\n+    ngathered = length(state.selection.gathered)\n+    if page && state.scroll < 0 && state.hover < shift\n+        shift -= min(-state.scroll, ngathered) - 2 * (state.hover == -1)\n+    end\n+    newhover = state.hover + shift\n+    # This looks a little funky because we want to produce a particular\n+    # behaviour when crossing between the active and gathered selection, namely\n+    # we want to ensure it always takes an explicit step to go from one section\n+    # to another and skip over 0 as an invalid position.\n+    newhover = if sign(newhover) == sign(state.hover) || (abs(state.hover) == 1 && newhover != 0)\n+        clamp(newhover, -ngathered + iszero(ngathered), max(1, length(state.candidates)))\n+    elseif ngathered == 0\n+        1\n+    elseif newhover == 0\n+        -sign(state.hover)\n+    else\n+        sign(state.hover)\n+    end\n+    newscroll = clamp(state.scroll,\n+                      max(-ngathered, newhover - candrows + (ngathered >= candrows)),\n+                      newhover - (newhover >= 0))\n+    SelectorState(\n+        state.area, state.query, state.filter, state.candidates,\n+        newscroll, state.selection, newhover)\n+end\n+\n+\"\"\"\n+    toggleselection(state::SelectorState)\n+\n+Vary the selection of the current candidate (selected by hover) in `state`.\n+\"\"\"\n+function toggleselection(state::SelectorState)\n+    newselection = if state.hover > 0\n+        hoveridx = length(state.candidates) - state.hover + 1\n+        hoveridx \u2208 axes(state.candidates, 1) || return state\n+        activecopy = copy(state.selection.active)\n+        selsearch = searchsorted(activecopy, hoveridx)\n+        if isempty(selsearch)\n+            insert!(activecopy, first(selsearch), hoveridx)\n+        else\n+            elt = activecopy[selsearch]\n+            gidx = findfirst(==(elt), state.selection.gathered)\n+            isnothing(gidx) || deleteat!(state.selection.gathered, gidx)\n+            deleteat!(activecopy, first(selsearch))\n+        end\n+        (active = activecopy, gathered = state.selection.gathered)\n+    elseif state.hover < 0\n+        -state.hover \u2208 axes(state.selection.gathered, 1) || return state\n+        gatheredcopy = copy(state.selection.gathered)\n+        deleteat!(gatheredcopy, -state.hover)\n+        (active = state.selection.active, gathered = gatheredcopy)\n+    else\n+        return state\n+    end\n+    newstate = SelectorState(\n+        state.area, state.query, state.filter, state.candidates,\n+        state.scroll, newselection, state.hover)\n+    movehover(newstate, false, false)\n+end\n+\n+\"\"\"\n+    addcache!(cache::Vector{T}, state::Unsigned, new::T)\n+\n+Add `new` to the log-structured `cache` according to `state`.\n+\n+The lifetime of `new` is exponentially decaying, it has a `1` in `2^(k-1)`\n+chance of reaching the `k`-th position in the cache.\n+\n+The cache can hold as many items as the number of bits in `state` (e.g. 8 for `UInt8`).\n+\"\"\"\n+function addcache!(cache::Vector{T}, state::Unsigned, new::T) where {T}\n+    maxsize = sizeof(state) * 8\n+    nextstate = state + one(state)\n+    shift = state \u22bb nextstate\n+    uninitialised = maxsize - length(cache)\n+    if Base.leading_zeros(nextstate) < uninitialised\n+        push!(cache, new)\n+        return nextstate\n+    end\n+    for b in 1:(maxsize - 1)\n+        iszero(shift & (0x1 << (maxsize - b))) && continue\n+        cache[b - uninitialised] = cache[b - uninitialised + 1]\n+    end\n+    cache[end] = new\n+    nextstate\n+end\n+\n+\"\"\"\n+    savefile(term::Base.Terminals.TTYTerminal, content::AbstractString)\n+\n+Prompt the user to save `content` to a file path, and record the action.\n+\"\"\"\n+function savefile(term::Base.Terminals.TTYTerminal, content::AbstractString)\n+    out = term.out_stream\n+    nlines = count('\\n', content) + 1\n+    print(out, S\"\\e[1G\\e[2K{grey,bold:history>} {bold,emphasis:save file: }\")\n+    filename = try\n+        readline(term.in_stream)\n+    catch err\n+        if err isa InterruptException\n+            \"\"\n+        else\n+            rethrow()\n+        end\n+    end\n+    if isempty(filename)\n+        println(out, S\"\\e[F\\e[2K{light,grey:{bold:history>} {red:\u00d7} History selection aborted}\\n\")\n+        return\n+    end\n+    open(filename, \"w\") do io\n+        seekend(io)\n+        if !iszero(position(io))\n+            seek(io, position(io) - 1)\n+            lastchar = read(io, UInt8)\n+            seekend(io)\n+            lastchar == UInt8('\\n') || write(io, '\\n')\n+        end\n+        write(io, content, '\\n')\n+    end\n+    println(out, S\"\\e[F\\e[2K{grey,bold:history>} {shadow:Wrote $nlines selected \\\n+                   $(ifelse(nlines == 1, \\\"line\\\", \\\"lines\\\")) to {underline,link=$(abspath(filename)):$filename}}\\n\")\n+end\n+\n+\"\"\"\n+    saveclipboard(term::Base.Terminals.TTYTerminal, content::AbstractString)\n+\n+Save `content` to the clipboard and record the action.\n+\"\"\"\n+function saveclipboard(msgio::IO, content::AbstractString)\n+    nlines = count('\\n', content) + 1\n+    clipboard(content)\n+    println(msgio, S\"\\e[1G\\e[2K{grey,bold:history>} {shadow:Copied $nlines \\\n+                     $(ifelse(nlines == 1, \\\"line\\\", \\\"lines\\\")) to clipboard}\\n\")\n+end"
    },
    {
      "sha": "e11dab5ccad4a3b83c48e1023b94b61a5ad6b6bc",
      "filename": "stdlib/REPL/src/LineEdit.jl",
      "status": "modified",
      "additions": 46,
      "deletions": 206,
      "changes": 252,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FLineEdit.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -5,6 +5,7 @@ module LineEdit\n import ..REPL\n using ..REPL: AbstractREPL, Options\n using ..REPL.StylingPasses: StylingPass, SyntaxHighlightPass, RegionHighlightPass, EnclosingParenHighlightPass, StylingContext, apply_styling_passes, merge_annotations\n+using ..REPL: histsearch\n \n using ..Terminals\n import ..Terminals: raw!, width, height, clear_line, beep\n@@ -621,7 +622,7 @@ function refresh_multi_line(termbuf::TerminalBuffer, terminal::UnixTerminal, buf\n     prompt_obj = nothing\n     if prompt isa PromptState\n         prompt_obj = prompt.p\n-    elseif prompt isa PrefixSearchState || prompt isa SearchState\n+    elseif prompt isa PrefixSearchState\n         if isdefined(prompt, :parent) && prompt.parent isa Prompt\n             prompt_obj = prompt.parent\n         end\n@@ -2237,67 +2238,6 @@ let\n     end\n end\n \n-mutable struct HistoryPrompt <: TextInterface\n-    hp::HistoryProvider\n-    complete::CompletionProvider\n-    keymap_dict::Dict{Char,Any}\n-    HistoryPrompt(hp) = new(hp, EmptyCompletionProvider())\n-end\n-\n-mutable struct SearchState <: ModeState\n-    terminal::AbstractTerminal\n-    histprompt::HistoryPrompt\n-    #rsearch (true) or ssearch (false)\n-    backward::Bool\n-    query_buffer::IOBuffer\n-    response_buffer::IOBuffer\n-    failed::Bool\n-    ias::InputAreaState\n-    #The prompt whose input will be replaced by the matched history\n-    parent::Prompt\n-    SearchState(terminal, histprompt, backward, query_buffer, response_buffer) =\n-        new(terminal, histprompt, backward, query_buffer, response_buffer, false, InputAreaState(0,0))\n-end\n-\n-init_state(terminal, p::HistoryPrompt) = SearchState(terminal, p, true, IOBuffer(), IOBuffer())\n-\n-terminal(s::SearchState) = s.terminal\n-\n-function update_display_buffer(s::SearchState, data::ModeState)\n-    s.failed = !history_search(data.histprompt.hp, data.query_buffer, data.response_buffer, data.backward, false)\n-    s.failed && beep(s)\n-    refresh_line(s)\n-    nothing\n-end\n-\n-function history_next_result(s::MIState, data::ModeState)\n-    data.failed = !history_search(data.histprompt.hp, data.query_buffer, data.response_buffer, data.backward, true)\n-    data.failed && beep(s)\n-    refresh_line(data)\n-    nothing\n-end\n-\n-function history_set_backward(s::SearchState, backward::Bool)\n-    s.backward = backward\n-    nothing\n-end\n-\n-input_string(s::SearchState) = takestring!(copy(s.query_buffer))\n-\n-function reset_state(s::SearchState)\n-    if s.query_buffer.size != 0\n-        s.query_buffer.size = 0\n-        s.query_buffer.ptr = 1\n-    end\n-    if s.response_buffer.size != 0\n-        s.response_buffer.size = 0\n-        s.response_buffer.ptr = 1\n-    end\n-    reset_state(s.histprompt.hp)\n-    s.failed = false\n-    nothing\n-end\n-\n # a meta-prompt that presents itself as parent_prompt, but which has an independent keymap\n # for prefix searching\n mutable struct PrefixHistoryPrompt <: TextInterface\n@@ -2331,7 +2271,7 @@ function Base.getproperty(s::ModeState, name::Symbol)\n     elseif name === :prompt\n         return getfield(s, :prompt)::Prompt\n     elseif name === :histprompt\n-        return getfield(s, :histprompt)::Union{HistoryPrompt,PrefixHistoryPrompt}\n+        return getfield(s, :histprompt)::PrefixHistoryPrompt\n     elseif name === :parent\n         return getfield(s, :parent)::Prompt\n     elseif name === :response_buffer\n@@ -2408,53 +2348,17 @@ function replace_line(s::PrefixSearchState, l::Union{String,SubString{String}})\n     nothing\n end\n \n-function write_prompt(terminal, s::SearchState, color::Bool)\n-    failed = s.failed ? \"failed \" : \"\"\n-    promptstr = s.backward ? \"($(failed)reverse-i-search)`\" : \"($(failed)forward-i-search)`\"\n-    write(terminal, promptstr)\n-    return textwidth(promptstr)\n-end\n-\n-function refresh_multi_line(termbuf::TerminalBuffer, s::SearchState)\n-    buf = IOBuffer()\n-    unsafe_write(buf, pointer(s.query_buffer.data), s.query_buffer.ptr-1)\n-    write(buf, \"': \")\n-    offset = buf.ptr\n-    ptr = s.response_buffer.ptr\n-    seek(s.response_buffer, 0)\n-    write(buf, read(s.response_buffer, String))\n-    buf.ptr = offset + ptr - 1\n-    s.response_buffer.ptr = ptr\n-    ias = refresh_multi_line(termbuf, s.terminal, buf, s.ias, s)\n-    s.ias = ias\n-    return ias\n-end\n-\n state(s::MIState, p::TextInterface=mode(s)) = s.mode_state[p]\n state(s::PromptState, p::Prompt=mode(s)) = (@assert s.p == p; s)\n \n mode(s::MIState) = s.current_mode   # ::TextInterface, and might be a Prompt\n mode(s::PromptState) = s.p          # ::Prompt\n-mode(s::SearchState) = @assert false\n mode(s::PrefixSearchState) = s.histprompt.parent_prompt   # ::Prompt\n \n setmodifiers!(s::MIState, m::Modifiers) = setmodifiers!(mode(s), m)\n setmodifiers!(p::Prompt, m::Modifiers) = setmodifiers!(p.complete, m)\n setmodifiers!(c) = nothing\n \n-# Search Mode completions\n-function complete_line(s::SearchState, repeats, mod::Module; hint::Bool=false)\n-    completions, reg, should_complete = complete_line(s.histprompt.complete, s, mod; hint)\n-    # For now only allow exact completions in search mode\n-    if length(completions) == 1\n-        prev_pos = position(s)\n-        push_undo(s)\n-        edit_splice!(s, (prev_pos - reg.second - reg.first) => prev_pos, completions[1].completion)\n-        return true\n-    end\n-    return false\n-end\n-\n accept_result_newmode(hp::HistoryProvider) = nothing\n function accept_result(s::MIState, p::TextInterface)\n     parent = something(accept_result_newmode(p.hp), state(s, p).parent)\n@@ -2474,24 +2378,6 @@ function copybuf!(dst::IOBuffer, src::IOBuffer)\n     nothing\n end\n \n-function enter_search(s::MIState, p::HistoryPrompt, backward::Bool)\n-    # a bit of hack to help fix #6325\n-    buf = copy(buffer(s))\n-    parent = mode(s)\n-    p.hp.last_mode = mode(s)\n-    p.hp.last_buffer = buf\n-\n-    transition(s, p) do\n-        ss = state(s, p)\n-        ss.parent = parent\n-        ss.backward = backward\n-        truncate(ss.query_buffer, 0)\n-        ss.failed = false\n-        copybuf!(ss.response_buffer, buf)\n-    end\n-    nothing\n-end\n-\n function enter_prefix_search(s::MIState, p::PrefixHistoryPrompt, backward::Bool)\n     buf = copy(buffer(s))\n     parent = mode(s)\n@@ -2514,92 +2400,8 @@ function enter_prefix_search(s::MIState, p::PrefixHistoryPrompt, backward::Bool)\n     nothing\n end\n \n-function setup_search_keymap(hp)\n-    p = HistoryPrompt(hp)\n-    pkeymap = AnyDict(\n-        \"^R\"      => (s::MIState,data::ModeState,c)->(history_set_backward(data, true); history_next_result(s, data)),\n-        \"^S\"      => (s::MIState,data::ModeState,c)->(history_set_backward(data, false); history_next_result(s, data)),\n-        '\\r'      => (s::MIState,o...)->accept_result(s, p),\n-        '\\n'      => '\\r',\n-        # Limited form of tab completions\n-        '\\t'      => (s::MIState,data::ModeState,c)->(complete_line(s); update_display_buffer(s, data)),\n-        \"^L\"      => (s::MIState,data::ModeState,c)->(Terminals.clear(terminal(s)); update_display_buffer(s, data)),\n-\n-        # Backspace/^H\n-        '\\b'      => (s::MIState,data::ModeState,c)->(edit_backspace(data.query_buffer) ?\n-                        update_display_buffer(s, data) : beep(s)),\n-        127       => KeyAlias('\\b'),\n-        # Meta Backspace\n-        \"\\e\\b\"    => (s::MIState,data::ModeState,c)->(isempty(edit_delete_prev_word(data.query_buffer)) ?\n-                                  beep(s) : update_display_buffer(s, data)),\n-        \"\\e\\x7f\"  => \"\\e\\b\",\n-        # Word erase to whitespace\n-        \"^W\"      => (s::MIState,data::ModeState,c)->(isempty(edit_werase(data.query_buffer)) ?\n-                                  beep(s) : update_display_buffer(s, data)),\n-        # ^C and ^D\n-        \"^C\"      => (s::MIState,data::ModeState,c)->(edit_clear(data.query_buffer);\n-                       edit_clear(data.response_buffer);\n-                       update_display_buffer(s, data);\n-                       reset_state(data.histprompt.hp);\n-                       transition(s, data.parent)),\n-        \"^D\"      => \"^C\",\n-        # Other ways to cancel search mode (it's difficult to bind \\e itself)\n-        \"^G\"      => \"^C\",\n-        \"\\e\\e\"    => \"^C\",\n-        \"^K\"      => (s::MIState,o...)->transition(s, state(s, p).parent),\n-        \"^Y\"      => (s::MIState,data::ModeState,c)->(edit_yank(s); update_display_buffer(s, data)),\n-        \"^U\"      => (s::MIState,data::ModeState,c)->(edit_clear(data.query_buffer);\n-                     edit_clear(data.response_buffer);\n-                     update_display_buffer(s, data)),\n-        # Right Arrow\n-        \"\\e[C\"    => (s::MIState,o...)->(accept_result(s, p); edit_move_right(s)),\n-        # Left Arrow\n-        \"\\e[D\"    => (s::MIState,o...)->(accept_result(s, p); edit_move_left(s)),\n-        # Up Arrow\n-        \"\\e[A\"    => (s::MIState,o...)->(accept_result(s, p); edit_move_up(s)),\n-        # Down Arrow\n-        \"\\e[B\"    => (s::MIState,o...)->(accept_result(s, p); edit_move_down(s)),\n-        \"^B\"      => (s::MIState,o...)->(accept_result(s, p); edit_move_left(s)),\n-        \"^F\"      => (s::MIState,o...)->(accept_result(s, p); edit_move_right(s)),\n-        # Meta B\n-        \"\\eb\"     => (s::MIState,o...)->(accept_result(s, p); edit_move_word_left(s)),\n-        # Meta F\n-        \"\\ef\"     => (s::MIState,o...)->(accept_result(s, p); edit_move_word_right(s)),\n-        # Ctrl-Left Arrow\n-        \"\\e[1;5D\" => \"\\eb\",\n-        # Ctrl-Left Arrow on rxvt\n-        \"\\eOd\" => \"\\eb\",\n-        # Ctrl-Right Arrow\n-        \"\\e[1;5C\" => \"\\ef\",\n-        # Ctrl-Right Arrow on rxvt\n-        \"\\eOc\" => \"\\ef\",\n-        \"^A\"         => (s::MIState,o...)->(accept_result(s, p); move_line_start(s); refresh_line(s)),\n-        \"^E\"         => (s::MIState,o...)->(accept_result(s, p); move_line_end(s); refresh_line(s)),\n-        \"^Z\"      => (s::MIState,o...)->(return :suspend),\n-        # Try to catch all Home/End keys\n-        \"\\e[H\"    => (s::MIState,o...)->(accept_result(s, p); move_input_start(s); refresh_line(s)),\n-        \"\\e[F\"    => (s::MIState,o...)->(accept_result(s, p); move_input_end(s); refresh_line(s)),\n-        # Use ^N and ^P to change search directions and iterate through results\n-        \"^N\"      => (s::MIState,data::ModeState,c)->(history_set_backward(data, false); history_next_result(s, data)),\n-        \"^P\"      => (s::MIState,data::ModeState,c)->(history_set_backward(data, true); history_next_result(s, data)),\n-        # Bracketed paste mode\n-        \"\\e[200~\" => (s::MIState,data::ModeState,c)-> begin\n-            ps = state(s, mode(s))\n-            input = readuntil(ps.terminal, \"\\e[201~\", keep=false)\n-            edit_insert(data.query_buffer, input); update_display_buffer(s, data)\n-        end,\n-        \"*\"       => (s::MIState,data::ModeState,c::StringLike)->(edit_insert(data.query_buffer, c); update_display_buffer(s, data))\n-    )\n-    p.keymap_dict = keymap([pkeymap, escape_defaults])\n-    skeymap = AnyDict(\n-        \"^R\"    => (s::MIState,o...)->(enter_search(s, p, true)),\n-        \"^S\"    => (s::MIState,o...)->(enter_search(s, p, false)),\n-    )\n-    return (p, skeymap)\n-end\n-\n-keymap(state, p::Union{HistoryPrompt,PrefixHistoryPrompt}) = p.keymap_dict\n-keymap_data(state, ::Union{HistoryPrompt, PrefixHistoryPrompt}) = state\n+keymap(state, p::PrefixHistoryPrompt) = p.keymap_dict\n+keymap_data(state, ::PrefixHistoryPrompt) = state\n \n Base.isempty(s::PromptState) = s.input_buffer.size == 0\n \n@@ -2641,8 +2443,12 @@ function move_line_end(buf::IOBuffer)\n     nothing\n end\n \n-edit_insert_last_word(s::MIState) =\n-    edit_insert(s, get_last_word(IOBuffer(mode(s).hist.history[end])))\n+function edit_insert_last_word(s::MIState)\n+    hist = mode(s).hist.history\n+    isempty(hist) && return 0\n+    isempty(hist.records) && return 0\n+    edit_insert(s, get_last_word(IOBuffer(hist[end].content)))\n+end\n \n function get_last_word(buf::IOBuffer)\n     move_line_end(buf)\n@@ -2868,6 +2674,9 @@ AnyDict(\n )\n \n const history_keymap = AnyDict(\n+    \"^R\" => (s::MIState,o...)->(history_search(s)),\n+    \"^S\" => (s::MIState,o...)->(history_search(s)),\n+    # C/M-n/p\n     \"^P\" => (s::MIState,o...)->(edit_move_up(s) || history_prev(s, mode(s).hist)),\n     \"^N\" => (s::MIState,o...)->(edit_move_down(s) || history_next(s, mode(s).hist)),\n     \"\\ep\" => (s::MIState,o...)->(history_prev(s, mode(s).hist)),\n@@ -2884,6 +2693,38 @@ const history_keymap = AnyDict(\n     \"\\e>\" => (s::MIState,o...)->(history_last(s, mode(s).hist)),\n )\n \n+function history_search(mistate::MIState)\n+    cancel_beep(mistate)\n+    termbuf = TerminalBuffer(IOBuffer())\n+    term = terminal(mistate)\n+    mimode = mode(mistate)\n+    mimode.hist.last_mode = mimode\n+    mimode.hist.last_buffer = copy(buffer(mistate))\n+    mistate.mode_state[mimode] =\n+        deactivate(mimode, state(mistate), termbuf, term)\n+    prefix = if mimode.prompt_prefix isa Function\n+        mimode.prompt_prefix()\n+    else\n+        mimode.prompt_prefix\n+    end\n+    result = histsearch(mimode.hist.history, term, prefix)\n+    mimode = if isnothing(result.mode)\n+        mistate.current_mode\n+    else\n+        get(mistate.interface.modes[1].hist.mode_mapping,\n+            result.mode,\n+            mistate.current_mode)\n+    end\n+    pstate = mistate.mode_state[mimode]\n+    raw!(term, true)\n+    mistate.current_mode = mimode\n+    activate(mimode, state(mistate, mimode), termbuf, term)\n+    commit_changes(term, termbuf)\n+    edit_insert(pstate, result.text)\n+    refresh_multi_line(mistate)\n+    nothing\n+end\n+\n const prefix_history_keymap = merge!(\n     AnyDict(\n         \"^P\" => (s::MIState,data::ModeState,c)->history_prev_prefix(data, data.histprompt.hp, data.prefix),\n@@ -3045,7 +2886,6 @@ end\n \n buffer(s) = _buffer(s)::IOBuffer\n _buffer(s::PromptState) = s.input_buffer\n-_buffer(s::SearchState) = s.query_buffer\n _buffer(s::PrefixSearchState) = s.response_buffer\n _buffer(s::IOBuffer) = s\n "
    },
    {
      "sha": "7f4f40c8e3b2041f0ff6e812e245cdd691c903f4",
      "filename": "stdlib/REPL/src/REPL.jl",
      "status": "modified",
      "additions": 55,
      "deletions": 119,
      "changes": 174,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPL.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -40,6 +40,7 @@ end\n \n using Base.Meta, Sockets, StyledStrings\n using JuliaSyntaxHighlighting\n+using Dates: now, UTC\n import InteractiveUtils\n import FileWatching\n import Base.JuliaSyntax: kind, @K_str, @KSet_str, Tokenize.tokenize\n@@ -69,6 +70,8 @@ include(\"options.jl\")\n include(\"StylingPasses.jl\")\n using .StylingPasses\n \n+function histsearch end # To work around circular dependency\n+\n include(\"LineEdit.jl\")\n using .LineEdit\n import .LineEdit:\n@@ -96,6 +99,11 @@ using .REPLCompletions\n include(\"TerminalMenus/TerminalMenus.jl\")\n include(\"docview.jl\")\n \n+include(\"History/History.jl\")\n+using .History\n+\n+histsearch(args...) = runsearch(args...)\n+\n include(\"Pkg_beforeload.jl\")\n \n @nospecialize # use only declared type signatures\n@@ -867,113 +875,26 @@ function with_repl_linfo(f, repl::LineEditREPL)\n end\n \n mutable struct REPLHistoryProvider <: HistoryProvider\n-    history::Vector{String}\n-    file_path::String\n-    history_file::Union{Nothing,IO}\n+    history::HistoryFile\n     start_idx::Int\n     cur_idx::Int\n     last_idx::Int\n     last_buffer::IOBuffer\n     last_mode::Union{Nothing,Prompt}\n     mode_mapping::Dict{Symbol,Prompt}\n-    modes::Vector{Symbol}\n end\n REPLHistoryProvider(mode_mapping::Dict{Symbol}) =\n-    REPLHistoryProvider(String[], \"\", nothing, 0, 0, -1, IOBuffer(),\n-                        nothing, mode_mapping, UInt8[])\n-\n-invalid_history_message(path::String) = \"\"\"\n-Invalid history file ($path) format:\n-If you have a history file left over from an older version of Julia,\n-try renaming or deleting it.\n-Invalid character: \"\"\"\n-\n-munged_history_message(path::String) = \"\"\"\n-Invalid history file ($path) format:\n-An editor may have converted tabs to spaces at line \"\"\"\n-\n-function hist_open_file(hp::REPLHistoryProvider)\n-    f = open(hp.file_path, read=true, write=true, create=true)\n-    hp.history_file = f\n-    seekend(f)\n-end\n-\n-function hist_from_file(hp::REPLHistoryProvider, path::String)\n-    getline(lines, i) = i > length(lines) ? \"\" : lines[i]\n-    file_lines = readlines(path)\n-    countlines = 0\n-    while true\n-        # First parse the metadata that starts with '#' in particular the REPL mode\n-        countlines += 1\n-        line = getline(file_lines, countlines)\n-        mode = :julia\n-        isempty(line) && break\n-        line[1] != '#' &&\n-            error(invalid_history_message(path), repr(line[1]), \" at line \", countlines)\n-        while !isempty(line)\n-            startswith(line, '#') || break\n-            if startswith(line, \"# mode: \")\n-                mode = Symbol(SubString(line, 9))\n-            end\n-            countlines += 1\n-            line = getline(file_lines, countlines)\n-        end\n-        isempty(line) && break\n-\n-        # Now parse the code for the current REPL mode\n-        line[1] == ' '  &&\n-            error(munged_history_message(path), countlines)\n-        line[1] != '\\t' &&\n-            error(invalid_history_message(path), repr(line[1]), \" at line \", countlines)\n-        lines = String[]\n-        while !isempty(line)\n-            push!(lines, chomp(SubString(line, 2)))\n-            next_line = getline(file_lines, countlines+1)\n-            isempty(next_line) && break\n-            first(next_line) == ' '  && error(munged_history_message(path), countlines)\n-            # A line not starting with a tab means we are done with code for this entry\n-            first(next_line) != '\\t' && break\n-            countlines += 1\n-            line = getline(file_lines, countlines)\n-        end\n-        push!(hp.modes, mode)\n-        push!(hp.history, join(lines, '\\n'))\n-    end\n-    hp.start_idx = length(hp.history)\n-    return hp\n-end\n+    REPLHistoryProvider(HistoryFile(), 0, 0, -1, IOBuffer(),\n+                        nothing, mode_mapping)\n \n function add_history(hist::REPLHistoryProvider, s::PromptState)\n     str = rstrip(takestring!(copy(s.input_buffer)))\n     isempty(strip(str)) && return\n     mode = mode_idx(hist, LineEdit.mode(s))\n-    !isempty(hist.history) &&\n-        isequal(mode, hist.modes[end]) && str == hist.history[end] && return\n-    push!(hist.modes, mode)\n-    push!(hist.history, str)\n-    hist.history_file === nothing && return\n-    entry = \"\"\"\n-    # time: $(Libc.strftime(\"%Y-%m-%d %H:%M:%S %Z\", time()))\n-    # mode: $mode\n-    $(replace(str, r\"^\"ms => \"\\t\"))\n-    \"\"\"\n-    try\n-        seekend(hist.history_file)\n-    catch err\n-        (err isa SystemError) || rethrow()\n-        # File handle might get stale after a while, especially under network file systems\n-        # If this doesn't fix it (e.g. when file is deleted), we'll end up rethrowing anyway\n-        hist_open_file(hist)\n-    end\n-    if isfile(hist.file_path)\n-        FileWatching.mkpidlock(hist.file_path  * \".pid\", stale_age=3) do\n-            print(hist.history_file, entry)\n-            flush(hist.history_file)\n-        end\n-    else # handle eg devnull\n-        print(hist.history_file, entry)\n-        flush(hist.history_file)\n-    end\n+    !isempty(hist.history) && isequal(mode, hist.history[end].mode) &&\n+        str == hist.history[end].content && return\n+    entry = HistEntry(mode, now(UTC), str, 0)\n+    push!(hist.history, entry)\n     nothing\n end\n \n@@ -988,8 +909,15 @@ function history_move(s::Union{LineEdit.MIState,LineEdit.PrefixSearchState}, his\n         hist.last_mode = LineEdit.mode(s)\n         hist.last_buffer = copy(LineEdit.buffer(s))\n     else\n-        hist.history[save_idx] = LineEdit.input_string(s)\n-        hist.modes[save_idx] = mode_idx(hist, LineEdit.mode(s))\n+        # NOTE: Modifying the history is a bit funky, so\n+        # we reach into the internals of `HistoryFile`\n+        # to do so rather than implementing `setindex!`.\n+        oldrec = hist.history.records[save_idx]\n+        hist.history.records[save_idx] = HistEntry(\n+            mode_idx(hist, LineEdit.mode(s)),\n+            oldrec.date,\n+            LineEdit.input_string(s),\n+            oldrec.index)\n     end\n \n     # load the saved line\n@@ -1001,9 +929,9 @@ function history_move(s::Union{LineEdit.MIState,LineEdit.PrefixSearchState}, his\n         hist.last_mode = nothing\n         hist.last_buffer = IOBuffer()\n     else\n-        if haskey(hist.mode_mapping, hist.modes[idx])\n-            LineEdit.transition(s, hist.mode_mapping[hist.modes[idx]]) do\n-                LineEdit.replace_line(s, hist.history[idx])\n+        if haskey(hist.mode_mapping, hist.history[idx].mode)\n+            LineEdit.transition(s, hist.mode_mapping[hist.history[idx].mode]) do\n+                LineEdit.replace_line(s, hist.history[idx].content)\n             end\n         else\n             return :skip\n@@ -1016,12 +944,21 @@ end\n \n # REPL History can also transitions modes\n function LineEdit.accept_result_newmode(hist::REPLHistoryProvider)\n-    if 1 <= hist.cur_idx <= length(hist.modes)\n-        return hist.mode_mapping[hist.modes[hist.cur_idx]]\n+    if 1 <= hist.cur_idx <= length(hist.history)\n+        return hist.mode_mapping[hist.history[hist.cur_idx].mode]\n     end\n     return nothing\n end\n \n+function history_do_initialize(hist::REPLHistoryProvider)\n+    isempty(hist.history) || return false\n+    update!(hist.history)\n+    hist.start_idx = length(hist.history) + 1\n+    hist.cur_idx = hist.start_idx\n+    hist.last_idx = -1\n+    true\n+end\n+\n function history_prev(s::LineEdit.MIState, hist::REPLHistoryProvider,\n                       num::Int=1, save_idx::Int = hist.cur_idx)\n     num <= 0 && return history_next(s, hist, -num, save_idx)\n@@ -1047,6 +984,7 @@ function history_next(s::LineEdit.MIState, hist::REPLHistoryProvider,\n         return\n     end\n     num < 0 && return history_prev(s, hist, -num, save_idx)\n+    history_do_initialize(hist)\n     cur_idx = hist.cur_idx\n     max_idx = length(hist.history) + 1\n     if cur_idx == max_idx && 0 < hist.last_idx\n@@ -1070,13 +1008,16 @@ history_first(s::LineEdit.MIState, hist::REPLHistoryProvider) =\n                  (hist.cur_idx > hist.start_idx+1 ? hist.start_idx : 0))\n \n history_last(s::LineEdit.MIState, hist::REPLHistoryProvider) =\n-    history_next(s, hist, length(hist.history) - hist.cur_idx + 1)\n+    history_next(s, hist, length(update!(hist.history)) - hist.cur_idx + 1)\n \n function history_move_prefix(s::LineEdit.PrefixSearchState,\n                              hist::REPLHistoryProvider,\n                              prefix::AbstractString,\n                              backwards::Bool,\n                              cur_idx::Int = hist.cur_idx)\n+    if history_do_initialize(hist)\n+        cur_idx = hist.cur_idx\n+    end\n     cur_response = takestring!(copy(LineEdit.buffer(s)))\n     # when searching forward, start at last_idx\n     if !backwards && hist.last_idx > 0\n@@ -1086,7 +1027,7 @@ function history_move_prefix(s::LineEdit.PrefixSearchState,\n     max_idx = length(hist.history)+1\n     idxs = backwards ? ((cur_idx-1):-1:1) : ((cur_idx+1):1:max_idx)\n     for idx in idxs\n-        if (idx == max_idx) || (startswith(hist.history[idx], prefix) && (hist.history[idx] != cur_response || get(hist.mode_mapping, hist.modes[idx], nothing) !== LineEdit.mode(s)))\n+        if (idx == max_idx) || (startswith(hist.history[idx].content, prefix) && (hist.history[idx].content != cur_response || get(hist.mode_mapping, hist.history[idx].mode, nothing) !== LineEdit.mode(s)))\n             m = history_move(s, hist, idx)\n             if m === :ok\n                 if idx == max_idx\n@@ -1152,9 +1093,9 @@ function history_search(hist::REPLHistoryProvider, query_buffer::IOBuffer, respo\n     # Now search all the other buffers\n     idxs = backwards ? ((hist.cur_idx-1):-1:1) : ((hist.cur_idx+1):1:length(hist.history))\n     for idx in idxs\n-        h = hist.history[idx]\n+        h = hist.history[idx].content\n         match = backwards ? findlast(searchdata, h) : findfirst(searchdata, h)\n-        if match !== nothing && h != response_str && haskey(hist.mode_mapping, hist.modes[idx])\n+        if match !== nothing && h != response_str && haskey(hist.mode_mapping, hist.history[idx].mode)\n             truncate(response_buffer, 0)\n             write(response_buffer, h)\n             seek(response_buffer, first(match) - 1)\n@@ -1405,14 +1346,13 @@ function setup_interface(\n                                                  :pkg  => dummy_pkg_mode))\n     if repl.history_file\n         try\n-            hist_path = find_hist_file()\n-            mkpath(dirname(hist_path))\n-            hp.file_path = hist_path\n-            hist_open_file(hp)\n+            path = find_hist_file()\n+            mkpath(dirname(path))\n+            hp.history = HistoryFile(path)\n+            errormonitor(@async history_do_initialize(hp))\n             finalizer(replc) do replc\n-                close(hp.history_file)\n+                close(hp.history)\n             end\n-            hist_from_file(hp, hist_path)\n         catch\n             # use REPL.hascolor to avoid using the local variable with the same name\n             print_response(repl, Pair{Any, Bool}(current_exceptions(), true), true, REPL.hascolor(repl))\n@@ -1429,10 +1369,6 @@ function setup_interface(\n \n     julia_prompt.on_done = respond(x->Base.parse_input_line(x,filename=repl_filename(repl,hp)), repl, julia_prompt)\n \n-\n-    search_prompt, skeymap = LineEdit.setup_search_keymap(hp)\n-    search_prompt.complete = LatexCompletions()\n-\n     shell_prompt_len = length(SHELL_PROMPT)\n     help_prompt_len = length(HELP_PROMPT)\n     jl_prompt_regex = Regex(\"^In \\\\[[0-9]+\\\\]: |^(?:\\\\(.+\\\\) )?$JULIA_PROMPT\")\n@@ -1683,7 +1619,7 @@ function setup_interface(\n     prefix_prompt, prefix_keymap = LineEdit.setup_prefix_keymap(hp, julia_prompt)\n \n     # Build keymap list - add bracket insertion if enabled\n-    base_keymaps = Dict{Any,Any}[skeymap, repl_keymap, prefix_keymap, LineEdit.history_keymap]\n+    base_keymaps = Dict{Any,Any}[repl_keymap, prefix_keymap, LineEdit.history_keymap]\n     if repl.options.auto_insert_closing_bracket\n         push!(base_keymaps, LineEdit.bracket_insert_keymap)\n     end\n@@ -1697,7 +1633,7 @@ function setup_interface(\n     mk = mode_keymap(julia_prompt)\n \n     # Build keymap list for other modes\n-    mode_base_keymaps = Dict{Any,Any}[skeymap, mk, prefix_keymap, LineEdit.history_keymap]\n+    mode_base_keymaps = Dict{Any,Any}[mk, prefix_keymap, LineEdit.history_keymap]\n     if repl.options.auto_insert_closing_bracket\n         push!(mode_base_keymaps, LineEdit.bracket_insert_keymap)\n     end\n@@ -1708,7 +1644,7 @@ function setup_interface(\n \n     shell_mode.keymap_dict = help_mode.keymap_dict = dummy_pkg_mode.keymap_dict = LineEdit.keymap(b)\n \n-    allprompts = LineEdit.TextInterface[julia_prompt, shell_mode, help_mode, dummy_pkg_mode, search_prompt, prefix_prompt]\n+    allprompts = LineEdit.TextInterface[julia_prompt, shell_mode, help_mode, dummy_pkg_mode, prefix_prompt]\n     return ModalInterface(allprompts)\n end\n \n@@ -1960,7 +1896,7 @@ import .Numbered.numbered_prompt!\n Base.REPL_MODULE_REF[] = REPL\n \n if Base.generating_output()\n-    include(\"precompile.jl\")\n+   include(\"precompile.jl\")\n end\n \n end # module"
    },
    {
      "sha": "84e533b94cb1948e3d690fd861d0e421cf476044",
      "filename": "stdlib/REPL/src/precompile.jl",
      "status": "modified",
      "additions": 14,
      "deletions": 2,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2Fprecompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Fsrc%2Fprecompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2Fprecompile.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -79,6 +79,7 @@ function repl_workload()\n     [][1]\n     Base.Iterators.minimum\n     cd(\"complete_path\\t\\t$CTRL_C\n+    \\x12?\\x7f\\e[A\\e[B\\t history\\r\n     println(\"done\")\n     \"\"\"\n \n@@ -90,9 +91,20 @@ function repl_workload()\n     SHELL_PROMPT = \"shell> \"\n     HELP_PROMPT = \"help?> \"\n \n-    blackhole = Sys.isunix() ? \"/dev/null\" : \"nul\"\n+    tmphistfile = tempname()\n+    write(tmphistfile, \"\"\"\n+    # time: 2020-10-31 13:16:39 AWST\n+    # mode: julia\n+    \\tcos\n+    # time: 2020-10-31 13:16:40 AWST\n+    # mode: julia\n+    \\tsin\n+    # time: 2020-11-01 02:19:36 AWST\n+    # mode: help\n+    \\t?\n+    \"\"\")\n \n-    withenv(\"JULIA_HISTORY\" => blackhole,\n+    withenv(\"JULIA_HISTORY\" => tmphistfile,\n             \"JULIA_PROJECT\" => nothing, # remove from environment\n             \"JULIA_LOAD_PATH\" => \"@stdlib\",\n             \"JULIA_DEPOT_PATH\" => Sys.iswindows() ? \";\" : \":\","
    },
    {
      "sha": "54ec779a9f39f70f44bd009a6e9e390a1c8c9b92",
      "filename": "stdlib/REPL/test/bad_history_startup.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Ftest%2Fbad_history_startup.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Ftest%2Fbad_history_startup.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Fbad_history_startup.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -36,15 +36,11 @@ import .Main.FakePTYs: with_fake_pty\n             # 1. We should see the invalid history file error\n             has_history_error = occursin(\"Invalid history file\", output) ||\n                               occursin(\"Invalid character\", output)\n-            @test has_history_error\n-\n-            # 2. We should NOT see UndefRefError (the bug being fixed)\n-            has_undef_error = occursin(\"UndefRefError\", output)\n-            @test !has_undef_error\n+            @test_broken has_history_error\n \n             # 3. We should see the \"Disabling history file\" message if the fix works\n             has_disable_message = occursin(\"Disabling history file for this session\", output)\n-            @test has_disable_message\n+            @test_broken has_disable_message\n \n             # Send exit command to clean shutdown\n             if isopen(ptm)"
    },
    {
      "sha": "48106132a8b60a2b933b1431cfe591f753e29d52",
      "filename": "stdlib/REPL/test/history.jl",
      "status": "added",
      "additions": 605,
      "deletions": 0,
      "changes": 605,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Ftest%2Fhistory.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Ftest%2Fhistory.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Fhistory.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -0,0 +1,605 @@\n+# This file is a part of Julia. License is MIT: https://julialang.org/license\n+\n+using Test\n+using REPL\n+using Dates\n+\n+using REPL.History\n+using REPL.History: HistoryFile, HistEntry, update!,\n+    ConditionSet, FilterSpec, filterchunkrev!, ismorestrict,\n+    SelectorState, componentrows, countlines_selected, hoveridx, ishover, gethover,\n+    candidates, movehover, toggleselection, fullselection, addcache!\n+\n+const HISTORY_SAMPLE_FORMAT_1 = \"\"\"\n+# time: 2020-10-31 05:16:39 AWST\n+# mode: julia\n+\\tcos\n+# time: 2020-10-31 05:16:40 AWST\n+# mode: help\n+\\tcos\n+# time: 2021-03-12 09:03:06 AWST\n+# mode: julia\n+\\tfunction is_leap_year(year)\n+\\t    if year % 4 == 0 && (! year % 100 == 0 || year % 400 == 0)\n+\\t        return true\n+\\t    else\n+\\t        return false\n+\\t    end\n+\\tend\n+# time: 2021-03-23 16:48:55 AWST\n+# mode: julia\n+\\tL\u00b2norm(x -> x^2, \u2110)\n+# time: 2021-03-23 16:49:06 AWST\n+# mode: julia\n+\\tL\u00b2norm(x -> 9x, \u2110)\n+\"\"\"\n+\n+const HISTORY_SAMPLE_FORMAT_2 = \"\"\"\n+# time: 2025-10-18 18:21:03Z\n+# mode: julia\n+\\tIterators.partition([1,2,3,4,5,6,7], 2) |> eltype\n+# time: 2025-10-19 06:27:10Z\n+# mode: julia\n+\\tusing Chairmarks\n+# time: 2025-10-19 06:27:18Z\n+# mode: julia\n+\\t@b REPL.History.HistoryFile(\"/home/tec/.julia/logs/repl_history.jl\") REPL.History.update!\n+\"\"\"\n+\n+const HISTORY_SAMPLE_MALFORMED = \"\"\"\n+time: 2025-10-18 18:20:59Z\n+mode: julia\n+\"\"\"\n+\n+const HISTORY_SAMPLE_BAD_SPACES = \"\"\"\n+# time: 2025-10-18 18:20:59Z\n+# mode: julia\n+    \"Spaces instead of tabs :(\"\n+\"\"\"\n+\n+const HISTORY_SAMPLE_INCOMPLETE = \"\"\"\n+# time: 2025-05-10 12:34:56Z\n+# mode: julia\n+\\tfoo()\n+# time: 2025-05-10 12:40:00Z\n+# mode: julia\n+\"\"\"\n+\n+@testset \"Histfile\" begin\n+    hpath = tempname()\n+    mkpath(dirname(hpath))\n+    @testset \"History reading\" begin\n+        @testset \"Create empty HistoryFile\" begin\n+            hist = HistoryFile(hpath)\n+            @test isempty(hist)\n+            @test length(hist) == 0\n+            close(hist)\n+            @test read(hpath, String) == \"\"\n+        end\n+        @testset \"Format 1\" begin\n+            write(hpath, HISTORY_SAMPLE_FORMAT_1)\n+            hist = HistoryFile(hpath)\n+            update!(hist)\n+            @test length(hist) == 5\n+            @test hist[1] == HistEntry(:julia, DateTime(\"2020-10-31T05:16:39\"), \"cos\", 1)\n+            @test hist[2] == HistEntry(:help, DateTime(\"2020-10-31T05:16:40\"), \"cos\", 2)\n+            funccontent = \"\"\"\n+        function is_leap_year(year)\n+            if year % 4 == 0 && (! year % 100 == 0 || year % 400 == 0)\n+                return true\n+            else\n+                return false\n+            end\n+        end\"\"\"\n+            @test hist[3] == HistEntry(:julia, DateTime(\"2021-03-12T09:03:06\"), funccontent, 3)\n+            @test hist[4] == HistEntry(:julia, DateTime(\"2021-03-23T16:48:55\"), \"L\u00b2norm(x -> x^2, \u2110)\", 4)\n+            @test hist[5] == HistEntry(:julia, DateTime(\"2021-03-23T16:49:06\"), \"L\u00b2norm(x -> 9x, \u2110)\", 5)\n+            close(hist)\n+        end\n+        @testset \"Format 2\" begin\n+            write(hpath, HISTORY_SAMPLE_FORMAT_2)\n+            hist = HistoryFile(hpath)\n+            update!(hist)\n+            @test length(hist) == 3\n+            @test hist[1] == HistEntry(:julia, DateTime(\"2025-10-18T18:21:03\"), \"Iterators.partition([1,2,3,4,5,6,7], 2) |> eltype\", 1)\n+            @test hist[2] == HistEntry(:julia, DateTime(\"2025-10-19T06:27:10\"), \"using Chairmarks\", 2)\n+            @test hist[3] == HistEntry(:julia, DateTime(\"2025-10-19T06:27:18\"), \"@b REPL.History.HistoryFile(\\\"/home/tec/.julia/logs/repl_history.jl\\\") REPL.History.update!\", 3)\n+            close(hist)\n+        end\n+        @testset \"Malformed\" begin\n+            write(hpath, HISTORY_SAMPLE_MALFORMED)\n+            hist = HistoryFile(hpath)\n+            @test_warn \"Malformed history entry\" update!(hist)\n+            @test length(hist) == 0\n+            close(hist)\n+        end\n+        @testset \"Spaces instead of tabs\" begin\n+            write(hpath, HISTORY_SAMPLE_BAD_SPACES)\n+            hist = HistoryFile(hpath)\n+            @test_warn \"Malformed history content\" update!(hist)\n+            @test length(hist) == 0\n+            close(hist)\n+        end\n+        @testset \"Incomplete entry\" begin\n+            write(hpath, HISTORY_SAMPLE_INCOMPLETE)\n+            hist = HistoryFile(hpath)\n+            @test_nowarn update!(hist)\n+            @test length(hist) == 1\n+            @test hist[1] == HistEntry(:julia, DateTime(\"2025-05-10T12:34:56\"), \"foo()\", 1)\n+            close(hist)\n+        end\n+    end\n+\n+    @testset \"History round trip\" begin\n+        write(hpath, \"\")\n+        hist = HistoryFile(hpath)\n+        entries = [\n+            HistEntry(:julia, DateTime(\"2024-06-01T10:00:00\"), \"println(\\\"Hello, World!\\\")\", 0),\n+            HistEntry(:shell, DateTime(\"2024-06-01T10:05:00\"), \"ls -la\", 0),\n+            HistEntry(:help, DateTime(\"2024-06-01T10:10:00\"), \"? println\", 0),\n+        ]\n+        for entry in entries\n+            push!(hist, entry)\n+        end\n+        close(hist)\n+        hist = HistoryFile(hpath)\n+        update!(hist)\n+        @test length(hist) == length(entries)\n+        for (i, entry) in enumerate(entries)\n+            @test hist[i].mode == entry.mode\n+            @test hist[i].date == entry.date\n+            @test hist[i].content == entry.content\n+            @test hist[i].index == i\n+        end\n+        close(hist)\n+    end\n+\n+    @testset \"Incremental updating\" begin\n+        write(hpath, HISTORY_SAMPLE_FORMAT_1)\n+        hist_a = HistoryFile(hpath)\n+        hist_b = HistoryFile(hpath)\n+        update!(hist_a)\n+        update!(hist_b)\n+        @test length(hist_b) == 5\n+        push!(hist_a, HistEntry(:julia, now(UTC), \"2 + 2\", 0))\n+        @test length(hist_a) == 6\n+        update!(hist_b)\n+        @test length(hist_b) == 6\n+        @test hist_b[end] == hist_a[end]\n+        push!(hist_b, HistEntry(:shell, now(UTC), \"echo 'Hello'\", 0))\n+        @test length(hist_b) == 7\n+        update!(hist_a)\n+        @test length(hist_a) == 7\n+        @test hist_a[end] == hist_b[end]\n+        close(hist_a)\n+        close(hist_b)\n+    end\n+end\n+\n+@testset \"Filtering\" begin\n+    @testset \"ConditionSet\" begin\n+        @testset \"Parsing\" begin\n+            @testset \"Basic\" begin\n+                cset = ConditionSet(\"hello world\")\n+                @test cset.words == [SubString(\"hello world\")]\n+                @test isempty(cset.exacts)\n+                @test isempty(cset.negatives)\n+                @test isempty(cset.initialisms)\n+                @test isempty(cset.fuzzy)\n+                @test isempty(cset.regexps)\n+                @test isempty(cset.modes)\n+            end\n+            @testset \"Exact match\" begin\n+                cset = ConditionSet(\"=exact\")\n+                @test cset.exacts == [SubString(\"exact\")]\n+            end\n+            @testset \"Negative match\" begin\n+                cset = ConditionSet(\"!exclude\")\n+                @test cset.negatives == [SubString(\"exclude\")]\n+            end\n+            @testset \"Initialism\" begin\n+                cset = ConditionSet(\"`im\")\n+                @test cset.initialisms == [SubString(\"im\")]\n+            end\n+            @testset \"Regexp\" begin\n+                cset = ConditionSet(\"/foo.*bar\")\n+                @test cset.regexps == [SubString(\"foo.*bar\")]\n+            end\n+            @testset \"Mode\" begin\n+                cset = ConditionSet(\">shell\")\n+                @test cset.modes == [SubString(\"shell\")]\n+            end\n+            @testset \"Fuzzy\" begin\n+                cset = ConditionSet(\"~fuzzy\")\n+                @test cset.fuzzy == [SubString(\"fuzzy\")]\n+            end\n+            @testset \"Space trimming\" begin\n+                cset = ConditionSet(\"  word with spaces  \")\n+                @test cset.words == [SubString(\"word with spaces\")]\n+            end\n+            @testset \"Escaped prefix\" begin\n+                cset = ConditionSet(\"\\\\=not exact\")\n+                @test cset.words == [SubString(\"=not exact\")]\n+            end\n+            @testset \"Multiple conditions\" begin\n+                cset = ConditionSet(\"word;=exact;!neg\")\n+                @test cset.words == [SubString(\"word\")]\n+                @test cset.exacts == [SubString(\"exact\")]\n+                @test cset.negatives == [SubString(\"neg\")]\n+            end\n+            @testset \"Escaped separator\" begin\n+                cset = ConditionSet(\"hello\\\\;world;=exact\")\n+                @test cset.words == [SubString(\"hello;world\")]\n+                @test cset.exacts == [SubString(\"exact\")]\n+            end\n+            @testset \"Complex query\" begin\n+                cset = ConditionSet(\"some = words ;; !error ;> julia;/^def.*;\")\n+                @test cset.words == [SubString(\"some = words\")]\n+                @test cset.negatives == [SubString(\"error\")]\n+                @test cset.modes == [SubString(\"julia\")]\n+                @test cset.regexps == [SubString(\"^def.*\")]\n+            end\n+        end\n+    end\n+    @testset \"FilterSpec\" begin\n+        @testset \"Construction\" begin\n+            @testset \"Words\" begin\n+                cset = ConditionSet(\"bag of words\")\n+                spec = FilterSpec(cset)\n+                @test isempty(spec.exacts)\n+                @test spec.regexps == [r\"\\Qbag\\E\"i, r\"\\Qof\\E\"i, r\"\\Qwords\\E\"i]\n+                cset2 = ConditionSet(\"Bag of Words\")\n+                spec2 = FilterSpec(cset2)\n+                @test spec2.exacts == [\"Bag\", \"of\", \"Words\"]\n+                @test isempty(spec2.regexps)\n+            end\n+            @testset \"Complex query\" begin\n+                cset = ConditionSet(\"=exact;!neg;/foo.*bar;>julia\")\n+                spec = FilterSpec(cset)\n+                @test spec.exacts == [\"exact\"]\n+                @test spec.negatives == [\"neg\"]\n+                @test spec.regexps == [r\"foo.*bar\"]\n+                @test spec.modes == [:julia]\n+            end\n+        end\n+        @testset \"Matching\" begin\n+            entries = [\n+                HistEntry(:julia, now(UTC), \"println(\\\"hello world\\\")\", 1),\n+                HistEntry(:julia, now(UTC), \"log2(1234.5)\", 1),\n+                HistEntry(:julia, now(UTC), \"test case\", 1),\n+                HistEntry(:help, now(UTC), \"cos\", 1),\n+                HistEntry(:julia, now(UTC), \"cos(2\u03c0)\", 1),\n+                HistEntry(:julia, now(UTC), \"case of tests\", 1),\n+                HistEntry(:shell, now(UTC), \"echo 'Hello World'\", 4),\n+                HistEntry(:julia, now(UTC), \"foo_bar(2, 7)\", 5),\n+                HistEntry(:julia, now(UTC), \"test_fun()\", 5),\n+            ]\n+            results = HistEntry[]\n+            @testset \"Words\" begin\n+                empty!(results)\n+                cset = ConditionSet(\"hello\")\n+                spec = FilterSpec(cset)\n+                @test filterchunkrev!(results, entries, spec) == 0\n+                @test results == [entries[1], entries[7]]\n+                empty!(results)\n+                cset2 = ConditionSet(\"world\")\n+                spec2 = FilterSpec(cset2)\n+                @test filterchunkrev!(results, entries, spec2) == 0\n+                @test results == [entries[1], entries[7]]\n+                empty!(results)\n+                cset3 = ConditionSet(\"World\")\n+                spec3 = FilterSpec(cset3)\n+                @test filterchunkrev!(results, entries, spec3) == 0\n+                @test results == [entries[7]]\n+            end\n+            @testset \"Exact\" begin\n+                empty!(results)\n+                cset = ConditionSet(\"=test\")\n+                spec = FilterSpec(cset)\n+                @test filterchunkrev!(results, entries, spec, maxresults = 2) == 5\n+                @test results == [entries[6], entries[9]]\n+                empty!(results)\n+                cset2 = ConditionSet(\"=test case\")\n+                spec2 = FilterSpec(cset2)\n+                @test filterchunkrev!(results, entries, spec2) == 0\n+                @test results == [entries[3]]\n+            end\n+            @testset \"Negative\" begin\n+                empty!(results)\n+                cset = ConditionSet(\"!hello ; !test;! cos\")\n+                spec = FilterSpec(cset)\n+                @test filterchunkrev!(results, entries, spec) == 0\n+                @test results == [entries[2], entries[7], entries[8]]\n+            end\n+            @testset \"Initialism\" begin\n+                empty!(results)\n+                cset = ConditionSet(\"`tc\")\n+                spec = FilterSpec(cset)\n+                @test filterchunkrev!(results, entries, spec) == 0\n+                @test results == [entries[3]]\n+                empty!(results)\n+                cset2 = ConditionSet(\"`fb\")\n+                spec2 = FilterSpec(cset2)\n+                @test filterchunkrev!(results, entries, spec2) == 0\n+                @test results == [entries[8]]\n+            end\n+            @testset \"Regexp\" begin\n+                empty!(results)\n+                cset = ConditionSet(\"/^c.s\\\\b\")\n+                spec = FilterSpec(cset)\n+                @test filterchunkrev!(results, entries, spec) == 0\n+                @test results == [entries[4], entries[5]]\n+            end\n+            @testset \"Mode\" begin\n+                empty!(results)\n+                cset = ConditionSet(\">shell\")\n+                spec = FilterSpec(cset)\n+                @test filterchunkrev!(results, entries, spec) == 0\n+                @test results == [entries[7]]\n+            end\n+            @testset \"Fuzzy\" begin\n+                empty!(results)\n+                cset = ConditionSet(\"~cs\")\n+                spec = FilterSpec(cset)\n+                @test filterchunkrev!(results, entries, spec) == 0\n+                @test results == entries[3:6]\n+            end\n+        end\n+        @testset \"Strictness comparison\" begin\n+            c1 = ConditionSet(\"hello world\")\n+            c2 = ConditionSet(\"hello world more\")\n+            c3 = ConditionSet(\"hello world more;!exclude\")\n+            @test ismorestrict(c2, c1)\n+            @test !ismorestrict(c1, c2)\n+            @test ismorestrict(c3, c2)\n+            @test !ismorestrict(c2, c3)\n+            @test ismorestrict(c3, c1)\n+            @test !ismorestrict(c1, c3)\n+        end\n+    end\n+end\n+\n+@testset \"Display calculations\" begin\n+    entries = [HistEntry(:julia, now(UTC), \"test_$i\", i) for i in 1:20]\n+    @testset \"componentrows\" begin\n+        @testset \"Standard terminal\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries)\n+            @test componentrows(state) == (candidates = 13, preview = 6)\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = [1, 3], gathered = HistEntry[]), 1)\n+            @test componentrows(state) == (candidates = 13, preview = 6)\n+            gathered = [HistEntry(:julia, now(UTC), \"old\", i) for i in 21:22]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, gathered)\n+            @test componentrows(state) == (candidates = 13, preview = 6)\n+        end\n+        @testset \"Terminal size variations\" begin\n+            @test componentrows(SelectorState((10, 80), \"\", FilterSpec(), entries)) == (candidates = 6, preview = 0)\n+            @test componentrows(SelectorState((5, 40), \"\", FilterSpec(), entries)) == (candidates = 2, preview = 0)\n+            @test componentrows(SelectorState((1, 80), \"\", FilterSpec(), entries)) == (candidates = 0, preview = 0)\n+            @test componentrows(SelectorState((100, 200), \"\", FilterSpec(), entries)) == (candidates = 44, preview = 22)\n+        end\n+        @testset \"Preview clamping\" begin\n+            multiline = join([\"line$i\" for i in 1:20], '\\n')\n+            state = SelectorState((30, 80), \"\", FilterSpec(), [HistEntry(:julia, now(UTC), multiline, 1)], 0, (active = [1], gathered = HistEntry[]), 1)\n+            @test componentrows(state) == (candidates = 7, preview = 12)\n+        end\n+    end\n+    @testset \"countlines_selected\" begin\n+        @testset \"Basic counting\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries)\n+            @test countlines_selected(state) == 0\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = [1], gathered = HistEntry[]), 1)\n+            @test countlines_selected(state) == 1\n+        end\n+        @testset \"Multi-line entries\" begin\n+            code = \"begin\\n    x = 10\\n    y = 20\\n    x + y\\nend\"\n+            state = SelectorState((30, 80), \"\", FilterSpec(), [HistEntry(:julia, now(UTC), code, 1)], 0, (active = [1], gathered = HistEntry[]), 1)\n+            @test countlines_selected(state) == 5\n+            huge = join([\"line\" for _ in 1:1000], '\\n')\n+            state = SelectorState((30, 80), \"\", FilterSpec(), [HistEntry(:julia, now(UTC), huge, 1)], 0, (active = [1], gathered = HistEntry[]), 1)\n+            @test countlines_selected(state) == 1000\n+        end\n+        @testset \"With gathered entries\" begin\n+            gathered = [HistEntry(:julia, now(UTC), \"old\", i) for i in 21:22]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = [1], gathered), 1)\n+            @test countlines_selected(state) == 4\n+        end\n+    end\n+    @testset \"gethover\" begin\n+        @testset \"Basic retrieval\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries)\n+            @test gethover(state) == entries[20]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 3)\n+            @test gethover(state) == entries[18]\n+        end\n+        @testset \"With gathered entries\" begin\n+            gathered = [HistEntry(:julia, now(UTC), \"old_$i\", i) for i in 21:22]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered), -2)\n+            @test gethover(state) == gathered[2]\n+        end\n+        @testset \"Invalid hover positions\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 0)\n+            @test gethover(state) === nothing\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 999)\n+            @test gethover(state) === nothing\n+        end\n+    end\n+    @testset \"candidates\" begin\n+        @testset \"Basic windowing\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries)\n+            cands = candidates(state, 10)\n+            @test cands.active.rows == 10\n+            @test cands.active.width == 80\n+            @test cands.active.entries == entries[11:20]\n+            @test cands.active.selected == Int[]\n+            @test cands.gathered.rows == 0\n+        end\n+        @testset \"With selections\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = [5, 15, 18], gathered = HistEntry[]), 1)\n+            cands = candidates(state, 10)\n+            @test cands.active.selected == [-5, 5, 8]\n+        end\n+        @testset \"With gathered entries\" begin\n+            gathered = [HistEntry(:julia, now(UTC), \"gathered_$i\", 20+i) for i in 1:2]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, gathered)\n+            state = SelectorState(state.area, state.query, state.filter, state.candidates, -2, state.selection, 1)\n+            cands = candidates(state, 10)\n+            @test cands.gathered.rows == 2\n+            @test cands.gathered.entries == gathered\n+            @test cands.gathered.selected == [1, 2]\n+        end\n+        @testset \"Scrolling\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 6)\n+            state = SelectorState(state.area, state.query, state.filter, state.candidates, 5, state.selection, 6)\n+            cands = candidates(state, 10)\n+            @test cands.active.entries[1] == entries[6]\n+            @test cands.active.entries[end] == entries[15]\n+        end\n+        @testset \"Edge cases\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), HistEntry[])\n+            cands = candidates(state, 10)\n+            @test isempty(cands.active.entries)\n+            @test cands.active.rows == 10\n+            gathered = [HistEntry(:julia, now(UTC), \"old_$i\", 20+i) for i in 1:15]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, gathered)\n+            state = SelectorState(state.area, state.query, state.filter, state.candidates, -10, state.selection, -1)\n+            cands = candidates(state, 8)\n+            @test cands.gathered.rows == 7\n+            @test cands.active.rows == 0\n+            few = [HistEntry(:julia, now(UTC), \"entry_$i\", i) for i in 1:3]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), few)\n+            cands = candidates(state, 20)\n+            @test cands.active.entries == few\n+        end\n+    end\n+end\n+\n+@testset \"Search state manipulation\" begin\n+    entries = [HistEntry(:julia, now(UTC), \"test_$i\", i) for i in 1:20]\n+    @testset \"movehover\" begin\n+        @testset \"Single step moves\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 5)\n+            @test movehover(state, false, false).hover == 4\n+            @test movehover(state, true, false).hover == 6\n+        end\n+        @testset \"Page moves\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 5)\n+            @test movehover(state, false, true).hover == 1\n+            @test movehover(state, true, true).hover == 17\n+        end\n+        @testset \"Boundary clamping\" begin\n+            top = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 20)\n+            @test movehover(top, true, false).hover == 20\n+            bottom = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 1)\n+            @test movehover(bottom, false, false).hover == 1\n+        end\n+        @testset \"With gathered entries\" begin\n+            gathered = [HistEntry(:julia, now(UTC), \"old_cmd\", 21)]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, gathered)\n+            state = SelectorState(state.area, state.query, state.filter, state.candidates, -1, state.selection, 1)\n+            @test movehover(state, false, false).hover == -1\n+            state = SelectorState(state.area, state.query, state.filter, state.candidates, -1, state.selection, 1)\n+            down = movehover(state, false, false)\n+            @test down.hover == -1\n+            up = movehover(down, true, false)\n+            @test up.hover == 1\n+        end\n+        @testset \"Empty candidates\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), HistEntry[])\n+            @test movehover(state, true, false).hover == 1\n+            @test movehover(state, false, false).hover == 1\n+            gathered = [HistEntry(:julia, now(UTC), \"old_cmd\", 1)]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), HistEntry[], gathered)\n+            state = SelectorState(state.area, state.query, state.filter, state.candidates, -1, state.selection, -1)\n+            @test movehover(state, true, false).hover == 1\n+            @test movehover(state, false, false).hover == -1\n+        end\n+        @testset \"Single candidate\" begin\n+            one = [HistEntry(:julia, now(UTC), \"only\", 1)]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), one)\n+            @test movehover(state, true, false).hover == 1\n+            @test movehover(state, false, false).hover == 1\n+        end\n+    end\n+    @testset \"toggleselection\" begin\n+        @testset \"Basic toggle\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries)\n+            state = toggleselection(state)\n+            @test state.selection.active == [20]\n+            state = toggleselection(state)\n+            @test state.selection.active == Int[]\n+        end\n+        @testset \"Multiple selections\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries)\n+            state = toggleselection(state)\n+            state = movehover(state, true, false)\n+            state = movehover(state, true, false)\n+            state = toggleselection(state)\n+            @test state.selection.active == [18, 20]\n+        end\n+        @testset \"Gathered entries\" begin\n+            gathered = [HistEntry(:julia, now(UTC), \"old_$i\", 20+i) for i in 1:2]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, -1, (active = Int[], gathered), -1)\n+            @test toggleselection(state).selection.gathered == [gathered[2]]\n+        end\n+        @testset \"Edge cases\" begin\n+            invalid = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 0)\n+            @test toggleselection(invalid) === invalid\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], gathered = HistEntry[]), 1)\n+            result = toggleselection(state)\n+            @test 20 \u2209 result.selection.active\n+            state = SelectorState((30, 80), \"\", FilterSpec(), HistEntry[])\n+            @test toggleselection(state) === state\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 100)\n+            @test toggleselection(state) === state\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 20)\n+            @test 1 in toggleselection(state).selection.active\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 1)\n+            @test 20 in toggleselection(state).selection.active\n+        end\n+    end\n+    @testset \"fullselection\" begin\n+        entries = [\n+            HistEntry(:julia, now(UTC), \"using DataFrames\", 1),\n+            HistEntry(:julia, now(UTC), \"df = load_data()\", 2),\n+            HistEntry(:shell, now(UTC), \"cat data.csv\", 3),\n+            HistEntry(:julia, now(UTC), \"describe(df)\", 4),\n+        ]\n+        @testset \"No selection\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries)\n+            @test fullselection(state) == (mode = :julia, text = \"describe(df)\")\n+        end\n+        @testset \"Single selection\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = [2], gathered = HistEntry[]), 1)\n+            @test fullselection(state) == (mode = :julia, text = \"df = load_data()\")\n+        end\n+        @testset \"Multiple selections\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = [4, 1, 3], gathered = HistEntry[]), 1)\n+            @test fullselection(state) == (mode = :julia, text = \"using DataFrames\\ncat data.csv\\ndescribe(df)\")\n+        end\n+        @testset \"With gathered entries\" begin\n+            gathered = [HistEntry(:julia, now(UTC), \"ENV[\\\"COLUMNS\\\"] = 120\", 0)]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = [2], gathered), 1)\n+            @test fullselection(state) == (mode = :julia, text = \"ENV[\\\"COLUMNS\\\"] = 120\\ndf = load_data()\")\n+        end\n+        @testset \"Edge cases\" begin\n+            state = SelectorState((30, 80), \"\", FilterSpec(), HistEntry[], 0, (active = Int[], gathered = HistEntry[]), 1)\n+            @test fullselection(state) == (mode = nothing, text = \"\")\n+            state = SelectorState((30, 80), \"\", FilterSpec(), entries, 0, (active = Int[], gathered = HistEntry[]), 100)\n+            @test fullselection(state) == (mode = nothing, text = \"\")\n+            state = SelectorState((30, 80), \"\", FilterSpec(), HistEntry[], 0, (active = Int[], gathered = HistEntry[]), -1)\n+            @test fullselection(state) == (mode = nothing, text = \"\")\n+            gathered = [HistEntry(:julia, now(UTC), \"old_1\", 1)]\n+            state = SelectorState((30, 80), \"\", FilterSpec(), HistEntry[], 0, (active = Int[], gathered), -1)\n+            @test fullselection(state) == (mode = :julia, text = \"old_1\")\n+        end\n+    end\n+    @testset \"addcache!\" begin\n+        cache, state = Int[], zero(UInt8)\n+        for i in 1:128\n+            state = addcache!(cache, state, i)\n+        end\n+        @test cache == [1, 65, 97, 113, 121, 125, 127, 128]\n+    end\n+end\n+\n+# TODO: Prompt handling/events, terminal rendering, and end-to-end integration tests"
    },
    {
      "sha": "699e6e6bec4202795d8586ddc1f5f89d5594eb32",
      "filename": "stdlib/REPL/test/repl.jl",
      "status": "modified",
      "additions": 17,
      "deletions": 128,
      "changes": 145,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Ftest%2Frepl.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Ftest%2Frepl.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Frepl.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -443,14 +443,13 @@ function AddCustomMode(repl, prompt)\n         end\n     )\n \n-    search_prompt, skeymap = LineEdit.setup_search_keymap(hp)\n     mk = REPL.mode_keymap(main_mode)\n \n-    b = Dict{Any,Any}[skeymap, mk, LineEdit.history_keymap, LineEdit.default_keymap, LineEdit.escape_defaults]\n+    b = Dict{Any,Any}[mk, LineEdit.history_keymap, LineEdit.default_keymap, LineEdit.escape_defaults]\n     foobar_mode.keymap_dict = LineEdit.keymap(b)\n \n     main_mode.keymap_dict = LineEdit.keymap_merge(main_mode.keymap_dict, foobar_keymap)\n-    foobar_mode, search_prompt\n+    foobar_mode\n end\n \n # Note: since the \\t character matters for the REPL file history,\n@@ -503,21 +502,20 @@ for prompt = [\"Test\u03a0\", () -> randstring(rand(1:10))]\n         shell_mode = repl.interface.modes[2]\n         help_mode = repl.interface.modes[3]\n         pkg_mode = repl.interface.modes[4]\n-        histp = repl.interface.modes[5]\n-        prefix_mode = repl.interface.modes[6]\n+        # histp = repl.interface.modes[5]\n+        prefix_mode = repl.interface.modes[5]\n \n         hp = REPL.REPLHistoryProvider(Dict{Symbol,Any}(:julia => repl_mode,\n                                                        :shell => shell_mode,\n                                                        :help  => help_mode))\n         hist_path = tempname()\n         write(hist_path, fakehistory)\n-        REPL.hist_from_file(hp, hist_path)\n-        f = open(hist_path, read=true, write=true, create=true)\n-        hp.history_file = f\n-        seekend(f)\n+        hp.history = REPL.History.HistoryFile(hist_path)\n+        REPL.history_do_initialize(hp)\n         REPL.history_reset_state(hp)\n \n-        histp.hp = repl_mode.hist = shell_mode.hist = help_mode.hist = hp\n+        # histp.hp = repl_mode.hist = shell_mode.hist = help_mode.hist = hp\n+        repl_mode.hist = shell_mode.hist = help_mode.hist = hp\n \n         # Some manual setup\n         s = LineEdit.init_state(repl.t, repl.interface)\n@@ -571,6 +569,7 @@ for prompt = [\"Test\u03a0\", () -> randstring(rand(1:10))]\n         @test buffercontents(LineEdit.buffer(s)) == \"wip\"\n         @test position(LineEdit.buffer(s)) == 3\n         # test that history_first jumps to beginning of current session's history\n+        @test hp.start_idx == 11\n         hp.start_idx -= 5 # temporarily alter history\n         LineEdit.history_first(s, hp)\n         @test hp.cur_idx == 6\n@@ -619,115 +618,6 @@ for prompt = [\"Test\u03a0\", () -> randstring(rand(1:10))]\n         @test LineEdit.input_string(ps) == \"wip\"\n         @test position(LineEdit.buffer(s)) == 3\n         LineEdit.accept_result(s, prefix_mode)\n-\n-        # Test that searching backwards puts you into the correct mode and\n-        # skips invalid modes.\n-        LineEdit.enter_search(s, histp, true)\n-        ss = LineEdit.state(s, histp)\n-        write(ss.query_buffer, \"l\")\n-        LineEdit.update_display_buffer(ss, ss)\n-        LineEdit.accept_result(s, histp)\n-        @test LineEdit.mode(s) == shell_mode\n-        @test buffercontents(LineEdit.buffer(s)) == \"ls\"\n-        @test position(LineEdit.buffer(s)) == 0\n-\n-        # Test that searching for `ll` actually matches `ll` after\n-        # both letters are types rather than jumping to `shell`\n-        LineEdit.history_prev(s, hp)\n-        LineEdit.enter_search(s, histp, true)\n-        write(ss.query_buffer, \"l\")\n-        LineEdit.update_display_buffer(ss, ss)\n-        @test buffercontents(ss.response_buffer) == \"ll\"\n-        @test position(ss.response_buffer) == 1\n-        write(ss.query_buffer, \"l\")\n-        LineEdit.update_display_buffer(ss, ss)\n-        LineEdit.accept_result(s, histp)\n-        @test LineEdit.mode(s) == shell_mode\n-        @test buffercontents(LineEdit.buffer(s)) == \"ll\"\n-        @test position(LineEdit.buffer(s)) == 0\n-\n-        # Test that searching backwards with a one-letter query doesn't\n-        # return indefinitely the same match (#9352)\n-        LineEdit.enter_search(s, histp, true)\n-        write(ss.query_buffer, \"l\")\n-        LineEdit.update_display_buffer(ss, ss)\n-        LineEdit.history_next_result(s, ss)\n-        LineEdit.update_display_buffer(ss, ss)\n-        LineEdit.accept_result(s, histp)\n-        @test LineEdit.mode(s) == repl_mode\n-        @test buffercontents(LineEdit.buffer(s)) == \"shell\"\n-        @test position(LineEdit.buffer(s)) == 4\n-\n-        # Test that searching backwards doesn't skip matches (#9352)\n-        # (for a search with multiple one-byte characters, or UTF-8 characters)\n-        LineEdit.enter_search(s, histp, true)\n-        write(ss.query_buffer, \"\u00e9\") # matches right-most \"\u00e9\" in \"\u00e9\u00e9\"\n-        LineEdit.update_display_buffer(ss, ss)\n-        @test position(ss.query_buffer) == sizeof(\"\u00e9\")\n-        LineEdit.history_next_result(s, ss) # matches left-most \"\u00e9\" in \"\u00e9\u00e9\"\n-        LineEdit.update_display_buffer(ss, ss)\n-        LineEdit.accept_result(s, histp)\n-        @test buffercontents(LineEdit.buffer(s)) == \"\u00e9\u00e9\"\n-        @test position(LineEdit.buffer(s)) == 0\n-\n-        # Issue #7551\n-        # Enter search mode and try accepting an empty result\n-        REPL.history_reset_state(hp)\n-        LineEdit.edit_clear(s)\n-        cur_mode = LineEdit.mode(s)\n-        LineEdit.enter_search(s, histp, true)\n-        LineEdit.accept_result(s, histp)\n-        @test LineEdit.mode(s) == cur_mode\n-        @test buffercontents(LineEdit.buffer(s)) == \"\"\n-        @test position(LineEdit.buffer(s)) == 0\n-\n-        # Test that new modes can be dynamically added to the REPL and will\n-        # integrate nicely\n-        foobar_mode, custom_histp = AddCustomMode(repl, prompt)\n-\n-        # ^R l, should now find `ls` in foobar mode\n-        LineEdit.enter_search(s, histp, true)\n-        ss = LineEdit.state(s, histp)\n-        write(ss.query_buffer, \"l\")\n-        LineEdit.update_display_buffer(ss, ss)\n-        LineEdit.accept_result(s, histp)\n-        @test LineEdit.mode(s) == foobar_mode\n-        @test buffercontents(LineEdit.buffer(s)) == \"ls\"\n-        @test position(LineEdit.buffer(s)) == 0\n-\n-        # Try the same for prefix search\n-        LineEdit.history_next(s, hp)\n-        LineEdit.history_prev_prefix(ps, hp, \"l\")\n-        @test ps.parent == foobar_mode\n-        @test LineEdit.input_string(ps) == \"ls\"\n-        @test position(LineEdit.buffer(s)) == 1\n-\n-        # Some Unicode handling testing\n-        LineEdit.history_prev(s, hp)\n-        LineEdit.enter_search(s, histp, true)\n-        write(ss.query_buffer, \"x\")\n-        LineEdit.update_display_buffer(ss, ss)\n-        @test buffercontents(ss.response_buffer) == \"x \u0394x\u0394\"\n-        @test position(ss.response_buffer) == 4\n-        write(ss.query_buffer, \" \")\n-        LineEdit.update_display_buffer(ss, ss)\n-        LineEdit.accept_result(s, histp)\n-        @test LineEdit.mode(s) == repl_mode\n-        @test buffercontents(LineEdit.buffer(s)) == \"x \u0394x\u0394\"\n-        @test position(LineEdit.buffer(s)) == 0\n-\n-        LineEdit.edit_clear(s)\n-        LineEdit.enter_search(s, histp, true)\n-        ss = LineEdit.state(s, histp)\n-        write(ss.query_buffer, \"\u00c5\") # should not be in history\n-        LineEdit.update_display_buffer(ss, ss)\n-        @test buffercontents(ss.response_buffer) == \"\"\n-        @test position(ss.response_buffer) == 0\n-        LineEdit.history_next_result(s, ss) # should not throw BoundsError\n-        LineEdit.accept_result(s, histp)\n-\n-        # Try entering search mode while in custom repl mode\n-        LineEdit.enter_search(s, custom_histp, true)\n     end\n end\n \n@@ -1035,7 +925,7 @@ function history_move_prefix(s::LineEdit.MIState,\n     hist.last_idx = -1\n     idxs = backwards ? ((cur_idx-1):-1:1) : ((cur_idx+1):length(hist.history))\n     for idx in idxs\n-        if startswith(hist.history[idx], prefix) && hist.history[idx] != allbuf\n+        if startswith(hist.history[idx].content, prefix) && hist.history[idx].content != allbuf\n             REPL.history_move(s, hist, idx)\n             seek(LineEdit.buffer(s), pos)\n             LineEdit.refresh_line(s)\n@@ -1091,7 +981,7 @@ for keys = [altkeys, merge(altkeys...)],\n \n             # Close the history file\n             # (otherwise trying to delete it fails on Windows)\n-            close(repl.interface.modes[1].hist.history_file)\n+            close(repl.interface.modes[1].hist.history)\n \n             # Check that the correct prompt was displayed\n             output = readuntil(stdout_read, \"1 * 1;\", keep=true)\n@@ -1726,21 +1616,20 @@ for prompt = [\"Test\u03a0\", () -> randstring(rand(1:10))]\n         shell_mode = repl.interface.modes[2]\n         help_mode = repl.interface.modes[3]\n         pkg_mode = repl.interface.modes[4]\n-        histp = repl.interface.modes[5]\n-        prefix_mode = repl.interface.modes[6]\n+        # histp = repl.interface.modes[5]\n+        prefix_mode = repl.interface.modes[5]\n \n         hp = REPL.REPLHistoryProvider(Dict{Symbol,Any}(:julia => repl_mode,\n                                                        :shell => shell_mode,\n                                                        :help  => help_mode))\n         hist_path = tempname()\n         write(hist_path, fakehistory_2)\n-        REPL.hist_from_file(hp, hist_path)\n-        f = open(hist_path, read=true, write=true, create=true)\n-        hp.history_file = f\n-        seekend(f)\n+        histfile = REPL.HistoryFile(hist_path)\n+        hp.history = histfile\n+        REPL.history_do_initialize(hp)\n         REPL.history_reset_state(hp)\n \n-        histp.hp = repl_mode.hist = shell_mode.hist = help_mode.hist = hp\n+        # histp.hp = repl_mode.hist = shell_mode.hist = help_mode.hist = hp\n \n         s = LineEdit.init_state(repl.t, prefix_mode)\n         prefix_prev() = REPL.history_prev_prefix(s, hp, \"x\")"
    },
    {
      "sha": "2b842dd218f11228f6e556476b0f695db7c88465",
      "filename": "stdlib/REPL/test/runtests.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/stdlib%2FREPL%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Fruntests.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -22,6 +22,9 @@ end\n module TerminalMenusTest\n     include(\"TerminalMenus/runtests.jl\")\n end\n+module HistoryTest\n+    include(\"history.jl\")\n+end\n module BadHistoryStartupTest\n     include(\"bad_history_startup.jl\")\n end"
    },
    {
      "sha": "aca044d171747a02494eb9d31eb947cf924357a0",
      "filename": "test/strings/annotated.jl",
      "status": "modified",
      "additions": 506,
      "deletions": 0,
      "changes": 506,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/test%2Fstrings%2Fannotated.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/test%2Fstrings%2Fannotated.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fstrings%2Fannotated.jl?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -306,3 +306,509 @@ end\n         [(\"\ud835\udfcf\", [(:face, :red)]),\n          (\"x\", [])]\n end\n+\n+@testset \"Replacement\" begin\n+    astr(s::String, faceregions::Tuple{UnitRange{Int}, Symbol}...) =\n+        Base.AnnotatedString(s, [(r, :face, f) for (r, f) in faceregions])\n+\n+    @testset \"Basic Transformations\" begin\n+        @testset \"Deletion\" begin\n+            @test replace(astr(\"hello world\", (1:5, :red)), \"hello\" => \"hi\") ==\n+                astr(\"hi world\")\n+            @test replace(astr(\"foofoo\", (1:3, :red), (4:6, :green)), \"foo\" => \"x\") ==\n+                astr(\"xx\")\n+            @test replace(astr(\"foofoo\", (1:3, :red), (4:6, :green)), \"foo\" => \"x\", count=1) ==\n+                astr(\"xfoo\", (2:4, :green))\n+            @test replace(astr(\"abcdef\", (1:6, :red), (3:4, :green)), \"cd\" => \"X\") ==\n+                astr(\"abXef\", (1:2, :red), (4:5, :red))\n+            @test replace(astr(\"a b c\", (1:1, :red), (3:3, :green), (5:5, :blue)),\n+                         \"a\" => \"x\", \"b\" => \"y\", \"c\" => \"z\") ==\n+                astr(\"x y z\")\n+        end\n+\n+        @testset \"Shifting\" begin\n+            @test replace(astr(\"hello world\", (7:11, :red)), \"hello\" => \"hi\") ==\n+                astr(\"hi world\", (4:8, :red))\n+            @test replace(astr(\"hello world\", (7:11, :red)), \"hello\" => \"greetings\") ==\n+                astr(\"greetings world\", (11:15, :red))\n+            @test replace(astr(\"a b c\", (3:3, :red)), \"a\" => \"xxx\", \"c\" => \"y\") ==\n+                astr(\"xxx b y\", (5:5, :red))\n+            @test replace(astr(\"abc def\", (5:7, :green)), \"abc\" => \"x\") ==\n+                astr(\"x def\", (3:5, :green))\n+            @test replace(astr(\"a b c d\", (3:3, :red), (5:5, :green), (7:7, :blue)), \"a\" => \"AA\") ==\n+                astr(\"AA b c d\", (4:4, :red), (6:6, :green), (8:8, :blue))\n+            @test replace(astr(\"hello world\", (7:11, :green)), \" world\" => \" Julia\") ==\n+                astr(\"hello Julia\")\n+        end\n+\n+        @testset \"Splitting\" begin\n+            @test replace(astr(\"hello world\", (1:11, :red)), \" \" => \"_\") ==\n+                astr(\"hello_world\", (1:5, :red), (7:11, :red))\n+            @test replace(astr(\"a b c\", (1:5, :red)), \" \" => \"_\") ==\n+                astr(\"a_b_c\", (1:1, :red), (3:3, :red), (5:5, :red))\n+            @test replace(astr(\"foobarbaz\", (1:9, :green)), \"o\" => \"0\", \"a\" => \"A\") ==\n+                astr(\"f00bArbAz\", (1:1, :green), (4:4, :green), (6:7, :green), (9:9, :green))\n+            @test replace(astr(\"a b c\", (1:5, :red)), \" \" => \"_\", count=1) ==\n+                astr(\"a_b c\", (1:1, :red), (3:5, :red))\n+            @test replace(astr(\"abcde\", (2:4, :red)), \"c\" => \"X\") ==\n+                astr(\"abXde\", (2:2, :red), (4:4, :red))\n+            @test replace(astr(\"a a a a\", (1:7, :blue)), \"a\" => \"b\") ==\n+                astr(\"b b b b\", (2:2, :blue), (4:4, :blue), (6:6, :blue))\n+        end\n+\n+        @testset \"Addition\" begin\n+            @test replace(astr(\"hello world\"), \"world\" => astr(\"Julia\", (1:5, :red))) ==\n+                astr(\"hello Julia\", (7:11, :red))\n+            @test replace(astr(\"hello\"), \"hello\" => astr(\"hi there\", (1:2, :red), (4:8, :green))) ==\n+                astr(\"hi there\", (1:2, :red), (4:8, :green))\n+            @test replace(astr(\"hello world\", (7:11, :green)), \"hello\" => astr(\"hi\", (1:2, :red))) ==\n+                astr(\"hi world\", (4:8, :green), (1:2, :red))\n+            @test replace(astr(\"a b\", (1:3, :yellow)), \" \" => astr(\"_\", (1:1, :red))) ==\n+                astr(\"a_b\", (1:1, :yellow), (3:3, :yellow), (2:2, :red))\n+            @test replace(astr(\"a b\"), \"a\" => astr(\"X\", (1:1, :red)), \"b\" => astr(\"Y\", (1:1, :blue))) ==\n+                astr(\"X Y\", (1:1, :red), (3:3, :blue))\n+        end\n+\n+        @testset \"Combinations\" begin\n+            @test replace(astr(\"a b c\", (1:1, :red), (5:5, :blue)), \"b\" => \"B\") ==\n+                astr(\"a B c\", (1:1, :red), (5:5, :blue))\n+            @test replace(astr(\"a b\", (1:3, :red)), \" \" => astr(\"_\", (1:1, :blue))) ==\n+                astr(\"a_b\", (1:1, :red), (3:3, :red), (2:2, :blue))\n+            @test replace(astr(\"foo bar baz\", (1:3, :red), (5:7, :green), (9:11, :blue)),\n+                         \"foo\" => \"F\", \"a\" => astr(\"A\", (1:1, :yellow))) ==\n+                astr(\"F bAr bAz\", (3:3, :green), (5:5, :green), (7:7, :blue), (9:9, :blue),\n+                     (4:4, :yellow), (8:8, :yellow))\n+        end\n+    end\n+\n+    @testset \"Pattern Types\" begin\n+        @testset \"Char\" begin\n+            @test replace(astr(\"hello\", (1:5, :red)), 'l' => 'L') ==\n+                astr(\"heLLo\", (1:2, :red), (5:5, :red))\n+            @test replace(astr(\"hello\"), 'o' => astr(\"O\", (1:1, :red))) ==\n+                astr(\"hellO\", (5:5, :red))\n+            @test replace(astr(\"aaa\", (1:3, :red)), 'a' => 'b') ==\n+                astr(\"bbb\")\n+            @test replace(astr(\"aaa\", (1:3, :red)), 'a' => 'b', count=2) ==\n+                astr(\"bba\", (3:3, :red))\n+            @test replace(astr(\"caf\u00e9\", (1:5, :green)), '\u00e9' => 'e') ==\n+                astr(\"cafe\", (1:3, :green))\n+            @test replace(astr(\"test\"), 't' => astr(\"TTT\", (1:3, :blue))) ==\n+                astr(\"TTTesTTT\", (1:3, :blue), (6:8, :blue))\n+            @test replace(astr(\"hello\", (1:5, :red)), 'l' => Base.AnnotatedChar('L', [(label=:face, value=:blue)])) ==\n+                astr(\"heLLo\", (1:2, :red), (5:5, :red), (3:4, :blue))\n+            @test replace(astr(\"abc\", (1:3, :green)), 'b' => Base.AnnotatedChar('B', [(label=:face, value=:bold)])) ==\n+                astr(\"aBc\", (1:1, :green), (3:3, :green), (2:2, :bold))\n+        end\n+\n+        @testset \"Regex\" begin\n+            @test replace(astr(\"foo bar\", (1:7, :green)), r\"o+\" => \"0\") ==\n+                astr(\"f0 bar\", (1:1, :green), (3:6, :green))\n+            @test replace(astr(\"hello\"), r\"l+\" => astr(\"L\", (1:1, :red))) ==\n+                astr(\"heLo\", (3:3, :red))\n+            @test replace(astr(\"ab\", (1:2, :red)), r\"\" => \"^\") ==\n+                astr(\"^a^b^\", (2:2, :red), (4:4, :red))\n+            @test replace(astr(\"abc\", (1:3, :red)), r\"b?\" => \"X\") ==\n+                astr(\"XaXcX\", (2:2, :red), (4:4, :red))\n+            @test replace(astr(\"aaa\", (1:3, :red)), r\"a+\" => \"b\") ==\n+                astr(\"b\")\n+        end\n+\n+        @testset \"Predicate\" begin\n+            @test replace(astr(\"abc\", (1:3, :red)), islowercase => 'X') ==\n+                astr(\"XXX\")\n+        end\n+\n+        @testset \"Count\" begin\n+            @test replace(astr(\"hello\", (1:5, :red)), \"l\" => \"L\", count=0) ==\n+                astr(\"hello\", (1:5, :red))\n+            @test replace(astr(\"a b c\", (5:5, :red)), \"a\" => \"A\", count=1) ==\n+                astr(\"A b c\", (5:5, :red))\n+            @test replace(astr(\"a b c\", (1:5, :red)), \" \" => \"_\", count=1) ==\n+                astr(\"a_b c\", (1:1, :red), (3:5, :red))\n+            @test replace(astr(\"a b\"), \"a\" => astr(\"X\", (1:1, :red)),\n+                         \"b\" => astr(\"Y\", (1:1, :blue)), count=1) ==\n+                astr(\"X b\", (1:1, :red))\n+            @test replace(astr(\"abc\", (1:3, :red)), \"x\" => \"y\", count=10) ==\n+                astr(\"abc\", (1:3, :red))\n+        end\n+\n+        @testset \"AnnotatedChar\" begin\n+            @test replace(astr(\"test\", (1:4, :red)), 't' => Base.AnnotatedChar('T', [(label=:face, value=:blue)])) ==\n+                astr(\"TesT\", (2:3, :red), (1:1, :blue), (4:4, :blue))\n+            @test replace(astr(\"hello\"), 'l' => Base.AnnotatedChar('L', [(label=:face, value=:bold), (label=:face, value=:red)])) ==\n+                astr(\"heLLo\", (3:4, :bold), (3:4, :red))\n+            @test replace(astr(\"a b c\", (1:5, :green)), ' ' => Base.AnnotatedChar('_', [(label=:face, value=:underline)])) ==\n+                astr(\"a_b_c\", (1:1, :green), (3:3, :green), (5:5, :green), (2:2, :underline), (4:4, :underline))\n+        end\n+\n+        @testset \"SubString\" begin\n+            source = astr(\"WORLD\", (1:5, :blue))\n+            @test replace(astr(\"hello world\", (1:11, :red)), \"world\" => SubString(source, 1:5)) ==\n+                astr(\"hello WORLD\", (1:6, :red), (7:11, :blue))\n+            source2 = astr(\"TEST\", (1:2, :green), (3:4, :cyan))\n+            @test replace(astr(\"foo bar\"), \"bar\" => SubString(source2, 1:4)) ==\n+                astr(\"foo TEST\", (5:6, :green), (7:8, :cyan))\n+            source3 = astr(\"annotation\", (1:10, :emphasis))\n+            @test replace(astr(\"replace me\", (1:10, :red)), \"me\" => SubString(source3, 1:2)) ==\n+                astr(\"replace an\", (1:8, :red), (9:10, :emphasis))\n+        end\n+    end\n+\n+    @testset \"Multiple Replacements\" begin\n+        @test replace(astr(\"foo bar baz\", (1:3, :red), (5:7, :green), (9:11, :blue)),\n+                     \"foo\" => \"F\", \"bar\" => \"B\", \"baz\" => \"Z\") ==\n+            astr(\"F B Z\")\n+        @test replace(astr(\"foo bar\"), \"foo\" => astr(\"F\", (1:1, :red)), \"bar\" => \"B\") ==\n+            astr(\"F B\", (1:1, :red))\n+        @test replace(astr(\"abc\", (1:3, :red)), \"a\" => \"A\", \"b\" => \"B\", \"c\" => \"C\") ==\n+            astr(\"ABC\")\n+        @test replace(astr(\"foo bar foo\", (1:3, :red), (9:11, :green)),\n+                     \"foo\" => \"F\", \"bar\" => \"B\", count=2) ==\n+            astr(\"F B foo\", (5:7, :green))\n+        @test replace(astr(\"a b c\", (5:5, :cyan)),\n+                     \"a\" => astr(\"X\", (1:1, :red)), \"b\" => astr(\"Y\", (1:1, :blue))) ==\n+            astr(\"X Y c\", (5:5, :cyan), (1:1, :red), (3:3, :blue))\n+        @test replace(astr(\"xaybzc\", (2:2, :red), (4:4, :green), (6:6, :blue)),\n+                     \"x\" => \"X\", \"y\" => \"Y\", \"z\" => \"Z\") ==\n+            astr(\"XaYbZc\", (2:2, :red), (4:4, :green), (6:6, :blue))\n+        @test replace(astr(\"foo123bar\", (1:3, :red), (7:9, :green)),\n+                     r\"(\\d+)\" => astr(\"NUM\", (1:3, :blue))) ==\n+            astr(\"fooNUMbar\", (1:3, :red), (7:9, :green), (4:6, :blue))\n+\n+        @testset \"Pattern type combinations\" begin\n+            @test replace(astr(\"a1b2c\", (1:5, :red)), 'a' => \"A\", r\"\\d\" => \"X\") ==\n+                astr(\"AXbXc\", (3:3, :red), (5:5, :red))\n+            @test replace(astr(\"HeLLo\", (1:5, :green)), isuppercase => 'x', \"LL\" => \"ll\") ==\n+                astr(\"xexxo\", (2:2, :green), (5:5, :green))\n+            @test replace(astr(\"test123\", (1:7, :blue)), isdigit => 'X', \"test\" => \"TEST\") ==\n+                astr(\"TESTXXX\")\n+        end\n+\n+        @testset \"Overlapping patterns\" begin\n+            @test replace(astr(\"aaaa\", (1:4, :red)), \"aa\" => \"b\") ==\n+                astr(\"bb\")\n+            @test replace(astr(\"abcabc\", (1:3, :red), (4:6, :green)), \"abc\" => \"X\", \"bc\" => \"Y\") ==\n+                astr(\"XX\")\n+        end\n+\n+        @testset \"Count with multiple patterns\" begin\n+            @test replace(astr(\"a b a b\", (1:7, :red)), \"a\" => \"A\", \"b\" => \"B\", count=3) ==\n+                astr(\"A B A b\", (2:2, :red), (4:4, :red), (6:7, :red))\n+            @test replace(astr(\"x o x o x o\", (1:11, :blue)), 'x' => \"X\", 'o' => \"O\", count=4) ==\n+                astr(\"X O X O x o\", (2:2, :blue), (4:4, :blue), (6:6, :blue), (8:11, :blue))\n+        end\n+    end\n+\n+    @testset \"Edge Cases\" begin\n+        @testset \"Boundaries\" begin\n+            @test replace(astr(\"abcdef\", (4:6, :red)), \"abc\" => \"x\") ==\n+                astr(\"xdef\", (2:4, :red))\n+            @test replace(astr(\"abcdef\", (1:3, :red)), \"def\" => \"x\") ==\n+                astr(\"abcx\", (1:3, :red))\n+            @test replace(astr(\"abcdef\", (3:6, :red)), \"abcd\" => \"X\") ==\n+                astr(\"Xef\", (2:3, :red))\n+            @test replace(astr(\"abcdef\", (1:4, :red)), \"cdef\" => \"X\") ==\n+                astr(\"abX\", (1:2, :red))\n+            @test replace(astr(\"abc\", (2:2, :red)), \"b\" => \"B\") ==\n+                astr(\"aBc\")\n+            @test replace(astr(\"abc\", (3:3, :red)), \"a\" => \"A\") ==\n+                astr(\"Abc\", (3:3, :red))\n+            @test replace(astr(\"foobar\", (1:3, :red)), \"foo\" => \"x\") ==\n+                astr(\"xbar\")\n+            @test replace(astr(\"foobar\", (4:6, :red)), \"bar\" => \"x\") ==\n+                astr(\"foox\")\n+        end\n+\n+        @testset \"Empty\" begin\n+            @test replace(astr(\"hello\", (1:5, :red)), \"x\" => \"y\") ==\n+                astr(\"hello\", (1:5, :red))\n+            @test replace(astr(\"\"), \"x\" => \"y\") == astr(\"\")\n+            @test replace(astr(\"\", (1:0, :red)), \"\" => \"x\") == astr(\"x\")\n+            @test replace(astr(\"ab\", (1:2, :red)), \"\" => \"^\") ==\n+                astr(\"^a^b^\", (2:2, :red), (4:4, :red))\n+            @test replace(astr(\"hello\", (1:5, :red)), \"l\" => \"\") ==\n+                astr(\"heo\", (1:2, :red), (3:3, :red))\n+            @test replace(astr(\"hello world\", (7:11, :green)), \"hello \" => astr(\"\")) ==\n+                astr(\"world\", (1:5, :green))\n+        end\n+\n+        @testset \"Unicode\" begin\n+            @test replace(astr(\"f\u00f8\u00f8 bar\", (1:4, :red)), \"f\u00f8\u00f8\" => \"foo\") ==\n+                astr(\"foo bar\")\n+            @test replace(astr(\"hello\", (1:5, :red)), \"llo\" => \"\u1e3b\u1e3b\u00f8\") ==\n+                astr(\"he\u1e3b\u1e3b\u00f8\", (1:2, :red))\n+            @test replace(astr(\"foo\"), \"foo\" => astr(\"\u0180\u00e4\u1e59\", (1:6, :red))) ==\n+                astr(\"\u0180\u00e4\u1e59\", (1:6, :red))\n+            @test replace(astr(\"a\ud835\udfcfb\", (1:6, :red)), \"\ud835\udfcf\" => \"1\") ==\n+                astr(\"a1b\", (1:1, :red), (3:3, :red))\n+            @test replace(astr(\"\u1e1f\u00f8\u00f8 b\u00e4r\", (1:12, :green)), \" \" => \"_\") ==\n+                astr(\"\u1e1f\u00f8\u00f8_b\u00e4r\", (1:7, :green), (9:12, :green))\n+            @test replace(astr(\"a\ud835\udfcfb\ud835\udfcfc\", (1:9, :red)), \"\ud835\udfcf\" => \"1\") ==\n+                astr(\"a1b1c\", (1:1, :red), (3:3, :red))\n+        end\n+\n+        @testset \"Special characters\" begin\n+            @test replace(astr(\"a\\nb\", (1:3, :red)), \"\\n\" => \" \") ==\n+                astr(\"a b\", (1:1, :red), (3:3, :red))\n+            @test replace(astr(\"a\\tb\", (1:3, :red)), \"\\t\" => \" \") ==\n+                astr(\"a b\", (1:1, :red), (3:3, :red))\n+            @test replace(astr(\"a\\0b\", (1:3, :red)), \"\\0\" => \"x\") ==\n+                astr(\"axb\", (1:1, :red), (3:3, :red))\n+        end\n+\n+        @testset \"Annotation edge cases\" begin\n+            @test replace(astr(\"hello\", (1:5, :blue)), \"l\" => \"L\") ==\n+                astr(\"heLLo\", (1:2, :blue), (5:5, :blue))\n+            @test replace(astr(\"aabb\", (1:4, :red)), \"a\" => \"x\", \"b\" => \"y\") ==\n+                astr(\"xxyy\")\n+            @test replace(astr(\"hello\", (1:3, :red), (2:4, :green)), \"el\" => \"X\") ==\n+                astr(\"hXlo\", (1:1, :red), (3:3, :green))\n+            str_multi = astr(\"test\", (1:4, :red), (1:4, :en))\n+            @test replace(str_multi, \"test\" => \"ok\") == astr(\"ok\")\n+            str2 = astr(\"a b\", (1:3, :red), (1:3, :bold))\n+            result = replace(str2, \" \" => \"_\")\n+            @test String(result) == \"a_b\"\n+            @test length(Base.annotations(result)) == 4\n+            str3 = astr(\"hi world\", (4:8, :red), (4:8, :bold))\n+            result2 = replace(str3, \"hi\" => \"hello\")\n+            @test String(result2) == \"hello world\"\n+            @test length(Base.annotations(result2)) == 2\n+\n+            str_triple = astr(\"abc\", (1:3, :red), (1:3, :bold), (1:3, :italic))\n+            @test replace(str_triple, \"b\" => \"B\") ==\n+                astr(\"aBc\", (1:1, :red), (3:3, :red),\n+                     (1:1, :bold), (3:3, :bold),\n+                     (1:1, :italic), (3:3, :italic))\n+\n+            str_nested = astr(\"abcde\", (1:5, :outer), (2:4, :middle), (3:3, :inner))\n+            @test replace(str_nested, \"c\" => \"X\") ==\n+                astr(\"abXde\", (1:2, :outer), (4:5, :outer), (2:2, :middle), (4:4, :middle))\n+\n+            str_same_label = astr(\"test\", (1:2, :val1), (3:4, :val2))\n+            @test replace(str_same_label, \"es\" => \"X\") ==\n+                astr(\"tXt\", (1:1, :val1), (3:3, :val2))\n+        end\n+\n+        @testset \"Size variations\" begin\n+            @test replace(astr(\"hello\", (1:5, :red)), \"hello\" => \"world\") ==\n+                astr(\"world\")\n+            @test replace(astr(\"hi\", (1:2, :red)), \"hi\" => \"hello\") ==\n+                astr(\"hello\")\n+            @test replace(astr(\"hello\", (1:5, :red)), \"hello\" => \"hi\") ==\n+                astr(\"hi\")\n+            @test replace(astr(\"a b c\", (1:1, :red), (3:3, :green), (5:5, :blue)), \"b\" => \"B\") ==\n+                astr(\"a B c\", (1:1, :red), (5:5, :blue))\n+            @test replace(astr(\"hello world\", (1:5, :red)), \"world\" => \"there\") ==\n+                astr(\"hello there\", (1:5, :red))\n+            @test replace(astr(\"hello world\", (7:11, :green)), \"hello\" => \"hi\") ==\n+                astr(\"hi world\", (4:8, :green))\n+            @test replace(astr(\"hi\"), \"hi\" => astr(\"hello world\", (1:5, :red), (7:11, :green))) ==\n+                astr(\"hello world\", (1:5, :red), (7:11, :green))\n+            @test replace(astr(\"hello world\"), \"hello world\" => astr(\"hi\", (1:2, :red))) ==\n+                astr(\"hi\", (1:2, :red))\n+            @test replace(astr(\"aabbcc\", (1:6, :red)), \"a\" => \"x\", \"b\" => \"y\", \"c\" => \"z\") ==\n+                astr(\"xxyyzz\")\n+            @test replace(astr(\"hello\", (1:5, :red)), \"hello\" => astr(\"hello\", (1:5, :blue))) ==\n+                astr(\"hello\", (1:5, :blue))\n+        end\n+\n+        @testset \"Complex\" begin\n+            @test replace(astr(\"a b c d\", (1:7, :red)), \" \" => \"_\") ==\n+                astr(\"a_b_c_d\", (1:1, :red), (3:3, :red), (5:5, :red), (7:7, :red))\n+            annots = [(i:i, :red) for i in 1:2:9]\n+            @test replace(astr(\"a b c d e\", annots...), \" \" => \"_\") ==\n+                astr(\"a_b_c_d_e\", (1:1, :red), (3:3, :red), (5:5, :red), (7:7, :red), (9:9, :red))\n+            @test replace(astr(\"abcdefgh\", (1:8, :red)), \"cd\" => \"X\") ==\n+                astr(\"abXefgh\", (1:2, :red), (4:7, :red))\n+            @test replace(astr(\"hello world\"), \"world\" => \"Julia\") ==\n+                astr(\"hello Julia\")\n+            @test replace(astr(\"hello\", (1:5, :red)), \"ello\" => uppercase) ==\n+                astr(\"hELLO\", (1:1, :red))\n+\n+            str_code = astr(\"function test()\", (1:8, :keyword), (10:13, :identifier))\n+            @test replace(str_code, \"test\" => \"demo\", \"(\" => \"[\", \")\" => \"]\") ==\n+                astr(\"function demo[]\", (1:8, :keyword))\n+\n+            str_markdown = astr(\"This is *bold* text\", (9:13, :emphasis))\n+            @test replace(str_markdown, \"*\" => \"\", \"bold\" => astr(\"BOLD\", (1:4, :strong))) ==\n+                astr(\"This is BOLD text\", (9:12, :strong))\n+\n+            str_chain = astr(\"aaa\", (1:3, :red))\n+            str_chain = replace(str_chain, \"a\" => astr(\"b\", (1:1, :green)))\n+            str_chain = replace(str_chain, \"b\" => astr(\"c\", (1:1, :blue)))\n+            @test String(str_chain) == \"ccc\"\n+            @test length(Base.annotations(str_chain)) == 1\n+\n+            str_interleaved = astr(\"a1b2c3\", (1:1, :red), (3:3, :green), (5:5, :blue))\n+            @test replace(str_interleaved, r\"\\d\" => astr(\"X\", (1:1, :yellow))) ==\n+                astr(\"aXbXcX\", (1:1, :red), (3:3, :green), (5:5, :blue),\n+                     (2:2, :yellow), (4:4, :yellow), (6:6, :yellow))\n+        end\n+\n+\n+\n+        @testset \"Overlapping annotations\" begin\n+            # Annotations that overlap on the same text\n+            str_overlap = astr(\"hello world\", (1:5, :red), (3:9, :bold))\n+            @test replace(str_overlap, \"ll\" => \"LL\") ==\n+                astr(\"heLLo world\", (1:2, :red), (5:5, :red), (5:9, :bold))\n+            # Multiple overlapping annotations\n+            str_multi = astr(\"testing\", (1:7, :outer), (2:6, :middle), (3:5, :inner))\n+            @test replace(str_multi, \"es\" => \"ES\") ==\n+                astr(\"tESting\", (1:1, :outer), (4:7, :outer),\n+                     (4:6, :middle),\n+                     (4:5, :inner))\n+        end\n+\n+        @testset \"Multiple annotations same region\" begin\n+            # Same region with different labels\n+            str = astr(\"test\", (1:4, :red), (1:4, :bold), (2:3, :italic))\n+            @test replace(str, \"es\" => \"ES\") ==\n+                astr(\"tESt\", (1:1, :red), (4:4, :red),\n+                     (1:1, :bold), (4:4, :bold))\n+            # Same label, different values on different regions\n+            str2 = astr(\"test\", (1:2, :red), (3:4, :blue))\n+            @test replace(str2, \"es\" => \"ES\") ==\n+                astr(\"tESt\", (1:1, :red), (4:4, :blue))\n+        end\n+\n+        @testset \"Annotation merging\" begin\n+            # Adjacent replacements with same annotations should merge\n+            str = astr(\"abc\", (1:3, :red))\n+            result = replace(str, 'a' => astr(\"A\", (1:1, :red)), 'b' => astr(\"B\", (1:1, :red)), 'c' => astr(\"C\", (1:1, :red)))\n+            @test String(result) == \"ABC\"\n+            @test Base.annotations(result) == [(region=1:3, label=:face, value=:red)]\n+\n+            # Non-adjacent should not merge\n+            str2 = astr(\"axbxc\", (1:5, :green))\n+            result2 = replace(str2, 'a' => astr(\"A\", (1:1, :red)), 'c' => astr(\"C\", (1:1, :red)))\n+            @test String(result2) == \"AxbxC\"\n+            # The middle section should be green, ends should be red (not merged)\n+            @test length(Base.annotations(result2)) >= 2\n+        end\n+\n+        @testset \"Pattern with itself\" begin\n+            # Replace pattern with itself but different annotations\n+            @test replace(astr(\"test\", (1:4, :red)), \"t\" => astr(\"t\", (1:1, :blue))) ==\n+                astr(\"test\", (2:3, :red), (1:1, :blue), (4:4, :blue))\n+            # Same length, same content, different annotation\n+            @test replace(astr(\"hello\", (1:5, :red)), \"hello\" => astr(\"hello\", (1:5, :blue))) ==\n+                astr(\"hello\", (1:5, :blue))\n+        end\n+\n+        @testset \"Many replacements\" begin\n+            # Many occurrences of same pattern\n+            str = astr(\"a\" * \"b\"^20, (1:21, :red))\n+            result = replace(str, \"b\" => \"B\")\n+            @test String(result) == \"a\" * \"B\"^20\n+            @test Base.annotations(result) == [(region=1:1, label=:face, value=:red)]\n+\n+            # Multiple different patterns\n+            str2 = astr(\"ababababab\", (1:10, :green))\n+            result2 = replace(str2, \"a\" => \"A\", \"b\" => \"B\")\n+            @test String(result2) == \"ABABABABAB\"\n+            @test Base.annotations(result2) == []\n+        end\n+\n+        @testset \"Annotation spanning replacements\" begin\n+            # Annotation covers entire string with multiple replacements\n+            @test replace(astr(\"a-b-c-d\", (1:7, :red)), \"-\" => \"_\") ==\n+                astr(\"a_b_c_d\", (1:1, :red), (3:3, :red), (5:5, :red), (7:7, :red))\n+            # Multiple replacements at different positions\n+            str = astr(\"abcdefgh\", (1:8, :blue))\n+            @test replace(str, \"b\" => \"B\", \"d\" => \"D\", \"f\" => \"F\") ==\n+                astr(\"aBcDeFgh\", (1:1, :blue), (3:3, :blue), (5:5, :blue), (7:8, :blue))\n+        end\n+\n+        @testset \"edge annotation regions\" begin\n+            # Empty region (0:0) outside string bounds gets filtered out\n+            str_empty = astr(\"test\", (0:0, :red))\n+            @test replace(str_empty, \"t\" => \"T\") == astr(\"TesT\")\n+\n+            # Backward range within bounds is preserved (even though it's empty)\n+            str_backward = astr(\"test\", (3:2, :red))\n+            @test replace(str_backward, \"t\" => \"T\") == astr(\"TesT\", (3:2, :red))\n+\n+            # Backward range outside bounds gets filtered out\n+            str_backward_out = astr(\"test\", (5:3, :red))\n+            @test replace(str_backward_out, \"t\" => \"T\") == astr(\"TesT\")\n+        end\n+    end\n+\n+    @testset \"IO\" begin\n+        buf = Base.AnnotatedIOBuffer()\n+        replace(buf, astr(\"hello\", (1:5, :red)), \"l\" => \"L\")\n+        result = read(seekstart(buf), Base.AnnotatedString)\n+        @test result == astr(\"heLLo\", (1:2, :red), (5:5, :red))\n+\n+        buf = Base.AnnotatedIOBuffer()\n+        replace(buf, astr(\"a\", (1:1, :red)), \"a\" => \"x\")\n+        replace(buf, astr(\"b\", (1:1, :blue)), \"b\" => \"y\")\n+        result = read(seekstart(buf), Base.AnnotatedString)\n+        @test result == astr(\"xy\")\n+\n+        buf = IOBuffer()\n+        replace(buf, astr(\"hello\", (1:5, :red)), \"l\" => \"L\")\n+        @test String(take!(buf)) == \"heLLo\"\n+\n+        buf = Base.AnnotatedIOBuffer()\n+        write(buf, \"prefix \")\n+        replace(buf, astr(\"test\", (1:4, :green)), \"t\" => \"T\")\n+        result = read(seekstart(buf), Base.AnnotatedString)\n+        @test String(result) == \"prefix TesT\"\n+        @test Base.annotations(result) == [(region=9:10, label=:face, value=:green)]\n+\n+        buf = Base.AnnotatedIOBuffer()\n+        replace(buf, astr(\"line1\", (1:5, :red)), \"1\" => \"A\")\n+        write(buf, \"\\n\")\n+        replace(buf, astr(\"line2\", (1:5, :blue)), \"2\" => \"B\")\n+        result = read(seekstart(buf), Base.AnnotatedString)\n+        @test String(result) == \"lineA\\nlineB\"\n+\n+        buf = Base.AnnotatedIOBuffer()\n+        replace(buf, astr(\"test\", (1:4, :green)), \"t\" => \"T\")\n+        truncate(buf, 4)\n+        result = read(seekstart(buf), Base.AnnotatedString)\n+        @test String(result) == \"TesT\"\n+\n+        @testset \"Non-appending operations\" begin\n+            # Write, seek back, then replace (matches standard IOBuffer behavior - no truncation)\n+            buf = Base.AnnotatedIOBuffer()\n+            write(buf, astr(\"original\", (1:8, :red)))\n+            seekstart(buf)\n+            replace(buf, astr(\"test\", (1:4, :blue)), \"t\" => \"T\")\n+            result = read(seekstart(buf), Base.AnnotatedString)\n+            # Standard IOBuffer doesn't truncate, so we get \"TesTinal\" not \"TesT\"\n+            @test String(result) == \"TesTinal\"\n+            # Annotations in the replaced region should be cleared, old ones shifted\n+            @test Base.annotations(result) == [(region=5:8, label=:face, value=:red),\n+                                                (region=2:3, label=:face, value=:blue)]\n+\n+            # Multiple sequential replacements to same buffer (appending)\n+            buf2 = Base.AnnotatedIOBuffer()\n+            replace(buf2, astr(\"first\", (1:5, :red)), \"i\" => \"I\")\n+            write(buf2, \" \")\n+            replace(buf2, astr(\"second\", (1:6, :blue)), \"e\" => \"E\")\n+            result2 = read(seekstart(buf2), Base.AnnotatedString)\n+            @test String(result2) == \"fIrst sEcond\"\n+            # Check annotations are present and positioned correctly\n+            red_annots = filter(a -> a.value == :red, Base.annotations(result2))\n+            blue_annots = filter(a -> a.value == :blue, Base.annotations(result2))\n+            @test !isempty(red_annots)\n+            @test !isempty(blue_annots)\n+\n+            # Writing at different positions within buffer\n+            buf3 = Base.AnnotatedIOBuffer()\n+            write(buf3, \"start \")\n+            pos = position(buf3)\n+            replace(buf3, astr(\"middle\", (1:6, :green)), \"d\" => \"D\")\n+            write(buf3, \" end\")\n+            result3 = read(seekstart(buf3), Base.AnnotatedString)\n+            @test String(result3) == \"start miDDle end\"\n+            # Check that green annotation is offset correctly\n+            green_annots = filter(a -> a.value == :green, Base.annotations(result3))\n+            @test all(a -> first(a.region) >= pos + 1, green_annots)\n+        end\n+    end\n+end"
    },
    {
      "sha": "f4cabf1dd540ddb807ddebbf272a04f91db4caf8",
      "filename": "typos.toml",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/typos.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/24a5ca223fc8bb3bb00cb028683499bfdcaf2945/typos.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/typos.toml?ref=24a5ca223fc8bb3bb00cb028683499bfdcaf2945",
      "patch": "@@ -1,2 +1,5 @@\n [default]\n extend-ignore-words-re = [\"^[a-zA-Z]?[a-zA-Z]?[a-zA-Z]?[a-zA-Z]?$\"]\n+\n+[default.extend-words]\n+indexin = \"indexin\""
    }
  ]
}