{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60312",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60312/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60312/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60312/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60312",
  "id": 3694714272,
  "node_id": "PR_kwDOABkWpM63EjGY",
  "number": 60312,
  "title": "Backports for 1.13.0-beta1",
  "user": {
    "login": "KristofferC",
    "id": 1282691,
    "node_id": "MDQ6VXNlcjEyODI2OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1282691?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KristofferC",
    "html_url": "https://github.com/KristofferC",
    "followers_url": "https://api.github.com/users/KristofferC/followers",
    "following_url": "https://api.github.com/users/KristofferC/following{/other_user}",
    "gists_url": "https://api.github.com/users/KristofferC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KristofferC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KristofferC/subscriptions",
    "organizations_url": "https://api.github.com/users/KristofferC/orgs",
    "repos_url": "https://api.github.com/users/KristofferC/repos",
    "events_url": "https://api.github.com/users/KristofferC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KristofferC/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1166579723,
      "node_id": "MDU6TGFiZWwxMTY2NTc5NzIz",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/release",
      "name": "release",
      "color": "9effb3",
      "default": false,
      "description": "Release management and versioning."
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 2,
  "created_at": "2025-12-04T13:34:49Z",
  "updated_at": "2026-01-10T00:49:58Z",
  "closed_at": "2026-01-09T13:31:14Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60312",
    "html_url": "https://github.com/JuliaLang/julia/pull/60312",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60312.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60312.patch",
    "merged_at": "2026-01-09T13:31:14Z"
  },
  "body": null,
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60312/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60312/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "289247e17d0e0c4c0f31d02fa8c10cbee9c038e1",
      "filename": "Compiler/src/abstractinterpretation.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fabstractinterpretation.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -2244,7 +2244,7 @@ function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::Stmt\n                 return Future(CallMeta(Bottom, ErrorException, EFFECTS_THROWS, NoCallInfo()))\n             end\n             # TODO: When we add curing, we may want to assume this is nothrow\n-            if (method_or_ci.owner === Nothing && method_ir_ci.def.def isa Method)\n+            if (method_or_ci.owner === Nothing && method_or_ci.def.def isa Method)\n                 exct = Union{exct, ErrorException}\n             end\n             update_valid_age!(sv, callee_valid_range)"
    },
    {
      "sha": "e3b7ee1f4926cfac0bacdd4e5bbbb3336037bc40",
      "filename": "Compiler/src/typeinfer.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/Compiler%2Fsrc%2Ftypeinfer.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/Compiler%2Fsrc%2Ftypeinfer.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftypeinfer.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -1501,6 +1501,12 @@ function collectinvokes!(workqueue::CompilationQueue, ci::CodeInfo, sptypes::Vec\n                 push!(argtypes, sp_type_rewrap(at[i], linfo, #= isreturn =# false))\n             end\n             atype = argtypes_to_type(argtypes)\n+        elseif isexpr(stmt, :new)\n+            # When creating a struct of Function type, check to see if we should\n+            # proactively compile the lambda\n+            t, _, _, _ = instanceof_tfunc(argextype(stmt.args[1], ci, sptypes))\n+            t <: Function || continue\n+            atype = Tuple{t, Vararg}\n         else\n             # TODO: handle other StmtInfo like OpaqueClosure?\n             continue"
    },
    {
      "sha": "141161b9403024289b978ccd93b6cf317af9c17e",
      "filename": "HISTORY.md",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/HISTORY.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/HISTORY.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/HISTORY.md?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -8,7 +8,7 @@ New language features\n   entry points. Entry points can be marked using `Base.Experimental.entrypoint` ([#55047]). Not all\n   code is expected to work with this option, and since it is experimental you may encounter problems.\n * Redefinition of constants is now well defined and follows world age semantics ([#57253]). Additional redefinitions\n-  (e.g. of types) are now allowed. See [the new manual chapter on world age](https://docs.julialang.org/en/v1.13-dev/manual/worldage/).\n+  (e.g. of types) are now allowed. See [the new manual chapter on world age](https://docs.julialang.org/en/v1/manual/worldage/).\n * A new keyword argument `usings::Bool` has been added to `names`, returning all names visible\n   via `using` ([#54609]).\n * The `@atomic` macro family now supports reference assignment syntax, e.g. `@atomic :monotonic v[3] += 4`,"
    },
    {
      "sha": "b4a991116bbcf129dd3be7f5372630fe6cfb7e5f",
      "filename": "Make.inc",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/Make.inc",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/Make.inc",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Make.inc?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -63,6 +63,10 @@ USE_SYSTEM_ZSTD:=0\n USE_SYSTEM_P7ZIP:=0\n USE_SYSTEM_LLD:=0\n \n+# Link libjulia-internal with static libgcc and libstdc++\n+USE_RT_STATIC_LIBGCC:=1\n+USE_RT_STATIC_LIBSTDCXX:=1\n+\n # Link to the LLVM shared library\n USE_LLVM_SHLIB := 1\n \n@@ -97,6 +101,9 @@ WITH_TRACY_CALLSTACKS := 0\n # Enable Timing Counts support\n WITH_TIMING_COUNTS := 0\n \n+# Should --gc-sections/-dead_strip be used to remove unreferenced code?\n+USE_LINKER_GC:=1\n+\n # Prevent picking up $ARCH from the environment variables\n ARCH:=\n \n@@ -932,6 +939,23 @@ JCXXFLAGS += -DUSE_NVTX\n JCFLAGS += -DUSE_NVTX\n endif\n \n+ifneq ($(findstring $(OS),WINNT FreeBSD OpenBSD),)\n+  USE_LINKER_GC := 0\n+  USE_RT_STATIC_LIBGCC := 0\n+  USE_RT_STATIC_LIBSTDCXX := 0\n+endif\n+\n+# Linker garbage collection\n+ifeq ($(USE_LINKER_GC), 1)\n+ifeq ($(OS), Darwin)\n+  JLDFLAGS += -Wl,-dead_strip\n+else\n+  JLDFLAGS += -Wl,--gc-sections\n+  JCFLAGS += -ffunction-sections -fdata-sections\n+  JCXXFLAGS += -ffunction-sections -fdata-sections\n+endif\n+endif\n+\n # ===========================================================================\n \n # Select the cpu architecture to target, or automatically detects the user's compiler"
    },
    {
      "sha": "14daef62c7e21f6fd8fe6fd570247a827dafa4e5",
      "filename": "Makefile",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/Makefile",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/Makefile",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Makefile?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -252,7 +252,7 @@ JL_PRIVATE_LIBS-$(USE_SYSTEM_ZLIB) += zlib\n else\n JL_PRIVATE_LIBS-$(USE_SYSTEM_ZLIB) += libz\n endif\n-JL_PRIVATE_LIBS-$(USE_SYSTEM_ZLIB) += libzstd\n+JL_PRIVATE_LIBS-$(USE_SYSTEM_ZSTD) += libzstd\n JL_PRIVATE_EXES += zstd$(EXE) zstdmt$(EXE)\n ifeq ($(USE_LLVM_SHLIB),1)\n JL_PRIVATE_LIBS-$(USE_SYSTEM_LLVM) += libLLVM $(LLVM_SHARED_LIB_NAME)"
    },
    {
      "sha": "7e3e5c604c13890df513e69e7858e88ac1e0f4b4",
      "filename": "THIRDPARTY.md",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/THIRDPARTY.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/THIRDPARTY.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/THIRDPARTY.md?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -4,6 +4,7 @@ and some utilities (most of the rest of the files in this repository). See below\n for exceptions.\n \n - [crc32c.c](https://stackoverflow.com/questions/17645167/implementing-sse-4-2s-crc32c-in-software) (CRC-32c checksum code by Mark Adler) [[ZLib](https://opensource.org/licenses/Zlib)].\n+- [dl-cache.h](https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html) (for reading ld-cache files on startup) [LGPL2.1+]\n - [LDC](https://github.com/ldc-developers/ldc/blob/master/LICENSE) (for ccall/cfunction ABI definitions) [BSD-3]. The portion of code that Julia uses from LDC is [BSD-3] licensed.\n - [LLVM](https://releases.llvm.org/3.9.0/LICENSE.TXT) (for parts of src/disasm.cpp) [UIUC]\n - [NetBSD](https://www.netbsd.org/about/redistribution.html) (for setjmp, longjmp, and strptime implementations on Windows) [BSD-3]"
    },
    {
      "sha": "4dcf385c496663a7f1b70f32e6236295bce5e16e",
      "filename": "base/array.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Farray.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Farray.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Farray.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -672,7 +672,7 @@ julia> collect(Float64, 1:2:5)\n collect(::Type{T}, itr) where {T} = _collect(T, itr, IteratorSize(itr))\n \n _collect(::Type{T}, itr, isz::Union{HasLength,HasShape}) where {T} =\n-    copyto!(_array_for(T, isz, _similar_shape(itr, isz)), itr)\n+    copyto!(_array_for_inner(T, isz, _similar_shape(itr, isz)), itr)\n function _collect(::Type{T}, itr, isz::SizeUnknown) where T\n     a = Vector{T}()\n     for x in itr\n@@ -696,12 +696,12 @@ _similar_for(c::AbstractArray, ::Type{T}, itr, ::HasShape, axs) where {T} =\n     similar(c, T, axs)\n \n # make a collection appropriate for collecting `itr::Generator`\n-_array_for(::Type{T}, ::SizeUnknown, ::Nothing) where {T} = Vector{T}(undef, 0)\n-_array_for(::Type{T}, ::HasLength, len::Integer) where {T} = Vector{T}(undef, Int(len))\n-_array_for(::Type{T}, ::HasShape{N}, axs) where {T,N} = similar(Array{T,N}, axs)\n+_array_for_inner(::Type{T}, ::SizeUnknown, ::Nothing) where {T} = Vector{T}(undef, 0)\n+_array_for_inner(::Type{T}, ::HasLength, len::Integer) where {T} = Vector{T}(undef, Int(len))\n+_array_for_inner(::Type{T}, ::HasShape{N}, axs) where {T,N} = similar(Array{T,N}, axs)\n \n # used by syntax lowering for simple typed comprehensions\n-_array_for(::Type{T}, itr, isz) where {T} = _array_for(T, isz, _similar_shape(itr, isz))\n+_array_for(::Type{T}, itr, isz) where {T} = _array_for_inner(T, isz, _similar_shape(itr, isz))\n \n \n \"\"\"\n@@ -827,10 +827,10 @@ function collect(itr::Generator)\n         shp = _similar_shape(itr, isz)\n         y = iterate(itr)\n         if y === nothing\n-            return _array_for(et, isz, shp)\n+            return _array_for_inner(et, isz, shp)\n         end\n         v1, st = y\n-        dest = _array_for(typeof(v1), isz, shp)\n+        dest = _array_for_inner(typeof(v1), isz, shp)\n         # The typeassert gives inference a helping hand on the element type and dimensionality\n         # (work-around for #28382)\n         et\u2032 = et <: Type ? Type : et"
    },
    {
      "sha": "04565411cabfbcf40e6bbb209f4f783f9c8d764e",
      "filename": "base/bitarray.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 18,
      "changes": 31,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Fbitarray.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Fbitarray.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fbitarray.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -146,16 +146,14 @@ function copy_chunks!(dest::Vector{UInt64}, pos_d::Int, src::Vector{UInt64}, pos\n     delta_ks = ks1 - ks0\n \n     u = _msk64\n+    msk_d0 = ~(u << ld0)\n+    msk_d1 = (u << (ld1+1))\n     if delta_kd == 0\n-        msk_d0 = ~(u << ld0) | (u << (ld1+1))\n-    else\n-        msk_d0 = ~(u << ld0)\n-        msk_d1 = (u << (ld1+1))\n+        msk_d0 |= msk_d1\n     end\n+    msk_s0 = (u << ls0)\n     if delta_ks == 0\n-        msk_s0 = (u << ls0) & ~(u << (ls1+1))\n-    else\n-        msk_s0 = (u << ls0)\n+        msk_s0 &= ~(u << (ls1+1))\n     end\n \n     chunk_s0 = glue_src_bitchunks(src, ks0, ks1, msk_s0, ls0)\n@@ -206,16 +204,14 @@ function copy_chunks_rtol!(chunks::Vector{UInt64}, pos_d::Int, pos_s::Int, numbi\n         delta_kd = kd1 - kd0\n         delta_ks = ks1 - ks0\n \n+        msk_d0 = ~(u << ld0)\n+        msk_d1 = (u << (ld1+1))\n         if delta_kd == 0\n-            msk_d0 = ~(u << ld0) | (u << (ld1+1))\n-        else\n-            msk_d0 = ~(u << ld0)\n-            msk_d1 = (u << (ld1+1))\n+            msk_d0 |= msk_d1\n         end\n+        msk_s0 = (u << ls0)\n         if delta_ks == 0\n-            msk_s0 = (u << ls0) & ~(u << (ls1+1))\n-        else\n-            msk_s0 = (u << ls0)\n+            msk_s0 &= ~(u << (ls1+1))\n         end\n \n         chunk_s0 = glue_src_bitchunks(chunks, ks0, ks1, msk_s0, ls0) & ~(u << s)\n@@ -241,11 +237,10 @@ function fill_chunks!(Bc::Array{UInt64}, x::Bool, pos::Int, numbits::Int)\n     k1, l1 = get_chunks_id(pos+numbits-1)\n \n     u = _msk64\n+    msk0 = (u << l0)\n+    msk1 = ~(u << (l1+1))\n     if k1 == k0\n-        msk0 = (u << l0) & ~(u << (l1+1))\n-    else\n-        msk0 = (u << l0)\n-        msk1 = ~(u << (l1+1))\n+        msk0 &= msk1\n     end\n     @inbounds if x\n         Bc[k0] |= msk0"
    },
    {
      "sha": "4b0b756a00ae17575b30b0bd5561145e6dd38a97",
      "filename": "base/file.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 8,
      "changes": 13,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Ffile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Ffile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Ffile.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -1059,7 +1059,7 @@ struct DirEntry\n end\n function Base.getproperty(obj::DirEntry, p::Symbol)\n     if p === :path\n-        return joinpath(obj.dir, obj.name)\n+        return joinpath(getfield(obj, :dir), getfield(obj, :name))\n     else\n         return getfield(obj, p)\n     end\n@@ -1267,22 +1267,19 @@ function rename(oldpath::AbstractString, newpath::AbstractString)\n end\n \n function sendfile(src::AbstractString, dst::AbstractString)\n-    src_open = false\n-    dst_open = false\n-    local src_file, dst_file\n+    src_file = nothing\n+    dst_file = nothing\n     try\n         src_file = open(src, JL_O_RDONLY)\n-        src_open = true\n         dst_file = open(dst, JL_O_CREAT | JL_O_TRUNC | JL_O_WRONLY, filemode(src_file))\n-        dst_open = true\n \n         bytes = filesize(stat(src_file))\n         sendfile(dst_file, src_file, Int64(0), Int(bytes))\n     finally\n-        if src_open && isopen(src_file)\n+        if src_file !== nothing && isopen(src_file)\n             close(src_file)\n         end\n-        if dst_open && isopen(dst_file)\n+        if dst_file !== nothing && isopen(dst_file)\n             close(dst_file)\n         end\n     end"
    },
    {
      "sha": "2227e80bb1b9abc6f1642ecd26f702cbbe60d354",
      "filename": "base/libdl.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Flibdl.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Flibdl.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Flibdl.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -506,6 +506,9 @@ function dlopen(ll::LazyLibrary, flags::Integer = ll.flags; kwargs...)\n                 if ll.on_load_callback !== nothing\n                     ll.on_load_callback()\n                 end\n+            else\n+                # Another thread loaded the library while we were waiting\n+                handle = @atomic :acquire ll.handle\n             end\n         end\n     else"
    },
    {
      "sha": "7e68ef87941f83df4e3274915b79cbb95bb3ce74",
      "filename": "base/lock.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Flock.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Flock.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Flock.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -366,7 +366,7 @@ This is similar to using [`lock`](@ref) with a `do` block, but avoids creating a\n and thus can improve the performance.\n \n !!! compat\n-    `@lock` was added in Julia 1.3, and exported in Julia 1.10.\n+    `@lock` was added in Julia 1.3, and exported in Julia 1.7.\n \"\"\"\n macro lock(l, expr)\n     quote"
    },
    {
      "sha": "3f6eec33d170b6500daeb13a2f9dd78e744b05f3",
      "filename": "base/locks-mt.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Flocks-mt.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Flocks-mt.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Flocks-mt.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -85,9 +85,9 @@ function lock(l::AbstractSpinLock)\n end\n \n function trylock(l::AbstractSpinLock)\n-    if l.owned == 0\n+    if l.owned::Int == 0\n         GC.disable_finalizers()\n-        p = @atomicswap :acquire l.owned = 1\n+        p = (@atomicswap :acquire l.owned = 1)::Int\n         if p == 0\n             return true\n         end\n@@ -97,7 +97,7 @@ function trylock(l::AbstractSpinLock)\n end\n \n function unlock(l::AbstractSpinLock)\n-    if (@atomicswap :release l.owned = 0) == 0\n+    if (@atomicswap :release l.owned = 0)::Int == 0\n         error(\"unlock count must match lock count\")\n     end\n     GC.enable_finalizers()\n@@ -106,5 +106,5 @@ function unlock(l::AbstractSpinLock)\n end\n \n function islocked(l::AbstractSpinLock)\n-    return (@atomic :monotonic l.owned) != 0\n+    return (@atomic :monotonic l.owned)::Int != 0\n end"
    },
    {
      "sha": "4a1c23a19925039b022ab0085b0c727bc3843a27",
      "filename": "base/logging/logging.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Flogging%2Flogging.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Flogging%2Flogging.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Flogging%2Flogging.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -129,6 +129,8 @@ end\n LogLevel(level::LogLevel) = level\n \n isless(a::LogLevel, b::LogLevel) = isless(a.level, b.level)\n+isless(a::LogLevel, b::Integer) = isless(a.level, b)\n+isless(a::Integer, b::LogLevel) = isless(a, b.level)\n +(level::LogLevel, inc::Integer) = LogLevel(level.level+inc)\n -(level::LogLevel, inc::Integer) = LogLevel(level.level-inc)\n convert(::Type{LogLevel}, level::Integer) = LogLevel(level)"
    },
    {
      "sha": "141a7615b599b97748b4084aedb90cba54e83bf1",
      "filename": "base/process.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Fprocess.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Fprocess.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fprocess.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -140,15 +140,14 @@ end\n         if err == 0\n             pp = Process(cmd, handle, syncd)\n             associate_julia_struct(handle, pp)\n+            iolock_end()\n+            return pp\n         else\n             ccall(:jl_forceclose_uv, Cvoid, (Ptr{Cvoid},), handle) # will call free on handle eventually\n+            iolock_end()\n+            throw(_UVError(\"could not spawn \" * repr(cmd), err))\n         end\n-        iolock_end()\n     end\n-    if err != 0\n-        throw(_UVError(\"could not spawn \" * repr(cmd), err))\n-    end\n-    return pp\n end\n \n _spawn(cmds::AbstractCmd) = _spawn(cmds, SpawnIOs())"
    },
    {
      "sha": "3f12d5ea4bd3f2b70b9e07b18f46165376cbbd3e",
      "filename": "base/sysinfo.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 12,
      "changes": 17,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Fsysinfo.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Fsysinfo.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fsysinfo.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -128,8 +128,6 @@ const WORD_SIZE = Core.sizeof(Int) * 8\n \n The number of system \"clock ticks\" per second, corresponding to `sysconf(_SC_CLK_TCK)` on\n POSIX systems, or `0` if it is unknown.\n-\n-CPU times, e.g. as returned by `Sys.cpu_info()`, are in units of ticks, i.e. units of `1 / Sys.SC_CLK_TCK` seconds if `Sys.SC_CLK_TCK > 0`.\n \"\"\"\n global SC_CLK_TCK::Clong\n \n@@ -224,8 +222,7 @@ The `CPUinfo` type is a mutable struct with the following fields:\n - `cpu_times!idle::UInt64`: Time spent in idle mode. CPU state shows the CPU time that's not actively being used.\n - `cpu_times!irq::UInt64`: Time spent handling interrupts. CPU state shows the amount of time the CPU has been servicing hardware interrupts.\n \n-The times are in units of `1/Sys.SC_CLK_TCK` seconds if `Sys.SC_CLK_TCK > 0`; otherwise they are in\n-unknown units.\n+The times are in units of milliseconds.\n \n Note: Included in the detailed system information via `versioninfo(verbose=true)`.\n \"\"\"\n@@ -246,24 +243,20 @@ CPUinfo(info::UV_cpu_info_t) = CPUinfo(unsafe_string(info.model), info.speed,\n public CPUinfo\n \n function _show_cpuinfo(io::IO, info::Sys.CPUinfo, header::Bool=true, prefix::AbstractString=\"    \")\n-    tck = SC_CLK_TCK\n     if header\n         println(io, info.model, \": \")\n         print(io, \" \"^length(prefix))\n         println(io, \"    \", lpad(\"speed\", 5), \"    \", lpad(\"user\", 9), \"    \", lpad(\"nice\", 9), \"    \",\n                 lpad(\"sys\", 9), \"    \", lpad(\"idle\", 9), \"    \", lpad(\"irq\", 9))\n     end\n     print(io, prefix)\n-    unit = tck > 0 ? \" s  \" : \"    \"\n-    tc = max(tck, 1)\n+    ms_per_s = 1000\n+    unit = \" s  \"\n     d(i, unit=unit) = lpad(string(round(Int64,i)), 9) * unit\n     print(io,\n           lpad(string(info.speed), 5), \" MHz  \",\n-          d(info.cpu_times!user / tc), d(info.cpu_times!nice / tc), d(info.cpu_times!sys / tc),\n-          d(info.cpu_times!idle / tc), d(info.cpu_times!irq / tc, tck > 0 ? \" s\" : \"  \"))\n-    if tck <= 0\n-        print(io, \"ticks\")\n-    end\n+          d(info.cpu_times!user / ms_per_s), d(info.cpu_times!nice / ms_per_s), d(info.cpu_times!sys / ms_per_s),\n+          d(info.cpu_times!idle / ms_per_s), d(info.cpu_times!irq / ms_per_s))\n end\n \n show(io::IO, ::MIME\"text/plain\", info::CPUinfo) = _show_cpuinfo(io, info, true, \"    \")"
    },
    {
      "sha": "22e4b5a0065bc72259e36cf4f3a60e2838e5f345",
      "filename": "base/timing.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Ftiming.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Ftiming.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Ftiming.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -113,7 +113,7 @@ end\n @static if Base.USING_STOCK_GC\n # must be kept in sync with `src/gc-stock.h``\n const FULL_SWEEP_REASONS = [:FULL_SWEEP_REASON_SWEEP_ALWAYS_FULL, :FULL_SWEEP_REASON_FORCED_FULL_SWEEP,\n-                            :FULL_SWEEP_REASON_USER_MAX_EXCEEDED, :FULL_SWEEP_REASON_LARGE_PROMOTION_RATE]\n+                            :FULL_SWEEP_REASON_USER_MAX_EXCEEDED, :FULL_SWEEP_REASON_LARGE_PROMOTION_RATE, :FULL_SWEEP_REASON_LARGE_HEAP_GROWTH]\n end\n \n \"\"\"\n@@ -498,6 +498,14 @@ function is_simply_call(@nospecialize ex)\n         Meta.isexpr(a, :..., 1) && is_simple_atom(a.args[1]) && continue\n         return false\n     end\n+    # Ensure Expr(:call, .+, ...) get wrapped\n+    if ex.args[1] isa Symbol\n+        sa = String(ex.args[1]::Symbol)\n+        startswith(sa, \".\") &&\n+            !endswith(sa, \".\") &&\n+            isoperator(Symbol(sa[2:end])) &&\n+            return false\n+    end\n     return true\n end\n "
    },
    {
      "sha": "5819ab44c6f81d12e9976e323cfbdf6d082b1ec8",
      "filename": "base/toml_parser.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Ftoml_parser.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/base%2Ftoml_parser.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Ftoml_parser.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -716,8 +716,8 @@ function parse_array(l::Parser{Dates})::Err{Vector} where Dates\n         copyto_typed!(new, array)\n     elseif T === Union{}\n         new = Any[]\n-    elseif (T === TOMLDict) || (T == BigInt) || (T === UInt128) || (T === Int128) || (T <: Vector) ||\n-        (T === Dates.Date) || (T === Dates.Time) || (T === Dates.DateTime)\n+    elseif (T === TOMLDict) || (T === BigInt) || (T === UInt128) || (T === Int128) || (T <: Vector) ||\n+        (Dates !== nothing && ((T === Dates.Date) || (T === Dates.Time) || (T === Dates.DateTime)))\n         # do nothing, leave as Vector{Any}\n         new = array\n     else @assert false end"
    },
    {
      "sha": "4602f759a476858ed3996ccfff81311e2069dae1",
      "filename": "cli/Makefile",
      "status": "modified",
      "additions": 16,
      "deletions": 3,
      "changes": 19,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2FMakefile",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2FMakefile",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2FMakefile?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -5,7 +5,7 @@ include $(JULIAHOME)/Make.inc\n include $(JULIAHOME)/deps/llvm-ver.make\n \n \n-HEADERS := $(addprefix $(SRCDIR)/,jl_exports.h loader.h) $(addprefix $(JULIAHOME)/src/,julia_fasttls.h support/platform.h support/dirpath.h jl_exported_data.inc jl_exported_funcs.inc)\n+HEADERS := $(addprefix $(SRCDIR)/,jl_exports.h loader.h dl-cache.h) $(addprefix $(JULIAHOME)/src/,julia_fasttls.h support/platform.h support/dirpath.h jl_exported_data.inc jl_exported_funcs.inc)\n \n LOADER_CFLAGS = $(JCFLAGS) -I$(BUILDROOT)/src -I$(JULIAHOME)/src -I$(JULIAHOME)/src/support -I$(build_includedir) -ffreestanding\n LOADER_LDFLAGS = $(JLDFLAGS) -ffreestanding -L$(build_shlibdir) -L$(build_libdir)\n@@ -39,10 +39,15 @@ $(BUILDDIR)/loader_lib.o: export MSYS2_ARG_CONV_EXCL = -DDEP_LIBS=\n $(BUILDDIR)/loader_lib.dbg.obj: export MSYS2_ARG_CONV_EXCL = -DDEP_LIBS=\n endif # MSYS2\n \n+ifeq ($(USE_RT_STATIC_LIBSTDCXX),1)\n+SHIPFLAGS += -DRT_STATIC_LIBSTDCXX\n+DEBUGFLAGS += -DRT_STATIC_LIBSTDCXX\n+endif # USE_RT_STATIC_LIBSTDCXX\n+\n EXE_OBJS := $(BUILDDIR)/loader_exe.o\n EXE_DOBJS := $(BUILDDIR)/loader_exe.dbg.obj\n-LIB_OBJS := $(BUILDDIR)/loader_lib.o\n-LIB_DOBJS := $(BUILDDIR)/loader_lib.dbg.obj\n+LIB_OBJS := $(BUILDDIR)/loader_lib.o $(BUILDDIR)/loader_symbol_probe.o $(BUILDDIR)/loader_library_probe.o\n+LIB_DOBJS := $(BUILDDIR)/loader_lib.dbg.obj $(BUILDDIR)/loader_symbol_probe.dbg.obj $(BUILDDIR)/loader_library_probe.dbg.obj\n \n # If this is an architecture that supports dynamic linking, link in a trampoline definition\n ifneq (,$(wildcard $(SRCDIR)/trampolines/trampolines_$(ARCH).S))\n@@ -66,6 +71,14 @@ $(BUILDDIR)/loader_trampolines.o : $(SRCDIR)/trampolines/trampolines_$(ARCH).S $\n \t@$(call PRINT_CC, $(CC) $(SHIPFLAGS) $(LOADER_CFLAGS) $< -c -o $@)\n $(BUILDDIR)/loader_trampolines.dbg.obj : $(SRCDIR)/trampolines/trampolines_$(ARCH).S $(HEADERS) $(SRCDIR)/trampolines/common.h\n \t@$(call PRINT_CC, $(CC) $(DEBUGFLAGS) $(LOADER_CFLAGS) $< -c -o $@)\n+$(BUILDDIR)/loader_library_probe.o : $(SRCDIR)/loader_library_probe.c $(HEADERS) $(JULIAHOME)/VERSION\n+\t@$(call PRINT_CC, $(CC) -DJL_LIBRARY_EXPORTS $(SHIPFLAGS) $(LOADER_CFLAGS) -c $< -o $@)\n+$(BUILDDIR)/loader_library_probe.dbg.obj : $(SRCDIR)/loader_library_probe.c $(HEADERS) $(JULIAHOME)/VERSION\n+\t@$(call PRINT_CC, $(CC) -DJL_LIBRARY_EXPORTS $(DEBUGFLAGS) $(LOADER_CFLAGS) -c $< -o $@)\n+$(BUILDDIR)/loader_symbol_probe.o : $(SRCDIR)/loader_symbol_probe.c $(HEADERS) $(JULIAHOME)/VERSION\n+\t@$(call PRINT_CC, $(CC) -DJL_LIBRARY_EXPORTS $(SHIPFLAGS) $(LOADER_CFLAGS) -c $< -o $@)\n+$(BUILDDIR)/loader_symbol_probe.dbg.obj : $(SRCDIR)/loader_symbol_probe.c $(HEADERS) $(JULIAHOME)/VERSION\n+\t@$(call PRINT_CC, $(CC) -DJL_LIBRARY_EXPORTS $(DEBUGFLAGS) $(LOADER_CFLAGS) -c $< -o $@)\n \n # Debugging target to help us see what kind of code is being generated for our trampolines\n dump-trampolines: $(SRCDIR)/trampolines/trampolines_$(ARCH).S"
    },
    {
      "sha": "eddaad088e979b92c1511a7f34247f04b26bc2f3",
      "filename": "cli/dl-cache.h",
      "status": "added",
      "additions": 184,
      "deletions": 0,
      "changes": 184,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2Fdl-cache.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2Fdl-cache.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2Fdl-cache.h?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -0,0 +1,184 @@\n+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.\n+   Copyright (C) 1999-2019 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <stdint.h>\n+\n+#define FLAG_ANY                        -1\n+#define FLAG_TYPE_MASK                  0x00ff\n+#define FLAG_LIBC4                      0x0000\n+#define FLAG_ELF                        0x0001\n+#define FLAG_ELF_LIBC5                  0x0002\n+#define FLAG_ELF_LIBC6                  0x0003\n+#define FLAG_REQUIRED_MASK              0xff00\n+#define FLAG_SPARC_LIB64                0x0100\n+#define FLAG_IA64_LIB64                 0x0200\n+#define FLAG_X8664_LIB64                0x0300\n+#define FLAG_S390_LIB64                 0x0400\n+#define FLAG_POWERPC_LIB64              0x0500\n+#define FLAG_MIPS64_LIBN32              0x0600\n+#define FLAG_MIPS64_LIBN64              0x0700\n+#define FLAG_X8664_LIBX32               0x0800\n+#define FLAG_ARM_LIBHF                  0x0900\n+#define FLAG_AARCH64_LIB64              0x0a00\n+#define FLAG_ARM_LIBSF                  0x0b00\n+#define FLAG_MIPS_LIB32_NAN2008         0x0c00\n+#define FLAG_MIPS64_LIBN32_NAN2008      0x0d00\n+#define FLAG_MIPS64_LIBN64_NAN2008      0x0e00\n+#define FLAG_RISCV_FLOAT_ABI_SOFT       0x0f00\n+#define FLAG_RISCV_FLOAT_ABI_DOUBLE     0x1000\n+\n+#if defined(_CPU_X86_64_)\n+\n+#define _DL_CACHE_DEFAULT_ID    0x303\n+#define _dl_cache_check_flags(flags)    ((flags) == _DL_CACHE_DEFAULT_ID)\n+\n+#elif defined(_CPU_AARCH64_)\n+\n+#ifdef __LP64__\n+# define _DL_CACHE_DEFAULT_ID    (FLAG_AARCH64_LIB64 | FLAG_ELF_LIBC6)\n+#else\n+# define _DL_CACHE_DEFAULT_ID    (FLAG_AARCH64_LIB32 | FLAG_ELF_LIBC6)\n+#endif\n+\n+#define _dl_cache_check_flags(flags)    ((flags) == _DL_CACHE_DEFAULT_ID)\n+\n+#elif defined(_CPU_RISCV64_)\n+\n+/* For now we only support the natural XLEN ABI length on all targets, so the\n+   only bits that need to go into ld.so.cache are the flags for ABI length.  */\n+#if defined __riscv_float_abi_double\n+# define _DL_CACHE_DEFAULT_ID    (FLAG_RISCV_FLOAT_ABI_DOUBLE | FLAG_ELF_LIBC6)\n+#else\n+# define _DL_CACHE_DEFAULT_ID    (FLAG_RISCV_FLOAT_ABI_SOFT | FLAG_ELF_LIBC6)\n+#endif\n+\n+#define _dl_cache_check_flags(flags)    ((flags) == _DL_CACHE_DEFAULT_ID)\n+\n+#elif defined(_CPU_ARM_)\n+\n+/* In order to support the transition from unmarked objects\n+   to marked objects we must treat unmarked objects as\n+   compatible with either FLAG_ARM_LIBHF or FLAG_ARM_LIBSF.  */\n+#ifdef __ARM_PCS_VFP\n+# define _dl_cache_check_flags(flags) \\\n+  ((flags) == (FLAG_ARM_LIBHF | FLAG_ELF_LIBC6) \\\n+   || (flags) == FLAG_ELF_LIBC6)\n+#else\n+# define _dl_cache_check_flags(flags) \\\n+  ((flags) == (FLAG_ARM_LIBSF | FLAG_ELF_LIBC6) \\\n+   || (flags) == FLAG_ELF_LIBC6)\n+#endif\n+\n+#elif defined(_CPU_X86_)\n+\n+/* Defined as (FLAG_ELF_LIBC6 | FLAG_X8664_LIBX32).  */\n+#undef _DL_CACHE_DEFAULT_ID\n+#define _DL_CACHE_DEFAULT_ID    0x803\n+\n+#elif defined(_CPU_PPC64_)\n+\n+#define _DL_CACHE_DEFAULT_ID    0x503\n+\n+#define _dl_cache_check_flags(flags)                    \\\n+  ((flags) == _DL_CACHE_DEFAULT_ID)\n+\n+#else\n+\n+#error \"Missing CPU arch-specific definitions in dl-cache.h\"\n+\n+#endif\n+\n+#ifndef _DL_CACHE_DEFAULT_ID\n+# define _DL_CACHE_DEFAULT_ID   3\n+#endif\n+\n+#ifndef _dl_cache_check_flags\n+# define _dl_cache_check_flags(flags)                   \\\n+  ((flags) == 1 || (flags) == _DL_CACHE_DEFAULT_ID)\n+#endif\n+\n+#ifndef LD_SO_CACHE\n+# define LD_SO_CACHE SYSCONFDIR \"/ld.so.cache\"\n+#endif\n+\n+#define CACHEMAGIC \"ld.so-1.7.0\"\n+\n+/* libc5 and glibc 2.0/2.1 use the same format.  For glibc 2.2 another\n+   format has been added in a compatible way:\n+   The beginning of the string table is used for the new table:\n+        old_magic\n+        nlibs\n+        libs[0]\n+        ...\n+        libs[nlibs-1]\n+        pad, new magic needs to be aligned\n+             - this is string[0] for the old format\n+        new magic - this is string[0] for the new format\n+        newnlibs\n+        ...\n+        newlibs[0]\n+        ...\n+        newlibs[newnlibs-1]\n+        string 1\n+        string 2\n+        ...\n+*/\n+struct file_entry\n+{\n+  int flags;            /* This is 1 for an ELF library.  */\n+  unsigned int key, value; /* String table indices.  */\n+};\n+\n+struct cache_file\n+{\n+  char magic[sizeof CACHEMAGIC - 1];\n+  unsigned int nlibs;\n+  struct file_entry libs[0];\n+};\n+\n+#define CACHEMAGIC_NEW \"glibc-ld.so.cache\"\n+#define CACHE_VERSION \"1.1\"\n+#define CACHEMAGIC_VERSION_NEW CACHEMAGIC_NEW CACHE_VERSION\n+\n+\n+struct file_entry_new\n+{\n+  int32_t flags;                /* This is 1 for an ELF library.  */\n+  uint32_t key, value;          /* String table indices.  */\n+  uint32_t osversion;           /* Required OS version.  */\n+  uint64_t hwcap;               /* Hwcap entry.  */\n+};\n+\n+struct cache_file_new\n+{\n+  char magic[sizeof CACHEMAGIC_NEW - 1];\n+  char version[sizeof CACHE_VERSION - 1];\n+  uint32_t nlibs;               /* Number of entries.  */\n+  uint32_t len_strings;         /* Size of string table. */\n+  uint32_t unused[5];           /* Leave space for future extensions\n+                                   and align to 8 byte boundary.  */\n+  struct file_entry_new libs[0]; /* Entries describing libraries.  */\n+  /* After this the string table of size len_strings is found.  */\n+};\n+\n+/* Used to align cache_file_new.  */\n+#define ALIGN_CACHE(addr)                               \\\n+(((addr) + __alignof__ (struct cache_file_new) -1)      \\\n+ & (~(__alignof__ (struct cache_file_new) - 1)))\n+\n+// extern int _dl_cache_libcmp (const char *p1, const char *p2) attribute_hidden;"
    },
    {
      "sha": "62e4f3d3e4b52dba6c611fde8f3e799fac55d948",
      "filename": "cli/loader.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2Floader.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2Floader.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2Floader.h?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -70,7 +70,10 @@\n JL_DLLEXPORT extern int jl_load_repl(int, char **);\n JL_DLLEXPORT void jl_loader_print_stderr(const char * msg);\n void jl_loader_print_stderr3(const char * msg1, const char * msg2, const char * msg3);\n+void *jl_loader_open_via_mmap(const char *filepath, size_t *size);\n static void * lookup_symbol(const void * lib_handle, const char * symbol_name);\n+const char *jl_loader_probe_system_library(const char *libname, const char *symbol);\n+int jl_loader_locate_symbol(const char *library, const char *symbol);\n \n #ifdef _OS_WINDOWS_\n LPWSTR *CommandLineToArgv(LPWSTR lpCmdLine, int *pNumArgs);"
    },
    {
      "sha": "78c7d42d9ecc389d82b8d4880024aba6e05ec7d7",
      "filename": "cli/loader_lib.c",
      "status": "modified",
      "additions": 13,
      "deletions": 156,
      "changes": 169,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2Floader_lib.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2Floader_lib.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2Floader_lib.c?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -222,166 +222,17 @@ JL_DLLEXPORT const char * jl_get_libdir()\n #include <link.h>\n #include <sys/wait.h>\n \n-// write(), but handle errors and avoid EINTR\n-static void write_wrapper(int fd, const char *str, size_t len)\n-{\n-    size_t written_sofar = 0;\n-    while (len) {\n-        ssize_t bytes_written = write(fd, str + written_sofar, len);\n-        if (bytes_written == -1 && errno == EINTR) continue;\n-        if (bytes_written == -1 && errno != EINTR) {\n-            perror(\"(julia) child libstdcxxprobe write\");\n-            _exit(1);\n-        }\n-        len -= bytes_written;\n-        written_sofar += bytes_written;\n-    }\n-}\n-\n-// read(), but handle errors and avoid EINTR\n-static void read_wrapper(int fd, char **ret, size_t *ret_len)\n-{\n-    // Allocate an initial buffer\n-    size_t len = JL_PATH_MAX;\n-    char *buf = (char *)malloc(len + 1);\n-    if (!buf) {\n-        perror(\"(julia) malloc\");\n-        exit(1);\n-    }\n-\n-    // Read into it, reallocating as necessary\n-    size_t have_read = 0;\n-    while (1) {\n-        ssize_t n = read(fd, buf + have_read, len - have_read);\n-        if (n == 0) break;\n-        if (n == -1 && errno != EINTR) {\n-            perror(\"(julia) libstdcxxprobe read\");\n-            exit(1);\n-        }\n-        if (n == -1 && errno == EINTR) continue;\n-        have_read += n;\n-        if (have_read == len) {\n-            buf = (char *)realloc(buf, 1 + (len *= 2));\n-            if (!buf) {\n-                perror(\"(julia) realloc\");\n-                exit(1);\n-            }\n-        }\n-    }\n-\n-    *ret = buf;\n-    *ret_len = have_read;\n-}\n-\n // Return the path to the libstdcxx to load.\n // If the path is found, return it.\n // Otherwise, print the error and exit.\n // The path returned must be freed.\n-static char *libstdcxxprobe(void)\n+static const char *libstdcxxprobe(void)\n {\n-    // Create the pipe and child process.\n-    int fork_pipe[2];\n-    int ret = pipe(fork_pipe);\n-    if (ret == -1) {\n-        perror(\"(julia) Error during libstdcxxprobe: pipe\");\n-        exit(1);\n-    }\n-    pid_t pid = fork();\n-    if (pid == -1)  {\n-        perror(\"Error during libstdcxxprobe:\\nfork\");\n-        exit(1);\n-    }\n-    if (pid == (pid_t) 0) { // Child process.\n-        close(fork_pipe[0]);\n-\n-        // Open the first available libstdc++.so.\n-        // If it can't be found, report so by exiting zero.\n-        // The star is there to prevent the compiler from merging constants\n-        // with \"\\0*libstdc++.so.6\", which we string replace inside the .so during\n-        // make install.\n-        void *handle = dlopen(\"libstdc++.so.6\\0*\", RTLD_LAZY);\n-        if (!handle) {\n-            _exit(0);\n-        }\n-\n-        // See if the version is compatible\n-        char *dlerr = dlerror(); // clear out dlerror\n-        void *sym = dlsym(handle, GLIBCXX_LEAST_VERSION_SYMBOL);\n-        (void)sym;\n-        dlerr = dlerror();\n-        if (dlerr) {\n-            // We can't use the library that was found, so don't write anything.\n-            // The main process will see that nothing was written,\n-            // then exit the function and return null.\n-            _exit(0);\n-        }\n-\n-        // No error means the symbol was found, we can use this library.\n-        // Get the path to it, and write it to the parent process.\n-        struct link_map *lm;\n-        ret = dlinfo(handle, RTLD_DI_LINKMAP, &lm);\n-        if (ret == -1) {\n-            char *errbuf = dlerror();\n-            char *errdesc = (char*)\"Error during libstdcxxprobe in child process:\\ndlinfo: \";\n-            write_wrapper(STDERR_FILENO, errdesc, strlen(errdesc));\n-            write_wrapper(STDERR_FILENO, errbuf, strlen(errbuf));\n-            write_wrapper(STDERR_FILENO, \"\\n\", 1);\n-            _exit(1);\n-        }\n-        char *libpath = lm->l_name;\n-        write_wrapper(fork_pipe[1], libpath, strlen(libpath));\n-        _exit(0);\n-    }\n-    else { // Parent process.\n-        close(fork_pipe[1]);\n-\n-        // Read the absolute path to the lib from the child process.\n-        char *path;\n-        size_t pathlen;\n-        read_wrapper(fork_pipe[0], &path, &pathlen);\n-\n-        // Close the read end of the pipe\n-        close(fork_pipe[0]);\n-\n-        // Wait for the child to complete.\n-        while (1) {\n-            int wstatus;\n-            pid_t npid = waitpid(pid, &wstatus, 0);\n-            if (npid == -1) {\n-                if (errno == EINTR) continue;\n-                if (errno == ECHILD) {\n-                    // SIGCHLD is set to SIG_IGN or has flag SA_NOCLDWAIT, so the child\n-                    // did not become a zombie and wait for `waitpid` - it just exited.\n-                    //\n-                    // Assume that it exited successfully and use whatever libpath we\n-                    // got out of the pipe, if any.\n-                    break;\n-                }\n-                perror(\"Error during libstdcxxprobe in parent process:\\nwaitpid\");\n-                exit(1);\n-            }\n-            else if (!WIFEXITED(wstatus)) {\n-                const char *err_str = \"Error during libstdcxxprobe in parent process:\\n\"\n-                                      \"The child process did not exit normally.\\n\";\n-                size_t err_strlen = strlen(err_str);\n-                write_wrapper(STDERR_FILENO, err_str, err_strlen);\n-                exit(1);\n-            }\n-            else if (WEXITSTATUS(wstatus)) {\n-                // The child has printed an error and exited, so the parent should exit too.\n-                exit(1);\n-            }\n-            break;\n-        }\n+    void *handle = dlopen(\"libstdc++.so.6\\0*\", RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD);\n+    if (handle != NULL)\n+        return NULL; // libstdc++ already loaded - nothing we can do\n \n-        if (!pathlen) {\n-            free(path);\n-            return NULL;\n-        }\n-        // Ensure that `path` is zero-terminated.\n-        path[pathlen] = '\\0';\n-        return path;\n-    }\n+    return jl_loader_probe_system_library(\"libstdc++.so.6\", GLIBCXX_LEAST_VERSION_SYMBOL);\n }\n #endif\n \n@@ -480,7 +331,7 @@ __attribute__((constructor)) void jl_load_libjulia_internal(void) {\n                         do_probe = 0;\n                 }\n                 if (do_probe) {\n-                    char *cxxpath = libstdcxxprobe();\n+                    const char *cxxpath = libstdcxxprobe();\n                     if (cxxpath) {\n                         void *cxx_handle = dlopen(cxxpath, RTLD_LAZY);\n                         (void)cxx_handle;\n@@ -490,14 +341,20 @@ __attribute__((constructor)) void jl_load_libjulia_internal(void) {\n                             jl_loader_print_stderr3(\"Message: \", dlr, \"\\n\");\n                             exit(1);\n                         }\n-                        free(cxxpath);\n+                        free((void *)cxxpath);\n                         probe_successful = 1;\n                     }\n                 }\n                 // If the probe rejected the system libstdc++ (or didn't find one!)\n                 // just load our bundled libstdc++ as identified by curr_dep;\n                 if (!probe_successful) {\n+# ifdef RT_STATIC_LIBSTDCXX\n+                    // If we have a statically-linked libstdc++, it is ok for\n+                    // this to fail.\n+                    load_library(curr_dep, lib_dir, 0);\n+# else\n                     load_library(curr_dep, lib_dir, 1);\n+# endif\n                 }\n #endif\n             } else if (special_idx == 1) {"
    },
    {
      "sha": "e9b88b1c3ffb69f6bf6432d7e969a34e5db462f5",
      "filename": "cli/loader_library_probe.c",
      "status": "added",
      "additions": 216,
      "deletions": 0,
      "changes": 216,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2Floader_library_probe.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2Floader_library_probe.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2Floader_library_probe.c?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -0,0 +1,216 @@\n+#include \"../src/support/platform.h\"\n+#include \"loader.h\"\n+\n+#ifdef _OS_LINUX_\n+\n+#include <stdio.h>\n+#include <assert.h>\n+\n+#include <stddef.h>\n+#include <fcntl.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <sys/stat.h>\n+#include <sys/mman.h>\n+#include <linux/limits.h>\n+\n+#include \"dl-cache.h\"\n+\n+void *jl_loader_open_via_mmap(const char *filepath, size_t *size)\n+{\n+    int fd;\n+    while (1) {\n+        fd = open(filepath, O_CLOEXEC | O_RDONLY);\n+        if (fd >= 0) {\n+            break;\n+        } else if (errno != EINTR) {\n+            return NULL;\n+        }\n+    }\n+\n+    struct stat info;\n+    while (1) {\n+        int err = fstat(fd, &info);\n+        if (err >= 0) {\n+            break;\n+        } else if (errno != EINTR) {\n+            close(fd);\n+            return NULL;\n+        }\n+    }\n+\n+    void *buffer = mmap(\n+        NULL, info.st_size, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, fd, /* offset */ 0\n+    );\n+    close(fd);\n+\n+    if (MAP_FAILED == buffer)\n+        return NULL;\n+\n+    *size = info.st_size;\n+    return buffer;\n+}\n+\n+static const char *search_ldcache_new(struct cache_file_new *cache, const char *libname, size_t *index)\n+{\n+    if (strncmp(cache->magic, CACHEMAGIC_NEW, sizeof(CACHEMAGIC_NEW) - 1) != 0)\n+        return NULL;\n+\n+    for (; *index < cache->nlibs; (*index)++) {\n+        struct file_entry_new *lib = &cache->libs[*index];\n+\n+        const char *strtab = (const char *)cache;\n+        const char *key = &strtab[lib->key];\n+        const char *value = &strtab[lib->value];\n+\n+        if (!_dl_cache_check_flags(lib->flags))\n+            continue;\n+        if (strcmp(key, libname) != 0)\n+            continue;\n+        (*index)++;\n+        return value;\n+    }\n+\n+    return NULL;\n+}\n+\n+static const char *search_ldcache(struct cache_file *cache, size_t cachesize, const char *libname, size_t *index)\n+{\n+    if (strncmp(cache->magic, CACHEMAGIC, sizeof(CACHEMAGIC) - 1) != 0)\n+        return search_ldcache_new((struct cache_file_new *)cache, libname, index);\n+\n+    // check for an embedded / hybrid 'new'-style cache\n+    size_t offset = ALIGN_CACHE(sizeof(struct cache_file) + cache->nlibs * sizeof(struct file_entry));\n+    if (cachesize >= offset + sizeof(struct cache_file_new)) {\n+        struct cache_file_new *new_cache = (struct cache_file_new *)((void *)cache + offset);\n+        if (strncmp(new_cache->magic, CACHEMAGIC_NEW, sizeof(CACHEMAGIC_NEW) - 1) == 0)\n+            return search_ldcache_new(new_cache, libname, index);\n+    }\n+\n+    for (; *index < cache->nlibs; (*index)++) {\n+        struct file_entry *lib = &cache->libs[*index];\n+\n+        const char *strtab = (const char *)&cache->libs[cache->nlibs];\n+        const char *key = &strtab[lib->key];\n+        const char *value = &strtab[lib->value];\n+\n+        if (!_dl_cache_check_flags(lib->flags))\n+            continue;\n+        if (strcmp(key, libname) != 0)\n+            continue;\n+        (*index)++;\n+        return value;\n+    }\n+\n+    return NULL;\n+}\n+\n+const char *ldcache_dirs[] = {\n+    \"/etc/ld.so.cache\",\n+};\n+\n+const char *default_libdirs[] = {\n+    \"/lib/\",\n+    \"/usr/lib/\",\n+#ifdef _P64\n+    \"/lib64/\",\n+    \"/usr/lib64/\",\n+#endif\n+};\n+\n+/**\n+ * Search for a system library with the filename `libname` containing `symbol`.\n+ * Return NULL if no matching library could be found.\n+ *\n+ * To emulate the Linux dynamic linker search behavior, this function scans for\n+ * system libraries in:\n+ *   1. LD_LIBRARY_PATH\n+ *   2. `/etc/ld.so.cache`\n+ *   3. \"default\" system libdirs (/lib, /usr/lib, etc.)\n+ *\n+ * This function does not consider any DT_RPATH or DT_RUNPATH entries.\n+ * (see `ld.so(8)` manpage)\n+ **/\n+const char *jl_loader_probe_system_library(const char *libname, const char *symbol)\n+{\n+    char buf[PATH_MAX];\n+\n+    // Make a best-effort attempt to emulate the linker's use of LD_LIBRARY_PATH\n+    char *LD_LIBRARY_PATH = getenv(\"LD_LIBRARY_PATH\");\n+    if (LD_LIBRARY_PATH != NULL) {\n+        LD_LIBRARY_PATH = strdup(LD_LIBRARY_PATH);\n+        char *path = LD_LIBRARY_PATH;\n+\n+        int last = 0;\n+        while (!last) {\n+            // walk to next ':' or '\\0'\n+            char *ch = path;\n+            while (1) {\n+                if (*ch == '\\0')\n+                    last = 1;\n+                if (*ch == ':' || *ch == '\\0')\n+                    break;\n+                ch += 1;\n+            }\n+            *ch = '\\0';\n+\n+            if (ch == path) {\n+                path += 1;\n+                continue;\n+            }\n+\n+            int bytes = snprintf(buf, sizeof(buf), (ch[-1] == '/' ? \"%s%s\" : \"%s/%s\"), path, libname);\n+            path = ch + 1;\n+            if (bytes < 0 || sizeof(buf) < (size_t) bytes)\n+                continue;\n+\n+            if (jl_loader_locate_symbol(buf, symbol)) {\n+                free(LD_LIBRARY_PATH);\n+                return strdup(buf);\n+            }\n+        }\n+        free(LD_LIBRARY_PATH);\n+    }\n+\n+    // Check the ld.so.cache for the library. Assuming we can find the cache,\n+    // this is by far our best chance to locate the lib successfully.\n+    size_t npaths = sizeof(ldcache_dirs) / sizeof(const char *);\n+    for (size_t i = 0; i < npaths; i++) {\n+        size_t sz;\n+        struct cache_file *cache =\n+            (struct cache_file *)jl_loader_open_via_mmap(ldcache_dirs[i], &sz);\n+\n+        if (cache == NULL)\n+            continue; // ld.so.cache was not found (could be NixOS)\n+\n+        size_t iter = 0;\n+        const char *library;\n+        while ((library = search_ldcache(cache, sz, libname, &iter)) != NULL) {\n+            if (jl_loader_locate_symbol(library, symbol)) {\n+                library = strdup(library);\n+                munmap((void *)cache, sz);\n+                return library;\n+            }\n+        }\n+\n+        munmap((void *)cache, sz);\n+    }\n+\n+    // As a last-ditch effort, try to emulate / search the \"default\" libdirs used\n+    // by the GLIBC dynamic linker.\n+    size_t ndirs = sizeof(default_libdirs) / sizeof(const char *);\n+    for (size_t i = 0; i < ndirs; i++) {\n+        int bytes = snprintf(buf, sizeof(buf), \"%s%s\", default_libdirs[i], libname);\n+        if (bytes < 0 || sizeof(buf) < (size_t) bytes)\n+            continue;\n+        if (jl_loader_locate_symbol(buf, symbol))\n+            return strdup(buf);\n+    }\n+\n+    return NULL;\n+}\n+\n+#endif"
    },
    {
      "sha": "de4598eb6a89e2e2f3dd4ef2df842f6ac0664ace",
      "filename": "cli/loader_symbol_probe.c",
      "status": "added",
      "additions": 123,
      "deletions": 0,
      "changes": 123,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2Floader_symbol_probe.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/cli%2Floader_symbol_probe.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/cli%2Floader_symbol_probe.c?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -0,0 +1,123 @@\n+#include \"../src/support/platform.h\"\n+#include \"loader.h\"\n+\n+#ifdef _OS_LINUX_\n+\n+#include <stdio.h>\n+\n+#include <assert.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string.h>\n+#include <sys/mman.h>\n+#include <linux/elf.h>\n+\n+static Elf64_Shdr *Elf64_get_section(Elf64_Ehdr *hdr, size_t i)\n+{\n+    size_t section_header_sz = hdr->e_shentsize;\n+    size_t byte_offset = hdr->e_shoff + i * section_header_sz;\n+    return (Elf64_Shdr *)&((char *)hdr)[byte_offset];\n+}\n+\n+static const char *Elf64_get_strtab(Elf64_Ehdr *hdr, Elf64_Shdr *section)\n+{\n+    return &((const char *)hdr)[section->sh_offset];\n+}\n+\n+static Elf64_Sym *Elf64_get_symbol(Elf64_Ehdr *hdr, Elf64_Shdr *section, size_t i)\n+{\n+    size_t byte_offset = section->sh_offset + i * section->sh_entsize;\n+    return (Elf64_Sym *)&((char *)hdr)[byte_offset];\n+}\n+\n+static int Elf64_locate_symbol(Elf64_Ehdr *hdr, const char *symbol)\n+{\n+    if (hdr->e_type != ET_DYN)\n+        return 0;\n+\n+    for (size_t sect_idx = 0; sect_idx < hdr->e_shnum; sect_idx++) {\n+        Elf64_Shdr *shdr = Elf64_get_section(hdr, sect_idx);\n+        if (shdr->sh_type != SHT_DYNSYM)\n+            continue;\n+\n+        Elf64_Shdr *strtab_shdr = Elf64_get_section(hdr, shdr->sh_link);\n+        const char *strtab = Elf64_get_strtab(hdr, strtab_shdr);\n+\n+        size_t nsymbols = shdr->sh_size / shdr->sh_entsize;\n+        for (size_t i = 0; i < nsymbols; i++) {\n+            Elf64_Sym *sym = Elf64_get_symbol(hdr, shdr, i);\n+            const char *name = &strtab[sym->st_name];\n+            if (strcmp(name, symbol) == 0)\n+                return 1;\n+        }\n+    }\n+    return 0;\n+}\n+\n+static Elf32_Shdr *Elf32_get_section(Elf32_Ehdr *hdr, size_t i)\n+{\n+    size_t section_header_sz = hdr->e_shentsize;\n+    size_t byte_offset = hdr->e_shoff + i * section_header_sz;\n+    return (Elf32_Shdr *)&((char *)hdr)[byte_offset];\n+}\n+\n+static const char *Elf32_get_strtab(Elf32_Ehdr *hdr, Elf32_Shdr *section)\n+{\n+    return &((const char *)hdr)[section->sh_offset];\n+}\n+\n+static Elf32_Sym *Elf32_get_symbol(Elf32_Ehdr *hdr, Elf32_Shdr *section, size_t i)\n+{\n+    size_t byte_offset = section->sh_offset + i * section->sh_entsize;\n+    return (Elf32_Sym *)&((char *)hdr)[byte_offset];\n+}\n+\n+static int Elf32_locate_symbol(Elf32_Ehdr *hdr, const char *symbol)\n+{\n+    if (hdr->e_type != ET_DYN)\n+        return 0;\n+\n+    for (size_t sect_idx = 0; sect_idx < hdr->e_shnum; sect_idx++) {\n+        Elf32_Shdr *shdr = Elf32_get_section(hdr, sect_idx);\n+        if (shdr->sh_type != SHT_DYNSYM)\n+            continue;\n+\n+        Elf32_Shdr *strtab_shdr = Elf32_get_section(hdr, shdr->sh_link);\n+        const char *strtab = Elf32_get_strtab(hdr, strtab_shdr);\n+\n+        size_t nsymbols = shdr->sh_size / shdr->sh_entsize;\n+        for (size_t i = 0; i < nsymbols; i++) {\n+            Elf32_Sym *sym = Elf32_get_symbol(hdr, shdr, i);\n+            const char *name = &strtab[sym->st_name];\n+            if (strcmp(name, symbol) == 0)\n+                return 1;\n+        }\n+    }\n+    return 0;\n+}\n+\n+int jl_loader_locate_symbol(const char *library, const char *symbol)\n+{\n+    size_t library_sz;\n+    void *elf_file = jl_loader_open_via_mmap(library, &library_sz);\n+    if (elf_file == NULL)\n+        return 0;\n+\n+    int found = 0;\n+    const char *hdr = (const char *)elf_file;\n+    if (strncmp(hdr, ELFMAG, SELFMAG) != 0)\n+        goto bail;\n+\n+    assert(hdr[5] == ELFDATA2LSB);\n+    if (hdr[4] == ELFCLASS32) {\n+        found = Elf32_locate_symbol((Elf32_Ehdr *)hdr, symbol);\n+    } else if (hdr[4] == ELFCLASS64) {\n+        found = Elf64_locate_symbol((Elf64_Ehdr *)hdr, symbol);\n+    }\n+\n+bail:\n+    munmap(elf_file, library_sz);\n+    return found;\n+}\n+\n+#endif"
    },
    {
      "sha": "fd7c4c28bd9715fadecc2f4cc1bed8f198ac014f",
      "filename": "contrib/escape_json.sh",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/contrib%2Fescape_json.sh",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/contrib%2Fescape_json.sh",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/contrib%2Fescape_json.sh?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -1,10 +1,9 @@\n-#!/bin/bash\n+#!/bin/sh\n # print arguments escaped as json list elements\n \n first=true\n for n in \"$@\"; do\n   $first && first=false || printf ', '\n-  n=\"${n//\\\\/\\\\\\\\}\"\n-  n=\"${n//\\\"/\\\\\\\"}\"\n+  n=$(printf '%s' \"$n\" | sed 's/\\\\/\\\\\\\\/g' | sed 's/\"/\\\\\"/g')\n   printf '\"%s\"' \"$n\"\n done"
    },
    {
      "sha": "9e88f984fa720c571fe4acd3ba497fcfe3c51a1c",
      "filename": "deps/checksums/LinearAlgebra-47864521739992c57be3138128458ecf7d339567.tar.gz/md5",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/deps%2Fchecksums%2FLinearAlgebra-47864521739992c57be3138128458ecf7d339567.tar.gz%2Fmd5",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/deps%2Fchecksums%2FLinearAlgebra-47864521739992c57be3138128458ecf7d339567.tar.gz%2Fmd5",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2Fchecksums%2FLinearAlgebra-47864521739992c57be3138128458ecf7d339567.tar.gz%2Fmd5?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -0,0 +1 @@\n+252d2268bcd34ed7705c3075b3df8780"
    },
    {
      "sha": "1c172f6b2fdbc7a7d8e6f77241b7eead58fe97ba",
      "filename": "deps/checksums/LinearAlgebra-47864521739992c57be3138128458ecf7d339567.tar.gz/sha512",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/deps%2Fchecksums%2FLinearAlgebra-47864521739992c57be3138128458ecf7d339567.tar.gz%2Fsha512",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/deps%2Fchecksums%2FLinearAlgebra-47864521739992c57be3138128458ecf7d339567.tar.gz%2Fsha512",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2Fchecksums%2FLinearAlgebra-47864521739992c57be3138128458ecf7d339567.tar.gz%2Fsha512?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -0,0 +1 @@\n+d65687ba794152f9d4645f4a2fc73bb5fae2a487363a7af46ec974e7143286721eac2fa2b5313accf809beda3ff5f9e2c544ba7d30236e3b22a1af81d237501f"
    },
    {
      "sha": "a7fb7c9d4ab28845b20a0f0dda9cd1c15b80389b",
      "filename": "deps/checksums/LinearAlgebra-7e11b5e1b474ff742fb55f420631964b60158fe6.tar.gz/md5",
      "status": "removed",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7f76b76527dc2e8eb26a05270419db7191ab9fe1/deps%2Fchecksums%2FLinearAlgebra-7e11b5e1b474ff742fb55f420631964b60158fe6.tar.gz%2Fmd5",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7f76b76527dc2e8eb26a05270419db7191ab9fe1/deps%2Fchecksums%2FLinearAlgebra-7e11b5e1b474ff742fb55f420631964b60158fe6.tar.gz%2Fmd5",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2Fchecksums%2FLinearAlgebra-7e11b5e1b474ff742fb55f420631964b60158fe6.tar.gz%2Fmd5?ref=7f76b76527dc2e8eb26a05270419db7191ab9fe1",
      "patch": "@@ -1 +0,0 @@\n-abfdf2d9379478148453a3052a626470"
    },
    {
      "sha": "329296a7e912eaa1d69c651e0aca4175bdacb2e7",
      "filename": "deps/checksums/LinearAlgebra-7e11b5e1b474ff742fb55f420631964b60158fe6.tar.gz/sha512",
      "status": "removed",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7f76b76527dc2e8eb26a05270419db7191ab9fe1/deps%2Fchecksums%2FLinearAlgebra-7e11b5e1b474ff742fb55f420631964b60158fe6.tar.gz%2Fsha512",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7f76b76527dc2e8eb26a05270419db7191ab9fe1/deps%2Fchecksums%2FLinearAlgebra-7e11b5e1b474ff742fb55f420631964b60158fe6.tar.gz%2Fsha512",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2Fchecksums%2FLinearAlgebra-7e11b5e1b474ff742fb55f420631964b60158fe6.tar.gz%2Fsha512?ref=7f76b76527dc2e8eb26a05270419db7191ab9fe1",
      "patch": "@@ -1 +0,0 @@\n-b59f23897fb184c9d5123c66e454676ee97cab1755ad80fdb1fe43fd3730e1189d3f86e2110b7496d3fbff6302fadac178f970127b6d550a7bae10699f060412"
    },
    {
      "sha": "641a98aecef0284bb8fabe0a6e0d7be4ac07df0b",
      "filename": "deps/checksums/cacert-2025-11-04.pem/md5",
      "status": "removed",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7f76b76527dc2e8eb26a05270419db7191ab9fe1/deps%2Fchecksums%2Fcacert-2025-11-04.pem%2Fmd5",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7f76b76527dc2e8eb26a05270419db7191ab9fe1/deps%2Fchecksums%2Fcacert-2025-11-04.pem%2Fmd5",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2Fchecksums%2Fcacert-2025-11-04.pem%2Fmd5?ref=7f76b76527dc2e8eb26a05270419db7191ab9fe1",
      "patch": "@@ -1 +0,0 @@\n-4ca8e1c3e8fc44c3ecd7a1fb9d3a6d03"
    },
    {
      "sha": "bbd48b9475d7fe73a39652c41e839728213e0bb9",
      "filename": "deps/checksums/cacert-2025-11-04.pem/sha512",
      "status": "removed",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7f76b76527dc2e8eb26a05270419db7191ab9fe1/deps%2Fchecksums%2Fcacert-2025-11-04.pem%2Fsha512",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7f76b76527dc2e8eb26a05270419db7191ab9fe1/deps%2Fchecksums%2Fcacert-2025-11-04.pem%2Fsha512",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2Fchecksums%2Fcacert-2025-11-04.pem%2Fsha512?ref=7f76b76527dc2e8eb26a05270419db7191ab9fe1",
      "patch": "@@ -1 +0,0 @@\n-9d9f7ecc829bafc222501d8a66852d96a51f522b04a82963e4166c87b85d6a5e5eedb50ced2ef3026cd7cb06fcb4b7dca59c4157813a067cb7b185e32f2957ec"
    },
    {
      "sha": "c482d2cc8dc9c11f8547f4baceae29539114f5c6",
      "filename": "deps/checksums/cacert-2025-12-02.pem/md5",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/deps%2Fchecksums%2Fcacert-2025-12-02.pem%2Fmd5",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/deps%2Fchecksums%2Fcacert-2025-12-02.pem%2Fmd5",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2Fchecksums%2Fcacert-2025-12-02.pem%2Fmd5?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -0,0 +1 @@\n+fafa2b78f98273ea332251e3d1628b02"
    },
    {
      "sha": "92e9d653aee45f4ded174257b68ec20da8ad8165",
      "filename": "deps/checksums/cacert-2025-12-02.pem/sha512",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/deps%2Fchecksums%2Fcacert-2025-12-02.pem%2Fsha512",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/deps%2Fchecksums%2Fcacert-2025-12-02.pem%2Fsha512",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2Fchecksums%2Fcacert-2025-12-02.pem%2Fsha512?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -0,0 +1 @@\n+aef293e084ef15a55a4f9dee395ee4bbbadea1f5a49c0590e0ff67a0630b5298d2bc79699ab95d70be0d2d06f9f1e55fe676b3e1d5ff912df88f2d6bff0d5736"
    },
    {
      "sha": "a39088064168ff86a46aba0ced31191e39cc6e54",
      "filename": "deps/libgit2.version",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/deps%2Flibgit2.version",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/deps%2Flibgit2.version",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2Flibgit2.version?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -11,4 +11,4 @@ LIBGIT2_SHA1=0060d9cf5666f015b1067129bd874c6cc4c9c7ac\n # The versions of cacert.pem are identified by the date (YYYY-MM-DD) of their changes.\n # See https://curl.haxx.se/docs/caextract.html for more details.\n # Keep in sync with `stdlib/MozillaCACerts_jll/Project.toml`.\n-MOZILLA_CACERT_VERSION := 2025-11-04\n+MOZILLA_CACERT_VERSION := 2025-12-02"
    },
    {
      "sha": "b19ac763465d4708f00e06fa5f9de5e9a2aa221c",
      "filename": "doc/src/manual/installation.md",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/doc%2Fsrc%2Fmanual%2Finstallation.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/doc%2Fsrc%2Fmanual%2Finstallation.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fmanual%2Finstallation.md?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -75,7 +75,12 @@ If the Windows Store is blocked on a system, we have an alternative\n [MSIX App Installer](https://learn.microsoft.com/en-us/windows/msix/app-installer/app-installer-file-overview)\n based setup. To use the App Installer version, download\n [this](https://install.julialang.org/Julia.appinstaller) file and open it by\n-double clicking on it.\n+double clicking on it. One can also install exactly the same version by executing\n+the PowerShell command\n+\n+```\n+Add-AppxPackage -AppInstallerFile https://install.julialang.org/Julia.appinstaller\n+```\n \n ### MSI Installer (Windows)\n "
    },
    {
      "sha": "bce8f832b5755b881a2ce994d8462e69f3f926ed",
      "filename": "pkgimage.mk",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/pkgimage.mk",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/pkgimage.mk",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/pkgimage.mk?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -27,7 +27,7 @@ print-depot-path:\n \n $(BUILDDIR)/stdlib/%.image: $(JULIAHOME)/stdlib/Project.toml $(JULIAHOME)/stdlib/Manifest.toml $(INDEPENDENT_STDLIBS_SRCS) $(DEPOTDIR)/compiled\n \t@$(call PRINT_JULIA, JULIA_CPU_TARGET=\"sysimage\" $(call spawn,$(JULIA_EXECUTABLE)) --startup-file=no -e \\\n-\t\t'Base.Precompilation.precompilepkgs(configs=[``=>Base.CacheFlags(debug_level=2, opt_level=3), ``=>Base.CacheFlags(check_bounds=1, debug_level=2, opt_level=3)])')\n+\t\t'Base.Precompilation.precompilepkgs(configs=[``=>Base.CacheFlags(debug_level=2, opt_level=3), ``=>Base.CacheFlags(check_bounds=1, debug_level=2, opt_level=3)]; strict=true)')\n \ttouch $@\n \n $(BUILDDIR)/stdlib/release.image: $(build_private_libdir)/sys.$(SHLIB_EXT)"
    },
    {
      "sha": "05230cfa19af38df72cd086eb6a09de287b6da13",
      "filename": "src/Makefile",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2FMakefile",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2FMakefile",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2FMakefile?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -207,6 +207,15 @@ RT_LIBS := $(WHOLE_ARCHIVE) $(LIBUV) $(WHOLE_ARCHIVE) $(LIBUTF8PROC) $(NO_WHOLE_\n # NB: CG needs uv_mutex_* symbols, but we expect to export them from libjulia-internal\n CG_LIBS := $(LIBUNWIND) $(CG_LLVMLINK) $(OSLIBS) $(LIBTRACYCLIENT) $(LIBITTAPI)\n \n+ifeq ($(USEGCC),1)\n+ifeq ($(USE_RT_STATIC_LIBGCC),1)\n+RT_LIBS += -static-libgcc\n+endif\n+ifeq ($(USE_RT_STATIC_LIBSTDCXX),1)\n+RT_LIBS += -static-libstdc++\n+endif\n+endif\n+\n ifeq (${USE_THIRD_PARTY_GC},mmtk)\n RT_LIBS += $(MMTK_LIB)\n CG_LIBS += $(MMTK_LIB)"
    },
    {
      "sha": "ca711e0f9678abd5073ff2960387054265c12a68",
      "filename": "src/coverage.cpp",
      "status": "modified",
      "additions": 23,
      "deletions": 32,
      "changes": 55,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fcoverage.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fcoverage.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcoverage.cpp?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -3,9 +3,6 @@\n #include <cstdint>\n #include <pthread.h>\n #include <string>\n-#include <fstream>\n-#include <map>\n-#include <vector>\n \n #include \"llvm-version.h\"\n #include <llvm/ADT/StringRef.h>\n@@ -137,26 +134,20 @@ static void write_log_data(logdata_t &logData, const char *extension) JL_NOTSAFE\n         if (!values.empty()) {\n             if (!jl_isabspath(filename.c_str()))\n                 filename = base + filename;\n-            std::ifstream inf(filename.c_str());\n-            if (!inf.is_open())\n+            FILE *inf = fopen(filename.c_str(), \"r\");\n+            if (!inf)\n                 continue;\n             std::string outfile = filename + extension;\n-            std::ofstream outf(outfile.c_str(), std::ofstream::trunc | std::ofstream::out | std::ofstream::binary);\n-            if (outf.is_open()) {\n-                inf.exceptions(std::ifstream::badbit);\n-                outf.exceptions(std::ifstream::failbit | std::ifstream::badbit);\n+            FILE *outf = fopen(outfile.c_str(), \"wb\");\n+            if (outf) {\n                 char line[1024];\n                 int l = 1;\n                 unsigned block = 0;\n-                while (!inf.eof()) {\n-                    inf.getline(line, sizeof(line));\n-                    if (inf.fail()) {\n-                        if (inf.eof())\n-                            break; // no content on trailing line\n-                        // Read through lines longer than sizeof(line)\n-                        inf.clear();\n-                        inf.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n-                    }\n+                int ret = 0;\n+                while (ret != EOF && (ret = fscanf(inf, \"%1023[^\\n]\", line)) != EOF) {\n+                    // Skip n non-newline chars and a single trailing newline\n+                    if ((ret = fscanf(inf, \"%*[^\\n]\")) != EOF)\n+                        ret = fscanf(inf, \"%*1[\\n]\");\n                     logdata_block *data = NULL;\n                     if (block < values.size()) {\n                         data = values[block];\n@@ -166,32 +157,32 @@ static void write_log_data(logdata_t &logData, const char *extension) JL_NOTSAFE\n                         l = 0;\n                         block++;\n                     }\n-                    outf.width(9);\n                     if (value == 0)\n-                        outf << '-';\n+                        fprintf(outf, \"        -\");\n                     else\n-                        outf << (value - 1);\n-                    outf.width(0);\n-                    outf << \" \" << line << '\\n';\n+                        fprintf(outf, \"%9\" PRIu64, value - 1);\n+                    fprintf(outf, \" %s\\n\", line);\n+                    line[0] = 0;\n                 }\n-                outf.close();\n+                fclose(outf);\n             }\n-            inf.close();\n+            fclose(inf);\n         }\n     }\n }\n \n static void write_lcov_data(logdata_t &logData, const std::string &outfile) JL_NOTSAFEPOINT\n {\n-    std::ofstream outf(outfile.c_str(), std::ofstream::ate | std::ofstream::out | std::ofstream::binary);\n+    FILE *outf = fopen(outfile.c_str(), \"ab\");\n+    if (!outf) return;\n     //std::string base = std::string(jl_options.julia_bindir);\n     //base = base + \"/../share/julia/base/\";\n     logdata_t::iterator it = logData.begin();\n     for (; it != logData.end(); it++) {\n         StringRef filename = it->first();\n         const SmallVector<logdata_block*, 0> &values = it->second;\n         if (!values.empty()) {\n-            outf << \"SF:\" << filename.str() << '\\n';\n+            fprintf(outf, \"SF:%.*s\\n\", (int)filename.size(), filename.data());\n             size_t n_covered = 0;\n             size_t n_instrumented = 0;\n             size_t lno = 0;\n@@ -204,7 +195,7 @@ static void write_lcov_data(logdata_t &logData, const std::string &outfile) JL_N\n                             n_instrumented++;\n                             if (cov > 1)\n                                 n_covered++;\n-                            outf << \"DA:\" << lno << ',' << (cov - 1) << '\\n';\n+                            fprintf(outf, \"DA:%zu,%\" PRIu64 \"\\n\", lno, cov - 1);\n                         }\n                         lno++;\n                     }\n@@ -213,12 +204,12 @@ static void write_lcov_data(logdata_t &logData, const std::string &outfile) JL_N\n                     lno += logdata_blocksize;\n                 }\n             }\n-            outf << \"LH:\" << n_covered << '\\n';\n-            outf << \"LF:\" << n_instrumented << '\\n';\n-            outf << \"end_of_record\\n\";\n+            fprintf(outf, \"LH:%zu\\n\", n_covered);\n+            fprintf(outf, \"LF:%zu\\n\", n_instrumented);\n+            fprintf(outf, \"end_of_record\\n\");\n         }\n     }\n-    outf.close();\n+    fclose(outf);\n }\n \n extern \"C\" JL_DLLEXPORT void jl_write_coverage_data(const char *output) JL_NOTSAFEPOINT"
    },
    {
      "sha": "62379263b03e75529d02f33159567ec5cfd5db8d",
      "filename": "src/gc-heap-snapshot.cpp",
      "status": "modified",
      "additions": 11,
      "deletions": 20,
      "changes": 31,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fgc-heap-snapshot.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fgc-heap-snapshot.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fgc-heap-snapshot.cpp?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -6,25 +6,19 @@\n #include \"julia_internal.h\"\n #include \"julia_assert.h\"\n \n+#include \"llvm/ADT/DenseMap.h\"\n+#include \"llvm/ADT/SmallString.h\"\n #include \"llvm/ADT/SmallVector.h\"\n #include \"llvm/ADT/StringMap.h\"\n-#include \"llvm/ADT/DenseMap.h\"\n-\n-#include <vector>\n-#include <string>\n-#include <sstream>\n-#include <iostream>\n-#include <set>\n+#include \"llvm/Support/FormatVariadic.h\"\n \n-using std::string;\n-using std::set;\n-using std::ostringstream;\n-using std::pair;\n using std::make_pair;\n using llvm::SmallVector;\n using llvm::StringMap;\n using llvm::DenseMap;\n using llvm::StringRef;\n+using llvm::SmallString;\n+using llvm::formatv;\n \n // https://stackoverflow.com/a/33799784/751061\n void print_str_escape_json(ios_t *stream, StringRef s)\n@@ -422,18 +416,16 @@ static size_t record_pointer_to_gc_snapshot(void *a, size_t bytes, StringRef nam\n     return val.first->second;\n }\n \n-static string _fieldpath_for_slot(void *obj, void *slot) JL_NOTSAFEPOINT\n+static SmallString<128> _fieldpath_for_slot(void *obj, void *slot) JL_NOTSAFEPOINT\n {\n-    string res;\n+    SmallString<128> res;\n     jl_datatype_t *objtype = (jl_datatype_t*)jl_typeof(obj);\n \n     while (1) {\n         int i = gc_slot_to_fieldidx(obj, slot, objtype);\n \n         if (jl_is_tuple_type(objtype) || jl_is_namedtuple_type(objtype)) {\n-            ostringstream ss;\n-            ss << \"[\" << i << \"]\";\n-            res += ss.str();\n+            res += formatv(\"[{0}]\", i).sstr<8>();\n         }\n         else {\n             jl_svec_t *field_names = jl_field_names(objtype);\n@@ -472,9 +464,8 @@ void _gc_heap_snapshot_record_gc_roots(jl_value_t *root, char *name) JL_NOTSAFEP\n void _gc_heap_snapshot_record_finlist(jl_value_t *obj, size_t index) JL_NOTSAFEPOINT\n {\n     auto to_node_idx = record_node_to_gc_snapshot(obj);\n-    ostringstream ss;\n-    ss << \"finlist-\" << index;\n-    auto edge_label = g_snapshot->names.serialize_if_necessary(g_snapshot->strings, ss.str());\n+    SmallString<16> ss = formatv(\"finlist-{0}\", index);\n+    auto edge_label = g_snapshot->names.serialize_if_necessary(g_snapshot->strings, ss);\n     _record_gc_just_edge(\"internal\", g_snapshot->_gc_finlist_root_idx, to_node_idx, edge_label);\n }\n \n@@ -536,7 +527,7 @@ void _gc_heap_snapshot_record_array_edge(jl_value_t *from, jl_value_t *to, size_\n \n void _gc_heap_snapshot_record_object_edge(jl_value_t *from, jl_value_t *to, void *slot) JL_NOTSAFEPOINT\n {\n-    string path = _fieldpath_for_slot(from, slot);\n+    SmallString<128> path = _fieldpath_for_slot(from, slot);\n     _record_gc_edge(\"property\", from, to,\n                     g_snapshot->names.serialize_if_necessary(g_snapshot->strings, path));\n }"
    },
    {
      "sha": "59b3cd3c05ad5ff54666c55ab520e6b2e9110e79",
      "filename": "src/gc-stock.c",
      "status": "modified",
      "additions": 26,
      "deletions": 17,
      "changes": 43,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fgc-stock.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fgc-stock.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fgc-stock.c?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -197,6 +197,7 @@ static int mark_reset_age = 0;\n \n static int64_t scanned_bytes; // young bytes scanned while marking\n static int64_t perm_scanned_bytes; // old bytes scanned while marking\n+static int64_t heap_size_after_last_full_gc = 0;\n int prev_sweep_full = 1;\n int current_sweep_full = 0;\n int next_sweep_full = 0;\n@@ -2241,13 +2242,13 @@ JL_DLLEXPORT void jl_gc_mark_queue_objarray(jl_ptls_t ptls, jl_value_t *parent,\n // `_new_obj` has its lowest bit tagged if it's in the remset (in which case we shouldn't update page metadata)\n FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_new_obj) JL_NOTSAFEPOINT\n {\n-    int meta_updated = (uintptr_t)_new_obj & GC_REMSET_PTR_TAG;\n+    int remset_object = (uintptr_t)_new_obj & GC_REMSET_PTR_TAG;\n     jl_value_t *new_obj = (jl_value_t *)((uintptr_t)_new_obj & ~(uintptr_t)GC_REMSET_PTR_TAG);\n     mark_obj: {\n         jl_taggedvalue_t *o = jl_astaggedvalue(new_obj);\n         uintptr_t vtag = o->header & ~(uintptr_t)0xf;\n         uint8_t bits = (gc_old(o->header) && !mark_reset_age) ? GC_OLD_MARKED : GC_MARKED;\n-        int update_meta = __likely(!meta_updated && !gc_verifying);\n+        int update_meta = __likely(!remset_object && !gc_verifying);\n         int foreign_alloc = 0;\n         if (update_meta && o->bits.in_image) {\n             foreign_alloc = 1;\n@@ -2347,7 +2348,7 @@ FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_\n                 uintptr_t nptr = (npointers << 2) | 1 | bits;\n                 new_obj = gc_mark_obj8(ptls, obj8_parent, obj8_begin, obj8_end, nptr);\n                 if (new_obj != NULL) {\n-                    if (!meta_updated)\n+                    if (!remset_object)\n                         goto mark_obj;\n                     else\n                         gc_ptr_queue_push(mq, new_obj);\n@@ -2469,7 +2470,7 @@ FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_\n             assert(obj8_begin < obj8_end);\n             new_obj = gc_mark_obj8(ptls, obj8_parent, obj8_begin, obj8_end, nptr);\n             if (new_obj != NULL) {\n-                if (!meta_updated)\n+                if (!remset_object)\n                     goto mark_obj;\n                 else\n                     gc_ptr_queue_push(mq, new_obj);\n@@ -2482,7 +2483,7 @@ FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_\n             assert(obj16_begin < obj16_end);\n             new_obj = gc_mark_obj16(ptls, obj16_parent, obj16_begin, obj16_end, nptr);\n             if (new_obj != NULL) {\n-                if (!meta_updated)\n+                if (!remset_object)\n                     goto mark_obj;\n                 else\n                     gc_ptr_queue_push(mq, new_obj);\n@@ -2497,7 +2498,7 @@ FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_\n             assert(obj32_begin < obj32_end);\n             new_obj = gc_mark_obj32(ptls, obj32_parent, obj32_begin, obj32_end, nptr);\n             if (new_obj != NULL) {\n-                if (!meta_updated)\n+                if (!remset_object)\n                     goto mark_obj;\n                 else\n                     gc_ptr_queue_push(mq, new_obj);\n@@ -3045,7 +3046,6 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n     uint64_t gc_start_time = jl_hrtime();\n     uint64_t mutator_time = gc_end_time == 0 ? old_mut_time : gc_start_time - gc_end_time;\n     uint64_t before_free_heap_size = jl_atomic_load_relaxed(&gc_heap_stats.heap_size);\n-    int64_t last_perm_scanned_bytes = perm_scanned_bytes;\n     uint64_t start_mark_time = jl_hrtime();\n     JL_PROBE_GC_MARK_BEGIN();\n     {\n@@ -3139,8 +3139,9 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n     gc_stats_all_pool();\n     gc_stats_big_obj();\n     gc_num.total_allocd += gc_num.allocd;\n-    if (!prev_sweep_full)\n-        promoted_bytes += perm_scanned_bytes - last_perm_scanned_bytes;\n+    // promoted_bytes are all the new bytes scanned that got promoted to old but that have never seen a full GC as old\n+    promoted_bytes += scanned_bytes;\n+    scanned_bytes = 0;\n     // 4. next collection decision\n     int remset_nptr = 0;\n     int sweep_full = next_sweep_full;\n@@ -3166,13 +3167,6 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n         recollect = 1;\n         gc_count_full_sweep_reason(FULL_SWEEP_REASON_FORCED_FULL_SWEEP);\n     }\n-    if (sweep_full) {\n-        // these are the difference between the number of gc-perm bytes scanned\n-        // on the first collection after sweep_full, and the current scan\n-        perm_scanned_bytes = 0;\n-        promoted_bytes = 0;\n-    }\n-    scanned_bytes = 0;\n     // 5. start sweeping\n     uint64_t start_sweep_time = jl_hrtime();\n     JL_PROBE_GC_SWEEP_BEGIN(sweep_full);\n@@ -3324,8 +3318,19 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n         target_heap = heap_size + jl_options.heap_target_increment;\n         jl_atomic_store_relaxed(&gc_heap_stats.heap_target, target_heap);\n     }\n-\n+    if (sweep_full) {\n+        // these are the difference between the number of gc-perm bytes scanned\n+        // on the first collection after sweep_full, and the current scan\n+        perm_scanned_bytes = 0;\n+        promoted_bytes = 0;\n+        heap_size_after_last_full_gc = jl_atomic_load_relaxed(&gc_heap_stats.heap_size);\n+    }\n+    // We want to trigger full GCs either if the heap size has grown a lot since the last full GC.\n+    // For this we use the overallocation function to see what a reasonable rate of growth is,\n+    // or if there is too much memory that has not seen a full GC after being promoted to old.\n     double old_ratio = (double)promoted_bytes/(double)heap_size;\n+    double expected_heap_size = overallocation(heap_size_after_last_full_gc, 0, UINT64_MAX) + heap_size_after_last_full_gc;\n+    double last_full_gc_heap_ratio = (double)heap_size/expected_heap_size;\n     if (heap_size > user_max) {\n         next_sweep_full = 1;\n         gc_count_full_sweep_reason(FULL_SWEEP_REASON_USER_MAX_EXCEEDED);\n@@ -3334,6 +3339,10 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n         next_sweep_full = 1;\n         gc_count_full_sweep_reason(FULL_SWEEP_REASON_LARGE_PROMOTION_RATE);\n     }\n+    else if (last_full_gc_heap_ratio > 1) {\n+        next_sweep_full = 1;\n+        gc_count_full_sweep_reason(FULL_SWEEP_REASON_LARGE_HEAP_GROWTH);\n+    }\n     else {\n         next_sweep_full = 0;\n     }"
    },
    {
      "sha": "d08901666186410c1c8769182349cbefc057a88a",
      "filename": "src/gc-stock.h",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fgc-stock.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fgc-stock.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fgc-stock.h?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -473,7 +473,8 @@ FORCE_INLINE void gc_big_object_link(bigval_t *sentinel_node, bigval_t *node) JL\n #define FULL_SWEEP_REASON_FORCED_FULL_SWEEP (1)\n #define FULL_SWEEP_REASON_USER_MAX_EXCEEDED (2)\n #define FULL_SWEEP_REASON_LARGE_PROMOTION_RATE (3)\n-#define FULL_SWEEP_NUM_REASONS (4)\n+#define FULL_SWEEP_REASON_LARGE_HEAP_GROWTH (4)\n+#define FULL_SWEEP_NUM_REASONS (5)\n \n extern JL_DLLEXPORT uint64_t jl_full_sweep_reasons[FULL_SWEEP_NUM_REASONS];\n STATIC_INLINE void gc_count_full_sweep_reason(int reason) JL_NOTSAFEPOINT"
    },
    {
      "sha": "84dece8d94c8171c9f483442ac06344d1ae5b9bc",
      "filename": "src/jloptions.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fjloptions.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fjloptions.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjloptions.c?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -713,9 +713,11 @@ JL_DLLEXPORT void jl_parse_opts(int *argcp, char ***argvp)\n                 }\n                 jl_options.nthreads = nthreads + nthreadsi;\n             }\n+            assert(jl_options.nthreadpools == 1 || jl_options.nthreadpools == 2);\n             int16_t *ntpp = (int16_t *)malloc_s(jl_options.nthreadpools * sizeof(int16_t));\n             ntpp[0] = (int16_t)nthreads;\n-            ntpp[1] = (int16_t)nthreadsi;\n+            if (jl_options.nthreadpools == 2)\n+                ntpp[1] = (int16_t)nthreadsi;\n             jl_options.nthreads_per_pool = ntpp;\n             break;\n         }"
    },
    {
      "sha": "52dcb61a1cf71e945baa0ad2d4ec0d35e33ee3bc",
      "filename": "src/julia_threads.h",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fjulia_threads.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fjulia_threads.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia_threads.h?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -194,6 +194,13 @@ typedef struct _jl_tls_states_t {\n #else\n     void *signal_stack;\n     size_t signal_stack_size;\n+#endif\n+#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_) || defined(_OS_OPENBSD_)\n+    // Saved context from jl_call_in_ctx for stack unwinding\n+    uintptr_t signal_ctx_pc;\n+    uintptr_t signal_ctx_sp;\n+    void (*signal_ctx_fptr)(void);\n+    uintptr_t signal_ctx_arg;\n #endif\n     jl_thread_t system_id;\n     _Atomic(int16_t) suspend_count;"
    },
    {
      "sha": "1a25171082d8205dd70663ab0088f1a70936b6ca",
      "filename": "src/processor.cpp",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fprocessor.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fprocessor.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fprocessor.cpp?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -16,7 +16,6 @@\n #include \"julia.h\"\n #include \"julia_internal.h\"\n \n-#include <map>\n #include <algorithm>\n \n #include \"julia_assert.h\"\n@@ -25,8 +24,6 @@\n #include <dlfcn.h>\n #endif\n \n-#include <iostream>\n-\n // CPU target string is a list of strings separated by `;` each string starts with a CPU\n // or architecture name and followed by an optional list of features separated by `,`.\n // A \"generic\" or empty CPU name means the basic required feature set of the target ISA"
    },
    {
      "sha": "898ab1a02542004d722b58afd6baaed2519d2a3e",
      "filename": "src/runtime_ccall.cpp",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fruntime_ccall.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fruntime_ccall.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fruntime_ccall.cpp?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -1,7 +1,6 @@\n // This file is a part of Julia. License is MIT: https://julialang.org/license\n \n #include \"llvm-version.h\"\n-#include <map>\n #include <string>\n #include <llvm/ADT/StringMap.h>\n #include <llvm/TargetParser/Host.h>\n@@ -25,7 +24,7 @@ using namespace llvm;\n jl_value_t *jl_libdl_dlopen_func JL_GLOBALLY_ROOTED;\n \n // map from user-specified lib names to handles\n-static std::map<std::string, void*> libMap;\n+static StringMap<void*> libMap;\n static jl_mutex_t libmap_lock;\n extern \"C\"\n void *jl_get_library_(const char *f_lib, int throw_err)"
    },
    {
      "sha": "c64a01068b34b517bfe18463a017bed1fa7cb506",
      "filename": "src/signals-mach.c",
      "status": "modified",
      "additions": 51,
      "deletions": 51,
      "changes": 102,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fsignals-mach.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fsignals-mach.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-mach.c?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -220,36 +220,36 @@ typedef arm_exception_state64_t host_exception_state_t;\n #define HOST_EXCEPTION_STATE_COUNT ARM_EXCEPTION_STATE64_COUNT\n #endif\n \n-// create a fake function that describes the variable manipulations in jl_call_in_state\n-__attribute__((naked)) static void fake_stack_pop(void)\n+// Create a fake function that describes the register manipulations in jl_call_in_state\n+// The callee-saved registers still may get smashed (by the cdecl fptr), since we didn't explicitly copy all of the\n+// state to the stack (to build a real sigreturn frame).\n+__attribute__((naked)) static void jl_fake_signal_return(void)\n {\n-#ifdef _CPU_X86_64_\n-    __asm__ volatile (\n-        \"  .cfi_signal_frame\\n\"\n-        \"  .cfi_def_cfa %rsp, 0\\n\" // CFA here uses %rsp directly\n-        \"  .cfi_offset %rip, 0\\n\" // previous value of %rip at CFA\n-        \"  .cfi_offset %rsp, 8\\n\" // previous value of %rsp at CFA\n-        \"  nop\\n\"\n-    );\n+#if defined(_CPU_X86_64_)\n+__asm__(\n+    \"  .cfi_signal_frame\\n\"\n+    \"  .cfi_def_cfa %rsp, 0\\n\" // CFA here uses %rsp directly\n+    \"  .cfi_offset %rip, 0\\n\" // previous value of %rip at CFA\n+    \"  .cfi_offset %rsp, 8\\n\" // previous value of %rsp at CFA\n+    \"  ud2\\n\"\n+    \"  ud2\\n\"\n+);\n #elif defined(_CPU_AARCH64_)\n-    __asm__ volatile (\n-        \"  .cfi_signal_frame\\n\"\n-        \"  .cfi_def_cfa sp, 0\\n\" // use sp as fp here\n-        \"  .cfi_offset lr, 0\\n\"\n-        \"  .cfi_offset sp, 8\\n\"\n-        // Anything else got smashed, since we didn't explicitly copy all of the\n-        // state object to the stack (to build a real sigreturn frame).\n-        // This is also not quite valid, since the AArch64 DWARF spec lacks the ability to define how to restore the LR register correctly,\n-        // so normally libunwind implementations on linux detect this function specially and hack around the invalid info:\n-        // https://github.com/llvm/llvm-project/commit/c82deed6764cbc63966374baf9721331901ca958\n-        \" nop\\n\"\n-    );\n-#else\n-CFI_NORETURN\n+__asm__(\n+    \"  .cfi_signal_frame\\n\"\n+    \"  .cfi_def_cfa sp, 0\\n\" // use sp as fp here\n+    // This is not quite valid, since the AArch64 DWARF spec lacks the ability to define how to restore the LR register correctly,\n+    // so normally libunwind implementations on linux detect this function specially and hack around the invalid info:\n+    // https://github.com/llvm/llvm-project/commit/c82deed6764cbc63966374baf9721331901ca958\n+    \"  .cfi_offset lr, 0\\n\"\n+    \"  .cfi_offset sp, 8\\n\"\n+    \"  brk #1\\n\"\n+    \"  brk #1\\n\"\n+);\n #endif\n }\n \n-static void jl_call_in_state(host_thread_state_t *state, void (*fptr)(void))\n+static void jl_call_in_state1(host_thread_state_t *state, void (*fptr)(void), uintptr_t arg0)\n {\n #ifdef _CPU_X86_64_\n     uintptr_t sp = state->__rsp;\n@@ -258,51 +258,59 @@ static void jl_call_in_state(host_thread_state_t *state, void (*fptr)(void))\n #endif\n     sp = (sp - 256) & ~(uintptr_t)15; // redzone and re-alignment\n     assert(sp % 16 == 0);\n-    sp -= 16;\n #ifdef _CPU_X86_64_\n-    // set return address to NULL\n-    *(uintptr_t*)sp = 0;\n-    // pushq %sp\n+    // push {%rsp, %rip}\n     sp -= sizeof(void*);\n     *(uintptr_t*)sp = state->__rsp;\n-    // pushq %rip\n     sp -= sizeof(void*);\n     *(uintptr_t*)sp = state->__rip;\n-    // pushq .fake_stack_pop + 1; aka call from fake_stack_pop\n+    // pushq .jl_fake_signal_return + 1; aka call from jl_fake_signal_return\n     sp -= sizeof(void*);\n-    *(uintptr_t*)sp = (uintptr_t)&fake_stack_pop + 1;\n+    *(uintptr_t*)sp = (uintptr_t)&jl_fake_signal_return + 1;\n     state->__rsp = sp; // set stack pointer\n     state->__rip = (uint64_t)fptr; // \"call\" the function\n+    state->__rdi = arg0;\n #elif defined(_CPU_AARCH64_)\n-    // push {%sp, %pc + 4}\n+    // push {%sp, %pc}\n     sp -= sizeof(void*);\n     *(uintptr_t*)sp = state->__sp;\n     sp -= sizeof(void*);\n     *(uintptr_t*)sp = (uintptr_t)state->__pc;\n     state->__sp = sp; // x31\n     state->__pc = (uint64_t)fptr; // pc\n-    state->__lr = (uintptr_t)&fake_stack_pop + 4; // x30\n+    state->__lr = (uintptr_t)&jl_fake_signal_return + 4; // x30\n+    state->__x[0] = arg0;\n #else\n #error \"julia: throw-in-context not supported on this platform\"\n #endif\n }\n \n static void jl_longjmp_in_state(host_thread_state_t *state, jl_jmp_buf jmpbuf)\n {\n-\n     if (!jl_simulate_longjmp(jmpbuf, (bt_context_t*)state)) {\n         // for sanitizer builds, fallback to calling longjmp on the original stack\n         // (this will fail for stack overflow, but that is hardly sanitizer-legal anyways)\n #ifdef _CPU_X86_64_\n-    state->__rdi = (uintptr_t)jmpbuf;\n-    state->__rsi = 1;\n+        uintptr_t sp = state->__rsp;\n+#elif defined(_CPU_AARCH64_)\n+        uintptr_t sp = state->__sp;\n+#endif\n+        sp = (sp - 256) & ~(uintptr_t)15; // redzone and re-alignment\n+        assert(sp % 16 == 0);\n+#ifdef _CPU_X86_64_\n+        state->__rdi = (uintptr_t)jmpbuf;\n+        state->__rsi = 1;\n+        state->__rsp = sp; // set stack pointer\n+        state->__rip = (uint64_t)longjmp; // \"call\" the function\n #elif defined(_CPU_AARCH64_)\n-    state->__x[0] = (uintptr_t)jmpbuf;\n-    state->__x[1] = 1;\n+        state->__x[0] = (uintptr_t)jmpbuf;\n+        state->__x[1] = 1;\n+        state->__sp = sp; // x31\n+        state->__pc = (uint64_t)longjmp; // pc\n+        state->__lr = (uintptr_t)0; // x30\n #else\n-#error \"julia: jl_longjmp_in_state not supported on this platform\"\n+#error \"julia: throw-in-context not supported on this platform\"\n #endif\n-        jl_call_in_state(state, (void (*)(void))longjmp);\n     }\n }\n \n@@ -577,7 +585,7 @@ static void jl_try_deliver_sigint(void)\n     HANDLE_MACH_ERROR(\"thread_resume\", ret);\n }\n \n-static void JL_NORETURN jl_exit_thread0_cb(int signo)\n+static void jl_exit_thread0_cb(int signo)\n {\n     jl_fprint_critical_error(ios_safe_stderr, signo, 0, NULL, jl_current_task);\n     jl_atexit_hook(128);\n@@ -602,15 +610,7 @@ static void jl_exit_thread0(int signo, jl_bt_element_t *bt_data, size_t bt_size)\n     ptls2->bt_size = bt_size; // <= JL_MAX_BT_SIZE\n     memcpy(ptls2->bt_data, bt_data, ptls2->bt_size * sizeof(bt_data[0]));\n \n-#ifdef _CPU_X86_64_\n-    // First integer argument. Not portable but good enough =)\n-    state.__rdi = signo;\n-#elif defined(_CPU_AARCH64_)\n-    state.__x[0] = signo;\n-#else\n-#error Fill in first integer argument here\n-#endif\n-    jl_call_in_state(&state, (void (*)(void))&jl_exit_thread0_cb);\n+    jl_call_in_state1(&state, (void (*)(void))&jl_exit_thread0_cb, signo);\n     unsigned int count = MACH_THREAD_STATE_COUNT;\n     ret = thread_set_state(thread, MACH_THREAD_STATE, (thread_state_t)&state, count);\n     HANDLE_MACH_ERROR(\"thread_set_state\", ret);"
    },
    {
      "sha": "232e32b3f335fef84456cf6839f78394267005cf",
      "filename": "src/signals-unix.c",
      "status": "modified",
      "additions": 149,
      "deletions": 28,
      "changes": 177,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fsignals-unix.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/src%2Fsignals-unix.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-unix.c?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -70,6 +70,95 @@ int jl_simulate_longjmp(jl_jmp_buf mctx, bt_context_t *c) JL_NOTSAFEPOINT;\n static void jl_longjmp_in_ctx(int sig, void *_ctx, jl_jmp_buf jmpbuf);\n \n #if !defined(_OS_DARWIN_)\n+extern void jl_fake_signal_return(void);\n+// Create a trampoline function that does the stack manipulations for jl_call_in_ctx/jl_call_in_state\n+// The callee-saved registers still may get smashed (by the cdecl fptr), since we didn't explicitly copy all of the\n+// state to the stack (to build a real sigreturn frame).\n+#if (defined(_OS_LINUX_) || defined(_OS_FREEBSD_) || defined(_OS_OPENBSD_)) && defined(_CPU_X86_64_)\n+__asm__(\n+    \"  .type jl_fake_signal_return, @function\\n\"\n+    \"jl_fake_signal_return:\\n\"\n+    \"  .cfi_startproc\\n\"\n+    \"  .cfi_signal_frame\\n\"\n+    // Mark as end of stack until frame is set up\n+    \"  .cfi_undefined %rip\\n\"\n+    \"  .cfi_undefined %rsp\\n\"\n+    // rdi points to signal_ctx_pc in ptls (followed by signal_ctx_sp, signal_ctx_fptr, signal_ctx_arg)\n+    \"  pushq (%rdi)\\n\"        // push pc (signal_ctx_pc)\n+    \"  pushq 8(%rdi)\\n\"       // push sp (signal_ctx_sp)\n+    // stack layout: [sp, pc] (pc at higher address, like return address after call)\n+    \"  .cfi_def_cfa %rsp, 8\\n\"\n+    \"  .cfi_offset %rip, 0\\n\"  // previous %rip at CFA+0 (pc slot at rsp+8)\n+    \"  .cfi_offset %rsp, -8\\n\" // previous %rsp at CFA-8 (sp slot at rsp+0)\n+    \"  pushq 16(%rdi)\\n\"      // push fptr (signal_ctx_fptr)\n+    \"  .cfi_def_cfa %rsp, 16\\n\"\n+    \"  movq 24(%rdi), %rdi\\n\" // restore original rdi from signal_ctx_arg\n+    \"  subq $8, %rsp\\n\"       // align stack to 16 bytes\n+    \"  .cfi_def_cfa %rsp, 24\\n\"\n+    \"  callq *8(%rsp)\\n\"      // call fptr\n+    \"  ud2\\n\"                 // unreachable\n+    \"  .cfi_endproc\\n\"\n+    \"  .size jl_fake_signal_return, .-jl_fake_signal_return\\n\"\n+);\n+\n+#elif (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && defined(_CPU_X86_)\n+__asm__(\n+    \"  .type jl_fake_signal_return, @function\\n\"\n+    \"jl_fake_signal_return:\\n\"\n+    \"  .cfi_startproc\\n\"\n+    \"  .cfi_signal_frame\\n\"\n+    // Mark as end of stack until frame is set up\n+    \"  .cfi_undefined 1\\n\"\n+    // eax points to signal_ctx_pc in ptls (followed by signal_ctx_sp, signal_ctx_fptr, signal_ctx_arg)\n+    \"  pushl (%eax)\\n\"        // push pc (signal_ctx_pc)\n+    \"  pushl 4(%eax)\\n\"       // push sp (signal_ctx_sp)\n+    // stack layout: [sp, pc] (pc at higher address, like return address after call)\n+    \"  .cfi_def_cfa %esp, 4\\n\"\n+    \"  .cfi_offset %eip, 0\\n\"  // previous %eip at CFA+0 (pc slot at esp+4)\n+    \"  .cfi_offset %esp, -4\\n\" // previous %esp at CFA-4 (sp slot at esp+0)\n+    \"  pushl 8(%eax)\\n\"       // push fptr (signal_ctx_fptr)\n+    \"  .cfi_def_cfa %esp, 8\\n\"\n+    \"  movl 12(%eax), %eax\\n\" // restore original eax from signal_ctx_arg\n+    \"  subl $4, %esp\\n\"       // align stack to 16 bytes\n+    \"  .cfi_def_cfa %esp, 12\\n\"\n+    \"  calll *4(%esp)\\n\"      // call fptr\n+    \"  ud2\\n\"                 // unreachable\n+    \"  .cfi_endproc\\n\"\n+    \"  .size jl_fake_signal_return, .-jl_fake_signal_return\\n\"\n+);\n+#elif (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && defined(_CPU_AARCH64_)\n+__asm__(\n+    \"  .type jl_fake_signal_return, @function\\n\"\n+    \"jl_fake_signal_return:\\n\"\n+    \"  .cfi_startproc\\n\"\n+    \"  .cfi_signal_frame\\n\"\n+    // Mark as end of stack until frame is set up\n+    \"  .cfi_undefined 1\\n\"\n+    // x0 points to signal_ctx_pc in ptls (followed by signal_ctx_sp, signal_ctx_fptr, signal_ctx_arg)\n+    \"  ldp x1, x2, [x0]\\n\"      // load pc (x1) and sp (x2)\n+    \"  stp x2, x1, [sp, #-16]!\\n\" // push sp and pc (sp at lower addr, pc at higher addr)\n+    // stack layout: [sp, pc] (pc at higher address, like return address after call)\n+    \"  .cfi_def_cfa sp, 16\\n\"\n+    \"  .cfi_offset lr, -8\\n\"   // previous lr (pc) at CFA-8 (pc slot at sp+8)\n+    \"  .cfi_offset sp, -16\\n\"  // previous sp at CFA-16 (sp slot at sp+0)\n+    // This is not quite valid, since the AArch64 DWARF spec lacks the ability to define how to restore the LR register correctly,\n+    // so normally libunwind implementations on linux detect this function specially and hack around the invalid info:\n+    // https://github.com/llvm/llvm-project/commit/c82deed6764cbc63966374baf9721331901ca958\n+    \"  ldp x1, x2, [x0, #16]\\n\" // load fptr (x1) and saved x0 (x2)\n+    \"  mov x0, x2\\n\"           // restore original x0\n+    \"  blr x1\\n\"               // call fptr\n+    \"  brk #1\\n\"               // unreachable\n+    \"  .cfi_endproc\\n\"\n+    \"  .size jl_fake_signal_return, .-jl_fake_signal_return\\n\"\n+);\n+#else\n+extern void JL_NORETURN jl_fake_signal_return(void)\n+{\n+    CFI_NORETURN\n+    abort();\n+}\n+#endif\n+\n static inline uintptr_t jl_get_rsp_from_ctx(const void *_ctx)\n {\n #if defined(_OS_LINUX_) && defined(_CPU_X86_64_)\n@@ -123,46 +212,79 @@ JL_NO_ASAN static void jl_call_in_ctx(jl_ptls_t ptls, void (*fptr)(void), int si\n     // will not be part of the validation...\n     uintptr_t rsp = jl_get_rsp_from_ctx(_ctx);\n     rsp = (rsp - 256) & ~(uintptr_t)15; // redzone and re-alignment\n+    assert(rsp % 16 == 0);\n #if defined(_OS_LINUX_) && defined(_CPU_X86_64_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    rsp -= sizeof(void*);\n-    *(uintptr_t*)rsp = 0;\n-    ctx->uc_mcontext.gregs[REG_RSP] = rsp;\n-    ctx->uc_mcontext.gregs[REG_RIP] = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->uc_mcontext.gregs[REG_RIP];\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.gregs[REG_RSP];\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.gregs[REG_RDI];\n+    ctx->uc_mcontext.gregs[REG_RSP] = rsp; // set stack pointer\n+    ctx->uc_mcontext.gregs[REG_RDI] = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx\n+    ctx->uc_mcontext.gregs[REG_RIP] = (uintptr_t)&jl_fake_signal_return; // \"call\" jl_fake_signal_return\n #elif defined(_OS_FREEBSD_) && defined(_CPU_X86_64_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    rsp -= sizeof(void*);\n-    *(uintptr_t*)rsp = 0;\n-    ctx->uc_mcontext.mc_rsp = rsp;\n-    ctx->uc_mcontext.mc_rip = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->uc_mcontext.mc_rip;\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.mc_rsp;\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.mc_rdi;\n+    ctx->uc_mcontext.mc_rsp = rsp; // set stack pointer\n+    ctx->uc_mcontext.mc_rdi = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx\n+    ctx->uc_mcontext.mc_rip = (uintptr_t)&jl_fake_signal_return; // \"call\" jl_fake_signal_return\n #elif defined(_OS_LINUX_) && defined(_CPU_X86_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    rsp -= sizeof(void*);\n-    *(uintptr_t*)rsp = 0;\n-    ctx->uc_mcontext.gregs[REG_ESP] = rsp;\n-    ctx->uc_mcontext.gregs[REG_EIP] = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->uc_mcontext.gregs[REG_EIP];\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.gregs[REG_ESP];\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.gregs[REG_EAX];\n+    ctx->uc_mcontext.gregs[REG_ESP] = rsp; // set stack pointer\n+    ctx->uc_mcontext.gregs[REG_EAX] = (uintptr_t)&ptls->signal_ctx_pc; // set eax to point to signal_ctx\n+    ctx->uc_mcontext.gregs[REG_EIP] = (uintptr_t)&jl_fake_signal_return; // \"call\" jl_fake_signal_return\n #elif defined(_OS_FREEBSD_) && defined(_CPU_X86_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    rsp -= sizeof(void*);\n-    *(uintptr_t*)rsp = 0;\n-    ctx->uc_mcontext.mc_esp = rsp;\n-    ctx->uc_mcontext.mc_eip = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->uc_mcontext.mc_eip;\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.mc_esp;\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.mc_eax;\n+    ctx->uc_mcontext.mc_esp = rsp; // set stack pointer\n+    ctx->uc_mcontext.mc_eax = (uintptr_t)&ptls->signal_ctx_pc; // set eax to point to signal_ctx\n+    ctx->uc_mcontext.mc_eip = (uintptr_t)&jl_fake_signal_return; // \"call\" jl_fake_signal_return\n #elif defined(_OS_OPENBSD_) && defined(_CPU_X86_64_)\n     struct sigcontext *ctx = (struct sigcontext *)_ctx;\n-    rsp -= sizeof(void*);\n-    *(uintptr_t*)rsp = 0;\n-    ctx->sc_rsp = rsp;\n-    ctx->sc_rip = fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->sc_rip;\n+    ptls->signal_ctx_sp = ctx->sc_rsp;\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->sc_rdi;\n+    ctx->sc_rsp = rsp; // set stack pointer\n+    ctx->sc_rdi = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx\n+    ctx->sc_rip = (uintptr_t)&jl_fake_signal_return; // \"call\" jl_fake_signal_return\n #elif defined(_OS_LINUX_) && defined(_CPU_AARCH64_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    ctx->uc_mcontext.sp = rsp;\n-    ctx->uc_mcontext.regs[29] = 0; // Clear link register (x29)\n-    ctx->uc_mcontext.pc = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = (uintptr_t)ctx->uc_mcontext.pc;\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.sp;\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.regs[0];\n+    ctx->uc_mcontext.sp = rsp; // sp\n+    ctx->uc_mcontext.regs[0] = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx\n+    ctx->uc_mcontext.pc = (uint64_t)&jl_fake_signal_return; // pc\n+    ctx->uc_mcontext.regs[30] = 0; // clear lr (x30)\n #elif defined(_OS_FREEBSD_) && defined(_CPU_AARCH64_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    ctx->uc_mcontext.mc_gpregs.gp_sp = rsp;\n-    ctx->uc_mcontext.mc_gpregs.gp_x[29] = 0; // Clear link register (x29)\n-    ctx->uc_mcontext.mc_gpregs.gp_elr = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->uc_mcontext.mc_gpregs.gp_elr;\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.mc_gpregs.gp_sp;\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.mc_gpregs.gp_x[0];\n+    ctx->uc_mcontext.mc_gpregs.gp_sp = rsp; // set stack pointer\n+    ctx->uc_mcontext.mc_gpregs.gp_x[0] = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx\n+    ctx->uc_mcontext.mc_gpregs.gp_elr = (uintptr_t)&jl_fake_signal_return; // pc\n+    ctx->uc_mcontext.mc_gpregs.gp_lr = 0; // clear lr (x30)\n #elif defined(_OS_LINUX_) && defined(_CPU_ARM_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n     uintptr_t target = (uintptr_t)fptr;\n@@ -549,9 +671,8 @@ static void jl_try_deliver_sigint(void)\n // Write only by signal handling thread, read only by main thread\n // no sync necessary.\n static int thread0_exit_signo = 0;\n-static void JL_NORETURN jl_exit_thread0_cb(void)\n+static void jl_exit_thread0_cb(void)\n {\n-CFI_NORETURN\n     jl_atomic_fetch_add(&jl_gc_disable_counter, -1);\n     jl_fprint_critical_error(ios_safe_stderr, thread0_exit_signo, 0, NULL, jl_current_task);\n     jl_atexit_hook(128);"
    },
    {
      "sha": "79cb05e86e35445e7bbee64c1bfec6f7ad1fb88b",
      "filename": "stdlib/Artifacts/src/Artifacts.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 2,
      "changes": 11,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FArtifacts%2Fsrc%2FArtifacts.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FArtifacts%2Fsrc%2FArtifacts.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FArtifacts%2Fsrc%2FArtifacts.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -16,6 +16,13 @@ using Base.TOML: TOML\n export artifact_exists, artifact_path, artifact_meta, artifact_hash,\n        select_downloadable_artifacts, find_artifacts_toml, @artifact_str\n \n+const _artifacts_world_age = Ref{UInt}(typemax(UInt))\n+\n+function __init__()\n+    _artifacts_world_age[] = Base.get_world_counter()\n+    nothing\n+end\n+\n \"\"\"\n     parse_toml(path::String)\n \n@@ -403,7 +410,7 @@ function artifact_meta(name::String, artifact_dict::Dict, artifacts_toml::String\n         dl_dict = Dict{Platform,Dict{String,Any}}()\n         for x in meta\n             x = x::Dict{String, Any}\n-            dl_dict[unpack_platform(x, name, artifacts_toml)] = x\n+            dl_dict[unpack_platform(x, name, artifacts_toml)::Platform] = x\n         end\n         meta = select_platform(dl_dict, platform)\n     # If it's NOT a dict, complain\n@@ -543,7 +550,7 @@ function jointail(dir, tail)\n end\n \n function _artifact_str(__module__, artifacts_toml, name, path_tail, artifact_dict, hash, platform, ::Val{LazyArtifacts}) where LazyArtifacts\n-    world = Base._require_world_age[]\n+    world = _artifacts_world_age[]\n     if world == typemax(UInt)\n         world = Base.get_world_counter()\n     end"
    },
    {
      "sha": "7c6edcd2fa8f8abb9683838dc8f8f07afb2de340",
      "filename": "stdlib/Libdl/test/runtests.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FLibdl%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FLibdl%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FLibdl%2Ftest%2Fruntests.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -339,6 +339,19 @@ end\n     libname = LazyLibraryPath(private_libdir, \"libccalllazyfoo.$(Libdl.dlext)\")\n     lazy_name_lazy_lib = LazyLibrary(libname)\n     @test dlpath(lazy_name_lazy_lib) == realpath(string(libname))\n+\n+    # Test parallel loading doesn't return C_NULL (issue #60378)\n+    script = \"\"\"\n+    using Libdl\n+    ll = LazyLibrary(ARGS[1])\n+    handles = Vector{Ptr{Cvoid}}(undef, 10)\n+    @sync for i in 1:10\n+        Threads.@spawn handles[i] = dlopen(ll)\n+    end\n+    @assert all(h -> h != C_NULL, handles) \"Some handles were C_NULL\"\n+    @assert all(h -> h == handles[1], handles) \"Handles were not all equal\"\n+    \"\"\"\n+    @test success(run(`$(Base.julia_cmd()) -t4 -e $script $lclf_path`))\n end\n \n @testset \"Docstrings\" begin"
    },
    {
      "sha": "e01f8f9cd9fa6594d061d6c981598b0e5572fe4a",
      "filename": "stdlib/LinearAlgebra.version",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FLinearAlgebra.version",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FLinearAlgebra.version",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FLinearAlgebra.version?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -1,4 +1,4 @@\n LINEARALGEBRA_BRANCH = release-1.13\n-LINEARALGEBRA_SHA1 = 7e11b5e1b474ff742fb55f420631964b60158fe6\n+LINEARALGEBRA_SHA1 = 47864521739992c57be3138128458ecf7d339567\n LINEARALGEBRA_GIT_URL := https://github.com/JuliaLang/LinearAlgebra.jl.git\n LINEARALGEBRA_TAR_URL = https://api.github.com/repos/JuliaLang/LinearAlgebra.jl/tarball/$1"
    },
    {
      "sha": "d585ec8167aa498bdd90ba712a16aca32cf5c4fd",
      "filename": "stdlib/Logging/test/runtests.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FLogging%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FLogging%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FLogging%2Ftest%2Fruntests.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -19,6 +19,13 @@ macro customlog(exs...) Base.CoreLogging.logmsg_code((Base.CoreLogging.@_sourcei\n     @test :handle_message in names(Logging, all=true)  # non-exported public function\n end\n \n+@testset \"LogLevel compatibility with integers\" begin\n+    @test Logging.Debug + 1000 == Logging.Info\n+    @test Logging.Warn - 1000 == Logging.Info\n+    @test Logging.Info < 500\n+    @test 500 < Logging.Warn\n+end\n+\n @testset \"ConsoleLogger\" begin\n     # First pass log limiting\n     @test min_enabled_level(ConsoleLogger(devnull, Logging.Debug)) == Logging.Debug"
    },
    {
      "sha": "d33a5c9252d5094eef8d88abef0d7a5b53ad2003",
      "filename": "stdlib/MozillaCACerts_jll/Project.toml",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FMozillaCACerts_jll%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FMozillaCACerts_jll%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FMozillaCACerts_jll%2FProject.toml?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -1,7 +1,7 @@\n name = \"MozillaCACerts_jll\"\n uuid = \"14a3606d-f60d-562e-9121-12d972cd8159\"\n # Keep in sync with `deps/libgit2.version`.\n-version = \"2025.11.04\"\n+version = \"2025.12.02\"\n \n [extras]\n Test = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\""
    },
    {
      "sha": "b619002c2a1be4f4cebaa248913f9fb581909eb0",
      "filename": "stdlib/REPL/src/LineEdit.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FLineEdit.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -2179,7 +2179,7 @@ let\n     for (left, right) in bracket_pairs\n         # Left bracket: insert both and move cursor between them\n         bracket_insert_keymap[left] = (s::MIState, o...) -> begin\n-            buf = buffer(s)\n+            local buf = buffer(s)\n             edit_insert(buf, left)\n             if eof(buf) || peek(buf, Char) in right_brackets_ws\n                 edit_insert(buf, right)\n@@ -2190,7 +2190,7 @@ let\n \n         # Right bracket: skip over if next char matches, otherwise insert\n         bracket_insert_keymap[right] = (s::MIState, o...) -> begin\n-            buf = buffer(s)\n+            local buf = buffer(s)\n             if !eof(buf) && peek(buf, Char) == right\n                 edit_move_right(buf)\n             else\n@@ -2203,7 +2203,7 @@ let\n     # Quote characters (need special handling for transpose detection)\n     for quote_char in ('\"', '\\'', '`')\n         bracket_insert_keymap[quote_char] = (s::MIState, o...) -> begin\n-            buf = buffer(s)\n+            local buf = buffer(s)\n             if !eof(buf) && peek(buf, Char) == quote_char\n                 # Skip over closing quote\n                 edit_move_right(buf)\n@@ -2231,15 +2231,14 @@ let\n             repl = Base.active_repl\n             mirepl = isdefined(repl, :mi) ? repl.mi : repl\n             main_mode = mirepl.interface.modes[1]\n-            buf = copy(buffer(s))\n+            local buf = copy(buffer(s))\n             transition(s, main_mode) do\n                 state(s, main_mode).input_buffer = buf\n             end\n             return\n         end\n \n-        buf = buffer(s)\n-        if try_remove_paired_delimiter(buf)\n+        if try_remove_paired_delimiter(buffer(s))\n             return refresh_line(s)\n         end\n         return edit_backspace(s)"
    },
    {
      "sha": "d641853eb4c7a2528f114077f56e7d10a655e9b9",
      "filename": "stdlib/REPL/src/REPL.jl",
      "status": "modified",
      "additions": 31,
      "deletions": 22,
      "changes": 53,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPL.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -611,14 +611,15 @@ function print_response(errio::IO, response, backend::Union{REPLBackendRef,Nothi\n         try\n             if val !== nothing && show_value\n                 Base.sigatomic_end() # allow display to be interrupted\n+                val_to_show = val\n                 val2, iserr = if specialdisplay === nothing\n                     # display calls may require being run on the main thread\n                     call_on_backend(backend) do\n-                        __repl_entry_display(val)\n+                        __repl_entry_display(val_to_show)\n                     end\n                 else\n                     call_on_backend(backend) do\n-                        __repl_entry_display(specialdisplay, val)\n+                        __repl_entry_display(specialdisplay, val_to_show)\n                     end\n                 end\n                 Base.sigatomic_begin()\n@@ -675,21 +676,23 @@ end\n \"\"\"\n function run_repl(repl::AbstractREPL, @nospecialize(consumer = x -> nothing); backend_on_current_task::Bool = true, backend = REPLBackend())\n     backend_ref = REPLBackendRef(backend)\n-    cleanup = @task try\n+    get_module = () -> Base.active_module(repl)\n+    cleanup_task(backend_ref, t) = @task try\n             destroy(backend_ref, t)\n         catch e\n             Core.print(Core.stderr, \"\\nINTERNAL ERROR: \")\n             Core.println(Core.stderr, e)\n             Core.println(Core.stderr, catch_backtrace())\n         end\n-    get_module = () -> Base.active_module(repl)\n     if backend_on_current_task\n         t = @async run_frontend(repl, backend_ref)\n+        cleanup = cleanup_task(backend_ref, t)\n         errormonitor(t)\n         Base._wait2(t, cleanup)\n         start_repl_backend(backend, consumer; get_module)\n     else\n         t = @async start_repl_backend(backend, consumer; get_module)\n+        cleanup = cleanup_task(backend_ref, t)\n         errormonitor(t)\n         Base._wait2(t, cleanup)\n         run_frontend(repl, backend_ref)\n@@ -1187,9 +1190,10 @@ function mode_keymap(julia_prompt::Prompt)\n     AnyDict(\n     '\\b' => function (s::MIState,o...)\n         if isempty(s) || position(LineEdit.buffer(s)) == 0\n-            buf = copy(LineEdit.buffer(s))\n-            transition(s, julia_prompt) do\n-                LineEdit.state(s, julia_prompt).input_buffer = buf\n+            let buf = copy(LineEdit.buffer(s))\n+                transition(s, julia_prompt) do\n+                    LineEdit.state(s, julia_prompt).input_buffer = buf\n+                end\n             end\n         else\n             buf = LineEdit.buffer(s)\n@@ -1328,9 +1332,10 @@ function setup_interface(\n                     for mode in repl.interface.modes\n                         if mode isa LineEdit.Prompt && mode.complete isa REPLExt.PkgCompletionProvider\n                             # pkg mode\n-                            buf = copy(LineEdit.buffer(s))\n-                            transition(s, mode) do\n-                                LineEdit.state(s, mode).input_buffer = buf\n+                            let buf = copy(LineEdit.buffer(s))\n+                                transition(s, mode) do\n+                                    LineEdit.state(s, mode).input_buffer = buf\n+                                end\n                             end\n                         end\n                     end\n@@ -1386,9 +1391,10 @@ function setup_interface(\n     repl_keymap = AnyDict(\n         ';' => function (s::MIState,o...)\n             if isempty(s) || position(LineEdit.buffer(s)) == 0\n-                buf = copy(LineEdit.buffer(s))\n-                transition(s, shell_mode) do\n-                    LineEdit.state(s, shell_mode).input_buffer = buf\n+                let buf = copy(LineEdit.buffer(s))\n+                    transition(s, shell_mode) do\n+                        LineEdit.state(s, shell_mode).input_buffer = buf\n+                    end\n                 end\n             else\n                 edit_insert(s, ';')\n@@ -1397,9 +1403,10 @@ function setup_interface(\n         end,\n         '?' => function (s::MIState,o...)\n             if isempty(s) || position(LineEdit.buffer(s)) == 0\n-                buf = copy(LineEdit.buffer(s))\n-                transition(s, help_mode) do\n-                    LineEdit.state(s, help_mode).input_buffer = buf\n+                let buf = copy(LineEdit.buffer(s))\n+                    transition(s, help_mode) do\n+                        LineEdit.state(s, help_mode).input_buffer = buf\n+                    end\n                 end\n             else\n                 edit_insert(s, '?')\n@@ -1408,9 +1415,10 @@ function setup_interface(\n         end,\n         ']' => function (s::MIState,o...)\n             if isempty(s) || position(LineEdit.buffer(s)) == 0\n-                buf = copy(LineEdit.buffer(s))\n-                transition(s, dummy_pkg_mode) do\n-                    LineEdit.state(s, dummy_pkg_mode).input_buffer = buf\n+                let buf = copy(LineEdit.buffer(s))\n+                    transition(s, dummy_pkg_mode) do\n+                        LineEdit.state(s, dummy_pkg_mode).input_buffer = buf\n+                    end\n                 end\n                 # load Pkg on another thread if available so that typing in the dummy Pkg prompt\n                 # isn't blocked, but instruct the main REPL task to do the transition via s.async_channel\n@@ -1422,9 +1430,10 @@ function setup_interface(\n                                 LineEdit.mode(s) === dummy_pkg_mode || return :ok\n                                 for mode in repl.interface.modes\n                                     if mode isa LineEdit.Prompt && mode.complete isa REPLExt.PkgCompletionProvider\n-                                        buf = copy(LineEdit.buffer(s))\n-                                        transition(s, mode) do\n-                                            LineEdit.state(s, mode).input_buffer = buf\n+                                        let buf = copy(LineEdit.buffer(s))\n+                                            transition(s, mode) do\n+                                                LineEdit.state(s, mode).input_buffer = buf\n+                                            end\n                                         end\n                                         if !isempty(s)\n                                             @invokelatest(LineEdit.check_show_hint(s))"
    },
    {
      "sha": "a0470ec91a57c34f8742c58fad5f289453559c9e",
      "filename": "stdlib/REPL/src/REPLCompletions.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -210,14 +210,15 @@ function complete_symbol!(suggestions::Vector{Completion},\n     end\n \n     if @isdefined(mod) # lookup names available within the module\n-        let modname = nameof(mod),\n-            is_main = mod===Main\n+        let mod_for_check = mod,\n+            modname = nameof(mod_for_check),\n+            is_main = mod_for_check === Main\n             append_filtered_mod_names!(suggestions, mod, name, complete_internal_only) do s::Symbol\n-                if Base.isdeprecated(mod, s)\n+                if Base.isdeprecated(mod_for_check, s)\n                     return false\n                 elseif s === modname\n                     return false # exclude `Main.Main.Main`, etc.\n-                elseif complete_modules_only && !completes_module(mod, s)\n+                elseif complete_modules_only && !completes_module(mod_for_check, s)\n                     return false\n                 elseif is_main && s === :MainInclude\n                     return false\n@@ -1021,8 +1022,8 @@ function completions(string::String, pos::Int, context_module::Module=Main, shif\n         if obj !== nothing\n             # Skip leading whitespace inside brackets.\n             i = @something findnext(!isspace, string, first(key)) nextind(string, last(key))\n-            key = i:last(key)\n-            s = string[intersect(key, 1:pos)]\n+            key = intersect(i:last(key), 1:pos)\n+            s = string[key]\n             matches = find_dict_matches(obj, s)\n             length(matches) == 1 && !closed && (matches[1] *= ']')\n             if length(matches) > 0\n@@ -1047,7 +1048,8 @@ function completions(string::String, pos::Int, context_module::Module=Main, shif\n     #  \"~/example.txt TAB => \"/home/user/example.txt\"\n     r, closed = find_str(cur)\n     if r !== nothing\n-        s = do_string_unescape(string[intersect(r, 1:pos)])\n+        r = intersect(r, 1:pos)\n+        s = do_string_unescape(string[r])\n         ret, success = complete_path_string(s, hint; string_escape=true,\n                                             dirsep=Sys.iswindows() ? '\\\\' : '/')\n         if length(ret) == 1 && !closed && close_path_completion(ret[1].path)\n@@ -1090,8 +1092,8 @@ function completions(string::String, pos::Int, context_module::Module=Main, shif\n         # Keyword argument completion:\n         #   foo(ar TAB   => keyword arguments like `arg1=`\n         elseif kind(cur) == K\"Identifier\"\n-            r = char_range(cur)\n-            s = string[intersect(r, 1:pos)]\n+            r = intersect(char_range(cur), 1:pos)\n+            s = string[r]\n             # Return without adding more suggestions if kwargs only\n             complete_keyword_argument!(suggestions, e, s, context_module, arg_pos; shift) &&\n                 return sort_suggestions(), r, true\n@@ -1379,9 +1381,10 @@ function complete_path_string(path, hint::Bool=false;\n \n     # Expand '~' if the user hits TAB on a path ending in '/'.\n     expanded && (hint || path != dir * \"/\") && (dir = contractuser(dir))\n+    local dir_for_paths = dir\n \n     map!(paths) do c::PathCompletion\n-        p = joinpath_withsep(dir, c.path; dirsep)\n+        p = joinpath_withsep(dir_for_paths, c.path; dirsep)\n         PathCompletion(escape(p))\n     end\n     return sort!(paths, by=p->p.path), success"
    },
    {
      "sha": "9e56afc7f9f773f5b999378c4145edca1f10325f",
      "filename": "stdlib/REPL/src/docview.jl",
      "status": "modified",
      "additions": 24,
      "deletions": 22,
      "changes": 46,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FREPL%2Fsrc%2Fdocview.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FREPL%2Fsrc%2Fdocview.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2Fdocview.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -530,26 +530,27 @@ function repl_latex(io::IO, s0::String)\n         print(io, \"\\\"\")\n         printstyled(io, s, color=:cyan)\n         print(io, \"\\\" can be typed by \")\n-        state::Char = '\\0'\n+        s_to_print = s\n         with_output_color(:cyan, io) do io\n-            for c in s\n+            state::Char = '\\0'\n+            for c in s_to_print\n                 cstr = string(c)\n                 if haskey(symbols_latex, cstr)\n-                    latex = symbols_latex[cstr]\n-                    if length(latex) == 3 && latex[2] in ('^','_')\n+                    latex_symbol = symbols_latex[cstr]\n+                    if length(latex_symbol) == 3 && latex_symbol[2] in ('^','_')\n                         # coalesce runs of sub/superscripts\n-                        if state != latex[2]\n+                        if state != latex_symbol[2]\n                             '\\0' != state && print(io, \"<tab>\")\n-                            print(io, latex[1:2])\n-                            state = latex[2]\n+                            print(io, latex_symbol[1:2])\n+                            state = latex_symbol[2]\n                         end\n-                        print(io, latex[3])\n+                        print(io, latex_symbol[3])\n                     else\n                         if '\\0' != state\n                             print(io, \"<tab>\")\n                             state = '\\0'\n                         end\n-                        print(io, latex, \"<tab>\")\n+                        print(io, latex_symbol, \"<tab>\")\n                     end\n                 else\n                     if '\\0' != state\n@@ -600,13 +601,14 @@ function _repl(x, brief::Bool=true, mod::Module=Main, internal_accesses::Union{N\n                     if kwarg isa Symbol\n                         kwarg = :($kwarg::Any)\n                     elseif isexpr(kwarg, :kw)\n-                        lhs = kwarg.args[1]\n-                        rhs = kwarg.args[2]\n-                        if lhs isa Symbol\n-                            if rhs isa Symbol\n-                                kwarg.args[1] = :($lhs::(@isdefined($rhs) ? typeof($rhs) : Any))\n-                            else\n-                                kwarg.args[1] = :($lhs::typeof($rhs))\n+                        let kw_lhs = kwarg.args[1],\n+                            kw_rhs = kwarg.args[2]\n+                            if kw_lhs isa Symbol\n+                                if kw_rhs isa Symbol\n+                                    kwarg.args[1] = :($kw_lhs::(@isdefined($kw_rhs) ? typeof($kw_rhs) : Any))\n+                                else\n+                                    kwarg.args[1] = :($kw_lhs::typeof($kw_rhs))\n+                                end\n                             end\n                         end\n                     end\n@@ -616,13 +618,13 @@ function _repl(x, brief::Bool=true, mod::Module=Main, internal_accesses::Union{N\n                 if kwargs === nothing\n                     kwargs = Any[]\n                 end\n-                lhs = arg.args[1]\n-                rhs = arg.args[2]\n-                if lhs isa Symbol\n-                    if rhs isa Symbol\n-                        arg.args[1] = :($lhs::(@isdefined($rhs) ? typeof($rhs) : Any))\n+                arg_lhs = arg.args[1]\n+                arg_rhs = arg.args[2]\n+                if arg_lhs isa Symbol\n+                    if arg_rhs isa Symbol\n+                        arg.args[1] = :($arg_lhs::(@isdefined($arg_rhs) ? typeof($arg_rhs) : Any))\n                     else\n-                        arg.args[1] = :($lhs::typeof($rhs))\n+                        arg.args[1] = :($arg_lhs::typeof($arg_rhs))\n                     end\n                 end\n                 push!(kwargs, arg)"
    },
    {
      "sha": "47c4fd8047b8712c628528a2f5a57c632296d5c8",
      "filename": "stdlib/REPL/test/replcompletions.jl",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FREPL%2Ftest%2Freplcompletions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/stdlib%2FREPL%2Ftest%2Freplcompletions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Freplcompletions.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -1492,6 +1492,23 @@ mktempdir() do path\n         @test \"$(path_expected)$(sep)foo_dir$(sep)\" in c\n         @test \"$(path_expected)$(sep)foo_file.txt\" in c\n     end\n+\n+    # Issue #60444: path completion should not delete text after the string (e.g. indexing)\n+    let (c, r, res) = test_complete_pos(\"f(\\\"$(path)$(sep)foo|\\\")\")\n+        @test res\n+        @test length(c) == 2\n+        @test \"$(path_expected)$(sep)foo_dir$(sep)\" in c\n+        @test \"$(path_expected)$(sep)foo_file.txt\" in c\n+    end\n+    let (c, r, res) = test_complete_pos(\"f(\\\"$(path)$(sep)foo|\\\")[1]\")\n+        @test res\n+        @test length(c) == 2\n+        @test \"$(path_expected)$(sep)foo_dir$(sep)\" in c\n+        @test \"$(path_expected)$(sep)foo_file.txt\" in c\n+        # Range should end at cursor position, not overwrite \")[1]\"\n+        pos = findfirst('|', \"f(\\\"$(path)$(sep)foo|\\\")[1]\") - 1\n+        @test last(r) == pos\n+    end\n end\n \n if Sys.iswindows()\n@@ -1644,6 +1661,14 @@ test_dict_completion(\"test_repl_comp_customdict\")\n     let s = \"test_dict_no_length[\"\n         @test REPLCompletions.completions(s, sizeof(s), Main.CompletionFoo) isa Tuple\n     end\n+\n+    # Issue #60444: completing dict keys should not overwrite input after cursor\n+    let s = \"test_dict[\\\"ab|c\\\"]\"\n+        c, r = test_complete_context_pos(s, Main.CompletionFoo)\n+        @test \"\\\"abc\\\"\" in c\n+        @test \"\\\"abcd\\\"\" in c\n+        @test r == 11:13  # range ends at cursor, not at end of key\n+    end\n end\n \n @testset \"completion of string/cmd macros (#22577)\" begin\n@@ -1790,6 +1815,13 @@ end\n     @test hasnokwsuggestions(\"CompletionFoo.kwtest5('a', 3, 5, unknownsplat...; xy\")\n     @test hasnokwsuggestions(\"CompletionFoo.kwtest5(3; somek\")\n     =#\n+\n+    # Issue #60444: completing keyword arguments should not overwrite input after cursor\n+    let s = \"CompletionFoo.kwtest3(a; foob|true)\"\n+        c, r = test_complete_pos(s)\n+        @test c == [\"foobar=\"]\n+        @test r == 26:29\n+    end\n end\n \n # Test completion in context"
    },
    {
      "sha": "7ccc56db512425db8305b9ff5a3c77b308d60ef7",
      "filename": "test/misc.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/test%2Fmisc.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/test%2Fmisc.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fmisc.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -1560,6 +1560,9 @@ end\n     @allocated _x = 1+2\n     @test _x === 3\n \n+    # test `@allocated` works for dotted operations\n+    @test (@allocated 1 .+ 1) == 0\n+\n     n, m = 10, 20\n     X = rand(n, m)\n     treshape59278(X, n, m)"
    },
    {
      "sha": "a2af4cd0f5260f781b1ce112e012834cb776062a",
      "filename": "test/sysinfo.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5abf758bb17ae8d469e70a4ed18390fa86073c18/test%2Fsysinfo.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5abf758bb17ae8d469e70a4ed18390fa86073c18/test%2Fsysinfo.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fsysinfo.jl?ref=5abf758bb17ae8d469e70a4ed18390fa86073c18",
      "patch": "@@ -65,9 +65,7 @@ end\n     Base.Sys.CPUinfo(\"Apple M1 Pro\", 2400, 0x00000000026784da, 0x0000000000000000, 0x0000000000fda30e, 0x0000000046a731ea, 0x0000000000000000)\n     Base.Sys.CPUinfo(\"Apple M1 Pro\", 2400, 0x00000000017726c0, 0x0000000000000000, 0x00000000009491de, 0x0000000048134f1e, 0x0000000000000000)]\n \n-    Sys.SC_CLK_TCK, save_SC_CLK_TCK = 100, Sys.SC_CLK_TCK # use platform-independent tick units\n     @test repr(example_cpus[1]) == \"Base.Sys.CPUinfo(\\\"Apple M1 Pro\\\", 2400, 0x000000000d913b08, 0x0000000000000000, 0x0000000005f4243c, 0x00000000352a550a, 0x0000000000000000)\"\n-    @test repr(\"text/plain\", example_cpus[1]) == \"Apple M1 Pro: \\n        speed         user         nice          sys         idle          irq\\n     2400 MHz    2276216 s          0 s     998861 s    8919667 s          0 s\"\n-    @test sprint(Sys.cpu_summary, example_cpus) == \"Apple M1 Pro: \\n       speed         user         nice          sys         idle          irq\\n#1  2400 MHz    2276216 s          0 s     998861 s    8919667 s          0 s\\n#2  2400 MHz    2275576 s          0 s     978101 s    8962204 s          0 s\\n#3  2400 MHz     403386 s          0 s     166224 s   11853624 s          0 s\\n#4  2400 MHz     245859 s          0 s      97367 s   12092250 s          0 s\\n\"\n-    Sys.SC_CLK_TCK = save_SC_CLK_TCK\n+    @test repr(\"text/plain\", example_cpus[1]) == \"Apple M1 Pro: \\n        speed         user         nice          sys         idle          irq\\n     2400 MHz     227622 s          0 s      99886 s     891967 s          0 s  \"\n+    @test sprint(Sys.cpu_summary, example_cpus) == \"Apple M1 Pro: \\n       speed         user         nice          sys         idle          irq\\n#1  2400 MHz     227622 s          0 s      99886 s     891967 s          0 s  \\n#2  2400 MHz     227558 s          0 s      97810 s     896220 s          0 s  \\n#3  2400 MHz      40339 s          0 s      16622 s    1185362 s          0 s  \\n#4  2400 MHz      24586 s          0 s       9737 s    1209225 s          0 s  \\n\"\n end"
    }
  ]
}