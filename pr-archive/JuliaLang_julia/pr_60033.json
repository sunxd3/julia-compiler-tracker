{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60033",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60033/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60033/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60033/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60033",
  "id": 3584472105,
  "node_id": "PR_kwDOABkWpM6xUBfo",
  "number": 60033,
  "title": "Make some tests not fail with uid 0",
  "user": {
    "login": "Keno",
    "id": 1291671,
    "node_id": "MDQ6VXNlcjEyOTE2NzE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1291671?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Keno",
    "html_url": "https://github.com/Keno",
    "followers_url": "https://api.github.com/users/Keno/followers",
    "following_url": "https://api.github.com/users/Keno/following{/other_user}",
    "gists_url": "https://api.github.com/users/Keno/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Keno/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Keno/subscriptions",
    "organizations_url": "https://api.github.com/users/Keno/orgs",
    "repos_url": "https://api.github.com/users/Keno/repos",
    "events_url": "https://api.github.com/users/Keno/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Keno/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-11-04T02:33:14Z",
  "updated_at": "2025-11-04T07:22:19Z",
  "closed_at": "2025-11-04T07:22:17Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60033",
    "html_url": "https://github.com/JuliaLang/julia/pull/60033",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60033.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60033.patch",
    "merged_at": "2025-11-04T07:22:17Z"
  },
  "body": "When running as UID 0 (system root, but also container root in various sandboxing technologies), the system ignores unix permissions. We have a number of tests that assume that a 000 mode means the file is not readable. Adjust these tests appropriately.\r\n\r\nThere are more failures, but I'll look at those in a follow-up.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60033/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60033/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "d8429f39b41b006efb96bfe11eea1456bdf6f391",
      "filename": "stdlib/REPL/test/replcompletions.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/e0e743f725910b8acff4896d5e5c0637481bf272/stdlib%2FREPL%2Ftest%2Freplcompletions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/e0e743f725910b8acff4896d5e5c0637481bf272/stdlib%2FREPL%2Ftest%2Freplcompletions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Freplcompletions.jl?ref=e0e743f725910b8acff4896d5e5c0637481bf272",
      "patch": "@@ -1249,7 +1249,10 @@ let s, c, r\n                 @test s[r] == \"tmp-execu\"\n \n                 c,r = test_scomplete(\"replcompletions-link\")\n-                @test isempty(c)\n+                if !Sys.isunix() || Libc.getuid() != 0\n+                    # Root bypasses permissions\n+                    @test isempty(c)\n+                end\n             end\n         finally\n             # If we don't fix the permissions here, our cleanup fails."
    },
    {
      "sha": "92e85125c845137e09ba062c9edd9bae6004620a",
      "filename": "test/file.jl",
      "status": "modified",
      "additions": 50,
      "deletions": 21,
      "changes": 71,
      "blob_url": "https://github.com/JuliaLang/julia/blob/e0e743f725910b8acff4896d5e5c0637481bf272/test%2Ffile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/e0e743f725910b8acff4896d5e5c0637481bf272/test%2Ffile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Ffile.jl?ref=e0e743f725910b8acff4896d5e5c0637481bf272",
      "patch": "@@ -260,13 +260,14 @@ no_error_logging(f::Function) =\n         @test TEMP_CLEANUP_MAX[] == 3\n         local t, f\n         temps = String[]\n+        npending = 0\n         # mktemp is normally cleaned up on completion\n         mktemp(d) do path, _\n             @test isfile(path)\n             t = path\n         end\n         @test !ispath(t)\n-        @test length(TEMP_CLEANUP) == 0\n+        @test length(TEMP_CLEANUP) == npending\n         @test TEMP_CLEANUP_MAX[] == 3\n         # mktemp when cleanup is prevented\n         no_error_logging() do\n@@ -277,19 +278,26 @@ no_error_logging(f::Function) =\n                 t = path\n             end\n         end\n+        # Make deleteable again\n         chmod(d, 0o700)\n         close(f)\n-        @test isfile(t)\n-        @test length(TEMP_CLEANUP) == 1\n-        @test TEMP_CLEANUP_MAX[] == 3\n-        push!(temps, t)\n+        if Libc.geteuid() == 0\n+            # Root can delete anything\n+            @test !isfile(t)\n+        else\n+            npending += 1\n+            @test isfile(t)\n+            @test length(TEMP_CLEANUP) == npending\n+            @test TEMP_CLEANUP_MAX[] == 3\n+            push!(temps, t)\n+        end\n         # mktempdir is normally cleaned up on completion\n         mktempdir(d) do path\n             @test isdir(path)\n             t = path\n         end\n         @test !ispath(t)\n-        @test length(TEMP_CLEANUP) == 1\n+        @test length(TEMP_CLEANUP) == npending\n         @test TEMP_CLEANUP_MAX[] == 3\n         # mktempdir when cleanup is prevented\n         no_error_logging() do\n@@ -301,16 +309,24 @@ no_error_logging(f::Function) =\n                 t = path\n             end\n         end\n+        # Make deleteable again\n         chmod(d, 0o700)\n         close(f)\n-        @test isdir(t)\n-        @test length(TEMP_CLEANUP) == 2\n-        @test TEMP_CLEANUP_MAX[] == 3\n-        push!(temps, t)\n+        if Libc.geteuid() == 0\n+            # Root can delete anything\n+            @test !isdir(t)\n+        else\n+            @test isdir(t)\n+            npending += 1\n+            @test length(TEMP_CLEANUP) == npending\n+            @test TEMP_CLEANUP_MAX[] == 3\n+            push!(temps, t)\n+        end\n         # make one more temp file\n         t = mktemp()[1]\n+        npending += 1\n         @test isfile(t)\n-        @test length(TEMP_CLEANUP) == 3\n+        @test length(TEMP_CLEANUP) == npending\n         @test TEMP_CLEANUP_MAX[] == 3\n         # nothing has been deleted yet\n         for t in temps\n@@ -319,8 +335,9 @@ no_error_logging(f::Function) =\n         # another temp file triggers purge\n         t = mktempdir()\n         @test isdir(t)\n-        @test length(TEMP_CLEANUP) == 2\n-        @test TEMP_CLEANUP_MAX[] == 4\n+        npending = 2\n+        @test length(TEMP_CLEANUP) == npending\n+        @test TEMP_CLEANUP_MAX[] == (Libc.geteuid() == 0 ? 3 : 4)\n         # now all the temps are gone\n         for t in temps\n             @test !ispath(t)\n@@ -420,6 +437,9 @@ function test_stat_error(stat::Function, pth)\n     if stat === lstat && !(pth isa AbstractString)\n         return # no lstat for fd handles\n     end\n+    if Libc.geteuid() == 0\n+        return # root bypasses permission checks\n+    end\n     ex = try; stat(pth); false; catch ex; ex; end::Base.IOError\n     @test ex.code == (pth isa AbstractString ? Base.UV_EACCES : Base.UV_EBADF)\n     pth isa AbstractString || (pth = Base.INVALID_OS_HANDLE)\n@@ -550,16 +570,23 @@ function multiple_uv_errors(pfx::AbstractString, codes::AbstractVector{<:Integer\n     return [Base._UVError(pfx, code) for code in codes]\n end\n \n+read_linux_id_map_max(file) = parse(Int, split(strip(read(file, String)), \" \", keepempty = false)[end]) % Cint\n if !Sys.iswindows()\n     # chown will give an error if the user does not have permissions to change files\n     uid = Libc.geteuid()\n     @test stat(file).uid == uid\n     @test uid == Libc.getuid()\n+    maxuid = maxgid = -1\n+    # Containers may have restricted uid/gid ranges\n+    if Sys.islinux() && isfile(\"/proc/self/uid_map\")\n+        maxuid = read_linux_id_map_max(\"/proc/self/uid_map\")\n+        maxgid = read_linux_id_map_max(\"/proc/self/gid_map\")\n+    end\n     if uid == 0 # root user\n-        chown(file, -2, -1)  # Change the file owner to nobody\n-        @test stat(file).uid != 0\n-        chown(file, 0, -2)  # Change the file group to nogroup (and owner back to root)\n-        @test stat(file).gid != 0\n+        chown(file, maxuid-1, -1)  # Change the file owner to nobody\n+        @test maxuid == 1 || stat(file).uid != 0\n+        chown(file, 0, maxgid-1)  # Change the file group to nogroup (and owner back to root)\n+        @test maxgid == 1 || stat(file).gid != 0\n         @test stat(file).uid == 0\n         @test chown(file, -1, 0) == file\n         @test stat(file).gid == 0\n@@ -1864,8 +1891,10 @@ if !Sys.iswindows()\n             @test !isdir(joinpath(d, \"empty_outer\"))\n \n             # But a non-empty directory is not\n-            @test_throws Base.IOError rm(joinpath(d, \"nonempty\"); recursive=true)\n-            chmod(joinpath(d, \"nonempty\"), 0o777)\n+            if Libc.geteuid() != 0 # root can override permissions\n+                @test_throws Base.IOError rm(joinpath(d, \"nonempty\"); recursive=true)\n+                chmod(joinpath(d, \"nonempty\"), 0o777)\n+            end\n             rm(joinpath(d, \"nonempty\"); recursive=true, force=true)\n             @test !isdir(joinpath(d, \"nonempty\"))\n         end\n@@ -2032,10 +2061,10 @@ end\n         chmod(fpath, 0o444)\n         @test !Sys.isexecutable(fpath)\n         @test Sys.isreadable(fpath)\n-        @test !Sys.iswritable(fpath)\n+        @test !Sys.iswritable(fpath) skip=Libc.getuid() == 0\n         chmod(fpath, 0o244)\n         @test !Sys.isexecutable(fpath)\n-        @test !Sys.isreadable(fpath) skip=Sys.iswindows()\n+        @test !Sys.isreadable(fpath) skip=(Sys.iswindows() || Libc.getuid() == 0)\n         @test Sys.iswritable(fpath) skip=Sys.iswindows()\n \n         # Ensure that, on Windows, where inheritance is default,"
    },
    {
      "sha": "b6fd0378a945bb0aa9dec3a26ff6509ca7da0295",
      "filename": "test/precompile.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/e0e743f725910b8acff4896d5e5c0637481bf272/test%2Fprecompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/e0e743f725910b8acff4896d5e5c0637481bf272/test%2Fprecompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fprecompile.jl?ref=e0e743f725910b8acff4896d5e5c0637481bf272",
      "patch": "@@ -2249,7 +2249,7 @@ precompile_test_harness(\"Issue #52063\") do load_path\n         @test e isa SystemError\n         @test e.prefix == \"opening file or folder $(repr(fname))\"\n         true\n-    end\n+    end skip = (Sys.isunix() && Libc.geteuid() == 0)\n     dir = mktempdir() do dir\n         @test include_dependency(dir) === nothing\n         chmod(dir, 0x000)\n@@ -2259,7 +2259,7 @@ precompile_test_harness(\"Issue #52063\") do load_path\n             @test e isa SystemError\n             @test e.prefix == \"opening file or folder $(repr(dir))\"\n             true\n-        end\n+        end skip = (Sys.isunix() && Libc.geteuid() == 0)\n         dir\n     end\n     @test try"
    },
    {
      "sha": "f213e48dc73b7fcd0c8b306d38c682071ba2da06",
      "filename": "test/sysinfo.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/e0e743f725910b8acff4896d5e5c0637481bf272/test%2Fsysinfo.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/e0e743f725910b8acff4896d5e5c0637481bf272/test%2Fsysinfo.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fsysinfo.jl?ref=e0e743f725910b8acff4896d5e5c0637481bf272",
      "patch": "@@ -35,7 +35,12 @@ if Sys.isunix()\n         original_path = ENV[\"PATH\"]\n         ENV[\"PATH\"] = string(firstdir, \":\", seconddir, \":\", original_path)\n         try\n-            @test abspath(Base.Sys.which(\"foo\")) == abspath(joinpath(seconddir, \"foo\"))\n+            if Libc.geteuid() == 0\n+                # Root bypasses permission checks\n+                @test abspath(Base.Sys.which(\"foo\")) == abspath(joinpath(firstdir, \"foo\"))\n+            else\n+                @test abspath(Base.Sys.which(\"foo\")) == abspath(joinpath(seconddir, \"foo\"))\n+            end\n         finally\n             # clean up\n             chmod(firstdir, 0o777)"
    }
  ]
}