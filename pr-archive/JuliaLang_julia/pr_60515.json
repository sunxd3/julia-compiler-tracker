{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60515",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60515/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60515/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60515/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60515",
  "id": 3770266164,
  "node_id": "PR_kwDOABkWpM66-WyQ",
  "number": 60515,
  "title": "Fix many instances of `Core.Box` in Base.",
  "user": {
    "login": "KristofferC",
    "id": 1282691,
    "node_id": "MDQ6VXNlcjEyODI2OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1282691?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KristofferC",
    "html_url": "https://github.com/KristofferC",
    "followers_url": "https://api.github.com/users/KristofferC/followers",
    "following_url": "https://api.github.com/users/KristofferC/following{/other_user}",
    "gists_url": "https://api.github.com/users/KristofferC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KristofferC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KristofferC/subscriptions",
    "organizations_url": "https://api.github.com/users/KristofferC/orgs",
    "repos_url": "https://api.github.com/users/KristofferC/repos",
    "events_url": "https://api.github.com/users/KristofferC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KristofferC/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9546926682,
      "node_id": "LA_kwDOABkWpM8AAAACOQqKWg",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/backport%201.13",
      "name": "backport 1.13",
      "color": "699295",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-12-30T13:50:32Z",
  "updated_at": "2026-01-03T21:14:23Z",
  "closed_at": "2026-01-03T21:14:22Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60515",
    "html_url": "https://github.com/JuliaLang/julia/pull/60515",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60515.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60515.patch",
    "merged_at": "2026-01-03T21:14:21Z"
  },
  "body": "Part of https://github.com/JuliaLang/julia/issues/60479.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60515/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60515/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "903fb4f6b68bccdf3b3b959eae474157efccc19c",
      "filename": "base/arrayshow.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Farrayshow.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Farrayshow.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Farrayshow.jl?ref=44cc29c2582715b97f4a16ddb8b6b8f4824f4474",
      "patch": "@@ -295,7 +295,14 @@ function _show_nd(io::IO, @nospecialize(a::AbstractArray), print_matrix::Functio\n                 ii = idxs[i]\n                 ind = tailinds[i]\n                 if length(ind) > 10\n-                    if ii == ind[firstindex(ind)+3] && all(d->idxs[d]==first(tailinds[d]),1:i-1)\n+                    all_first = true\n+                    for d = 1:i-1\n+                        if idxs[d] != first(tailinds[d])\n+                            all_first = false\n+                            break\n+                        end\n+                    end\n+                    if ii == ind[firstindex(ind)+3] && all_first\n                         for j=i+1:nd\n                             szj = length(axs[j+2])\n                             indj = tailinds[j]"
    },
    {
      "sha": "08cd5ce403b85a2d77ae57b6cfe385569978388b",
      "filename": "base/binaryplatforms.jl",
      "status": "modified",
      "additions": 38,
      "deletions": 37,
      "changes": 75,
      "blob_url": "https://github.com/JuliaLang/julia/blob/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Fbinaryplatforms.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Fbinaryplatforms.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fbinaryplatforms.jl?ref=44cc29c2582715b97f4a16ddb8b6b8f4824f4474",
      "patch": "@@ -872,6 +872,42 @@ function get_csl_member(member::Symbol)\n     return nothing\n end\n \n+\n+function _get_libgfortran_path()\n+    # If CompilerSupportLibraries_jll is a stdlib, we can just directly ask for\n+    # the path here, without checking `dllist()`:\n+    libgfortran_path = get_csl_member(:libgfortran_path)\n+    if libgfortran_path !== nothing\n+        return libgfortran_path::String\n+    end\n+\n+    # Otherwise, look for it having already been loaded by something\n+    libgfortran_paths = filter!(x -> occursin(\"libgfortran\", x), Libdl.dllist())\n+    if !isempty(libgfortran_paths)\n+        return first(libgfortran_paths)::String\n+    end\n+\n+    # One day, I hope to not be linking against libgfortran in base Julia\n+    return nothing\n+end\n+\n+function _get_libstdcxx_handle()\n+    # If CompilerSupportLibraries_jll is a stdlib, we can just directly open it\n+    libstdcxx = get_csl_member(:libstdcxx)\n+    if libstdcxx !== nothing\n+        return nothing\n+    end\n+\n+    # Otherwise, look for it having already been loaded by something\n+    libstdcxx_paths = filter!(x -> occursin(\"libstdc++\", x), Libdl.dllist())\n+    if !isempty(libstdcxx_paths)\n+        return Libdl.dlopen(first(libstdcxx_paths), Libdl.RTLD_NOLOAD)::Ptr{Cvoid}\n+    end\n+\n+    # One day, I hope to not be linking against libgfortran in base Julia\n+    return nothing\n+end\n+\n \"\"\"\n     detect_libgfortran_version()\n \n@@ -880,25 +916,7 @@ linked against (if any).  Returns `nothing` if no libgfortran version dependence\n detected.\n \"\"\"\n function detect_libgfortran_version()\n-    function get_libgfortran_path()\n-        # If CompilerSupportLibraries_jll is a stdlib, we can just directly ask for\n-        # the path here, without checking `dllist()`:\n-        libgfortran_path = get_csl_member(:libgfortran_path)\n-        if libgfortran_path !== nothing\n-            return libgfortran_path::String\n-        end\n-\n-        # Otherwise, look for it having already been loaded by something\n-        libgfortran_paths = filter!(x -> occursin(\"libgfortran\", x), Libdl.dllist())\n-        if !isempty(libgfortran_paths)\n-            return first(libgfortran_paths)::String\n-        end\n-\n-        # One day, I hope to not be linking against libgfortran in base Julia\n-        return nothing\n-    end\n-\n-    libgfortran_path = get_libgfortran_path()\n+    libgfortran_path = _get_libgfortran_path()\n     name, version = parse_dl_name_version(libgfortran_path, os())\n     if version === nothing\n         # Even though we complain about this, we allow it to continue in the hopes that\n@@ -922,25 +940,8 @@ it is linked against (if any).  `max_minor_version` is the latest version in the\n 3.4 series of GLIBCXX where the search is performed.\n \"\"\"\n function detect_libstdcxx_version(max_minor_version::Int=30)\n-    function get_libstdcxx_handle()\n-        # If CompilerSupportLibraries_jll is a stdlib, we can just directly open it\n-        libstdcxx = get_csl_member(:libstdcxx)\n-        if libstdcxx !== nothing\n-            return nothing\n-        end\n-\n-        # Otherwise, look for it having already been loaded by something\n-        libstdcxx_paths = filter!(x -> occursin(\"libstdc++\", x), Libdl.dllist())\n-        if !isempty(libstdcxx_paths)\n-            return Libdl.dlopen(first(libstdcxx_paths), Libdl.RTLD_NOLOAD)::Ptr{Cvoid}\n-        end\n-\n-        # One day, I hope to not be linking against libgfortran in base Julia\n-        return nothing\n-    end\n-\n     # Brute-force our way through GLIBCXX_* symbols to discover which version we're linked against\n-    libstdcxx = get_libstdcxx_handle()\n+    libstdcxx = _get_libstdcxx_handle()\n \n     if libstdcxx !== nothing\n         # Try all GLIBCXX versions down to GCC v4.8:"
    },
    {
      "sha": "3ae3a99f82b5aae39f77a75a5f1cb66535dd007f",
      "filename": "base/experimental.jl",
      "status": "modified",
      "additions": 25,
      "deletions": 20,
      "changes": 45,
      "blob_url": "https://github.com/JuliaLang/julia/blob/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Fexperimental.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Fexperimental.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fexperimental.jl?ref=44cc29c2582715b97f4a16ddb8b6b8f4824f4474",
      "patch": "@@ -655,26 +655,7 @@ function wait_with_timeout(c::GenericCondition; first::Bool=false, timeout::Real\n         timer = Timer(timeout)\n         waiter_left = Threads.Atomic{Bool}(false)\n         # start a task to wait on the timer\n-        t = Task() do\n-            try\n-                wait(timer)\n-            catch e\n-                # if the timer was closed, the waiting task has been scheduled; do nothing\n-                e isa EOFError && return\n-            end\n-            dosched = false\n-            lock(c.lock)\n-            # Confirm that the waiting task is still in the wait queue and remove it. If\n-            # the task is not in the wait queue, it must have been notified already so we\n-            # don't do anything here.\n-            if !waiter_left[] && ct.queue === c.waitq\n-                dosched = true\n-                Base.list_deletefirst!(c.waitq, ct)\n-            end\n-            unlock(c.lock)\n-            # send the waiting task a timeout\n-            dosched && schedule(ct, :timed_out)\n-        end\n+        t = _wait_with_timeout_task(c, ct, timer, waiter_left)\n         t.sticky = false\n         Threads._spawn_set_thrpool(t, :interactive)\n         schedule(t)\n@@ -695,6 +676,30 @@ function wait_with_timeout(c::GenericCondition; first::Bool=false, timeout::Real\n     end\n end\n \n+function _wait_with_timeout_task(c::GenericCondition, ct::Task, timer::Timer,\n+    waiter_left::Threads.Atomic{Bool})\n+    return Task() do\n+        try\n+            wait(timer)\n+        catch e\n+            # if the timer was closed, the waiting task has been scheduled; do nothing\n+            e isa EOFError && return\n+        end\n+        dosched = false\n+        lock(c.lock)\n+        # Confirm that the waiting task is still in the wait queue and remove it. If\n+        # the task is not in the wait queue, it must have been notified already so we\n+        # don't do anything here.\n+        if !waiter_left[] && ct.queue === c.waitq\n+            dosched = true\n+            Base.list_deletefirst!(c.waitq, ct)\n+        end\n+        unlock(c.lock)\n+        # send the waiting task a timeout\n+        dosched && schedule(ct, :timed_out)\n+    end\n+end\n+\n \"\"\"\n     Base.Experimental.@reexport using Module\n "
    },
    {
      "sha": "f1080489699374c4ca92c896db2574a541ecc2b2",
      "filename": "base/file.jl",
      "status": "modified",
      "additions": 38,
      "deletions": 36,
      "changes": 74,
      "blob_url": "https://github.com/JuliaLang/julia/blob/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Ffile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Ffile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Ffile.jl?ref=44cc29c2582715b97f4a16ddb8b6b8f4824f4474",
      "patch": "@@ -666,18 +666,18 @@ function temp_cleanup_purge_prelocked(force::Bool)\n end\n \n function temp_cleanup_purge_all()\n-    may_need_gc = false\n+    may_need_gc = Ref(false)\n     @lock TEMP_CLEANUP_LOCK filter!(TEMP_CLEANUP) do (path, asap)\n         try\n             ispath(path) || return false\n-            may_need_gc = true\n+            may_need_gc[] = true\n             return true\n         catch ex\n             ex isa InterruptException && rethrow()\n             return true\n         end\n     end\n-    if may_need_gc\n+    if may_need_gc[]\n         # this is only usually required on Sys.iswindows(), but may as well do it everywhere\n         GC.gc(true)\n     end\n@@ -1187,43 +1187,45 @@ julia> (path, dirs, files) = first(itr)\n ```\n \"\"\"\n function walkdir(path = pwd(); topdown=true, follow_symlinks=false, onerror=throw)\n-    function _walkdir(chnl, path)\n-        tryf(f, p) = try\n-                f(p)\n-            catch err\n-                isa(err, IOError) || rethrow()\n-                try\n-                    onerror(err)\n-                catch err2\n-                    close(chnl, err2)\n-                end\n-                return\n-            end\n-        entries = tryf(_readdirx, path)\n-        entries === nothing && return\n-        dirs = Vector{String}()\n-        files = Vector{String}()\n-        for entry in entries\n-            # If we're not following symlinks, then treat all symlinks as files\n-            if (!follow_symlinks && something(tryf(islink, entry), true)) || !something(tryf(isdir, entry), false)\n-                push!(files, entry.name)\n-            else\n-                push!(dirs, entry.name)\n-            end\n-        end\n+    return Channel{Tuple{String,Vector{String},Vector{String}}}(chnl ->\n+        _walkdir(chnl, path, topdown, follow_symlinks, onerror))\n+end\n \n-        if topdown\n-            push!(chnl, (path, dirs, files))\n-        end\n-        for dir in dirs\n-            _walkdir(chnl, joinpath(path, dir))\n+function _walkdir(chnl, path, topdown, follow_symlinks, onerror)\n+    tryf(f, p) = try\n+            f(p)\n+        catch err\n+            isa(err, IOError) || rethrow()\n+            try\n+                onerror(err)\n+            catch err2\n+                close(chnl, err2)\n+            end\n+            return\n         end\n-        if !topdown\n-            push!(chnl, (path, dirs, files))\n+    entries = tryf(_readdirx, path)\n+    entries === nothing && return\n+    dirs = Vector{String}()\n+    files = Vector{String}()\n+    for entry in entries\n+        # If we're not following symlinks, then treat all symlinks as files\n+        if (!follow_symlinks && something(tryf(islink, entry), true)) || !something(tryf(isdir, entry), false)\n+            push!(files, entry.name)\n+        else\n+            push!(dirs, entry.name)\n         end\n-        nothing\n     end\n-    return Channel{Tuple{String,Vector{String},Vector{String}}}(chnl -> _walkdir(chnl, path))\n+\n+    if topdown\n+        push!(chnl, (path, dirs, files))\n+    end\n+    for dir in dirs\n+        _walkdir(chnl, joinpath(path, dir), topdown, follow_symlinks, onerror)\n+    end\n+    if !topdown\n+        push!(chnl, (path, dirs, files))\n+    end\n+    nothing\n end\n \n function unlink(p::AbstractString)"
    },
    {
      "sha": "4f39c855754fe1c3b63f82fd74fb976c71ff66fe",
      "filename": "base/loading.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "blob_url": "https://github.com/JuliaLang/julia/blob/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Floading.jl?ref=44cc29c2582715b97f4a16ddb8b6b8f4824f4474",
      "patch": "@@ -2858,7 +2858,7 @@ function __require_prelocked(pkg::PkgId, env)\n     path = spec.path\n     set_pkgorigin_version_path(pkg, path)\n \n-    parallel_precompile_attempted = false # being safe to avoid getting stuck in a precompilepkgs loop\n+    parallel_precompile_attempted = Ref(false) # being safe to avoid getting stuck in a precompilepkgs loop\n     reasons = Dict{String,Int}()\n     # attempt to load the module file via the precompile cache locations\n     if JLOptions().use_compiled_modules != 0\n@@ -2900,8 +2900,8 @@ function __require_prelocked(pkg::PkgId, env)\n \n                     unlock(require_lock)\n                     try\n-                        if !generating_output() && !parallel_precompile_attempted && !disable_parallel_precompile && @isdefined(Precompilation)\n-                            parallel_precompile_attempted = true\n+                        if !generating_output() && !parallel_precompile_attempted[] && !disable_parallel_precompile && @isdefined(Precompilation)\n+                            parallel_precompile_attempted[] = true\n                             precompiled = Precompilation.precompilepkgs([pkg]; _from_loading=true, ignore_loaded=false)\n                             # prcompiled returns either nothing, indicating it needs serial precompile,\n                             # or the entry(ies) that it found would be best to load (possibly because it just created it)\n@@ -3526,9 +3526,10 @@ function compilecache(pkg::PkgId, spec::PkgLoadSpec, internal_stderr::IO = stder\n             ocachefile = cache_objects ? ocachefile_from_cachefile(cachefile) : nothing\n \n             # append checksum for so to the end of the .ji file:\n-            crc_so = UInt32(0)\n-            if cache_objects\n-                crc_so = open(_crc32c, tmppath_so, \"r\")\n+            crc_so = if cache_objects\n+                open(_crc32c, tmppath_so, \"r\")\n+            else\n+                UInt32(0)\n             end\n \n             # append extra crc to the end of the .ji file:"
    },
    {
      "sha": "5e9bff46d06a89ba3617d5e450ce0c3271ef2932",
      "filename": "base/precompilation.jl",
      "status": "modified",
      "additions": 51,
      "deletions": 44,
      "changes": 95,
      "blob_url": "https://github.com/JuliaLang/julia/blob/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Fprecompilation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Fprecompilation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fprecompilation.jl?ref=44cc29c2582715b97f4a16ddb8b6b8f4824f4474",
      "patch": "@@ -885,6 +885,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n     n_already_precomp = Ref(0)\n     n_loaded = Ref(0)\n     interrupted = Ref(false)\n+    t_print = Ref{Task}()\n \n     function handle_interrupt(err, in_printloop::Bool)\n         if err isa InterruptException\n@@ -897,7 +898,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n             notify(evt)\n         end\n         notify(first_started)\n-        in_printloop || wait(t_print) # Wait to let the print loop cease first. This makes the printing incorrect, so we shouldn't wait here, but we do anyways.\n+        in_printloop || (isassigned(t_print) && wait(t_print[])) # Wait to let the print loop cease first. This makes the printing incorrect, so we shouldn't wait here, but we do anyways.\n         if err isa InterruptException\n             @lock print_lock begin\n                 println(io, \" Interrupted: Exiting precompilation...\", ansi_cleartoendofline)\n@@ -912,45 +913,8 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n     pkgspidlocked = Dict{PkgConfig,String}()\n     pkg_liveprinted = Ref{Union{Nothing, PkgId}}(nothing)\n \n-    function monitor_std(pkg_config, pipe; single_requested_pkg=false)\n-        local pkg, config = pkg_config\n-        try\n-            local liveprinting = false\n-            local thistaskwaiting = false\n-            while !eof(pipe)\n-                local str = readline(pipe, keep=true)\n-                if single_requested_pkg && (liveprinting || !isempty(str))\n-                    @lock print_lock begin\n-                        if !liveprinting\n-                            liveprinting = true\n-                            pkg_liveprinted[] = pkg\n-                        end\n-                        print(io, ansi_cleartoendofline, str)\n-                    end\n-                end\n-                write(get!(IOBuffer, std_outputs, pkg_config), str)\n-                if thistaskwaiting\n-                    if occursin(\"Waiting for background task / IO / timer\", str)\n-                        thistaskwaiting = true\n-                        !liveprinting && !fancyprint && @lock print_lock begin\n-                            println(io, full_name(ext_to_parent, pkg), color_string(str, Base.warn_color()))\n-                        end\n-                        push!(taskwaiting, pkg_config)\n-                    end\n-                else\n-                    # XXX: don't just re-enable IO for random packages without printing the context for them first\n-                    !liveprinting && !fancyprint && @lock print_lock begin\n-                        print(io, ansi_cleartoendofline, str)\n-                    end\n-                end\n-            end\n-        catch err\n-            err isa InterruptException || rethrow()\n-        end\n-    end\n-\n     ## fancy print loop\n-    t_print = @async begin\n+    t_print[] = @async begin\n         try\n             wait(first_started)\n             (isempty(pkg_queue) || interrupted_or_done[]) && return\n@@ -980,16 +944,18 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                     else\n                         pkg_queue\n                     end\n+                    local i_local = i\n+                    local final_loop_local = final_loop\n                     str_ = sprint() do iostr\n-                        if i > 1\n+                        if i_local > 1\n                             print(iostr, ansi_cleartoend)\n                         end\n                         bar.current = n_done[] - n_already_precomp[]\n                         bar.max = n_total - n_already_precomp[]\n                         # when sizing to the terminal width subtract a little to give some tolerance to resizing the\n                         # window between print cycles\n                         termwidth = (displaysize(io)::Tuple{Int,Int})[2] - 4\n-                        if !final_loop\n+                        if !final_loop_local\n                             s = sprint(io -> show_progress(io, bar; termwidth, carriagereturn=false); context=logio)\n                             print(iostr, Base._truncate_at_width_or_chars(true, s, termwidth), \"\\n\")\n                         end\n@@ -1012,7 +978,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                             elseif started[pkg_config]\n                                 # Offset each spinner animation using the first character in the package name as the seed.\n                                 # If not offset, on larger terminal fonts it looks odd that they all sync-up\n-                                anim_char = anim_chars[(i + Int(dep.name[1])) % length(anim_chars) + 1]\n+                                anim_char = anim_chars[(i_local + Int(dep.name[1])) % length(anim_chars) + 1]\n                                 anim_char_colored = dep in project_deps ? anim_char : color_string(anim_char, :light_black)\n                                 waiting = if haskey(pkgspidlocked, pkg_config)\n                                     who_has_lock = pkgspidlocked[pkg_config]\n@@ -1104,7 +1070,9 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n \n                         # std monitoring\n                         std_pipe = Base.link_pipe!(Pipe(); reader_supports_async=true, writer_supports_async=true)\n-                        t_monitor = @async monitor_std(pkg_config, std_pipe; single_requested_pkg)\n+                        t_monitor = @async _precompilepkgs_monitor_std(pkg_config, std_pipe,\n+                            single_requested_pkg, ext_to_parent, hascolor, std_outputs, taskwaiting,\n+                            pkg_liveprinted, print_lock, io, fancyprint, ansi_cleartoendofline)\n \n                         local name\n                         try\n@@ -1230,7 +1198,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n         end\n     end\n     notify(first_started) # in cases of no-op or !fancyprint\n-    fancyprint && wait(t_print)\n+    fancyprint && isassigned(t_print) && wait(t_print[])\n     quick_exit = any(t -> !istaskdone(t) || istaskfailed(t), tasks) || interrupted[] # all should have finished (to avoid memory corruption)\n     seconds_elapsed = round(Int, (time_ns() - time_start) / 1e9)\n     ndeps = count(values(was_recompiled))\n@@ -1344,6 +1312,45 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n     return collect(String, Iterators.flatten((v for (pkgid, v) in cachepath_cache if pkgid in requested_pkgids)))\n end\n \n+function _precompilepkgs_monitor_std(pkg_config, pipe, single_requested_pkg::Bool,\n+    ext_to_parent, hascolor::Bool, std_outputs, taskwaiting, pkg_liveprinted, print_lock,\n+    io::IOContext, fancyprint::Bool, ansi_cleartoendofline::String)\n+    local pkg, config = pkg_config\n+    try\n+        local liveprinting = false\n+        local thistaskwaiting = false\n+        while !eof(pipe)\n+            local str = readline(pipe, keep=true)\n+            if single_requested_pkg && (liveprinting || !isempty(str))\n+                @lock print_lock begin\n+                    if !liveprinting\n+                        liveprinting = true\n+                        pkg_liveprinted[] = pkg\n+                    end\n+                    print(io, ansi_cleartoendofline, str)\n+                end\n+            end\n+            write(get!(IOBuffer, std_outputs, pkg_config), str)\n+            if thistaskwaiting\n+                if occursin(\"Waiting for background task / IO / timer\", str)\n+                    thistaskwaiting = true\n+                    !liveprinting && !fancyprint && @lock print_lock begin\n+                        println(io, full_name(ext_to_parent, pkg), _color_string(str, Base.warn_color(), hascolor))\n+                    end\n+                    push!(taskwaiting, pkg_config)\n+                end\n+            else\n+                # XXX: don't just re-enable IO for random packages without printing the context for them first\n+                !liveprinting && !fancyprint && @lock print_lock begin\n+                    print(io, ansi_cleartoendofline, str)\n+                end\n+            end\n+        end\n+    catch err\n+        err isa InterruptException || rethrow()\n+    end\n+end\n+\n _timing_string(t) = string(lpad(round(t * 1e3, digits = 1), 9), \" ms\")\n \n function _color_string(cstr::String, col::Union{Int64, Symbol}, hascolor)"
    },
    {
      "sha": "78b1af5645d2e2d7d5795910277bf5cc13f695bd",
      "filename": "base/shell.jl",
      "status": "modified",
      "additions": 31,
      "deletions": 25,
      "changes": 56,
      "blob_url": "https://github.com/JuliaLang/julia/blob/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Fshell.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Fshell.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fshell.jl?ref=44cc29c2582715b97f4a16ddb8b6b8f4824f4474",
      "patch": "@@ -244,34 +244,40 @@ function print_shell_escaped_posixly(io::IO, args::AbstractString...)\n         first || print(io, ' ')\n         # avoid printing quotes around simple enough strings\n         # that any (reasonable) shell will definitely never consider them to be special\n-        have_single::Bool = false\n-        have_double::Bool = false\n-        function isword(c::AbstractChar)\n-            if '0' <= c <= '9' || 'a' <= c <= 'z' || 'A' <= c <= 'Z'\n-                # word characters\n-            elseif c == '_' || c == '/' || c == '+' || c == '-' || c == '.'\n-                # other common characters\n-            elseif c == '\\''\n-                have_single = true\n-            elseif c == '\"'\n-                have_double && return false # switch to single quoting\n-                have_double = true\n-            elseif !first && c == '='\n-                # equals is special if it is first (e.g. `env=val ./cmd`)\n-            else\n-                # anything else\n-                return false\n-            end\n-            return true\n-        end\n         if isempty(arg)\n             print(io, \"''\")\n-        elseif all(isword, arg)\n-            have_single && (arg = replace(arg, '\\'' => \"\\\\'\"))\n-            have_double && (arg = replace(arg, '\"' => \"\\\\\\\"\"))\n-            print(io, arg)\n         else\n-            print(io, '\\'', replace(arg, '\\'' => \"'\\\\''\"), '\\'')\n+            have_single = false\n+            have_double = false\n+            isword = true\n+            for c in arg\n+                if '0' <= c <= '9' || 'a' <= c <= 'z' || 'A' <= c <= 'Z'\n+                    # word characters\n+                elseif c == '_' || c == '/' || c == '+' || c == '-' || c == '.'\n+                    # other common characters\n+                elseif c == '\\''\n+                    have_single = true\n+                elseif c == '\"'\n+                    if have_double\n+                        isword = false\n+                        break # switch to single quoting\n+                    end\n+                    have_double = true\n+                elseif !first && c == '='\n+                    # equals is special if it is first (e.g. `env=val ./cmd`)\n+                else\n+                    # anything else\n+                    isword = false\n+                    break\n+                end\n+            end\n+            if isword\n+                have_single && (arg = replace(arg, '\\'' => \"\\\\'\"))\n+                have_double && (arg = replace(arg, '\"' => \"\\\\\\\"\"))\n+                print(io, arg)\n+            else\n+                print(io, '\\'', replace(arg, '\\'' => \"'\\\\''\"), '\\'')\n+            end\n         end\n         first = false\n     end"
    },
    {
      "sha": "0e807adb92839ff808babd838920d38cc7c71f67",
      "filename": "base/stacktraces.jl",
      "status": "modified",
      "additions": 14,
      "deletions": 12,
      "changes": 26,
      "blob_url": "https://github.com/JuliaLang/julia/blob/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Fstacktraces.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/44cc29c2582715b97f4a16ddb8b6b8f4824f4474/base%2Fstacktraces.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fstacktraces.jl?ref=44cc29c2582715b97f4a16ddb8b6b8f4824f4474",
      "patch": "@@ -167,20 +167,22 @@ function lookup(ip::Base.InterpreterIP)\n     if isempty(scopes)\n         return [StackFrame(func, file, line, code, false, false, 0)]\n     end\n-    closure = let inlined::Bool = false, def = def\n-        function closure_inner(lno)\n-            if inlined\n-                def = lno.method\n-                def isa Union{Method,Core.CodeInstance,MethodInstance} || (def = nothing)\n-            else\n-                def = codeinfo\n-            end\n-            sf = StackFrame(IRShow.normalize_method_name(lno.method), lno.file, lno.line, def, false, inlined, 0)\n-            inlined = true\n-            return sf\n+    res = Vector{StackFrame}(undef, length(scopes))\n+    inlined = false\n+    def_local = def\n+    for i in eachindex(scopes)\n+        lno = scopes[i]\n+        if inlined\n+            def_local = lno.method\n+            def_local isa Union{Method,Core.CodeInstance,MethodInstance} || (def_local = nothing)\n+        else\n+            def_local = codeinfo\n         end\n+        res[i] = StackFrame(IRShow.normalize_method_name(lno.method), lno.file, lno.line,\n+            def_local, false, inlined, 0)\n+        inlined = true\n     end\n-    return map(closure, scopes)\n+    return res\n end\n \n \"\"\""
    }
  ]
}