{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60168",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60168/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60168/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60168/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60168",
  "id": 3640220241,
  "node_id": "PR_kwDOABkWpM60OMl2",
  "number": 60168,
  "title": "[JuliaLowering] get macro name in `ctx.world`; fix lowering iterator",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 250223102,
      "node_id": "MDU6TGFiZWwyNTAyMjMxMDI=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:lowering",
      "name": "compiler:lowering",
      "color": "5319e7",
      "default": false,
      "description": "Syntax lowering (compiler front end, 2nd stage)"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 1,
  "created_at": "2025-11-18T22:25:35Z",
  "updated_at": "2025-11-24T23:22:51Z",
  "closed_at": "2025-11-24T23:22:51Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60168",
    "html_url": "https://github.com/JuliaLang/julia/pull/60168",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60168.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60168.patch",
    "merged_at": "2025-11-24T23:22:51Z"
  },
  "body": "Evaluating a macro's name should be done in the same world we pass into lowering and use for expansion.  Fix this for all reasonable macro names.\r\n\r\nThe lowering iterator (currently very cold code only used for module/toplevel expressions that JuliaLowering \"controls\") also needs to update the expansion world between steps.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60168/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60168/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "474b8b917d83ea4b388b55a1d239e1f16de00ac6",
      "filename": "JuliaLowering/src/eval.jl",
      "status": "modified",
      "additions": 28,
      "deletions": 73,
      "changes": 101,
      "blob_url": "https://github.com/JuliaLang/julia/blob/06106f5d94f26de1be7866e4f3c7bb3c0452e9f7/JuliaLowering%2Fsrc%2Feval.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/06106f5d94f26de1be7866e4f3c7bb3c0452e9f7/JuliaLowering%2Fsrc%2Feval.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Feval.jl?ref=06106f5d94f26de1be7866e4f3c7bb3c0452e9f7",
      "patch": "@@ -33,50 +33,42 @@ end\n # how we end up putting this into Base.\n \n struct LoweringIterator{GraphType}\n-    ctx::MacroExpansionContext{GraphType}\n+    expr_compat_mode::Bool # later stored in module?\n     todo::Vector{Tuple{SyntaxTree{GraphType}, Bool, Int}}\n end\n \n-function lower_init(ex::SyntaxTree, mod::Module, macro_world::UInt; expr_compat_mode::Bool=false)\n-    graph = ensure_macro_attributes(syntax_graph(ex))\n-    ctx = MacroExpansionContext(graph, mod, expr_compat_mode, macro_world)\n-    ex = reparent(ctx, ex)\n-    LoweringIterator{typeof(graph)}(ctx, [(ex, false, 0)])\n+function lower_init(ex::SyntaxTree{T};\n+                    expr_compat_mode::Bool=false) where {T}\n+    LoweringIterator{T}(expr_compat_mode, [(ex, false, 0)])\n end\n \n-function lower_step(iter, push_mod=nothing)\n-    if !isnothing(push_mod)\n-        push_layer!(iter.ctx, push_mod, false)\n-    end\n-\n+function lower_step(iter, mod, world=Base.get_world_counter())\n     if isempty(iter.todo)\n         return Core.svec(:done)\n     end\n \n-    ex, is_module_body, child_idx = pop!(iter.todo)\n+    top_ex, is_module_body, child_idx = pop!(iter.todo)\n     if child_idx > 0\n-        next_child = child_idx + 1\n-        if child_idx <= numchildren(ex)\n-            push!(iter.todo, (ex, is_module_body, next_child))\n-            ex = ex[child_idx]\n+        if child_idx <= numchildren(top_ex)\n+            push!(iter.todo, (top_ex, is_module_body, child_idx + 1))\n+            ex = top_ex[child_idx]\n+        elseif is_module_body\n+            return Core.svec(:end_module)\n         else\n-            if is_module_body\n-                pop_layer!(iter.ctx)\n-                return Core.svec(:end_module)\n-            else\n-                return lower_step(iter)\n-            end\n+            return lower_step(iter, mod)\n         end\n+    else\n+        ex = top_ex\n     end\n \n     k = kind(ex)\n     if !(k in KSet\"toplevel module\")\n-        ex = expand_forms_1(iter.ctx, ex)\n+        ctx1, ex = expand_forms_1(mod, ex, iter.expr_compat_mode, world)\n         k = kind(ex)\n     end\n     if k == K\"toplevel\"\n         push!(iter.todo, (ex, false, 1))\n-        return lower_step(iter)\n+        return lower_step(iter, mod)\n     elseif k == K\"module\"\n         name = ex[1]\n         if kind(name) != K\"Identifier\"\n@@ -93,7 +85,7 @@ function lower_step(iter, push_mod=nothing)\n         return Core.svec(:begin_module, newmod_name, std_defs, loc)\n     else\n         # Non macro expansion parts of lowering\n-        ctx2, ex2 = expand_forms_2(iter.ctx, ex)\n+        ctx2, ex2 = expand_forms_2(ctx1, ex)\n         ctx3, ex3 = resolve_scopes(ctx2, ex2)\n         ctx4, ex4 = convert_closures(ctx3, ex3)\n         ctx5, ex5 = linearize_ir(ctx4, ex4)\n@@ -457,7 +449,7 @@ end\n @fzone \"JL: eval\" function eval(mod::Module, ex::SyntaxTree;\n                                 macro_world::UInt=Base.get_world_counter(),\n                                 opts...)\n-    iter = lower_init(ex, mod, macro_world; opts...)\n+    iter = lower_init(ex; opts...)\n     _eval(mod, iter)\n end\n \n@@ -466,69 +458,32 @@ function eval(mod::Module, ex; opts...)\n     eval(mod, expr_to_syntaxtree(ex); opts...)\n end\n \n-if VERSION >= v\"1.13.0-DEV.1199\" # https://github.com/JuliaLang/julia/pull/59604\n-\n function _eval(mod, iter)\n-    modules = Module[]\n-    new_mod = nothing\n+    modules = Module[mod]\n     result = nothing\n     while true\n-        thunk = lower_step(iter, new_mod)::Core.SimpleVector\n-        new_mod = nothing\n+        thunk = lower_step(iter, modules[end])::Core.SimpleVector\n         type = thunk[1]::Symbol\n         if type == :done\n             break\n         elseif type == :begin_module\n-            push!(modules, mod)\n             filename = something(thunk[4].file, :none)\n-            mod = @ccall jl_begin_new_module(mod::Any, thunk[2]::Symbol, thunk[3]::Cint,\n-                                             filename::Cstring, thunk[4].line::Cint)::Module\n-            new_mod = mod\n-        elseif type == :end_module\n-            @ccall jl_end_new_module(mod::Module)::Cvoid\n-            result = mod\n-            mod = pop!(modules)\n-        else\n-            @assert type == :thunk\n-            result = Core.eval(mod, thunk[2])\n-        end\n-    end\n-    @assert isempty(modules)\n-    return result\n-end\n-\n-else\n-\n-function _eval(mod, iter, new_mod=nothing)\n-    in_new_mod = !isnothing(new_mod)\n-    result = nothing\n-    while true\n-        thunk = lower_step(iter, new_mod)::Core.SimpleVector\n-        new_mod = nothing\n-        type = thunk[1]::Symbol\n-        if type == :done\n-            @assert !in_new_mod\n-            break\n-        elseif type == :begin_module\n-            name = thunk[2]::Symbol\n-            std_defs = thunk[3]\n-            result = Core.eval(mod,\n-                Expr(:module, std_defs, name,\n-                     Expr(:block, thunk[4], Expr(:call, m->_eval(m, iter, m), name)))\n-            )\n+            mod = @ccall jl_begin_new_module(\n+                modules[end]::Any, thunk[2]::Symbol, thunk[3]::Cint,\n+                filename::Cstring, thunk[4].line::Cint)::Module\n+            push!(modules, mod)\n         elseif type == :end_module\n-            @assert in_new_mod\n-            return mod\n+            @ccall jl_end_new_module(modules[end]::Module)::Cvoid\n+            result = pop!(modules)\n         else\n             @assert type == :thunk\n-            result = Core.eval(mod, thunk[2])\n+            result = Core.eval(modules[end], thunk[2])\n         end\n     end\n+    @assert length(modules) === 1\n     return result\n end\n \n-end\n-\n \"\"\"\n     include(mod::Module, path::AbstractString)\n "
    },
    {
      "sha": "708aed4e14fce58344ea2a154025e27799b66a01",
      "filename": "JuliaLowering/src/macro_expansion.jl",
      "status": "modified",
      "additions": 41,
      "deletions": 17,
      "changes": 58,
      "blob_url": "https://github.com/JuliaLang/julia/blob/06106f5d94f26de1be7866e4f3c7bb3c0452e9f7/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/06106f5d94f26de1be7866e4f3c7bb3c0452e9f7/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fmacro_expansion.jl?ref=06106f5d94f26de1be7866e4f3c7bb3c0452e9f7",
      "patch": "@@ -158,25 +158,49 @@ function fixup_macro_name(ctx::MacroExpansionContext, ex::SyntaxTree)\n     end\n end\n \n-function eval_macro_name(ctx::MacroExpansionContext, mctx::MacroContext, ex::SyntaxTree)\n-    # `ex1` might contain a nontrivial mix of scope layers so we can't just\n-    # `eval()` it, as it's already been partially lowered by this point.\n-    # Instead, we repeat the latter parts of `lower()` here.\n-    ex1 = expand_forms_1(ctx, fixup_macro_name(ctx, ex))\n-    ctx2, ex2 = expand_forms_2(ctx, ex1)\n-    ctx3, ex3 = resolve_scopes(ctx2, ex2)\n-    ctx4, ex4 = convert_closures(ctx3, ex3)\n-    ctx5, ex5 = linearize_ir(ctx4, ex4)\n+function _eval_dot(world::UInt, mod, ex::SyntaxTree)\n+    if kind(ex) === K\".\"\n+        mod = _eval_dot(world, mod, ex[1])\n+        ex = ex[2]\n+    end\n+    kind(ex) in KSet\"Identifier Symbol\" && mod isa Module ?\n+        Base.invoke_in_world(world, getproperty, mod, Symbol(ex.name_val)) :\n+        nothing\n+end\n+\n+# If macroexpand(ex[1]) is an identifier or dot-expression, we can simply grab\n+# it from the scope layer's module in ctx.macro_world.  Otherwise, we need to\n+# eval arbitrary code (which, TODO: does not use the correct world age, and it\n+# isn't clear the language is meant to support this).\n+function eval_macro_name(ctx::MacroExpansionContext, mctx::MacroContext, ex0::SyntaxTree)\n     mod = current_layer(ctx).mod\n-    expr_form = to_lowered_expr(ex5)\n+    ex = fixup_macro_name(ctx, expand_forms_1(ctx, ex0))\n     try\n-        # Using Core.eval here fails when precompiling packages since we hit the\n-        # user-facing error (in `jl_check_top_level_effect`) that warns that\n-        # effects won't persist when eval-ing into a closed module.\n-        # `jl_invoke_julia_macro` bypasses this by calling `jl_toplevel_eval` on\n-        # the macro name.  This is fine assuming the first argument to the\n-        # macrocall is effect-free.\n-        ccall(:jl_toplevel_eval, Any, (Any, Any), mod, expr_form)\n+        if kind(ex) === K\"Value\"\n+            !(ex.value isa GlobalRef) ? ex.value :\n+                Base.invoke_in_world(ctx.macro_world, getglobal,\n+                                     ex.value.mod, ex.value.name)\n+        elseif kind(ex) === K\"Identifier\"\n+            layer = get(ex, :scope_layer, nothing)\n+            if !isnothing(layer)\n+                mod = ctx.scope_layers[layer].mod\n+            end\n+            Base.invoke_in_world(ctx.macro_world, getproperty,\n+                                 mod, Symbol(ex.name_val))\n+        elseif kind(ex) === K\".\" &&\n+                (ed = _eval_dot(ctx.macro_world, mod, ex); !isnothing(ed))\n+            ed\n+        else\n+            # `ex` might contain a nontrivial mix of scope layers so we can't\n+            # just `eval()` it, as it's already been partially lowered by this\n+            # point.  Instead, we repeat the latter parts of `lower()` here.\n+            ctx2, ex2 = expand_forms_2(ctx, ex)\n+            ctx3, ex3 = resolve_scopes(ctx2, ex2)\n+            ctx4, ex4 = convert_closures(ctx3, ex3)\n+            ctx5, ex5 = linearize_ir(ctx4, ex4)\n+            expr_form = to_lowered_expr(ex5)\n+            ccall(:jl_toplevel_eval, Any, (Any, Any), mod, expr_form)\n+        end\n     catch err\n         throw(MacroExpansionError(mctx, ex, \"Macro not found\", :all, err))\n     end"
    },
    {
      "sha": "6c181f6e176fcd3b0a0f191a957f126d65fe1029",
      "filename": "JuliaLowering/test/macros.jl",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/JuliaLang/julia/blob/06106f5d94f26de1be7866e4f3c7bb3c0452e9f7/JuliaLowering%2Ftest%2Fmacros.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/06106f5d94f26de1be7866e4f3c7bb3c0452e9f7/JuliaLowering%2Ftest%2Fmacros.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmacros.jl?ref=06106f5d94f26de1be7866e4f3c7bb3c0452e9f7",
      "patch": "@@ -515,5 +515,27 @@ end\n \"\"\")\n code = JuliaLowering.include_string(test_mod, \"\"\"Mod1.@indirect_MODULE()\"\"\")\n @test JuliaLowering.eval(test_mod, code) === test_mod # !== test_mod.Mod1\n+# the lowering/eval iterator needs to expand in the correct world age (currently\n+# the only way to hit this from user code is macros producing toplevel)\n+\n+@testset \"macros defining macros\" begin\n+    @eval test_mod macro make_and_use_macro_toplevel()\n+        Expr(:toplevel,\n+             esc(:(macro from_toplevel_expansion()\n+                   :(123)\n+               end)),\n+             esc(:(@from_toplevel_expansion())))\n+    end\n+\n+    @test JuliaLowering.include_string(\n+        test_mod, \"@make_and_use_macro_toplevel()\"; expr_compat_mode=true) === 123\n+\n+    if isdefined(test_mod, Symbol(\"@from_toplevel_expansion\"))\n+        Base.delete_binding(test_mod, Symbol(\"@from_toplevel_expansion\"))\n+    end\n+\n+    @test JuliaLowering.include_string(\n+        test_mod, \"@make_and_use_macro_toplevel()\"; expr_compat_mode=false) === 123\n+end\n \n end"
    },
    {
      "sha": "f5f7fd41f874451d854a0eb9f14aed70dbdf5043",
      "filename": "JuliaLowering/test/macros_ir.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/06106f5d94f26de1be7866e4f3c7bb3c0452e9f7/JuliaLowering%2Ftest%2Fmacros_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/06106f5d94f26de1be7866e4f3c7bb3c0452e9f7/JuliaLowering%2Ftest%2Fmacros_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmacros_ir.jl?ref=06106f5d94f26de1be7866e4f3c7bb3c0452e9f7",
      "patch": "@@ -147,7 +147,7 @@ _never_exist = @m_not_exist 42\n #---------------------\n MacroExpansionError while expanding @m_not_exist in module Main.TestMod:\n _never_exist = @m_not_exist 42\n-#              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Macro not found\n+#               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Macro not found\n Caused by:\n UndefVarError: `@m_not_exist` not defined in `Main.TestMod`\n Suggestion: check for spelling errors or missing imports."
    }
  ]
}