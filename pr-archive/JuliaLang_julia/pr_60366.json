{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60366",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60366/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60366/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60366/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60366",
  "id": 3718494758,
  "node_id": "PR_kwDOABkWpM64T3Jp",
  "number": 60366,
  "title": "Improve the invalidation situation somewhat when someone defines `convert` to a `Symbol` or `String`",
  "user": {
    "login": "KristofferC",
    "id": 1282691,
    "node_id": "MDQ6VXNlcjEyODI2OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1282691?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KristofferC",
    "html_url": "https://github.com/KristofferC",
    "followers_url": "https://api.github.com/users/KristofferC/followers",
    "following_url": "https://api.github.com/users/KristofferC/following{/other_user}",
    "gists_url": "https://api.github.com/users/KristofferC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KristofferC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KristofferC/subscriptions",
    "organizations_url": "https://api.github.com/users/KristofferC/orgs",
    "repos_url": "https://api.github.com/users/KristofferC/repos",
    "events_url": "https://api.github.com/users/KristofferC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KristofferC/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 944193805,
      "node_id": "MDU6TGFiZWw5NDQxOTM4MDU=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/latency",
      "name": "latency",
      "color": "76e8d8",
      "default": false,
      "description": "Latency"
    },
    {
      "id": 7606699692,
      "node_id": "LA_kwDOABkWpM8AAAABxWUGrA",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/invalidations",
      "name": "invalidations",
      "color": "A33505",
      "default": false,
      "description": ""
    },
    {
      "id": 9546926682,
      "node_id": "LA_kwDOABkWpM8AAAACOQqKWg",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/backport%201.13",
      "name": "backport 1.13",
      "color": "699295",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-12-11T09:14:13Z",
  "updated_at": "2025-12-17T10:59:04Z",
  "closed_at": "2025-12-17T10:59:02Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60366",
    "html_url": "https://github.com/JuliaLang/julia/pull/60366",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60366.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60366.patch",
    "merged_at": "2025-12-17T10:59:02Z"
  },
  "body": "```\r\n inserting convert(::Type{Symbol}, x::JSON.PtrString) @ JSON ~/.julia/packages/JSON/0oqO1/src/lazy.jl:435 invalidated:\r\n                 16: signature Tuple{typeof(convert), Type{Symbol}, Any} triggered MethodInstance for setindex!(::Dict{Symbol, Bool}, ::Any, ::Any) (650 children)\r\n                 17: signature Tuple{typeof(convert), Type{Symbol}, Any} triggered MethodInstance for @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}(::NamedTuple{(:region, :label, :value)}) (763 children)\r\n```\r\n\r\nHandled by:\r\n\r\n- **avoid `convert` calls from type unstable `Dict` in `TermInfo` constructor**\r\n- **force inline of setindex on named tuple in some annotated string code to make the `:region` field be const known, ref #60365**\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60366/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60366/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "3ce20329762af223313f75a45d9caab4a1f442fa",
      "filename": "base/docs/Docs.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fdocs%2FDocs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fdocs%2FDocs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fdocs%2FDocs.jl?ref=4b12890211cae96c362e501b906354bf8ab2a484",
      "patch": "@@ -371,7 +371,7 @@ function metadata(__source__, __module__, expr, ismodule)\n             if isa(eachex, Symbol) || isexpr(eachex, :(::))\n                 # a field declaration\n                 if last_docstr !== nothing\n-                    push!(fields, P(namify(eachex), last_docstr))\n+                    push!(fields, P(namify(eachex)::Symbol, last_docstr))\n                     last_docstr = nothing\n                 end\n             elseif isexpr(eachex, :function) || isexpr(eachex, :(=))"
    },
    {
      "sha": "9961072440ef8da3e9817d9dcf0f7190b1c1cbb6",
      "filename": "base/loading.jl",
      "status": "modified",
      "additions": 49,
      "deletions": 17,
      "changes": 66,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4b12890211cae96c362e501b906354bf8ab2a484/base%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Floading.jl?ref=4b12890211cae96c362e501b906354bf8ab2a484",
      "patch": "@@ -271,7 +271,16 @@ struct LoadingCache\n     located::Dict{Tuple{PkgId, Union{String, Nothing}}, Union{Tuple{PkgLoadSpec, String}, Nothing}}\n end\n const LOADING_CACHE = Ref{Union{LoadingCache, Nothing}}(nothing) # n.b.: all access to and through this are protected by require_lock\n-LoadingCache() = LoadingCache(load_path(), Dict(), Dict(), Dict(), Set(), Dict(), Dict(), Dict())\n+LoadingCache() = LoadingCache(\n+    load_path(),\n+    Dict{String, UUID}(),\n+    Dict{String, Union{Bool, String}}(),\n+    Dict{String, Union{Nothing, String}}(),\n+    Set{String}(),\n+    Dict{Tuple{PkgId, String}, Union{Nothing, Tuple{PkgId, String}}}(),\n+    Dict{String, Union{Nothing, Tuple{PkgId, String}}}(),\n+    Dict{Tuple{PkgId, Union{String, Nothing}}, Union{Tuple{PkgLoadSpec, String}, Nothing}}()\n+)\n \n \n struct TOMLCache{Dates}\n@@ -343,25 +352,22 @@ Same as [`Base.identify_package`](@ref) except that the path to the environment\n is also returned, except when the identity is not identified.\n \"\"\"\n identify_package_env(where::Module, name::String) = identify_package_env(PkgId(where), name)\n-function identify_package_env(where::Union{PkgId, Nothing}, name::String)\n+function identify_package_env(where::PkgId, name::String)\n     # Special cases\n-    if where !== nothing\n-        if where.name === name\n-            # Project tries to load itself\n-            return (where, nothing)\n-        elseif where.uuid === nothing\n-            # Project without Project.toml - treat as toplevel load\n-            where = nothing\n-        end\n+    if where.name === name\n+        # Project tries to load itself\n+        return (where, nothing)\n+    elseif where.uuid === nothing\n+        # Project without Project.toml - treat as toplevel load\n+        return identify_package_env(nothing, name)\n     end\n \n     # Check if we have a cached answer for this\n     assert_havelock(require_lock)\n     cache = LOADING_CACHE[]\n-    cache_key = where === nothing ? name : (where, name)\n+    cache_key = (where, name)\n     if cache !== nothing\n-        env_cache = where === nothing ? cache.identified : cache.identified_where\n-        pkg_env = get(env_cache, cache_key, missing)\n+        pkg_env = get(cache.identified_where, cache_key, missing)\n         pkg_env === missing || return pkg_env\n     end\n \n@@ -372,14 +378,14 @@ function identify_package_env(where::Union{PkgId, Nothing}, name::String)\n         pkgid = environment_deps_get(env, where, name)\n         # If we didn't find `where` at all, keep looking through the environment stack\n         pkgid === nothing && continue\n-        if pkgid.uuid !== nothing || where === nothing\n-            pkg_env = pkgid, env\n+        if pkgid.uuid !== nothing\n+            pkg_env = (pkgid, env)\n         end\n         # If we don't have pkgid.uuid, still break here - this is a sentinel that indicates\n         # that we've found `where` but it did not have the required dependency. We terminate the search.\n         break\n     end\n-    if pkg_env === nothing && where !== nothing && is_stdlib(where)\n+    if pkg_env === nothing && is_stdlib(where)\n         # if not found it could be that manifests are from a different julia version/commit\n         # where stdlib dependencies have changed, so look up deps based on the stdlib Project.toml\n         # as a fallback\n@@ -388,7 +394,33 @@ function identify_package_env(where::Union{PkgId, Nothing}, name::String)\n \n     # Cache the result\n     if cache !== nothing\n-        env_cache[cache_key] = pkg_env\n+        cache.identified_where[cache_key] = pkg_env\n+    end\n+    return pkg_env\n+end\n+function identify_package_env(where::Nothing, name::String)\n+    # Check if we have a cached answer for this\n+    assert_havelock(require_lock)\n+    cache = LOADING_CACHE[]\n+    if cache !== nothing\n+        pkg_env = get(cache.identified, name, missing)\n+        pkg_env === missing || return pkg_env\n+    end\n+\n+    # Main part: Search through all environments in the load path to see if we have\n+    # a matching entry.\n+    pkg_env = nothing\n+    for env in load_path()\n+        pkgid = environment_deps_get(env, nothing, name)\n+        # If we didn't find `where` at all, keep looking through the environment stack\n+        pkgid === nothing && continue\n+        pkg_env = (pkgid, env)\n+        break\n+    end\n+\n+    # Cache the result\n+    if cache !== nothing\n+        cache.identified[name] = pkg_env\n     end\n     return pkg_env\n end"
    },
    {
      "sha": "f1558037097431d9a144b51323a700c0b12cf8f4",
      "filename": "base/precompilation.jl",
      "status": "modified",
      "additions": 25,
      "deletions": 17,
      "changes": 42,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fprecompilation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fprecompilation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fprecompilation.jl?ref=4b12890211cae96c362e501b906354bf8ab2a484",
      "patch": "@@ -568,15 +568,15 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                          _from_loading::Bool,\n                          configs::Vector{Config},\n                          io::IOContext{IO},\n-                         fancyprint::Bool,\n+                         fancyprint\u2032::Bool,\n                          manifest::Bool,\n                          ignore_loaded::Bool)\n     requested_pkgs = copy(pkgs) # for understanding user intent\n     pkg_names = pkgs isa Vector{String} ? copy(pkgs) : String[pkg.name for pkg in pkgs]\n     if pkgs isa Vector{PkgId}\n-        requested_pkgids = copy(pkgs)\n+        requested_pkgids\u2032 = copy(pkgs)\n     else\n-        requested_pkgids = PkgId[]\n+        requested_pkgids\u2032 = PkgId[]\n         for name in pkgs\n             pkgid = Base.identify_package(name)\n             if pkgid === nothing\n@@ -586,9 +586,10 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                     throw(PkgPrecompileError(\"Unknown package: $name\"))\n                 end\n             end\n-            push!(requested_pkgids, pkgid)\n+            push!(requested_pkgids\u2032, pkgid)\n         end\n     end\n+    requested_pkgids = requested_pkgids\u2032\n \n     time_start = time_ns()\n \n@@ -605,17 +606,20 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n     # suppress precompilation progress messages when precompiling for loading packages, except during interactive sessions\n     # or when specified by logging heuristics that explicitly require it\n     # since the complicated IO implemented here can have somewhat disastrous consequences when happening in the background (e.g. #59599)\n-    logio = io\n-    logcalls = nothing\n+    logio\u2032 = io\n+    logcalls\u2032 = nothing\n     if _from_loading\n         if isinteractive()\n-            logcalls = CoreLogging.Info # sync with Base.compilecache\n+            logcalls\u2032 = CoreLogging.Info # sync with Base.compilecache\n         else\n-            logio = IOContext{IO}(devnull)\n-            fancyprint = false\n-            logcalls = CoreLogging.Debug # sync with Base.compilecache\n+            logio\u2032 = IOContext{IO}(devnull)\n+            fancyprint\u2032 = false\n+            logcalls\u2032 = CoreLogging.Debug # sync with Base.compilecache\n         end\n     end\n+    fancyprint = fancyprint\u2032\n+    logio = logio\u2032\n+    logcalls = logcalls\u2032\n \n     nconfigs = length(configs)\n     hascolor = get(logio, :color, false)::Bool\n@@ -992,7 +996,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                         for pkg_config in pkg_queue_show\n                             dep, config = pkg_config\n                             loaded = warn_loaded && haskey(Base.loaded_modules, dep)\n-                            flags, cacheflags = config\n+                            local flags, cacheflags = config\n                             name = describe_pkg(dep, dep in project_deps, dep in serial_deps, flags, cacheflags)\n                             line = if pkg_config in precomperr_deps\n                                 string(color_string(\"  ? \", Base.warn_color()), name)\n@@ -1077,7 +1081,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                 notify(was_processed[pkg_config])\n                 continue\n             end\n-            flags, cacheflags = config\n+            local flags, cacheflags = config\n             task = @async begin\n                 try\n                     loaded = warn_loaded && haskey(Base.loaded_modules, pkg)\n@@ -1118,17 +1122,21 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                             end\n                             # for extensions, any extension that can trigger it needs to be accounted for here (even stdlibs, which are excluded from direct_deps)\n                             loadable_exts = haskey(ext_to_parent, pkg) ? filter((dep)->haskey(ext_to_parent, dep), triggers[pkg]) : nothing\n-                            if !isempty(deps)\n+\n+                            flags_ =if !isempty(deps)\n                                 # if deps is empty, either it doesn't have any (so compiled-modules is\n                                 # irrelevant) or we couldn't compute them (so we actually should attempt\n                                 # serial compile, as the dependencies are not in the parallel list)\n-                                flags = `$flags --compiled-modules=strict`\n+                                `$flags --compiled-modules=strict`\n+                            else\n+                                flags\n                             end\n+\n                             if _from_loading && pkg in requested_pkgids\n                                 # loading already took the cachefile_lock and printed logmsg for its explicit requests\n                                 t = @elapsed ret = begin\n                                     Base.compilecache(pkg, sourcespec, std_pipe, std_pipe, !ignore_loaded;\n-                                                      flags, cacheflags, loadable_exts)\n+                                                      flags=flags_, cacheflags, loadable_exts)\n                                 end\n                             else\n                                 # allows processes to wait if another process is precompiling a given package to\n@@ -1138,7 +1146,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                                     if interrupted_or_done[]\n                                         return ErrorException(\"canceled\")\n                                     end\n-                                    cachepaths = Base.find_all_in_cache_path(pkg)\n+                                    local cachepaths = Base.find_all_in_cache_path(pkg)\n                                     local freshpath = Base.compilecache_freshest_path(pkg; ignore_loaded, stale_cache, cachepath_cache, cachepaths, sourcespec, flags=cacheflags)\n                                     local is_stale = freshpath === nothing\n                                     if !is_stale\n@@ -1149,7 +1157,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                                         @debug \"Precompiling $(repr(\"text/plain\", pkg))\"\n                                     end\n                                     Base.compilecache(pkg, sourcespec, std_pipe, std_pipe, !ignore_loaded;\n-                                                      flags, cacheflags, loadable_exts)\n+                                                      flags=flags_, cacheflags, loadable_exts)\n                                 end\n                             end\n                             if ret isa Exception"
    },
    {
      "sha": "1accb71bf3bd1cb2151622b01cf9dd084f334f8a",
      "filename": "base/shell.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fshell.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fshell.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fshell.jl?ref=4b12890211cae96c362e501b906354bf8ab2a484",
      "patch": "@@ -171,7 +171,7 @@ function shell_split(s::AbstractString)\n     parsed = shell_parse(s, false)[1]\n     args = String[]\n     for arg in parsed\n-        push!(args, string(arg...))\n+        push!(args, string(arg...)::String)\n     end\n     args\n end"
    },
    {
      "sha": "6bc0c76fdbaa8790d113ddb585639144e0d1efe8",
      "filename": "base/strings/annotated.jl",
      "status": "modified",
      "additions": 27,
      "deletions": 15,
      "changes": 42,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fstrings%2Fannotated.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fstrings%2Fannotated.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fstrings%2Fannotated.jl?ref=4b12890211cae96c362e501b906354bf8ab2a484",
      "patch": "@@ -250,7 +250,7 @@ function annotatedstring(xs...)\n         size = filesize(s.io)\n         if x isa AnnotatedString\n             for annot in x.annotations\n-                push!(annotations, setindex(annot, annot.region .+ size, :region))\n+                push!(annotations, @inline(setindex(annot, annot.region .+ size, :region)))\n             end\n             print(s, x.string)\n         elseif x isa SubString{<:AnnotatedString}\n@@ -259,7 +259,7 @@ function annotatedstring(xs...)\n                 if start <= x.offset + x.ncodeunits && stop > x.offset\n                     rstart = size + max(0, start - x.offset - 1) + 1\n                     rstop = size + min(stop, x.offset + x.ncodeunits) - x.offset\n-                    push!(annotations, setindex(annot, rstart:rstop, :region))\n+                    push!(annotations, @inline(setindex(annot, rstart:rstop, :region)))\n                 end\n             end\n             print(s, SubString(x.string.string, x.offset, x.ncodeunits, Val(:noshift)))\n@@ -293,12 +293,12 @@ function repeat(str::AnnotatedString, r::Integer)\n     elseif allequal(a -> a.region, str.annotations) && first(str.annotations).region == fullregion\n         newfullregion = firstindex(unannot):lastindex(unannot)\n         for annot in str.annotations\n-            push!(annotations, setindex(annot, newfullregion, :region))\n+            push!(annotations, @inline(setindex(annot, newfullregion, :region)))\n         end\n     else\n         for offset in 0:len:(r-1)*len\n             for annot in str.annotations\n-                push!(annotations, setindex(annot, annot.region .+ offset, :region))\n+                push!(annotations, @inline(setindex(annot, annot.region .+ offset, :region)))\n             end\n         end\n     end\n@@ -318,10 +318,10 @@ function reverse(s::AnnotatedString)\n     lastind = lastindex(s)\n     AnnotatedString(\n         reverse(s.string),\n-        [setindex(annot,\n+        [@inline(setindex(annot,\n                   UnitRange(1 + lastind - last(annot.region),\n                             1 + lastind - first(annot.region)),\n-                  :region)\n+                  :region))\n          for annot in s.annotations])\n end\n \n@@ -389,16 +389,28 @@ See also: [`annotate!`](@ref).\n annotations(s::AnnotatedString) = s.annotations\n \n function annotations(s::SubString{<:AnnotatedString})\n-    RegionAnnotation[\n-        setindex(ann, first(ann.region)-s.offset:last(ann.region)-s.offset, :region)\n-        for ann in annotations(s.string, s.offset+1:s.offset+s.ncodeunits)]\n+    substr_range = s.offset+1:s.offset+s.ncodeunits\n+    result = RegionAnnotation[]\n+    for ann in annotations(s.string, substr_range)\n+        # Shift the region to be relative to the substring start\n+        shifted_region = first(ann.region)-s.offset:last(ann.region)-s.offset\n+        # @inline setindex makes :region const knowable (#60365)\n+        push!(result, @inline(setindex(ann, shifted_region, :region)))\n+    end\n+    return result\n end\n \n function annotations(s::AnnotatedString, pos::UnitRange{<:Integer})\n     # TODO optimise\n-    RegionAnnotation[\n-        setindex(ann, max(first(pos), first(ann.region)):min(last(pos), last(ann.region)), :region)\n-        for ann in s.annotations if !isempty(intersect(pos, ann.region))]\n+    result = RegionAnnotation[]\n+    for ann in s.annotations\n+        if !isempty(intersect(pos, ann.region))\n+            clamped_region = max(first(pos), first(ann.region)):min(last(pos), last(ann.region))\n+            # @inline setindex makes :region const knowable (#60365)\n+            push!(result, @inline(setindex(ann, clamped_region, :region)))\n+        end\n+    end\n+    return result\n end\n \n annotations(s::AnnotatedString, pos::Integer) = annotations(s, pos:pos)\n@@ -455,7 +467,7 @@ function annotated_chartransform(f::Function, str::AnnotatedString, state=nothin\n         start, stop = first(annot.region), last(annot.region)\n         start_offset = last(offsets[findlast(<=(start) \u2218 first, offsets)::Int])\n         stop_offset  = last(offsets[findlast(<=(stop) \u2218 first, offsets)::Int])\n-        push!(annots, setindex(annot, (start + start_offset):(stop + stop_offset), :region))\n+        push!(annots, @inline(setindex(annot, (start + start_offset):(stop + stop_offset), :region)))\n     end\n     AnnotatedString(takestring!(outstr), annots)\n end\n@@ -509,7 +521,7 @@ function eachregion(s::AnnotatedString, subregion::UnitRange{Int}=firstindex(s):\n     pos = first(events).pos\n     if pos > first(subregion)\n         push!(regions, thisind(s, first(subregion)):prevind(s, pos))\n-        push!(annots, [])\n+        push!(annots, Annotation[])\n     end\n     activelist = Int[]\n     for event in events\n@@ -526,7 +538,7 @@ function eachregion(s::AnnotatedString, subregion::UnitRange{Int}=firstindex(s):\n     end\n     if last(events).pos < nextind(s, last(subregion))\n         push!(regions, last(events).pos:thisind(s, last(subregion)))\n-        push!(annots, [])\n+        push!(annots, Annotation[])\n     end\n     RegionIterator(s.string, regions, annots)\n end"
    },
    {
      "sha": "519c6ebb7799df222763bf385c831e5bf8bed331",
      "filename": "base/strings/annotated_io.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fstrings%2Fannotated_io.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fstrings%2Fannotated_io.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fstrings%2Fannotated_io.jl?ref=4b12890211cae96c362e501b906354bf8ab2a484",
      "patch": "@@ -52,7 +52,7 @@ function write(dest::AnnotatedIOBuffer, src::AnnotatedIOBuffer)\n     srcpos = position(src)\n     nb = write(dest.io, src.io)\n     isappending || _clear_annotations_in_region!(dest.annotations, destpos:destpos+nb)\n-    srcannots = [setindex(annot, max(1 + srcpos, first(annot.region)):last(annot.region), :region)\n+    srcannots = [@inline(setindex(annot, max(1 + srcpos, first(annot.region)):last(annot.region), :region))\n                  for annot in src.annotations if first(annot.region) >= srcpos]\n     _insert_annotations!(dest, srcannots, destpos - srcpos)\n     nb\n@@ -78,10 +78,11 @@ function write(io::AbstractPipe, c::AnnotatedChar)\n end\n \n function read(io::AnnotatedIOBuffer, ::Type{AnnotatedString{T}}) where {T <: AbstractString}\n-    if (start = position(io)) == 0\n+    start = position(io)\n+    if start == 0\n         AnnotatedString(read(io.io, T), copy(io.annotations))\n     else\n-        annots = [setindex(annot, UnitRange{Int}(max(1, first(annot.region) - start), last(annot.region)-start), :region)\n+        annots = [@inline(setindex(annot, UnitRange{Int}(max(1, first(annot.region) - start), last(annot.region)-start), :region))\n                   for annot in io.annotations if last(annot.region) > start]\n         AnnotatedString(read(io.io, T), annots)\n     end\n@@ -101,7 +102,7 @@ read(io::AnnotatedIOBuffer, ::Type{AnnotatedChar}) = read(io, AnnotatedChar{Char\n function truncate(io::AnnotatedIOBuffer, size::Integer)\n     truncate(io.io, size)\n     filter!(ann -> first(ann.region) <= size, io.annotations)\n-    map!(ann -> setindex(ann, first(ann.region):min(size, last(ann.region)), :region),\n+    map!(ann -> @inline(setindex(ann, first(ann.region):min(size, last(ann.region)), :region)),\n          io.annotations, io.annotations)\n     io\n end\n@@ -125,17 +126,17 @@ function _clear_annotations_in_region!(annotations::Vector{RegionAnnotation}, sp\n         # Test for partial overlap\n         if first(region) <= first(span) <= last(region) || first(region) <= last(span) <= last(region)\n             annotations[i] =\n-                setindex(annot,\n+                @inline(setindex(annot,\n                          if first(region) < first(span)\n                              first(region):first(span)-1\n                          else\n                              last(span)+1:last(region)\n                          end,\n-                         :region)\n+                         :region))\n             # If `span` fits exactly within `region`, then we've only copied over\n             # the beginning overhang, but also need to conserve the end overhang.\n             if first(region) < first(span) && last(span) < last(region)\n-                push!(extras, (i, setindex(annot, last(span)+1:last(region), :region)))\n+                push!(extras, (i, @inline(setindex(annot, last(span)+1:last(region), :region))))\n             end\n         end\n     end"
    },
    {
      "sha": "fec0ed800cddf7fb3ac5b9f477d2af6794d8cc86",
      "filename": "base/terminfo.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fterminfo.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4b12890211cae96c362e501b906354bf8ab2a484/base%2Fterminfo.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fterminfo.jl?ref=4b12890211cae96c362e501b906354bf8ab2a484",
      "patch": "@@ -69,7 +69,7 @@ struct TermInfo\n     aliases::Dict{Symbol, Symbol}\n end\n \n-TermInfo() = TermInfo([], Dict(), Dict(), Dict(), nothing, Dict())\n+TermInfo() = TermInfo(String[], Dict{Symbol, Bool}(), Dict{Symbol, Int}(), Dict{Symbol, String}(), nothing, Dict{Symbol, Symbol}())\n \n function read(data::IO, ::Type{TermInfoRaw})\n     # Parse according to `term(5)`"
    }
  ]
}