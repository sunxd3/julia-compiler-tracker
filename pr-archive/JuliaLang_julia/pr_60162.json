{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60162",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60162/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60162/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60162/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60162",
  "id": 3635530647,
  "node_id": "PR_kwDOABkWpM6z-UaX",
  "number": 60162,
  "title": "Bypass `SyntaxNode` in JuliaLowering; fix `kw` bug",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 163368715,
      "node_id": "MDU6TGFiZWwxNjMzNjg3MTU=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/parser",
      "name": "parser",
      "color": "bfdadc",
      "default": false,
      "description": "Language parsing and surface syntax"
    },
    {
      "id": 250223102,
      "node_id": "MDU6TGFiZWwyNTAyMjMxMDI=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:lowering",
      "name": "compiler:lowering",
      "color": "5319e7",
      "default": false,
      "description": "Syntax lowering (compiler front end, 2nd stage)"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 2,
  "created_at": "2025-11-18T00:04:55Z",
  "updated_at": "2025-12-02T23:51:45Z",
  "closed_at": "2025-12-02T23:51:16Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60162",
    "html_url": "https://github.com/JuliaLang/julia/pull/60162",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60162.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60162.patch",
    "merged_at": "2025-12-02T23:51:16Z"
  },
  "body": "I set out to fix a stdlib compilation failure https://github.com/c42f/JuliaLowering.jl/issues/98, but ran\r\ninto a limitation in the JuliaSyntax AST.  Instead of hacking in a fix, this PR\r\nattempts to address https://github.com/c42f/JuliaLowering.jl/issues/77 too.\r\n\r\n## `kw`\r\n\r\nThe `kw` form isn't produced in `SyntaxNode`/`SyntaxTree` like it is in Expr,\r\nwhich simplifies the parser, but causes problems once we start start caring\r\nabout the semantics of these trees.  Parsing `\"f(a=1)\"` will always produce an\r\n`Expr(:call, :f, Expr(:kw, :a, 1))`, but the equivalent SyntaxNode\r\nrepresentation `(call f (= a 1))` makes `Expr(:call, :f, Expr(:(=), :a, 1))`\r\nunrepresentable, even though that's valid syntax a macro could produce.\r\n\r\nTo fix this, we need to convert `=` to `kw` within certain forms before\r\nmacro expansion.\r\n\r\n## One problem\r\nThere is currently no good place to put this conversion. Here's the path\r\nfrom source to lowering:\r\n\r\n```\r\n    (source text)\r\n         |\r\n       1 |\r\n         v\r\n[JS] RawGreenNode\r\n         |      \\ 5a\r\n      2* |       \\\r\n         v        ----> Expr\r\n[JS] SyntaxNode  /      /\r\n         |      / 5b   /\r\n      3* |     /      /\r\n         v    /      /\r\n[JL] SyntaxTree0 <--- 6\r\n         |\r\n       4 |\r\n         v\r\n[JL] SyntaxTree1\r\n         |\r\n         |\r\n         v\r\n (desugaring and beyond)\r\n```\r\n\r\n*(2) and (3) are pretty trivial, and data structure names are used as\r\nshorthand for what actually matters to this issue (the tree represented by the\r\ndata structure).\r\n\r\n1. is parsing, which is the most complex of any of these steps.\r\n2. `JS._to_SyntaxNode`, which just deletes trivia\r\n3. `JL._convert_nodes`, which is more-or-less a one-to-one conversion, and I\r\n   think is an artifact of JuliaSyntax and JuliaLowering being in separate\r\n   repositories.  @c42f has talked about wanting to replace SyntaxNode with\r\n   SyntaxTree eventually.\r\n4. Random fixups in JuliaLowering's macro expansion step to make desugaring\r\n   easier\r\n5. `JS._node_to_expr`, which is used for femtolisp lowering (5a) and for\r\n   JuliaLowering's compatibility with existing macros (5b)\r\n6. `JL.expr_to_syntaxtree`, which is also used for Expr-macro compatibility\r\n\r\nExpr gets the chance to swap out `=` within `(call (parameters ...))` in\r\n`_node_to_expr`, but to change SyntaxTree we can only change parsing.  (The\r\ninverse is also true: if someone wants to change parsing to `RawGreenNode`,\r\nJuliaLowering will have to eat it).\r\n\r\nThis PR implements the following instead, where `_green_to_ast` happens at (2)\r\nand may fix up the AST before lowering.  Ideally this means more room for parser\r\ncleanup and eventually eliminating our \"pre-desugaring\" mixed in with macro\r\nexpansion.\r\n\r\n```\r\n(source text)\r\n     |\r\n   1 |\r\n     v        3\r\nRawGreenNode ---> Expr\r\n     |\r\n   2 |   4 -----> Expr\r\n     v    /       /\r\nSyntaxTree0 <----- 5\r\n     |\r\n     |      <- TODO delete\r\n     v\r\nSyntaxTree1\r\n     |\r\n     |\r\n     v\r\n(desugaring and beyond)\r\n```\r\n\r\nThe catch is that if we want SyntaxTree to be different from RawGreenNode, we do\r\nneed to convert them to Expr differently.  There are a few things we could do:\r\n- Separate the RawGreenNode->Expr and SyntaxTree->Expr transformations\r\n  (pictured, and implemented).\r\n- Make RawGreenNode->SyntaxTree a necessary prerequisite for creating an Expr.\r\n  This would add a step to our current femtolisp-lowered parsing (why)\r\n- Give up on making `SyntaxTree` structurally different from Expr (I wouldn't\r\n  mind this) and try to feed them through the same generic code (not so sure\r\n  about that).\r\n\r\nFor now I've done the lazy thing by using a boolean parameter to implement the\r\nfirst option.\r\n\r\nI also took this opportunity to put the green tree into the syntax graph.  This\r\ndoesn't really change anything given how little we look at the green tree, but\r\nwasn't difficult, and it's a neat representation.\r\n\r\n## `kw` notes\r\nI've made SyntaxTree and Expr the same here, though some inconsistencies could\r\nbe ironed out in the future with syntax evolution.  Ideally, we use `kw`\r\nwherever a textual `=` behaves more like a `=>`, or if `\"=\"` is a parse error,\r\nwherever it would be more consistent to treat it like `=>`.\r\n\r\n| Kind        | Source         | Expr and this PR    | Ideal                 |\r\n|-------------|----------------|:--------------------|:----------------------|\r\n| `call`*     | ` x(a=1,;b=1)` | `(kw a 1) (kw b 1)` | `(kw a 1) (kw b 1)`   |\r\n| `dotcall`   | `x.(a=1,;b=1)` | `(kw a 1) (kw b 1)` | `(kw a 1) (kw b 1)`   |\r\n| `ref`       | ` x[a=1,;b=1]` | `(kw a 1) (=  b 1)` | `(kw a 1) (kw b 1)`   |\r\n| `curly`     | ` x{a=1,;b=1}` | `(=  a 1) (=  b 1)` | `(kw a 1) (kw b 1)`   |\r\n| `tuple`     | `  (a=1,;b=1)` | `(=  a 1) (kw b 1)` | `(kw a 1) (kw b 1)`   |\r\n| `vect`      | `  [a=1,;b=1]` | `(=  a 1) (=  b 1)` | `(=  a 1) (kw b 1)`   |\r\n| `braces`    | `  {a=1,;b=1}` | `(=  a 1) (=  b 1)` | `(=  a 1) (kw b 1)`   |\r\n| `macrocall` | `@x(a=1,;b=1)` | `(=  a 1) (kw b 1)` | `(=  a 1) (kw b 1)`   |\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60162/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60162/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0
}