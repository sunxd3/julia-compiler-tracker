{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60162",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60162/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60162/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60162/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60162",
  "id": 3635530647,
  "node_id": "PR_kwDOABkWpM6z-UaX",
  "number": 60162,
  "title": "Bypass `SyntaxNode` in JuliaLowering; fix `kw` bug",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 163368715,
      "node_id": "MDU6TGFiZWwxNjMzNjg3MTU=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/parser",
      "name": "parser",
      "color": "bfdadc",
      "default": false,
      "description": "Language parsing and surface syntax"
    },
    {
      "id": 250223102,
      "node_id": "MDU6TGFiZWwyNTAyMjMxMDI=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:lowering",
      "name": "compiler:lowering",
      "color": "5319e7",
      "default": false,
      "description": "Syntax lowering (compiler front end, 2nd stage)"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 2,
  "created_at": "2025-11-18T00:04:55Z",
  "updated_at": "2025-12-02T23:51:45Z",
  "closed_at": "2025-12-02T23:51:16Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60162",
    "html_url": "https://github.com/JuliaLang/julia/pull/60162",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60162.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60162.patch",
    "merged_at": "2025-12-02T23:51:16Z"
  },
  "body": "I set out to fix a stdlib compilation failure https://github.com/c42f/JuliaLowering.jl/issues/98, but ran\r\ninto a limitation in the JuliaSyntax AST.  Instead of hacking in a fix, this PR\r\nattempts to address https://github.com/c42f/JuliaLowering.jl/issues/77 too.\r\n\r\n## `kw`\r\n\r\nThe `kw` form isn't produced in `SyntaxNode`/`SyntaxTree` like it is in Expr,\r\nwhich simplifies the parser, but causes problems once we start start caring\r\nabout the semantics of these trees.  Parsing `\"f(a=1)\"` will always produce an\r\n`Expr(:call, :f, Expr(:kw, :a, 1))`, but the equivalent SyntaxNode\r\nrepresentation `(call f (= a 1))` makes `Expr(:call, :f, Expr(:(=), :a, 1))`\r\nunrepresentable, even though that's valid syntax a macro could produce.\r\n\r\nTo fix this, we need to convert `=` to `kw` within certain forms before\r\nmacro expansion.\r\n\r\n## One problem\r\nThere is currently no good place to put this conversion. Here's the path\r\nfrom source to lowering:\r\n\r\n```\r\n    (source text)\r\n         |\r\n       1 |\r\n         v\r\n[JS] RawGreenNode\r\n         |      \\ 5a\r\n      2* |       \\\r\n         v        ----> Expr\r\n[JS] SyntaxNode  /      /\r\n         |      / 5b   /\r\n      3* |     /      /\r\n         v    /      /\r\n[JL] SyntaxTree0 <--- 6\r\n         |\r\n       4 |\r\n         v\r\n[JL] SyntaxTree1\r\n         |\r\n         |\r\n         v\r\n (desugaring and beyond)\r\n```\r\n\r\n*(2) and (3) are pretty trivial, and data structure names are used as\r\nshorthand for what actually matters to this issue (the tree represented by the\r\ndata structure).\r\n\r\n1. is parsing, which is the most complex of any of these steps.\r\n2. `JS._to_SyntaxNode`, which just deletes trivia\r\n3. `JL._convert_nodes`, which is more-or-less a one-to-one conversion, and I\r\n   think is an artifact of JuliaSyntax and JuliaLowering being in separate\r\n   repositories.  @c42f has talked about wanting to replace SyntaxNode with\r\n   SyntaxTree eventually.\r\n4. Random fixups in JuliaLowering's macro expansion step to make desugaring\r\n   easier\r\n5. `JS._node_to_expr`, which is used for femtolisp lowering (5a) and for\r\n   JuliaLowering's compatibility with existing macros (5b)\r\n6. `JL.expr_to_syntaxtree`, which is also used for Expr-macro compatibility\r\n\r\nExpr gets the chance to swap out `=` within `(call (parameters ...))` in\r\n`_node_to_expr`, but to change SyntaxTree we can only change parsing.  (The\r\ninverse is also true: if someone wants to change parsing to `RawGreenNode`,\r\nJuliaLowering will have to eat it).\r\n\r\nThis PR implements the following instead, where `_green_to_ast` happens at (2)\r\nand may fix up the AST before lowering.  Ideally this means more room for parser\r\ncleanup and eventually eliminating our \"pre-desugaring\" mixed in with macro\r\nexpansion.\r\n\r\n```\r\n(source text)\r\n     |\r\n   1 |\r\n     v        3\r\nRawGreenNode ---> Expr\r\n     |\r\n   2 |   4 -----> Expr\r\n     v    /       /\r\nSyntaxTree0 <----- 5\r\n     |\r\n     |      <- TODO delete\r\n     v\r\nSyntaxTree1\r\n     |\r\n     |\r\n     v\r\n(desugaring and beyond)\r\n```\r\n\r\nThe catch is that if we want SyntaxTree to be different from RawGreenNode, we do\r\nneed to convert them to Expr differently.  There are a few things we could do:\r\n- Separate the RawGreenNode->Expr and SyntaxTree->Expr transformations\r\n  (pictured, and implemented).\r\n- Make RawGreenNode->SyntaxTree a necessary prerequisite for creating an Expr.\r\n  This would add a step to our current femtolisp-lowered parsing (why)\r\n- Give up on making `SyntaxTree` structurally different from Expr (I wouldn't\r\n  mind this) and try to feed them through the same generic code (not so sure\r\n  about that).\r\n\r\nFor now I've done the lazy thing by using a boolean parameter to implement the\r\nfirst option.\r\n\r\nI also took this opportunity to put the green tree into the syntax graph.  This\r\ndoesn't really change anything given how little we look at the green tree, but\r\nwasn't difficult, and it's a neat representation.\r\n\r\n## `kw` notes\r\nI've made SyntaxTree and Expr the same here, though some inconsistencies could\r\nbe ironed out in the future with syntax evolution.  Ideally, we use `kw`\r\nwherever a textual `=` behaves more like a `=>`, or if `\"=\"` is a parse error,\r\nwherever it would be more consistent to treat it like `=>`.\r\n\r\n| Kind        | Source         | Expr and this PR    | Ideal                 |\r\n|-------------|----------------|:--------------------|:----------------------|\r\n| `call`*     | ` x(a=1,;b=1)` | `(kw a 1) (kw b 1)` | `(kw a 1) (kw b 1)`   |\r\n| `dotcall`   | `x.(a=1,;b=1)` | `(kw a 1) (kw b 1)` | `(kw a 1) (kw b 1)`   |\r\n| `ref`       | ` x[a=1,;b=1]` | `(kw a 1) (=  b 1)` | `(kw a 1) (kw b 1)`   |\r\n| `curly`     | ` x{a=1,;b=1}` | `(=  a 1) (=  b 1)` | `(kw a 1) (kw b 1)`   |\r\n| `tuple`     | `  (a=1,;b=1)` | `(=  a 1) (kw b 1)` | `(kw a 1) (kw b 1)`   |\r\n| `vect`      | `  [a=1,;b=1]` | `(=  a 1) (=  b 1)` | `(=  a 1) (kw b 1)`   |\r\n| `braces`    | `  {a=1,;b=1}` | `(=  a 1) (=  b 1)` | `(=  a 1) (kw b 1)`   |\r\n| `macrocall` | `@x(a=1,;b=1)` | `(=  a 1) (kw b 1)` | `(=  a 1) (kw b 1)`   |\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60162/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60162/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "bb405abeaa24226f1d6e698e8acd2a5acee73cce",
      "filename": "JuliaLowering/src/compat.jl",
      "status": "modified",
      "additions": 12,
      "deletions": 16,
      "changes": 28,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fcompat.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -34,9 +34,7 @@ end\n     graph = syntax_graph(ctx)\n     toplevel_src = if isnothing(lnn)\n         # Provenance sinkhole for all nodes until we hit a linenode\n-        dummy_src = SourceRef(\n-            SourceFile(\"No source for expression\"),\n-            1, JS.GreenNode(K\"None\", 0))\n+        dummy_src = SourceRef(SourceFile(\"No source for expression\"), 1, 0)\n         _insert_tree_node(graph, K\"None\", dummy_src)\n     else\n         lnn\n@@ -46,15 +44,14 @@ end\n     return out\n end\n \n-function _expr_replace!(@nospecialize(e), replace_pred::Function, replacer!::Function,\n+function _expr_replace(@nospecialize(e), replace_pred::Function, replacer::Function,\n                         recurse_pred=(@nospecialize e)->true)\n     if replace_pred(e)\n-        replacer!(e)\n-    end\n-    if e isa Expr && recurse_pred(e)\n-        for a in e.args\n-            _expr_replace!(a, replace_pred, replacer!, recurse_pred)\n-        end\n+        replacer(e)\n+    elseif e isa Expr && recurse_pred(e)\n+        Expr(e.head, Any[_expr_replace(a, replace_pred, replacer, recurse_pred) for a in e.args]...)\n+    else\n+        e\n     end\n end\n \n@@ -366,7 +363,8 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n             lam_eqs = Any[]\n             for a in a1.args\n                 a isa LineNumberNode && continue\n-                a isa Expr && a.head === :(=) ? push!(lam_eqs, a) : push!(lam_args, a)\n+                a isa Expr && a.head === :(=) ?\n+                    push!(lam_eqs, Expr(:kw, a.args...)) : push!(lam_args, a)\n             end\n             !isempty(lam_eqs) && push!(lam_args, Expr(:parameters, lam_eqs...))\n             child_exprs[1] = a1_esc(Expr(:tuple, lam_args...))\n@@ -436,11 +434,9 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n         child_exprs = child_exprs[2:end]\n         # TODO handle docstrings after refactor\n     elseif (e.head === :using || e.head === :import)\n-        _expr_replace!(e,\n-                       (e)->(e isa Expr && e.head === :.),\n-                       (e)->(e.head = :importpath))\n-    elseif e.head === :kw\n-        st_k = K\"=\"\n+        e2 = _expr_replace(e, (e)->(e isa Expr && e.head === :.),\n+                           (e)->Expr(:importpath, e.args...))\n+        child_exprs = e2.args\n     elseif e.head in (:local, :global) && nargs > 1\n         # Possible normalization\n         # child_exprs = Any[Expr(:tuple, child_exprs...)]"
    },
    {
      "sha": "98969a9043a5596f5379b659f6e1fe26dafe53be",
      "filename": "JuliaLowering/src/desugaring.jl",
      "status": "modified",
      "additions": 46,
      "deletions": 35,
      "changes": 81,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fdesugaring.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -86,7 +86,7 @@ function check_no_parameters(ex::SyntaxTree, msg)\n end\n \n function check_no_assignment(exs, msg=\"misplaced assignment statement in `[ ... ]`\")\n-    i = findfirst(kind(e) == K\"=\" for e in exs)\n+    i = findfirst(kind(e) == K\"=\" || kind(e) == K\"kw\" for e in exs)\n     if !isnothing(i)\n         throw(LoweringError(exs[i], msg))\n     end\n@@ -532,17 +532,17 @@ end\n \n #-------------------------------------------------------------------------------\n # Expansion of array indexing\n-function _arg_to_temp(ctx, stmts, ex, eq_is_kw=false)\n+function _arg_to_temp(ctx, stmts, ex)\n     k = kind(ex)\n     if is_effect_free(ex)\n         ex\n     elseif k == K\"...\"\n         @ast ctx ex [k _arg_to_temp(ctx, stmts, ex[1])]\n-    elseif k == K\"=\" && eq_is_kw\n-        @ast ctx ex [K\"=\" ex[1] _arg_to_temp(ctx, stmts, ex[2], false)]\n+    elseif k == K\"kw\"\n+        @ast ctx ex [K\"kw\" ex[1] _arg_to_temp(ctx, stmts, ex[2])]\n     elseif k == K\"parameters\"\n         mapchildren(ctx, ex) do e\n-            _arg_to_temp(ctx, stmts, e, true)\n+            _arg_to_temp(ctx, stmts, e)\n         end\n     else\n         emit_assign_tmp(stmts, ctx, ex)\n@@ -565,9 +565,8 @@ function remove_argument_side_effects(ctx, stmts, ex)\n             emit_assign_tmp(stmts, ctx, ex)\n         else\n             args = SyntaxList(ctx)\n-            eq_is_kw = ((k == K\"call\" || k == K\"dotcall\") && is_prefix_call(ex)) || k == K\"ref\"\n             for (i,e) in enumerate(children(ex))\n-                push!(args, _arg_to_temp(ctx, stmts, e, eq_is_kw && i > 1))\n+                push!(args, _arg_to_temp(ctx, stmts, e))\n             end\n             # TODO: Copy attributes?\n             @ast ctx ex [k args...]\n@@ -1613,7 +1612,7 @@ function _merge_named_tuple(ctx, srcref, old, new)\n     end\n end\n \n-function expand_named_tuple(ctx, ex, kws;\n+function expand_named_tuple(ctx, ex, kws, eq_is_kw;\n                             field_name=\"named tuple field\",\n                             element_name=\"named tuple element\")\n     name_strs = Set{String}()\n@@ -1628,7 +1627,8 @@ function expand_named_tuple(ctx, ex, kws;\n             # x  ==>  x = x\n             name = to_symbol(ctx, kw)\n             value = kw\n-        elseif k == K\"=\"\n+        elseif k == K\"kw\" || (eq_is_kw && k == K\"=\")\n+            # syntax TODO: This should parse to K\"kw\"\n             # x = a\n             if kind(kw[1]) != K\"Identifier\" && kind(kw[1]) != K\"Placeholder\"\n                 throw(LoweringError(kw[1], \"invalid $field_name name\"))\n@@ -1696,7 +1696,7 @@ end\n function expand_kw_call(ctx, srcref, farg, args, kws)\n     @ast ctx srcref [K\"block\"\n         func := farg\n-        kw_container := expand_named_tuple(ctx, srcref, kws;\n+        kw_container := expand_named_tuple(ctx, srcref, kws, false;\n                                            field_name=\"keyword argument\",\n                                            element_name=\"keyword argument\")\n         if all(kind(kw) == K\"...\" for kw in kws)\n@@ -1869,7 +1869,7 @@ function remove_kw_args!(ctx, args::SyntaxList)\n     for i in 1:length(args)\n         arg = args[i]\n         k = kind(arg)\n-        if k == K\"=\"\n+        if k == K\"kw\"\n             if isnothing(kws)\n                 kws = SyntaxList(ctx)\n             end\n@@ -2277,7 +2277,7 @@ end\n function expand_function_arg(ctx, body_stmts, arg, is_last_arg, is_kw, arg_id)\n     ex = arg\n \n-    if kind(ex) == K\"=\"\n+    if kind(ex) == K\"kw\"\n         default = ex[2]\n         ex = ex[1]\n     else\n@@ -2858,8 +2858,10 @@ function keyword_function_defs(ctx, srcref, callex_srcref, name_str, typevar_nam\n             kwcall_body_tail\n         ]\n     else\n-        scope_nest(ctx, kw_names, kw_values, kwcall_body_tail)\n+        scope_nest(ctx, has_kw_slurp ? kw_names[1:end-1] : kw_names,\n+                   kw_values, kwcall_body_tail)\n     end\n+\n     main_kwcall_typevars = trim_used_typevars(ctx, kwcall_arg_types, typevar_names, typevar_stmts)\n     push!(kwcall_method_defs,\n           method_def_expr(ctx, srcref, callex_srcref, kwcall_mtable,\n@@ -3233,6 +3235,29 @@ end\n \n #-------------------------------------------------------------------------------\n # Anon function syntax\n+function expand_arrow_args(ctx, arglist)\n+    k = kind(arglist)\n+    # The arglist can sometimes be parsed as a block, or something else, and\n+    # fixing this is extremely awkward when nested inside `where`. See\n+    # https://github.com/JuliaLang/JuliaSyntax.jl/pull/522\n+    if k == K\"block\"\n+        @chk numchildren(arglist) == 2\n+        kw = arglist[2]\n+        if kind(kw) === K\"=\"\n+            kw = @ast ctx kw [K\"kw\" children(kw)...]\n+        end\n+        arglist = @ast ctx arglist [K\"tuple\"\n+            arglist[1]\n+            [K\"parameters\" kw]\n+        ]\n+    elseif k != K\"tuple\"\n+        arglist = @ast ctx arglist [K\"tuple\" arglist]\n+    end\n+    return mapchildren(ctx, arglist) do a\n+        kind(a) === K\"=\" ? @ast(ctx, a, [K\"kw\" children(a)...]) : a\n+    end\n+end\n+\n function expand_arrow_arglist(ctx, arglist, arrowname)\n     k = kind(arglist)\n     if k == K\"where\"\n@@ -3241,23 +3266,9 @@ function expand_arrow_arglist(ctx, arglist, arrowname)\n             arglist[2]\n         ]\n     else\n-        # The arglist can sometimes be parsed as a block, or something else, and\n-        # fixing this is extremely awkward when nested inside `where`. See\n-        # https://github.com/JuliaLang/JuliaSyntax.jl/pull/522\n-        if k == K\"block\"\n-            @chk numchildren(arglist) == 2\n-            arglist = @ast ctx arglist [K\"tuple\"\n-                arglist[1]\n-                [K\"parameters\" arglist[2]]\n-            ]\n-        elseif k != K\"tuple\"\n-            arglist = @ast ctx arglist [K\"tuple\"\n-                arglist[1]\n-            ]\n-        end\n         @ast ctx arglist [K\"call\"\n             arrowname::K\"Placeholder\"\n-            children(arglist)...\n+            children(expand_arrow_args(ctx, arglist))...\n         ]\n     end\n end\n@@ -3280,7 +3291,7 @@ function expand_opaque_closure(ctx, ex)\n     func_expr = ex[5]\n     @chk kind(func_expr) == K\"->\"\n     @chk numchildren(func_expr) == 2\n-    args = func_expr[1]\n+    args = expand_arrow_args(ctx, func_expr[1])\n     @chk kind(args) == K\"tuple\"\n     check_no_parameters(ex, args)\n \n@@ -3829,7 +3840,7 @@ function _rewrite_ctor_new_calls(ctx, ex, struct_name, global_struct_name, ctor_\n         )\n     end\n     # Rewrite a call to new()\n-    kw_arg_i = findfirst(e->(k = kind(e); k == K\"=\" || k == K\"parameters\"), children(ex))\n+    kw_arg_i = findfirst(e->(k = kind(e); k == K\"kw\" || k == K\"parameters\"), children(ex))\n     if !isnothing(kw_arg_i)\n         throw(LoweringError(ex[kw_arg_i], \"`new` does not accept keyword arguments\"))\n     end\n@@ -4147,7 +4158,7 @@ function expand_struct_def(ctx, ex, docs)\n                 struct_name\n                 isnothing(docs) ? nothing_(ctx, ex) : docs[1]\n                 ::K\"SourceLocation\"(ex)\n-                [K\"=\"\n+                [K\"kw\"\n                     \"field_docs\"::K\"Identifier\"\n                     [K\"call\" \"svec\"::K\"core\" field_docs...]\n                 ]\n@@ -4194,7 +4205,7 @@ end\n function expand_curly(ctx, ex)\n     @assert kind(ex) == K\"curly\"\n     check_no_parameters(ex, \"unexpected semicolon in type parameter list\")\n-    check_no_assignment(children(ex), \"misplace assignment in type parameter list\")\n+    check_no_assignment(children(ex), \"misplaced assignment in type parameter list\")\n \n     typevar_stmts = SyntaxList(ctx)\n     type_args = SyntaxList(ctx)\n@@ -4512,9 +4523,9 @@ function expand_forms_2(ctx::DesugaringContext, ex::SyntaxTree, docs=nothing)\n             if numchildren(ex) > 1\n                 throw(LoweringError(ex[end], \"unexpected semicolon in tuple - use `,` to separate tuple elements\"))\n             end\n-            expand_forms_2(ctx, expand_named_tuple(ctx, ex, children(ex[1])))\n+            expand_forms_2(ctx, expand_named_tuple(ctx, ex, children(ex[1]), true))\n         elseif any_assignment(children(ex))\n-            expand_forms_2(ctx, expand_named_tuple(ctx, ex, children(ex)))\n+            expand_forms_2(ctx, expand_named_tuple(ctx, ex, children(ex), true))\n         else\n             expand_forms_2(ctx, @ast ctx ex [K\"call\"\n                 \"tuple\"::K\"core\"\n@@ -4558,7 +4569,7 @@ function expand_forms_2(ctx::DesugaringContext, ex::SyntaxTree, docs=nothing)\n                 ctx.mod               ::K\"Value\"\n                 [K\"inert\" ex]\n                 [K\"parameters\"\n-                    [K\"=\"\n+                    [K\"kw\"\n                         \"expr_compat_mode\"::K\"Identifier\"\n                         ctx.expr_compat_mode::K\"Bool\"\n                     ]"
    },
    {
      "sha": "9bf04e1a80183ec1447167943e3eb2dc54c44a13",
      "filename": "JuliaLowering/src/hooks.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fhooks.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fhooks.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fhooks.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -15,7 +15,7 @@ function core_lowering_hook(@nospecialize(code), mod::Module,\n     file = file isa Ptr{UInt8} ? unsafe_string(file) : file\n     line = !(line isa Int) ? Int(line) : line\n \n-    local st0 = nothing\n+    local st0, st1 = nothing, nothing\n     try\n         st0 = code isa Expr ? expr_to_syntaxtree(code, LineNumberNode(line, file)) : code\n         if kind(st0) in KSet\"toplevel module\"\n@@ -32,7 +32,7 @@ function core_lowering_hook(@nospecialize(code), mod::Module,\n         ex = to_lowered_expr(st5)\n         return Core.svec(ex, st5, ctx5)\n     catch exc\n-        @info(\"JuliaLowering threw given input:\", code=code, st0=st0, file=file, line=line, mod=mod)\n+        @info(\"JuliaLowering threw given input:\", code=code, st0=st0, st1=st1, file=file, line=line, mod=mod)\n         rethrow(exc)\n \n         # TODO: Re-enable flisp fallback once we're done collecting errors"
    },
    {
      "sha": "28b36c2f6dfc0134f7841f853348692aeea86a63",
      "filename": "JuliaLowering/src/macro_expansion.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fmacro_expansion.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -471,8 +471,9 @@ function expand_forms_1(ctx::MacroExpansionContext, ex::SyntaxTree)\n         # TODO: Upstream should set a general flag for detecting parenthesized\n         # expressions so we don't need to dig into `green_tree` here. Ugh!\n         plain_symbol = has_flags(ex, JuliaSyntax.COLON_QUOTE) &&\n-                       kind(ex[1]) == K\"Identifier\" &&\n-                       (sr = sourceref(ex); sr isa SourceRef && kind(sr.green_tree[2]) != K\"parens\")\n+            kind(ex[1]) == K\"Identifier\" && (\n+                prov = flattened_provenance(ex);\n+                length(prov) >= 1 && kind(prov[end][end]) != K\"parens\")\n         if plain_symbol\n             # As a compromise for compatibility, we treat non-parenthesized\n             # colon quoted identifiers like `:x` as plain Symbol literals"
    },
    {
      "sha": "2630825197e55bd07b0d287afa1d587a6ca5defc",
      "filename": "JuliaLowering/src/syntax_graph.jl",
      "status": "modified",
      "additions": 129,
      "deletions": 40,
      "changes": 169,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fsyntax_graph.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -1,3 +1,8 @@\n+# TODO: This whole file should probably be moved to JuliaSyntax.\n+import .JuliaSyntax: ParseStream, RedTreeCursor, reverse_toplevel_siblings,\n+    has_toplevel_siblings, _unsafe_wrap_substring, parse_julia_literal, is_trivia,\n+    is_prefix_op_call, @isexpr, SyntaxHead, COLON_QUOTE, is_syntactic_operator\n+\n const NodeId = Int\n \n \"\"\"\n@@ -180,28 +185,6 @@ function setflags!(graph, id::NodeId, f::UInt16)\n     graph.syntax_flags[id] = f\n end\n \n-function _convert_nodes(graph::SyntaxGraph, node::SyntaxNode)\n-    id = newnode!(graph)\n-    sethead!(graph, id, head(node))\n-    if !isnothing(node.val)\n-        v = node.val\n-        if v isa Symbol\n-            # TODO: Fixes in JuliaSyntax to avoid ever converting to Symbol\n-            setattr!(graph, id, name_val=string(v))\n-        else\n-            setattr!(graph, id, value=v)\n-        end\n-    end\n-    setattr!(graph, id, source=SourceRef(node.source, node.position, node.raw))\n-    if !is_leaf(node)\n-        cs = map(children(node)) do n\n-            _convert_nodes(graph, n)\n-        end\n-        setchildren!(graph, id, cs)\n-    end\n-    return id\n-end\n-\n \"\"\"\n     syntax_graph(ctx)\n \n@@ -333,12 +316,11 @@ end\n struct SourceRef\n     file::SourceFile\n     first_byte::Int\n-    # TODO: Do we need the green node, or would last_byte suffice?\n-    green_tree::JuliaSyntax.GreenNode\n+    last_byte::Int\n end\n \n JuliaSyntax.sourcefile(src::SourceRef) = src.file\n-JuliaSyntax.byte_range(src::SourceRef) = src.first_byte:(src.first_byte + span(src.green_tree) - 1)\n+JuliaSyntax.byte_range(src::SourceRef) = src.first_byte:src.last_byte\n \n # TODO: Adding these methods to support LineNumberNode is kind of hacky but we\n # can remove these after JuliaLowering becomes self-bootstrapping for macros\n@@ -449,17 +431,6 @@ end\n \n const SourceAttrType = Union{SourceRef,LineNumberNode,NodeId,Tuple}\n \n-function SyntaxTree(graph::SyntaxGraph, node::SyntaxNode)\n-    ensure_attributes!(graph, kind=Kind, syntax_flags=UInt16, source=SourceAttrType,\n-                       value=Any, name_val=String)\n-    id = _convert_nodes(graph, node)\n-    return SyntaxTree(graph, id)\n-end\n-\n-function SyntaxTree(node::SyntaxNode)\n-    return SyntaxTree(SyntaxGraph(), node)\n-end\n-\n attrsummary(name, value) = string(name)\n attrsummary(name, value::Number) = \"$name=$value\"\n \n@@ -577,10 +548,6 @@ end\n \n syntax_graph(ex::SyntaxTree) = ex._graph\n \n-function JuliaSyntax.build_tree(::Type{SyntaxTree}, stream::JuliaSyntax.ParseStream; kws...)\n-    SyntaxTree(JuliaSyntax.build_tree(SyntaxNode, stream; kws...))\n-end\n-\n JuliaSyntax.sourcefile(ex::SyntaxTree) = sourcefile(sourceref(ex))\n JuliaSyntax.byte_range(ex::SyntaxTree) = byte_range(sourceref(ex))\n \n@@ -607,6 +574,20 @@ function JuliaSyntax._expr_leaf_val(ex::SyntaxTree, _...)\n     end\n end\n \n+function JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, head::SyntaxHead,\n+                                      @nospecialize(arg), first::Bool)\n+    isa(arg, Expr) || return arg\n+    k = kind(head)\n+    coalesce_dot = k in KSet\"call dotcall curly\" ||\n+                   (k == K\"quote\" && has_flags(head, COLON_QUOTE))\n+    if @isexpr(arg, :., 1) && arg.args[1] isa Tuple\n+        h, a = arg.args[1]::Tuple{SyntaxHead,Any}\n+        arg = ((coalesce_dot && first) || is_syntactic_operator(h)) ?\n+            Symbol(\".\", a) : Expr(:., a)\n+    end\n+    return arg\n+end\n+\n Base.Expr(ex::SyntaxTree) = JuliaSyntax.to_expr(ex)\n \n #--------------------------------------------------\n@@ -829,3 +810,111 @@ end\n #     end\n #     out\n # end\n+\n+#-------------------------------------------------------------------------------\n+# Conversion from the raw parsed tree\n+# TODO: move to JuliaSyntax. Replace SyntaxNode?\n+\n+function JuliaSyntax.build_tree(::Type{SyntaxTree}, stream::ParseStream;\n+                                filename=nothing, first_line=1)\n+    cursor = RedTreeCursor(stream)\n+    graph = SyntaxGraph()\n+    sf = SourceFile(stream; filename, first_line)\n+    source = SourceRef(sf, first_byte(stream), last_byte(stream))\n+    cs = SyntaxList(graph)\n+    for c in reverse_toplevel_siblings(cursor)\n+        is_trivia(c) && !is_error(c) && continue\n+        push!(cs, SyntaxTree(graph, sf, c))\n+    end\n+    # There may be multiple non-trivia toplevel nodes (e.g. parse error)\n+    length(cs) === 1 && return only(cs)\n+    id = newnode!(graph)\n+    setchildren!(graph, id, reverse(cs).ids)\n+    setattr!(graph, id; source, kind=K\"wrapper\")\n+    return SyntaxTree(graph, id)\n+end\n+\n+function SyntaxTree(graph::SyntaxGraph, sf::SourceFile, cursor::RedTreeCursor)\n+    ensure_attributes!(graph, kind=Kind, syntax_flags=UInt16,\n+                       source=SourceAttrType, value=Any, name_val=String)\n+    green_id = GC.@preserve sf begin\n+        raw_offset, txtbuf = _unsafe_wrap_substring(sf.code)\n+        offset = raw_offset - sf.byte_offset\n+        _insert_green(graph, sf, txtbuf, offset, cursor)\n+    end\n+    out = _green_to_ast(K\"None\", SyntaxTree(graph, green_id))\n+    @assert !isnothing(out) \"SyntaxTree requires >0 nontrivia nodes\"\n+    return out\n+end\n+\n+# TODO: Do we really need all trivia?  K\"parens\" can be good to keep, but things\n+# like K\"(\" and whitespace might not be useful.\n+function _insert_green(graph::SyntaxGraph, sf::SourceFile,\n+                       txtbuf::Vector{UInt8}, offset::Int,\n+                       cursor::RedTreeCursor)\n+    id = newnode!(graph)\n+    sethead!(graph, id, head(cursor))\n+    setattr!(graph, id, source=SourceRef(sf, first_byte(cursor), last_byte(cursor)))\n+    if !is_leaf(cursor)\n+        cs = NodeId[]\n+        for c in reverse(cursor)\n+            push!(cs, _insert_green(graph, sf, txtbuf, offset, c))\n+        end\n+        setchildren!(graph, id, reverse(cs))\n+    else\n+        v = parse_julia_literal(txtbuf, head(cursor), byte_range(cursor) .+ offset)\n+        if v isa Symbol\n+            # TODO: Fixes in JuliaSyntax to avoid ever converting to Symbol\n+            setattr!(graph, id, name_val=string(v))\n+        elseif !isnothing(v)\n+            setattr!(graph, id, value=v)\n+        end\n+    end\n+    return id\n+end\n+\n+# Leaves are shared.  Unlike `mapchildren`, doesn't bother checking for\n+# unchanged children so internal nodes can be shared, since the likelihood of\n+# not deleting trivia under an internal node is practically zero.\n+function _green_to_ast(parent::Kind, ex::SyntaxTree; eq_to_kw=false)\n+    is_trivia(ex) && !is_error(ex) && return nothing\n+    graph = syntax_graph(ex)\n+    k = kind(ex)\n+    if k === K\"ref\" ||\n+        (k in KSet\"call dotcall\" && (\n+            is_prefix_call(ex) || is_prefix_op_call(ex) && numchildren(ex) > 2))\n+        cs = SyntaxList(ex)\n+        for c in children(ex)\n+            c2 = _green_to_ast(k, c; eq_to_kw=length(cs)>0)\n+            !isnothing(c2) && push!(cs, c2)\n+        end\n+        makenode(graph, ex, ex, cs)\n+    elseif k === K\"parameters\"\n+        eq_to_kw = parent != K\"vect\"   && parent != K\"curly\" &&\n+                   parent != K\"braces\" && parent != K\"ref\"\n+        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex); eq_to_kw))\n+    elseif k === K\"parens\"\n+        cs = _map_green_to_ast(parent, children(ex); eq_to_kw)\n+        @assert length(cs) === 1\n+        cs[1]\n+    elseif k in KSet\"var char\"\n+        cs = _map_green_to_ast(parent, children(ex))\n+        @assert length(cs) === 1\n+        cs[1]\n+    elseif k === K\"=\" && eq_to_kw\n+        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex)); kind=K\"kw\")\n+    elseif is_leaf(ex)\n+        return ex\n+    else\n+        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex)))\n+    end\n+end\n+\n+function _map_green_to_ast(parent::Kind, cs::SyntaxList; eq_to_kw=false)\n+    out = SyntaxList(cs)\n+    for c in cs\n+        c2 = _green_to_ast(parent, c; eq_to_kw)\n+        !isnothing(c2) && push!(out, c2)\n+    end\n+    return out\n+end"
    },
    {
      "sha": "00b5d1215546939e47e00b03d8ab6694c7bea90f",
      "filename": "JuliaLowering/src/syntax_macros.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fsyntax_macros.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Fsrc%2Fsyntax_macros.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fsyntax_macros.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -19,9 +19,13 @@ function _apply_nospecialize(ctx, ex)\n     k = kind(ex)\n     if k == K\"Identifier\" || k == K\"Placeholder\" || k == K\"tuple\"\n         setmeta(ex; nospecialize=true)\n-    elseif k == K\"...\" || k == K\"::\" || k == K\"=\"\n+    elseif k == K\"...\" || k == K\"::\" || k == K\"=\" || k == K\"kw\"\n+        # The @nospecialize macro is responsible for converting K\"=\" to K\"kw\".\n+        # Desugaring uses this helper internally, so we may see K\"kw\" too.\n         if k == K\"::\" && numchildren(ex) == 1\n             ex = @ast ctx ex [K\"::\" \"_\"::K\"Placeholder\" ex[1]]\n+        elseif k == K\"=\" && numchildren(ex) === 2\n+            ex = @ast ctx ex [K\"kw\" ex[1] ex[2]]\n         end\n         mapchildren(c->_apply_nospecialize(ctx, c), ctx, ex, 1:1)\n     else\n@@ -293,7 +297,7 @@ function _at_eval_code(ctx, srcref, mod, ex)\n                     mod\n                     [K\"quote\" ex]\n                     [K\"parameters\"\n-                        [K\"=\"\n+                        [K\"kw\"\n                             \"expr_compat_mode\"::K\"Identifier\"\n                             ctx.expr_compat_mode::K\"Bool\"\n                         ]"
    },
    {
      "sha": "a39f0967461931d2dff82a551c5c277ceb12adee",
      "filename": "JuliaLowering/test/compat.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Ftest%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Ftest%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fcompat.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -217,6 +217,8 @@ const JL = JuliaLowering\n             \"f(((a = 1)))\",\n             \"(((a = 1)),)\",\n             \"(;((a = 1)),)\",\n+            \"(a = 1) |> f\",\n+            \"(a = 1)'\",\n             \"a.b\",\n             \"a.@b x\",\n             \"f.(x,y)\","
    },
    {
      "sha": "ac1afbbf6ff5b17361f7bfd8108b43cd396bba4a",
      "filename": "JuliaLowering/test/functions.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Ftest%2Ffunctions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Ftest%2Ffunctions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Ffunctions.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -119,7 +119,7 @@ end\n \n # Passes desugaring, but T is detected as unused and throws an error.\n # Is it clear whether this should be `f(x::T) where T` or `f(x::T where T)`?\n-@test_broken JuliaLowering.include_string(test_mod, \"\"\"\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n let\n     f = ((x::T) where T) -> x\n     f(1)"
    },
    {
      "sha": "07441e8d6bb0cc9ce2fce287c7ea88a54e9d4a10",
      "filename": "JuliaLowering/test/quoting.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Ftest%2Fquoting.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Ftest%2Fquoting.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fquoting.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -28,9 +28,11 @@ end\n     (call g z)\n     \u251c\u2500 (call g z)\n     \u2502  \u2514\u2500 (call g z)\n-    \u2502     \u2514\u2500 @ string:3\n+    \u2502     \u2514\u2500 (call g \u2718 z \u2718)\n+    \u2502        \u2514\u2500 @ string:3\n     \u2514\u2500 ($ y)\n-       \u2514\u2500 @ string:5\n+       \u2514\u2500 ($ $ y)\n+          \u2514\u2500 @ string:5\n     \"\"\"\n @test sprint(io->showprov(io, ex[1][3])) == raw\"\"\"\n     begin"
    },
    {
      "sha": "10d0b17865e89ec352d359985ec0c42fed032546",
      "filename": "JuliaLowering/test/typedefs_ir.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Ftest%2Ftypedefs_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaLowering%2Ftest%2Ftypedefs_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Ftypedefs_ir.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -181,7 +181,7 @@ X{S, T=w}\n #---------------------\n LoweringError:\n X{S, T=w}\n-#   \u2514\u2500\u2500\u2518 \u2500\u2500 misplace assignment in type parameter list\n+#   \u2514\u2500\u2500\u2518 \u2500\u2500 misplaced assignment in type parameter list\n \n ########################################\n # Simple abstract type definition"
    },
    {
      "sha": "c5ecc5365ce88791e916d1e2c56ca20c4e37d097",
      "filename": "JuliaSyntax/src/integration/expr.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 6,
      "changes": 19,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -145,7 +145,7 @@ end\n \n # Shared fixups for Expr children in cases where the type of the parent node\n # affects the child layout.\n-function fixup_Expr_child(head::SyntaxHead, @nospecialize(arg), first::Bool)\n+function fixup_Expr_child(::Type, head::SyntaxHead, @nospecialize(arg), first::Bool)\n     isa(arg, Expr) || return arg\n     k = kind(head)\n     eq_to_kw_in_call = ((k == K\"call\" || k == K\"dotcall\") &&\n@@ -211,7 +211,8 @@ function parseargs!(retexpr::Expr, loc::LineNumberNode, cursor, source, txtbuf::\n         secondchildhead = firstchildhead\n         firstchildhead = head(child)\n         firstchildrange = byte_range(child)\n-        pushfirst!(args, fixup_Expr_child(head(cursor), expr, r === nothing))\n+        pushfirst!(args, fixup_Expr_child(\n+            typeof(cursor), head(cursor), expr, r === nothing))\n     end\n     return (firstchildhead, secondchildhead, firstchildrange)\n end\n@@ -285,7 +286,7 @@ function node_to_expr(cursor, source, txtbuf::Vector{UInt8}, txtbuf_offset::UInt\n             expr = node_to_expr(child, source, txtbuf, txtbuf_offset)\n             @assert expr !== nothing\n             # K\"block\" does not have special first-child handling, so we do not need to keep track of that here\n-            pushfirst!(args, fixup_Expr_child(head(cursor), expr, false))\n+            pushfirst!(args, fixup_Expr_child(typeof(cursor), head(cursor), expr, false))\n             pushfirst!(args, source_location(LineNumberNode, source, first(byte_range(child))))\n         end\n         isempty(args) && push!(args, loc)\n@@ -673,11 +674,15 @@ function build_tree(::Type{Expr}, stream::ParseStream, source::SourceFile)\n         entry = Expr(:block)\n         for child in\n                 Iterators.filter(should_include_node, reverse_toplevel_siblings(cursor))\n-            pushfirst!(entry.args, fixup_Expr_child(wrapper_head, node_to_expr(child, source, txtbuf), false))\n+            pushfirst!(entry.args, fixup_Expr_child(\n+                RedTreeCursor, wrapper_head,\n+                node_to_expr(child, source, txtbuf), false))\n         end\n         length(entry.args) == 1 && (entry = only(entry.args))\n     else\n-        entry = fixup_Expr_child(wrapper_head, node_to_expr(cursor, source, txtbuf), false)\n+        entry = fixup_Expr_child(\n+            RedTreeCursor, wrapper_head,\n+            node_to_expr(cursor, source, txtbuf), false)\n     end\n     return entry\n end\n@@ -686,7 +691,9 @@ function to_expr(node)\n     source = sourcefile(node)\n     txtbuf_offset, txtbuf = _unsafe_wrap_substring(sourcetext(source))\n     wrapper_head = SyntaxHead(K\"wrapper\",EMPTY_FLAGS)\n-    return fixup_Expr_child(wrapper_head, node_to_expr(node, source, txtbuf, UInt32(txtbuf_offset)), false)\n+    return fixup_Expr_child(\n+        typeof(node), wrapper_head,\n+        node_to_expr(node, source, txtbuf, UInt32(txtbuf_offset)), false)\n end\n \n Base.Expr(node::SyntaxNode) = to_expr(node)"
    },
    {
      "sha": "07b005e07ed9fd927b15ebe58ba0598812775d5b",
      "filename": "JuliaSyntax/src/julia/kinds.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5611a245f390835b52a5439f74eae6e03033ef2d/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl?ref=5611a245f390835b52a5439f74eae6e03033ef2d",
      "patch": "@@ -1027,6 +1027,7 @@ register_kinds!(JuliaSyntax, 0, [\n         \"char\"           # A char string node (containing delims + char data)\n         \"macrocall\"\n         \"parameters\"     # the list after ; in f(; a=1)\n+        \"kw\"\n         \"toplevel\"\n         \"tuple\"\n         \"ref\""
    }
  ]
}