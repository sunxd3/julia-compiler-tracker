{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59859",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59859/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59859/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59859/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59859",
  "id": 3520115696,
  "node_id": "PR_kwDOABkWpM6t_q0J",
  "number": 59859,
  "title": "bindings: Add native automatic re-export feature",
  "user": {
    "login": "Keno",
    "id": 1291671,
    "node_id": "MDQ6VXNlcjEyOTE2NzE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1291671?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Keno",
    "html_url": "https://github.com/Keno",
    "followers_url": "https://api.github.com/users/Keno/followers",
    "following_url": "https://api.github.com/users/Keno/following{/other_user}",
    "gists_url": "https://api.github.com/users/Keno/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Keno/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Keno/subscriptions",
    "organizations_url": "https://api.github.com/users/Keno/orgs",
    "repos_url": "https://api.github.com/users/Keno/repos",
    "events_url": "https://api.github.com/users/Keno/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Keno/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-10-16T02:44:21Z",
  "updated_at": "2025-10-31T17:42:17Z",
  "closed_at": "2025-10-31T17:42:15Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59859",
    "html_url": "https://github.com/JuliaLang/julia/pull/59859",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59859.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59859.patch",
    "merged_at": "2025-10-31T17:42:15Z"
  },
  "body": "This implements a native version of automatic re-export, similar to the macro from Reexport.jl. Doing this natively in the binding system has two key advantages:\r\n\r\n1. It properly participates in binding resolution and world ages. If a new binding is Revise'd into a re-exported module, this will now propagate.\r\n\r\n2. The re-exported bindings are allocated lazily, improving performance.\r\n\r\nAn accessor for this functionality is provided as `@Base.Experimental.reexport`. However, the only supported argument to this macro is single `using` statement (unlike the Reexport.jl version, which has more syntax). It is my expectation that Reexport.jl will be updated to make use of the underlying functionality here directly, the base version of the macro is mostly for testing.\r\n\r\nThere are a few design warts here - in particular, we inherit the module name exporting behavior\r\n(https://github.com/JuliaLang/Reexport.jl/issues/39).\r\n\r\nHowever, I think that would be best addressed by not exporting the module name itself from the modules but rather introducing the module name as an additional binding on `using` statements.\r\n\r\nHowever, this would be potentially breaking (even if the effect is unlikely to be seen in practice), so I'm not proposing it here. The Reexport.jl version of the macro can do whatever it needs to, including creating an explicit non-exported binding to suppress the automatic re-export for this if desired.\r\n\r\nPartially written by Claude Code.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59859/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59859/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "730a42eb1717daf21428320731992dd9f7862d46",
      "filename": "base/experimental.jl",
      "status": "modified",
      "additions": 51,
      "deletions": 0,
      "changes": 51,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/base%2Fexperimental.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/base%2Fexperimental.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fexperimental.jl?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -695,4 +695,55 @@ function wait_with_timeout(c::GenericCondition; first::Bool=false, timeout::Real\n     end\n end\n \n+\"\"\"\n+    Base.Experimental.@reexport using Module\n+\n+Automatically re-export all exported names from a module when using it.\n+\n+# Examples\n+\n+```jldoctest\n+julia> module A\n+           export foo\n+           foo() = \"foo from A\"\n+       end\n+A\n+\n+julia> module B\n+           using Base.Experimental: @reexport\n+           @reexport using ..A\n+           # Now B exports foo, even though it's defined in A\n+       end\n+B\n+\n+julia> using .B\n+\n+julia> foo()\n+\"foo from A\"\n+```\n+\n+!!! warning\n+    This interface is experimental and subject to change or removal without notice.\n+\"\"\"\n+macro reexport(ex)\n+    if !Meta.isexpr(ex, :using) || isempty(ex.args)\n+        error(\"@reexport must be used with a `using` statement, e.g., `@reexport using MyModule`\")\n+    end\n+\n+    # Check for `using Foo: x, y` syntax (not supported)\n+    if any(arg -> Meta.isexpr(arg, :(:)), ex.args)\n+        error(\"@reexport does not support `using Module: names` syntax\")\n+    end\n+\n+    # Generate _eval_using calls for each module in the using statement\n+    calls = Expr(:block)\n+    for mod_path in ex.args\n+        push!(calls.args, :($(Core._eval_using)($(__module__), $(QuoteNode(mod_path)), $(Base.JL_MODULE_USING_REEXPORT))))\n+    end\n+    push!(calls.args, Expr(:latestworld))\n+    push!(calls.args, :nothing)\n+\n+    return esc(calls)\n+end\n+\n end # module"
    },
    {
      "sha": "9cf74f81fccae29f2b70bb8d2b873f0e55cf1e6c",
      "filename": "base/module.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/base%2Fmodule.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/base%2Fmodule.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fmodule.jl?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -133,9 +133,9 @@ using A.B            => _module_using(Main, Expr(:., :A, :B))\n \n See also [`_using`](@ref Core._using).\n \"\"\"\n-function _eval_using(to::Module, path::Expr)\n+function _eval_using(to::Module, path::Expr, flags::UInt8=UInt8(0))\n     from = eval_import_path_all(to, path, \"using\")\n-    Core._using(to, from)\n+    Core._using(to, from, flags)\n     is_package = length(path.args) == 1 && path.args[1] !== :.\n     if to == Main && is_package\n         Core._import(to, from, nameof(from))"
    },
    {
      "sha": "25e174a14d20412fb61647d6a9aa0addd12ada38",
      "filename": "base/runtime_internals.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/base%2Fruntime_internals.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/base%2Fruntime_internals.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fruntime_internals.jl?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -253,12 +253,15 @@ const PARTITION_KIND_BACKDATED_CONST    = 0xb\n const PARTITION_FLAG_EXPORTED     = 0x10\n const PARTITION_FLAG_DEPRECATED   = 0x20\n const PARTITION_FLAG_DEPWARN      = 0x40\n+const PARTITION_FLAG_IMPLICITLY_EXPORTED = 0x80\n \n const PARTITION_MASK_KIND         = 0x0f\n const PARTITION_MASK_FLAG         = 0xf0\n \n const BINDING_FLAG_ANY_IMPLICIT_EDGES = 0x8\n \n+const JL_MODULE_USING_REEXPORT = 0x1\n+\n is_defined_const_binding(kind::UInt8) = (kind == PARTITION_KIND_CONST || kind == PARTITION_KIND_CONST_IMPORT || kind == PARTITION_KIND_IMPLICIT_CONST || kind == PARTITION_KIND_BACKDATED_CONST)\n is_some_const_binding(kind::UInt8) = (is_defined_const_binding(kind) || kind == PARTITION_KIND_UNDEF_CONST)\n is_some_imported(kind::UInt8) = (kind == PARTITION_KIND_IMPLICIT_GLOBAL || kind == PARTITION_KIND_IMPLICIT_CONST || kind == PARTITION_KIND_EXPLICIT || kind == PARTITION_KIND_IMPORTED)"
    },
    {
      "sha": "e4a87d2c00dd8135b393837389d804214057378d",
      "filename": "base/show.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/base%2Fshow.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/base%2Fshow.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fshow.jl?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -3294,6 +3294,10 @@ function print_partition(io::IO, partition::Core.BindingPartition)\n         if (partition.kind & PARTITION_FLAG_EXPORTED) != 0\n             print(io, \"exported\")\n         end\n+        if (partition.kind & PARTITION_FLAG_IMPLICITLY_EXPORTED) != 0\n+            first ? (first = false) : print(io, \",\")\n+            print(io, \"re-exported\")\n+        end\n         if (partition.kind & PARTITION_FLAG_DEPRECATED) != 0\n             first ? (first = false) : print(io, \",\")\n             print(io, \"deprecated\")"
    },
    {
      "sha": "b50e6c247ce467a1821612072f58419494f9bf84",
      "filename": "src/builtins.c",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fbuiltins.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fbuiltins.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fbuiltins.c?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -1579,10 +1579,15 @@ JL_CALLABLE(jl_f__import)\n // _using(to::Module, from::Module)\n JL_CALLABLE(jl_f__using)\n {\n-    JL_NARGS(_using, 2, 2);\n+    JL_NARGS(_using, 2, 3);\n     JL_TYPECHK(_using, module, args[0]);\n     JL_TYPECHK(_using, module, args[1]);\n-    jl_module_using((jl_module_t *)args[0], (jl_module_t *)args[1]);\n+    size_t flags = 0;\n+    if (nargs == 3) {\n+        JL_TYPECHK(_using, uint8, args[2]);\n+        flags = jl_unbox_uint8(args[2]);\n+    }\n+    jl_module_using((jl_module_t *)args[0], (jl_module_t *)args[1], flags);\n     return jl_nothing;\n }\n "
    },
    {
      "sha": "312faad91e677076de05b99c2ebfb185173d0d50",
      "filename": "src/gc-stock.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fgc-stock.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fgc-stock.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fgc-stock.c?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -2168,9 +2168,9 @@ STATIC_INLINE void gc_mark_module_binding(jl_ptls_t ptls, jl_module_t *mb_parent\n         jl_value_t *obj_parent = (jl_value_t *)mb_parent;\n         struct _jl_module_using *objary_begin = (struct _jl_module_using *)mb_parent->usings.items;\n         struct _jl_module_using *objary_end = objary_begin + nusings;\n-        static_assert(sizeof(struct _jl_module_using) == 3*sizeof(void *), \"Mismatch in _jl_module_using size\");\n+        static_assert(sizeof(struct _jl_module_using) == 4*sizeof(void *), \"Mismatch in _jl_module_using size\");\n         static_assert(offsetof(struct _jl_module_using, mod) == 0, \"Expected `mod` at the beginning of _jl_module_using\");\n-        gc_mark_objarray(ptls, obj_parent, (jl_value_t**)objary_begin, (jl_value_t**)objary_end, 3, nptr);\n+        gc_mark_objarray(ptls, obj_parent, (jl_value_t**)objary_begin, (jl_value_t**)objary_end, 4, nptr);\n     }\n     else {\n         gc_mark_push_remset(ptls, (jl_value_t *)mb_parent, nptr);"
    },
    {
      "sha": "e5cb3fd4e4a7a0f25703c43f04c2bd7c1f466cd2",
      "filename": "src/julia.h",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fjulia.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fjulia.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia.h?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -765,6 +765,9 @@ static const uint8_t PARTITION_FLAG_DEPRECATED     = 0x20;\n // implies _DEPRECATED. However, the reverse is not true. Such bindings are usually used for functions,\n // where calling the function itself will provide a (better) deprecation warning/error.\n static const uint8_t PARTITION_FLAG_DEPWARN        = 0x40;\n+// _IMPLICITLY_EXPORTED: This binding partition is implicitly exported via @reexport. Unlike _EXPORTED,\n+// this flag is set during implicit resolution and can be removed if the resolution changes.\n+static const uint8_t PARTITION_FLAG_IMPLICITLY_EXPORTED = 0x80;\n \n #if defined(_COMPILER_MICROSOFT_)\n #define JL_ALIGNED_ATTR(alignment) \\\n@@ -853,6 +856,8 @@ typedef struct _jl_module_t {\n     int8_t max_methods;\n     // If cleared no binding partition in this module has PARTITION_FLAG_EXPORTED and min_world > jl_require_world.\n     _Atomic(int8_t) export_set_changed_since_require_world;\n+    // Set if this module has any reexport usings (used to bypass fast-path in implicit resolution)\n+    _Atomic(int8_t) has_reexports;\n     jl_mutex_t lock;\n     intptr_t hash;\n } jl_module_t;\n@@ -861,8 +866,12 @@ struct _jl_module_using {\n     jl_module_t *mod;\n     size_t min_world;\n     size_t max_world;\n+    size_t flags;\n };\n \n+// Flags for _jl_module_using.flags\n+static const uint8_t JL_MODULE_USING_REEXPORT = 0x1;\n+\n struct _jl_globalref_t {\n     JL_DATA_TYPE\n     jl_module_t *mod;\n@@ -2038,7 +2047,7 @@ JL_DLLEXPORT jl_binding_partition_t *jl_declare_constant_val(jl_binding_t *b JL_\n JL_DLLEXPORT jl_binding_partition_t *jl_declare_constant_val2(jl_binding_t *b JL_ROOTING_ARGUMENT, jl_module_t *mod, jl_sym_t *var, jl_value_t *val JL_ROOTED_ARGUMENT JL_MAYBE_UNROOTED, enum jl_partition_kind);\n JL_DLLEXPORT void jl_module_import(jl_task_t *ct, jl_module_t *to, jl_module_t *from, jl_sym_t *asname, jl_sym_t *s, int explici);\n JL_DLLEXPORT void jl_import_module(jl_task_t *ct, jl_module_t *m, jl_module_t *import, jl_sym_t *asname);\n-JL_DLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from);\n+JL_DLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from, size_t flags);\n int jl_module_public_(jl_module_t *from, jl_sym_t *s, int exported, size_t new_world);\n JL_DLLEXPORT int jl_is_imported(jl_module_t *m, jl_sym_t *s);\n JL_DLLEXPORT int jl_module_exports_p(jl_module_t *m, jl_sym_t *var);"
    },
    {
      "sha": "d67a5dce810a2f707693207b7ef90743575182b7",
      "filename": "src/julia_internal.h",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fjulia_internal.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fjulia_internal.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia_internal.h?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -916,19 +916,19 @@ typedef struct _modstack_t {\n // The analyzer doesn't like looking through the arraylist, so just model the\n // access for it using this function\n STATIC_INLINE struct _jl_module_using *module_usings_getidx(jl_module_t *m JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT {\n-    return (struct _jl_module_using *)&(m->usings.items[3*i]);\n+    return (struct _jl_module_using *)&(m->usings.items[4*i]);\n }\n STATIC_INLINE jl_module_t *module_usings_getmod(jl_module_t *m JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT {\n     return module_usings_getidx(m, i)->mod;\n }\n #endif\n \n STATIC_INLINE size_t module_usings_length(jl_module_t *m) JL_NOTSAFEPOINT {\n-    return m->usings.len/3;\n+    return m->usings.len/4;\n }\n \n STATIC_INLINE size_t module_usings_max(jl_module_t *m) JL_NOTSAFEPOINT {\n-    return m->usings.max/3;\n+    return m->usings.max/4;\n }\n \n JL_DLLEXPORT jl_sym_t *jl_module_name(jl_module_t *m) JL_NOTSAFEPOINT;\n@@ -1029,6 +1029,10 @@ STATIC_INLINE int jl_bkind_is_real_constant(enum jl_partition_kind kind) JL_NOTS\n     return kind == PARTITION_KIND_IMPLICIT_CONST || kind == PARTITION_KIND_CONST || kind == PARTITION_KIND_CONST_IMPORT;\n }\n \n+STATIC_INLINE int jl_bpart_is_exported(uint8_t flags) JL_NOTSAFEPOINT {\n+    return flags & (PARTITION_FLAG_EXPORTED | PARTITION_FLAG_IMPLICITLY_EXPORTED);\n+}\n+\n JL_DLLEXPORT jl_binding_partition_t *jl_get_binding_partition(jl_binding_t *b JL_PROPAGATES_ROOT, size_t world) JL_GLOBALLY_ROOTED;\n JL_DLLEXPORT jl_binding_partition_t *jl_get_binding_partition_with_hint(jl_binding_t *b JL_PROPAGATES_ROOT, jl_binding_partition_t *previous_part, size_t world) JL_GLOBALLY_ROOTED;\n JL_DLLEXPORT jl_binding_partition_t *jl_get_binding_partition_all(jl_binding_t *b JL_PROPAGATES_ROOT, size_t min_world, size_t max_world) JL_GLOBALLY_ROOTED;"
    },
    {
      "sha": "3cfee6ad0a8c817d5c6b61d5d954f46205d74ece",
      "filename": "src/module.c",
      "status": "modified",
      "additions": 136,
      "deletions": 23,
      "changes": 159,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fmodule.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fmodule.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fmodule.c?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -77,6 +77,7 @@ struct implicit_search_resolution {\n     size_t min_world;\n     size_t max_world;\n     int saw_cycle;\n+    int should_be_reexported;  // Set if resolved through a using with JL_MODULE_USING_REEXPORT\n     //// Not semantic, but used for reflection.\n     // If non-null, the unique module from which this binding was imported\n     jl_module_t *debug_only_import_from;\n@@ -93,6 +94,7 @@ static void update_implicit_resolution(struct implicit_search_resolution *to_upd\n     to_update->min_world = WORLDMAX(to_update->min_world, resolution.min_world);\n     to_update->max_world = WORLDMIN(to_update->max_world, resolution.max_world);\n     to_update->saw_cycle |= resolution.saw_cycle;\n+    to_update->should_be_reexported |= resolution.should_be_reexported;\n     if (resolution.ultimate_kind == PARTITION_FAKE_KIND_CYCLE) {\n         // Cycles get ignored. This causes the resolution resolution to only be partial, so we can't\n         // cache it. This gets tracked in saw_cycle;\n@@ -130,6 +132,10 @@ static void update_implicit_resolution(struct implicit_search_resolution *to_upd\n static jl_binding_partition_t *jl_implicit_import_resolved(jl_binding_t *b, struct implicit_search_gap gap, struct implicit_search_resolution resolution)\n {\n     size_t new_kind = resolution.ultimate_kind | gap.inherited_flags;\n+    // If the resolution indicates this should be reexported, add the implicit export flag\n+    if (resolution.should_be_reexported) {\n+        new_kind |= PARTITION_FLAG_IMPLICITLY_EXPORTED;\n+    }\n     size_t new_max_world = gap.max_world < resolution.max_world ? gap.max_world : resolution.max_world;\n     size_t new_min_world = gap.min_world > resolution.min_world ? gap.min_world : resolution.min_world;\n     jl_binding_partition_t *next = gap.replace;\n@@ -210,7 +216,7 @@ struct implicit_search_resolution jl_resolve_implicit_import(jl_binding_t *b, mo\n         modstack_t *tmp = st;\n         for (; tmp != NULL; tmp = tmp->prev) {\n             if (tmp->b == b) {\n-                return (struct implicit_search_resolution){ PARTITION_FAKE_KIND_CYCLE, NULL, 0, ~(size_t)0, 1, NULL, NULL };\n+                return (struct implicit_search_resolution){ PARTITION_FAKE_KIND_CYCLE, NULL, 0, ~(size_t)0, 1, 0, NULL, NULL };\n             }\n         }\n     }\n@@ -223,7 +229,7 @@ struct implicit_search_resolution jl_resolve_implicit_import(jl_binding_t *b, mo\n     struct implicit_search_resolution depimpstate;\n     size_t min_world = 0;\n     size_t max_world = ~(size_t)0;\n-    impstate = depimpstate = (struct implicit_search_resolution){ PARTITION_KIND_GUARD, NULL, min_world, max_world, 0, NULL, NULL };\n+    impstate = depimpstate = (struct implicit_search_resolution){ PARTITION_KIND_GUARD, NULL, min_world, max_world, 0, 0, NULL, NULL };\n \n     JL_LOCK(&m->lock);\n     int i = (int)module_usings_length(m) - 1;\n@@ -245,16 +251,22 @@ struct implicit_search_resolution jl_resolve_implicit_import(jl_binding_t *b, mo\n         max_world = WORLDMIN(max_world, data.max_world);\n \n         jl_module_t *imp = data.mod;\n+        uint8_t has_reexports = jl_atomic_load_relaxed(&imp->has_reexports);\n         JL_GC_PROMISE_ROOTED(imp);\n         jl_binding_t *tempb = jl_get_module_binding(imp, var, 0);\n         if (!tempb) {\n             // If the binding has never been allocated, it could not have been marked exported, so\n             // it is irrelevant for our resolution. We can move on.\n-            continue;\n+            // Exception: if this module has reexports, the binding might be reexported from another module,\n+            // so we need to create the binding to trigger implicit resolution\n+            if (!has_reexports)\n+                continue;\n+            tempb = jl_get_module_binding(imp, var, 1);  // Create the binding\n         }\n \n         struct implicit_search_gap gap;\n-        jl_binding_partition_t *tempbpart = jl_get_binding_partition_if_present(tempb, world, &gap);\n+        jl_binding_partition_t *tempbpart;\n+        tempbpart = jl_get_binding_partition_if_present(tempb, world, &gap);\n         size_t tempbpart_flags = tempbpart ? (tempbpart->kind & PARTITION_MASK_FLAG) : gap.inherited_flags;\n \n         while (tempbpart && jl_bkind_is_some_explicit_import(jl_binding_kind(tempbpart))) {\n@@ -272,7 +284,8 @@ struct implicit_search_resolution jl_resolve_implicit_import(jl_binding_t *b, mo\n         max_world = WORLDMIN(max_world, tembppart_max_world);\n         min_world = WORLDMAX(min_world, tembppart_min_world);\n \n-        if (!(tempbpart_flags & PARTITION_FLAG_EXPORTED)) {\n+        uint8_t is_any_exported = jl_bpart_is_exported(tempbpart_flags);\n+        if (!is_any_exported && (tempbpart_valid || !has_reexports)) {\n             // Partition not exported - skip.\n             continue;\n         }\n@@ -292,9 +305,15 @@ struct implicit_search_resolution jl_resolve_implicit_import(jl_binding_t *b, mo\n             comparison = &depimpstate;\n         }\n \n-        struct implicit_search_resolution imp_resolution = { PARTITION_KIND_GUARD, NULL, min_world, max_world, 0, NULL, NULL };\n+        struct implicit_search_resolution imp_resolution = { PARTITION_KIND_GUARD, NULL, min_world, max_world, 0, 0, NULL, NULL };\n         if (!tempbpart_valid) {\n             imp_resolution = jl_resolve_implicit_import(tempb, &top, world, trust_cache);\n+            // imp_resolution is the resolution for import into tempb (which may have been cached for tempb\n+            // if we're not in a cycle). `imp_resolution.should_be_reexported` indicates whether the binding\n+            // should be reexported from `imp`, not `m`, so check here.\n+            if (!(tempbpart_flags & PARTITION_FLAG_EXPORTED) && !imp_resolution.should_be_reexported)\n+                continue;\n+            imp_resolution.should_be_reexported = 0;\n         } else {\n             enum jl_partition_kind kind = jl_binding_kind(tempbpart);\n             if (kind == PARTITION_KIND_IMPLICIT_GLOBAL) {\n@@ -312,6 +331,10 @@ struct implicit_search_resolution jl_resolve_implicit_import(jl_binding_t *b, mo\n                 imp_resolution.ultimate_kind = PARTITION_KIND_IMPLICIT_CONST;\n             }\n         }\n+        // If this using has the reexport flag, mark that the binding should be reexported\n+        if (data.flags & JL_MODULE_USING_REEXPORT) {\n+            imp_resolution.should_be_reexported = 1;\n+        }\n         imp_resolution.debug_only_import_from = imp;\n         update_implicit_resolution(comparison, imp_resolution);\n \n@@ -516,6 +539,7 @@ static jl_module_t *jl_new_module__(jl_sym_t *name, jl_module_t *parent)\n     m->compile = -1;\n     m->infer = -1;\n     m->max_methods = -1;\n+    jl_atomic_store_relaxed(&m->has_reexports, 0);\n     m->file = jl_empty_sym;\n     m->line = 0;\n     m->hash = parent == NULL ? bitmix(name->hash, jl_module_type->hash) :\n@@ -1340,38 +1364,61 @@ void jl_module_initial_using(jl_module_t *to, jl_module_t *from)\n     struct _jl_module_using new_item = {\n         .mod = from,\n         .min_world = 0,\n-        .max_world = ~(size_t)0\n+        .max_world = ~(size_t)0,\n+        .flags = 0\n     };\n     arraylist_grow(&to->usings, sizeof(struct _jl_module_using)/sizeof(void*));\n-    memcpy(&to->usings.items[to->usings.len-3], &new_item, sizeof(struct _jl_module_using));\n+    memcpy(&to->usings.items[to->usings.len-4], &new_item, sizeof(struct _jl_module_using));\n     jl_gc_wb(to, from);\n     jl_add_usings_backedge(from, to);\n }\n \n-JL_DLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from)\n+JL_DLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from, size_t flags)\n {\n     if (to == from)\n         return;\n     check_safe_import_from(from);\n     JL_LOCK(&world_counter_lock);\n     JL_LOCK(&to->lock);\n+\n+    // Check if this module is already in the usings list\n+    size_t existing_idx = (size_t)-1;\n     for (size_t i = 0; i < module_usings_length(to); i++) {\n         if (from == module_usings_getmod(to, i)) {\n+            existing_idx = i;\n+            break;\n+        }\n+    }\n+\n+    size_t new_world = jl_atomic_load_acquire(&jl_world_counter)+1;\n+\n+    if (existing_idx == (size_t)-1) {\n+        // Add new using entry\n+        struct _jl_module_using new_item = {\n+            .mod = from,\n+            .min_world = new_world,\n+            .max_world = ~(size_t)0,\n+            .flags = flags\n+        };\n+        arraylist_grow(&to->usings, sizeof(struct _jl_module_using)/sizeof(void*));\n+        memcpy(&to->usings.items[to->usings.len-4], &new_item, sizeof(struct _jl_module_using));\n+        jl_gc_wb(to, from);\n+    } else {\n+        // Update existing entry to add new flags\n+        struct _jl_module_using *existing = module_usings_getidx(to, existing_idx);\n+        // Early out if reexport is already set (strongest form), or if all requested flags are already set\n+        if ((existing->flags & JL_MODULE_USING_REEXPORT) || (existing->flags & flags) == flags) {\n             JL_UNLOCK(&to->lock);\n             JL_UNLOCK(&world_counter_lock);\n             return;\n         }\n+        existing->flags |= flags;\n     }\n \n-    size_t new_world = jl_atomic_load_acquire(&jl_world_counter)+1;\n-    struct _jl_module_using new_item = {\n-        .mod = from,\n-        .min_world = new_world,\n-        .max_world = ~(size_t)0\n-    };\n-    arraylist_grow(&to->usings, sizeof(struct _jl_module_using)/sizeof(void*));\n-    memcpy(&to->usings.items[to->usings.len-3], &new_item, sizeof(struct _jl_module_using));\n-    jl_gc_wb(to, from);\n+    // Set has_reexports flag if this is a reexport using\n+    if (flags & JL_MODULE_USING_REEXPORT) {\n+        jl_atomic_store_relaxed(&to->has_reexports, 1);\n+    }\n \n     JL_UNLOCK(&to->lock);\n \n@@ -1384,7 +1431,7 @@ JL_DLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from)\n         if ((void*)b == jl_nothing)\n             break;\n         jl_binding_partition_t *frombpart = jl_get_binding_partition(b, new_world);\n-        if (frombpart->kind & PARTITION_FLAG_EXPORTED) {\n+        if (jl_bpart_is_exported(frombpart->kind)) {\n             jl_sym_t *var = b->globalref->name;\n             jl_binding_t *tob = jl_get_module_binding(to, var, 0);\n             if (tob) {\n@@ -1494,7 +1541,7 @@ JL_DLLEXPORT int jl_module_exports_p(jl_module_t *m, jl_sym_t *var)\n {\n     jl_binding_t *b = jl_get_module_binding(m, var, 0);\n     jl_binding_partition_t *bpart = jl_get_binding_partition(b, jl_current_task->world_age);\n-    return b && (bpart->kind & PARTITION_FLAG_EXPORTED);\n+    return b && jl_bpart_is_exported(bpart->kind);\n }\n \n JL_DLLEXPORT int jl_module_public_p(jl_module_t *m, jl_sym_t *var)\n@@ -1715,6 +1762,10 @@ JL_DLLEXPORT jl_binding_partition_t *jl_replace_binding_locked2(jl_binding_t *b,\n         assert(!restriction_val);\n         struct implicit_search_resolution resolution = jl_resolve_implicit_import(b, NULL, new_world, 0);\n         new_bpart->kind = resolution.ultimate_kind | (kind & PARTITION_MASK_FLAG);\n+        // If the resolution indicates this should be reexported, add the implicit export flag\n+        if (resolution.should_be_reexported) {\n+            new_bpart->kind |= PARTITION_FLAG_IMPLICITLY_EXPORTED;\n+        }\n         new_bpart->restriction = resolution.binding_or_const;\n         assert(resolution.min_world <= new_world && resolution.max_world == ~(size_t)0);\n         if (new_bpart->kind == old_bpart->kind && new_bpart->restriction == old_bpart->restriction) {\n@@ -1731,7 +1782,7 @@ JL_DLLEXPORT jl_binding_partition_t *jl_replace_binding_locked2(jl_binding_t *b,\n     jl_atomic_store_relaxed(&new_bpart->next, old_bpart);\n     jl_gc_wb_fresh(new_bpart, old_bpart);\n \n-    if (((old_bpart->kind & PARTITION_FLAG_EXPORTED) || (kind & PARTITION_FLAG_EXPORTED)) && jl_require_world != ~(size_t)0) {\n+    if ((jl_bpart_is_exported(old_bpart->kind) || jl_bpart_is_exported(kind)) && jl_require_world != ~(size_t)0) {\n         jl_atomic_store_release(&b->globalref->mod->export_set_changed_since_require_world, 1);\n     }\n \n@@ -1969,8 +2020,60 @@ void _append_symbol_to_bindings_array(jl_array_t* a, jl_sym_t *name) {\n     jl_array_ptr_set(a, jl_array_dim0(a)-1, (jl_value_t*)name);\n }\n \n+static void _materialize_reexported_bindings(jl_module_t *m, size_t world, jl_array_t *visited_modules)\n+{\n+    size_t len = jl_array_len(visited_modules);\n+    for (size_t i = 0; i < len; i++) {\n+        if (jl_array_ptr_ref(visited_modules, i) == (jl_value_t*)m)\n+            return;\n+    }\n+    jl_array_ptr_1d_push(visited_modules, (jl_value_t*)m);\n+\n+    JL_LOCK(&m->lock);\n+    size_t usings_len = module_usings_length(m);\n+    JL_UNLOCK(&m->lock);\n+\n+    for (size_t i = 0; i < usings_len; i++) {\n+        JL_LOCK(&m->lock);\n+        struct _jl_module_using data = *module_usings_getidx(m, i);\n+        JL_UNLOCK(&m->lock);\n+\n+        if (data.min_world > world || data.max_world < world)\n+            continue;\n+\n+        if (data.flags & JL_MODULE_USING_REEXPORT) {\n+            jl_module_t *from = data.mod;\n+            JL_GC_PROMISE_ROOTED(from);\n+\n+            _materialize_reexported_bindings(from, world, visited_modules);\n+\n+            jl_svec_t *table = jl_atomic_load_relaxed(&from->bindings);\n+            for (size_t j = 0; j < jl_svec_len(table); j++) {\n+                jl_binding_t *b = (jl_binding_t*)jl_svecref(table, j);\n+                if ((void*)b == jl_nothing)\n+                    break;\n+\n+                jl_binding_partition_t *frombpart = jl_get_binding_partition(b, world);\n+                if (jl_bpart_is_exported(frombpart->kind)) {\n+                    jl_sym_t *var = b->globalref->name;\n+                    jl_binding_t *tob = jl_get_module_binding(m, var, 1);\n+                    jl_get_binding_partition(tob, world);  // Force implicit resolution\n+                }\n+                table = jl_atomic_load_relaxed(&from->bindings);\n+            }\n+        }\n+    }\n+}\n+\n void append_module_names(jl_array_t* a, jl_module_t *m, int all, int imported, int usings)\n {\n+    // Materialize reexported bindings first\n+    size_t world = jl_current_task->world_age;\n+    jl_array_t *visited_modules = jl_alloc_vec_any(0);\n+    JL_GC_PUSH1(&visited_modules);\n+    _materialize_reexported_bindings(m, world, visited_modules);\n+    JL_GC_POP();\n+\n     jl_svec_t *table = jl_atomic_load_relaxed(&m->bindings);\n     for (size_t i = 0; i < jl_svec_len(table); i++) {\n         jl_binding_t *b = (jl_binding_t*)jl_svecref(table, i);\n@@ -1982,6 +2085,7 @@ void append_module_names(jl_array_t* a, jl_module_t *m, int all, int imported, i\n         jl_binding_partition_t *bpart = jl_get_binding_partition(b, jl_current_task->world_age);\n         enum jl_partition_kind kind = jl_binding_kind(bpart);\n         if (((jl_atomic_load_relaxed(&b->flags) & BINDING_FLAG_PUBLICP) ||\n+             jl_bpart_is_exported(bpart->kind) ||\n              (imported && (kind == PARTITION_KIND_CONST_IMPORT || kind == PARTITION_KIND_IMPORTED)) ||\n              (usings && kind == PARTITION_KIND_EXPLICIT) ||\n              ((kind == PARTITION_KIND_GLOBAL || kind == PARTITION_KIND_CONST || kind == PARTITION_KIND_DECLARED) && (all || main_public))) &&\n@@ -1992,13 +2096,22 @@ void append_module_names(jl_array_t* a, jl_module_t *m, int all, int imported, i\n \n void append_exported_names(jl_array_t* a, jl_module_t *m, int all)\n {\n+    size_t world = jl_current_task->world_age;\n+\n+    // First, materialize all reexported bindings\n+    jl_array_t *visited_modules = jl_alloc_vec_any(0);\n+    JL_GC_PUSH1(&visited_modules);\n+    _materialize_reexported_bindings(m, world, visited_modules);\n+    JL_GC_POP();\n+\n+    // Now collect all exported bindings\n     jl_svec_t *table = jl_atomic_load_relaxed(&m->bindings);\n     for (size_t i = 0; i < jl_svec_len(table); i++) {\n         jl_binding_t *b = (jl_binding_t*)jl_svecref(table, i);\n         if ((void*)b == jl_nothing)\n             break;\n-        jl_binding_partition_t *bpart = jl_get_binding_partition(b, jl_current_task->world_age);\n-        if ((bpart->kind & PARTITION_FLAG_EXPORTED) && (all || !(bpart->kind & PARTITION_FLAG_DEPRECATED)))\n+        jl_binding_partition_t *bpart = jl_get_binding_partition(b, world);\n+        if (jl_bpart_is_exported(bpart->kind) && (all || !(bpart->kind & PARTITION_FLAG_DEPRECATED)))\n             _append_symbol_to_bindings_array(a, b->globalref->name);\n     }\n }"
    },
    {
      "sha": "ec7f5f4267a55ba21370e5fdcd858a842ebe97ce",
      "filename": "src/staticdata.c",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fstaticdata.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/src%2Fstaticdata.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fstaticdata.c?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -1244,12 +1244,13 @@ static void jl_write_module(jl_serializer_state *s, uintptr_t item, jl_module_t\n             // TODO: Remove dead entries\n             newm_data->min_world = data->min_world;\n             newm_data->max_world = data->max_world;\n+            newm_data->flags = data->flags;\n             if (s->incremental) {\n                 if (data->max_world != ~(size_t)0)\n                     newm_data->max_world = 0;\n                 newm_data->min_world = jl_require_world;\n             }\n-            arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings._space[3*i])));\n+            arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings._space[4*i])));\n             arraylist_push(&s->relocs_list, (void*)backref_id(s, data->mod, s->link_ids_relocs));\n         }\n         newm->usings.items = (void**)offsetof(jl_module_t, usings._space);\n@@ -1271,13 +1272,15 @@ static void jl_write_module(jl_serializer_state *s, uintptr_t item, jl_module_t\n                 write_uint(s->s, data->min_world);\n                 write_uint(s->s, data->max_world);\n             }\n-            static_assert(sizeof(struct _jl_module_using) == 3*sizeof(void*), \"_jl_module_using mismatch\");\n+            write_uint(s->s, data->flags);\n+            static_assert(sizeof(struct _jl_module_using) == 4*sizeof(void*), \"_jl_module_using mismatch\");\n             tot += sizeof(struct _jl_module_using);\n         }\n         for (; i < module_usings_max(m); i++) {\n             write_pointer(s->s);\n             write_uint(s->s, 0);\n             write_uint(s->s, 0);\n+            write_uint(s->s, 0);\n             tot += sizeof(struct _jl_module_using);\n         }\n     }"
    },
    {
      "sha": "709cb0859f6f523f2c31e1a5694aac828eab3659",
      "filename": "test/rebinding.jl",
      "status": "modified",
      "additions": 61,
      "deletions": 0,
      "changes": 61,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/test%2Frebinding.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5/test%2Frebinding.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Frebinding.jl?ref=fcdc9038e74c18d40f7ad5ecbfae8d08d92abad5",
      "patch": "@@ -1,5 +1,7 @@\n # This file is a part of Julia. License is MIT: https://julialang.org/license\n \n+using Test\n+\n module Rebinding\n     using Test\n     make_foo() = Foo(1)\n@@ -408,3 +410,62 @@ module Invalidate59272\n     Core.eval(Foo, :(struct Bar; x; end))\n     @test Bar(1) == Foo.Bar(1)\n end\n+\n+# Test @reexport\n+module ReexportTests\n+    using Test\n+    using Base.Experimental: @reexport\n+\n+    # Test dynamic export additions through reexport\n+    module Source1\n+        export s1\n+        s1() = \"s1\"\n+    end\n+    module Reexporter1\n+        import ..@reexport\n+        @reexport using ..Source1\n+    end\n+    module User1\n+        using ..Reexporter1\n+    end\n+    @test (:s1,) \u2286 names(Reexporter1)\n+    @test User1.s1() == \"s1\"\n+    Core.eval(Source1, :(s2() = \"s2\"; export s2))\n+    @test (:s1, :s2) \u2286 names(Reexporter1)\n+    @test User1.s2() == \"s2\"\n+\n+    # Test reexport syntax, multiple modules\n+    module Source2\n+        export s3\n+        s3() = \"s3\"\n+    end\n+    module Reexporter2\n+        import ..@reexport\n+        @reexport using ..Source2, ..Source1\n+    end\n+    module User2\n+        using ..Reexporter2\n+    end\n+    @test (:s1, :s3) \u2286 names(Reexporter2)\n+    @test User2.s1() == \"s1\"\n+    @test User2.s3() == \"s3\"\n+\n+    # Test same name from different modules - one with reexport, one without\n+    module Source3\n+        export same_name\n+        const same_name = 42\n+    end\n+    module Source4\n+        export same_name\n+        const same_name = 42\n+    end\n+    module Reexporter3\n+        import ..@reexport\n+        using ..Source4  # without reexport\n+        @reexport using ..Source3\n+    end\n+    module User3\n+        using ..Reexporter3\n+    end\n+    @test User3.same_name == 42\n+end"
    }
  ]
}