{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60060",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60060/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60060/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60060/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60060",
  "id": 3595934042,
  "node_id": "PR_kwDOABkWpM6x5_bN",
  "number": 60060,
  "title": "improve behavior of bracket insertion in some situations",
  "user": {
    "login": "KristofferC",
    "id": 1282691,
    "node_id": "MDQ6VXNlcjEyODI2OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1282691?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KristofferC",
    "html_url": "https://github.com/KristofferC",
    "followers_url": "https://api.github.com/users/KristofferC/followers",
    "following_url": "https://api.github.com/users/KristofferC/following{/other_user}",
    "gists_url": "https://api.github.com/users/KristofferC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KristofferC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KristofferC/subscriptions",
    "organizations_url": "https://api.github.com/users/KristofferC/orgs",
    "repos_url": "https://api.github.com/users/KristofferC/repos",
    "events_url": "https://api.github.com/users/KristofferC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KristofferC/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 42281298,
      "node_id": "MDU6TGFiZWw0MjI4MTI5OA==",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/REPL",
      "name": "REPL",
      "color": "c7def8",
      "default": false,
      "description": "Julia's REPL (Read Eval Print Loop)"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-11-06T13:55:33Z",
  "updated_at": "2025-11-28T20:10:27Z",
  "closed_at": "2025-11-07T12:36:49Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60060",
    "html_url": "https://github.com/JuliaLang/julia/pull/60060",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60060.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60060.patch",
    "merged_at": "2025-11-07T12:36:49Z"
  },
  "body": "this more closely mimics how other editors do it and should hopefully remove a few annoying cases\r\n\r\nsee tests for concrete changes\r\n\r\n(also make sure that other modes also remove paired delimiters on backspace)\r\n\r\nTests and some code written by Claude Code :robot: ",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60060/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60060/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "1ea3044264a0e0abea724faf781e77f5fe56647e",
      "filename": "stdlib/REPL/src/LineEdit.jl",
      "status": "modified",
      "additions": 51,
      "deletions": 43,
      "changes": 94,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4eff3931c27b1fb9697f361cf978d1084eb46688/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4eff3931c27b1fb9697f361cf978d1084eb46688/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FLineEdit.jl?ref=4eff3931c27b1fb9697f361cf978d1084eb46688",
      "patch": "@@ -2103,6 +2103,29 @@ const escape_defaults = merge!(\n     )\n \n \n+# Helper function to check and remove paired brackets/quotes\n+# Returns true if paired delimiters were removed, false otherwise\n+function try_remove_paired_delimiter(buf::IOBuffer)\n+    left_brackets = ('(', '{', '[', '\"', '\\'', '`')\n+    right_brackets = (')', '}', ']', '\"', '\\'', '`')\n+\n+    if !eof(buf) && position(buf) > 0\n+        # Peek at char to the left\n+        p = position(buf)\n+        left_char = char_move_left(buf)\n+        seek(buf, p)\n+\n+        i = findfirst(isequal(left_char), left_brackets)\n+        if i !== nothing && peek(buf, Char) == right_brackets[i]\n+            # Remove both the left and right bracket/quote\n+            edit_delete(buf)\n+            edit_backspace(buf)\n+            return true\n+        end\n+    end\n+    return false\n+end\n+\n # Keymap for automatic bracket/quote insertion and completion\n const bracket_insert_keymap = AnyDict()\n let\n@@ -2125,37 +2148,33 @@ let\n         return c\n     end\n \n-    # Check if there's an unmatched opening quote before the cursor\n-    function has_unmatched_quote(buf::IOBuffer, quote_char::Char)\n-        pos = position(buf)\n-        content = String(buf.data[1:pos])\n-        isempty(content) && return false\n-\n-        # Count unescaped quotes before cursor position\n-        count = 0\n-        i = 1\n-        while i <= length(content)\n-            if content[i] == quote_char\n-                # Check if escaped by counting preceding backslashes\n-                num_backslashes = 0\n-                j = i - 1\n-                while j >= 1 && content[j] == '\\\\'\n-                    num_backslashes += 1\n-                    j -= 1\n-                end\n-                # If even number of backslashes (including zero), the quote is not escaped\n-                if num_backslashes % 2 == 0\n-                    count += 1\n-                end\n-            end\n-            i = nextind(content, i)\n+    # Check if we should auto-close a quote (insert paired quotes)\n+    # auto-close when \"transparent\" chars on both sides\n+    # Transparent chars: whitespace, opening brackets ([{, closing brackets )]}, or nothing\n+    function should_auto_close_quote(buf::IOBuffer, quote_char::Char)\n+        # Check left side: BOF, whitespace, or opening bracket\n+        left_ok = if position(buf) == 0\n+            true\n+        else\n+            left_char = peek_char_left(buf)\n+            isspace(left_char) || left_char in ('(', '[', '{')\n+        end\n+\n+        # Check right side: EOF, whitespace, or closing bracket\n+        right_ok = if eof(buf)\n+            true\n+        else\n+            right_char = peek(buf, Char)\n+            isspace(right_char) || right_char in (')', ']', '}')\n         end\n-        return isodd(count)\n+\n+        return left_ok && right_ok\n     end\n \n     # Left/right bracket pairs\n     bracket_pairs = (('(', ')'), ('{', '}'), ('[', ']'))\n-    right_brackets_ws = (')', '}', ']', ' ', '\\t', '\\n')\n+    # Characters that are \"transparent\" for bracket auto-closing\n+    right_brackets_ws = (')', '}', ']', ' ', '\\t', '\\n', '\"', '\\'', '`')\n \n     for (left, right) in bracket_pairs\n         # Left bracket: insert both and move cursor between them\n@@ -2191,14 +2210,13 @@ let\n             elseif position(buf) > 0 && should_skip_closing_bracket(peek_char_left(buf), quote_char)\n                 # Don't auto-close (e.g., for transpose or triple quotes)\n                 edit_insert(buf, quote_char)\n-            elseif quote_char in ('\"', '\\'', '`') && has_unmatched_quote(buf, quote_char)\n-                # For quotes, check if we're closing an existing string\n-                edit_insert(buf, quote_char)\n-            else\n-                # Insert both quotes\n+            elseif should_auto_close_quote(buf, quote_char)\n                 edit_insert(buf, quote_char)\n                 edit_insert(buf, quote_char)\n                 edit_move_left(buf)\n+            else\n+                # Just insert single quote\n+                edit_insert(buf, quote_char)\n             end\n             refresh_line(s)\n         end\n@@ -2221,18 +2239,8 @@ let\n         end\n \n         buf = buffer(s)\n-        left_brackets = ('(', '{', '[', '\"', '\\'', '`')\n-        right_brackets = (')', '}', ']', '\"', '\\'', '`')\n-\n-        if !eof(buf) && position(buf) > 0\n-            left_char = peek_char_left(buf)\n-            i = findfirst(isequal(left_char), left_brackets)\n-            if i !== nothing && peek(buf, Char) == right_brackets[i]\n-                # Remove both the left and right bracket/quote\n-                edit_delete(buf)\n-                edit_backspace(buf)\n-                return refresh_line(s)\n-            end\n+        if try_remove_paired_delimiter(buf)\n+            return refresh_line(s)\n         end\n         return edit_backspace(s)\n     end"
    },
    {
      "sha": "de246f7971c30f0862a0e584559cd604dee8c580",
      "filename": "stdlib/REPL/src/REPL.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4eff3931c27b1fb9697f361cf978d1084eb46688/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4eff3931c27b1fb9697f361cf978d1084eb46688/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPL.jl?ref=4eff3931c27b1fb9697f361cf978d1084eb46688",
      "patch": "@@ -1192,6 +1192,10 @@ function mode_keymap(julia_prompt::Prompt)\n                 LineEdit.state(s, julia_prompt).input_buffer = buf\n             end\n         else\n+            buf = LineEdit.buffer(s)\n+            if LineEdit.try_remove_paired_delimiter(buf)\n+                return LineEdit.refresh_line(s)\n+            end\n             LineEdit.edit_backspace(s)\n         end\n     end,"
    },
    {
      "sha": "d86a6c6b5642ac329fe4a5e228c53046e674dd39",
      "filename": "stdlib/REPL/test/lineedit.jl",
      "status": "modified",
      "additions": 55,
      "deletions": 13,
      "changes": 68,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4eff3931c27b1fb9697f361cf978d1084eb46688/stdlib%2FREPL%2Ftest%2Flineedit.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4eff3931c27b1fb9697f361cf978d1084eb46688/stdlib%2FREPL%2Ftest%2Flineedit.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Flineedit.jl?ref=4eff3931c27b1fb9697f361cf978d1084eb46688",
      "patch": "@@ -1103,24 +1103,66 @@ end\n     @test content(s) == \"() \"\n     @test position(buffer(s)) == 1\n \n-    # Test context-aware quote closing: typing \" inside include(\"myfile.jl should close the string\n+    # Test quote behavior: |foo\" + \" -> \"foo\" (not \"\"foo\")\n     s = LineEdit.init_state(term, interface)\n-    write_input(s, \"include(\\\"myfile.jl\")\n+    write_input(s, \"foo\\\"\")\n+    charseek(buffer(s), 0)\n     write_input(s, \"\\\"\")\n-    @test content(s) == \"include(\\\"myfile.jl\\\")\"\n-    @test position(buffer(s)) == 19\n+    @test content(s) == \"\\\"foo\\\"\"\n+    @test position(buffer(s)) == 1\n \n-    # Test context-aware quote closing for single quotes\n+    # Test quote behavior: foo| + \" -> foo\" (not foo\"\")\n     s = LineEdit.init_state(term, interface)\n-    write_input(s, \"include('fsfds \")\n-    write_input(s, \"'\")\n-    @test content(s) == \"include('fsfds ')\"\n-    @test position(buffer(s)) == 16\n+    write_input(s, \"foo\")\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"foo\\\"\"\n+    @test position(buffer(s)) == 4\n \n-    # Test that auto-close for quotes still works when there's no unmatched quote\n+    # Test quote behavior: foo | + \" -> foo \"\"\n     s = LineEdit.init_state(term, interface)\n-    write_input(s, \"foo()\")\n+    write_input(s, \"foo \")\n     write_input(s, \"\\\"\")\n-    @test content(s) == \"foo()\\\"\\\"\"\n-    @test position(buffer(s)) == 6\n+    @test content(s) == \"foo \\\"\\\"\"\n+    @test position(buffer(s)) == 5\n+\n+    # Test quote behavior: | foo + \" -> \"\" foo (space before foo means double quotes)\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \" foo\")\n+    charseek(buffer(s), 0)\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"\\\"\\\" foo\"\n+    @test position(buffer(s)) == 1\n+\n+    # Test quote behavior:  | + \" -> \"\"\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \" \")\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \" \\\"\\\"\"\n+    @test position(buffer(s)) == 2\n+\n+    # Test quote behavior: (|) + \" -> (\"\")\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \")\")\n+    charseek(buffer(s), 0)\n+    write_input(s, \"(\")\n+    # Buffer is now () with cursor at 1\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"(\\\"\\\"))\"\n+    @test position(buffer(s)) == 2\n+\n+    # Test quote behavior: (|bar) + \" -> (\"bar)\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"(bar)\")\n+    charseek(buffer(s), 1)\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"(\\\"bar)\"\n+    @test position(buffer(s)) == 2\n+\n+    # Test bracket behavior: \"|\" + ( -> \"()\"\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"\\\"\\\"\")\n+    charseek(buffer(s), 1)\n+    write_input(s, \"(\")\n+    @test content(s) == \"\\\"()\\\"\"\n+    @test position(buffer(s)) == 2\n end"
    }
  ]
}