{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/58107",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/58107/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/58107/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/58107/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/58107",
  "id": 2993323645,
  "node_id": "PR_kwDOABkWpM6SgGio",
  "number": 58107,
  "title": "Mention Base.Lockable in \"multi-threading.md\"",
  "user": {
    "login": "KronosTheLate",
    "id": 61620837,
    "node_id": "MDQ6VXNlcjYxNjIwODM3",
    "avatar_url": "https://avatars.githubusercontent.com/u/61620837?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KronosTheLate",
    "html_url": "https://github.com/KronosTheLate",
    "followers_url": "https://api.github.com/users/KronosTheLate/followers",
    "following_url": "https://api.github.com/users/KronosTheLate/following{/other_user}",
    "gists_url": "https://api.github.com/users/KronosTheLate/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KronosTheLate/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KronosTheLate/subscriptions",
    "organizations_url": "https://api.github.com/users/KronosTheLate/orgs",
    "repos_url": "https://api.github.com/users/KronosTheLate/repos",
    "events_url": "https://api.github.com/users/KronosTheLate/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KronosTheLate/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 115619,
      "node_id": "MDU6TGFiZWwxMTU2MTk=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/docs",
      "name": "docs",
      "color": "02d7e1",
      "default": false,
      "description": "This change adds or pertains to documentation"
    },
    {
      "id": 9159719,
      "node_id": "MDU6TGFiZWw5MTU5NzE5",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/parallelism",
      "name": "parallelism",
      "color": "f7e102",
      "default": false,
      "description": "Parallel or distributed computation"
    },
    {
      "id": 184008807,
      "node_id": "MDU6TGFiZWwxODQwMDg4MDc=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/multithreading",
      "name": "multithreading",
      "color": "fbca04",
      "default": false,
      "description": "Base.Threads and related functionality"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 8,
  "created_at": "2025-04-14T14:51:01Z",
  "updated_at": "2025-10-22T22:21:49Z",
  "closed_at": "2025-10-22T22:21:49Z",
  "author_association": "CONTRIBUTOR",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/58107",
    "html_url": "https://github.com/JuliaLang/julia/pull/58107",
    "diff_url": "https://github.com/JuliaLang/julia/pull/58107.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/58107.patch",
    "merged_at": "2025-10-22T22:21:49Z"
  },
  "body": "When I originally learned about multithreading and locks (and ended up rewriting [https://docs.julialang.org/en/v1/manual/multi-threading/#man-using-locks](Using locks to avoid data-races)), I was puzzled to find that the association of a lock and a value was the mental task of the programmer, and not the programmatic task of the program. I made that explicit in that section of the manual, writing the following:\r\n> Note that the link between a lock and a variable is made by the programmer, and not the program.\r\n\r\nI was therefore very happy to see Base.Lockable introduced in Julia 1.11. What was missing, was any mention of it in the relevant section of the manual.\r\n\r\nThis PR adds a subsection under locks (So a forth level of headings, not sure if that is fine), showcasing and reccomending the use of Base.Lockable. I have made heavy use of comments in the example, which breaks with the general style, but adds valuable interpretation along the way. I am very open restructuring that part in particular.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/58107/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/58107/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "ae592a69d59b7d1fc8ec7d68322e92a6ecfd74fc",
      "filename": "doc/src/manual/multi-threading.md",
      "status": "modified",
      "additions": 45,
      "deletions": 1,
      "changes": 46,
      "blob_url": "https://github.com/JuliaLang/julia/blob/edc7465dbc2e30af0629114bcd66c4f02c3e7594/doc%2Fsrc%2Fmanual%2Fmulti-threading.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/edc7465dbc2e30af0629114bcd66c4f02c3e7594/doc%2Fsrc%2Fmanual%2Fmulti-threading.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fmanual%2Fmulti-threading.md?ref=edc7465dbc2e30af0629114bcd66c4f02c3e7594",
      "patch": "@@ -306,7 +306,9 @@ bad_read2(a) # it is NOT safe to access `a` here\n ```\n \n ### [Using locks to avoid data-races](@id man-using-locks)\n-An important tool to avoid data-races, and thereby write thread-safe code, is the concept of a \"lock\". A lock can be locked and unlocked. If a thread has locked a lock, and not unlocked it, it is said to \"hold\" the lock. If there is only one lock, and we write code the requires holding the lock to access some data, we can ensure that multiple threads will never access the same data simultaneously. Note that the link between a lock and a variable is made by the programmer, and not the program.\n+An important tool for avoiding data races, and writing thread-safe code in general, is the concept of a \"lock\". A lock can be locked and unlocked. If a thread has locked a lock, and not unlocked it, it is said to \"hold\" the lock. If there is only one lock, and we write code that requires holding the lock to access some data, we can ensure that multiple threads will never access the same data simultaneously.\n+\n+Note that the link between a lock and a variable is made by the programmer, and not the program. A helper-type [`Base.Lockable`](@ref) exists that helps you associate a lock and a value. This is often more safe than keeping track yourself, and is detailed under [Using Base.Lockable to associate a lock and a value](@ref man-lockable).\n \n For example, we can create a lock `my_lock`, and lock it while we mutate a variable `my_variable`. This is done most simply with the `@lock` macro:\n \n@@ -342,6 +344,48 @@ julia> begin\n All three options are equivalent. Note how the final version requires an explicit `try`-block to ensure that the lock is always unlocked, whereas the first two version do this internally. One should always use the lock pattern above when changing data (such as assigning\n to a global or closure variable) accessed by other threads. Failing to do this could have unforeseen and serious consequences.\n \n+#### [Using Base.Lockable to associate a lock and a value](@id man-lockable)\n+As mentioned in the previous section, the helper-type [`Base.Lockable`](@ref) can be used to programmatically ensure the association between a lock and a value. This is generally recommended, as it is both less prone to error and more readable for others compared to having the association only by convention.\n+\n+Any object can be wrapped in `Base.Lockable`:\n+```julia-repl\n+julia> my_array = [];\n+\n+julia> my_locked_array = Base.Lockable(my_array);\n+```\n+\n+If the lock is held, the underlying object can be accessed with the empty indexing notation:\n+```julia-repl\n+julia> begin\n+           lock(my_locked_array)\n+           try\n+               push!(my_locked_array[], 1)\n+           finally\n+               unlock(my_locked_array)\n+           end\n+       end\n+1-element Vector{Any}:\n+ 1\n+```\n+\n+It is usually easier and safer to pass a function as the first argument to `lock`. The function is applied to the unlocked object, and the locking/unlocking is handled automatically:\n+```julia-repl\n+julia> lock(x -> push!(x, 2), my_locked_array);\n+\n+julia> lock(display, my_locked_array)\n+2-element Vector{Any}:\n+ 1\n+ 2\n+\n+julia> lock(my_locked_array) do x\n+           x[1] = \u03c0\n+           display(x)\n+       end\n+2-element Vector{Any}:\n+ \u03c0 = 3.1415926535897...\n+ 2\n+```\n+\n ### [Atomic Operations](@id man-atomic-operations)\n \n Julia supports accessing and modifying values *atomically*, that is, in a thread-safe way to avoid"
    }
  ]
}