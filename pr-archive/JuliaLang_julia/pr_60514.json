{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60514",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60514/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60514/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60514/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60514",
  "id": 3770042687,
  "node_id": "PR_kwDOABkWpM669lmM",
  "number": 60514,
  "title": "fix `Core.Box` in REPL",
  "user": {
    "login": "KristofferC",
    "id": 1282691,
    "node_id": "MDQ6VXNlcjEyODI2OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1282691?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KristofferC",
    "html_url": "https://github.com/KristofferC",
    "followers_url": "https://api.github.com/users/KristofferC/followers",
    "following_url": "https://api.github.com/users/KristofferC/following{/other_user}",
    "gists_url": "https://api.github.com/users/KristofferC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KristofferC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KristofferC/subscriptions",
    "organizations_url": "https://api.github.com/users/KristofferC/orgs",
    "repos_url": "https://api.github.com/users/KristofferC/repos",
    "events_url": "https://api.github.com/users/KristofferC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KristofferC/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 42281298,
      "node_id": "MDU6TGFiZWw0MjI4MTI5OA==",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/REPL",
      "name": "REPL",
      "color": "c7def8",
      "default": false,
      "description": "Julia's REPL (Read Eval Print Loop)"
    },
    {
      "id": 944193805,
      "node_id": "MDU6TGFiZWw5NDQxOTM4MDU=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/latency",
      "name": "latency",
      "color": "76e8d8",
      "default": false,
      "description": "Latency"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-12-30T12:31:13Z",
  "updated_at": "2026-01-09T13:33:06Z",
  "closed_at": "2025-12-30T19:44:10Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60514",
    "html_url": "https://github.com/JuliaLang/julia/pull/60514",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60514.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60514.patch",
    "merged_at": "2025-12-30T19:44:10Z"
  },
  "body": "Various strategies:\r\n\r\n- `let` wrapping\r\n- introducing new single assignment variables\r\n- renaming variables to avoid accidental name collision (or using `local`).\r\n\r\nPart of #60479 ",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60514/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60514/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "183e759f6fb7840550ac7847328c8cb01d21169f",
      "filename": "stdlib/REPL/src/LineEdit.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/JuliaLang/julia/blob/e4f0fab0955be39afd1e71e263acfcc79cdb7053/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/e4f0fab0955be39afd1e71e263acfcc79cdb7053/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FLineEdit.jl?ref=e4f0fab0955be39afd1e71e263acfcc79cdb7053",
      "patch": "@@ -2181,7 +2181,7 @@ let\n     for (left, right) in bracket_pairs\n         # Left bracket: insert both and move cursor between them\n         bracket_insert_keymap[left] = (s::MIState, o...) -> begin\n-            buf = buffer(s)\n+            local buf = buffer(s)\n             edit_insert(buf, left)\n             if eof(buf) || peek(buf, Char) in right_brackets_ws\n                 edit_insert(buf, right)\n@@ -2192,7 +2192,7 @@ let\n \n         # Right bracket: skip over if next char matches, otherwise insert\n         bracket_insert_keymap[right] = (s::MIState, o...) -> begin\n-            buf = buffer(s)\n+            local buf = buffer(s)\n             if !eof(buf) && peek(buf, Char) == right\n                 edit_move_right(buf)\n             else\n@@ -2205,7 +2205,7 @@ let\n     # Quote characters (need special handling for transpose detection)\n     for quote_char in ('\"', '\\'', '`')\n         bracket_insert_keymap[quote_char] = (s::MIState, o...) -> begin\n-            buf = buffer(s)\n+            local buf = buffer(s)\n             if !eof(buf) && peek(buf, Char) == quote_char\n                 # Skip over closing quote\n                 edit_move_right(buf)\n@@ -2233,15 +2233,14 @@ let\n             repl = Base.active_repl\n             mirepl = isdefined(repl, :mi) ? repl.mi : repl\n             main_mode = mirepl.interface.modes[1]\n-            buf = copy(buffer(s))\n+            local buf = copy(buffer(s))\n             transition(s, main_mode) do\n                 state(s, main_mode).input_buffer = buf\n             end\n             return\n         end\n \n-        buf = buffer(s)\n-        if try_remove_paired_delimiter(buf)\n+        if try_remove_paired_delimiter(buffer(s))\n             return refresh_line(s)\n         end\n         return edit_backspace(s)"
    },
    {
      "sha": "23a107fedad0537b00c9255952719216180dd806",
      "filename": "stdlib/REPL/src/REPL.jl",
      "status": "modified",
      "additions": 31,
      "deletions": 22,
      "changes": 53,
      "blob_url": "https://github.com/JuliaLang/julia/blob/e4f0fab0955be39afd1e71e263acfcc79cdb7053/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/e4f0fab0955be39afd1e71e263acfcc79cdb7053/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPL.jl?ref=e4f0fab0955be39afd1e71e263acfcc79cdb7053",
      "patch": "@@ -611,14 +611,15 @@ function print_response(errio::IO, response, backend::Union{REPLBackendRef,Nothi\n         try\n             if val !== nothing && show_value\n                 Base.sigatomic_end() # allow display to be interrupted\n+                val_to_show = val\n                 val2, iserr = if specialdisplay === nothing\n                     # display calls may require being run on the main thread\n                     call_on_backend(backend) do\n-                        __repl_entry_display(val)\n+                        __repl_entry_display(val_to_show)\n                     end\n                 else\n                     call_on_backend(backend) do\n-                        __repl_entry_display(specialdisplay, val)\n+                        __repl_entry_display(specialdisplay, val_to_show)\n                     end\n                 end\n                 Base.sigatomic_begin()\n@@ -675,21 +676,23 @@ end\n \"\"\"\n function run_repl(repl::AbstractREPL, @nospecialize(consumer = x -> nothing); backend_on_current_task::Bool = true, backend = REPLBackend())\n     backend_ref = REPLBackendRef(backend)\n-    cleanup = @task try\n+    get_module = () -> Base.active_module(repl)\n+    cleanup_task(backend_ref, t) = @task try\n             destroy(backend_ref, t)\n         catch e\n             Core.print(Core.stderr, \"\\nINTERNAL ERROR: \")\n             Core.println(Core.stderr, e)\n             Core.println(Core.stderr, catch_backtrace())\n         end\n-    get_module = () -> Base.active_module(repl)\n     if backend_on_current_task\n         t = @async run_frontend(repl, backend_ref)\n+        cleanup = cleanup_task(backend_ref, t)\n         errormonitor(t)\n         Base._wait2(t, cleanup)\n         start_repl_backend(backend, consumer; get_module)\n     else\n         t = @async start_repl_backend(backend, consumer; get_module)\n+        cleanup = cleanup_task(backend_ref, t)\n         errormonitor(t)\n         Base._wait2(t, cleanup)\n         run_frontend(repl, backend_ref)\n@@ -1192,9 +1195,10 @@ function mode_keymap(julia_prompt::Prompt)\n     AnyDict(\n     '\\b' => function (s::MIState,o...)\n         if isempty(s) || position(LineEdit.buffer(s)) == 0\n-            buf = copy(LineEdit.buffer(s))\n-            transition(s, julia_prompt) do\n-                LineEdit.state(s, julia_prompt).input_buffer = buf\n+            let buf = copy(LineEdit.buffer(s))\n+                transition(s, julia_prompt) do\n+                    LineEdit.state(s, julia_prompt).input_buffer = buf\n+                end\n             end\n         else\n             buf = LineEdit.buffer(s)\n@@ -1333,9 +1337,10 @@ function setup_interface(\n                     for mode in repl.interface.modes\n                         if mode isa LineEdit.Prompt && mode.complete isa REPLExt.PkgCompletionProvider\n                             # pkg mode\n-                            buf = copy(LineEdit.buffer(s))\n-                            transition(s, mode) do\n-                                LineEdit.state(s, mode).input_buffer = buf\n+                            let buf = copy(LineEdit.buffer(s))\n+                                transition(s, mode) do\n+                                    LineEdit.state(s, mode).input_buffer = buf\n+                                end\n                             end\n                         end\n                     end\n@@ -1391,9 +1396,10 @@ function setup_interface(\n     repl_keymap = AnyDict(\n         ';' => function (s::MIState,o...)\n             if isempty(s) || position(LineEdit.buffer(s)) == 0\n-                buf = copy(LineEdit.buffer(s))\n-                transition(s, shell_mode) do\n-                    LineEdit.state(s, shell_mode).input_buffer = buf\n+                let buf = copy(LineEdit.buffer(s))\n+                    transition(s, shell_mode) do\n+                        LineEdit.state(s, shell_mode).input_buffer = buf\n+                    end\n                 end\n             else\n                 edit_insert(s, ';')\n@@ -1402,9 +1408,10 @@ function setup_interface(\n         end,\n         '?' => function (s::MIState,o...)\n             if isempty(s) || position(LineEdit.buffer(s)) == 0\n-                buf = copy(LineEdit.buffer(s))\n-                transition(s, help_mode) do\n-                    LineEdit.state(s, help_mode).input_buffer = buf\n+                let buf = copy(LineEdit.buffer(s))\n+                    transition(s, help_mode) do\n+                        LineEdit.state(s, help_mode).input_buffer = buf\n+                    end\n                 end\n             else\n                 edit_insert(s, '?')\n@@ -1413,9 +1420,10 @@ function setup_interface(\n         end,\n         ']' => function (s::MIState,o...)\n             if isempty(s) || position(LineEdit.buffer(s)) == 0\n-                buf = copy(LineEdit.buffer(s))\n-                transition(s, dummy_pkg_mode) do\n-                    LineEdit.state(s, dummy_pkg_mode).input_buffer = buf\n+                let buf = copy(LineEdit.buffer(s))\n+                    transition(s, dummy_pkg_mode) do\n+                        LineEdit.state(s, dummy_pkg_mode).input_buffer = buf\n+                    end\n                 end\n                 # load Pkg on another thread if available so that typing in the dummy Pkg prompt\n                 # isn't blocked, but instruct the main REPL task to do the transition via s.async_channel\n@@ -1427,9 +1435,10 @@ function setup_interface(\n                                 LineEdit.mode(s) === dummy_pkg_mode || return :ok\n                                 for mode in repl.interface.modes\n                                     if mode isa LineEdit.Prompt && mode.complete isa REPLExt.PkgCompletionProvider\n-                                        buf = copy(LineEdit.buffer(s))\n-                                        transition(s, mode) do\n-                                            LineEdit.state(s, mode).input_buffer = buf\n+                                        let buf = copy(LineEdit.buffer(s))\n+                                            transition(s, mode) do\n+                                                LineEdit.state(s, mode).input_buffer = buf\n+                                            end\n                                         end\n                                         if !isempty(s)\n                                             @invokelatest(LineEdit.check_show_hint(s))"
    },
    {
      "sha": "cab6ad9fefbb4a118ceb77e84a931996c23dc523",
      "filename": "stdlib/REPL/src/REPLCompletions.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/JuliaLang/julia/blob/e4f0fab0955be39afd1e71e263acfcc79cdb7053/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/e4f0fab0955be39afd1e71e263acfcc79cdb7053/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl?ref=e4f0fab0955be39afd1e71e263acfcc79cdb7053",
      "patch": "@@ -210,14 +210,15 @@ function complete_symbol!(suggestions::Vector{Completion},\n     end\n \n     if @isdefined(mod) # lookup names available within the module\n-        let modname = nameof(mod),\n-            is_main = mod===Main\n+        let mod_for_check = mod,\n+            modname = nameof(mod_for_check),\n+            is_main = mod_for_check === Main\n             append_filtered_mod_names!(suggestions, mod, name, complete_internal_only) do s::Symbol\n-                if Base.isdeprecated(mod, s)\n+                if Base.isdeprecated(mod_for_check, s)\n                     return false\n                 elseif s === modname\n                     return false # exclude `Main.Main.Main`, etc.\n-                elseif complete_modules_only && !completes_module(mod, s)\n+                elseif complete_modules_only && !completes_module(mod_for_check, s)\n                     return false\n                 elseif is_main && s === :MainInclude\n                     return false\n@@ -1384,9 +1385,10 @@ function complete_path_string(path, hint::Bool=false;\n \n     # Expand '~' if the user hits TAB on a path ending in '/'.\n     expanded && (hint || path != dir * \"/\") && (dir = contractuser(dir))\n+    local dir_for_paths = dir\n \n     map!(paths) do c::PathCompletion\n-        p = joinpath_withsep(dir, c.path; dirsep)\n+        p = joinpath_withsep(dir_for_paths, c.path; dirsep)\n         PathCompletion(escape(p))\n     end\n     return sort!(paths, by=p->p.path), success"
    },
    {
      "sha": "9e56afc7f9f773f5b999378c4145edca1f10325f",
      "filename": "stdlib/REPL/src/docview.jl",
      "status": "modified",
      "additions": 24,
      "deletions": 22,
      "changes": 46,
      "blob_url": "https://github.com/JuliaLang/julia/blob/e4f0fab0955be39afd1e71e263acfcc79cdb7053/stdlib%2FREPL%2Fsrc%2Fdocview.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/e4f0fab0955be39afd1e71e263acfcc79cdb7053/stdlib%2FREPL%2Fsrc%2Fdocview.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2Fdocview.jl?ref=e4f0fab0955be39afd1e71e263acfcc79cdb7053",
      "patch": "@@ -530,26 +530,27 @@ function repl_latex(io::IO, s0::String)\n         print(io, \"\\\"\")\n         printstyled(io, s, color=:cyan)\n         print(io, \"\\\" can be typed by \")\n-        state::Char = '\\0'\n+        s_to_print = s\n         with_output_color(:cyan, io) do io\n-            for c in s\n+            state::Char = '\\0'\n+            for c in s_to_print\n                 cstr = string(c)\n                 if haskey(symbols_latex, cstr)\n-                    latex = symbols_latex[cstr]\n-                    if length(latex) == 3 && latex[2] in ('^','_')\n+                    latex_symbol = symbols_latex[cstr]\n+                    if length(latex_symbol) == 3 && latex_symbol[2] in ('^','_')\n                         # coalesce runs of sub/superscripts\n-                        if state != latex[2]\n+                        if state != latex_symbol[2]\n                             '\\0' != state && print(io, \"<tab>\")\n-                            print(io, latex[1:2])\n-                            state = latex[2]\n+                            print(io, latex_symbol[1:2])\n+                            state = latex_symbol[2]\n                         end\n-                        print(io, latex[3])\n+                        print(io, latex_symbol[3])\n                     else\n                         if '\\0' != state\n                             print(io, \"<tab>\")\n                             state = '\\0'\n                         end\n-                        print(io, latex, \"<tab>\")\n+                        print(io, latex_symbol, \"<tab>\")\n                     end\n                 else\n                     if '\\0' != state\n@@ -600,13 +601,14 @@ function _repl(x, brief::Bool=true, mod::Module=Main, internal_accesses::Union{N\n                     if kwarg isa Symbol\n                         kwarg = :($kwarg::Any)\n                     elseif isexpr(kwarg, :kw)\n-                        lhs = kwarg.args[1]\n-                        rhs = kwarg.args[2]\n-                        if lhs isa Symbol\n-                            if rhs isa Symbol\n-                                kwarg.args[1] = :($lhs::(@isdefined($rhs) ? typeof($rhs) : Any))\n-                            else\n-                                kwarg.args[1] = :($lhs::typeof($rhs))\n+                        let kw_lhs = kwarg.args[1],\n+                            kw_rhs = kwarg.args[2]\n+                            if kw_lhs isa Symbol\n+                                if kw_rhs isa Symbol\n+                                    kwarg.args[1] = :($kw_lhs::(@isdefined($kw_rhs) ? typeof($kw_rhs) : Any))\n+                                else\n+                                    kwarg.args[1] = :($kw_lhs::typeof($kw_rhs))\n+                                end\n                             end\n                         end\n                     end\n@@ -616,13 +618,13 @@ function _repl(x, brief::Bool=true, mod::Module=Main, internal_accesses::Union{N\n                 if kwargs === nothing\n                     kwargs = Any[]\n                 end\n-                lhs = arg.args[1]\n-                rhs = arg.args[2]\n-                if lhs isa Symbol\n-                    if rhs isa Symbol\n-                        arg.args[1] = :($lhs::(@isdefined($rhs) ? typeof($rhs) : Any))\n+                arg_lhs = arg.args[1]\n+                arg_rhs = arg.args[2]\n+                if arg_lhs isa Symbol\n+                    if arg_rhs isa Symbol\n+                        arg.args[1] = :($arg_lhs::(@isdefined($arg_rhs) ? typeof($arg_rhs) : Any))\n                     else\n-                        arg.args[1] = :($lhs::typeof($rhs))\n+                        arg.args[1] = :($arg_lhs::typeof($arg_rhs))\n                     end\n                 end\n                 push!(kwargs, arg)"
    }
  ]
}