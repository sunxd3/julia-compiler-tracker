{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60501",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60501/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60501/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60501/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60501",
  "id": 3766424481,
  "node_id": "PR_kwDOABkWpM66xmw9",
  "number": 60501,
  "title": "Test: add context arg for `@test` etc.",
  "user": {
    "login": "IanButterworth",
    "id": 1694067,
    "node_id": "MDQ6VXNlcjE2OTQwNjc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1694067?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/IanButterworth",
    "html_url": "https://github.com/IanButterworth",
    "followers_url": "https://api.github.com/users/IanButterworth/followers",
    "following_url": "https://api.github.com/users/IanButterworth/following{/other_user}",
    "gists_url": "https://api.github.com/users/IanButterworth/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/IanButterworth/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/IanButterworth/subscriptions",
    "organizations_url": "https://api.github.com/users/IanButterworth/orgs",
    "repos_url": "https://api.github.com/users/IanButterworth/repos",
    "events_url": "https://api.github.com/users/IanButterworth/events{/privacy}",
    "received_events_url": "https://api.github.com/users/IanButterworth/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 402147973,
      "node_id": "MDU6TGFiZWw0MDIxNDc5NzM=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/testsystem",
      "name": "testsystem",
      "color": "e99695",
      "default": false,
      "description": "The unit testing framework and Test stdlib"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-12-29T05:07:57Z",
  "updated_at": "2025-12-31T09:22:15Z",
  "closed_at": "2025-12-31T09:21:55Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60501",
    "html_url": "https://github.com/JuliaLang/julia/pull/60501",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60501.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60501.patch",
    "merged_at": "2025-12-31T09:21:55Z"
  },
  "body": "Provides a more proper way to do this without the non-boolean thing which is pretty commonly used\r\n```\r\njulia> @test false || \"some context information\"\r\nError During Test at REPL[2]:1\r\n  Expression evaluated to non-Boolean\r\n  Expression: false || \"some context information\"\r\n       Value: \"some context information\"\r\nERROR: There was an error during testing\r\n```\r\nWith this PR:\r\n```\r\njulia> @test false context=\"some context information\"\r\nTest Failed at REPL[1]:1\r\n  Expression: false\r\n     Context: \"some context information\"\r\nERROR: There was an error during testing\r\n```\r\n\r\nThe motivator I have is this allows `broken` to be used in conjunction with context information. \r\nPrior to this, you cannot mark a test that evaluates as non-boolean as broken\r\n```\r\njulia> @test false || \"some context information\" broken=true\r\nError During Test at REPL[2]:1\r\n  Expression evaluated to non-Boolean\r\n  Expression: false || \"some context information\"\r\n       Value: \"some context information\"\r\nERROR: There was an error during testing\r\n```\r\nwith this PR you can do\r\n```\r\njulia> @test false context=\"some context information\" broken=true\r\nTest Broken\r\n  Expression: false\r\n```\r\n\r\n---\r\n\r\nI included a commit to update tests that could use this, but can move that to a follow-on PR if preferred.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60501/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60501/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "eecb7534157346205f26d101cdeefe0de5d20c5e",
      "filename": "Compiler/test/inference.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/Compiler%2Ftest%2Finference.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/Compiler%2Ftest%2Finference.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Finference.jl?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -731,7 +731,7 @@ for (codetype, all_ssa) in Any[\n     local i\n     for i = 1:length(code.ssavaluetypes)\n         typ = code.ssavaluetypes[i]\n-        @test isa(typ, Type) || isa(typ, Const) || isa(typ, Conditional) || typ\n+        @test isa(typ, Type) || isa(typ, Const) || isa(typ, Conditional) context=typ\n     end\n     test_inferred_static(codetype, all_ssa)\n end\n@@ -1298,7 +1298,7 @@ function test_const_return(@nospecialize(f), @nospecialize(t), @nospecialize(val\n                 continue\n             end\n         end\n-        @test false || \"Side effect expressions found $ex\"\n+        @test false context=\"Side effect expressions found $ex\"\n         return\n     end\n end"
    },
    {
      "sha": "a89a684a2c2bbfbac348d3ee27a87da11823fee0",
      "filename": "Compiler/test/inline.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/Compiler%2Ftest%2Finline.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/Compiler%2Ftest%2Finline.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Finline.jl?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -1733,7 +1733,7 @@ let src = code_typed1(with_unmatched_typeparam)\n             break\n         end\n     end\n-    @test isnothing(found) || (source=src, statement=found)\n+    @test isnothing(found) context=(; source=src, statement=found)\n end\n \n function twice_sitofp(x::Int, y::Int)"
    },
    {
      "sha": "c65ceb45e22c715137c39ea7f0492a9343aaa22a",
      "filename": "NEWS.md",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/NEWS.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/NEWS.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/NEWS.md?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -58,6 +58,10 @@ Standard library changes\n \n #### Test\n \n+* `@test`, `@test_throws`, and `@test_broken` now support a `context` keyword argument\n+  that provides additional information displayed on test failure. This is useful for\n+  debugging which specific case failed in parameterized tests ([#60501]).\n+\n #### InteractiveUtils\n \n #### Dates"
    },
    {
      "sha": "39ef6ae7e75910350f209298853690eb52515126",
      "filename": "stdlib/FileWatching/test/runtests.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib%2FFileWatching%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/stdlib%2FFileWatching%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FFileWatching%2Ftest%2Fruntests.jl?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -429,7 +429,7 @@ if !Sys.isapple()\n                 end\n             end\n         end\n-        @test all(x -> (isa(x, Pair) && x[1] == F_PATH && (x[2].changed \u22bb x[2].renamed)), changes) || changes\n+        @test all(x -> (isa(x, Pair) && x[1] == F_PATH && (x[2].changed \u22bb x[2].renamed)), changes) context=changes\n     end\n end\n @test_throws(Base._UVError(\"FileMonitor (start)\", Base.UV_ENOENT),"
    },
    {
      "sha": "3c64729d4c4ce3a392e01b5ea7510494c0f508ff",
      "filename": "stdlib/InteractiveUtils/test/runtests.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib%2FInteractiveUtils%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/stdlib%2FInteractiveUtils%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FInteractiveUtils%2Ftest%2Fruntests.jl?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -574,16 +574,16 @@ let errf = tempname(),\n             @test startswith(errstr, \"\"\"start\n                 Internal error: encountered unexpected error during compilation of f_broken_code:\n                 ErrorException(\\\"unsupported or misplaced expression \\\\\\\"invalid\\\\\\\" in function f_broken_code\\\")\n-                \"\"\") || errstr\n+                \"\"\") context=errstr\n             @test occursin(\"\"\"\\nmiddle\n                 Internal error: encountered unexpected error during compilation of f_broken_code:\n                 ErrorException(\\\"unsupported or misplaced expression \\\\\\\"invalid\\\\\\\" in function f_broken_code\\\")\n-                \"\"\", errstr) || errstr\n+                \"\"\", errstr) context=errstr\n             @test occursin(\"\"\"\\nlater\n                 Internal error: encountered unexpected error during compilation of f_broken_code:\n                 ErrorException(\\\"unsupported or misplaced expression \\\\\\\"invalid\\\\\\\" in function f_broken_code\\\")\n-                \"\"\", errstr) || errstr\n-            @test endswith(errstr, \"\\nend\\n\") || errstr\n+                \"\"\", errstr) context=errstr\n+            @test endswith(errstr, \"\\nend\\n\") context=errstr\n         end\n         rm(errf)\n     end"
    },
    {
      "sha": "4c45104a262aa5015aa51ffe3ef49b6b92978f31",
      "filename": "stdlib/Test/src/Test.jl",
      "status": "modified",
      "additions": 77,
      "deletions": 43,
      "changes": 120,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib%2FTest%2Fsrc%2FTest.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/stdlib%2FTest%2Fsrc%2FTest.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FTest%2Fsrc%2FTest.jl?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -201,9 +201,9 @@ function Base.show(io::IO, t::Fail)\n             # evaluated version as well\n             print(io, \"\\n   Evaluated: \", data)\n         end\n-        if t.context !== nothing\n-            print(io, \"\\n     Context: \", t.context)\n-        end\n+    end\n+    if t.context !== nothing\n+        print(io, \"\\n     Context: \", t.context)\n     end\n end\n \n@@ -285,22 +285,22 @@ function Base.show(io::IO, t::Error)\n     elseif t.test_type === :test_error\n         println(io, \"  Test threw exception\")\n         println(io, \"  Expression: \", t.orig_expr)\n-        if t.context !== nothing\n-            println(io, \"     Context: \", t.context)\n-        end\n         # Capture error message and indent to match\n         join(io, (\"  \" * line for line in filter!(!isempty, split(t.backtrace, \"\\n\"))), \"\\n\")\n     elseif t.test_type === :test_unbroken\n         # A test that was expected to fail did not\n         println(io, \" Unexpected Pass\")\n         println(io, \" Expression: \", t.orig_expr)\n-        println(io, \" Got correct result, please change to @test if no longer broken.\")\n+        print(io, \" Got correct result, please change to @test if no longer broken.\")\n     elseif t.test_type === :nontest_error\n         # we had an error outside of a @test\n         println(io, \"  Got exception outside of a @test\")\n         # Capture error message and indent to match\n         join(io, (\"  \" * line for line in filter!(!isempty, split(t.backtrace, \"\\n\"))), \"\\n\")\n     end\n+    if t.context !== nothing\n+        print(io, \"\\n     Context: \", t.context)\n+    end\n end\n \n \"\"\"\n@@ -452,6 +452,7 @@ end\n     @test f(args...) key=val ...\n     @test ex broken=true\n     @test ex skip=true\n+    @test ex context=ctx\n \n Test that the expression `ex` evaluates to `true`.\n If executed inside a `@testset`, return a `Pass` `Result` if it does, a `Fail` `Result` if it is\n@@ -480,8 +481,8 @@ This is equivalent to the uglier test `@test \u2248(\u03c0, 3.14, atol=0.01)`.\n It is an error to supply more than one expression unless the first\n is a call expression and the rest are assignments (`k=v`).\n \n-You can use any key for the `key=val` arguments, except for `broken` and `skip`,\n-which have special meanings in the context of `@test`:\n+You can use any key for the `key=val` arguments, except for `broken`, `skip`,\n+and `context`, which have special meanings in the context of `@test`:\n \n * `broken=cond` indicates a test that should pass but currently consistently\n   fails when `cond==true`.  Tests that the expression `ex` evaluates to `false`\n@@ -492,6 +493,9 @@ which have special meanings in the context of `@test`:\n   test summary reporting as `Broken`, when `cond==true`.  This can be useful for\n   tests that intermittently fail, or tests of not-yet-implemented functionality.\n   Regular `@test ex` is evaluated when `cond==false`.\n+* `context=ctx` provides additional context that will be displayed if the test\n+  fails. The context expression is evaluated and its result is shown in the\n+  test failure output. This is useful for providing debugging information.\n \n # Examples\n \n@@ -513,14 +517,18 @@ Test Passed\n \n !!! compat \"Julia 1.7\"\n      The `broken` and `skip` keyword arguments require at least Julia 1.7.\n+\n+!!! compat \"Julia 1.14\"\n+     The `context` keyword argument requires at least Julia 1.14.\n \"\"\"\n macro test(ex, kws...)\n-    # Collect the broken/skip keywords and remove them from the rest of keywords\n+    # Collect the broken/skip/context keywords and remove them from the rest of keywords\n     broken = [kw.args[2] for kw in kws if kw.args[1] === :broken]\n     skip = [kw.args[2] for kw in kws if kw.args[1] === :skip]\n-    kws = filter(kw -> kw.args[1] \u2209 (:skip, :broken), kws)\n-    # Validation of broken/skip keywords\n-    for (kw, name) in ((broken, :broken), (skip, :skip))\n+    context = [kw.args[2] for kw in kws if kw.args[1] === :context]\n+    kws = filter(kw -> kw.args[1] \u2209 (:skip, :broken, :context), kws)\n+    # Validation of broken/skip/context keywords\n+    for (kw, name) in ((broken, :broken), (skip, :skip), (context, :context))\n         if length(kw) > 1\n             error(\"invalid test macro call: cannot set $(name) keyword multiple times\")\n         end\n@@ -535,12 +543,13 @@ macro test(ex, kws...)\n     result = get_test_result(ex, __source__)\n \n     ex = Expr(:inert, ex)\n+    ctx = length(context) > 0 ? esc(context[1]) : nothing\n     result = quote\n         if $(length(skip) > 0 && esc(skip[1]))\n             record(get_testset(), Broken(:skipped, $ex))\n         else\n             let _do = $(length(broken) > 0 && esc(broken[1])) ? do_broken_test : do_test\n-                _do($result, $ex)\n+                _do($result, $ex, $ctx)\n             end\n         end\n     end\n@@ -550,6 +559,7 @@ end\n \"\"\"\n     @test_broken ex\n     @test_broken f(args...) key=val ...\n+    @test_broken ex context=ctx\n \n Indicates a test that should pass but currently consistently fails.\n Tests that the expression `ex` evaluates to `false` or causes an\n@@ -559,6 +569,9 @@ if the expression evaluates to `true`.  This is equivalent to\n \n The `@test_broken f(args...) key=val...` form works as for the `@test` macro.\n \n+The `context=ctx` keyword provides additional context that will be displayed\n+if the test unexpectedly passes (becomes an `Error`).\n+\n # Examples\n ```jldoctest\n julia> @test_broken 1 == 2\n@@ -569,13 +582,20 @@ julia> @test_broken 1 == 2 atol=0.1\n Test Broken\n   Expression: ==(1, 2, atol = 0.1)\n ```\n+\n+!!! compat \"Julia 1.14\"\n+     The `context` keyword argument requires at least Julia 1.14.\n \"\"\"\n macro test_broken(ex, kws...)\n+    # Extract context keyword if present\n+    context = [kw.args[2] for kw in kws if isa(kw, Expr) && kw.head === :(=) && kw.args[1] === :context]\n+    kws = filter(kw -> !(isa(kw, Expr) && kw.head === :(=) && kw.args[1] === :context), kws)\n     test_expr!(\"@test_broken\", ex, kws...)\n     result = get_test_result(ex, __source__)\n+    ctx = length(context) > 0 ? esc(context[1]) : nothing\n     # code to call do_test with execution result and original expr\n     ex = Expr(:inert, ex)\n-    return :(do_broken_test($result, $ex))\n+    return :(do_broken_test($result, $ex, $ctx))\n end\n \n \"\"\"\n@@ -758,9 +778,10 @@ end\n \n # An internal function, called by the code generated by the @test\n # macro to actually perform the evaluation and manage the result.\n-function do_test(result::ExecutionResult, @nospecialize orig_expr)\n+function do_test(result::ExecutionResult, @nospecialize(orig_expr), context=nothing)\n     # get_testset() returns the most recently added test set\n     # We then call record() with this test set and the test result\n+    context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)\n     if isa(result, Returned)\n         # expr, in the case of a comparison, will contain the\n         # comparison with evaluated values of each term spliced in.\n@@ -771,33 +792,34 @@ function do_test(result::ExecutionResult, @nospecialize orig_expr)\n         testres = if isa(value, Bool)\n             # a true value Passes\n             value ? Pass(:test, orig_expr, result.data, value, result.source) :\n-                    Fail(:test, orig_expr, result.data, value, nothing, result.source, false)\n+                    Fail(:test, orig_expr, result.data, value, context_str, result.source, false)\n         else\n             # If the result is non-Boolean, this counts as an Error\n-            Error(:test_nonbool, orig_expr, value, nothing, result.source, nothing)\n+            Error(:test_nonbool, orig_expr, value, nothing, result.source, context_str)\n         end\n     else\n         # The predicate couldn't be evaluated without throwing an\n         # exception, so that is an Error and not a Fail\n         @assert isa(result, Threw)\n-        testres = Error(:test_error, orig_expr, result.exception, result.current_exceptions, result.source, nothing)\n+        testres = Error(:test_error, orig_expr, result.exception, result.current_exceptions, result.source, context_str)\n     end\n     isa(testres, Pass) || trigger_test_failure_break(result)\n     record(get_testset(), testres)\n end\n \n-function do_broken_test(result::ExecutionResult, @nospecialize orig_expr)\n+function do_broken_test(result::ExecutionResult, @nospecialize(orig_expr), context=nothing)\n     testres = Broken(:test, orig_expr)\n+    context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)\n     # Assume the test is broken and only change if the result is true\n     if isa(result, Returned)\n         value = result.value\n         if isa(value, Bool)\n             if value\n-                testres = Error(:test_unbroken, orig_expr, value, nothing, result.source, nothing)\n+                testres = Error(:test_unbroken, orig_expr, value, nothing, result.source, context_str)\n             end\n         else\n             # If the result is non-Boolean, this counts as an Error\n-            testres = Error(:test_nonbool, orig_expr, value, nothing, result.source, nothing)\n+            testres = Error(:test_nonbool, orig_expr, value, nothing, result.source, context_str)\n         end\n     end\n     record(get_testset(), testres)\n@@ -808,6 +830,7 @@ end\n \"\"\"\n     @test_throws exception expr\n     @test_throws extype pattern expr\n+    @test_throws exception expr context=ctx\n \n Tests that the expression `expr` throws `exception`.\n The exception may specify either a type,\n@@ -822,14 +845,18 @@ a message pattern are tested. The `extype` must be a type, and `pattern` may be\n a string, regular expression, or list of strings occurring in the displayed error message,\n a matching function, or a value.\n \n-Note that `@test_throws` does not support a trailing keyword form.\n+The optional `context=ctx` keyword provides additional context that will be displayed\n+if the test fails (wrong exception type, wrong message, or no exception thrown).\n \n !!! compat \"Julia 1.8\"\n     The ability to specify anything other than a type or a value as `exception` requires Julia v1.8 or later.\n \n !!! compat \"Julia 1.13\"\n     The three-argument form `@test_throws extype pattern expr` requires Julia v1.12 or later.\n \n+!!! compat \"Julia 1.14\"\n+    The `context` keyword argument requires at least Julia 1.14.\n+\n # Examples\n ```jldoctest\n julia> @test_throws BoundsError [1, 2, 3][4]\n@@ -857,23 +884,29 @@ In the third example, instead of matching a single string it could alternatively\n \n In the final example, both the exception type (`ErrorException`) and message pattern (`\"error foo\"`) are tested.\n \"\"\"\n-macro test_throws(extype, ex)\n-    orig_ex = Expr(:inert, ex)\n-    ex = Expr(:block, __source__, esc(ex))\n-    result = quote\n-        try\n-            Returned($ex, nothing, $(QuoteNode(__source__)))\n-        catch _e\n-            if $(esc(extype)) != InterruptException && _e isa InterruptException\n-                rethrow()\n-            end\n-            Threw(_e, Base.current_exceptions(), $(QuoteNode(__source__)))\n-        end\n+macro test_throws(args...)\n+    # Parse arguments: expect (extype, ex) or (extype, pattern, ex), with optional context=... at end\n+    nargs = length(args)\n+    nargs >= 2 || error(\"@test_throws requires at least 2 arguments\")\n+\n+    # Check for context=... keyword at end\n+    ctx = nothing\n+    if nargs >= 3 && args[end] isa Expr && args[end].head === :(=) && args[end].args[1] === :context\n+        ctx = esc(args[end].args[2])\n+        args = args[1:end-1]\n+        nargs -= 1\n+    end\n+\n+    if nargs == 2\n+        extype, ex = args\n+        pattern = nothing\n+    elseif nargs == 3\n+        extype, pattern, ex = args\n+        pattern = esc(pattern)\n+    else\n+        error(\"@test_throws expects 2 or 3 positional arguments (plus optional context=...)\")\n     end\n-    return :(do_test_throws($result, $orig_ex, $(esc(extype))))\n-end\n \n-macro test_throws(extype, pattern, ex)\n     orig_ex = Expr(:inert, ex)\n     ex = Expr(:block, __source__, esc(ex))\n     result = quote\n@@ -886,7 +919,7 @@ macro test_throws(extype, pattern, ex)\n             Threw(_e, Base.current_exceptions(), $(QuoteNode(__source__)))\n         end\n     end\n-    return :(do_test_throws($result, $orig_ex, $(esc(extype)), $(esc(pattern))))\n+    return :(do_test_throws($result, $orig_ex, $(esc(extype)), $pattern, $ctx))\n end\n \n const MACROEXPAND_LIKE = Symbol.((\"@macroexpand\", \"@macroexpand1\", \"macroexpand\"))\n@@ -906,7 +939,8 @@ end\n \n # An internal function, called by the code generated by @test_throws\n # to evaluate and catch the thrown exception - if it exists\n-function do_test_throws(result::ExecutionResult, @nospecialize(orig_expr), extype, pattern=nothing)\n+function do_test_throws(result::ExecutionResult, @nospecialize(orig_expr), extype, pattern=nothing, context=nothing)\n+    context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)\n     if isa(result, Threw)\n         # Check that the right type of exception was thrown\n         success = false\n@@ -917,7 +951,7 @@ function do_test_throws(result::ExecutionResult, @nospecialize(orig_expr), extyp\n         if pattern !== nothing\n             # In 3-arg form, first argument must be a type\n             if !isa(extype, Type)\n-                testres = Fail(:test_throws_wrong, orig_expr, extype, exc, nothing, result.source, false, \"First argument must be an exception type in three-argument form\")\n+                testres = Fail(:test_throws_wrong, orig_expr, extype, exc, context_str, result.source, false, \"First argument must be an exception type in three-argument form\")\n                 record(get_testset(), testres)\n                 return\n             end\n@@ -995,7 +1029,7 @@ function do_test_throws(result::ExecutionResult, @nospecialize(orig_expr), extyp\n                         \"of type \" * string(typeof(ex))\n                     end\n             end\n-            testres = Fail(:test_throws_wrong, orig_expr, extype, exc, nothing, result.source, message_only, bt_str)\n+            testres = Fail(:test_throws_wrong, orig_expr, extype, exc, context_str, result.source, message_only, bt_str)\n         end\n     else\n         # Handle no exception case - need to format extype properly for 3-arg form\n@@ -1005,7 +1039,7 @@ function do_test_throws(result::ExecutionResult, @nospecialize(orig_expr), extyp\n                          string(pattern)\n             extype = string(extype) * \" with pattern \" * pattern_str\n         end\n-        testres = Fail(:test_throws_nothing, orig_expr, extype, nothing, nothing, result.source, false)\n+        testres = Fail(:test_throws_nothing, orig_expr, extype, nothing, context_str, result.source, false)\n     end\n     record(get_testset(), testres)\n end"
    },
    {
      "sha": "2e9bcea792c516b91be4f7edd835687584d2124e",
      "filename": "stdlib/Test/test/runtests.jl",
      "status": "modified",
      "additions": 76,
      "deletions": 0,
      "changes": 76,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib%2FTest%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/stdlib%2FTest%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FTest%2Ftest%2Fruntests.jl?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -466,6 +466,82 @@ end\n     end\n end\n \n+# Tests for context keyword\n+@testset \"@test with context keyword\" begin\n+    # Test that context appears in Fail\n+    let f = Test.Fail(:test, \"false\", nothing, \"false\", \"(sin, Float64)\", LineNumberNode(1), false)\n+        @test occursin(\"Context: (sin, Float64)\", sprint(show, f))\n+    end\n+\n+    # Test that context is evaluated and shown in @test\n+    let fails = @testset NoThrowTestSet begin\n+            @test false context=(sin, Float64)\n+        end\n+        @test length(fails) == 1\n+        @test fails[1] isa Test.Fail\n+        @test occursin(\"(sin, Float64)\", fails[1].context)\n+    end\n+\n+    # Test context with broken=true (should record as Broken)\n+    let results = @testset NoThrowTestSet begin\n+            @test false context=\"info\" broken=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+    end\n+\n+    # Test context with Error (exception thrown)\n+    let errors = @testset NoThrowTestSet begin\n+            @test error(\"boom\") context=\"error info\"\n+        end\n+        @test length(errors) == 1\n+        @test errors[1] isa Test.Error\n+        @test errors[1].context == \"\\\"error info\\\"\"\n+    end\n+end\n+\n+@testset \"@test_throws with context keyword\" begin\n+    # Test context appears when wrong exception thrown\n+    let fails = @testset NoThrowTestSet begin\n+            @test_throws ArgumentError error(\"wrong\") context=\"extra info\"\n+        end\n+        @test length(fails) == 1\n+        @test fails[1] isa Test.Fail\n+        @test fails[1].context == \"\\\"extra info\\\"\"\n+    end\n+\n+    # Test context with three-arg form\n+    let fails = @testset NoThrowTestSet begin\n+            @test_throws ErrorException \"pattern\" error(\"wrong msg\") context=(1, 2)\n+        end\n+        @test length(fails) == 1\n+        @test fails[1] isa Test.Fail\n+        @test occursin(\"(1, 2)\", fails[1].context)\n+    end\n+\n+    # Test context when no exception thrown\n+    let fails = @testset NoThrowTestSet begin\n+            @test_throws ErrorException 1 + 1 context=\"no throw info\"\n+        end\n+        @test length(fails) == 1\n+        @test fails[1] isa Test.Fail\n+        @test fails[1].test_type === :test_throws_nothing\n+        @test fails[1].context == \"\\\"no throw info\\\"\"\n+    end\n+end\n+\n+@testset \"@test_broken with context keyword\" begin\n+    # Test context with @test_broken when test unexpectedly passes\n+    let errors = @testset NoThrowTestSet begin\n+            @test_broken true context=\"broken info\"\n+        end\n+        @test length(errors) == 1\n+        @test errors[1] isa Test.Error\n+        @test errors[1].test_type === :test_unbroken\n+        @test errors[1].context == \"\\\"broken info\\\"\"\n+    end\n+end\n+\n @testset \"printing of a TestSetException\" begin\n     tse_str = sprint(show, Test.TestSetException(1, 2, 3, 4, Vector{Union{Test.Error, Test.Fail}}()))\n     @test occursin(\"1 passed\", tse_str)"
    },
    {
      "sha": "12be39066af9e788533996d15f4b8f39c10be75f",
      "filename": "test/bitarray.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/test%2Fbitarray.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/test%2Fbitarray.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fbitarray.jl?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -19,7 +19,7 @@ bitcheck(x) = true\n function check_bitop_call(ret_type, func, args...; kwargs...)\n     r2 = func(map(x->(isa(x, BitArray) ? Array(x) : x), args)...; kwargs...)\n     r1 = func(args...; kwargs...)\n-    ret_type \u2262 nothing && (@test isa(r1, ret_type) || @show ret_type, typeof(r1))\n+    ret_type \u2262 nothing && @test isa(r1, ret_type) context=(; ret_type, actual=typeof(r1))\n     @test tc(r1, r2)\n     @test isequal(r1, r2)\n     @test bitcheck(r1)"
    },
    {
      "sha": "44c65ebb6ed236e5adf4ca8adb708bd06111e243",
      "filename": "test/cmdlineargs.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/test%2Fcmdlineargs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/test%2Fcmdlineargs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fcmdlineargs.jl?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -551,19 +551,19 @@ let exename = `$(Base.julia_cmd()) --startup-file=no --color=no`\n         @test isfile(covfile)\n         got = read(covfile, String)\n         rm(covfile)\n-        @test occursin(expected, got) || (expected, got)\n+        @test occursin(expected, got) context=(expected, got)\n         @test readchomp(`$cov_exename -E \"Base.JLOptions().code_coverage\" -L $inputfile\n             --code-coverage=$covfile --code-coverage=user`) == \"1\"\n         @test isfile(covfile)\n         got = read(covfile, String)\n         rm(covfile)\n-        @test occursin(expected, got) || (expected, got)\n+        @test occursin(expected, got) context=(expected, got)\n         @test readchomp(`$cov_exename -E \"Base.JLOptions().code_coverage\" -L $inputfile\n             --code-coverage=$covfile --code-coverage=all`) == \"2\"\n         @test isfile(covfile)\n         got = read(covfile, String)\n         rm(covfile)\n-        @test occursin(expected, got) || (expected, got)\n+        @test occursin(expected, got) context=(expected, got)\n \n         # Ask for coverage in specific file\n         tfile = realpath(inputfile)\n@@ -572,7 +572,7 @@ let exename = `$(Base.julia_cmd()) --startup-file=no --color=no`\n         @test isfile(covfile)\n         got = read(covfile, String)\n         rm(covfile)\n-        @test occursin(expected, got) || (expected, got)\n+        @test occursin(expected, got) context=(expected, got)\n \n         # Ask for coverage in directory\n         tdir = dirname(realpath(inputfile))\n@@ -581,7 +581,7 @@ let exename = `$(Base.julia_cmd()) --startup-file=no --color=no`\n         @test isfile(covfile)\n         got = read(covfile, String)\n         rm(covfile)\n-        @test occursin(expected, got) || (expected, got)\n+        @test occursin(expected, got) context=(expected, got)\n \n         # Ask for coverage in current directory\n         tdir = dirname(realpath(inputfile))\n@@ -593,7 +593,7 @@ let exename = `$(Base.julia_cmd()) --startup-file=no --color=no`\n         @test isfile(covfile)\n         got = read(covfile, String)\n         rm(covfile)\n-        @test occursin(expected, got) || (expected, got)\n+        @test occursin(expected, got) context=(expected, got)\n \n         # Ask for coverage in relative directory\n         tdir = dirname(realpath(inputfile))\n@@ -604,7 +604,7 @@ let exename = `$(Base.julia_cmd()) --startup-file=no --color=no`\n         @test isfile(covfile)\n         got = read(covfile, String)\n         rm(covfile)\n-        @test occursin(expected, got) || (expected, got)\n+        @test occursin(expected, got) context=(expected, got)\n \n         # Ask for coverage in relative directory with dot-dot notation\n         tdir = dirname(realpath(inputfile))\n@@ -615,7 +615,7 @@ let exename = `$(Base.julia_cmd()) --startup-file=no --color=no`\n         @test isfile(covfile)\n         got = read(covfile, String)\n         rm(covfile)\n-        @test occursin(expected, got) || (expected, got)\n+        @test occursin(expected, got) context=(expected, got)\n \n         # Ask for coverage in a different directory\n         tdir = mktempdir() # a dir that contains no code\n@@ -726,7 +726,7 @@ let exename = `$(Base.julia_cmd()) --startup-file=no --color=no`\n         end\n         @test popfirst!(got) == \"        - end\"\n         @test popfirst!(got) == \"        - f(1.23)\"\n-        @test isempty(got) || got\n+        @test isempty(got) context=got\n     end\n \n "
    },
    {
      "sha": "fbb05fb1c729878d9dae4ad6626f7b400fdb0cb6",
      "filename": "test/math.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/test%2Fmath.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/test%2Fmath.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fmath.jl?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -1537,7 +1537,7 @@ end\n             @test func(-zero(T), zero(T), -zero(T)) === -zero(T)\n             for _ in 1:2^18\n                 a, b, c = reinterpret.(T, rand(Base.uinttype(T), 3))\n-                @test isequal(func(a, b, c), fma(a, b, c)) || (a,b,c)\n+                @test isequal(func(a, b, c), fma(a, b, c)) context=(a,b,c)\n             end\n         end\n         @test func(floatmax(Float64), nextfloat(1.0), -floatmax(Float64)) === 3.991680619069439e292\n@@ -1559,9 +1559,9 @@ end\n             for y in (0.0, -0.0, 1.0, -3.0,-10.0 , Inf, NaN, -Inf, -NaN)\n                 got, expected = T(x)^T(y), T(big(x)^T(y))\n                 if isnan(expected)\n-                    @test isnan_type(T, got) || T.((x,y))\n+                    @test isnan_type(T, got) context=T.((x,y))\n                 else\n-                    @test got == expected || T.((x,y))\n+                    @test got == expected context=T.((x,y))\n                 end\n             end\n         end\n@@ -1571,13 +1571,13 @@ end\n             got, expected = x^y, widen(x)^y\n             if isfinite(eps(T(expected)))\n                 if y == T(-2) # unfortunately x^-2 is less accurate for performance reasons.\n-                    @test abs(expected-got) <= POW_TOLS[T][4]*eps(T(expected)) || (x,y)\n+                    @test abs(expected-got) <= POW_TOLS[T][4]*eps(T(expected)) context=(x,y)\n                 elseif y == T(3) # unfortunately x^3 is less accurate for performance reasons.\n-                    @test abs(expected-got) <= POW_TOLS[T][5]*eps(T(expected)) || (x,y)\n+                    @test abs(expected-got) <= POW_TOLS[T][5]*eps(T(expected)) context=(x,y)\n                 elseif issubnormal(got)\n-                    @test abs(expected-got) <= POW_TOLS[T][2]*eps(T(expected)) || (x,y)\n+                    @test abs(expected-got) <= POW_TOLS[T][2]*eps(T(expected)) context=(x,y)\n                 else\n-                    @test abs(expected-got) <= POW_TOLS[T][1]*eps(T(expected)) || (x,y)\n+                    @test abs(expected-got) <= POW_TOLS[T][1]*eps(T(expected)) context=(x,y)\n                 end\n             end\n         end\n@@ -1586,7 +1586,7 @@ end\n             x=rand(T)*floatmin(T); y=rand(T)*3-T(1.2)\n             got, expected = x^y, widen(x)^y\n             if isfinite(eps(T(expected)))\n-                @test abs(expected-got) <= POW_TOLS[T][3]*eps(T(expected)) || (x,y)\n+                @test abs(expected-got) <= POW_TOLS[T][3]*eps(T(expected)) context=(x,y)\n             end\n         end\n         # test (-x)^y for y larger than typemax(Int)"
    },
    {
      "sha": "d82bed379d409e1a0b602f368ba3653e5919ccc3",
      "filename": "test/strings/basic.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/test%2Fstrings%2Fbasic.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/35eaf05348215063bd239f3609a625e97735685d/test%2Fstrings%2Fbasic.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fstrings%2Fbasic.jl?ref=35eaf05348215063bd239f3609a625e97735685d",
      "patch": "@@ -1248,16 +1248,16 @@ end\n                    (hash, (String,UInt)),\n                    (hash, (Char,UInt)),]\n         e = Base.infer_effects(f, Ts)\n-        @test Core.Compiler.is_foldable(e) || (f, Ts)\n-        @test Core.Compiler.is_removable_if_unused(e) || (f, Ts)\n+        @test Core.Compiler.is_foldable(e) context=(f, Ts)\n+        @test Core.Compiler.is_removable_if_unused(e) context=(f, Ts)\n     end\n     for (f, Ts) in [(^, (String, Int)),\n                    (^, (Char, Int)),\n                    (codeunit, (String, Int)),\n                    ]\n         e = Base.infer_effects(f, Ts)\n-        @test Core.Compiler.is_foldable(e) || (f, Ts)\n-        @test !Core.Compiler.is_removable_if_unused(e) || (f, Ts)\n+        @test Core.Compiler.is_foldable(e) context=(f, Ts)\n+        @test !Core.Compiler.is_removable_if_unused(e) context=(f, Ts)\n     end\n     # Substrings don't have any nice effects because the compiler can\n     # invent fake indices leading to out of bounds\n@@ -1267,8 +1267,8 @@ end\n                    (hash, (SubString{String},UInt)),\n                    ]\n         e = Base.infer_effects(f, Ts)\n-        @test !Core.Compiler.is_foldable(e) || (f, Ts)\n-        @test !Core.Compiler.is_removable_if_unused(e) || (f, Ts)\n+        @test !Core.Compiler.is_foldable(e) context=(f, Ts)\n+        @test !Core.Compiler.is_removable_if_unused(e) context=(f, Ts)\n     end\n     @test_throws ArgumentError Symbol(\"a\\0a\")\n "
    }
  ]
}