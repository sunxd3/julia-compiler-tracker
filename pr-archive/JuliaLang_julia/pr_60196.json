{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60196",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60196/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60196/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60196/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60196",
  "id": 3653202324,
  "node_id": "PR_kwDOABkWpM606E4B",
  "number": 60196,
  "title": "Revert \"Add JLJITLinkMemoryManager (ports memory manager to JITLink)\"",
  "user": {
    "login": "giordano",
    "id": 765740,
    "node_id": "MDQ6VXNlcjc2NTc0MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/765740?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/giordano",
    "html_url": "https://github.com/giordano",
    "followers_url": "https://api.github.com/users/giordano/followers",
    "following_url": "https://api.github.com/users/giordano/following{/other_user}",
    "gists_url": "https://api.github.com/users/giordano/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/giordano/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/giordano/subscriptions",
    "organizations_url": "https://api.github.com/users/giordano/orgs",
    "repos_url": "https://api.github.com/users/giordano/repos",
    "events_url": "https://api.github.com/users/giordano/events{/privacy}",
    "received_events_url": "https://api.github.com/users/giordano/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4447355909,
      "node_id": "LA_kwDOABkWpM8AAAABCRVEBQ",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/revert",
      "name": "revert",
      "color": "fbca04",
      "default": false,
      "description": "This reverts a previously merged PR."
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 3,
  "created_at": "2025-11-21T21:57:29Z",
  "updated_at": "2025-11-22T02:11:23Z",
  "closed_at": "2025-11-22T01:20:18Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60196",
    "html_url": "https://github.com/JuliaLang/julia/pull/60196",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60196.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60196.patch",
    "merged_at": "2025-11-22T01:20:18Z"
  },
  "body": "Reverts JuliaLang/julia#60105.  Nightly builds of aarch64-darwin Julia hang at startup on some systems, notably on GitHub Actions, making all nightly jobs timeout (after 6 hours...), see https://discourse.julialang.org/t/ci-testing-hangs-on-macos-nightly/133909 (previously reported on Slack at https://julialang.slack.com/archives/CPWJ5DGG1/p1763055610279379).  See also https://github.com/julia-actions/julia-runtest/pull/155. The error message when the process receives a SIGTERM signal is\r\n```\r\nin expression starting at none:0\r\n__psynch_cvwait at /usr/lib/system/libsystem_kernel.dylib (unknown line)\r\nunknown function (ip: 0x0) at (unknown file)\r\n__psynch_mutexwait at /usr/lib/system/libsystem_kernel.dylib (unknown line)\r\nunknown function (ip: 0x0) at (unknown file)\r\nAllocations: 1 (Pool: 1; Big: 0); GC: 0\r\n```\r\nI can reliably reproduce it locally on a M1 box with MacOSX 12.6 21.6.0, I can provide more information as needed.\r\n\r\nI bisected the issue to #60105.  CC @xal-0 for your information.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60196/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60196/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "99f78b81bf0b2c50d0c6d4442ce677a9c6732c2f",
      "filename": "src/cgmemmgr.cpp",
      "status": "modified",
      "additions": 46,
      "deletions": 187,
      "changes": 233,
      "blob_url": "https://github.com/JuliaLang/julia/blob/305ae33084f35dc5719492eaea7070297e71cc4d/src%2Fcgmemmgr.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/305ae33084f35dc5719492eaea7070297e71cc4d/src%2Fcgmemmgr.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcgmemmgr.cpp?ref=305ae33084f35dc5719492eaea7070297e71cc4d",
      "patch": "@@ -3,11 +3,7 @@\n #include \"llvm-version.h\"\n #include \"platform.h\"\n \n-#include <llvm/ExecutionEngine/JITLink/JITLink.h>\n-#include <llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h>\n-#include <llvm/ExecutionEngine/Orc/MapperJITLinkMemoryManager.h>\n #include <llvm/ExecutionEngine/SectionMemoryManager.h>\n-\n #include \"julia.h\"\n #include \"julia_internal.h\"\n \n@@ -464,36 +460,26 @@ struct Block {\n     }\n };\n \n-struct Allocation {\n-    // Address to write to (the one returned by the allocation function)\n-    void *wr_addr;\n-    // Runtime address\n-    void *rt_addr;\n-    size_t sz;\n-    bool relocated;\n-};\n-\n class RWAllocator {\n     static constexpr int nblocks = 8;\n     Block blocks[nblocks]{};\n public:\n     RWAllocator() JL_NOTSAFEPOINT = default;\n-    Allocation alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n+    void *alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n     {\n         size_t min_size = (size_t)-1;\n         int min_id = 0;\n         for (int i = 0;i < nblocks && blocks[i].ptr;i++) {\n             if (void *ptr = blocks[i].alloc(size, align))\n-                return {ptr, ptr, size, false};\n+                return ptr;\n             if (blocks[i].avail < min_size) {\n                 min_size = blocks[i].avail;\n                 min_id = i;\n             }\n         }\n         size_t block_size = get_block_size(size);\n         blocks[min_id].reset(map_anon_page(block_size), block_size);\n-        void *ptr = blocks[min_id].alloc(size, align);\n-        return {ptr, ptr, size, false};\n+        return blocks[min_id].alloc(size, align);\n     }\n };\n \n@@ -533,6 +519,16 @@ struct SplitPtrBlock : public Block {\n     }\n };\n \n+struct Allocation {\n+    // Address to write to (the one returned by the allocation function)\n+    void *wr_addr;\n+    // Runtime address\n+    void *rt_addr;\n+    size_t sz;\n+    bool relocated;\n+};\n+\n+template<bool exec>\n class ROAllocator {\n protected:\n     static constexpr int nblocks = 8;\n@@ -560,7 +556,7 @@ class ROAllocator {\n     }\n     // Allocations that have not been finalized yet.\n     SmallVector<Allocation, 16> allocations;\n-    Allocation alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n+    void *alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n     {\n         size_t min_size = (size_t)-1;\n         int min_id = 0;\n@@ -576,9 +572,8 @@ class ROAllocator {\n                     wr_ptr = get_wr_ptr(block, ptr, size, align);\n                 }\n                 block.state |= SplitPtrBlock::Alloc;\n-                Allocation a{wr_ptr, ptr, size, false};\n-                allocations.push_back(a);\n-                return a;\n+                allocations.push_back(Allocation{wr_ptr, ptr, size, false});\n+                return wr_ptr;\n             }\n             if (block.avail < min_size) {\n                 min_size = block.avail;\n@@ -599,21 +594,18 @@ class ROAllocator {\n #ifdef _OS_WINDOWS_\n         block.state = SplitPtrBlock::Alloc;\n         void *wr_ptr = get_wr_ptr(block, ptr, size, align);\n-        Allocation a{wr_ptr, ptr, size, false};\n-        allocations.push_back(a);\n+        allocations.push_back(Allocation{wr_ptr, ptr, size, false});\n         ptr = wr_ptr;\n #else\n         block.state = SplitPtrBlock::Alloc | SplitPtrBlock::InitAlloc;\n-        Allocation a{ptr, ptr, size, false};\n-        allocations.push_back(a);\n+        allocations.push_back(Allocation{ptr, ptr, size, false});\n #endif\n-        return a;\n+        return ptr;\n     }\n };\n \n-class DualMapAllocator : public ROAllocator {\n-    bool exec;\n-\n+template<bool exec>\n+class DualMapAllocator : public ROAllocator<exec> {\n protected:\n     void *get_wr_ptr(SplitPtrBlock &block, void *rt_ptr, size_t, size_t) override JL_NOTSAFEPOINT\n     {\n@@ -674,7 +666,7 @@ class DualMapAllocator : public ROAllocator {\n         }\n     }\n public:\n-    DualMapAllocator(bool exec) JL_NOTSAFEPOINT : exec(exec)\n+    DualMapAllocator() JL_NOTSAFEPOINT\n     {\n         assert(anon_hdl != -1);\n     }\n@@ -687,13 +679,13 @@ class DualMapAllocator : public ROAllocator {\n             finalize_block(block, true);\n             block.reset(nullptr, 0);\n         }\n-        ROAllocator::finalize();\n+        ROAllocator<exec>::finalize();\n     }\n };\n \n #ifdef _OS_LINUX_\n-class SelfMemAllocator : public ROAllocator {\n-    bool exec;\n+template<bool exec>\n+class SelfMemAllocator : public ROAllocator<exec> {\n     SmallVector<Block, 16> temp_buff;\n protected:\n     void *get_wr_ptr(SplitPtrBlock &block, void *rt_ptr,\n@@ -730,7 +722,9 @@ class SelfMemAllocator : public ROAllocator {\n         }\n     }\n public:\n-    SelfMemAllocator(bool exec) JL_NOTSAFEPOINT : exec(exec), temp_buff()\n+    SelfMemAllocator() JL_NOTSAFEPOINT\n+        : ROAllocator<exec>(),\n+          temp_buff()\n     {\n         assert(get_self_mem_fd() != -1);\n     }\n@@ -764,25 +758,11 @@ class SelfMemAllocator : public ROAllocator {\n         }\n         if (cached)\n             temp_buff.resize(1);\n-        ROAllocator::finalize();\n+        ROAllocator<exec>::finalize();\n     }\n };\n #endif // _OS_LINUX_\n \n-std::pair<std::unique_ptr<ROAllocator>, std::unique_ptr<ROAllocator>>\n-get_preferred_allocators() JL_NOTSAFEPOINT\n-{\n-#ifdef _OS_LINUX_\n-    if (get_self_mem_fd() != -1)\n-        return {std::make_unique<SelfMemAllocator>(false),\n-                std::make_unique<SelfMemAllocator>(true)};\n-#endif\n-    if (init_shared_map() != -1)\n-        return {std::make_unique<DualMapAllocator>(false),\n-                std::make_unique<DualMapAllocator>(true)};\n-    return {};\n-}\n-\n class RTDyldMemoryManagerJL : public SectionMemoryManager {\n     struct EHFrame {\n         uint8_t *addr;\n@@ -792,18 +772,29 @@ class RTDyldMemoryManagerJL : public SectionMemoryManager {\n     void operator=(const RTDyldMemoryManagerJL&) = delete;\n     SmallVector<EHFrame, 16> pending_eh;\n     RWAllocator rw_alloc;\n-    std::unique_ptr<ROAllocator> ro_alloc;\n-    std::unique_ptr<ROAllocator> exe_alloc;\n+    std::unique_ptr<ROAllocator<false>> ro_alloc;\n+    std::unique_ptr<ROAllocator<true>> exe_alloc;\n     size_t total_allocated;\n \n public:\n     RTDyldMemoryManagerJL() JL_NOTSAFEPOINT\n         : SectionMemoryManager(),\n           pending_eh(),\n           rw_alloc(),\n+          ro_alloc(),\n+          exe_alloc(),\n           total_allocated(0)\n     {\n-        std::tie(ro_alloc, exe_alloc) = get_preferred_allocators();\n+#ifdef _OS_LINUX_\n+        if (!ro_alloc && get_self_mem_fd() != -1) {\n+            ro_alloc.reset(new SelfMemAllocator<false>());\n+            exe_alloc.reset(new SelfMemAllocator<true>());\n+        }\n+#endif\n+        if (!ro_alloc && init_shared_map() != -1) {\n+            ro_alloc.reset(new DualMapAllocator<false>());\n+            exe_alloc.reset(new DualMapAllocator<true>());\n+        }\n     }\n     ~RTDyldMemoryManagerJL() override JL_NOTSAFEPOINT\n     {\n@@ -856,7 +847,7 @@ uint8_t *RTDyldMemoryManagerJL::allocateCodeSection(uintptr_t Size,\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITSize, Size);\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITCodeSize, Size);\n     if (exe_alloc)\n-        return (uint8_t*)exe_alloc->alloc(Size, Alignment).wr_addr;\n+        return (uint8_t*)exe_alloc->alloc(Size, Alignment);\n     return SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID,\n                                                      SectionName);\n }\n@@ -871,9 +862,9 @@ uint8_t *RTDyldMemoryManagerJL::allocateDataSection(uintptr_t Size,\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITSize, Size);\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITDataSize, Size);\n     if (!isReadOnly)\n-        return (uint8_t*)rw_alloc.alloc(Size, Alignment).wr_addr;\n+        return (uint8_t*)rw_alloc.alloc(Size, Alignment);\n     if (ro_alloc)\n-        return (uint8_t*)ro_alloc->alloc(Size, Alignment).wr_addr;\n+        return (uint8_t*)ro_alloc->alloc(Size, Alignment);\n     return SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID,\n                                                      SectionName, isReadOnly);\n }\n@@ -928,133 +919,6 @@ void RTDyldMemoryManagerJL::deregisterEHFrames(uint8_t *Addr,\n }\n #endif\n \n-class JLJITLinkMemoryManager : public jitlink::JITLinkMemoryManager {\n-    using OnFinalizedFunction =\n-        jitlink::JITLinkMemoryManager::InFlightAlloc::OnFinalizedFunction;\n-\n-    std::mutex Mutex;\n-    RWAllocator RWAlloc;\n-    std::unique_ptr<ROAllocator> ROAlloc;\n-    std::unique_ptr<ROAllocator> ExeAlloc;\n-    SmallVector<OnFinalizedFunction> FinalizedCallbacks;\n-    uint32_t InFlight{0};\n-\n-public:\n-    class InFlightAlloc;\n-\n-    static std::unique_ptr<JITLinkMemoryManager> Create()\n-    {\n-        auto [ROAlloc, ExeAlloc] = get_preferred_allocators();\n-        if (ROAlloc && ExeAlloc)\n-            return std::unique_ptr<JLJITLinkMemoryManager>(\n-                new JLJITLinkMemoryManager(std::move(ROAlloc), std::move(ExeAlloc)));\n-\n-        return cantFail(\n-            orc::MapperJITLinkMemoryManager::CreateWithMapper<orc::InProcessMemoryMapper>(\n-                /*Reservation Granularity*/ 16 * 1024 * 1024));\n-    }\n-\n-    void allocate(const jitlink::JITLinkDylib *JD, jitlink::LinkGraph &G,\n-                  OnAllocatedFunction OnAllocated) override;\n-\n-    void deallocate(std::vector<FinalizedAlloc> Allocs,\n-                    OnDeallocatedFunction OnDeallocated) override\n-    {\n-        jl_unreachable();\n-    }\n-\n-protected:\n-    JLJITLinkMemoryManager(std::unique_ptr<ROAllocator> ROAlloc,\n-                           std::unique_ptr<ROAllocator> ExeAlloc)\n-      : ROAlloc(std::move(ROAlloc)), ExeAlloc(std::move(ExeAlloc))\n-    {\n-    }\n-\n-    void finalize(OnFinalizedFunction OnFinalized)\n-    {\n-        SmallVector<OnFinalizedFunction> Callbacks;\n-        {\n-            std::unique_lock Lock{Mutex};\n-            FinalizedCallbacks.push_back(std::move(OnFinalized));\n-\n-            if (--InFlight > 0)\n-                return;\n-\n-            ROAlloc->finalize();\n-            ExeAlloc->finalize();\n-            Callbacks = std::move(FinalizedCallbacks);\n-        }\n-\n-        for (auto &CB : Callbacks)\n-            std::move(CB)(FinalizedAlloc{});\n-    }\n-};\n-\n-class JLJITLinkMemoryManager::InFlightAlloc\n-  : public jitlink::JITLinkMemoryManager::InFlightAlloc {\n-    JLJITLinkMemoryManager &MM;\n-    jitlink::LinkGraph &G;\n-\n-public:\n-    InFlightAlloc(JLJITLinkMemoryManager &MM, jitlink::LinkGraph &G) : MM(MM), G(G) {}\n-\n-    void abandon(OnAbandonedFunction OnAbandoned) override { jl_unreachable(); }\n-\n-    void finalize(OnFinalizedFunction OnFinalized) override\n-    {\n-        auto *GP = &G;\n-        MM.finalize([GP, OnFinalized =\n-                             std::move(OnFinalized)](Expected<FinalizedAlloc> FA) mutable {\n-            if (!FA)\n-                return OnFinalized(FA.takeError());\n-            // Need to handle dealloc actions when we GC code\n-            auto E = orc::shared::runFinalizeActions(GP->allocActions());\n-            if (!E)\n-                return OnFinalized(E.takeError());\n-            OnFinalized(std::move(FA));\n-        });\n-    }\n-};\n-\n-using orc::MemProt;\n-\n-void JLJITLinkMemoryManager::allocate(const jitlink::JITLinkDylib *JD,\n-                                      jitlink::LinkGraph &G,\n-                                      OnAllocatedFunction OnAllocated)\n-{\n-    jitlink::BasicLayout BL{G};\n-\n-    {\n-        std::unique_lock Lock{Mutex};\n-        for (auto &[AG, Seg] : BL.segments()) {\n-            if (AG.getMemLifetime() == orc::MemLifetime::NoAlloc)\n-                continue;\n-            assert(AG.getMemLifetime() == orc::MemLifetime::Standard);\n-\n-            auto Prot = AG.getMemProt();\n-            uint64_t Alignment = Seg.Alignment.value();\n-            uint64_t Size = Seg.ContentSize + Seg.ZeroFillSize;\n-            Allocation Alloc;\n-            if (Prot == (MemProt::Read | MemProt::Write))\n-                Alloc = RWAlloc.alloc(Size, Alignment);\n-            else if (Prot == MemProt::Read)\n-                Alloc = ROAlloc->alloc(Size, Alignment);\n-            else if (Prot == (MemProt::Read | MemProt::Exec))\n-                Alloc = ExeAlloc->alloc(Size, Alignment);\n-            else\n-                abort();\n-\n-            Seg.Addr = orc::ExecutorAddr::fromPtr(Alloc.rt_addr);\n-            Seg.WorkingMem = (char *)Alloc.wr_addr;\n-        }\n-    }\n-\n-    if (auto Err = BL.apply())\n-        return OnAllocated(std::move(Err));\n-\n-    ++InFlight;\n-    OnAllocated(std::make_unique<InFlightAlloc>(*this, G));\n-}\n }\n \n RTDyldMemoryManager* createRTDyldMemoryManager() JL_NOTSAFEPOINT\n@@ -1066,8 +930,3 @@ size_t getRTDyldMemoryManagerTotalBytes(RTDyldMemoryManager *mm) JL_NOTSAFEPOINT\n {\n     return ((RTDyldMemoryManagerJL*)mm)->getTotalBytes();\n }\n-\n-std::unique_ptr<jitlink::JITLinkMemoryManager> createJITLinkMemoryManager()\n-{\n-    return JLJITLinkMemoryManager::Create();\n-}"
    },
    {
      "sha": "0773d1a6c16a1edf1922dfabba6e2574a305c8f1",
      "filename": "src/jitlayers.cpp",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/305ae33084f35dc5719492eaea7070297e71cc4d/src%2Fjitlayers.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/305ae33084f35dc5719492eaea7070297e71cc4d/src%2Fjitlayers.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjitlayers.cpp?ref=305ae33084f35dc5719492eaea7070297e71cc4d",
      "patch": "@@ -1208,6 +1208,12 @@ class JLMemoryUsagePlugin : public ObjectLinkingLayer::Plugin {\n #pragma clang diagnostic ignored \"-Wunused-function\"\n #endif\n \n+// TODO: Port our memory management optimisations to JITLink instead of using the\n+// default InProcessMemoryManager.\n+std::unique_ptr<jitlink::JITLinkMemoryManager> createJITLinkMemoryManager() JL_NOTSAFEPOINT {\n+    return cantFail(orc::MapperJITLinkMemoryManager::CreateWithMapper<orc::InProcessMemoryMapper>(/*Reservation Granularity*/ 16 * 1024 * 1024));\n+}\n+\n #ifdef _COMPILER_CLANG_\n #pragma clang diagnostic pop\n #endif\n@@ -1231,7 +1237,6 @@ class JLEHFrameRegistrar final : public jitlink::EHFrameRegistrar {\n };\n \n RTDyldMemoryManager *createRTDyldMemoryManager(void) JL_NOTSAFEPOINT;\n-std::unique_ptr<jitlink::JITLinkMemoryManager> createJITLinkMemoryManager() JL_NOTSAFEPOINT;\n \n // A simple forwarding class, since OrcJIT v2 needs a unique_ptr, while we have a shared_ptr\n class ForwardingMemoryManager : public RuntimeDyld::MemoryManager {"
    }
  ]
}