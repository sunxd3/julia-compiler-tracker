{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59678",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59678/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59678/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59678/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59678",
  "id": 3460592461,
  "node_id": "PR_kwDOABkWpM6q3v-j",
  "number": 59678,
  "title": "clear up several more inconsistencies among `gcd` , `gcdx` and `invmod`",
  "user": {
    "login": "adienes",
    "id": 51664769,
    "node_id": "MDQ6VXNlcjUxNjY0NzY5",
    "avatar_url": "https://avatars.githubusercontent.com/u/51664769?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/adienes",
    "html_url": "https://github.com/adienes",
    "followers_url": "https://api.github.com/users/adienes/followers",
    "following_url": "https://api.github.com/users/adienes/following{/other_user}",
    "gists_url": "https://api.github.com/users/adienes/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/adienes/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/adienes/subscriptions",
    "organizations_url": "https://api.github.com/users/adienes/orgs",
    "repos_url": "https://api.github.com/users/adienes/repos",
    "events_url": "https://api.github.com/users/adienes/events{/privacy}",
    "received_events_url": "https://api.github.com/users/adienes/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 171885699,
      "node_id": "MDU6TGFiZWwxNzE4ODU2OTk=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/maths",
      "name": "maths",
      "color": "93755D",
      "default": false,
      "description": "Mathematical functions"
    },
    {
      "id": 414648058,
      "node_id": "MDU6TGFiZWw0MTQ2NDgwNTg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/bugfix",
      "name": "bugfix",
      "color": "15ff91",
      "default": false,
      "description": "This change fixes an existing bug"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 8,
  "created_at": "2025-09-27T18:18:44Z",
  "updated_at": "2025-10-21T23:00:44Z",
  "closed_at": "2025-10-21T14:21:26Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59678",
    "html_url": "https://github.com/JuliaLang/julia/pull/59678",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59678.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59678.patch",
    "merged_at": "2025-10-21T14:21:26Z"
  },
  "body": "fixes some bad behavior in `gcdx` where it would return nonpositive `gcd`:\r\n```\r\njulia> gcdx(typemin(Int8), typemin(Int8)) \r\n(-128, 0, -1)\r\n```\r\n\r\nthereby exposing new issues in `invmod` which had previously worked around these inconsistencies.\r\n\r\nthis PR makes that above example an error\r\n```\r\njulia> gcdx(typemin(Int8), typemin(Int8)) \r\nERROR: OverflowError: checked arithmetic: cannot compute |x| for x = -128::Int8\r\n```\r\n\r\nbut also fixes cases like\r\n```\r\njulia> gcdx(typemin(Int8), Int8(-1))\r\n(1, 0, -1)\r\n\r\njulia> gcd(typemin(Int8), UInt16(2))\r\n0x0002\r\n```\r\n\r\nwhich currently error on master.\r\n\r\nalso fixes several correctness issues with `invmod`, one random example: `invmod(0x3e81, Int16(-5716))`\r\n\r\nthe policy I'm targeting --- doesn't have to be publicly documented / promised I guess, but it's probably good to at least have an internal definition is:\r\n\r\nfor all of `gcd`, `gcdx`, `lcm`, `invmod`\r\n* if for `T = promote_typeof(a, b)`, `signed(T)` cannot fit `abs(a)` and `abs(b)`, then we obtain an error (ideally map to `DomainError`, but currently is `InexactError`)\r\n* the computation is returned in `T`, implying that if the correct value should be `abs(typemin(T))` and `T` is signed, we must error. again, this would ideally be a `DomainError` but is currently a mix of `DivideError` and `OverflowError`\r\n\r\notherwise, all the normal rules for these functions must hold:\r\n* `gcd(a, b) == gcdx(a, b)[1]`\r\n* `gcd` and `gcdx[1]` are positive\r\n* `d, u, v = gcdx(a, b)` must satisfy `d == u * a + v * b` modulo `T` possibly with overflow\r\n* `i = invmod(x, m)` must satisfy `mod(1, m) == mod(widemul(x, i), m)`\r\n* return sign of `invmod` follows the same conventions as the sign of `mod`\r\n\r\nand any inputs that do not error must return a correct value.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59678/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59678/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "b9a635b314e2d2323c09498b1fb80709ae9312ab",
      "filename": "base/intfuncs.jl",
      "status": "modified",
      "additions": 61,
      "deletions": 31,
      "changes": 92,
      "blob_url": "https://github.com/JuliaLang/julia/blob/548f2f464abb7afc1cbb03ff02f8affd4354a3a3/base%2Fintfuncs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/548f2f464abb7afc1cbb03ff02f8affd4354a3a3/base%2Fintfuncs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fintfuncs.jl?ref=548f2f464abb7afc1cbb03ff02f8affd4354a3a3",
      "patch": "@@ -143,13 +143,19 @@ function lcm(a::T, b::T) where T<:Integer\n     end\n end\n \n+function _promote_mixed_signs(a::Signed, b::Unsigned)\n+    # handle the case a == typemin(typeof(a)) if R != typeof(a)\n+    R = promote_typeof(a, b)\n+    promote(abs(a % signed(R)), b)\n+end\n+\n gcd(a::Integer) = checked_abs(a)\n gcd(a::Rational) = checked_abs(a.num) // a.den\n lcm(a::Union{Integer,Rational}) = gcd(a)\n-gcd(a::Unsigned, b::Signed) = gcd(promote(a, abs(b))...)\n-gcd(a::Signed, b::Unsigned) = gcd(promote(abs(a), b)...)\n+gcd(a::Unsigned, b::Signed) = gcd(b, a)\n+gcd(a::Signed, b::Unsigned) = gcd(_promote_mixed_signs(a, b)...)\n lcm(a::Unsigned, b::Signed) = lcm(promote(a, abs(b))...)\n-lcm(a::Signed, b::Unsigned) = lcm(promote(abs(a), b)...)\n+lcm(a::Signed, b::Unsigned) = lcm(_promote_mixed_signs(a, b)...)\n gcd(a::Real, b::Real) = gcd(promote(a,b)...)\n lcm(a::Real, b::Real) = lcm(promote(a,b)...)\n gcd(a::Real, b::Real, c::Real...) = gcd(a, gcd(b, c...))\n@@ -223,22 +229,31 @@ julia> gcdx(15, 12, 20)\n     their `typemax`, and the identity then holds only via the unsigned\n     integers' modulo arithmetic.\n \"\"\"\n-Base.@assume_effects :terminates_locally function gcdx(a::Integer, b::Integer)\n-    T = promote_type(typeof(a), typeof(b))\n-    a == b == 0 && return (zero(T), zero(T), zero(T))\n+Base.@assume_effects :terminates_locally function gcdx(a::T, b::T) where {T<:Integer}\n+    if iszero(a) && iszero(b)\n+        return (zero(T), zero(T), zero(T))\n+    elseif isone(abs(b))\n+        # handles (typemin(::Signed), -1)\n+        return (one(T), zero(T), b)\n+    elseif isone(abs(a))\n+        return (one(T), a, zero(T))\n+    end\n     # a0, b0 = a, b\n     s0, s1 = oneunit(T), zero(T)\n     t0, t1 = s1, s0\n     # The loop invariant is: s0*a0 + t0*b0 == a && s1*a0 + t1*b0 == b\n-    x = a % T\n-    y = b % T\n-    while y != 0\n-        q, r = divrem(x, y)\n-        x, y = y, r\n+    while !iszero(b)\n+        q, r = divrem(a, b)\n+        a, b = b, r\n         s0, s1 = s1, s0 - q*s1\n         t0, t1 = t1, t0 - q*t1\n     end\n-    x < 0 ? (-x, -s0, -t0) : (x, s0, t0)\n+    # for cases like abs(Int8(-128))\n+    if isnegative(a) && isnegative(abs(a))\n+        throw(DomainError((a, b), LazyString(\"gcd not representable in \", T)))\n+    else\n+        return isnegative(a) ? (abs(a), -s0, -t0) : (a, s0, t0)\n+    end\n end\n gcdx(a::Real, b::Real) = gcdx(promote(a,b)...)\n gcdx(a::T, b::T) where T<:Real = throw(MethodError(gcdx, (a,b)))\n@@ -254,11 +269,12 @@ function gcdx(a::Real, b::Real, cs::Real...)\n     d\u2032, x, ys... = gcdx(d, cs...)\n     return d\u2032, i*x, j*x, ys...\n end\n+\n function gcdx(a::Signed, b::Unsigned)\n-    R = promote_type(typeof(a), typeof(b))\n-    _a = a % signed(R) # handle the case a == typemin(typeof(a)) if R != typeof(a)\n-    d, u, v = gcdx(promote(abs(_a), b)...)\n-    d, flipsign(u, a), v\n+    R = promote_typeof(a, b)\n+    d, u, v = gcdx(promote(abs(a % signed(R)), b)...)\n+    flip_typemin = isnegative(a) & (R <: Signed)\n+    d, flipsign(u, a - flip_typemin), v\n end\n function gcdx(a::Unsigned, b::Signed)\n     d, v, u = gcdx(b, a)\n@@ -287,24 +303,38 @@ julia> invmod(5, 6)\n ```\n \"\"\"\n function invmod(n::Integer, m::Integer)\n+    # The postcondition is: mod(widemul(result, n), m) == mod(one(T), m) && iszero(div(result, m))\n     iszero(m) && throw(DomainError(m, \"`m` must not be 0.\"))\n-    if n isa Signed && hastypemax(typeof(n))\n-        # work around inconsistencies in gcdx\n-        # https://github.com/JuliaLang/julia/issues/33781\n-        T = promote_type(typeof(n), typeof(m))\n-        n == typemin(typeof(n)) && m == typeof(n)(-1) && return T(0)\n-        n == typeof(n)(-1) && m == typemin(typeof(n)) && return T(-1)\n+    R = promote_typeof(n, m)\n+    if R <: Signed\n+        x = _bezout_coef(n, m)\n+        return mod(x, m)\n+    else\n+        S = signed(R)\n+        if !hastypemax(S) || (n <= typemax(S)) && (m <= typemax(S))\n+            x = _bezout_coef(n % S, m % S)\n+\n+            # this branch is only hit if R <: Unsigned, so we don't have\n+            # to worry about abs(typemin(::Signed)) overflow. If `m` is\n+            # signed then `x` must be unsigned, and thus never negative\n+            isnegative(x) && (x += abs(m))\n+            return mod(x % R, m)\n+        else\n+            # since gcdx only promises bezout w.r.t overflow for unsigned ints,\n+            # we have to widen to a signed type\n+            W = widen(S)\n+            x = _bezout_coef(n % W, m % W)\n+            t = mod(x, m % W)\n+            isnegative(m) && (t -= m)\n+            return mod(t % R, m)\n+        end\n     end\n-    g, x, y = gcdx(n, m)\n+end\n+\n+function _bezout_coef(n, m)\n+    g, x, _ = gcdx(n, m)\n     g != 1 && throw(DomainError((n, m), LazyString(\"Greatest common divisor is \", g, \".\")))\n-    # Note that m might be negative here.\n-    if x isa Unsigned && hastypemax(typeof(x)) && x > typemax(x)>>1\n-        # x might have wrapped if it would have been negative\n-        # adding back m forces a correction\n-        x += m\n-    end\n-    # The postcondition is: mod(result * n, m) == mod(T(1), m) && div(result, m) == 0\n-    return mod(x, m)\n+    return x\n end\n \n \"\"\""
    },
    {
      "sha": "193b557a0d3696c987e008c6612ab348ad38f7ce",
      "filename": "test/intfuncs.jl",
      "status": "modified",
      "additions": 25,
      "deletions": 2,
      "changes": 27,
      "blob_url": "https://github.com/JuliaLang/julia/blob/548f2f464abb7afc1cbb03ff02f8affd4354a3a3/test%2Fintfuncs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/548f2f464abb7afc1cbb03ff02f8affd4354a3a3/test%2Fintfuncs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fintfuncs.jl?ref=548f2f464abb7afc1cbb03ff02f8affd4354a3a3",
      "patch": "@@ -217,6 +217,19 @@ end\n     d, u, v = gcdx(x, y)\n     @test x*u + y*v == d\n \n+    for T in (Int8, Int16, Int32, Int64, Int128)\n+        @test_throws DomainError gcdx(typemin(T), typemin(T))\n+        @test_throws DomainError gcdx(typemin(T), T(0))\n+        @test_throws DomainError gcdx(T(0), typemin(T))\n+        d, u, v = gcdx(typemin(T), T(-1))\n+        @test d == T(1)\n+        @test typemin(T) * u + T(-1) * v == T(1)\n+        @test gcdx(T(-1), typemin(T)) == (d, v, u)\n+        d, u, v = gcdx(typemin(T), T(1))\n+        @test d == T(1)\n+        @test typemin(T) * u + T(1) * v == T(1)\n+        @test gcdx(T(1), typemin(T)) == (d, v, u)\n+    end\n end\n \n # issue #58025\n@@ -244,7 +257,7 @@ end\n \n     @test gcdx(Int16(-32768), Int8(-128)) === (Int16(128), Int16(0), Int16(-1))\n     @test gcdx(Int8(-128), UInt16(256)) === (0x0080, 0xffff, 0x0000)\n-    @test_broken gcd(Int8(-128), UInt16(256)) === 0x0080\n+    @test gcd(Int8(-128), UInt16(256)) === 0x0080\n end\n \n @testset \"gcd/lcm/gcdx for custom types\" begin\n@@ -294,10 +307,20 @@ end\n     # Verify issue described in PR 58010 is fixed\n     @test invmod(UInt8(3), UInt16(50000)) === 0x411b\n \n+    @test invmod(0x00000001, Int8(-128)) === Int32(-127)\n+    @test invmod(0xffffffff, Int8(-38)) === Int32(-15)\n+    @test invmod(Int8(-1), 0xffffffff) === 0xfffffffe\n+    @test invmod(Int32(-1), typemin(Int64)) === Int64(-1)\n+    @test invmod(0x3e81, Int16(-5716)) === Int16(-2407)\n+\n     for T in (Int8, UInt8)\n         for x in typemin(T):typemax(T)\n             for m in typemin(T):typemax(T)\n-                if m != 0 && try gcdx(x, m)[1] == 1 catch _ true end\n+                if !(\n+                    iszero(m) ||\n+                    iszero(mod(x, m)) && !isone(abs(m)) ||\n+                    !isone(gcd(x, m))\n+                )\n                     y = invmod(x, m)\n                     @test mod(widemul(y, x), m) == mod(1, m)\n                     @test div(y, m) == 0"
    }
  ]
}