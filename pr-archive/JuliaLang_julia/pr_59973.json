{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59973",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59973/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59973/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59973/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59973",
  "id": 3558313652,
  "node_id": "PR_kwDOABkWpM6v-Y5I",
  "number": 59973,
  "title": "Remove use of ArrayRef(std::nullopt_t) constructor",
  "user": {
    "login": "yuyichao",
    "id": 712232,
    "node_id": "MDQ6VXNlcjcxMjIzMg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/712232?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/yuyichao",
    "html_url": "https://github.com/yuyichao",
    "followers_url": "https://api.github.com/users/yuyichao/followers",
    "following_url": "https://api.github.com/users/yuyichao/following{/other_user}",
    "gists_url": "https://api.github.com/users/yuyichao/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/yuyichao/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/yuyichao/subscriptions",
    "organizations_url": "https://api.github.com/users/yuyichao/orgs",
    "repos_url": "https://api.github.com/users/yuyichao/repos",
    "events_url": "https://api.github.com/users/yuyichao/events{/privacy}",
    "received_events_url": "https://api.github.com/users/yuyichao/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "vtjnash",
      "id": 330950,
      "node_id": "MDQ6VXNlcjMzMDk1MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vtjnash",
      "html_url": "https://github.com/vtjnash",
      "followers_url": "https://api.github.com/users/vtjnash/followers",
      "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
      "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
      "organizations_url": "https://api.github.com/users/vtjnash/orgs",
      "repos_url": "https://api.github.com/users/vtjnash/repos",
      "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vtjnash/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-10-27T19:35:11Z",
  "updated_at": "2025-12-10T20:06:06Z",
  "closed_at": "2025-12-10T20:06:04Z",
  "author_association": "CONTRIBUTOR",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59973",
    "html_url": "https://github.com/JuliaLang/julia/pull/59973",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59973.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59973.patch",
    "merged_at": "2025-12-10T20:06:04Z"
  },
  "body": "This is deprecated on LLVM 21 and in almost all cases this could be replaced with a simple `{}` which is both shorter and clearer that it was an array argument expected here. Only exception is constructor of `jl_cgval_t` due to an ambiguity.\r\n\r\nAs far as I can tell, all the places that was replaced has always been taking an `ArrayRef` so this should work on older LLVM versions as well.\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59973/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59973/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "d89f85302b2e3dfeba3664fa37357039f80811bf",
      "filename": "src/cgutils.cpp",
      "status": "modified",
      "additions": 7,
      "deletions": 8,
      "changes": 15,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fcgutils.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fcgutils.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcgutils.cpp?ref=c733f4149e24e591c8394d3296d49f00fcc241fd",
      "patch": "@@ -308,7 +308,7 @@ void jl_debugcache_t::initialize(Module *m) {\n     jl_di_func_sig = dbuilder.createSubroutineType(\n         dbuilder.getOrCreateTypeArray(diargs));\n     jl_di_func_null_sig = dbuilder.createSubroutineType(\n-        dbuilder.getOrCreateTypeArray(None));\n+        dbuilder.getOrCreateTypeArray({}));\n }\n \n static Value *emit_pointer_from_objref(jl_codectx_t &ctx, Value *V)\n@@ -580,7 +580,7 @@ static Constant *julia_pgv(jl_codegen_params_t &params, Module *M, const char *c\n     // since the load at the new location satisfy the same condition as the original one.\n     // Mark the global as constant to LLVM code using our own metadata\n     // which is much less likely to be striped.\n-    gv->setMetadata(\"julia.constgv\", MDNode::get(gv->getContext(), None));\n+    gv->setMetadata(\"julia.constgv\", MDNode::get(gv->getContext(), {}));\n     assert(localname == gv->getName());\n     assert(!gv->hasInitializer());\n     return gv;\n@@ -698,7 +698,7 @@ static inline Instruction *maybe_mark_load_dereferenceable(Instruction *LI, bool\n     if (isa<PointerType>(LI->getType())) {\n         if (!can_be_null)\n             // The `dereferenceable` below does not imply `nonnull` for non addrspace(0) pointers.\n-            LI->setMetadata(LLVMContext::MD_nonnull, MDNode::get(LI->getContext(), None));\n+            LI->setMetadata(LLVMContext::MD_nonnull, MDNode::get(LI->getContext(), {}));\n         if (size) {\n             Metadata *OP = ConstantAsMetadata::get(ConstantInt::get(getInt64Ty(LI->getContext()), size));\n             LI->setMetadata(can_be_null ? LLVMContext::MD_dereferenceable_or_null : LLVMContext::MD_dereferenceable,\n@@ -1907,7 +1907,7 @@ static Value *emit_typeof(jl_codectx_t &ctx, Value *v, bool maybenull, bool just\n             Value *smallp = emit_ptrgep(ctx, prepare_global_in(M, jl_small_typeof_var), tag);\n             jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_const);\n             auto small = ctx.builder.CreateAlignedLoad(typetag->getType(), smallp, M->getDataLayout().getPointerABIAlignment(0));\n-            small->setMetadata(LLVMContext::MD_nonnull, MDNode::get(M->getContext(), None));\n+            small->setMetadata(LLVMContext::MD_nonnull, MDNode::get(M->getContext(), {}));\n             return ai.decorateInst(small);\n         });\n     });\n@@ -2605,8 +2605,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n                 FunctionType::get(StructType::get(elty, elty), {ptr->getType(), ctx.builder.getPtrTy(), ctx.builder.getInt8Ty(), ctx.builder.getInt8Ty()}, true),\n                 AttributeList::get(elty->getContext(),\n                   Attributes(elty->getContext(), {Attribute::NoMerge}), // prevent llvm from merging calls to different functions\n-                  AttributeSet(),\n-                  None));\n+                  AttributeSet(), {}));\n         SmallVector<Value*,0> Args = {ptr, op, ctx.builder.getInt8((unsigned)Order), ctx.builder.getInt8(SyncScope::System)};\n         if (rhs.V)\n             Args.push_back(rhs.V);\n@@ -3533,7 +3532,7 @@ static Value *emit_genericmemoryptr(jl_codectx_t &ctx, Value *mem, const jl_data\n     PointerType *PPT = cast<PointerType>(ctx.types().T_jlgenericmemory->getElementType(1));\n     LoadInst *LI = ctx.builder.CreateAlignedLoad(PPT, addr, Align(sizeof(char*)));\n     LI->setOrdering(AtomicOrdering::NotAtomic);\n-    LI->setMetadata(LLVMContext::MD_nonnull, MDNode::get(ctx.builder.getContext(), None));\n+    LI->setMetadata(LLVMContext::MD_nonnull, MDNode::get(ctx.builder.getContext(), {}));\n     jl_aliasinfo_t aliasinfo = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_memoryptr);\n     aliasinfo.decorateInst(LI);\n     Value *ptr = LI;\n@@ -3552,7 +3551,7 @@ static Value *emit_genericmemoryowner(jl_codectx_t &ctx, Value *t)\n     Type *T_data = ctx.types().T_jlgenericmemory->getElementType(1);\n     LoadInst *LI = ctx.builder.CreateAlignedLoad(T_data, addr, Align(sizeof(char*)));\n     LI->setOrdering(AtomicOrdering::NotAtomic);\n-    LI->setMetadata(LLVMContext::MD_nonnull, MDNode::get(ctx.builder.getContext(), None));\n+    LI->setMetadata(LLVMContext::MD_nonnull, MDNode::get(ctx.builder.getContext(), {}));\n     jl_aliasinfo_t aliasinfo_mem = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_memoryown);\n     aliasinfo_mem.decorateInst(LI);\n     addr = emit_ptrgep(ctx, m, JL_SMALL_BYTE_ALIGNMENT);"
    },
    {
      "sha": "d40db1eb082e5eccfd3a8bc1657f4c8d778e5445",
      "filename": "src/codegen.cpp",
      "status": "modified",
      "additions": 34,
      "deletions": 34,
      "changes": 68,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fcodegen.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fcodegen.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcodegen.cpp?ref=c733f4149e24e591c8394d3296d49f00fcc241fd",
      "patch": "@@ -625,15 +625,15 @@ static AttributeList get_attrs_noreturn(LLVMContext &C)\n     return AttributeList::get(C,\n                 Attributes(C, {Attribute::NoReturn}),\n                 AttributeSet(),\n-                None);\n+                {});\n }\n \n static AttributeList get_attrs_basic(LLVMContext &C)\n {\n     return AttributeList::get(C,\n                 AttributeSet(),\n                 Attributes(C, {Attribute::NonNull}),\n-                None);\n+                {});\n }\n \n static AttributeList get_attrs_box_float(LLVMContext &C, unsigned nbytes)\n@@ -649,7 +649,7 @@ static AttributeList get_attrs_box_float(LLVMContext &C, unsigned nbytes)\n     return AttributeList::get(C,\n                 AttributeSet::get(C, FnAttrs),\n                 AttributeSet::get(C, RetAttrs),\n-                None);\n+                {});\n }\n \n static AttributeList get_attrs_box_sext(LLVMContext &C, unsigned nbytes)\n@@ -936,7 +936,7 @@ static const auto jltopeval_func = new JuliaFunction<>{\n     [](LLVMContext &C) { return AttributeList::get(C,\n             AttributeSet(),\n             Attributes(C, {Attribute::NonNull}),\n-            None); },\n+            {}); },\n };\n static const auto jlcopyast_func = new JuliaFunction<>{\n     XSTR(jl_copy_ast),\n@@ -948,7 +948,7 @@ static const auto jlcopyast_func = new JuliaFunction<>{\n     [](LLVMContext &C) { return AttributeList::get(C,\n             AttributeSet(),\n             Attributes(C, {Attribute::NonNull}),\n-            None); },\n+            {}); },\n };\n static const auto jlapplygeneric_func = new JuliaFunction<>{\n     XSTR(jl_apply_generic),\n@@ -1052,7 +1052,7 @@ static const auto jlleave_func = new JuliaFunction<>{\n             return AttributeList::get(C,\n                 AttributeSet::get(C, FnAttrs),\n                 AttributeSet(),\n-                None);\n+                {});\n         },\n };\n static const auto jlleave_noexcept_func = new JuliaFunction<>{\n@@ -1069,7 +1069,7 @@ static const auto jlleave_noexcept_func = new JuliaFunction<>{\n             return AttributeList::get(C,\n                 AttributeSet::get(C, FnAttrs),\n                 AttributeSet(),\n-                None);\n+                {});\n         },\n };\n static const auto jl_restore_excstack_func = new JuliaFunction<TypeFnContextAndSizeT>{\n@@ -1099,7 +1099,7 @@ static const auto jlegalx_func = new JuliaFunction<TypeFnContextAndSizeT>{\n         return AttributeList::get(C,\n                 AttributeSet::get(C, FnAttrs),\n                 AttributeSet(),\n-                None); },\n+                {}); },\n };\n static const auto jl_alloc_obj_func = new JuliaFunction<TypeFnContextAndSizeT>{\n     \"julia.gc_alloc_obj\",\n@@ -1122,7 +1122,7 @@ static const auto jl_alloc_obj_func = new JuliaFunction<TypeFnContextAndSizeT>{\n         return AttributeList::get(C,\n             AttributeSet::get(C, FnAttrs),\n             AttributeSet::get(C, RetAttrs),\n-            None);\n+            {});\n     },\n };\n static const auto jl_alloc_genericmemory_unchecked_func = new JuliaFunction<TypeFnContextAndSizeT>{\n@@ -1145,7 +1145,7 @@ static const auto jl_alloc_genericmemory_unchecked_func = new JuliaFunction<Type\n         return AttributeList::get(C,\n             AttributeSet::get(C, FnAttrs),\n             AttributeSet::get(C, RetAttrs),\n-            None);\n+            {});\n     },\n };\n static const auto jl_newbits_func = new JuliaFunction<>{\n@@ -1158,7 +1158,7 @@ static const auto jl_newbits_func = new JuliaFunction<>{\n     [](LLVMContext &C) { return AttributeList::get(C,\n             AttributeSet(),\n             Attributes(C, {Attribute::NonNull}),\n-            None); },\n+            {}); },\n };\n // `julia.typeof` does read memory, but it is effectively readnone before we lower\n // the allocation function. This is OK as long as we lower `julia.typeof` no later than\n@@ -1178,7 +1178,7 @@ static const auto jl_typeof_func = new JuliaFunction<>{\n         return AttributeList::get(C,\n             AttributeSet::get(C, FnAttrs),\n             Attributes(C, {Attribute::NonNull}),\n-            None); },\n+            {}); },\n };\n \n static const auto jl_write_barrier_func = new JuliaFunction<>{\n@@ -1230,7 +1230,7 @@ static const auto jlapplytype_func = new JuliaFunction<>{\n             AttributeSet(),\n             AttributeSet::get(C, ArrayRef<Attribute>({Attribute::get(C, Attribute::NonNull),\n                                                Attribute::getWithAlignment(C, Align(16))})),\n-            None);\n+            {});\n     },\n };\n static const auto jl_object_id__func = new JuliaFunction<TypeFnContextAndSizeT>{\n@@ -1251,7 +1251,7 @@ static const auto setjmp_func = new JuliaFunction<TypeFnContextAndTriple>{\n     [](LLVMContext &C) { return AttributeList::get(C,\n             Attributes(C, {Attribute::ReturnsTwice}),\n             AttributeSet(),\n-            None); },\n+            {}); },\n };\n static const auto memcmp_func = new JuliaFunction<TypeFnContextAndSizeT>{\n     XSTR(memcmp),\n@@ -1264,7 +1264,7 @@ static const auto memcmp_func = new JuliaFunction<TypeFnContextAndSizeT>{\n         return AttributeList::get(C,\n             AttributeSet::get(C, FnAttrs),\n             AttributeSet(),\n-            None); },\n+            {}); },\n     // TODO: inferLibFuncAttributes(*memcmp_func, TLI);\n };\n static const auto jldlsym_func = new JuliaFunction<>{\n@@ -1298,7 +1298,7 @@ static const auto jlgetnthfieldchecked_func = new JuliaFunction<TypeFnContextAnd\n     [](LLVMContext &C) { return AttributeList::get(C,\n             AttributeSet(),\n             Attributes(C, {Attribute::NonNull}),\n-            None); },\n+            {}); },\n };\n static const auto jlfieldindex_func = new JuliaFunction<>{\n     XSTR(jl_field_index),\n@@ -1315,7 +1315,7 @@ static const auto jlfieldindex_func = new JuliaFunction<>{\n         return AttributeList::get(C,\n             AttributeSet::get(C, FnAttrs),\n             AttributeSet(),\n-            None); }, // This function can error if the third argument is 1 so don't do that.\n+            {}); }, // This function can error if the third argument is 1 so don't do that.\n };\n static const auto jlfieldisdefinedchecked_func = new JuliaFunction<TypeFnContextAndSizeT>{\n     XSTR(jl_field_isdefined_checked),\n@@ -1327,7 +1327,7 @@ static const auto jlfieldisdefinedchecked_func = new JuliaFunction<TypeFnContext\n     [](LLVMContext &C) { return AttributeList::get(C,\n             AttributeSet(),\n             Attributes(C, {}),\n-            None); },\n+            {}); },\n };\n static const auto jlgetcfunctiontrampoline_func = new JuliaFunction<>{\n     XSTR(jl_get_cfunction_trampoline),\n@@ -1349,7 +1349,7 @@ static const auto jlgetcfunctiontrampoline_func = new JuliaFunction<>{\n     [](LLVMContext &C) { return AttributeList::get(C,\n             AttributeSet(),\n             Attributes(C, {Attribute::NonNull}),\n-            None); },\n+            {}); },\n };\n static const auto jlgetabiconverter_func = new JuliaFunction<TypeFnContextAndSizeT>{\n     XSTR(jl_get_abi_converter),\n@@ -1389,7 +1389,7 @@ static const auto jl_allocgenericmemory = new JuliaFunction<TypeFnContextAndSize\n             return AttributeList::get(C,\n                 AttributeSet::get(C, FnAttrs),\n                 AttributeSet::get(C, RetAttrs),\n-                None); },\n+                {}); },\n };\n #define BOX_FUNC(ct,at,attrs,nbytes)                                                    \\\n static const auto box_##ct##_func = new JuliaFunction<>{                           \\\n@@ -1431,7 +1431,7 @@ static const auto jldnd_func = new JuliaFunction<>{\n         return AttributeList::get(C,\n                 AttributeSet::get(C, FnAttrs),\n                 Attributes(C, {}),\n-                None);\n+                {});\n     },\n };\n \n@@ -1466,7 +1466,7 @@ static const auto pointer_from_objref_func = new JuliaFunction<>{\n         return AttributeList::get(C,\n             AttributeSet::get(C, FnAttrs),\n             Attributes(C, {Attribute::NonNull}),\n-            None); },\n+            {}); },\n };\n static const auto gc_loaded_func = new JuliaFunction<>{\n     \"julia.gc_loaded\",\n@@ -1680,7 +1680,7 @@ struct jl_aliasinfo_t {\n                 MDNode *operand = cast<MDNode>(this->scope->getOperand(0));\n                 auto scope_name = cast<MDString>(operand->getOperand(0))->getString();\n                 if (scope_name == \"jnoalias_const\")\n-                    inst->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(inst->getContext(), None));\n+                    inst->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(inst->getContext(), {}));\n             }\n         }\n \n@@ -2065,7 +2065,7 @@ jl_aliasinfo_t jl_aliasinfo_t::fromTBAA(jl_codectx_t &ctx, MDNode *tbaa) {\n \n static Type *julia_type_to_llvm(jl_codectx_t &ctx, jl_value_t *jt, bool *isboxed = NULL);\n static jl_returninfo_t get_specsig_function(jl_codegen_params_t &ctx, Module *M, Value *fval, StringRef name, jl_value_t *sig, jl_value_t *jlrettype, bool is_opaque_closure,\n-        ArrayRef<const char*> ArgNames=None, unsigned nreq=0);\n+        ArrayRef<const char*> ArgNames={}, unsigned nreq=0);\n static jl_cgval_t emit_expr(jl_codectx_t &ctx, jl_value_t *expr, ssize_t ssaval = -1);\n static jl_cgval_t emit_checked_var(jl_codectx_t &ctx, Value *bp, jl_sym_t *name, jl_value_t *scope, bool isvol, MDNode *tbaa);\n static jl_cgval_t emit_sparam(jl_codectx_t &ctx, size_t i);\n@@ -2243,7 +2243,7 @@ static inline jl_cgval_t ghostValue(jl_codectx_t &ctx, jl_value_t *typ)\n     if (jl_is_type_type(typ)) {\n         assert(is_uniquerep_Type(typ));\n         // replace T::Type{T} with T, by assuming that T must be a leaftype of some sort\n-        jl_cgval_t constant(NULL, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), None);\n+        jl_cgval_t constant(NULL, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n         constant.constant = jl_tparam0(typ);\n         if (typ == (jl_value_t*)jl_typeofbottom_type->super)\n             constant.isghost = true;\n@@ -2267,13 +2267,13 @@ static inline jl_cgval_t mark_julia_const(jl_codectx_t &ctx, jl_value_t *jv)\n         if (jl_is_datatype_singleton((jl_datatype_t*)typ))\n             return ghostValue(ctx, typ);\n     }\n-    jl_cgval_t constant(NULL, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), None);\n+    jl_cgval_t constant(NULL, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n     constant.constant = jv;\n     return constant;\n }\n \n \n-static inline jl_cgval_t mark_julia_slot(Value *v, jl_value_t *typ, Value *tindex, MDNode *tbaa, ArrayRef<Value*> inline_roots=None)\n+static inline jl_cgval_t mark_julia_slot(Value *v, jl_value_t *typ, Value *tindex, MDNode *tbaa, ArrayRef<Value*> inline_roots={})\n {\n     // this enables lazy-copying of immutable values and stack or argument slots\n     jl_cgval_t tagval(v, false, typ, tindex, tbaa, inline_roots);\n@@ -2353,7 +2353,7 @@ static inline jl_cgval_t mark_julia_type(jl_codectx_t &ctx, Value *v, bool isbox\n     if (type_is_ghost(T))\n         return ghostValue(ctx, typ);\n     if (isboxed)\n-        return jl_cgval_t(v, isboxed, typ, NULL, best_tbaa(ctx.tbaa(), typ), None);\n+        return jl_cgval_t(v, isboxed, typ, NULL, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n     if (v && v->getType()->isAggregateType()) {\n         // eagerly put this back onto the stack\n         // llvm mem2reg pass will remove this if unneeded\n@@ -2414,7 +2414,7 @@ static inline jl_cgval_t update_julia_type(jl_codectx_t &ctx, const jl_cgval_t &\n                 return jl_cgval_t();\n             }\n             if (v.Vboxed && (v.isboxed || alwaysboxed)) {\n-                return jl_cgval_t(v.Vboxed, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), None);\n+                return jl_cgval_t(v.Vboxed, true, typ, NULL, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n             }\n         }\n         if (!jl_is_concrete_type(typ))\n@@ -2529,7 +2529,7 @@ static jl_cgval_t convert_julia_type_to_union(jl_codectx_t &ctx, const jl_cgval_\n             }\n             else if (jl_subtype(v.typ, typ)) {\n                 // convert to a simple isboxed value, since it must be boxed in the new union\n-                return jl_cgval_t(boxed(ctx, v), true, typ, new_tindex, best_tbaa(ctx.tbaa(), typ), None);\n+                return jl_cgval_t(boxed(ctx, v), true, typ, new_tindex, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n             }\n             else {\n                 if (!allow_mismatch)\n@@ -2792,7 +2792,7 @@ static jl_cgval_t convert_julia_type_to_union(jl_codectx_t &ctx, const jl_cgval_\n     if (!computed_new_index_early && isa<Constant>(new_tindex)) {\n         // no new tindex (it is set to UNION_BOX_MARKER), so the new value must be something boxed in the new union\n         // TODO: use ret.Vboxed or box_union directly to set skip instead of emitting a trap?\n-        return jl_cgval_t(boxed(ctx, v), true, typ, new_tindex, best_tbaa(ctx.tbaa(), typ), None);\n+        return jl_cgval_t(boxed(ctx, v), true, typ, new_tindex, best_tbaa(ctx.tbaa(), typ), ArrayRef<Value*>());\n     }\n     // some of the values are still unboxed\n     setName(ctx.emission_context, new_tindex, \"tindex\");\n@@ -5770,7 +5770,7 @@ static jl_cgval_t emit_varinfo(jl_codectx_t &ctx, jl_varinfo_t &vi, jl_sym_t *va\n             Value *tindex = NULL;\n             if (vi.pTIndex)\n                 tindex = ctx.builder.CreateAlignedLoad(getInt8Ty(ctx.builder.getContext()), vi.pTIndex, Align(1), vi.isVolatile);\n-            v = mark_julia_slot(ssaslot, vi.value.typ, tindex, ctx.tbaa().tbaa_stack, None);\n+            v = mark_julia_slot(ssaslot, vi.value.typ, tindex, ctx.tbaa().tbaa_stack);\n         }\n         if (vi.inline_roots) {\n             AllocaInst *varslot = vi.inline_roots;\n@@ -6734,7 +6734,7 @@ static jl_cgval_t emit_expr(jl_codectx_t &ctx, jl_value_t *expr, ssize_t ssaidx_\n         SmallVector<Metadata *, 8> MDs;\n \n         // Reserve first location for self reference to the LoopID metadata node.\n-        TempMDTuple TempNode = MDNode::getTemporary(ctx.builder.getContext(), None);\n+        TempMDTuple TempNode = MDNode::getTemporary(ctx.builder.getContext(), {});\n         MDs.push_back(TempNode.get());\n \n         for (int i = 0, ie = nargs; i < ie; ++i) {\n@@ -8799,7 +8799,7 @@ static jl_llvm_functions_t\n             AllocaInst *roots = sizes.second > 0 ? emit_static_roots(ctx, sizes.second) : nullptr;\n             if (bits) bits->setName(jl_symbol_name(s));\n             if (roots) roots->setName(StringRef(\".roots.\") + jl_symbol_name(s));\n-            varinfo.value = mark_julia_slot(bits, jt, NULL, ctx.tbaa().tbaa_stack, None);\n+            varinfo.value = mark_julia_slot(bits, jt, NULL, ctx.tbaa().tbaa_stack, {});\n             varinfo.inline_roots = roots;\n             varinfo.inline_roots_count = sizes.second;\n             alloc_def_flag(ctx, varinfo);"
    },
    {
      "sha": "10f8091aac7e2596aec3587bcadee08126a30045",
      "filename": "src/llvm-codegen-shared.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fllvm-codegen-shared.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fllvm-codegen-shared.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fllvm-codegen-shared.h?ref=c733f4149e24e591c8394d3296d49f00fcc241fd",
      "patch": "@@ -158,7 +158,7 @@ static inline llvm::Instruction *tbaa_decorate(llvm::MDNode *md, llvm::Instructi\n     using namespace llvm;\n     inst->setMetadata(llvm::LLVMContext::MD_tbaa, md);\n     if (llvm::isa<llvm::LoadInst>(inst) && md && md == get_tbaa_const(md->getContext())) {\n-        inst->setMetadata(llvm::LLVMContext::MD_invariant_load, llvm::MDNode::get(md->getContext(), std::nullopt));\n+        inst->setMetadata(llvm::LLVMContext::MD_invariant_load, llvm::MDNode::get(md->getContext(), {}));\n     }\n     return inst;\n }"
    },
    {
      "sha": "4c4b5efcd57274c5339d2c396346200925a455f2",
      "filename": "src/llvm-late-gc-lowering.cpp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fllvm-late-gc-lowering.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fllvm-late-gc-lowering.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fllvm-late-gc-lowering.cpp?ref=c733f4149e24e591c8394d3296d49f00fcc241fd",
      "patch": "@@ -2198,7 +2198,7 @@ bool LateLowerGCFrame::CleanupIR(Function &F, State *S, bool *CFGModified) {\n                 } else {\n                     // remove all operand bundles\n #if JL_LLVM_VERSION >= 200000\n-                    CallInst *NewCall = CallInst::Create(CI, None, CI->getIterator());\n+                    CallInst *NewCall = CallInst::Create(CI, {}, CI->getIterator());\n #else\n                     CallInst *NewCall = CallInst::Create(CI, None, CI);\n #endif"
    },
    {
      "sha": "55b20479408f99c38b689cc0efe01a24c79ecddb",
      "filename": "src/llvm-multiversioning.cpp",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fllvm-multiversioning.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fllvm-multiversioning.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fllvm-multiversioning.cpp?ref=c733f4149e24e591c8394d3296d49f00fcc241fd",
      "patch": "@@ -520,7 +520,7 @@ Function *CloneCtx::create_trampoline(Function *F, GlobalVariable *slot, bool au\n \n     auto ptr = irbuilder.CreateLoad(F->getType(), slot);\n     ptr->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);\n-    ptr->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(F->getContext(), None));\n+    ptr->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(F->getContext(), {}));\n \n     SmallVector<Value *, 0> Args;\n     for (auto &arg : trampoline->args())\n@@ -876,7 +876,7 @@ static void replaceUsesWithLoad(Function &F, Type *T_size, I2GV should_replace,\n #endif\n             Instruction *ptr = new LoadInst(F.getType(), slot, \"\", false, insert_before);\n             ptr->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);\n-            ptr->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(ptr->getContext(), None));\n+            ptr->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(ptr->getContext(), {}));\n             use_i->setOperand(info.use->getOperandNo(),\n                                 rewrite_inst_use(uses.get_stack(), T_size, ptr,\n                                                 insert_before));"
    },
    {
      "sha": "3929ecbb0e64e797f0ae6fa98d2497c0de7a1df2",
      "filename": "src/llvm-ptls.cpp",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fllvm-ptls.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c733f4149e24e591c8394d3296d49f00fcc241fd/src%2Fllvm-ptls.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fllvm-ptls.cpp?ref=c733f4149e24e591c8394d3296d49f00fcc241fd",
      "patch": "@@ -225,7 +225,7 @@ void LowerPTLS::fix_pgcstack_use(CallInst *pgcstack, Function *pgcstack_getter,\n             //     pgcstack = getter();    // slow\n             auto offset = builder.CreateLoad(T_size, pgcstack_offset);\n             offset->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);\n-            offset->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(pgcstack->getContext(), None));\n+            offset->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(pgcstack->getContext(), {}));\n             auto cmp = builder.CreateICmpNE(offset, Constant::getNullValue(offset->getType()));\n             MDBuilder MDB(pgcstack->getContext());\n             SmallVector<uint32_t, 2> Weights{9, 1};\n@@ -250,7 +250,7 @@ void LowerPTLS::fix_pgcstack_use(CallInst *pgcstack, Function *pgcstack_getter,\n             builder.SetInsertPoint(pgcstack);\n             auto getter = builder.CreateLoad(T_pgcstack_getter, pgcstack_func_slot);\n             getter->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);\n-            getter->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(pgcstack->getContext(), None));\n+            getter->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(pgcstack->getContext(), {}));\n             pgcstack->setCalledFunction(pgcstack->getFunctionType(), getter);\n             set_pgcstack_attrs(pgcstack);\n \n@@ -265,11 +265,11 @@ void LowerPTLS::fix_pgcstack_use(CallInst *pgcstack, Function *pgcstack_getter,\n         // since we may not know which getter function to use ahead of time.\n         auto getter = builder.CreateLoad(T_pgcstack_getter, pgcstack_func_slot);\n         getter->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);\n-        getter->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(pgcstack->getContext(), None));\n+        getter->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(pgcstack->getContext(), {}));\n         if (TargetTriple.isOSDarwin()) {\n             auto key = builder.CreateLoad(T_size, pgcstack_key_slot);\n             key->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);\n-            key->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(pgcstack->getContext(), None));\n+            key->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(pgcstack->getContext(), {}));\n             auto new_pgcstack = builder.CreateCall(FT_pgcstack_getter, getter, {key});\n             new_pgcstack->takeName(pgcstack);\n             pgcstack->replaceAllUsesWith(new_pgcstack);"
    }
  ]
}