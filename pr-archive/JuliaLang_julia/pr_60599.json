{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60599",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60599/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60599/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60599/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60599",
  "id": 3792724636,
  "node_id": "PR_kwDOABkWpM68HMHP",
  "number": 60599,
  "title": "avoid some more `Core.Box` in Base and SharedArrays",
  "user": {
    "login": "KristofferC",
    "id": 1282691,
    "node_id": "MDQ6VXNlcjEyODI2OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1282691?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KristofferC",
    "html_url": "https://github.com/KristofferC",
    "followers_url": "https://api.github.com/users/KristofferC/followers",
    "following_url": "https://api.github.com/users/KristofferC/following{/other_user}",
    "gists_url": "https://api.github.com/users/KristofferC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KristofferC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KristofferC/subscriptions",
    "organizations_url": "https://api.github.com/users/KristofferC/orgs",
    "repos_url": "https://api.github.com/users/KristofferC/repos",
    "events_url": "https://api.github.com/users/KristofferC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KristofferC/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9546926682,
      "node_id": "LA_kwDOABkWpM8AAAACOQqKWg",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/backport%201.13",
      "name": "backport 1.13",
      "color": "699295",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 1,
  "created_at": "2026-01-08T12:38:57Z",
  "updated_at": "2026-01-09T13:35:28Z",
  "closed_at": "2026-01-09T13:35:26Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60599",
    "html_url": "https://github.com/JuliaLang/julia/pull/60599",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60599.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60599.patch",
    "merged_at": "2026-01-09T13:35:26Z"
  },
  "body": null,
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60599/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60599/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "8c3edb09f3fd0eb0ca485a43e9dc0df0f1a05f94",
      "filename": "Compiler/src/abstractinterpretation.jl",
      "status": "modified",
      "additions": 119,
      "deletions": 118,
      "changes": 237,
      "blob_url": "https://github.com/JuliaLang/julia/blob/93c80ff7ec0d283f05e0e4c3989bb87369ec03ae/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/93c80ff7ec0d283f05e0e4c3989bb87369ec03ae/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fabstractinterpretation.jl?ref=93c80ff7ec0d283f05e0e4c3989bb87369ec03ae",
      "patch": "@@ -1577,133 +1577,134 @@ function abstract_iteration(interp::AbstractInterpreter, @nospecialize(itft), @n\n         return Future(AbstractIterationResult(Any[Vararg{Any}], nothing, Effects()))\n     end\n     @assert !isvarargtype(itertype)\n-\n-    iterateresult = Future{AbstractIterationResult}()\n-    call1future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[itft, itertype]), StmtInfo(true, false), vtypes, sv)::Future\n-    function inferiterate(interp, sv)\n-        call1 = call1future[]\n-        stateordonet = call1.rt\n-        # Return Bottom if this is not an iterator.\n-        # WARNING: Changes to the iteration protocol must be reflected here,\n-        # this is not just an optimization.\n-        # TODO: this doesn't realize that Array, GenericMemory, SimpleVector, Tuple, and NamedTuple do not use the iterate protocol\n-        if stateordonet === Bottom\n-            iterateresult[] = AbstractIterationResult(Any[Bottom], AbstractIterationInfo(CallMeta[CallMeta(Bottom, Any, call1.effects, call1.info)], true))\n-            return true\n-        end\n-        stateordonet_widened = widenconst(stateordonet)\n-        calls = CallMeta[call1]\n-        valtype = statetype = Bottom\n-        ret = Any[]\n-        \ud835\udd43\u1d62 = typeinf_lattice(interp)\n-        may_have_terminated = false\n-        local call2future::Future{CallMeta}\n-\n-        nextstate::UInt8 = 0x0\n-        function inferiterate_2arg(interp, sv)\n-            if nextstate === 0x1\n-                nextstate = 0xff\n-                @goto state1\n-            elseif nextstate === 0x2\n-                nextstate = 0xff\n-                @goto state2\n-            else\n-                @assert nextstate === 0x0\n-                nextstate = 0xff\n-            end\n-\n-            # Try to unroll the iteration up to max_tuple_splat, which covers any finite\n-            # length iterators, or interesting prefix\n-            while true\n-                if stateordonet_widened === Nothing\n-                    iterateresult[] = AbstractIterationResult(ret, AbstractIterationInfo(calls, true))\n-                    return true\n-                end\n-                if Nothing <: stateordonet_widened || length(ret) >= InferenceParams(interp).max_tuple_splat\n-                    break\n-                end\n-                if !isa(stateordonet_widened, DataType) || !(stateordonet_widened <: Tuple) || isvatuple(stateordonet_widened) || length(stateordonet_widened.parameters) != 2\n-                    break\n-                end\n-                nstatetype = getfield_tfunc(\ud835\udd43\u1d62, stateordonet, Const(2))\n-                # If there's no new information in this statetype, don't bother continuing,\n-                # the iterator won't be finite.\n-                if \u2291(\ud835\udd43\u1d62, nstatetype, statetype)\n-                    iterateresult[] = AbstractIterationResult(Any[Bottom], AbstractIterationInfo(calls, false), EFFECTS_THROWS)\n-                    return true\n-                end\n-                valtype = getfield_tfunc(\ud835\udd43\u1d62, stateordonet, Const(1))\n-                push!(ret, valtype)\n-                statetype = nstatetype\n-                call2future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[Const(iteratef), itertype, statetype]), StmtInfo(true, false), vtypes, sv)::Future\n-                if !isready(call2future)\n-                    nextstate = 0x1\n-                    return false\n-                    @label state1\n-                end\n-                let call = call2future[]\n-                    push!(calls, call)\n-                    stateordonet = call.rt\n-                    stateordonet_widened = widenconst(stateordonet)\n-                end\n+    let iteratef = iteratef\n+        iterateresult = Future{AbstractIterationResult}()\n+        call1future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[itft, itertype]), StmtInfo(true, false), vtypes, sv)::Future\n+        function inferiterate(interp, sv)\n+            call1 = call1future[]\n+            stateordonet = call1.rt\n+            # Return Bottom if this is not an iterator.\n+            # WARNING: Changes to the iteration protocol must be reflected here,\n+            # this is not just an optimization.\n+            # TODO: this doesn't realize that Array, GenericMemory, SimpleVector, Tuple, and NamedTuple do not use the iterate protocol\n+            if stateordonet === Bottom\n+                iterateresult[] = AbstractIterationResult(Any[Bottom], AbstractIterationInfo(CallMeta[CallMeta(Bottom, Any, call1.effects, call1.info)], true))\n+                return true\n             end\n-            # From here on, we start asking for results on the widened types, rather than\n-            # the precise (potentially const) state type\n-            # statetype and valtype are reinitialized in the first iteration below from the\n-            # (widened) stateordonet, which has not yet been fully analyzed in the loop above\n+            stateordonet_widened = widenconst(stateordonet)\n+            calls = CallMeta[call1]\n             valtype = statetype = Bottom\n-            may_have_terminated = Nothing <: stateordonet_widened\n-            while valtype !== Any\n-                nounion = typeintersect(stateordonet_widened, Tuple{Any,Any})\n-                if nounion !== Union{} && !isa(nounion, DataType)\n-                    # nounion is of a type we cannot handle\n-                    valtype = Any\n-                    break\n+            ret = Any[]\n+            \ud835\udd43\u1d62 = typeinf_lattice(interp)\n+            may_have_terminated = false\n+            local call2future::Future{CallMeta}\n+\n+            nextstate::UInt8 = 0x0\n+            function inferiterate_2arg(interp, sv)\n+                if nextstate === 0x1\n+                    nextstate = 0xff\n+                    @goto state1\n+                elseif nextstate === 0x2\n+                    nextstate = 0xff\n+                    @goto state2\n+                else\n+                    @assert nextstate === 0x0\n+                    nextstate = 0xff\n                 end\n-                if nounion === Union{} || (nounion.parameters[1] <: valtype && nounion.parameters[2] <: statetype)\n-                    # reached a fixpoint or iterator failed/gave invalid answer\n-                    if !hasintersect(stateordonet_widened, Nothing)\n-                        # ... but cannot terminate\n-                        if may_have_terminated\n-                            # ... and iterator may have terminated prior to this loop, but not during it\n-                            valtype = Bottom\n-                        else\n-                            #  ... or cannot have terminated prior to this loop\n-                            iterateresult[] = AbstractIterationResult(Any[Bottom], AbstractIterationInfo(calls, false), Effects())\n-                            return true\n-                        end\n+\n+                # Try to unroll the iteration up to max_tuple_splat, which covers any finite\n+                # length iterators, or interesting prefix\n+                while true\n+                    if stateordonet_widened === Nothing\n+                        iterateresult[] = AbstractIterationResult(ret, AbstractIterationInfo(calls, true))\n+                        return true\n+                    end\n+                    if Nothing <: stateordonet_widened || length(ret) >= InferenceParams(interp).max_tuple_splat\n+                        break\n+                    end\n+                    if !isa(stateordonet_widened, DataType) || !(stateordonet_widened <: Tuple) || isvatuple(stateordonet_widened) || length(stateordonet_widened.parameters) != 2\n+                        break\n+                    end\n+                    nstatetype = getfield_tfunc(\ud835\udd43\u1d62, stateordonet, Const(2))\n+                    # If there's no new information in this statetype, don't bother continuing,\n+                    # the iterator won't be finite.\n+                    if \u2291(\ud835\udd43\u1d62, nstatetype, statetype)\n+                        iterateresult[] = AbstractIterationResult(Any[Bottom], AbstractIterationInfo(calls, false), EFFECTS_THROWS)\n+                        return true\n+                    end\n+                    valtype = getfield_tfunc(\ud835\udd43\u1d62, stateordonet, Const(1))\n+                    push!(ret, valtype)\n+                    statetype = nstatetype\n+                    call2future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[Const(iteratef), itertype, statetype]), StmtInfo(true, false), vtypes, sv)::Future\n+                    if !isready(call2future)\n+                        nextstate = 0x1\n+                        return false\n+                        @label state1\n+                    end\n+                    let call = call2future[]\n+                        push!(calls, call)\n+                        stateordonet = call.rt\n+                        stateordonet_widened = widenconst(stateordonet)\n                     end\n-                    break\n                 end\n-                valtype = tmerge(valtype, nounion.parameters[1])\n-                statetype = tmerge(statetype, nounion.parameters[2])\n-                call2future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[Const(iteratef), itertype, statetype]), StmtInfo(true, false), vtypes, sv)::Future\n-                if !isready(call2future)\n-                    nextstate = 0x2\n-                    return false\n-                    @label state2\n+                # From here on, we start asking for results on the widened types, rather than\n+                # the precise (potentially const) state type\n+                # statetype and valtype are reinitialized in the first iteration below from the\n+                # (widened) stateordonet, which has not yet been fully analyzed in the loop above\n+                valtype = statetype = Bottom\n+                may_have_terminated = Nothing <: stateordonet_widened\n+                while valtype !== Any\n+                    nounion = typeintersect(stateordonet_widened, Tuple{Any,Any})\n+                    if nounion !== Union{} && !isa(nounion, DataType)\n+                        # nounion is of a type we cannot handle\n+                        valtype = Any\n+                        break\n+                    end\n+                    if nounion === Union{} || (nounion.parameters[1] <: valtype && nounion.parameters[2] <: statetype)\n+                        # reached a fixpoint or iterator failed/gave invalid answer\n+                        if !hasintersect(stateordonet_widened, Nothing)\n+                            # ... but cannot terminate\n+                            if may_have_terminated\n+                                # ... and iterator may have terminated prior to this loop, but not during it\n+                                valtype = Bottom\n+                            else\n+                                #  ... or cannot have terminated prior to this loop\n+                                iterateresult[] = AbstractIterationResult(Any[Bottom], AbstractIterationInfo(calls, false), Effects())\n+                                return true\n+                            end\n+                        end\n+                        break\n+                    end\n+                    valtype = tmerge(valtype, nounion.parameters[1])\n+                    statetype = tmerge(statetype, nounion.parameters[2])\n+                    call2future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[Const(iteratef), itertype, statetype]), StmtInfo(true, false), vtypes, sv)::Future\n+                    if !isready(call2future)\n+                        nextstate = 0x2\n+                        return false\n+                        @label state2\n+                    end\n+                    let call = call2future[]\n+                        push!(calls, call)\n+                        stateordonet = call.rt\n+                        stateordonet_widened = widenconst(stateordonet)\n+                    end\n                 end\n-                let call = call2future[]\n-                    push!(calls, call)\n-                    stateordonet = call.rt\n-                    stateordonet_widened = widenconst(stateordonet)\n+                if valtype !== Union{}\n+                    push!(ret, Vararg{valtype})\n                 end\n-            end\n-            if valtype !== Union{}\n-                push!(ret, Vararg{valtype})\n-            end\n-            iterateresult[] = AbstractIterationResult(ret, AbstractIterationInfo(calls, false))\n+                iterateresult[] = AbstractIterationResult(ret, AbstractIterationInfo(calls, false))\n+                return true\n+            end # function inferiterate_2arg\n+            # continue making progress as much as possible, on iterate(arg, state)\n+            inferiterate_2arg(interp, sv) || push!(sv.tasks, inferiterate_2arg)\n             return true\n-        end # function inferiterate_2arg\n-        # continue making progress as much as possible, on iterate(arg, state)\n-        inferiterate_2arg(interp, sv) || push!(sv.tasks, inferiterate_2arg)\n-        return true\n-    end # inferiterate\n-    # continue making progress as soon as possible, on iterate(arg)\n-    if !(isready(call1future) && inferiterate(interp, sv))\n-        push!(sv.tasks, inferiterate)\n+        end # inferiterate\n+        # continue making progress as soon as possible, on iterate(arg)\n+        if !(isready(call1future) && inferiterate(interp, sv))\n+            push!(sv.tasks, inferiterate)\n+        end\n+        return iterateresult\n     end\n-    return iterateresult\n end\n \n # do apply(af, fargs...), where af is a function value"
    },
    {
      "sha": "6313e4aaaa2cfa66f0cf3e86a71db8e7fab0b251",
      "filename": "base/loading.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/93c80ff7ec0d283f05e0e4c3989bb87369ec03ae/base%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/93c80ff7ec0d283f05e0e4c3989bb87369ec03ae/base%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Floading.jl?ref=93c80ff7ec0d283f05e0e4c3989bb87369ec03ae",
      "patch": "@@ -2889,7 +2889,7 @@ function __require_prelocked(pkg::PkgId, env)\n     if JLOptions().use_compiled_modules == 1\n         if !generating_output(#=incremental=#false)\n             # spawn off a new incremental pre-compile task for recursive `require` calls\n-            loaded = let spec = spec, reasons = reasons\n+            loaded = let spec = spec, reasons = reasons, parallel_precompile_attempted = parallel_precompile_attempted\n                 maybe_cachefile_lock(pkg, spec.path) do\n                     # double-check the search now that we have lock\n                     m = _require_search_from_serialized(pkg, spec, UInt128(0), true)"
    },
    {
      "sha": "1ade7a7941de2a60e31287cee961c7bc292dada7",
      "filename": "base/timing.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/JuliaLang/julia/blob/93c80ff7ec0d283f05e0e4c3989bb87369ec03ae/base%2Ftiming.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/93c80ff7ec0d283f05e0e4c3989bb87369ec03ae/base%2Ftiming.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Ftiming.jl?ref=93c80ff7ec0d283f05e0e4c3989bb87369ec03ae",
      "patch": "@@ -261,30 +261,31 @@ function time_print(io::IO, elapsedtime, bytes=0, gctime=0, allocs=0, lock_confl\n         print(io, timestr, \" seconds\")\n         parens = bytes != 0 || allocs != 0 || gctime > 0 || lock_conflicts > 0 || compile_time > 0\n         parens && print(io, \" (\")\n-        if bytes != 0 || allocs != 0\n-            allocs, ma = prettyprint_getunits(allocs, length(_cnt_units), Int64(1000))\n+        had_allocs = bytes != 0 || allocs != 0\n+        if had_allocs\n+            allocs_scaled, ma = prettyprint_getunits(allocs, length(_cnt_units), Int64(1000))\n             if ma == 1\n-                print(io, Int(allocs), _cnt_units[ma], allocs==1 ? \" allocation: \" : \" allocations: \")\n+                print(io, Int(allocs_scaled), _cnt_units[ma], allocs_scaled==1 ? \" allocation: \" : \" allocations: \")\n             else\n-                print(io, Ryu.writefixed(Float64(allocs), 2), _cnt_units[ma], \" allocations: \")\n+                print(io, Ryu.writefixed(Float64(allocs_scaled), 2), _cnt_units[ma], \" allocations: \")\n             end\n             print(io, format_bytes(bytes))\n         end\n         if gctime > 0\n-            if bytes != 0 || allocs != 0\n+            if had_allocs\n                 print(io, \", \")\n             end\n             print(io, Ryu.writefixed(Float64(100*gctime/elapsedtime), 2), \"% gc time\")\n         end\n         if lock_conflicts > 0\n-            if bytes != 0 || allocs != 0 || gctime > 0\n+            if had_allocs || gctime > 0\n                 print(io, \", \")\n             end\n             plural = lock_conflicts == 1 ? \"\" : \"s\"\n             print(io, lock_conflicts, \" lock conflict$plural\")\n         end\n         if compile_time > 0\n-            if bytes != 0 || allocs != 0 || gctime > 0 || lock_conflicts > 0\n+            if had_allocs || gctime > 0 || lock_conflicts > 0\n                 print(io, \", \")\n             end\n             print(io, Ryu.writefixed(Float64(100*compile_time/elapsedtime), 2), \"% compilation time\")"
    },
    {
      "sha": "fca7e7ced90272d9a080e5ed39fc0fc05f93eae7",
      "filename": "base/views.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/93c80ff7ec0d283f05e0e4c3989bb87369ec03ae/base%2Fviews.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/93c80ff7ec0d283f05e0e4c3989bb87369ec03ae/base%2Fviews.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fviews.jl?ref=93c80ff7ec0d283f05e0e4c3989bb87369ec03ae",
      "patch": "@@ -58,8 +58,8 @@ function replace_ref_begin_end_!(__module__::Module, ex, withex, in_quote_contex\n             temp_vars = Tuple{Int,Symbol}[]\n             for j = 2:J\n                 n = nx === 0 ? ni : :($nx + $ni)\n-                exj, used = replace_ref_begin_end_!(__module__, ref_ex.args[j], (:($firstindex($S,$n)),:($lastindex($S,$n))), in_quote_context, escs)\n-                used_S |= used\n+                exj, used_arg = replace_ref_begin_end_!(__module__, ref_ex.args[j], (:($firstindex($S,$n)),:($lastindex($S,$n))), in_quote_context, escs)\n+                used_S |= used_arg\n                 ref_ex.args[j] = exj\n                 ni += 1\n                 if need_temps"
    },
    {
      "sha": "fdbfc989c8994da040cd316204b0abbffd2245b8",
      "filename": "stdlib/SharedArrays/src/SharedArrays.jl",
      "status": "modified",
      "additions": 19,
      "deletions": 20,
      "changes": 39,
      "blob_url": "https://github.com/JuliaLang/julia/blob/93c80ff7ec0d283f05e0e4c3989bb87369ec03ae/stdlib%2FSharedArrays%2Fsrc%2FSharedArrays.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/93c80ff7ec0d283f05e0e4c3989bb87369ec03ae/stdlib%2FSharedArrays%2Fsrc%2FSharedArrays.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FSharedArrays%2Fsrc%2FSharedArrays.jl?ref=93c80ff7ec0d283f05e0e4c3989bb87369ec03ae",
      "patch": "@@ -113,20 +113,21 @@ function SharedArray{T,N}(dims::Dims{N}; init=false, pids=Int[]) where {T,N}\n     local shmmem_create_pid\n     try\n         # On OSX, the shm_seg_name length must be <= 31 characters (including the terminating NULL character)\n-        shm_seg_name = \"/jl$(lpad(string(getpid() % 10^6), 6, \"0\"))$(randstring(20))\"\n+        seg_name = \"/jl$(lpad(string(getpid() % 10^6), 6, \"0\"))$(randstring(20))\"\n+        shm_seg_name = seg_name\n         if onlocalhost\n             shmmem_create_pid = myid()\n-            s = shm_mmap_array(T, dims, shm_seg_name, JL_O_CREAT | JL_O_RDWR)\n+            s = shm_mmap_array(T, dims, seg_name, JL_O_CREAT | JL_O_RDWR)\n         else\n             # The shared array is created on a remote machine\n             shmmem_create_pid = pids[1]\n             remotecall_fetch(pids[1]) do\n-                shm_mmap_array(T, dims, shm_seg_name, JL_O_CREAT | JL_O_RDWR)\n+                shm_mmap_array(T, dims, seg_name, JL_O_CREAT | JL_O_RDWR)\n                 nothing\n             end\n         end\n \n-        func_mapshmem = () -> shm_mmap_array(T, dims, shm_seg_name, JL_O_RDWR)\n+        func_mapshmem = () -> shm_mmap_array(T, dims, seg_name, JL_O_RDWR)\n \n         refs = Vector{Future}(undef, length(pids))\n         for (i, p) in enumerate(pids)\n@@ -141,13 +142,13 @@ function SharedArray{T,N}(dims::Dims{N}; init=false, pids=Int[]) where {T,N}\n         # All good, immediately unlink the segment.\n         if (prod(dims) > 0) && (sizeof(T) > 0)\n             if onlocalhost\n-                rc = shm_unlink(shm_seg_name)\n+                rc = shm_unlink(seg_name)\n             else\n-                rc = remotecall_fetch(shm_unlink, shmmem_create_pid, shm_seg_name)\n+                rc = remotecall_fetch(shm_unlink, shmmem_create_pid, seg_name)\n             end\n-            systemerror(\"Error unlinking shmem segment \" * shm_seg_name, rc != 0)\n+            systemerror(\"Error unlinking shmem segment \" * seg_name, rc != 0)\n         end\n-        S = SharedArray{T,N}(dims, pids, refs, shm_seg_name, s)\n+        S = SharedArray{T,N}(dims, pids, refs, seg_name, s)\n         initialize_shared_array(S, onlocalhost, init, pids)\n         shm_seg_name = \"\"\n \n@@ -185,23 +186,21 @@ function SharedArray{T,N}(filename::AbstractString, dims::NTuple{N,Int}, offset:\n \n     # If not supplied, determine the appropriate mode\n     have_file = onlocalhost ? isfile(filename) : remotecall_fetch(isfile, pids[1], filename)\n-    if mode === nothing\n-        mode = have_file ? \"r+\" : \"w+\"\n-    end\n-    workermode = mode == \"w+\" ? \"r+\" : mode  # workers don't truncate!\n+    mode_val = mode === nothing ? (have_file ? \"r+\" : \"w+\") : mode\n+    workermode = mode_val == \"w+\" ? \"r+\" : mode_val  # workers don't truncate!\n \n     # Ensure the file will be readable\n-    if !(mode in (\"r\", \"r+\", \"w+\", \"a+\"))\n-        throw(ArgumentError(\"mode must be readable, but $mode is not\"))\n+    if !(mode_val in (\"r\", \"r+\", \"w+\", \"a+\"))\n+        throw(ArgumentError(\"mode must be readable, but $mode_val is not\"))\n     end\n     if init !== false\n         typeassert(init, Function)\n-        if !(mode in (\"r+\", \"w+\", \"a+\"))\n-            throw(ArgumentError(\"cannot initialize unwritable array (mode = $mode)\"))\n+        if !(mode_val in (\"r+\", \"w+\", \"a+\"))\n+            throw(ArgumentError(\"cannot initialize unwritable array (mode = $mode_val)\"))\n         end\n     end\n-    if mode == \"r\" && !isfile(filename)\n-        throw(ArgumentError(\"file $filename does not exist, but mode $mode cannot create it\"))\n+    if mode_val == \"r\" && !isfile(filename)\n+        throw(ArgumentError(\"file $filename does not exist, but mode $mode_val cannot create it\"))\n     end\n \n     # Create the file if it doesn't exist, map it if it does\n@@ -211,13 +210,13 @@ function SharedArray{T,N}(filename::AbstractString, dims::NTuple{N,Int}, offset:\n     end\n     s = Array{T}(undef, ntuple(d->0,N))\n     if onlocalhost\n-        s = func_mmap(mode)\n+        s = func_mmap(mode_val)\n         refs[1] = remotecall(pids[1]) do\n             func_mmap(workermode)\n         end\n     else\n         refs[1] = remotecall_wait(pids[1]) do\n-            func_mmap(mode)\n+            func_mmap(mode_val)\n         end\n     end\n "
    }
  ]
}