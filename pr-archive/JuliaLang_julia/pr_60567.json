{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60567",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60567/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60567/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60567/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60567",
  "id": 3786147768,
  "node_id": "PR_kwDOABkWpM67xjQ3",
  "number": 60567,
  "title": "[JuliaLowering] Implement flisp-compatible Box optimization",
  "user": {
    "login": "aviatesk",
    "id": 40514306,
    "node_id": "MDQ6VXNlcjQwNTE0MzA2",
    "avatar_url": "https://avatars.githubusercontent.com/u/40514306?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/aviatesk",
    "html_url": "https://github.com/aviatesk",
    "followers_url": "https://api.github.com/users/aviatesk/followers",
    "following_url": "https://api.github.com/users/aviatesk/following{/other_user}",
    "gists_url": "https://api.github.com/users/aviatesk/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/aviatesk/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/aviatesk/subscriptions",
    "organizations_url": "https://api.github.com/users/aviatesk/orgs",
    "repos_url": "https://api.github.com/users/aviatesk/repos",
    "events_url": "https://api.github.com/users/aviatesk/events{/privacy}",
    "received_events_url": "https://api.github.com/users/aviatesk/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9763847389,
      "node_id": "LA_kwDOABkWpM8AAAACRfh83Q",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/JuliaLowering",
      "name": "JuliaLowering",
      "color": "144fbf",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 10,
  "created_at": "2026-01-06T18:44:10Z",
  "updated_at": "2026-01-12T14:47:49Z",
  "closed_at": "2026-01-10T01:21:52Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60567",
    "html_url": "https://github.com/JuliaLang/julia/pull/60567",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60567.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60567.patch",
    "merged_at": "2026-01-10T01:21:52Z"
  },
  "body": "### Motivation\r\n\r\nJETLS recently added a diagnostic for captured boxed variables (aviatesk/JETLS.jl#452). However, without proper Box optimization in JuliaLowering (the lowering backend for JETLS's analysis), there were too many false positives to be useful. This PR brings JuliaLowering's Box optimization roughly on par with flisp's `lambda-optimize-vars!` implementation.\r\n\r\n### Changes\r\n\r\nThis PR implements `_optimize_lambda_vars!` which identifies captured local variables that can avoid `Core.Box` allocation. The optimization uses flisp-compatible save/restore pattern from `lambda-optimize-vars!` (from julia-syntax.scm).\r\n\r\nSome implementation details:\r\n- Use flisp-compatible table structure: `unused`, `live`, `seen`, `decl`\r\n- Implement `kill!`/`restore!`/`leave_loop!` operations\r\n- Save/restore `live` set around control flow (if/try/loops)\r\n- Only invalidate candidates when symbolic labels are present\r\n\r\nNow JuliaLowering is able to optimize common closure patterns like:\r\n```julia\r\n# Assignment after if statements\r\nlet \r\n    if cond; do_something(); end\r\n    y = 1\r\n    () -> y  # No Box needed\r\nend\r\n\r\n# Ternary operators\r\nlet \r\n    y = x > 0 ? x : 0\r\n    () -> y  # No Box needed\r\nend\r\n\r\n# Guard patterns\r\nlet \r\n    (x === nothing || error()) && return\r\n    () -> x  # No Box needed\r\nend\r\n```\r\n\r\n### Future work\r\n\r\nThe current implementation is tree-based and only optimizes single-assigned variables, matching flisp's behavior. A more sophisticated approach might be to internally linearize each lambda body and perform proper domination analysis on the CFG. This would allow optimizing cases like:\r\n\r\n```julia\r\nlet\r\n    y = 0\r\n    if x > 0\r\n        y = x\r\n    end\r\n    () -> y  # Currently requires Box, but all assignments dominate closure creation\r\nend\r\n```\r\n\r\nThis linearization-based approach is left for future work.\r\n\r\n### Note\r\n\r\nRegarding the code in this PR, a significant portion of the implementation was done by Claude Code.\r\nWhile I had some careful discussions about the implementation approach and I believe we arrived at a reasonably sound strategy, there may be potential issues with code quality. From my understanding, I think it's a reasonable implementation, but please feel free to let me know if you notice any problems.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60567/reactions",
    "total_count": 4,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 2,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60567/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0
}