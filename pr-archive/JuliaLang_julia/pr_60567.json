{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60567",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60567/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60567/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60567/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60567",
  "id": 3786147768,
  "node_id": "PR_kwDOABkWpM67xjQ3",
  "number": 60567,
  "title": "[JuliaLowering] Implement flisp-compatible Box optimization",
  "user": {
    "login": "aviatesk",
    "id": 40514306,
    "node_id": "MDQ6VXNlcjQwNTE0MzA2",
    "avatar_url": "https://avatars.githubusercontent.com/u/40514306?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/aviatesk",
    "html_url": "https://github.com/aviatesk",
    "followers_url": "https://api.github.com/users/aviatesk/followers",
    "following_url": "https://api.github.com/users/aviatesk/following{/other_user}",
    "gists_url": "https://api.github.com/users/aviatesk/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/aviatesk/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/aviatesk/subscriptions",
    "organizations_url": "https://api.github.com/users/aviatesk/orgs",
    "repos_url": "https://api.github.com/users/aviatesk/repos",
    "events_url": "https://api.github.com/users/aviatesk/events{/privacy}",
    "received_events_url": "https://api.github.com/users/aviatesk/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9763847389,
      "node_id": "LA_kwDOABkWpM8AAAACRfh83Q",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/JuliaLowering",
      "name": "JuliaLowering",
      "color": "144fbf",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 10,
  "created_at": "2026-01-06T18:44:10Z",
  "updated_at": "2026-01-12T14:47:49Z",
  "closed_at": "2026-01-10T01:21:52Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60567",
    "html_url": "https://github.com/JuliaLang/julia/pull/60567",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60567.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60567.patch",
    "merged_at": "2026-01-10T01:21:52Z"
  },
  "body": "### Motivation\r\n\r\nJETLS recently added a diagnostic for captured boxed variables (aviatesk/JETLS.jl#452). However, without proper Box optimization in JuliaLowering (the lowering backend for JETLS's analysis), there were too many false positives to be useful. This PR brings JuliaLowering's Box optimization roughly on par with flisp's `lambda-optimize-vars!` implementation.\r\n\r\n### Changes\r\n\r\nThis PR implements `_optimize_lambda_vars!` which identifies captured local variables that can avoid `Core.Box` allocation. The optimization uses flisp-compatible save/restore pattern from `lambda-optimize-vars!` (from julia-syntax.scm).\r\n\r\nSome implementation details:\r\n- Use flisp-compatible table structure: `unused`, `live`, `seen`, `decl`\r\n- Implement `kill!`/`restore!`/`leave_loop!` operations\r\n- Save/restore `live` set around control flow (if/try/loops)\r\n- Only invalidate candidates when symbolic labels are present\r\n\r\nNow JuliaLowering is able to optimize common closure patterns like:\r\n```julia\r\n# Assignment after if statements\r\nlet \r\n    if cond; do_something(); end\r\n    y = 1\r\n    () -> y  # No Box needed\r\nend\r\n\r\n# Ternary operators\r\nlet \r\n    y = x > 0 ? x : 0\r\n    () -> y  # No Box needed\r\nend\r\n\r\n# Guard patterns\r\nlet \r\n    (x === nothing || error()) && return\r\n    () -> x  # No Box needed\r\nend\r\n```\r\n\r\n### Future work\r\n\r\nThe current implementation is tree-based and only optimizes single-assigned variables, matching flisp's behavior. A more sophisticated approach might be to internally linearize each lambda body and perform proper domination analysis on the CFG. This would allow optimizing cases like:\r\n\r\n```julia\r\nlet\r\n    y = 0\r\n    if x > 0\r\n        y = x\r\n    end\r\n    () -> y  # Currently requires Box, but all assignments dominate closure creation\r\nend\r\n```\r\n\r\nThis linearization-based approach is left for future work.\r\n\r\n### Note\r\n\r\nRegarding the code in this PR, a significant portion of the implementation was done by Claude Code.\r\nWhile I had some careful discussions about the implementation approach and I believe we arrived at a reasonably sound strategy, there may be potential issues with code quality. From my understanding, I think it's a reasonable implementation, but please feel free to let me know if you notice any problems.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60567/reactions",
    "total_count": 4,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 2,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60567/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "e5e004ceef281dc60cd4a6f04286cc8dc14e4e3a",
      "filename": "JuliaLowering/src/JuliaLowering.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Fsrc%2FJuliaLowering.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Fsrc%2FJuliaLowering.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2FJuliaLowering.jl?ref=fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc",
      "patch": "@@ -33,6 +33,7 @@ _include(\"utils.jl\")\n _include(\"macro_expansion.jl\")\n _include(\"desugaring.jl\")\n _include(\"scope_analysis.jl\")\n+_include(\"binding_analysis.jl\")\n _include(\"closure_conversion.jl\")\n _include(\"linear_ir.jl\")\n _include(\"runtime.jl\")"
    },
    {
      "sha": "ff687bb6cfc36917a5e92b2d8a71981499561720",
      "filename": "JuliaLowering/src/binding_analysis.jl",
      "status": "added",
      "additions": 340,
      "deletions": 0,
      "changes": 340,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Fsrc%2Fbinding_analysis.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Fsrc%2Fbinding_analysis.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fbinding_analysis.jl?ref=fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc",
      "patch": "@@ -0,0 +1,340 @@\n+#-------------------------------------------------------------------------------\n+# Syntactic-block-local dominance analysis to optimize Box allocations.\n+# Nearly identical (by design) to flisp's `lambda-optimize-vars!` in julia-syntax.scm.\n+#\n+# This pass attempts to prove\n+# (for the special case of assigned-once variables):\n+#   1. A variable is always defined at every use / capture\n+#   2. A variable will not be modified anywhere after any capture\n+#\n+# Within inner syntactic blocks, an outer assignment effectively \"guards\" the\n+# variable so that uses / captures do not taint the \"always-defined\" status.\n+#\n+# This \"guard\" behavior is disabled when a variable was introduced outside of\n+# an enclosing loop, since that would allow condition (2) to be violated. In\n+# contrast, straight-line captures (i.e. an assignment followed by a capture\n+# in the same block) is allowed even in loops, since it's unconditional.\n+#\n+# In the implementation, any variables in `unused` / `live` are considered\n+# \"always-defined- when-used-or-captured-and-only-modified-once-dynamically\".\n+# These variables may temporarily lose their status when considering uses /\n+# captures in inner blocks, but this is restored later if dominated by an\n+# outer assignment.\n+#\n+# XXX: This pass under-approximates the \"is_always_defined\" flag to mean something\n+#      closer to \"is_always_defined_and_not_modified_after_any_capture\" (which is\n+#      the real condition needed to apply unboxing safely)\n+\n+\"\"\"\n+    analyze_def_and_use!(ctx, ex)\n+\n+Perform tree-based def-use analysis to find captured variables that are\n+assigned before any closure captures them (never-undef) and not modified\n+afterward. For such variables, as an abuse of binding flags we can mark them\n+as `is_always_defined=true` to avoid unnecessary `Core.Box` allocations during\n+closure conversion.\n+\n+This is called on the outermost lambda, and recursively processes nested lambdas.\n+\"\"\"\n+function analyze_def_and_use!(ctx, ex)\n+    k = kind(ex)\n+    if k != K\"lambda\"\n+        return\n+    end\n+\n+    # First, recursively analyze nested lambdas (depth-first)\n+    if numchildren(ex) >= 3\n+        _analyze_nested_lambdas!(ctx, ex[3])\n+    end\n+\n+    # Now analyze this lambda\n+    _analyze_lambda_vars!(ctx, ex)\n+end\n+\n+function _analyze_nested_lambdas!(ctx, ex)\n+    k = kind(ex)\n+    if k == K\"lambda\"\n+        analyze_def_and_use!(ctx, ex)\n+    elseif !is_leaf(ex) && !is_quoted(ex)\n+        for child in children(ex)\n+            _analyze_nested_lambdas!(ctx, child)\n+        end\n+    end\n+end\n+\n+function _analyze_lambda_vars!(ctx, ex)\n+    lambda_bindings = ex.lambda_bindings\n+\n+    # Collect candidate variables: captured and single-assigned\n+    # We check binfo.is_captured instead of lbinfo (is_capt) because for variables\n+    # defined in this lambda and captured by inner lambdas, lbinfo may be false\n+    # but binfo.is_captured will be true.\n+    candidates = Set{IdTag}()\n+    for (id, _) in lambda_bindings.locals_capt\n+        binfo = get_binding(ctx, id)\n+        if (binfo.is_captured && binfo.is_assigned_once &&\n+            (binfo.kind == :local || binfo.kind == :argument))\n+            push!(candidates, id)\n+            # For arguments, reset is_always_defined so we can determine if the\n+            # outer-scope assignment dominates the capture. Arguments start with\n+            # is_always_defined=true, but if they're reassigned inside a closure\n+            # (not in outer scope), we need the def-use analysis to decide.\n+            if binfo.kind == :argument\n+                binfo.is_always_defined = false\n+            end\n+        end\n+    end\n+    isempty(candidates) && return\n+\n+    # flisp-compatible tables for tracking variable def and use:\n+    # - unused: candidate variables not yet used (read) in current block\n+    # - live: variables that have been assigned in current block\n+    # - seen: all variables we've seen assigned\n+    # - decl: variables scoped in current scope (via `local` or an argument)\n+    # - decl_outside_loop: variables scoped in scope outside loop (via `local` or an argument)\n+    # - args: argument variables (never undefined, special handling in mark_used!)\n+    unused = candidates\n+    live = Set{IdTag}()\n+    seen = Set{IdTag}()\n+    decl = Set{IdTag}()\n+    decl_outside_loop = Set{IdTag}()\n+    args = Set{IdTag}()\n+    # Initialize decl and args with arguments since they're implicitly declared outside any loop\n+    for id in candidates\n+        binfo = get_binding(ctx, id)\n+        if binfo.kind == :argument\n+            push!(decl, id)\n+            push!(args, id)\n+        end\n+    end\n+\n+    # At CFG merge points, we lose certainty about which path was taken,\n+    # so variables assigned in one branch may not have been assigned.\n+    # Move live variables back to unused to require re-assignment.\n+    # NOTE: This is NOT needed at branch points (return/break/goto) because\n+    # code after them is unreachable - only at merge points (if/while/label).\n+    function kill!()\n+        union!(unused, live)\n+        empty!(live)\n+    end\n+\n+    # Restore live to a previous state, moving new additions back to unused\n+    function restore!(prev)\n+        for id in decl_outside_loop\n+            if (id in prev) && !(id in unused)\n+                # This variable was 'used' inside this branch, but it's declared\n+                # outside of a loop so it may see the dominating assignment execute\n+                # multiple times. Invalidate it here for soundness.\n+                delete!(prev, id)\n+            end\n+        end\n+        for id in live\n+            if !(id in prev)\n+                push!(unused, id)\n+            end\n+        end\n+        empty!(live)\n+        union!(live, prev)\n+    end\n+\n+    # At the beginning of a loop, move all active decls into the \"decl_outside_loop\" set.\n+    function enter_loop!()\n+        prev_decl_outside_loop = decl_outside_loop\n+        decl_outside_loop = decl\n+        decl = copy(decl)\n+        return prev_decl_outside_loop\n+    end\n+\n+    # At the end of a loop, restore the previous set of \"declared\" variables.\n+    function leave_loop!(prev_decl_outside_loop)\n+        decl = decl_outside_loop\n+        decl_outside_loop = prev_decl_outside_loop\n+    end\n+\n+    # When a variable is used (read), remove from unused.\n+    # Note: arguments are only \"used\" for purposes of this analysis when\n+    # they are captured, since they are never undefined.\n+    function mark_used!(var_id)\n+        if var_id in unused && !(var_id in args)\n+            delete!(unused, var_id)\n+        end\n+    end\n+\n+    # When a variable is captured by a nested lambda before being assigned\n+    function mark_captured!(var_id)\n+        if var_id in unused\n+            delete!(unused, var_id)\n+        end\n+    end\n+\n+    # When a variable is assigned, move from unused to live\n+    function assign!(var_id)\n+        if var_id in unused\n+            push!(live, var_id)\n+            push!(seen, var_id)\n+            delete!(unused, var_id)\n+        end\n+    end\n+\n+    # Track local declarations for loop handling\n+    function declare!(var_id)\n+        if var_id in unused\n+            push!(decl, var_id)\n+        end\n+    end\n+\n+    # Returns whether e contained a symbolic_label\n+    function visit(e)\n+        k = kind(e)\n+\n+        if k == K\"BindingId\"\n+            mark_used!(e.var_id)\n+            return false\n+\n+        elseif k == K\"symbolic_label\"\n+            # Must check BEFORE is_leaf since symbolic_label is a leaf node\n+            kill!()\n+            return true\n+\n+        elseif k == K\"label\"\n+            kill!()\n+            return false\n+\n+        elseif k in KSet\"break symbolic_goto\"\n+            # this kill!() is not required for soundness since these are branch points\n+            # not merge points, but it's here for parity with flisp\n+            kill!()\n+            return false\n+\n+        elseif k == K\"=\"\n+            # Visit RHS first, then record assignment\n+            has_label = visit(e[2])\n+            lhs = e[1]\n+            if kind(lhs) == K\"BindingId\"\n+                assign!(lhs.var_id)\n+            end\n+            return has_label\n+\n+        elseif k == K\"lambda\"\n+            # Check captures from nested lambda\n+            nested_lb = e.lambda_bindings\n+            for (id, is_capt) in nested_lb.locals_capt\n+                if is_capt\n+                    mark_captured!(id)\n+                end\n+            end\n+            # Don't recurse into nested lambdas - they have their own analysis\n+            return false\n+\n+        elseif k == K\"local\"\n+            # Track local declarations for loop handling\n+            # Note: For typed locals like `local x::T`, the K\"local\" node only\n+            # contains the BindingId after desugaring. The type info is in\n+            # a separate K\"decl\" node. So we only need to handle K\"BindingId\" here.\n+            for child in children(e)\n+                if kind(child) == K\"BindingId\"\n+                    declare!(child.var_id)\n+                end\n+            end\n+            return false\n+\n+        elseif k == K\"decl\"\n+            # Don't recurse into decl nodes - the BindingId is just a declaration,\n+            # not a use. We only need to visit the type expression.\n+            if numchildren(e) >= 2\n+                return visit(e[2])\n+            end\n+            return false\n+\n+        elseif k == K\"method_defs\" || k == K\"function_decl\"\n+            # Process nested lambdas within\n+            has_label = false\n+            for child in children(e)\n+                has_label |= visit(child)\n+            end\n+            return has_label\n+\n+        elseif k == K\"return\"\n+            has_label = numchildren(e) >= 1 ? visit(e[1]) : false\n+            kill!() # not necessary, but included for flisp parity\n+            return has_label\n+\n+        elseif k in KSet\"if elseif trycatchelse tryfinally\"\n+            prev = copy(live)\n+            has_label = false\n+            for child in children(e)\n+                has_label |= visit(child)\n+                kill!()\n+            end\n+            if has_label\n+                # If there's a label inside, we could have skipped a prior\n+                # variable initialization\n+                return true\n+            else\n+                restore!(prev)\n+                return false\n+            end\n+\n+        elseif k in KSet\"_while _do_while\"\n+            prev = copy(live)\n+            old_decl = enter_loop!()\n+            has_label = false\n+            for child in children(e)\n+                has_label |= visit(child)\n+            end\n+            leave_loop!(old_decl)\n+            if has_label\n+                kill!()\n+                return true\n+            else\n+                restore!(prev)\n+                return false\n+            end\n+\n+        elseif k == K\"break_block\"\n+            # Skip the first child (break target label) - it's not a @goto target\n+            # No save/restore needed: the body always executes (break just exits early)\n+            has_label = false\n+            for child in children(e)[2:end]\n+                has_label |= visit(child)\n+            end\n+            return has_label\n+\n+        elseif is_leaf(e) || is_quoted(e) ||\n+            k in KSet\"local meta inbounds boundscheck noinline loopinfo decl\n+                with_static_parameters toplevel_butfirst global globalref\n+                extension constdecl atomic isdefined toplevel module error\n+                gc_preserve_begin gc_preserve_end export public inline\"\n+\n+            # Forms that don't interact with locals or affect control flow (likely more than is necessary).\n+            # flisp: `lambda-opt-ignored-exprs`\n+            return false\n+\n+        else\n+            has_label = false\n+            for child in children(e)\n+                has_label |= visit(child)\n+            end\n+            return has_label\n+        end\n+    end\n+\n+    # Visit the lambda body\n+    if numchildren(ex) >= 3\n+        body = ex[3]\n+        if kind(body) == K\"block\"\n+            for stmt in children(body)\n+                visit(stmt)\n+            end\n+        else\n+            visit(body)\n+        end\n+    end\n+\n+    # Variables in live or unused (that were seen assigned) are never-undef\n+    for id in union(live, unused)\n+        if id in seen\n+            get_binding(ctx, id).is_always_defined = true\n+        end\n+    end\n+end"
    },
    {
      "sha": "c9951a7b240b50286d8f91579187784b9ca38ad8",
      "filename": "JuliaLowering/src/closure_conversion.jl",
      "status": "modified",
      "additions": 10,
      "deletions": 5,
      "changes": 15,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Fsrc%2Fclosure_conversion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Fsrc%2Fclosure_conversion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fclosure_conversion.jl?ref=fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc",
      "patch": "@@ -302,13 +302,18 @@ function type_for_closure(ctx::ClosureConversionCtx, srcref, name_str, field_sym\n end\n \n function is_boxed(binfo::BindingInfo)\n-    # True for\n+    # No box needed for:\n     # * :argument when it's not reassigned\n     # * :static_parameter (these can't be reassigned)\n     defined_but_not_assigned = binfo.is_always_defined && !binfo.is_assigned\n-    # For now, we box almost everything but later we'll want to do dominance\n-    # analysis on the untyped IR.\n-    return binfo.is_captured && !defined_but_not_assigned\n+    # * Single-assigned variables (local or argument) assigned before any closure captures them\n+    #   (identified by liveness analysis in optimize_captured_vars!)\n+    #   For arguments, the liveness analysis resets is_always_defined and only sets it back\n+    #   if the outer-scope assignment dominates all captures. This distinguishes arguments\n+    #   reassigned in outer scope (no box) from those reassigned only inside closures (needs box).\n+    single_assigned_never_undef = binfo.kind in (:local, :argument) &&\n+                                  binfo.is_always_defined && binfo.is_assigned_once\n+    return binfo.is_captured && !defined_but_not_assigned && !single_assigned_never_undef\n end\n \n function is_boxed(ctx, x)\n@@ -404,7 +409,7 @@ function _convert_closures(ctx::ClosureConversionCtx, ex)\n     elseif k == K\"local\"\n         var = ex[1]\n         binfo = get_binding(ctx, var)\n-        if binfo.is_captured\n+        if is_boxed(binfo)\n             @ast ctx ex [K\"=\" var [K\"call\" \"Box\"::K\"core\"]]\n         elseif !binfo.is_always_defined\n             @ast ctx ex [K\"newvar\" var]"
    },
    {
      "sha": "b0eb35b4531cb73e4ca62506c6b2ae08014e54cc",
      "filename": "JuliaLowering/src/scope_analysis.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Fsrc%2Fscope_analysis.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Fsrc%2Fscope_analysis.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fscope_analysis.jl?ref=fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc",
      "patch": "@@ -714,5 +714,6 @@ enclosing lambda form and information about variables captured by closures.\n     ctx3 = VariableAnalysisContext(\n         ctx2.graph, ctx2.bindings, ctx2.mod, ctx2.scopes, ex2.lambda_bindings)\n     analyze_variables!(ctx3, ex2)\n+    analyze_def_and_use!(ctx3, ex2)\n     ctx3, ex2\n end"
    },
    {
      "sha": "56b6ee7a47382d25a868546843e1267018a01d68",
      "filename": "JuliaLowering/test/closures.jl",
      "status": "modified",
      "additions": 164,
      "deletions": 0,
      "changes": 164,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Ftest%2Fclosures.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Ftest%2Fclosures.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fclosures.jl?ref=fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc",
      "patch": "@@ -241,4 +241,168 @@ method_ex = lower_str(test_mod, \"Base.Experimental.@opaque x -> 2x\").args[1].cod\n @test method_ex.args[1] === nothing\n @test method_ex.args[4] isa LineNumberNode\n \n+# Argument reassigned in outer scope - no Box needed\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function f_arg_reassign(x)\n+        x = 1\n+        return ()->x\n+    end\n+    f_arg_reassign(100)()\n+end\n+\"\"\") == 1\n+\n+# Argument reassigned in if-branch before capture - no Box needed (PR #60567 review)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function f_arg_if_branch(x, cond)\n+        if cond\n+            x = 5\n+            return ()->x\n+        end\n+        return x\n+    end\n+    # When closure is returned, it captures the reassigned value\n+    f_arg_if_branch(100, true)()\n+end\n+\"\"\") == 5\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function f_arg_if_branch2(x, cond)\n+        if cond\n+            x = 5\n+            return ()->x\n+        end\n+        return x\n+    end\n+    # When original value is returned\n+    f_arg_if_branch2(100, false)\n+end\n+\"\"\") == 100\n+\n+# Variable declared outside loop, assigned inside - needs Box (issue #37690)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function f_loop_capture()\n+        local f\n+        local x\n+        for k = 1 : 2\n+            x = k\n+            if k == 1\n+                f = () -> x\n+            end\n+        end\n+        f()\n+    end\n+    f_loop_capture()\n+end\n+\"\"\") == 2\n+\n+# Typed local declared outside loop, assigned inside - needs Box (issue #37690)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function f_typed_local_loop()\n+        local f\n+        local x::Int\n+        for k = 1:2\n+            x = k\n+            if k == 1\n+                f = () -> x\n+            end\n+        end\n+        f()\n+    end\n+    f_typed_local_loop()\n+end\n+\"\"\") == 2\n+\n+# Label can be jumped to, bypassing assignment - needs Box\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    @goto L\n+    y = 1\n+    @label L\n+    f = ()->y\n+    f.y\n+end\n+\"\"\") isa Core.Box\n+\n+# Argument reassigned inside loop - needs Box (argument is implicitly declared outside loop) (issue #37690)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function f_arg_loop(x)\n+        local f\n+        for i in 1:2\n+            x = i\n+            i == 1 && (f = ()->x;)\n+        end\n+        f()\n+    end\n+    f_arg_loop(0)\n+end\n+\"\"\") == 2\n+\n+# Variable in while-true loop with break - needs Box (issue #37690)\n+let x = JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_break_loop()\n+            local f\n+            local x\n+            i = 1\n+            while true\n+                x = i\n+                if i == 1\n+                    f = ()->x\n+                end\n+                i >= 3 && break\n+                i += 1\n+            end\n+            f.x\n+        end\n+        f_break_loop()\n+    end\n+    \"\"\")\n+    @test x isa Core.Box\n+    @test x.contents == 3\n+end\n+\n+# Variable in while-true loop with post-dominated capture (not captured in a branch) - no Box\n+let x = JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_break_loop2()\n+            local f\n+            local x\n+            i = 1\n+            while true\n+                x = i\n+                f = ()->x\n+                i >= 3 && break\n+                i += 1\n+            end\n+            f.x\n+        end\n+        f_break_loop2()\n+    end\n+    \"\"\")\n+    @test x isa Int\n+    @test x === 3\n+end\n+\n+let keep = JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_for_after_capture(cond)\n+            if cond\n+                keep = Set{Base.PkgId}()\n+                return ()->keep\n+            end\n+            for x in 1:3; end\n+        end\n+        f_for_after_capture(true).keep\n+    end\n+    \"\"\")\n+    @test keep isa Set{Base.PkgId}\n+    @test keep == Set{Base.PkgId}()\n+end\n+\n end"
    },
    {
      "sha": "4f282c165df787c21830fc2bb956d2bae23a8b61",
      "filename": "JuliaLowering/test/closures_ir.jl",
      "status": "modified",
      "additions": 481,
      "deletions": 124,
      "changes": 605,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Ftest%2Fclosures_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Ftest%2Fclosures_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fclosures_ir.jl?ref=fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc",
      "patch": "@@ -1,5 +1,5 @@\n ########################################\n-# Simple closure\n+# Simple closure - single-assigned capture before control flow doesn't need Box\n # (FIXME: #self# should have `read` flag set)\n let\n     x = 1\n@@ -8,38 +8,30 @@ let\n     end\n end\n #---------------------\n-1   (= slot\u2082/x (call core.Box))\n-2   1\n-3   slot\u2082/x\n-4   (call core.setfield! %\u2083 :contents %\u2082)\n-5   (call core.svec :x)\n-6   (call core.svec true)\n-7   (call JuliaLowering.eval_closure_type TestMod :#f##0 %\u2085 %\u2086)\n-8   latestworld\n-9   TestMod.#f##0\n-10  slot\u2082/x\n-11  (new %\u2089 %\u2081\u2080)\n-12  (= slot\u2081/f %\u2081\u2081)\n-13  TestMod.#f##0\n-14  (call core.svec %\u2081\u2083 core.Any)\n-15  (call core.svec)\n-16  SourceLocation::3:14\n-17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n-18  --- method core.nothing %\u2081\u2087\n-    slots: [slot\u2081/#self#(!read) slot\u2082/y slot\u2083/x(!read,maybe_undef)]\n+1   (= slot\u2082/x 1)\n+2   (call core.svec :x)\n+3   (call core.svec false)\n+4   (call JuliaLowering.eval_closure_type TestMod :#f##0 %\u2082 %\u2083)\n+5   latestworld\n+6   TestMod.#f##0\n+7   (call core.typeof slot\u2082/x)\n+8   (call core.apply_type %\u2086 %\u2087)\n+9   (new %\u2088 slot\u2082/x)\n+10  (= slot\u2081/f %\u2089)\n+11  TestMod.#f##0\n+12  (call core.svec %\u2081\u2081 core.Any)\n+13  (call core.svec)\n+14  SourceLocation::3:14\n+15  (call core.svec %\u2081\u2082 %\u2081\u2083 %\u2081\u2084)\n+16  --- method core.nothing %\u2081\u2085\n+    slots: [slot\u2081/#self#(!read) slot\u2082/y]\n     1   TestMod.+\n     2   (call core.getfield slot\u2081/#self# :x)\n-    3   (call core.isdefined %\u2082 :contents)\n-    4   (gotoifnot %\u2083 label\u2086)\n-    5   (goto label\u2088)\n-    6   (newvar slot\u2083/x)\n-    7   slot\u2083/x\n-    8   (call core.getfield %\u2082 :contents)\n-    9   (call %\u2081 %\u2088 slot\u2082/y)\n-    10  (return %\u2089)\n-19  latestworld\n-20  slot\u2081/f\n-21  (return %\u2082\u2080)\n+    3   (call %\u2081 %\u2082 slot\u2082/y)\n+    4   (return %\u2083)\n+17  latestworld\n+18  slot\u2081/f\n+19  (return %\u2081\u2088)\n \n ########################################\n # Closure declaration with no methods\n@@ -152,6 +144,60 @@ end\n 22  TestMod.f\n 23  (return %\u2082\u2082)\n \n+########################################\n+# Argument reassigned in outer scope then captured - no Box needed\n+# (from PR #60567 review)\n+function foo(x)\n+    if rand(Bool)\n+        x = 5\n+        return ()->x\n+    end\n+    return x\n+end\n+#---------------------\n+1   (method TestMod.foo)\n+2   latestworld\n+3   (call core.svec :x)\n+4   (call core.svec false)\n+5   (call JuliaLowering.eval_closure_type TestMod :#foo#->##0 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#foo#->##0\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::4:16\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (call core.getfield slot\u2081/#self# :x)\n+    2   (return %\u2081)\n+13  latestworld\n+14  TestMod.foo\n+15  (call core.Typeof %\u2081\u2084)\n+16  (call core.svec %\u2081\u2085 core.Any)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(single_assign) slot\u2083/x(!read)]\n+    1   (= slot\u2083/x slot\u2082/x)\n+    2   TestMod.rand\n+    3   TestMod.Bool\n+    4   (call %\u2082 %\u2083)\n+    5   (gotoifnot %\u2084 label\u2081\u2084)\n+    6   (= slot\u2083/x 5)\n+    7   TestMod.#foo#->##0\n+    8   slot\u2083/x\n+    9   (call core.typeof %\u2088)\n+    10  (call core.apply_type %\u2087 %\u2089)\n+    11  slot\u2083/x\n+    12  (new %\u2081\u2080 %\u2081\u2081)\n+    13  (return %\u2081\u2082)\n+    14  slot\u2083/x\n+    15  (return %\u2081\u2084)\n+21  latestworld\n+22  TestMod.foo\n+23  (return %\u2082\u2082)\n+\n ########################################\n # Closure where a local `x` is captured but not boxed\n function f(x)\n@@ -473,35 +519,28 @@ function f(::g) where {g}\n end\n \n ########################################\n-# Opaque closure\n+# Opaque closure (y is single-assigned before capture, no Box needed)\n let y = 1\n     Base.Experimental.@opaque (x, z::T)->2x + y - z\n end\n #---------------------\n 1   1\n-2   (= slot\u2081/y (call core.Box))\n-3   (call core.setfield! slot\u2081/y :contents %\u2081)\n-4   TestMod.T\n-5   (call core.apply_type core.Tuple core.Any %\u2084)\n-6   (call core.apply_type core.Union)\n-7   --- opaque_closure_method  core.nothing 2 false SourceLocation::2:31\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/z slot\u2084/y(!read,maybe_undef)]\n+2   (= slot\u2081/y %\u2081)\n+3   TestMod.T\n+4   (call core.apply_type core.Tuple core.Any %\u2083)\n+5   (call core.apply_type core.Union)\n+6   --- opaque_closure_method  core.nothing 2 false SourceLocation::2:31\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/z]\n     1   TestMod.-\n     2   TestMod.+\n     3   TestMod.*\n     4   (call %\u2083 2 slot\u2082/x)\n     5   (call core.getfield slot\u2081/#self# 1)\n-    6   (call core.isdefined %\u2085 :contents)\n-    7   (gotoifnot %\u2086 label\u2089)\n-    8   (goto label\u2081\u2081)\n-    9   (newvar slot\u2084/y)\n-    10  slot\u2084/y\n-    11  (call core.getfield %\u2085 :contents)\n-    12  (call %\u2082 %\u2084 %\u2081\u2081)\n-    13  (call %\u2081 %\u2081\u2082 slot\u2083/z)\n-    14  (return %\u2081\u2083)\n-8   (new_opaque_closure %\u2085 %\u2086 core.Any true %\u2087 slot\u2081/y)\n-9   (return %\u2088)\n+    6   (call %\u2082 %\u2084 %\u2085)\n+    7   (call %\u2081 %\u2086 slot\u2083/z)\n+    8   (return %\u2087)\n+7   (new_opaque_closure %\u2084 %\u2085 core.Any true %\u2086 slot\u2081/y)\n+8   (return %\u2087)\n \n ########################################\n # Opaque closure with `...`\n@@ -610,53 +649,48 @@ let y = y_init\n end\n #---------------------\n 1   TestMod.y_init\n-2   (= slot\u2081/y (call core.Box))\n-3   (= slot\u2082/#f_kw_closure#0 (call core.Box))\n-4   (call core.setfield! slot\u2081/y :contents %\u2081)\n-5   (call core.svec :#f_kw_closure#0)\n-6   (call core.svec true)\n-7   (call JuliaLowering.eval_closure_type TestMod :#f_kw_closure##0 %\u2085 %\u2086)\n-8   latestworld\n-9   TestMod.#f_kw_closure##0\n-10  slot\u2082/#f_kw_closure#0\n-11  (new %\u2089 %\u2081\u2080)\n-12  (= slot\u2083/f_kw_closure %\u2081\u2081)\n-13  (call core.svec :y)\n-14  (call core.svec true)\n-15  (call JuliaLowering.eval_closure_type TestMod :##f_kw_closure#0##0 %\u2081\u2083 %\u2081\u2084)\n-16  latestworld\n-17  TestMod.##f_kw_closure#0##0\n-18  (new %\u2081\u2087 slot\u2081/y)\n-19  slot\u2082/#f_kw_closure#0\n-20  (call core.setfield! %\u2081\u2089 :contents %\u2081\u2088)\n-21  TestMod.##f_kw_closure#0##0\n-22  TestMod.X\n-23  TestMod.#f_kw_closure##0\n-24  (call core.svec %\u2082\u2081 %\u2082\u2082 %\u2082\u2083)\n-25  (call core.svec)\n-26  SourceLocation::2:14\n-27  (call core.svec %\u2082\u2084 %\u2082\u2085 %\u2082\u2086)\n-28  --- method core.nothing %\u2082\u2087\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/#self# slot\u2084/y(!read,maybe_undef)]\n+2   (= slot\u2082/#f_kw_closure#0 (call core.Box))\n+3   (= slot\u2081/y %\u2081)\n+4   (call core.svec :#f_kw_closure#0)\n+5   (call core.svec true)\n+6   (call JuliaLowering.eval_closure_type TestMod :#f_kw_closure##0 %\u2084 %\u2085)\n+7   latestworld\n+8   TestMod.#f_kw_closure##0\n+9   slot\u2082/#f_kw_closure#0\n+10  (new %\u2088 %\u2089)\n+11  (= slot\u2083/f_kw_closure %\u2081\u2080)\n+12  (call core.svec :y)\n+13  (call core.svec false)\n+14  (call JuliaLowering.eval_closure_type TestMod :##f_kw_closure#0##0 %\u2081\u2082 %\u2081\u2083)\n+15  latestworld\n+16  TestMod.##f_kw_closure#0##0\n+17  (call core.typeof slot\u2081/y)\n+18  (call core.apply_type %\u2081\u2086 %\u2081\u2087)\n+19  (new %\u2081\u2088 slot\u2081/y)\n+20  slot\u2082/#f_kw_closure#0\n+21  (call core.setfield! %\u2082\u2080 :contents %\u2081\u2089)\n+22  TestMod.##f_kw_closure#0##0\n+23  TestMod.X\n+24  TestMod.#f_kw_closure##0\n+25  (call core.svec %\u2082\u2082 %\u2082\u2083 %\u2082\u2084)\n+26  (call core.svec)\n+27  SourceLocation::2:14\n+28  (call core.svec %\u2082\u2085 %\u2082\u2086 %\u2082\u2087)\n+29  --- method core.nothing %\u2082\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/#self#]\n     1   (meta :nkw 1)\n     2   TestMod.+\n     3   (call core.getfield slot\u2081/#self# :y)\n-    4   (call core.isdefined %\u2083 :contents)\n-    5   (gotoifnot %\u2084 label\u2087)\n-    6   (goto label\u2089)\n-    7   (newvar slot\u2084/y)\n-    8   slot\u2084/y\n-    9   (call core.getfield %\u2083 :contents)\n-    10  (call %\u2082 slot\u2082/x %\u2089)\n-    11  (return %\u2081\u2080)\n-29  latestworld\n-30  (call core.typeof core.kwcall)\n-31  TestMod.#f_kw_closure##0\n-32  (call core.svec %\u2083\u2080 core.NamedTuple %\u2083\u2081)\n-33  (call core.svec)\n-34  SourceLocation::2:14\n-35  (call core.svec %\u2083\u2082 %\u2083\u2083 %\u2083\u2084)\n-36  --- code_info\n+    4   (call %\u2082 slot\u2082/x %\u2083)\n+    5   (return %\u2084)\n+30  latestworld\n+31  (call core.typeof core.kwcall)\n+32  TestMod.#f_kw_closure##0\n+33  (call core.svec %\u2083\u2081 core.NamedTuple %\u2083\u2082)\n+34  (call core.svec)\n+35  SourceLocation::2:14\n+36  (call core.svec %\u2083\u2083 %\u2083\u2084 %\u2083\u2085)\n+37  --- code_info\n     slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/kwtmp slot\u2085/x(!read) slot\u2086/#f_kw_closure#0(!read,maybe_undef)]\n     1   (newvar slot\u2085/x)\n     2   (call core.isdefined slot\u2082/kws :x)\n@@ -690,17 +724,17 @@ end\n     30  (call core.getfield %\u2082\u2084 :contents)\n     31  (call %\u2083\u2080 %\u2081\u2086 slot\u2083/#self#)\n     32  (return %\u2083\u2081)\n-37  slot\u2082/#f_kw_closure#0\n-38  (call core.svec %\u2083\u2087)\n-39  (call JuliaLowering.replace_captured_locals! %\u2083\u2086 %\u2083\u2088)\n-40  --- method core.nothing %\u2083\u2085 %\u2083\u2089\n-41  latestworld\n-42  TestMod.#f_kw_closure##0\n-43  (call core.svec %\u2084\u2082)\n-44  (call core.svec)\n-45  SourceLocation::2:14\n-46  (call core.svec %\u2084\u2083 %\u2084\u2084 %\u2084\u2085)\n-47  --- method core.nothing %\u2084\u2086\n+38  slot\u2082/#f_kw_closure#0\n+39  (call core.svec %\u2083\u2088)\n+40  (call JuliaLowering.replace_captured_locals! %\u2083\u2087 %\u2083\u2089)\n+41  --- method core.nothing %\u2083\u2086 %\u2084\u2080\n+42  latestworld\n+43  TestMod.#f_kw_closure##0\n+44  (call core.svec %\u2084\u2083)\n+45  (call core.svec)\n+46  SourceLocation::2:14\n+47  (call core.svec %\u2084\u2084 %\u2084\u2085 %\u2084\u2086)\n+48  --- method core.nothing %\u2084\u2087\n     slots: [slot\u2081/#self# slot\u2082/#f_kw_closure#0(!read,maybe_undef)]\n     1   (call core.getfield slot\u2081/#self# :#f_kw_closure#0)\n     2   (call core.isdefined %\u2081 :contents)\n@@ -712,9 +746,9 @@ end\n     8   TestMod.x_default\n     9   (call %\u2087 %\u2088 slot\u2081/#self#)\n     10  (return %\u2089)\n-48  latestworld\n-49  slot\u2083/f_kw_closure\n-50  (return %\u2084\u2089)\n+49  latestworld\n+50  slot\u2083/f_kw_closure\n+51  (return %\u2085\u2080)\n \n ########################################\n # Closure capturing a typed local must also capture the type expression\n@@ -728,25 +762,348 @@ let T=Blah\n     x\n end\n #---------------------\n-slots: [slot\u2081/#self#(!read) slot\u2082/T(!read,maybe_undef) slot\u2083/tmp(!read)]\n+slots: [slot\u2081/#self#(!read) slot\u2082/tmp(!read)]\n 1   2.0\n 2   (call core.getfield slot\u2081/#self# :x)\n 3   (call core.getfield slot\u2081/#self# :T)\n-4   (call core.isdefined %\u2083 :contents)\n-5   (gotoifnot %\u2084 label\u2087)\n-6   (goto label\u2089)\n-7   (newvar slot\u2082/T)\n-8   slot\u2082/T\n-9   (call core.getfield %\u2083 :contents)\n-10  (= slot\u2083/tmp %\u2081)\n-11  (call core.isa slot\u2083/tmp %\u2089)\n-12  (gotoifnot %\u2081\u2081 label\u2081\u2084)\n-13  (goto label\u2081\u2086)\n-14  (call top.convert %\u2089 slot\u2083/tmp)\n-15  (= slot\u2083/tmp (call core.typeassert %\u2081\u2084 %\u2089))\n-16  slot\u2083/tmp\n-17  (call core.setfield! %\u2082 :contents %\u2081\u2086)\n-18  (return %\u2081)\n+4   (= slot\u2082/tmp %\u2081)\n+5   (call core.isa slot\u2082/tmp %\u2083)\n+6   (gotoifnot %\u2085 label\u2088)\n+7   (goto label\u2081\u2080)\n+8   (call top.convert %\u2083 slot\u2082/tmp)\n+9   (= slot\u2082/tmp (call core.typeassert %\u2088 %\u2083))\n+10  slot\u2082/tmp\n+11  (call core.setfield! %\u2082 :contents %\u2081\u2080)\n+12  (return %\u2081)\n+\n+########################################\n+# Assignment after if statement doesn't need Box (flisp-compatible save/restore)\n+function f_after_if(cond)\n+    if cond\n+        println(\"hello\")\n+    end\n+    y = 1\n+    () -> y\n+end\n+#---------------------\n+1   (method TestMod.f_after_if)\n+2   latestworld\n+3   (call core.svec :y)\n+4   (call core.svec false)\n+5   (call JuliaLowering.eval_closure_type TestMod :#f_after_if#->##0 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#f_after_if#->##0\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::6:5\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (call core.getfield slot\u2081/#self# :y)\n+    2   (return %\u2081)\n+13  latestworld\n+14  TestMod.f_after_if\n+15  (call core.Typeof %\u2081\u2084)\n+16  (call core.svec %\u2081\u2085 core.Any)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/cond slot\u2083/y(single_assign)]\n+    1   (gotoifnot slot\u2082/cond label\u2084)\n+    2   TestMod.println\n+    3   (call %\u2082 \"hello\")\n+    4   (= slot\u2083/y 1)\n+    5   TestMod.#f_after_if#->##0\n+    6   (call core.typeof slot\u2083/y)\n+    7   (call core.apply_type %\u2085 %\u2086)\n+    8   (new %\u2087 slot\u2083/y)\n+    9   (return %\u2088)\n+21  latestworld\n+22  TestMod.f_after_if\n+23  (return %\u2082\u2082)\n+\n+########################################\n+# Ternary operator (if expression in value position) doesn't need Box\n+function f_ternary(x)\n+    y = x > 0 ? x : 0\n+    () -> y\n+end\n+#---------------------\n+1   (method TestMod.f_ternary)\n+2   latestworld\n+3   (call core.svec :y)\n+4   (call core.svec false)\n+5   (call JuliaLowering.eval_closure_type TestMod :#f_ternary#->##0 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#f_ternary#->##0\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::3:5\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (call core.getfield slot\u2081/#self# :y)\n+    2   (return %\u2081)\n+13  latestworld\n+14  TestMod.f_ternary\n+15  (call core.Typeof %\u2081\u2084)\n+16  (call core.svec %\u2081\u2085 core.Any)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y(single_assign) slot\u2084/if_val(!read)]\n+    1   TestMod.>\n+    2   (call %\u2081 slot\u2082/x 0)\n+    3   (gotoifnot %\u2082 label\u2087)\n+    4   slot\u2082/x\n+    5   (= slot\u2084/if_val %\u2084)\n+    6   (goto label\u2088)\n+    7   (= slot\u2084/if_val 0)\n+    8   slot\u2084/if_val\n+    9   (= slot\u2083/y %\u2088)\n+    10  TestMod.#f_ternary#->##0\n+    11  (call core.typeof slot\u2083/y)\n+    12  (call core.apply_type %\u2081\u2080 %\u2081\u2081)\n+    13  (new %\u2081\u2082 slot\u2083/y)\n+    14  (return %\u2081\u2083)\n+21  latestworld\n+22  TestMod.f_ternary\n+23  (return %\u2082\u2082)\n+\n+########################################\n+# || guard pattern (value position with early exit) doesn't need Box\n+function f_or_guard(x)\n+    (x === nothing || x === missing) && return nothing\n+    y = x\n+    () -> y\n+end\n+#---------------------\n+1   (method TestMod.f_or_guard)\n+2   latestworld\n+3   (call core.svec :y)\n+4   (call core.svec false)\n+5   (call JuliaLowering.eval_closure_type TestMod :#f_or_guard#->##0 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#f_or_guard#->##0\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::4:5\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (call core.getfield slot\u2081/#self# :y)\n+    2   (return %\u2081)\n+13  latestworld\n+14  TestMod.f_or_guard\n+15  (call core.Typeof %\u2081\u2084)\n+16  (call core.svec %\u2081\u2085 core.Any)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y(single_assign) slot\u2084/if_val(!read)]\n+    1   TestMod.===\n+    2   TestMod.nothing\n+    3   (call %\u2081 slot\u2082/x %\u2082)\n+    4   (gotoifnot %\u2083 label\u2087)\n+    5   (= slot\u2084/if_val true)\n+    6   (goto label\u2081\u2080)\n+    7   TestMod.===\n+    8   TestMod.missing\n+    9   (= slot\u2084/if_val (call %\u2087 slot\u2082/x %\u2088))\n+    10  slot\u2084/if_val\n+    11  (gotoifnot %\u2081\u2080 label\u2081\u2085)\n+    12  TestMod.nothing\n+    13  (return %\u2081\u2082)\n+    14  (goto label\u2081\u2085)\n+    15  slot\u2082/x\n+    16  (= slot\u2083/y %\u2081\u2085)\n+    17  TestMod.#f_or_guard#->##0\n+    18  (call core.typeof slot\u2083/y)\n+    19  (call core.apply_type %\u2081\u2087 %\u2081\u2088)\n+    20  (new %\u2081\u2089 slot\u2083/y)\n+    21  (return %\u2082\u2080)\n+21  latestworld\n+22  TestMod.f_or_guard\n+23  (return %\u2082\u2082)\n+\n+########################################\n+# Argument reassigned in outer scope - no Box needed\n+function f_arg_reassign(x)\n+    x = 1\n+    return ()->x\n+end\n+#---------------------\n+1   (method TestMod.f_arg_reassign)\n+2   latestworld\n+3   (call core.svec :x)\n+4   (call core.svec false)\n+5   (call JuliaLowering.eval_closure_type TestMod :#f_arg_reassign#->##0 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#f_arg_reassign#->##0\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::3:12\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (call core.getfield slot\u2081/#self# :x)\n+    2   (return %\u2081)\n+13  latestworld\n+14  TestMod.f_arg_reassign\n+15  (call core.Typeof %\u2081\u2084)\n+16  (call core.svec %\u2081\u2085 core.Any)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(single_assign) slot\u2083/x(!read)]\n+    1   (= slot\u2083/x slot\u2082/x)\n+    2   (= slot\u2083/x 1)\n+    3   TestMod.#f_arg_reassign#->##0\n+    4   slot\u2083/x\n+    5   (call core.typeof %\u2084)\n+    6   (call core.apply_type %\u2083 %\u2085)\n+    7   slot\u2083/x\n+    8   (new %\u2086 %\u2087)\n+    9   (return %\u2088)\n+21  latestworld\n+22  TestMod.f_arg_reassign\n+23  (return %\u2082\u2082)\n+\n+########################################\n+# Label can be jumped to, bypassing assignment - needs Box\n+let\n+    @goto L\n+    y = 1\n+    @label L\n+    ()->y\n+end\n+#---------------------\n+1   (= slot\u2081/y (call core.Box))\n+2   (goto label\u2086)\n+3   1\n+4   slot\u2081/y\n+5   (call core.setfield! %\u2084 :contents %\u2083)\n+6   (call core.svec :y)\n+7   (call core.svec true)\n+8   (call JuliaLowering.eval_closure_type TestMod :#->##1 %\u2086 %\u2087)\n+9   latestworld\n+10  TestMod.#->##1\n+11  slot\u2081/y\n+12  (new %\u2081\u2080 %\u2081\u2081)\n+13  TestMod.#->##1\n+14  (call core.svec %\u2081\u2083)\n+15  (call core.svec)\n+16  SourceLocation::5:5\n+17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n+18  --- method core.nothing %\u2081\u2087\n+    slots: [slot\u2081/#self#(!read) slot\u2082/y(!read,maybe_undef)]\n+    1   (call core.getfield slot\u2081/#self# :y)\n+    2   (call core.isdefined %\u2081 :contents)\n+    3   (gotoifnot %\u2082 label\u2085)\n+    4   (goto label\u2087)\n+    5   (newvar slot\u2082/y)\n+    6   slot\u2082/y\n+    7   (call core.getfield %\u2081 :contents)\n+    8   (return %\u2087)\n+19  latestworld\n+20  (return %\u2081\u2082)\n+\n+########################################\n+# Local single-assigned after declaration - no Box needed\n+function f_local_no_box()\n+    local x\n+    x = 1\n+    ()->x\n+end\n+#---------------------\n+1   (method TestMod.f_local_no_box)\n+2   latestworld\n+3   (call core.svec :x)\n+4   (call core.svec false)\n+5   (call JuliaLowering.eval_closure_type TestMod :#f_local_no_box#->##0 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#f_local_no_box#->##0\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::4:5\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (call core.getfield slot\u2081/#self# :x)\n+    2   (return %\u2081)\n+13  latestworld\n+14  TestMod.f_local_no_box\n+15  (call core.Typeof %\u2081\u2084)\n+16  (call core.svec %\u2081\u2085)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(single_assign)]\n+    1   (= slot\u2082/x 1)\n+    2   TestMod.#f_local_no_box#->##0\n+    3   (call core.typeof slot\u2082/x)\n+    4   (call core.apply_type %\u2082 %\u2083)\n+    5   (new %\u2084 slot\u2082/x)\n+    6   (return %\u2085)\n+21  latestworld\n+22  TestMod.f_local_no_box\n+23  (return %\u2082\u2082)\n+\n+########################################\n+# Typed local single-assigned after declaration - no Box needed\n+function f_typed_local_no_box()\n+    local x::Int\n+    x = 1\n+    ()->x\n+end\n+#---------------------\n+1   (method TestMod.f_typed_local_no_box)\n+2   latestworld\n+3   (call core.svec :x)\n+4   (call core.svec false)\n+5   (call JuliaLowering.eval_closure_type TestMod :#f_typed_local_no_box#->##0 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#f_typed_local_no_box#->##0\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::4:5\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (call core.getfield slot\u2081/#self# :x)\n+    2   (return %\u2081)\n+13  latestworld\n+14  TestMod.f_typed_local_no_box\n+15  (call core.Typeof %\u2081\u2084)\n+16  (call core.svec %\u2081\u2085)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(single_assign) slot\u2083/tmp(!read)]\n+    1   1\n+    2   TestMod.Int\n+    3   (= slot\u2083/tmp %\u2081)\n+    4   (call core.isa slot\u2083/tmp %\u2082)\n+    5   (gotoifnot %\u2084 label\u2087)\n+    6   (goto label\u2089)\n+    7   (call top.convert %\u2082 slot\u2083/tmp)\n+    8   (= slot\u2083/tmp (call core.typeassert %\u2087 %\u2082))\n+    9   slot\u2083/tmp\n+    10  (= slot\u2082/x %\u2089)\n+    11  TestMod.#f_typed_local_no_box#->##0\n+    12  (call core.typeof slot\u2082/x)\n+    13  (call core.apply_type %\u2081\u2081 %\u2081\u2082)\n+    14  (new %\u2081\u2083 slot\u2082/x)\n+    15  (return %\u2081\u2084)\n+21  latestworld\n+22  TestMod.f_typed_local_no_box\n+23  (return %\u2082\u2082)\n \n ########################################\n # Error: Closure outside any top level context"
    },
    {
      "sha": "3704600c5331e45d97783e763fc0f6a124ad7069",
      "filename": "JuliaLowering/test/scopes_ir.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Ftest%2Fscopes_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc/JuliaLowering%2Ftest%2Fscopes_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fscopes_ir.jl?ref=fc649b5fb5dc8b5d6fc26a7bd9276146dd8157fc",
      "patch": "@@ -129,6 +129,7 @@ end\n \n ########################################\n # @islocal with function arguments\n+# (y is single-assigned before capture, so no Box needed)\n begin\n     local y = 2\n     function f(x)"
    }
  ]
}