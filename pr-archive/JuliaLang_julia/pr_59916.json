{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59916",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59916/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59916/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59916/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59916",
  "id": 3532696596,
  "node_id": "PR_kwDOABkWpM6upTWr",
  "number": 59916,
  "title": "Use jl_effective_threads for container-aware CPU detection",
  "user": {
    "login": "KristofferC",
    "id": 1282691,
    "node_id": "MDQ6VXNlcjEyODI2OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1282691?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KristofferC",
    "html_url": "https://github.com/KristofferC",
    "followers_url": "https://api.github.com/users/KristofferC/followers",
    "following_url": "https://api.github.com/users/KristofferC/following{/other_user}",
    "gists_url": "https://api.github.com/users/KristofferC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KristofferC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KristofferC/subscriptions",
    "organizations_url": "https://api.github.com/users/KristofferC/orgs",
    "repos_url": "https://api.github.com/users/KristofferC/repos",
    "events_url": "https://api.github.com/users/KristofferC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KristofferC/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 184008807,
      "node_id": "MDU6TGFiZWwxODQwMDg4MDc=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/multithreading",
      "name": "multithreading",
      "color": "fbca04",
      "default": false,
      "description": "Base.Threads and related functionality"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 1,
  "created_at": "2025-10-20T14:35:24Z",
  "updated_at": "2025-10-22T23:22:41Z",
  "closed_at": "2025-10-22T23:22:39Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59916",
    "html_url": "https://github.com/JuliaLang/julia/pull/59916",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59916.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59916.patch",
    "merged_at": "2025-10-22T23:22:39Z"
  },
  "body": "\ud83d\udc68 It seems to me we should use the effective thread number basically everywhere when defaulting to running some threaded workload. Running with the raw cpu threads will explode quickly when running in a constrained environment.\r\n\r\n-----\r\n\r\n\ud83e\udd16 \r\n\r\nJulia was not respecting container CPU limits (Docker --cpus, Kubernetes\r\nCPU limits, cgroups) in several places, leading to oversubscription when\r\ndetermining parallelism.\r\n\r\nChanges:\r\n- src/aotcompile.cpp:2013: Use jl_effective_threads() for LLVM compilation threads\r\n- src/threading.c:760: Use jl_effective_threads() for GC thread capping/warnings\r\n- src/threading.c:842: Use jl_effective_threads() for JULIA_EXCLUSIVE mode validation\r\n- base/sysinfo.jl: Add Sys.EFFECTIVE_CPU_THREADS constant for user access\r\n- test/runtests.jl:119: Use Sys.EFFECTIVE_CPU_THREADS for test worker processes\r\n- base/precompilation.jl:529: Use Sys.EFFECTIVE_CPU_THREADS for precompilation tasks\r\n- base/util.jl:697: Use Sys.EFFECTIVE_CPU_THREADS for Base.runtests() default\r\n\r\nThe existing jl_effective_threads() function returns min(jl_cpu_threads(),\r\nuv_available_parallelism()), where uv_available_parallelism() respects\r\ncgroup limits.\r\n\r\n--------\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59916/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59916/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "adecc50f6d1e4c7cd89e4be1de1e5059d973c61e",
      "filename": "base/precompilation.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/612ac77721a17d70c2688c70519599a72adc72e4/base%2Fprecompilation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/612ac77721a17d70c2688c70519599a72adc72e4/base%2Fprecompilation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fprecompilation.jl?ref=612ac77721a17d70c2688c70519599a72adc72e4",
      "patch": "@@ -526,7 +526,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n \n     # Windows sometimes hits a ReadOnlyMemoryError, so we halve the default number of tasks. Issue #2323\n     # TODO: Investigate why this happens in windows and restore the full task limit\n-    default_num_tasks = Sys.iswindows() ? div(Sys.CPU_THREADS::Int, 2) + 1 : Sys.CPU_THREADS::Int + 1\n+    default_num_tasks = Sys.iswindows() ? div(Sys.EFFECTIVE_CPU_THREADS::Int, 2) + 1 : Sys.EFFECTIVE_CPU_THREADS::Int + 1\n     default_num_tasks = min(default_num_tasks, 16) # limit for better stability on shared resource systems\n \n     num_tasks = max(1, something(tryparse(Int, get(ENV, \"JULIA_NUM_PRECOMPILE_TASKS\", string(default_num_tasks))), 1))"
    },
    {
      "sha": "5b0d60a406b2fe84fd54a4ec2e0c4c2919394d09",
      "filename": "base/sysinfo.jl",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/JuliaLang/julia/blob/612ac77721a17d70c2688c70519599a72adc72e4/base%2Fsysinfo.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/612ac77721a17d70c2688c70519599a72adc72e4/base%2Fsysinfo.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fsysinfo.jl?ref=612ac77721a17d70c2688c70519599a72adc72e4",
      "patch": "@@ -8,6 +8,7 @@ Provide methods for retrieving information about hardware and the operating syst\n export BINDIR,\n        STDLIB,\n        CPU_THREADS,\n+       EFFECTIVE_CPU_THREADS,\n        CPU_NAME,\n        WORD_SIZE,\n        ARCH,\n@@ -73,9 +74,28 @@ CPU cores, for example, in the presence of\n [hyper-threading](https://en.wikipedia.org/wiki/Hyper-threading).\n \n See Hwloc.jl or CpuId.jl for extended information, including number of physical cores.\n+\n+See also: [`Sys.EFFECTIVE_CPU_THREADS`](@ref) for a container-aware CPU count that respects\n+cgroup limits.\n \"\"\"\n global CPU_THREADS::Int = 1 # for bootstrap, changed on startup\n \n+\"\"\"\n+    Sys.EFFECTIVE_CPU_THREADS::Int\n+\n+The effective number of logical CPU cores available to the Julia process, taking into\n+account container limits (e.g., Docker `--cpus`, Kubernetes CPU limits, cgroup quotas).\n+This is the minimum of the hardware CPU thread count and any imposed CPU limits.\n+\n+In non-containerized environments, this typically equals `Sys.CPU_THREADS`. In containerized\n+environments, it respects cgroup CPU limits and provides a more accurate measure of\n+available parallelism.\n+\n+Use this constant when determining default thread pool sizes or parallelism levels to\n+ensure proper behavior in containerized deployments.\n+\"\"\"\n+global EFFECTIVE_CPU_THREADS::Int = 1 # for bootstrap, changed on startup\n+\n \"\"\"\n     Sys.ARCH::Symbol\n \n@@ -167,6 +187,7 @@ function __init__()\n     else\n         Int(ccall(:jl_cpu_threads, Int32, ()))\n     end\n+    global EFFECTIVE_CPU_THREADS = min(CPU_THREADS, Int(ccall(:jl_effective_threads, Int32, ())))\n     global SC_CLK_TCK = ccall(:jl_SC_CLK_TCK, Clong, ())\n     global CPU_NAME = ccall(:jl_get_cpu_name, Ref{String}, ())\n     global JIT = ccall(:jl_get_JIT, Ref{String}, ())"
    },
    {
      "sha": "962a6873cf05439f77b0041b5bf31aff9d8a1818",
      "filename": "base/util.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/612ac77721a17d70c2688c70519599a72adc72e4/base%2Futil.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/612ac77721a17d70c2688c70519599a72adc72e4/base%2Futil.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Futil.jl?ref=612ac77721a17d70c2688c70519599a72adc72e4",
      "patch": "@@ -680,7 +680,7 @@ end\n # testing\n \n \"\"\"\n-    Base.runtests(tests=[\"all\"]; ncores=ceil(Int, Sys.CPU_THREADS / 2),\n+    Base.runtests(tests=[\"all\"]; ncores=ceil(Int, Sys.EFFECTIVE_CPU_THREADS / 2),\n                   exit_on_error=false, revise=false, propagate_project=true, [seed], [julia_args::Cmd])\n \n Run the Julia unit tests listed in `tests`, which can be either a string or an array of\n@@ -694,7 +694,7 @@ If a seed is provided via the keyword argument, it is used to seed the\n global RNG in the context where the tests are run; otherwise the seed is chosen randomly.\n The argument `julia_args` can be used to pass custom `julia` command line flags to the test process.\n \"\"\"\n-function runtests(tests = [\"all\"]; ncores::Int = ceil(Int, Sys.CPU_THREADS / 2),\n+function runtests(tests = [\"all\"]; ncores::Int = ceil(Int, Sys.EFFECTIVE_CPU_THREADS / 2),\n                   exit_on_error::Bool=false,\n                   revise::Bool=false,\n                   propagate_project::Bool=false,"
    },
    {
      "sha": "bd7cc1339a21ecd21995441ef1e23b37d705e091",
      "filename": "doc/src/base/constants.md",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/612ac77721a17d70c2688c70519599a72adc72e4/doc%2Fsrc%2Fbase%2Fconstants.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/612ac77721a17d70c2688c70519599a72adc72e4/doc%2Fsrc%2Fbase%2Fconstants.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fbase%2Fconstants.md?ref=612ac77721a17d70c2688c70519599a72adc72e4",
      "patch": "@@ -10,6 +10,7 @@ Base.DEPOT_PATH\n Base.LOAD_PATH\n Base.Sys.BINDIR\n Base.Sys.CPU_THREADS\n+Base.Sys.EFFECTIVE_CPU_THREADS\n Base.Sys.WORD_SIZE\n Base.Sys.KERNEL\n Base.Sys.ARCH"
    },
    {
      "sha": "1f1ed18e880a2c05fc84afcedcae12cc3f04913b",
      "filename": "src/aotcompile.cpp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/612ac77721a17d70c2688c70519599a72adc72e4/src%2Faotcompile.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/612ac77721a17d70c2688c70519599a72adc72e4/src%2Faotcompile.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Faotcompile.cpp?ref=612ac77721a17d70c2688c70519599a72adc72e4",
      "patch": "@@ -2010,7 +2010,7 @@ static unsigned compute_image_thread_count(const ModuleInfo &info) {\n         return 1;\n     }\n \n-    unsigned threads = std::max(jl_cpu_threads() / 2, 1);\n+    unsigned threads = std::max(jl_effective_threads() / 2, 1);\n \n     auto max_threads = info.globals / 100;\n     if (max_threads < threads) {"
    },
    {
      "sha": "96495fef44c2b269efbdf13f2ca1d0886faa6469",
      "filename": "src/threading.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/612ac77721a17d70c2688c70519599a72adc72e4/src%2Fthreading.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/612ac77721a17d70c2688c70519599a72adc72e4/src%2Fthreading.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fthreading.c?ref=612ac77721a17d70c2688c70519599a72adc72e4",
      "patch": "@@ -757,7 +757,7 @@ void jl_init_threading(void)\n         }\n     }\n \n-    int cpu = jl_cpu_threads();\n+    int cpu = jl_effective_threads();\n     jl_n_markthreads = jl_options.nmarkthreads - 1;\n     jl_n_sweepthreads = jl_options.nsweepthreads;\n     if (jl_n_markthreads == -1) { // --gcthreads not specified\n@@ -839,7 +839,7 @@ void jl_start_threads(void)\n     // default pool according to a 'compact' policy\n     // non-exclusive: no affinity settings; let the kernel move threads about\n     if (exclusive) {\n-        if (ndefault_threads > jl_cpu_threads()) {\n+        if (ndefault_threads > jl_effective_threads()) {\n             jl_printf(JL_STDERR, \"ERROR: Too many threads requested for %s option.\\n\", MACHINE_EXCLUSIVE_NAME);\n             exit(1);\n         }"
    },
    {
      "sha": "b7e35e6e1466229d69047cfb4fd2da01bfd32112",
      "filename": "test/runtests.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/612ac77721a17d70c2688c70519599a72adc72e4/test%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/612ac77721a17d70c2688c70519599a72adc72e4/test%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fruntests.jl?ref=612ac77721a17d70c2688c70519599a72adc72e4",
      "patch": "@@ -116,7 +116,7 @@ cd(@__DIR__) do\n     # multiple worker processes regardless of the value of `net_on`.\n     # Otherwise, we use multiple worker processes if and only if `net_on` is true.\n     if net_on || JULIA_TEST_USE_MULTIPLE_WORKERS\n-        n = min(Sys.CPU_THREADS, length(tests))\n+        n = min(Sys.EFFECTIVE_CPU_THREADS, length(tests))\n         n > 1 && addprocs_with_testenv(n)\n         LinearAlgebra.BLAS.set_num_threads(1)\n     end"
    }
  ]
}