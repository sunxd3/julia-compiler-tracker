{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59870",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59870/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59870/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59870/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59870",
  "id": 3524600481,
  "node_id": "PR_kwDOABkWpM6uOyC_",
  "number": 59870,
  "title": "Move JuliaSyntax + JuliaLowering into the main tree",
  "user": {
    "login": "c42f",
    "id": 601473,
    "node_id": "MDQ6VXNlcjYwMTQ3Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/601473?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/c42f",
    "html_url": "https://github.com/c42f",
    "followers_url": "https://api.github.com/users/c42f/followers",
    "following_url": "https://api.github.com/users/c42f/following{/other_user}",
    "gists_url": "https://api.github.com/users/c42f/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/c42f/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/c42f/subscriptions",
    "organizations_url": "https://api.github.com/users/c42f/orgs",
    "repos_url": "https://api.github.com/users/c42f/repos",
    "events_url": "https://api.github.com/users/c42f/events{/privacy}",
    "received_events_url": "https://api.github.com/users/c42f/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4232017300,
      "node_id": "LA_kwDOABkWpM78P3WU",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/don't%20squash",
      "name": "don't squash",
      "color": "ff4500",
      "default": false,
      "description": "Don't squash merge"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 43,
  "created_at": "2025-10-17T05:41:20Z",
  "updated_at": "2025-11-16T13:27:15Z",
  "closed_at": "2025-11-14T19:15:55Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59870",
    "html_url": "https://github.com/JuliaLang/julia/pull/59870",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59870.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59870.patch",
    "merged_at": "2025-11-14T19:15:55Z"
  },
  "body": "There's been some interest in having the new Julia compiler frontend (JuliaSyntax + JuliaLowering) in the main Julia tree so that these are easier to work on together and so the new lowering code can co-evolve with changes to Core more easily.\r\n\r\nHere's a simple sketch for moving both these libraries into the main tree as separate top level modules in the JuliaSyntax and JuliaLowering subdirectories. For git history, I've used`git-filter-repo` to rewrite the history of both repositories into their respective subdirectories. At the same time some light rewriting was performed to avoid confusion for commit messages referring to issue numbers.  For example, if a commit in the JuliaSyntax history refers to #256, that will be rewritten to the string JuliaLang/JuliaSyntax.jl#256.  (Note for completeness that the history of these projects also includes the git history of Tokenize.jl which is the origin of the lexer.)\r\n\r\nThere's a few questions / TODOs I'd like to consider before merging this:\r\n\r\n### How do we do CI of JuliaSyntax against old Julia versions?\r\n\r\nJuliaSyntax currently supports Julia versions back to 1.0 (!!) Admittedly this may be excessive, but we should keep the JuliaSyntax registered in General working for at least some older Julia versions.\r\n\r\nThe problem is I know very little about how to set this up and I'd like advice or help :) @IanButterworth I can see you're active with both build kite and github actions infrastructure - I hoped you might have some thoughts or be able to point me in the right direction? Presumably we download pre-built versions from `julialang-s3.julialang.org` and test the JuliaSyntax module against those in addition to the current dev version of Julia.\r\n\r\n### Easing the archiving of JuliaLang/JuliaSyntax\r\n\r\nThere's enough open PRs on JuliaSyntax that it'd be nice to make migrating those to the main Julia repository easy. My rough plan is to filter all branches while running `git-filter-repo` and push those filtered branches to JuliaLang/JuliaSyntax. Then PR authors should be able to grab the filtered version of their branch and apply it to the main Julia repo without issues.  I haven't figured out the details of this yet but it should be done in one `git-filter-repo` run to ensure consistency of version hashes.\r\n\r\nWhen this is done I'll also move c42f/JuliaLowering.jl into JuliaLang/JuliaLowering.jl and archive it so there's a more permanent home for the associated github issue and PR discussions.\r\n\r\n### What should these modules be called?\r\n\r\nI hesitate to bring this up because it might become a distraction. But if we want to rename either of these modules it makes sense to do it now while we're moving git histories around.\r\n\r\nOriginally, `JuliaSyntax` was named that way because there was a very old and obsolete `JuliaParser` already taking the name, and the prefix \"Julia\" was used for clarity given that it was going into the General registry. (Also, the parser work was started as an experimental side project and taking a canonical name seemed rather too bold :sweat_smile:) If we want to claim a more canonical name at this point we might consider renaming it to `Parser`.  (Of course we could take `JuliaParser` as a name, but that seems marginal enough that we may as well stick with the existing name.)\r\n\r\n`JuliaLowering` was named with the same convention but if we change the JuliaSyntax name to just Parser we might also consider renaming JuliaLowering to something like `Lowering` or `CodeLowering`.  `CompilerFrontend` is also a tempting name but not including the parser in the \"compiler frontend\" would be a bit weird.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59870/reactions",
    "total_count": 21,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 10,
    "confused": 0,
    "heart": 10,
    "rocket": 1,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59870/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "b067eddee4ee0afc7c0ea1304b68c5af07c3d5ca",
      "filename": "JuliaLowering/.gitignore",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2F.gitignore",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2F.gitignore",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2F.gitignore?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1 @@\n+/Manifest.toml"
    },
    {
      "sha": "62a00d053a4289bdc96238f7ad73c41802669143",
      "filename": "JuliaLowering/LICENSE",
      "status": "added",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2FLICENSE",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2FLICENSE",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2FLICENSE?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,21 @@\n+MIT License\n+\n+Copyright (c) 2024 JuliaHub and contributors\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."
    },
    {
      "sha": "4add188a89eef4beed10c05a233802cba0a289f6",
      "filename": "JuliaLowering/Project.toml",
      "status": "added",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2FProject.toml?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,22 @@\n+name = \"JuliaLowering\"\n+uuid = \"f3c80556-a63f-4383-b822-37d64f81a311\"\n+authors = [\"Claire Foster <aka.c42f@gmail.com> and contributors\"]\n+version = \"1.0.0-DEV\"\n+\n+[deps]\n+JuliaSyntax = \"70703baa-626e-46a2-a12c-08ffd08c73b4\"\n+\n+[sources]\n+JuliaSyntax = {path = \"../JuliaSyntax\"}\n+\n+[compat]\n+julia = \"1\"\n+\n+[extras]\n+Test = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n+Markdown = \"d6f4376e-aef5-505a-96c1-9c027394607a\"\n+FileWatching = \"7b1f6079-737a-58dc-b8bc-7a2ca5c1b5ee\"\n+REPL = \"3fa0cd96-eef1-5676-8a61-b3b8758bbffb\"\n+\n+[targets]\n+test = [\"Test\", \"FileWatching\", \"Markdown\", \"REPL\"]"
    },
    {
      "sha": "5ebe02b95688dae579f03737c3ec99d6383df6ce",
      "filename": "JuliaLowering/README.md",
      "status": "added",
      "additions": 954,
      "deletions": 0,
      "changes": 954,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2FREADME.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2FREADME.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2FREADME.md?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,954 @@\n+# JuliaLowering\n+\n+[![Build Status](https://github.com/c42f/JuliaLowering.jl/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/c42f/JuliaLowering.jl/actions/workflows/CI.yml?query=branch%3Amain)\n+\n+JuliaLowering.jl is an experimental port of Julia's code lowering compiler\n+passes, written in Julia itself. \"Code lowering\" is the set of compiler passes\n+which *symbolically* transform and simplify Julia's syntax prior to type\n+inference.\n+\n+## Goals\n+\n+This work is intended to\n+* Bring precise code provenance to Julia's lowered form (and eventually\n+  downstream in type inference, stack traces, etc). This has many benefits\n+    - Talk to users precisely about their code via character-precise error and\n+      diagnostic messages from lowering\n+    - Greatly simplify the implementation of critical tools like Revise.jl\n+      which rely on analyzing how the user's source maps to the compiler's data\n+      structures\n+    - Allow tools like JuliaInterpreter to use type-inferred and optimized\n+      code, with the potential for huge speed improvements.\n+* Bring improvements for macro authors\n+    - Prototype \"automatic hygiene\" (no more need for `esc()`!)\n+    - Precise author-defined error reporting from macros\n+    - Sketch better interfaces for syntax trees (hopefully!)\n+\n+## Trying it out\n+\n+Note this is a work in progress; many types of syntax are not yet handled.\n+\n+1. You need a 1.13.0-DEV build of Julia: At least 1.13.0-DEV.880. Commit `5ebc5b463ea` is currently known to work. Note that JuliaLowering relies on Julia internals and may be broken on the latest Julia dev version from time to time.\n+2. Use commit `e02f29f` of [JuliaSyntax](https://github.com/JuliaLang/JuliaSyntax.jl)\n+3. Get the latest version of [JuliaSyntaxFormatter](https://github.com/c42f/JuliaSyntaxFormatter.jl)\n+4. Run the demo `include(\"test/demo.jl\")`\n+\n+# Design notes\n+\n+## Syntax trees\n+\n+Want something something better than `JuliaSyntax.SyntaxNode`! `SyntaxTree` and\n+`SyntaxGraph` provide this. Some future version of these should end up in\n+`JuliaSyntax`.\n+\n+We want to allow arbitrary attributes to be attached to tree nodes by analysis\n+passes. This separates the analysis pass implementation from the data\n+structure, allowing passes which don't know about each other to act on a shared\n+data structure.\n+\n+Design and implementation inspiration comes in several analogies:\n+\n+Analogy 1: the ECS (Entity-Component-System) pattern for computer game design.\n+This pattern is highly successful because it separates game logic (systems)\n+from game objects (entities) by providing flexible storage\n+* Compiler passes are \"systems\"\n+* AST tree nodes are \"entities\"\n+* Node attributes are \"components\"\n+\n+Analogy 2: The AoS to SoA transformation. But here we've got a kind of\n+tree-of-structs-with-optional-attributes to struct-of-Dicts transformation.\n+The data alignment / packing efficiency and concrete type safe storage benefits\n+are similar.\n+\n+Analogy 3: Graph algorithms which represent graphs as a compact array of node\n+ids and edges with integer indices, rather than using a linked data structure.\n+\n+### References\n+\n+Sander Mertens, the author of the Flecs ECS has a blog post series discussing\n+ECS data structures and the many things that may be done with them. We may want\n+to use some of these tricks to make `SyntaxTree` faster, eventually. See, for\n+example,\n+[Building Games in ECS with Entity Relationships](https://ajmmertens.medium.com/building-games-in-ecs-with-entity-relationships-657275ba2c6c)\n+\n+### Structural assertions / checking validity of syntax trees\n+\n+Syntax trees in Julia `Expr` form are very close to lisp lists: a symbol at the\n+`head` of the list which specifies the syntactic form, and a sequence of\n+children in the syntax tree. This is a representation which `JuliaSyntax` and\n+`JuliaLowering` follow but it does come with certain disadvantages. One of the\n+most problematic is that the number of children affects the validity (and\n+sometimes semantics) of an AST node, as much as the `head` symbol does.\n+\n+In `JuliaSyntax` we've greatly reduced the overloading of `head` in order to\n+simplify the interpretation of child structures in the tree. For example,\n+broadcast calls like `f.(x,y)` use the `K\"dotcall\"` kind rather than being a\n+node with `head == Symbol(\".\")` and a tuple as children.\n+\n+However, there's still many ways for lowering to encounter invalid expressions\n+of type `SyntaxTree` and these must be checked. In JuliaSyntax we have several\n+levels of effort corresponding to the type of errors conditions we desire to\n+check and report:\n+\n+* For invalid syntax which is accepted by the `JuliaSyntax`\n+  parser but is invalid in lowering we use manual `if` blocks followed by\n+  throwing a `LoweringError`. This is more programming effort but allows for\n+  the highest quality error messages for the typical end user.\n+* For invalid syntax which can only be produced by macros (ie, not by the\n+  parser) we mostly use the `@chk` macro. This is a quick tool for validating\n+  input but gives lesser quality error messages.\n+* For JuliaLowering's internal invariants we just use `@assert` - these should\n+  never be hit and can be compiled out in principle.\n+\n+## Provenance tracking\n+\n+Expression provenance is tracked through lowering by attaching provenance\n+information in the `source` attribute to every expression as it is generated.\n+For example when parsing a source file we have\n+\n+```julia\n+julia> ex = parsestmt(SyntaxTree, \"a + b\", filename=\"foo.jl\")\n+SyntaxTree with attributes kind,value,name_val,syntax_flags,source\n+[call-i]                                \u2502\n+  a                                     \u2502\n+  +                                     \u2502\n+  b                                     \u2502\n+\n+julia> ex[3].source\n+a + b\n+#   \u2559 \u2500\u2500 these are the bytes you're looking for \ud83d\ude0a\n+```\n+\n+The `provenance` function should be used to look up the `source` attribute and\n+the `showprov` function used to inspect the content (this is preferred because\n+the encoding of `source` is an implementation detail). For example:\n+\n+```julia\n+julia> showprov(ex[3])\n+a + b\n+#   \u2559 \u2500\u2500 in source\n+# @ foo.jl:1\n+```\n+\n+During macro expansion and lowering provenance gets more complicated because an\n+expression can arise from multiple sources. For example, we want to keep track\n+of the entire stack of macro expansions an expression was generated by, while\n+also recording where it occurred in the original source file.\n+\n+For this, we use a tree data structure. Let's look at the following pair of\n+macros\n+\n+```julia\n+julia> JuliaLowering.include_string(Main, raw\"\"\"\n+       module M\n+           macro inner()\n+               :(2)\n+           end\n+\n+           macro outer()\n+               :((1, @inner))\n+           end\n+       end\n+       \"\"\", \"some_macros.jl\")\n+```\n+\n+The tree which arises from macro expanding this is pretty simple:\n+\n+```julia\n+julia> expanded = JuliaLowering.macroexpand(Main, parsestmt(SyntaxTree, \"M.@outer()\"))\n+SyntaxTree with attributes scope_layer,kind,value,var_id,name_val,syntax_flags,source\n+[tuple-p]                               \u2502\n+  1                                     \u2502\n+  2                                     \u2502\n+```\n+\n+but the provenance information recorded for the second element `2` of this\n+tuple is not trivial; it includes the macro call expressions for `@inner` and\n+`@outer`. We can show this in tree form:\n+\n+```julia\n+julia> showprov(expanded[2], tree=true)\n+2\n+\u251c\u2500 2\n+\u2502  \u2514\u2500 @ some_macros.jl:3\n+\u2514\u2500 (macrocall @inner)\n+   \u251c\u2500 (macrocall @inner)\n+   \u2502  \u2514\u2500 @ some_macros.jl:7\n+   \u2514\u2500 (macrocall-p (. M @outer))\n+      \u2514\u2500 @ foo.jl:1\n+```\n+\n+or as a more human readable flattened list highlighting of source ranges:\n+\n+```julia\n+module M\n+    macro inner()\n+        :(2)\n+#         \u2559 \u2500\u2500 in source\n+    end\n+\n+# @ some_macros.jl:3\n+\n+\n+    macro outer()\n+        :((1, @inner))\n+#             \u2514\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 in macro expansion\n+    end\n+end\n+# @ some_macros.jl:7\n+\n+M.@outer()\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 in macro expansion\n+# @ foo.jl:1\n+```\n+\n+## Problems with Hygiene in Julia's exiting macro system\n+\n+To write correct hygienic macros in Julia (as of 2024), macro authors must use\n+`esc()` on any any syntax passed to the macro so that passed identifiers escape\n+to the macro caller scope. However\n+\n+* This is not automatic and the correct use of `esc()` is one of the things\n+  that new macro authors find most confusing. (My impression, based on various\n+  people complaining about how confusing `esc()` is.)\n+* `esc()` wraps expressions in `Expr(:escape)`, but this doesn't work well when\n+  macros pass such escaped syntax to an inner macro call. As discussed in\n+  [Julia issue #37691](https://github.com/JuliaLang/julia/issues/37691), macros\n+  in Julia's existing system are not composable by default. Writing\n+  composable macros in the existing system would require preserving the escape\n+  nesting depth when recursing into any macro argument nested expressions.\n+  Almost no macro author knows how to do this and is prepared to pay for the\n+  complexity of getting it right.\n+\n+The requirement to use `esc()` stems from Julia's pervasive use of the simple\n+`Expr` data structure which represents a unadorned AST in which names are plain\n+symbols. For example, a macro call `@foo x` gets passed the  symbol `:x`\n+which is just a name without any information attached to indicate that it came\n+from the scope where `@foo` was called.\n+\n+### Hygiene References\n+\n+* [Toward Fearless Macros](https://lambdaland.org/posts/2023-10-17_fearless_macros) -\n+  a blog post by Ashton Wiersdorf\n+* [Towards the Essence of Hygiene](https://michaeldadams.org/papers/hygiene/hygiene-2015-popl-authors-copy.pdf) - a paper by Michael Adams\n+* [Bindings as sets of scopes](https://www-old.cs.utah.edu/plt/scope-sets/) - a description of Racket's scope set mechanism by Matthew Flatt\n+\n+# Overview of lowering passes\n+\n+JuliaLowering uses six symbolic transformation passes:\n+\n+1. Macro expansion - expanding user-defined syntactic constructs by running the\n+   user's macros. This pass also includes a small amount of other symbolic\n+   simplification.\n+2. Syntax desugaring - simplifying Julia's rich surface syntax down to a small\n+   number of syntactic forms.\n+3. Scope analysis - analyzing identifier names used in the code to discover\n+   local variables, closure captures, and associate global variables to the\n+   appropriate module. Transform all names (kind `K\"Identifier\"`) into binding\n+   IDs (kind `K\"BindingId\"`) which can be looked up in a table of bindings.\n+4. Closure conversion - convert closures to types and deal with captured\n+   variables efficiently where possible.\n+5. Flattening to untyped IR - convert code in hierarchical tree form to a\n+   flat array of statements; convert control flow into gotos.\n+6. Convert untyped IR to `CodeInfo` form for integration with the Julia runtime.\n+\n+## Pass 1: Macro expansion\n+\n+This pass expands macros and quoted syntax, and does some very light conversion\n+of a few syntax `Kind`s in preparation for syntax desugaring.\n+\n+### Hygiene in JuliaLowering\n+\n+In JuliaLowering we make hygiene automatic and remove `esc()` by combining names\n+with scope information. In the language of the paper [*Towards the Essence of\n+Hygiene*](https://michaeldadams.org/papers/hygiene/hygiene-2015-popl-authors-copy.pdf)\n+by Michael Adams, this combination is called a \"syntax object\". In\n+JuliaLowering our representation is the tuple `(name,scope_layer)`, also called\n+`VarId` in the scope resolution pass.\n+\n+JuliaLowering's macro expander attaches a unique *scope layer* to each\n+identifier in a piece of syntax. A \"scope layer\" is an integer identifier\n+combined with the module in which the syntax was created.\n+\n+When expanding macros,\n+\n+* Any identifiers passed to the macro are tagged with the scope layer they were\n+  defined within.\n+* A new unique scope layer is generated for the macro invocation, and any names\n+  in the syntax produced by the macro are tagged with this layer.\n+\n+Subsequently, the `(name,scope_layer)` pairs are used when resolving bindings.\n+This ensures that, by default, we satisfy the basic rules for hygienic macros\n+discussed in Adams' paper:\n+\n+1. A macro can't insert a binding that can capture references other than those\n+   inserted by the macro.\n+2. A macro can't insert a reference that can be captured by bindings other than\n+   those inserted by the macro.\n+\n+TODO: Write more here...\n+\n+\n+### Compatibility with `Expr` macros\n+\n+In order to have compatibility with old-style macros which expect an `Expr`-based\n+data structure as input, we convert `SyntaxTree` to `Expr`, call the old-style\n+macro, then convert `SyntaxTree` back to `Expr` and continue with the expansion\n+process. This involves some loss of provenance precision but allows full\n+interoperability in the package ecosystem without a need to make breaking\n+changes.\n+\n+Let's look at an example. Suppose a manually escaped old-style macro\n+`@oldstyle` is implemented as\n+\n+```julia\n+macro oldstyle(a, b)\n+    quote\n+        x = \"x in @oldstyle\"\n+        @newstyle $(esc(a)) $(esc(b)) x\n+    end\n+end\n+```\n+\n+along with two correctly escaped new-style macros:\n+\n+```julia\n+macro call_oldstyle_macro(y)\n+    quote\n+        x = \"x in call_oldstyle_macro\"\n+        @oldstyle $y x\n+    end\n+end\n+\n+macro newstyle(x, y, z)\n+    quote\n+        x = \"x in @newstyle\"\n+        ($x, $y, $z, x)\n+    end\n+end\n+```\n+\n+Then want some code like the following to \"just work\" with respect to hygiene\n+\n+```julia\n+let\n+    x = \"x in outer ctx\"\n+    @call_oldstyle_macro x\n+end\n+```\n+\n+When calling `@oldstyle`, we must convert `SyntaxTree` into `Expr`, but we need\n+to preserve the scope layer of the `x` from the outer context as it is passed\n+into `@oldstyle` as a macro argument. To do this, we use `Expr(:scope_layer,\n+:x, outer_layer_id)`. (In the old system, this would be `Expr(:escape, :x)`\n+instead, presuming that `@call_oldstyle_macro` was implemented using `esc()`.)\n+\n+When receiving output from old style macro invocations, we preserve the escape\n+handling of the existing system for any symbols which aren't tagged with a\n+scope layer.\n+\n+## Pass 2: Syntax desugaring\n+\n+This pass recursively converts many special surface syntax forms to a smaller\n+set of syntax `Kind`s, following the AST's hierarchical tree structure. Some\n+such as `K\"scope_block\"` are internal to lowering and removed during later\n+passes. See `kinds.jl` for a list of these internal forms.\n+\n+This pass is implemented in `desugaring.jl`. It's quite large because Julia has\n+many special syntax features.\n+\n+### Desugaring of function definitions\n+\n+Desugaring of function definitions is particularly complex because of the cross\n+product of features which need to work together consistently:\n+\n+* Positional arguments (with and without defaults, with and without types)\n+* Keyword arguments (with and without defaults, with and without types)\n+* Type parameters with `where` syntax\n+* Argument slurping syntax with `...`\n+* Fancy arguments (argument destructuring)\n+\n+The combination of positional arguments with defaults and keyword arguments is\n+particularly complex. Here's an example.  Suppose we're given the function\n+definition\n+\n+```julia\n+function f(a::A=a_default, b::B=b_default; x::X=x_default,y::Y=y_default)\n+    body\n+end\n+```\n+\n+This generates\n+* One method of `f` for each number of positional arguments which can be\n+  called when `f` is called without keyword args\n+* One overload of `Core.kwcall(kws, ::typeof(f), ...)` for each number of\n+  positional arguments (when called with a nonzero number of keyword args; the\n+  tuple `kws` being constructed by the caller)\n+* One internal method for the body of the function (we can call it `f_kw`\n+  though it will be named something like `#f#18`)\n+\n+First, partially expanding the kw definitions this roughly looks like\n+\n+```julia\n+function f_kw(x::X, y::X, f_self::typeof(f), a::A, b::B)\n+    body\n+end\n+\n+function f(a::A=a_default, b::B=b_default)\n+    f_kw(x_default, y_default, var\"#self#\", a, b)\n+end\n+\n+function Core.kwcall(kws::NamedTuple, self::typeof(f), a::A=a_default, b::B=b_default)\n+    if Core.isdefined(kws, :x)\n+        x_tmp = Core.getfield(kws, :x)\n+        if x_tmp isa X\n+            nothing\n+        else\n+            Core.throw($(Expr(:new, Core.TypeError, Symbol(\"keyword argument\"), :x, X, x_tmp)))\n+        end\n+        x = x_tmp\n+    else\n+        x = 1\n+    end\n+    if Core.isdefined(kws, :y)\n+        y_tmp = Core.getfield(kws, :y)\n+        if y_tmp isa Y\n+            nothing\n+        else\n+            Core.throw($(Expr(:new, Core.TypeError, Symbol(\"keyword argument\"), :y, Y, y_tmp)))\n+        end\n+        y = y_tmp\n+    else\n+        y = 2\n+    end\n+    if Base.isempty(Base.diff_names(Base.keys(kws), (:x, :y)))\n+        nothing\n+    else\n+        # Else unsupported kws\n+        Base.kwerr(kws, self, a, b)\n+    end\n+    f_kw(x, y, self, a, b)\n+end\n+```\n+\n+We can then pass this to function expansion for default arguments which expands\n+each of the above into three more methods. For example, for the first\n+definition we conceptually expand `f(a::A=a_default, b::B=b_default)` into the\n+methods\n+\n+```julia\n+# The body\n+function f(a::A, b::B)\n+    f_kw(x_default, y_default, var\"#self#\", a, b)\n+end\n+\n+# And two methods for the different numbers of default args\n+function f(a::A)\n+    var\"#self#\"(a, b_default)\n+end\n+\n+function f()\n+    var\"#self#\"(a_default, b_default)\n+end\n+```\n+\n+In total, this expands a single \"function definition\" into seven methods.\n+\n+Note that the above is only a sketch! There's more fiddly details when `where`\n+syntax comes in\n+\n+### Desugaring of generated functions\n+\n+A brief description of how this works. Let's consider the generated function\n+\n+```julia\n+function gen(x::NTuple{N}, y) where {N,T}\n+    shared = :shared\n+    # Unnecessary use of @generated, but it shows what's going on.\n+    if @generated\n+        quote\n+            maybe_gen = ($x, $N)\n+        end\n+    else\n+        maybe_gen = (typeof(x), N)\n+    end\n+    (shared, maybe_gen)\n+end\n+```\n+\n+This is desugared into the following two function definitions. First, a code\n+generator which will generate code for the body of the function, given the\n+static parameters `N`, `T` and the positional arguments `x`, `y`.\n+(`var\"#self#\"::Type{typeof(gen)}` is also provided by the Julia runtime to\n+complete the full signature of `gen`, though the user won't normally use this.)\n+\n+```julia\n+function var\"#gen@generator#0\"(__context__::JuilaSyntax.MacroContext, N, T, var\"#self#\", x, y)\n+    gen_stuff = quote\n+        maybe_gen = ($x, $N)\n+    end\n+    quote\n+        shared = :shared\n+        $gen_stuff\n+        (shared, maybe_gen)\n+    end\n+end\n+```\n+\n+Second, the non-generated version, using the `if @generated` else branches, and\n+containing mostly normal code.\n+\n+```julia\n+function gen(x::NTuple{N}, y) where {N,T}\n+    $(Expr(:meta, :generated,\n+        Expr(:call, JuliaLowering.GeneratedFunctionStub,\n+             :var\"#gen@generator#0\", sourceref_of_gen,\n+             :(Core.svec(:var\"#self\", :x, :y))\n+             :(Core.svec(:N, :T)))))\n+    shared = :shared\n+    maybe_gen = (typeof(x), N)\n+    (shared, maybe_gen)\n+end\n+```\n+\n+The one extra thing added here is the `Expr(:meta, :generated)` which is an\n+expression creating a callable wrapper for the user's generator, to be\n+evaluated at top level. This wrapper will then be invoked by the runtime\n+whenever the user calls `gen` with a new signature and it's expected that a\n+`CodeInfo` be returned from it. `JuliaLowering.GeneratedFunctionStub` differs\n+from `Core.GeneratedFunctionStub` in that it contains extra provenance\n+information (the `sourcref_of_gen`) and expects a `SyntaxTree` to be returned\n+by the user's generator code.\n+\n+## Pass 3: Scope analysis / binding resolution\n+\n+This pass replaces variables with bindings of kind `K\"BindingId\"`,\n+disambiguating variables when the same name is used in different scopes. It\n+also fills in the list of non-global bindings within each lambda and metadata\n+about such bindings as will be used later during closure conversion.\n+\n+Scopes are documented in the Juila documentation on\n+[Scope of Variables](https://docs.julialang.org/en/v1/manual/variables-and-scoping/)\n+\n+During scope resolution, we maintain a stack of `ScopeInfo` data structures.\n+\n+When a new `lambda` or `scope_block` is discovered, we create a new `ScopeInfo` by\n+1. Find all identifiers bound or used within a scope. New *bindings* may be\n+   introduced by one of the `local`, `global` keywords, implicitly by\n+   assignment, as function arguments to a `lambda`, or as type arguments in a\n+   method (\"static parameters\"). Identifiers are *used* when they are\n+   referenced.\n+2. Infer which bindings are newly introduced local or global variables (and\n+   thus require a distinct identity from names already in the stack)\n+3. Assign a `BindingId` (unique integer) to each new binding\n+\n+We then push this `ScopeInfo` onto the stack and traverse the expressions\n+within the scope translating each `K\"Identifier\"` into the associated\n+`K\"BindingId\"`. While we're doing this we also resolve some special forms like\n+`islocal` by making use of the scope stack.\n+\n+The detailed rules for whether assignment introduces a new variable depend on\n+the `scope_block`'s `scope_type` attribute when we are processing top-level\n+code.\n+* `scope_type == :hard` (as for bindings inside a `let` block) means an\n+  assignment always introduces a new binding\n+* `scope_type == :neutral` - inherit soft or hard scope from the parent scope.\n+* `scope_type == :soft` - assignments are to globals if the variable\n+  exists in global module scope. Soft scope doesn't have surface syntax and is\n+  introduced for top-level code by REPL-like environments.\n+\n+## Pass 4: Closure conversion / lower bindings\n+\n+The main goal of this pass is closure conversion, but it's also used for\n+lowering typed bindings and global assignments. Roughly, this is passes 3 and 4\n+in the original `julia-syntax.scm`. In JuliaLowering it also comes in two steps:\n+\n+The first step (part of `scope_resolution.jl`) is to compute metadata related\n+to bindings, both per-binding and per-binding-per-closure-scope.\n+\n+Properties which are computed per-binding which can help with symbolic\n+optimizations include:\n+* Type is declared (`x::T` syntax in a statement): type conversions must be\n+  inserted at every assignment of `x`.\n+* Never undefined: value is always assigned to the binding before being read\n+  hence this binding doesn't require the use of `Core.NewvarNode`.\n+* Single assignment: (TODO how is this defined, what is it for and does it go\n+  here or below?)\n+\n+Properties of non-globals which are computed per-binding-per-closure include:\n+* Read: the value of the binding is used.\n+* Write: the binding is assigned to.\n+* Captured: Bindings defined outside the closure which are either Read or Write\n+  within the closure are \"captured\" and need to be one of the closure's fields.\n+* Called: the binding is called as a function, ie, `x()`. (TODO - what is this\n+  for?)\n+\n+The second step uses this metadata to\n+* Convert closures into `struct` types\n+* Lower bindings captured by closures into references to boxes as necessary\n+* Deal with typed bindings (`K\"decl\"`) and their assignments\n+* Lower const and non-const global assignments\n+* TODO: probably more here.\n+\n+\n+### Q&A\n+\n+#### When does `function` introduce a closure?\n+\n+Closures are just functions where the name of the function is *local* in scope.\n+How does the function name become a local? The `function` keyword acts like an\n+assignment to the function name for the purposes of scope resolution. Thus\n+`function f() body end` is rather like `f = ()->body` and may result in the\n+symbol `f` being either `local` or `global`. Like other assignments, `f` may be\n+declared global or local explicitly, but if not `f` is subject to the usual\n+rules for assignments inside scopes. For example, inside a `let` scope\n+`function f() ...` would result in the symbol `f` being local.\n+\n+Examples:\n+\n+```julia\n+begin\n+    # f is global because `begin ... end` does not introduce a scope\n+    function f()\n+        body\n+    end\n+\n+    # g is a closure because `g` is explicitly declared local\n+    local g\n+    function g()\n+        body\n+    end\n+end\n+\n+let\n+    # f is local so this is a closure because `let ... end` introduces a scope\n+    function f()\n+        body\n+    end\n+\n+    # g is not a closure because `g` is declared global\n+    global g\n+    function g()\n+        body\n+    end\n+end\n+```\n+\n+#### How do captures work with non-closures?\n+\n+Yes it's true, you can capture local variables into global methods. For example:\n+\n+```julia\n+begin\n+    local x = 1\n+    function f(y)\n+        x + y\n+    end\n+    x = 2\n+end\n+```\n+\n+The way this works is to put `x` in a `Box` and interpolate it into the AST of\n+`f` (the `Box` can be eliminated in some cases, but not here). Essentially this\n+lowers to code which is almost-equivalent to the following:\n+\n+```julia\n+begin\n+    local x = Core.Box(1)\n+    @eval function f(y)\n+        $(x.contents) + y\n+    end\n+    x.contents = 2\n+end\n+```\n+\n+#### How do captures work with closures with multiple methods?\n+\n+Sometimes you might want a closure with multiple methods, but those methods\n+might capture different local variables. For example,\n+\n+```julia\n+let\n+    x = 1\n+    y = 1.5\n+    function f(xx::Int)\n+        xx + x\n+    end\n+    function f(yy::Float64)\n+        yy + y\n+    end\n+\n+    f(42)\n+end\n+```\n+\n+In this case, the closure type must capture both `x` and `y` and the generated\n+code looks rather like this:\n+\n+```julia\n+struct TheClosureType\n+    x\n+    y\n+end\n+\n+let\n+    x = 1\n+    y = 1.5\n+    f = TheClosureType(x,y)\n+    function (self::TheClosureType)(xx::Int)\n+        xx + self.x\n+    end\n+    function (self::TheClosureType)(yy::Int)\n+        yy + self.y\n+    end\n+\n+    f(42)\n+end\n+```\n+\n+#### When are `method` defs lifted to top level?\n+\n+Closure method definitions must be lifted to top level whenever the definitions\n+appear inside a function. This is allow efficient compilation and avoid world\n+age issues.\n+\n+Conversely, when method defs appear in top level code, they are executed\n+inline.\n+\n+## Pass 5: Convert to untyped IR\n+\n+This pass is implemented in `linear_ir.jl`.\n+\n+### Untyped IR (JuliaLowering form)\n+\n+JuliaLowering's untyped IR is very close to the runtime's `CodeInfo` form (see\n+below), but is more concretely typed as `JuliaLowering.SyntaxTree`.\n+\n+Metadata is generally represented differently:\n+* The statements retain full code provenance information as `SyntaxTree`\n+  objects. See `kinds.jl` for a list of which `Kind`s occur in the output IR\n+  but not in surface syntax.\n+* The list of slots is `Vector{Slot}`, including `@nospecialize` metadata\n+\n+### Lowering of exception handlers\n+\n+Exception handling involves a careful interplay between lowering and the Julia\n+runtime. The forms `enter`, `leave` and `pop_exception` dynamically modify the\n+exception-related state on the `Task`; lowering and the runtime work together\n+to maintain correct invariants for this state.\n+\n+Lowering of exception handling must ensure that\n+\n+* Each `enter` is matched with a `leave` on every possible non-exceptional\n+  program path (including implicit returns generated in tail position).\n+* Each `catch` block which is entered and handles the exception - by exiting\n+  via a non-exceptional program path - is matched with a `pop_exception`\n+* Each `finally` block runs, regardless of the way it's entered - either by\n+  normal program flow, an exception, early `return` or a jump out of an inner\n+  context via `break`/`continue`/`goto` etc.\n+\n+The following special forms are emitted into the IR:\n+\n+* `(= tok (enter catch_label dynscope))` -\n+  push exception handler with catch block at `catch_label` and dynamic\n+  scope `dynscope`, yielding a token which is used by `leave` and\n+  `pop_exception`. `dynscope` is only used in the special `tryfinally` form\n+  without associated source level syntax (see the `@with` macro)\n+* `(leave tok)` -\n+    pop exception handler back to the state of the `tok` from the associated\n+    `enter`. Multiple tokens can be supplied to pop multiple handlers using\n+    `(leave tok1 tok2 ...)`.\n+* `(pop_exception tok)` - pop exception stack back to state of associated enter\n+\n+When an `enter` is encountered, the runtime pushes a new handler onto the\n+`Task`'s exception handler stack which will jump to `catch_label` when an\n+exception occurs.\n+\n+There are two ways that the exception-related task state can be restored\n+\n+1. By encountering a `leave` which will restore the handler state with `tok`.\n+2. By throwing an exception. In this case the runtime will pop one handler\n+   automatically and jump to the catch label with the new exception pushed\n+   onto the exception stack. On this path the exception stack state must be\n+   restored back to the associated `enter` by encountering `pop_exception`.\n+\n+Note that the handler and exception stack represent two distinct types of\n+exception-related state restoration which need to happen. Note also that the\n+\"handler state restoration\" actually includes several pieces of runtime state\n+including GC flags - see `jl_eh_restore_state` in the runtime for that.\n+\n+#### Lowering finally code paths\n+\n+When lowering `finally` blocks we want to emit the user's finally code once but\n+multiple code paths may traverse the finally block. For example, consider the\n+code\n+\n+```julia\n+function foo(x)\n+    while true\n+        try\n+            if x == 1\n+                return f(x)\n+            elseif x == 2\n+                g(x)\n+                continue\n+            else\n+                break\n+            end\n+        finally\n+            h()\n+        end\n+    end\n+end\n+```\n+\n+In this situation there's four distinct code paths through the finally block:\n+1. `return f(x)` needs to call `val = f(x)`, leave the `try` block, run `h()` then\n+   return `val`.\n+2. `continue` needs to call `h()` then jump to the start of the while loop\n+3. `break` needs to call `h()` then jump to the exit of the while loop\n+4. If an exception occurs in `f(x)` or `g(x)`, we need to call `h()` before\n+   falling back into the while loop.\n+\n+To deal with these we create a `finally_tag` variable to dynamically track\n+which action to take after the finally block exits. Before jumping to the block\n+we set this variable to a unique integer tag identifying the incoming code\n+path. At the exit of the user's code (`h()` in this case) we perform the jump\n+appropriate to the `break`, `continue` or `return` as necessary based on the tag.\n+\n+(TODO - these are the only four cases which can occur, but, for example,\n+multiple `return`s create multiple tags rather than assigning to a single\n+variable. Collapsing these into a single case might be worth considering? But\n+also might be worse for type inference in some cases?)\n+\n+## Pass 6: Convert IR to `CodeInfo` representation\n+\n+This pass convert's JuliaLowering's internal representation of untyped IR into\n+a form the Julia runtime understands. This is a necessary decoupling which\n+separates the development of JuliaLowering.jl from the evolution of the Julia\n+runtime itself.\n+\n+### Untyped IR (`CodeInfo` form)\n+\n+The final lowered IR is expressed as `CodeInfo` objects which are a sequence of\n+`code` statements containing\n+* Literals\n+* Restricted forms of `Expr` (with semantics different from surface syntax,\n+  even for the same `head`! for example the arguments to `Expr(:call)` in IR\n+  must be \"simple\" and aren't evaluated in order)\n+* `Core.SlotNumber`\n+* Other special forms from `Core` like `Core.ReturnNode`, `Core.EnterNode`, etc.\n+* `Core.SSAValue`, indexing any value generated from a statement in the `code`\n+  array.\n+* Etc (todo)\n+\n+The IR obeys certain invariants which are checked by the downstream code in\n+base/compiler/validation.jl.\n+\n+See also https://docs.julialang.org/en/v1/devdocs/ast/#Lowered-form\n+\n+CodeInfo layout (as of early 1.12-DEV):\n+\n+```julia\n+mutable struct CodeInfo\n+    code::Vector{Any}             # IR statements\n+    codelocs::Vector{Int32}       # `length(code)` Vector of indices into `linetable`\n+    ssavaluetypes::Any            # `length(code)` or Vector of inferred types after opt\n+    ssaflags::Vector{UInt32}      # flag for every statement in `code`\n+                                  #   0 if meta statement\n+                                  #   inbounds_flag - 1 bit (LSB)\n+                                  #   inline_flag   - 1 bit\n+                                  #   noinline_flag - 1 bit\n+                                  #   ... other 8 flags which are defined in compiler/optimize.jl\n+                                  #   effects_flags - 9 bits\n+    method_for_inference_limit_heuristics::Any\n+    linetable::Any\n+    slotnames::Vector{Symbol}     # names of parameters and local vars used in the code\n+    slotflags::Vector{UInt8}      # vinfo flags from flisp\n+    slottypes::Any                # nothing (used by typeinf)\n+    rettype::Any                  # Any (used by typeinf)\n+    parent::Any                   # nothing (used by typeinf)\n+    edges::Any\n+    min_world::UInt64\n+    max_world::UInt64\n+    inferred::Bool\n+    propagate_inbounds::Bool\n+    has_fcall::Bool\n+    nospecializeinfer::Bool\n+    inlining::UInt8\n+    constprop::UInt8\n+    purity::UInt16\n+    inlining_cost::UInt16\n+end\n+```\n+\n+## Notes on toplevel-only forms and eval-related functions\n+\n+In the current Julia runtime,\n+\n+`Base.eval()`\n+- Uses `jl_toplevel_eval_in` which calls `jl_toplevel_eval_flex`\n+\n+`jl_toplevel_eval_flex(mod, ex)`\n+- Lowers if necessary\n+- Evaluates certain blessed top level forms\n+  * `:.`\n+  * `:module`\n+  * `:using`\n+  * `:import`\n+  * `:public`\n+  * `:export`\n+  * `:toplevel`\n+  * `:error`\n+  * `:incomplete`\n+  * Identifier and literals\n+- Otherwise expects `Expr(:thunk)`\n+  * Use codegen \"where necessary/profitable\" (eg ccall, has_loops etc)\n+  * Otherwise interpret via `jl_interpret_toplevel_thunk`\n+\n+Should we lower the above blessed top level forms to julia runtime calls?\n+Pros:\n+- Semantically sound. Lowering should do syntax checking in things like\n+  `Expr(:using)` rather than doing this in the runtime support functions.\n+- Precise lowering error messages\n+- Replaces more Expr usage\n+- Replaces a whole pile of C code with significantly less Julia code\n+- Lowering output becomes more consistently imperative\n+Cons:\n+- Lots more code to write\n+- May need to invent intermediate data structures to replace `Expr`\n+- Bootstrap?\n+- Some forms require creating toplevel thunks\n+\n+In general, we'd be replacing current *declarative* lowering targets like\n+`Expr(:using)` with an *imperative* call to a `Core` API instead. The call and\n+the setup of its arguments would need to go in a thunk. We've currently got an\n+odd mixture of imperative and declarative lowered code.\n+\n+## Bugs in Julia's lowering\n+\n+Subset of bugs which exist in upstream in flisp implementation, but which are fixed here\n+* `f()[begin]` has the side effect `f()` twice.\n+* `a[(begin=1; a=2)]` gives a weird error\n+* `function A.ccall() ; end` allows `ccall` as a name but it's not allowed without the `A.`\n+* `a .< b .< c` expands to `(a .< b) .& (b .< c)` where the scope of the `&` is\n+  the expansion module but should be `top.&` to avoid scope-dependence\n+  (especially in the presence of macros)\n+\n+## Notes on Racket's hygiene\n+\n+People look at [Racket](https://racket-lang.org/) as an example of a very\n+complete system of hygienic macros. We should learn from them, but keeping in\n+mind that Racket's macro system is inherently more complicated. Racket's\n+current approach to hygiene is described in an [accessible talk](https://www.youtube.com/watch?v=Or_yKiI3Ha4)\n+and in more depth in [a paper](https://www-old.cs.utah.edu/plt/publications/popl16-f.pdf).\n+\n+Some differences which makes Racket's macro expander different from Julia:\n+\n+* Racket allows *local* definitions of macros. Macro code can be embedded in an\n+  inner lexical scope and capture locals from that scope, but still needs to be\n+  executed at compile time. Julia supports macros at top level scope only.\n+* Racket goes to great lengths to execute the minimal package code necessary to\n+  expand macros; the \"pass system\". Julia just executes all top level\n+  statements in order when precompiling a package.\n+* As a lisp, Racket's surface syntax is dramatically simpler and more uniform"
    },
    {
      "sha": "d8ff05dd013e87e4f5406aca73b7bd062fdd018f",
      "filename": "JuliaLowering/src/JuliaLowering.jl",
      "status": "added",
      "additions": 47,
      "deletions": 0,
      "changes": 47,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2FJuliaLowering.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2FJuliaLowering.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2FJuliaLowering.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,47 @@\n+# Use a baremodule because we're implementing `include` and `eval`\n+baremodule JuliaLowering\n+\n+using Base\n+# We define a separate _include() for use in this module to avoid mixing method\n+# tables with the public `JuliaLowering.include()` API\n+const _include = Base.IncludeInto(JuliaLowering)\n+\n+if parentmodule(JuliaLowering) === Base\n+    using Base.JuliaSyntax\n+else\n+    using JuliaSyntax\n+end\n+\n+using .JuliaSyntax: highlight, Kind, @KSet_str, is_leaf, children, numchildren,\n+    head, kind, flags, has_flags, numeric_flags, filename, first_byte,\n+    last_byte, byte_range, sourcefile, source_location, span, sourcetext,\n+    is_literal, is_number, is_operator, is_prec_assignment, is_prefix_call,\n+    is_infix_op_call, is_postfix_op_call, is_error\n+\n+_include(\"kinds.jl\")\n+_register_kinds()\n+\n+_include(\"syntax_graph.jl\")\n+_include(\"ast.jl\")\n+_include(\"bindings.jl\")\n+_include(\"utils.jl\")\n+\n+_include(\"macro_expansion.jl\")\n+_include(\"desugaring.jl\")\n+_include(\"scope_analysis.jl\")\n+_include(\"closure_conversion.jl\")\n+_include(\"linear_ir.jl\")\n+_include(\"runtime.jl\")\n+_include(\"syntax_macros.jl\")\n+\n+_include(\"eval.jl\")\n+_include(\"compat.jl\")\n+_include(\"hooks.jl\")\n+\n+function __init__()\n+    _register_kinds()\n+end\n+\n+_include(\"precompile.jl\")\n+\n+end"
    },
    {
      "sha": "93f5a7c13f5c3108b8ae69f1cae1375581a193f4",
      "filename": "JuliaLowering/src/ast.jl",
      "status": "added",
      "additions": 748,
      "deletions": 0,
      "changes": 748,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fast.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fast.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fast.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,748 @@\n+#-------------------------------------------------------------------------------\n+# @chk: Basic AST structure checking tool\n+#\n+# Check a condition involving an expression, throwing a LoweringError if it\n+# doesn't evaluate to true. Does some very simple pattern matching to attempt\n+# to extract the expression variable from the left hand side.\n+#\n+# Forms:\n+# @chk pred(ex)\n+# @chk pred(ex) msg\n+# @chk pred(ex) (msg_display_ex, msg)\n+macro chk(cond, msg=nothing)\n+    if Meta.isexpr(msg, :tuple)\n+        ex = msg.args[1]\n+        msg = msg.args[2]\n+    else\n+        ex = cond\n+        while true\n+            if ex isa Symbol\n+                break\n+            elseif ex.head == :call\n+                ex = ex.args[2]\n+            elseif ex.head == :ref\n+                ex = ex.args[1]\n+            elseif ex.head == :.\n+                ex = ex.args[1]\n+            elseif ex.head in (:(==), :(in), :<, :>)\n+                ex = ex.args[1]\n+            else\n+                error(\"Can't analyze $cond\")\n+            end\n+        end\n+    end\n+    quote\n+        ex = $(esc(ex))\n+        @assert ex isa SyntaxTree\n+        ok = try\n+            $(esc(cond))\n+        catch\n+            false\n+        end\n+        if !ok\n+            throw(LoweringError(ex, $(isnothing(msg) ? \"expected `$cond`\" : esc(msg))))\n+        end\n+    end\n+end\n+\n+#-------------------------------------------------------------------------------\n+abstract type AbstractLoweringContext end\n+\n+\"\"\"\n+Bindings for the current lambda being processed.\n+\n+Lowering passes prior to scope resolution return `nothing` and bindings are\n+collected later.\n+\"\"\"\n+current_lambda_bindings(ctx::AbstractLoweringContext) = nothing\n+\n+function syntax_graph(ctx::AbstractLoweringContext)\n+    ctx.graph\n+end\n+\n+\"\"\"\n+Unique symbolic identity for a variable, constant, label, or other entity\n+\"\"\"\n+const IdTag = Int\n+\n+\"\"\"\n+Id for scope layers in macro expansion\n+\"\"\"\n+const LayerId = Int\n+\n+\"\"\"\n+A `ScopeLayer` is a mechanism for automatic hygienic macros; every identifier\n+is assigned to a particular layer and can only match against bindings which are\n+themselves part of that layer.\n+\n+Normal code contains a single scope layer, whereas each macro expansion\n+generates a new layer.\n+\"\"\"\n+struct ScopeLayer\n+    id::LayerId\n+    mod::Module\n+    parent_layer::LayerId # Index of parent layer in a macro expansion. Equal to 0 for no parent\n+    is_macro_expansion::Bool # FIXME\n+end\n+\n+#-------------------------------------------------------------------------------\n+# AST creation utilities\n+_node_id(graph::SyntaxGraph, ex::SyntaxTree) = (check_compatible_graph(graph, ex); ex._id)\n+function _node_id(graph::SyntaxGraph, ex)\n+    # Fallback to give a comprehensible error message for use with the @ast macro\n+    error(\"Attempt to use `$(repr(ex))` of type `$(typeof(ex))` as an AST node. Try annotating with `::K\\\"your_intended_kind\\\"?`\")\n+end\n+function _node_id(graph::SyntaxGraph, ex::AbstractVector{<:SyntaxTree})\n+    # Fallback to give a comprehensible error message for use with the @ast macro\n+    error(\"Attempt to use vector as an AST node. Did you mean to splat this? (content: `$(repr(ex))`)\")\n+end\n+\n+_node_ids(graph::SyntaxGraph) = ()\n+_node_ids(graph::SyntaxGraph, ::Nothing, cs...) = _node_ids(graph, cs...)\n+_node_ids(graph::SyntaxGraph, c, cs...) = (_node_id(graph, c), _node_ids(graph, cs...)...)\n+_node_ids(graph::SyntaxGraph, cs::SyntaxList, cs1...) = (_node_ids(graph, cs...)..., _node_ids(graph, cs1...)...)\n+function _node_ids(graph::SyntaxGraph, cs::SyntaxList)\n+    check_compatible_graph(graph, cs)\n+    cs.ids\n+end\n+\n+_unpack_srcref(graph, srcref::SyntaxTree) = _node_id(graph, srcref)\n+_unpack_srcref(graph, srcref::Tuple)      = _node_ids(graph, srcref...)\n+_unpack_srcref(graph, srcref)             = srcref\n+\n+function _push_nodeid!(graph::SyntaxGraph, ids::Vector{NodeId}, val)\n+    push!(ids, _node_id(graph, val))\n+end\n+function _push_nodeid!(graph::SyntaxGraph, ids::Vector{NodeId}, val::Nothing)\n+    nothing\n+end\n+function _append_nodeids!(graph::SyntaxGraph, ids::Vector{NodeId}, vals)\n+    for v in vals\n+        _push_nodeid!(graph, ids, v)\n+    end\n+end\n+function _append_nodeids!(graph::SyntaxGraph, ids::Vector{NodeId}, vals::SyntaxList)\n+    check_compatible_graph(graph, vals)\n+    append!(ids, vals.ids)\n+end\n+\n+function makeleaf(graph::SyntaxGraph, srcref, proto; attrs...)\n+    id = newnode!(graph)\n+    ex = SyntaxTree(graph, id)\n+    copy_attrs!(ex, proto, true)\n+    setattr!(graph, id; source=_unpack_srcref(graph, srcref), attrs...)\n+    return ex\n+end\n+\n+function _makenode(graph::SyntaxGraph, srcref, proto, children; attrs...)\n+    id = newnode!(graph)\n+    setchildren!(graph, id, children)\n+    ex = SyntaxTree(graph, id)\n+    copy_attrs!(ex, proto, true)\n+    setattr!(graph, id; source=_unpack_srcref(graph, srcref), attrs...)\n+    return SyntaxTree(graph, id)\n+end\n+function _makenode(ctx, srcref, proto, children; attrs...)\n+    _makenode(syntax_graph(ctx), srcref, proto, children; attrs...)\n+end\n+\n+function makenode(ctx, srcref, proto, children...; attrs...)\n+    _makenode(ctx, srcref, proto, _node_ids(syntax_graph(ctx), children...); attrs...)\n+end\n+\n+function makeleaf(ctx, srcref, proto; kws...)\n+    makeleaf(syntax_graph(ctx), srcref, proto; kws...)\n+end\n+\n+function makeleaf(ctx, srcref, k::Kind, value; kws...)\n+    graph = syntax_graph(ctx)\n+    if k == K\"Identifier\" || k == K\"core\" || k == K\"top\" || k == K\"Symbol\" ||\n+            k == K\"globalref\" || k == K\"Placeholder\" ||\n+            k == K\"StrMacroName\" || k == K\"CmdMacroName\"\n+        makeleaf(graph, srcref, k; name_val=value, kws...)\n+    elseif k == K\"BindingId\"\n+        makeleaf(graph, srcref, k; var_id=value, kws...)\n+    elseif k == K\"label\"\n+        makeleaf(graph, srcref, k; id=value, kws...)\n+    elseif k == K\"symbolic_label\"\n+        makeleaf(graph, srcref, k; name_val=value, kws...)\n+    elseif k in KSet\"TOMBSTONE SourceLocation latestworld latestworld_if_toplevel\"\n+        makeleaf(graph, srcref, k; kws...)\n+    else\n+        val = k == K\"Integer\" ? convert(Int,     value) :\n+              k == K\"Float\"   ? convert(Float64, value) :\n+              k == K\"String\"  ? convert(String,  value) :\n+              k == K\"Char\"    ? convert(Char,    value) :\n+              k == K\"Value\"   ? value                   :\n+              k == K\"Bool\"    ? value                   :\n+              error(\"Unexpected leaf kind `$k`\")\n+        makeleaf(graph, srcref, k; value=val, kws...)\n+    end\n+end\n+\n+# TODO: Replace this with makeleaf variant?\n+function mapleaf(ctx, src, kind)\n+    ex = makeleaf(syntax_graph(ctx), src, kind)\n+    # TODO: Value coercion might be broken here due to use of `name_val` vs\n+    # `value` vs ... ?\n+    copy_attrs!(ex, src)\n+    ex\n+end\n+\n+# Convenience functions to create leaf nodes referring to identifiers within\n+# the Core and Top modules.\n+core_ref(ctx, ex, name) = makeleaf(ctx, ex, K\"core\", name)\n+svec_type(ctx, ex) = core_ref(ctx, ex, \"svec\")\n+nothing_(ctx, ex) = core_ref(ctx, ex, \"nothing\")\n+\n+top_ref(ctx, ex, name) = makeleaf(ctx, ex, K\"top\", name)\n+\n+# Assign `ex` to an SSA variable.\n+# Return (variable, assignment_node)\n+function assign_tmp(ctx::AbstractLoweringContext, ex, name=\"tmp\")\n+    var = ssavar(ctx, ex, name)\n+    assign_var = makenode(ctx, ex, K\"=\", var, ex)\n+    var, assign_var\n+end\n+\n+function emit_assign_tmp(stmts::SyntaxList, ctx, ex, name=\"tmp\")\n+    if is_ssa(ctx, ex)\n+        return ex\n+    end\n+    var = ssavar(ctx, ex, name)\n+    push!(stmts, makenode(ctx, ex, K\"=\", var, ex))\n+    var\n+end\n+\n+#-------------------------------------------------------------------------------\n+# @ast macro\n+function _match_srcref(ex)\n+    if Meta.isexpr(ex, :macrocall) && ex.args[1] == Symbol(\"@HERE\")\n+        QuoteNode(ex.args[2])\n+    else\n+        esc(ex)\n+    end\n+end\n+\n+function _match_kind(f::Function, srcref, ex)\n+    kws = []\n+    if Meta.isexpr(ex, :call)\n+        kind = esc(ex.args[1])\n+        args = ex.args[2:end]\n+        if Meta.isexpr(args[1], :parameters)\n+            kws = map(esc, args[1].args)\n+            popfirst!(args)\n+        end\n+        while length(args) >= 1 && Meta.isexpr(args[end], :kw)\n+            pushfirst!(kws, esc(pop!(args)))\n+        end\n+        if length(args) == 1\n+            srcref_tmp = gensym(\"srcref\")\n+            return quote\n+                $srcref_tmp = $(_match_srcref(args[1]))\n+                $(f(kind, srcref_tmp, kws))\n+            end\n+        elseif length(args) > 1\n+            error(\"Unexpected: extra srcref argument in `$ex`?\")\n+        end\n+    else\n+        kind = esc(ex)\n+    end\n+    f(kind, srcref, kws)\n+end\n+\n+function _expand_ast_tree(ctx, srcref, tree)\n+    if Meta.isexpr(tree, :(::))\n+        # Leaf node\n+        if length(tree.args) == 2\n+            val = esc(tree.args[1])\n+            kindspec = tree.args[2]\n+        else\n+            val = nothing\n+            kindspec = tree.args[1]\n+        end\n+        _match_kind(srcref, kindspec) do kind, srcref, kws\n+            :(makeleaf($ctx, $srcref, $kind, $(val), $(kws...)))\n+        end\n+    elseif Meta.isexpr(tree, :call) && tree.args[1] === :(=>)\n+        # Leaf node with copied attributes\n+        kind = esc(tree.args[3])\n+        srcref = esc(tree.args[2])\n+        :(mapleaf($ctx, $srcref, $kind))\n+    elseif Meta.isexpr(tree, (:vcat, :hcat, :vect))\n+        # Interior node\n+        flatargs = []\n+        for a in tree.args\n+            if Meta.isexpr(a, :row)\n+                append!(flatargs, a.args)\n+            else\n+                push!(flatargs, a)\n+            end\n+        end\n+        children_ex = :(let child_ids = Vector{NodeId}(), graph = syntax_graph($ctx)\n+        end)\n+        child_stmts = children_ex.args[2].args\n+        for a in flatargs[2:end]\n+            child = _expand_ast_tree(ctx, srcref, a)\n+            if Meta.isexpr(child, :(...))\n+                push!(child_stmts, :(_append_nodeids!(graph, child_ids, $(child.args[1]))))\n+            else\n+                push!(child_stmts, :(_push_nodeid!(graph, child_ids, $child)))\n+            end\n+        end\n+        push!(child_stmts, :(child_ids))\n+        _match_kind(srcref, flatargs[1]) do kind, srcref, kws\n+            :(_makenode($ctx, $srcref, $kind, $children_ex; $(kws...)))\n+        end\n+    elseif Meta.isexpr(tree, :(:=))\n+        lhs = tree.args[1]\n+        rhs = _expand_ast_tree(ctx, srcref, tree.args[2])\n+        ssadef = gensym(\"ssadef\")\n+        quote\n+            ($(esc(lhs)), $ssadef) = assign_tmp($ctx, $rhs, $(string(lhs)))\n+            $ssadef\n+        end\n+    elseif Meta.isexpr(tree, :macrocall)\n+        esc(tree)\n+    elseif tree isa Expr\n+        Expr(tree.head, map(a->_expand_ast_tree(ctx, srcref, a), tree.args)...)\n+    else\n+        esc(tree)\n+    end\n+end\n+\n+\"\"\"\n+    @ast ctx srcref tree\n+\n+Syntactic s-expression shorthand for constructing a `SyntaxTree` AST.\n+\n+* `ctx` - SyntaxGraph context\n+* `srcref` - Reference to the source code from which this AST was derived.\n+\n+The `tree` contains syntax of the following forms:\n+* `[kind child\u2081 child\u2082]` - construct an interior node with children\n+* `value :: kind`        - construct a leaf node\n+* `ex => kind`           - convert a leaf node to the given `kind`, copying attributes\n+                           from it and also using `ex` as the source reference.\n+* `var := ex`            - Set `var=ssavar(...)` and return an assignment node `\\$var=ex`.\n+                           `var` may be used outside `@ast`\n+* `cond ? ex1 : ex2`     - Conditional; `ex1` and `ex2` will be recursively expanded.\n+                           `if ... end` and `if ... else ... end` also work with this.\n+\n+Any `kind` can be replaced with an expression of the form\n+* `kind(srcref)` - override the source reference for this node and its children\n+* `kind(attr=val)` - set an additional attribute\n+* `kind(srcref; attr\u2081=val\u2081, attr\u2082=val\u2082)` - the general form\n+\n+In any place `srcref` is used, the special form `@HERE()` can be used to instead\n+to indicate that the \"primary\" location of the source is the location where\n+`@HERE` occurs.\n+\n+\n+# Examples\n+\n+```\n+@ast ctx srcref [\n+   K\"toplevel\"\n+   [K\"using\"\n+       [K\"importpath\"\n+           \"Base\"       ::K\"Identifier\"(src)\n+       ]\n+   ]\n+   [K\"function\"\n+       [K\"call\"\n+           \"eval\"       ::K\"Identifier\"\n+           \"x\"          ::K\"Identifier\"\n+       ]\n+       [K\"call\"\n+           \"eval\"       ::K\"core\"\n+           mn           =>K\"Identifier\"\n+           \"x\"          ::K\"Identifier\"\n+       ]\n+   ]\n+]\n+```\n+\"\"\"\n+macro ast(ctx, srcref, tree)\n+    quote\n+        ctx = $(esc(ctx))\n+        srcref = $(_match_srcref(srcref))\n+        $(_expand_ast_tree(:ctx, :srcref, tree))\n+    end\n+end\n+\n+#-------------------------------------------------------------------------------\n+# Mapping and copying of AST nodes\n+function copy_attrs!(dest, src, all=false)\n+    # TODO: Make this faster?\n+    for (name, attr) in pairs(src._graph.attributes)\n+        if (all || (name !== :source && name !== :kind && name !== :syntax_flags)) &&\n+                haskey(attr, src._id)\n+            dest_attr = getattr(dest._graph, name, nothing)\n+            if !isnothing(dest_attr)\n+                dest_attr[dest._id] = attr[src._id]\n+            end\n+        end\n+    end\n+end\n+\n+function copy_attrs!(dest, head::Union{Kind,JuliaSyntax.SyntaxHead}, all=false)\n+    if all\n+        sethead!(dest._graph, dest._id, head)\n+    end\n+end\n+\n+function mapchildren(f::Function, ctx, ex::SyntaxTree, do_map_child::Function;\n+                     extra_attrs...)\n+    if is_leaf(ex)\n+        return ex\n+    end\n+    orig_children = children(ex)\n+    cs = isempty(extra_attrs) ? nothing : SyntaxList(ctx)\n+    for (i,e) in enumerate(orig_children)\n+        newchild = do_map_child(i) ? f(e) : e\n+        if isnothing(cs)\n+            if newchild == e\n+                continue\n+            else\n+                cs = SyntaxList(ctx)\n+                append!(cs, orig_children[1:i-1])\n+            end\n+        end\n+        push!(cs::SyntaxList, newchild)\n+    end\n+    if isnothing(cs)\n+        # This function should be allocation-free if no children were changed\n+        # by the mapping and there's no extra_attrs\n+        return ex\n+    end\n+    cs::SyntaxList\n+    ex2 = makenode(ctx, ex, head(ex), cs)\n+    copy_attrs!(ex2, ex)\n+    setattr!(ex2; extra_attrs...)\n+    return ex2\n+end\n+\n+function mapchildren(f::Function, ctx, ex::SyntaxTree, mapped_children::AbstractVector{<:Integer};\n+                     extra_attrs...)\n+    j = Ref(firstindex(mapped_children))\n+    function do_map_child(i)\n+        ind = j[]\n+        if ind <= lastindex(mapped_children) && mapped_children[ind] == i\n+            j[] += 1\n+            true\n+        else\n+            false\n+        end\n+    end\n+    mapchildren(f, ctx, ex, do_map_child; extra_attrs...)\n+end\n+\n+function mapchildren(f::Function, ctx, ex::SyntaxTree; extra_attrs...)\n+    mapchildren(f, ctx, ex, i->true; extra_attrs...)\n+end\n+\n+\n+\"\"\"\n+Recursively copy AST `ex` into `ctx`.\n+\n+Special provenance handling: If `copy_source` is true, treat the `.source`\n+attribute as a reference and recurse on its contents.  Otherwise, treat it like\n+any other attribute.\n+\"\"\"\n+function copy_ast(ctx, ex::SyntaxTree; copy_source=true)\n+    graph1 = syntax_graph(ex)\n+    graph2 = syntax_graph(ctx)\n+    !copy_source && check_same_graph(graph1, graph2)\n+    id2 = _copy_ast(graph2, graph1, ex._id, Dict{NodeId, NodeId}(), copy_source)\n+    return SyntaxTree(graph2, id2)\n+end\n+\n+function _copy_ast(graph2::SyntaxGraph, graph1::SyntaxGraph,\n+                   id1::NodeId, seen, copy_source)\n+    let copied = get(seen, id1, nothing)\n+        isnothing(copied) || return copied\n+    end\n+    id2 = newnode!(graph2)\n+    seen[id1] = id2\n+    src1 = get(SyntaxTree(graph1, id1), :source, nothing)\n+    src2 = if !copy_source\n+        src1\n+    elseif src1 isa NodeId\n+        _copy_ast(graph2, graph1, src1, seen, copy_source)\n+    elseif src1 isa Tuple\n+        map(i->_copy_ast(graph2, graph1, i, seen, copy_source), src1)\n+    else\n+        src1\n+    end\n+    copy_attrs!(SyntaxTree(graph2, id2), SyntaxTree(graph1, id1), true)\n+    setattr!(graph2, id2; source=src2)\n+    if !is_leaf(graph1, id1)\n+        cs = NodeId[]\n+        for cid in children(graph1, id1)\n+            push!(cs, _copy_ast(graph2, graph1, cid, seen, copy_source))\n+        end\n+        setchildren!(graph2, id2, cs)\n+    end\n+    return id2\n+end\n+\n+#-------------------------------------------------------------------------------\n+function set_scope_layer(ctx, ex, layer_id, force)\n+    k = kind(ex)\n+    scope_layer = force ? layer_id : get(ex, :scope_layer, layer_id)\n+    if k == K\"module\" || k == K\"toplevel\" || k == K\"inert\"\n+        makenode(ctx, ex, ex, children(ex);\n+                 scope_layer=scope_layer)\n+    elseif k == K\".\"\n+        makenode(ctx, ex, ex, set_scope_layer(ctx, ex[1], layer_id, force), ex[2],\n+                 scope_layer=scope_layer)\n+    elseif !is_leaf(ex)\n+        mapchildren(e->set_scope_layer(ctx, e, layer_id, force), ctx, ex;\n+                    scope_layer=scope_layer)\n+    else\n+        makeleaf(ctx, ex, ex;\n+                 scope_layer=scope_layer)\n+    end\n+end\n+\n+\"\"\"\n+    adopt_scope(ex, ref)\n+\n+Copy `ex`, adopting the scope layer of `ref`.\n+\"\"\"\n+function adopt_scope(ex::SyntaxTree, scope_layer::LayerId)\n+    set_scope_layer(ex, ex, scope_layer, true)\n+end\n+\n+function adopt_scope(ex::SyntaxTree, layer::ScopeLayer)\n+    adopt_scope(ex, layer.id)\n+end\n+\n+function adopt_scope(ex::SyntaxTree, ref::SyntaxTree)\n+    adopt_scope(ex, ref.scope_layer)\n+end\n+\n+function adopt_scope(exs::SyntaxList, ref)\n+    out = SyntaxList(syntax_graph(exs))\n+    for e in exs\n+        push!(out, adopt_scope(e, ref))\n+    end\n+    return out\n+end\n+\n+# Type for `meta` attribute, to replace `Expr(:meta)`.\n+# It's unclear how much flexibility we need here - is a dict good, or could we\n+# just use a struct? Likely this will be sparse. Alternatively we could just\n+# use individual attributes but those aren't easy to add on an ad-hoc basis in\n+# the middle of a pass.\n+const CompileHints = Base.ImmutableDict{Symbol,Any}\n+\n+function CompileHints(d::Dict{Symbol, Any})\n+    id = CompileHints()\n+    for (k, v) in d\n+        id = CompileHints(id, k, v)\n+    end\n+    id\n+end\n+\n+function setmeta!(ex::SyntaxTree; kws...)\n+    @assert length(kws) == 1 # todo relax later ?\n+    key = first(keys(kws))\n+    value = first(values(kws))\n+    meta = begin\n+        m = get(ex, :meta, nothing)\n+        isnothing(m) ? CompileHints(key, value) : CompileHints(m, key, value)\n+    end\n+    setattr!(ex; meta=meta)\n+    ex\n+end\n+\n+setmeta(ex::SyntaxTree; kws...) = setmeta!(copy_node(ex); kws...)\n+\n+function getmeta(ex::SyntaxTree, name::Symbol, default)\n+    meta = get(ex, :meta, nothing)\n+    isnothing(meta) ? default : get(meta, name, default)\n+end\n+\n+name_hint(name) = CompileHints(:name_hint, name)\n+\n+#-------------------------------------------------------------------------------\n+# Predicates and accessors working on expression trees\n+\n+# For historical reasons, `cglobal` and `ccall` are their own special\n+# quasi-identifier-like syntax but with special handling inside lowering which\n+# means they can't be used as normal identifiers.\n+function is_ccall_or_cglobal(name::AbstractString)\n+    return name == \"ccall\" || name == \"cglobal\"\n+end\n+\n+function is_quoted(ex)\n+    kind(ex) in KSet\"Symbol quote top core globalref break inert\n+                     meta inbounds inline noinline loopinfo\"\n+end\n+\n+function extension_type(ex)\n+    @assert kind(ex) == K\"extension\" || kind(ex) == K\"assert\"\n+    @chk numchildren(ex) >= 1\n+    @chk kind(ex[1]) == K\"Symbol\"\n+    ex[1].name_val\n+end\n+\n+function is_sym_decl(x)\n+    k = kind(x)\n+    k == K\"Identifier\" || k == K\"::\"\n+end\n+\n+function is_eventually_call(ex::SyntaxTree)\n+    k = kind(ex)\n+    return k == K\"call\" || ((k == K\"where\" || k == K\"::\") && is_eventually_call(ex[1]))\n+end\n+\n+function find_parameters_ind(exs)\n+    i = length(exs)\n+    while i >= 1\n+        k = kind(exs[i])\n+        if k == K\"parameters\"\n+            return i\n+        elseif k != K\"do\"\n+            break\n+        end\n+        i -= 1\n+    end\n+    return 0\n+end\n+\n+function has_parameters(ex::SyntaxTree)\n+    find_parameters_ind(children(ex)) != 0\n+end\n+\n+function has_parameters(args::AbstractVector)\n+    find_parameters_ind(args) != 0\n+end\n+\n+function any_assignment(exs)\n+    any(kind(e) == K\"=\" for e in exs)\n+end\n+\n+function is_valid_modref(ex)\n+    return kind(ex) == K\".\" && kind(ex[2]) == K\"Symbol\" &&\n+           (kind(ex[1]) == K\"Identifier\" || is_valid_modref(ex[1]))\n+end\n+\n+function is_core_ref(ex, name)\n+    kind(ex) == K\"core\" && ex.name_val == name\n+end\n+\n+function is_core_nothing(ex)\n+    is_core_ref(ex, \"nothing\")\n+end\n+\n+function is_core_Any(ex)\n+    is_core_ref(ex, \"Any\")\n+end\n+\n+function is_simple_atom(ctx, ex)\n+    k = kind(ex)\n+    # TODO thismodule\n+    is_literal(k) || k == K\"Symbol\" || k == K\"Value\" || is_ssa(ctx, ex) || is_core_nothing(ex)\n+end\n+\n+function is_identifier_like(ex)\n+    k = kind(ex)\n+    k == K\"Identifier\" || k == K\"BindingId\" || k == K\"Placeholder\"\n+end\n+\n+function decl_var(ex)\n+    kind(ex) == K\"::\" ? ex[1] : ex\n+end\n+\n+# Given the signature of a `function`, return the symbol that will ultimately\n+# be assigned to in local/global scope, if any.\n+function assigned_function_name(ex)\n+    while kind(ex) == K\"where\"\n+        # f() where T\n+        ex = ex[1]\n+    end\n+    if kind(ex) == K\"::\" && numchildren(ex) == 2\n+        # f()::T\n+        ex = ex[1]\n+    end\n+    if kind(ex) != K\"call\"\n+        throw(LoweringError(ex, \"Expected call syntax in function signature\"))\n+    end\n+    ex = ex[1]\n+    if kind(ex) == K\"curly\"\n+        # f{T}()\n+        ex = ex[1]\n+    end\n+    if kind(ex) == K\"::\" || kind(ex) == K\".\"\n+        # (obj::CallableType)(args)\n+        # A.b.c(args)\n+        nothing\n+    elseif is_identifier_like(ex)\n+        ex\n+    else\n+        throw(LoweringError(ex, \"Unexpected name in function signature\"))\n+    end\n+end\n+\n+# Remove empty parameters block, eg, in the arg list of `f(x, y;)`\n+function remove_empty_parameters(args)\n+    i = length(args)\n+    while i > 0 && kind(args[i]) == K\"parameters\" && numchildren(args[i]) == 0\n+        i -= 1\n+    end\n+    args[1:i]\n+end\n+\n+function to_symbol(ctx, ex)\n+    @ast ctx ex ex=>K\"Symbol\"\n+end\n+\n+function new_scope_layer(ctx, mod_ref::Module=ctx.mod)\n+    new_layer = ScopeLayer(length(ctx.scope_layers)+1, ctx.mod, 0, false)\n+    push!(ctx.scope_layers, new_layer)\n+    new_layer.id\n+end\n+\n+function new_scope_layer(ctx, mod_ref::SyntaxTree)\n+    @assert kind(mod_ref) == K\"Identifier\"\n+    new_scope_layer(ctx, ctx.scope_layers[mod_ref.scope_layer].mod)\n+end\n+\n+#-------------------------------------------------------------------------------\n+# Context wrapper which helps to construct a list of statements to be executed\n+# prior to some expression. Useful when we need to use subexpressions multiple\n+# times.\n+struct StatementListCtx{Ctx, GraphType} <: AbstractLoweringContext\n+    ctx::Ctx\n+    stmts::SyntaxList{GraphType}\n+end\n+\n+function Base.getproperty(ctx::StatementListCtx, field::Symbol)\n+    if field === :ctx\n+        getfield(ctx, :ctx)\n+    elseif field === :stmts\n+        getfield(ctx, :stmts)\n+    else\n+        getproperty(getfield(ctx, :ctx), field)\n+    end\n+end\n+\n+function emit(ctx::StatementListCtx, ex)\n+    push!(ctx.stmts, ex)\n+end\n+\n+function emit_assign_tmp(ctx::StatementListCtx, ex, name=\"tmp\")\n+    emit_assign_tmp(ctx.stmts, ctx.ctx, ex, name)\n+end\n+\n+with_stmts(ctx, stmts) = StatementListCtx(ctx, stmts)\n+with_stmts(ctx::StatementListCtx, stmts) = StatementListCtx(ctx.ctx, stmts)\n+\n+function with_stmts(ctx)\n+    StatementListCtx(ctx, SyntaxList(ctx))\n+end\n+\n+with_stmts(ctx::StatementListCtx) = StatementListCtx(ctx.ctx)"
    },
    {
      "sha": "286e67ecbeb148537317a132e894d7c7d9183706",
      "filename": "JuliaLowering/src/bindings.jl",
      "status": "added",
      "additions": 249,
      "deletions": 0,
      "changes": 249,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fbindings.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fbindings.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fbindings.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,249 @@\n+\"\"\"\n+Metadata about a binding\n+\"\"\"\n+struct BindingInfo\n+    id::IdTag                 # Unique integer identifying this binding\n+    name::String\n+    kind::Symbol              # :local :global :argument :static_parameter\n+    node_id::Int              # ID of associated K\"BindingId\" node in the syntax graph\n+    mod::Union{Nothing,Module} # Set when `kind === :global`\n+    type::Union{Nothing,SyntaxTree} # Type, for bindings declared like x::T = 10\n+    n_assigned::Int32         # Number of times variable is assigned to\n+    is_const::Bool            # Constant, cannot be reassigned\n+    is_ssa::Bool              # Single assignment, defined before use\n+    is_captured::Bool         # Variable is captured by some lambda\n+    is_always_defined::Bool   # A local that we know has an assignment that dominates all usages (is never undef)\n+    is_internal::Bool         # True for internal bindings generated by the compiler\n+    is_ambiguous_local::Bool  # Local, but would be global in soft scope (ie, the REPL)\n+    is_nospecialize::Bool     # @nospecialize on this argument (only valid for kind == :argument)\n+end\n+\n+function BindingInfo(id::IdTag, name::AbstractString, kind::Symbol, node_id::Integer;\n+                     mod::Union{Nothing,Module} = nothing,\n+                     type::Union{Nothing,SyntaxTree} = nothing,\n+                     n_assigned::Integer = 0,\n+                     is_const::Bool = false,\n+                     is_ssa::Bool = false,\n+                     is_captured::Bool = false,\n+                     is_always_defined::Bool = is_ssa,\n+                     is_internal::Bool = false,\n+                     is_ambiguous_local::Bool = false,\n+                     is_nospecialize::Bool = false)\n+    BindingInfo(id, name, kind, node_id, mod, type, n_assigned, is_const,\n+                is_ssa, is_captured, is_always_defined,\n+                is_internal, is_ambiguous_local, is_nospecialize)\n+end\n+\n+function Base.show(io::IO, binfo::BindingInfo)\n+    print(io, \"BindingInfo(\", binfo.id, \", \",\n+          repr(binfo.name), \", \",\n+          repr(binfo.kind), \", \",\n+          binfo.node_id)\n+    if !isnothing(binfo.mod)\n+        print(io, \", mod=\", binfo.mod)\n+    end\n+    if !isnothing(binfo.type)\n+        print(io, \", type=\", binfo.type)\n+    end\n+    if binfo.n_assigned != 0\n+        print(io, \", n_assigned=\", binfo.n_assigned)\n+    end\n+    if binfo.is_const\n+        print(io, \", is_const=\", binfo.is_const)\n+    end\n+    if binfo.is_ssa\n+        print(io, \", is_ssa=\", binfo.is_ssa)\n+    end\n+    if binfo.is_captured\n+        print(io, \", is_captured=\", binfo.is_captured)\n+    end\n+    if binfo.is_always_defined != binfo.is_ssa\n+        print(io, \", is_always_defined=\", binfo.is_always_defined)\n+    end\n+    if binfo.is_internal\n+        print(io, \", is_internal=\", binfo.is_internal)\n+    end\n+    if binfo.is_ambiguous_local\n+        print(io, \", is_ambiguous_local=\", binfo.is_ambiguous_local)\n+    end\n+    if binfo.is_nospecialize\n+        print(io, \", is_nospecialize=\", binfo.is_nospecialize)\n+    end\n+    print(io, \")\")\n+end\n+\n+\"\"\"\n+Metadata about \"entities\" (variables, constants, etc) in the program. Each\n+entity is associated to a unique integer id, the BindingId. A binding will be\n+inferred for each *name* in the user's source program by symbolic analysis of\n+the source.\n+\n+However, bindings can also be introduced programmatically during lowering or\n+macro expansion: the primary key for bindings is the `BindingId` integer, not\n+a name.\n+\"\"\"\n+struct Bindings\n+    info::Vector{BindingInfo}\n+end\n+\n+Bindings() = Bindings(Vector{BindingInfo}())\n+\n+next_binding_id(bindings::Bindings) = length(bindings.info) + 1\n+\n+function add_binding(bindings::Bindings, binding)\n+    if next_binding_id(bindings) != binding.id\n+        error(\"Use next_binding_id() to create a valid binding id\")\n+    end\n+    push!(bindings.info, binding)\n+end\n+\n+function _binding_id(id::Integer)\n+    id\n+end\n+\n+function _binding_id(ex::SyntaxTree)\n+    @chk kind(ex) == K\"BindingId\"\n+    ex.var_id\n+end\n+\n+function update_binding!(bindings::Bindings, x;\n+        type=nothing, is_const=nothing, add_assigned=0,\n+        is_always_defined=nothing, is_captured=nothing)\n+    id = _binding_id(x)\n+    b = lookup_binding(bindings, id)\n+    bindings.info[id] = BindingInfo(\n+        b.id,\n+        b.name,\n+        b.kind,\n+        b.node_id,\n+        b.mod,\n+        isnothing(type) ? b.type : type,\n+        b.n_assigned + add_assigned,\n+        isnothing(is_const) ? b.is_const : is_const,\n+        b.is_ssa,\n+        isnothing(is_captured) ? b.is_captured : is_captured,\n+        isnothing(is_always_defined) ? b.is_always_defined : is_always_defined,\n+        b.is_internal,\n+        b.is_ambiguous_local,\n+        b.is_nospecialize\n+    )\n+end\n+\n+function lookup_binding(bindings::Bindings, x)\n+    bindings.info[_binding_id(x)]\n+end\n+\n+function lookup_binding(ctx::AbstractLoweringContext, x)\n+    lookup_binding(ctx.bindings, x)\n+end\n+\n+function update_binding!(ctx::AbstractLoweringContext, x; kws...)\n+    update_binding!(ctx.bindings, x; kws...)\n+end\n+\n+function new_binding(ctx::AbstractLoweringContext, srcref::SyntaxTree,\n+                     name::AbstractString, kind::Symbol; kws...)\n+    binding_id = next_binding_id(ctx.bindings)\n+    ex = @ast ctx srcref binding_id::K\"BindingId\"\n+    add_binding(ctx.bindings, BindingInfo(binding_id, name, kind, ex._id; kws...))\n+    ex\n+end\n+\n+# Create a new SSA binding\n+function ssavar(ctx::AbstractLoweringContext, srcref, name=\"tmp\")\n+    nameref = makeleaf(ctx, srcref, K\"Identifier\", name_val=name)\n+    new_binding(ctx, nameref, name, :local; is_ssa=true, is_internal=true)\n+end\n+\n+# Create a new local mutable binding or lambda argument\n+function new_local_binding(ctx::AbstractLoweringContext, srcref, name; kind=:local, kws...)\n+    @assert kind === :local || kind === :argument\n+    nameref = makeleaf(ctx, srcref, K\"Identifier\", name_val=name)\n+    ex = new_binding(ctx, nameref, name, kind; is_internal=true, kws...)\n+    lbindings = current_lambda_bindings(ctx)\n+    if !isnothing(lbindings)\n+        init_lambda_binding(lbindings, ex.var_id)\n+    end\n+    ex\n+end\n+\n+function new_global_binding(ctx::AbstractLoweringContext, srcref, name, mod; kws...)\n+    nameref = makeleaf(ctx, srcref, K\"Identifier\", name_val=name)\n+    new_binding(ctx, nameref, name, :global; is_internal=true, mod=mod, kws...)\n+end\n+\n+function binding_ex(ctx::AbstractLoweringContext, id::IdTag)\n+    # Reconstruct the SyntaxTree for this binding. We keep only the node_id\n+    # here, because that's got a concrete type. Whereas if we stored SyntaxTree\n+    # that would contain the type of the graph used in the pass where the\n+    # bindings were created and we'd need to call reparent(), etc.\n+    SyntaxTree(syntax_graph(ctx), lookup_binding(ctx, id).node_id)\n+end\n+\n+\n+#-------------------------------------------------------------------------------\n+\"\"\"\n+Metadata about how a binding is used within some enclosing lambda\n+\"\"\"\n+struct LambdaBindingInfo\n+    is_captured::Bool\n+    is_read::Bool\n+    is_assigned::Bool\n+    # Binding was the function name in a call. Used for specialization\n+    # heuristics in the optimizer.\n+    is_called::Bool\n+end\n+\n+LambdaBindingInfo() = LambdaBindingInfo(false, false, false, false)\n+\n+function LambdaBindingInfo(parent::LambdaBindingInfo;\n+                           is_captured = nothing,\n+                           is_read     = nothing,\n+                           is_assigned = nothing,\n+                           is_called   = nothing)\n+    LambdaBindingInfo(\n+        isnothing(is_captured) ? parent.is_captured : is_captured,\n+        isnothing(is_read)     ? parent.is_read     : is_read,\n+        isnothing(is_assigned) ? parent.is_assigned : is_assigned,\n+        isnothing(is_called)   ? parent.is_called   : is_called,\n+    )\n+end\n+\n+struct LambdaBindings\n+    # Bindings used within the lambda\n+    self::IdTag\n+    bindings::Dict{IdTag,LambdaBindingInfo}\n+end\n+\n+LambdaBindings(self::IdTag = 0) = LambdaBindings(self, Dict{IdTag,LambdaBindings}())\n+\n+function init_lambda_binding(bindings::LambdaBindings, id; kws...)\n+    @assert !haskey(bindings.bindings, id)\n+    bindings.bindings[id] = LambdaBindingInfo(LambdaBindingInfo(); kws...)\n+end\n+\n+function update_lambda_binding!(bindings::LambdaBindings, x; kws...)\n+    id = _binding_id(x)\n+    binfo = bindings.bindings[id]\n+    bindings.bindings[id] = LambdaBindingInfo(binfo; kws...)\n+end\n+\n+function update_lambda_binding!(ctx::AbstractLoweringContext, x; kws...)\n+    update_lambda_binding!(current_lambda_bindings(ctx), x; kws...)\n+end\n+\n+function lookup_lambda_binding(bindings::LambdaBindings, x)\n+    get(bindings.bindings, _binding_id(x), nothing)\n+end\n+\n+function lookup_lambda_binding(ctx::AbstractLoweringContext, x)\n+    lookup_lambda_binding(current_lambda_bindings(ctx), x)\n+end\n+\n+function has_lambda_binding(bindings::LambdaBindings, x)\n+    haskey(bindings.bindings, _binding_id(x))\n+end\n+\n+function has_lambda_binding(ctx::AbstractLoweringContext, x)\n+    has_lambda_binding(current_lambda_bindings(ctx), x)\n+end"
    },
    {
      "sha": "1dc4ca2bc8d9dd49850fdfdcd407ea963861ef90",
      "filename": "JuliaLowering/src/closure_conversion.jl",
      "status": "added",
      "additions": 633,
      "deletions": 0,
      "changes": 633,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fclosure_conversion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fclosure_conversion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fclosure_conversion.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,633 @@\n+struct ClosureInfo{GraphType}\n+    # Global name of the type of the closure\n+    type_name::SyntaxTree{GraphType}\n+    # Names of fields for use with getfield, in order\n+    field_names::SyntaxList{GraphType}\n+    # Map from the original BindingId of closed-over vars to the index of the\n+    # associated field in the closure type.\n+    field_inds::Dict{IdTag,Int}\n+end\n+\n+struct ClosureConversionCtx{GraphType} <: AbstractLoweringContext\n+    graph::GraphType\n+    bindings::Bindings\n+    mod::Module\n+    closure_bindings::Dict{IdTag,ClosureBindings}\n+    capture_rewriting::Union{Nothing,ClosureInfo{GraphType},SyntaxList{GraphType}}\n+    lambda_bindings::LambdaBindings\n+    # True if we're in a section of code which preserves top-level sequencing\n+    # such that closure types can be emitted inline with other code.\n+    is_toplevel_seq_point::Bool\n+    # True if this expression should not have toplevel effects, namely, it\n+    # should not declare the globals it references.  This allows generated\n+    # functions to refer to globals that have already been declared, without\n+    # triggering the \"function body AST not pure\" error.\n+    toplevel_pure::Bool\n+    toplevel_stmts::SyntaxList{GraphType}\n+    closure_infos::Dict{IdTag,ClosureInfo{GraphType}}\n+end\n+\n+function ClosureConversionCtx(graph::GraphType, bindings::Bindings,\n+                              mod::Module, closure_bindings::Dict{IdTag,ClosureBindings},\n+                              lambda_bindings::LambdaBindings) where {GraphType}\n+    ClosureConversionCtx{GraphType}(\n+        graph, bindings, mod, closure_bindings, nothing,\n+        lambda_bindings, false, true, SyntaxList(graph),\n+        Dict{IdTag,ClosureInfo{GraphType}}())\n+end\n+\n+function current_lambda_bindings(ctx::ClosureConversionCtx)\n+    ctx.lambda_bindings\n+end\n+\n+# Access captured variable from inside a closure\n+function captured_var_access(ctx, ex)\n+    cap_rewrite = ctx.capture_rewriting\n+    if cap_rewrite isa ClosureInfo\n+        field_sym = cap_rewrite.field_names[cap_rewrite.field_inds[ex.var_id]]\n+        @ast ctx ex [K\"call\"\n+            \"getfield\"::K\"core\"\n+            binding_ex(ctx, current_lambda_bindings(ctx).self)\n+            field_sym\n+        ]\n+    else\n+        interpolations = cap_rewrite\n+        @assert !isnothing(cap_rewrite)\n+        if isempty(interpolations) || !is_same_identifier_like(interpolations[end], ex)\n+            push!(interpolations, ex)\n+        end\n+        @ast ctx ex [K\"captured_local\" length(interpolations)::K\"Integer\"]\n+    end\n+end\n+\n+function get_box_contents(ctx::ClosureConversionCtx, var, box_ex)\n+    undef_var = new_local_binding(ctx, var, lookup_binding(ctx, var.var_id).name)\n+    @ast ctx var [K\"block\"\n+        box := box_ex\n+        # Lower in an UndefVar check to a similarly named variable\n+        # (ref #20016) so that closure lowering Box introduction\n+        # doesn't impact the error message and the compiler is expected\n+        # to fold away the extraneous null check\n+        #\n+        # TODO: Ideally the runtime would rely on provenance info for\n+        # this error and we can remove the isdefined check.\n+        [K\"if\" [K\"call\"\n+                \"isdefined\"::K\"core\"\n+                box\n+                \"contents\"::K\"Symbol\"\n+            ]\n+            ::K\"TOMBSTONE\"\n+            [K\"block\"\n+                 [K\"newvar\" undef_var]\n+                 undef_var\n+            ]\n+        ]\n+        [K\"call\"\n+            \"getfield\"::K\"core\"\n+            box\n+            \"contents\"::K\"Symbol\"\n+        ]\n+    ]\n+end\n+\n+# Convert `ex` to `type` by calling `convert(type, ex)` when necessary.\n+#\n+# Used for converting the right hand side of an assignment to a typed local or\n+# global and for converting the return value of a function call to the declared\n+# return type.\n+function convert_for_type_decl(ctx, srcref, ex, type, do_typeassert)\n+    # Use a slot to permit union-splitting this in inference\n+    tmp = new_local_binding(ctx, srcref, \"tmp\", is_always_defined=true)\n+\n+    @ast ctx srcref [K\"block\"\n+        type_tmp := type\n+        # [K\"=\" type_ssa renumber_assigned_ssavalues(type)]\n+        [K\"=\" tmp ex]\n+        [K\"if\"\n+            [K\"call\" \"isa\"::K\"core\" tmp type_tmp]\n+            \"nothing\"::K\"core\"\n+            [K\"=\"\n+                tmp\n+                if do_typeassert\n+                    [K\"call\"\n+                        \"typeassert\"::K\"core\"\n+                        [K\"call\" \"convert\"::K\"top\" type_tmp tmp]\n+                        type_tmp\n+                    ]\n+                else\n+                    [K\"call\" \"convert\"::K\"top\" type_tmp tmp]\n+                end\n+            ]\n+        ]\n+        tmp\n+    ]\n+end\n+\n+# TODO: Avoid producing redundant calls to declare_global\n+function make_globaldecl(ctx, src_ex, mod, name, strong=false, type=nothing; ret_nothing=false)\n+    if !ctx.toplevel_pure\n+        decl = @ast ctx src_ex [K\"block\"\n+            [K\"call\"\n+                \"declare_global\"::K\"core\"\n+                mod::K\"Value\" name::K\"Symbol\" strong::K\"Bool\"\n+                type\n+            ]\n+            [K\"latestworld\"]\n+            \"nothing\"::K\"core\"\n+        ]\n+        if ctx.is_toplevel_seq_point\n+            return decl\n+        else\n+            push!(ctx.toplevel_stmts, decl)\n+        end\n+    end\n+    if ret_nothing\n+        nothing\n+    else\n+        @ast ctx src_ex \"nothing\"::K\"core\"\n+    end\n+end\n+\n+function convert_global_assignment(ctx, ex, var, rhs0)\n+    binfo = lookup_binding(ctx, var)\n+    @assert binfo.kind == :global\n+    stmts = SyntaxList(ctx)\n+    decl = make_globaldecl(ctx, ex, binfo.mod, binfo.name, true; ret_nothing=true)\n+    decl !== nothing && push!(stmts, decl)\n+    rhs1 = if is_simple_atom(ctx, rhs0)\n+        rhs0\n+    else\n+        tmp = ssavar(ctx, rhs0)\n+        push!(stmts, @ast ctx rhs0 [K\"=\" tmp rhs0])\n+        tmp\n+    end\n+    rhs = if binfo.is_const && isnothing(binfo.type)\n+        # const global assignments without a type declaration don't need us to\n+        # deal with the binding type at all.\n+        rhs1\n+    else\n+        type_var = ssavar(ctx, ex, \"binding_type\")\n+        push!(stmts, @ast ctx ex [K\"=\"\n+            type_var\n+            [K\"call\"\n+                \"get_binding_type\"::K\"core\"\n+                binfo.mod::K\"Value\"\n+                binfo.name::K\"Symbol\"\n+            ]\n+        ])\n+        do_typeassert = false # Global assignment type checking is done by the runtime\n+        convert_for_type_decl(ctx, ex, rhs1, type_var, do_typeassert)\n+    end\n+    push!(stmts, @ast ctx ex [K\"=\" var rhs])\n+    @ast ctx ex [K\"block\"\n+        stmts...\n+        rhs1\n+    ]\n+end\n+\n+# Convert assignment to a closed variable to a `setfield!` call and generate\n+# `convert` calls for variables with declared types.\n+#\n+# When doing this, the original value needs to be preserved, to ensure the\n+# expression `a=b` always returns exactly `b`.\n+function convert_assignment(ctx, ex)\n+    var = ex[1]\n+    rhs0 = _convert_closures(ctx, ex[2])\n+    if kind(var) == K\"Placeholder\"\n+        return @ast ctx ex [K\"=\" var rhs0]\n+    end\n+    @chk kind(var) == K\"BindingId\"\n+    binfo = lookup_binding(ctx, var)\n+    if binfo.kind == :global\n+        convert_global_assignment(ctx, ex, var, rhs0)\n+    else\n+        @assert binfo.kind == :local || binfo.kind == :argument\n+        boxed = is_boxed(binfo)\n+        if isnothing(binfo.type) && !boxed\n+            @ast ctx ex [K\"=\" var rhs0]\n+        else\n+            # Typed local\n+            tmp_rhs0 = ssavar(ctx, rhs0)\n+            rhs = isnothing(binfo.type) ? tmp_rhs0 :\n+                  convert_for_type_decl(ctx, ex, tmp_rhs0, _convert_closures(ctx, binfo.type), true)\n+            assignment = if boxed\n+                @ast ctx ex [K\"call\"\n+                    \"setfield!\"::K\"core\"\n+                    is_self_captured(ctx, var) ? captured_var_access(ctx, var) : var\n+                    \"contents\"::K\"Symbol\"\n+                    rhs\n+                ]\n+            else\n+                @ast ctx ex [K\"=\" var rhs]\n+            end\n+            @ast ctx ex [K\"block\"\n+                [K\"=\" tmp_rhs0 rhs0]\n+                assignment\n+                tmp_rhs0\n+            ]\n+        end\n+    end\n+end\n+\n+# Compute fields for a closure type, one field for each captured variable.\n+function closure_type_fields(ctx, srcref, closure_binds, is_opaque)\n+    capture_ids = Vector{IdTag}()\n+    for lambda_bindings in closure_binds.lambdas\n+        for (id, lbinfo) in lambda_bindings.bindings\n+            if lbinfo.is_captured\n+                push!(capture_ids, id)\n+            end\n+        end\n+    end\n+    # sort here to avoid depending on undefined Dict iteration order.\n+    capture_ids = sort!(unique(capture_ids))\n+\n+    field_syms = SyntaxList(ctx)\n+    if is_opaque\n+        field_orig_bindings = capture_ids\n+        # For opaque closures we don't try to generate sensible names for the\n+        # fields as there's no closure type to generate.\n+        for (i,id) in enumerate(field_orig_bindings)\n+            push!(field_syms, @ast ctx srcref i::K\"Integer\")\n+        end\n+    else\n+        field_names = Dict{String,IdTag}()\n+        for id in capture_ids\n+            binfo = lookup_binding(ctx, id)\n+            # We name each field of the closure after the variable which was closed\n+            # over, for clarity. Adding a suffix can be necessary when collisions\n+            # occur due to macro expansion and generated bindings\n+            name0 = binfo.name\n+            name = name0\n+            i = 1\n+            while haskey(field_names, name)\n+                name = \"$name0#$i\"\n+                i += 1\n+            end\n+            field_names[name] = id\n+        end\n+        field_orig_bindings = Vector{IdTag}()\n+        for (name,id) in sort!(collect(field_names))\n+            push!(field_syms, @ast ctx srcref name::K\"Symbol\")\n+            push!(field_orig_bindings, id)\n+        end\n+    end\n+    field_inds = Dict{IdTag,Int}()\n+    field_is_box = Vector{Bool}()\n+    for (i,id) in enumerate(field_orig_bindings)\n+        push!(field_is_box, is_boxed(ctx, id))\n+        field_inds[id] = i\n+    end\n+\n+    return field_syms, field_orig_bindings, field_inds, field_is_box\n+end\n+\n+# Return a thunk which creates a new type for a closure with `field_syms` named\n+# fields. The new type will be named `name_str` which must be an unassigned\n+# name in the module.\n+function type_for_closure(ctx::ClosureConversionCtx, srcref, name_str, field_syms, field_is_box)\n+    # New closure types always belong to the module we're expanding into - they\n+    # need to be serialized there during precompile.\n+    mod = ctx.mod\n+    type_binding = new_global_binding(ctx, srcref, name_str, mod)\n+    type_ex = @ast ctx srcref [K\"call\"\n+        #\"_call_latest\"::K\"core\"\n+        eval_closure_type::K\"Value\"\n+        ctx.mod::K\"Value\"\n+        name_str::K\"Symbol\"\n+        [K\"call\" \"svec\"::K\"core\" field_syms...]\n+        [K\"call\" \"svec\"::K\"core\" [f::K\"Bool\" for f in field_is_box]...]\n+    ]\n+    type_ex, type_binding\n+end\n+\n+function is_boxed(binfo::BindingInfo)\n+    # True for\n+    # * :argument when it's not reassigned\n+    # * :static_parameter (these can't be reassigned)\n+    defined_but_not_assigned = binfo.is_always_defined && binfo.n_assigned == 0\n+    # For now, we box almost everything but later we'll want to do dominance\n+    # analysis on the untyped IR.\n+    return binfo.is_captured && !defined_but_not_assigned\n+end\n+\n+function is_boxed(ctx, x)\n+    is_boxed(lookup_binding(ctx, x))\n+end\n+\n+# Is captured in the closure's `self` argument\n+function is_self_captured(ctx, x)\n+    lbinfo = lookup_lambda_binding(ctx, x)\n+    !isnothing(lbinfo) && lbinfo.is_captured\n+end\n+\n+# Map the children of `ex` through _convert_closures, lifting any toplevel\n+# closure definition statements to occur before the other content of `ex`.\n+function map_cl_convert(ctx::ClosureConversionCtx, ex, toplevel_preserving)\n+    if ctx.is_toplevel_seq_point && !toplevel_preserving\n+        toplevel_stmts = SyntaxList(ctx)\n+        ctx2 = ClosureConversionCtx(ctx.graph, ctx.bindings, ctx.mod,\n+                                    ctx.closure_bindings, ctx.capture_rewriting, ctx.lambda_bindings,\n+                                    false, ctx.toplevel_pure, toplevel_stmts, ctx.closure_infos)\n+        res = mapchildren(e->_convert_closures(ctx2, e), ctx2, ex)\n+        if isempty(toplevel_stmts)\n+            res\n+        else\n+            @ast ctx ex [K\"block\"\n+                toplevel_stmts...\n+                res\n+            ]\n+        end\n+    else\n+        mapchildren(e->_convert_closures(ctx, e), ctx, ex)\n+    end\n+end\n+\n+function _convert_closures(ctx::ClosureConversionCtx, ex)\n+    k = kind(ex)\n+    if k == K\"BindingId\"\n+        access = is_self_captured(ctx, ex) ? captured_var_access(ctx, ex) : ex\n+        if is_boxed(ctx, ex)\n+            get_box_contents(ctx, ex, access)\n+        else\n+            access\n+        end\n+    elseif is_leaf(ex) || k == K\"inert\" || k == K\"static_eval\"\n+        ex\n+    elseif k == K\"=\"\n+        convert_assignment(ctx, ex)\n+    elseif k == K\"isdefined\"\n+        # Convert isdefined expr to function for closure converted variables\n+        var = ex[1]\n+        binfo = lookup_binding(ctx, var)\n+        if is_boxed(binfo)\n+            access = is_self_captured(ctx, var) ? captured_var_access(ctx, var) : var\n+            @ast ctx ex [K\"call\"\n+                \"isdefined\"::K\"core\"\n+                access\n+                \"contents\"::K\"Symbol\"\n+            ]\n+        elseif binfo.is_always_defined || is_self_captured(ctx, var)\n+            # Captured but unboxed vars are always defined\n+            @ast ctx ex true::K\"Bool\"\n+        elseif binfo.kind == :global\n+            # Normal isdefined won't work for globals (#56985)\n+            @ast ctx ex [K\"call\"\n+                \"isdefinedglobal\"::K\"core\"\n+                ctx.mod::K\"Value\"\n+                binfo.name::K\"Symbol\"\n+                false::K\"Bool\"]\n+        else\n+            ex\n+        end\n+    elseif k == K\"decl\"\n+        @assert kind(ex[1]) == K\"BindingId\"\n+        binfo = lookup_binding(ctx, ex[1])\n+        if binfo.kind == :global\n+            # flisp has this, but our K\"assert\" handling is in a previous pass\n+            # [K\"assert\" \"toplevel_only\"::K\"Symbol\" [K\"inert\" ex]]\n+            make_globaldecl(ctx, ex, binfo.mod, binfo.name, true, _convert_closures(ctx, ex[2]))\n+        else\n+            makeleaf(ctx, ex, K\"TOMBSTONE\")\n+        end\n+    elseif k == K\"global\"\n+        # Leftover `global` forms become weak globals.\n+        mod, name = if kind(ex[1]) == K\"BindingId\"\n+            binfo = lookup_binding(ctx, ex[1])\n+            @assert binfo.kind == :global\n+            binfo.mod, binfo.name\n+        else\n+            # See note about using eval on Expr(:global/:const, GlobalRef(...))\n+            @assert ex[1].value isa GlobalRef\n+            ex[1].value.mod, String(ex[1].value.name)\n+        end\n+        @ast ctx ex [K\"unused_only\" make_globaldecl(ctx, ex, mod, name, false)]\n+    elseif k == K\"local\"\n+        var = ex[1]\n+        binfo = lookup_binding(ctx, var)\n+        if binfo.is_captured\n+            @ast ctx ex [K\"=\" var [K\"call\" \"Box\"::K\"core\"]]\n+        elseif !binfo.is_always_defined\n+            @ast ctx ex [K\"newvar\" var]\n+        else\n+            makeleaf(ctx, ex, K\"TOMBSTONE\")\n+        end\n+    elseif k == K\"lambda\"\n+        closure_convert_lambda(ctx, ex)\n+    elseif k == K\"function_decl\"\n+        func_name = ex[1]\n+        @assert kind(func_name) == K\"BindingId\"\n+        func_name_id = func_name.var_id\n+        if haskey(ctx.closure_bindings, func_name_id)\n+            closure_info = get(ctx.closure_infos, func_name_id, nothing)\n+            needs_def = isnothing(closure_info)\n+            if needs_def\n+                closure_binds = ctx.closure_bindings[func_name_id]\n+                field_syms, field_orig_bindings, field_inds, field_is_box =\n+                    closure_type_fields(ctx, ex, closure_binds, false)\n+                name_str = reserve_module_binding_i(ctx.mod,\n+                    \"#$(join(closure_binds.name_stack, \"#\"))##\")\n+                closure_type_def, closure_type_ =\n+                    type_for_closure(ctx, ex, name_str, field_syms, field_is_box)\n+                if !ctx.is_toplevel_seq_point\n+                    push!(ctx.toplevel_stmts, closure_type_def)\n+                    push!(ctx.toplevel_stmts, @ast ctx ex (::K\"latestworld_if_toplevel\"))\n+                    closure_type_def = nothing\n+                end\n+                closure_info = ClosureInfo(closure_type_, field_syms, field_inds)\n+                ctx.closure_infos[func_name_id] = closure_info\n+                type_params = SyntaxList(ctx)\n+                init_closure_args = SyntaxList(ctx)\n+                for (id, boxed) in zip(field_orig_bindings, field_is_box)\n+                    field_val = binding_ex(ctx, id)\n+                    if is_self_captured(ctx, field_val)\n+                        # Access from outer closure if necessary but do not\n+                        # unbox to feed into the inner nested closure.\n+                        field_val = captured_var_access(ctx, field_val)\n+                    end\n+                    push!(init_closure_args, field_val)\n+                    if !boxed\n+                        push!(type_params, @ast ctx ex [K\"call\"\n+                              # TODO: Update to use _typeof_captured_variable (#40985)\n+                              #\"_typeof_captured_variable\"::K\"core\"\n+                              \"typeof\"::K\"core\"\n+                              field_val])\n+                    end\n+                end\n+                @ast ctx ex [K\"block\"\n+                    closure_type_def\n+                    (::K\"latestworld_if_toplevel\")\n+                    closure_type := if isempty(type_params)\n+                        closure_type_\n+                    else\n+                        [K\"call\" \"apply_type\"::K\"core\" closure_type_ type_params...]\n+                    end\n+                    closure_val := [K\"new\"\n+                        closure_type\n+                        init_closure_args...\n+                    ]\n+                    convert_assignment(ctx, [K\"=\" func_name closure_val])\n+                    ::K\"TOMBSTONE\"\n+                ]\n+            else\n+                @ast ctx ex (::K\"TOMBSTONE\")\n+            end\n+        else\n+            # Single-arg K\"method\" has the side effect of creating a global\n+            # binding for `func_name` if it doesn't exist.\n+            @ast ctx ex [K\"block\"\n+                [K\"method\" func_name]\n+                ::K\"TOMBSTONE\" # <- function_decl should not be used in value position\n+            ]\n+        end\n+    elseif k == K\"function_type\"\n+        func_name = ex[1]\n+        if kind(func_name) == K\"BindingId\" && lookup_binding(ctx, func_name).kind === :local\n+            ctx.closure_infos[func_name.var_id].type_name\n+        else\n+            @ast ctx ex [K\"call\" \"Typeof\"::K\"core\" func_name]\n+        end\n+    elseif k == K\"method_defs\"\n+        name = ex[1]\n+        is_closure = kind(name) == K\"BindingId\" && lookup_binding(ctx, name).kind === :local\n+        cap_rewrite = is_closure ? ctx.closure_infos[name.var_id] : nothing\n+        ctx2 = ClosureConversionCtx(ctx.graph, ctx.bindings, ctx.mod,\n+                                    ctx.closure_bindings, cap_rewrite, ctx.lambda_bindings,\n+                                    ctx.is_toplevel_seq_point, ctx.toplevel_pure, ctx.toplevel_stmts,\n+                                    ctx.closure_infos)\n+        body = map_cl_convert(ctx2, ex[2], false)\n+        if is_closure\n+            if ctx.is_toplevel_seq_point\n+                body\n+            else\n+                # Move methods out to a top-level sequence point.\n+                push!(ctx.toplevel_stmts, body)\n+                @ast ctx ex (::K\"TOMBSTONE\")\n+            end\n+        else\n+            @ast ctx ex [K\"block\"\n+                body\n+                ::K\"TOMBSTONE\"\n+            ]\n+        end\n+    elseif k == K\"_opaque_closure\"\n+        closure_binds = ctx.closure_bindings[ex[1].var_id]\n+        field_syms, field_orig_bindings, field_inds, field_is_box =\n+            closure_type_fields(ctx, ex, closure_binds, true)\n+\n+        capture_rewrites = ClosureInfo(ex #=unused=#, field_syms, field_inds)\n+\n+        ctx2 = ClosureConversionCtx(ctx.graph, ctx.bindings, ctx.mod,\n+                                    ctx.closure_bindings, capture_rewrites, ctx.lambda_bindings,\n+                                    false, ctx.toplevel_pure, ctx.toplevel_stmts, ctx.closure_infos)\n+\n+        init_closure_args = SyntaxList(ctx)\n+        for id in field_orig_bindings\n+            push!(init_closure_args, binding_ex(ctx, id))\n+        end\n+        @ast ctx ex [K\"new_opaque_closure\"\n+            ex[2] # arg type tuple\n+            ex[3] # return_lower_bound\n+            ex[4] # return_upper_bound\n+            ex[5] # allow_partial\n+            [K\"opaque_closure_method\"\n+                \"nothing\"::K\"core\"\n+                ex[6] # nargs\n+                ex[7] # is_va\n+                ex[8] # functionloc\n+                closure_convert_lambda(ctx2, ex[9])\n+            ]\n+            init_closure_args...\n+        ]\n+    else\n+        # A small number of kinds are toplevel-preserving in terms of closure\n+        # closure definitions will be lifted out into `toplevel_stmts` if they\n+        # occur inside `ex`.\n+        toplevel_seq_preserving = k == K\"if\" || k == K\"elseif\" || k == K\"block\" ||\n+                              k == K\"tryfinally\" || k == K\"trycatchelse\"\n+        map_cl_convert(ctx, ex, toplevel_seq_preserving)\n+    end\n+end\n+\n+function closure_convert_lambda(ctx, ex)\n+    @assert kind(ex) == K\"lambda\"\n+    lambda_bindings = ex.lambda_bindings\n+    interpolations = nothing\n+    if isnothing(ctx.capture_rewriting)\n+        # Global method which may capture locals\n+        interpolations = SyntaxList(ctx)\n+        cap_rewrite = interpolations\n+    else\n+        cap_rewrite = ctx.capture_rewriting\n+    end\n+    ctx2 = ClosureConversionCtx(ctx.graph, ctx.bindings, ctx.mod,\n+                                ctx.closure_bindings, cap_rewrite, lambda_bindings,\n+                                ex.is_toplevel_thunk, ctx.toplevel_pure && ex.toplevel_pure,\n+                                ctx.toplevel_stmts, ctx.closure_infos)\n+    lambda_children = SyntaxList(ctx)\n+    args = ex[1]\n+    push!(lambda_children, args)\n+    push!(lambda_children, ex[2])\n+\n+    # Add box initializations for arguments which are captured by an inner lambda\n+    body_stmts = SyntaxList(ctx)\n+    for arg in children(args)\n+        kind(arg) != K\"Placeholder\" || continue\n+        if is_boxed(ctx, arg)\n+            push!(body_stmts, @ast ctx arg [K\"=\"\n+                arg\n+                [K\"call\" \"Box\"::K\"core\" arg]\n+            ])\n+        end\n+    end\n+    # Convert body.\n+    input_body_stmts = kind(ex[3]) != K\"block\" ? ex[3:3] : ex[3][1:end]\n+    for e in input_body_stmts\n+        push!(body_stmts, _convert_closures(ctx2, e))\n+    end\n+    push!(lambda_children, @ast ctx2 ex[3] [K\"block\" body_stmts...])\n+\n+    if numchildren(ex) > 3\n+        # Convert return type\n+        @assert numchildren(ex) == 4\n+        push!(lambda_children, _convert_closures(ctx2, ex[4]))\n+    end\n+\n+    lam = makenode(ctx, ex, ex, lambda_children; lambda_bindings=lambda_bindings)\n+    if !isnothing(interpolations) && !isempty(interpolations)\n+        @ast ctx ex [K\"call\"\n+            replace_captured_locals!::K\"Value\"\n+            lam\n+            [K\"call\"\n+                \"svec\"::K\"core\"\n+                interpolations...\n+            ]\n+        ]\n+    else\n+        lam\n+    end\n+end\n+\n+\n+\"\"\"\n+Closure conversion and lowering of bindings\n+\n+This pass does a few things things:\n+* Deal with typed variables (K\"decl\") and their assignments\n+* Deal with const and non-const global assignments\n+* Convert closures into types\n+* Lower variables captured by closures into boxes, etc, as necessary\n+\n+Invariants:\n+* This pass must not introduce new K\"Identifier\" - only K\"BindingId\".\n+* Any new binding IDs must be added to the enclosing lambda locals\n+\"\"\"\n+@fzone \"JL: closures\" function convert_closures(ctx::VariableAnalysisContext, ex)\n+    ctx = ClosureConversionCtx(ctx.graph, ctx.bindings, ctx.mod,\n+                               ctx.closure_bindings, ex.lambda_bindings)\n+    ex1 = closure_convert_lambda(ctx, ex)\n+    if !isempty(ctx.toplevel_stmts)\n+        throw(LoweringError(first(ctx.toplevel_stmts), \"Top level code was found outside any top level context. `@generated` functions may not contain closures, including `do` syntax and generators/comprehension\"))\n+    end\n+    ctx, ex1\n+end"
    },
    {
      "sha": "133fb55151bcb231aa38a311bfb2c5b86521ff88",
      "filename": "JuliaLowering/src/compat.jl",
      "status": "added",
      "additions": 604,
      "deletions": 0,
      "changes": 604,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fcompat.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,604 @@\n+const JS = JuliaSyntax\n+\n+function _insert_tree_node(graph::SyntaxGraph, k::Kind, src::SourceAttrType,\n+                           flags::UInt16=0x0000; attrs...)\n+    id = newnode!(graph)\n+    sethead!(graph, id, k)\n+    flags !== 0 && setflags!(graph, id, flags)\n+    setattr!(graph, id; source=src, attrs...)\n+    return id\n+end\n+\n+\"\"\"\n+An Expr -> SyntaxTree transformation that should preserve semantics, but will\n+have low-quality provenance info (namely, each tree node will be associated with\n+the last seen LineNumberNode in the pre-order expr traversal).\n+\n+Last-resort option so that, for example, we can lower the output of old\n+Expr-producing macros.  Always prefer re-parsing source text over using this.\n+\n+Supports parsed and/or macro-expanded exprs, but not lowered exprs\n+\"\"\"\n+function expr_to_syntaxtree(@nospecialize(e), lnn::Union{LineNumberNode, Nothing}=nothing)\n+    graph = ensure_attributes!(\n+        SyntaxGraph(),\n+        kind=Kind, syntax_flags=UInt16,\n+        source=SourceAttrType, var_id=Int, value=Any,\n+        name_val=String, is_toplevel_thunk=Bool,\n+        scope_layer=LayerId, meta=CompileHints,\n+        toplevel_pure=Bool)\n+    expr_to_syntaxtree(graph, e, lnn)\n+end\n+\n+@fzone \"JL: expr_to_syntaxtree\" function expr_to_syntaxtree(ctx, @nospecialize(e), lnn::Union{LineNumberNode, Nothing})\n+    graph = syntax_graph(ctx)\n+    toplevel_src = if isnothing(lnn)\n+        # Provenance sinkhole for all nodes until we hit a linenode\n+        dummy_src = SourceRef(\n+            SourceFile(\"No source for expression\"),\n+            1, JS.GreenNode(K\"None\", 0))\n+        _insert_tree_node(graph, K\"None\", dummy_src)\n+    else\n+        lnn\n+    end\n+    st_id, _ = _insert_convert_expr(e, graph, toplevel_src)\n+    out = SyntaxTree(graph, st_id)\n+    return out\n+end\n+\n+function _expr_replace!(@nospecialize(e), replace_pred::Function, replacer!::Function,\n+                        recurse_pred=(@nospecialize e)->true)\n+    if replace_pred(e)\n+        replacer!(e)\n+    end\n+    if e isa Expr && recurse_pred(e)\n+        for a in e.args\n+            _expr_replace!(a, replace_pred, replacer!, recurse_pred)\n+        end\n+    end\n+end\n+\n+function _to_iterspec(exs::Vector, is_generator::Bool)\n+    if length(exs) === 1 && exs[1].head === :filter\n+        @assert length(exs[1].args) >= 2\n+        return Expr(:filter, _to_iterspec(exs[1].args[2:end], true), exs[1].args[1])\n+    end\n+    outex = Expr(:iteration)\n+    for e in exs\n+        if e.head === :block && !is_generator\n+            for iter in e.args\n+                push!(outex.args, Expr(:in, iter.args...))\n+            end\n+        elseif e.head === :(=)\n+            push!(outex.args, Expr(:in, e.args...))\n+        else\n+            @assert false \"unknown iterspec in $e\"\n+        end\n+    end\n+    return outex\n+end\n+\n+\"\"\"\n+Return `e.args`, but with any parameters in SyntaxTree (flattened, source) order.\n+Parameters are expected to be at `e.args[pos]`.\n+\n+e.g. orderings of (a,b,c;d;e;f):\n+  Expr:       (tuple (parameters (parameters (parameters f) e) d) a b c)\n+  SyntaxTree: (tuple a b c (parameters d) (parameters e) (parameters f))\n+\"\"\"\n+function collect_expr_parameters(e::Expr, pos::Int)\n+    params = expr_parameters(e, pos)\n+    isnothing(params) && return copy(e.args)\n+    args = Any[e.args[1:pos-1]..., e.args[pos+1:end]...]\n+    return _flatten_params!(args, params)\n+end\n+function _flatten_params!(out::Vector{Any}, params::Expr)\n+    p,p_esc = unwrap_esc(params)\n+    p1 = expr_parameters(p, 1)\n+    if !isnothing(p1)\n+        push!(out, p_esc(Expr(:parameters, p.args[2:end]...)))\n+        _flatten_params!(out, p_esc(p1))\n+    else\n+        push!(out, params::Any)\n+    end\n+    return out\n+end\n+function expr_parameters(p::Expr, pos::Int)\n+    if pos <= length(p.args)\n+        e,_ = unwrap_esc(p.args[pos])\n+        if e isa Expr && e.head === :parameters\n+            return p.args[pos]\n+        end\n+    end\n+    return nothing\n+end\n+\n+\"\"\"\n+If `b` (usually a block) has exactly one non-LineNumberNode argument, unwrap it.\n+\"\"\"\n+function maybe_unwrap_arg(b)\n+    if !(b isa Expr)\n+        return b\n+    end\n+    e1 = findfirst(c -> !isa(c, LineNumberNode), b.args)\n+    isnothing(e1) && return b\n+    e2 = findfirst(c -> !isa(c, LineNumberNode), b.args[e1+1:end])\n+    !isnothing(e2) && return b\n+    return b.args[e1]\n+end\n+\n+function maybe_extract_lnn(b, default)\n+    !(b isa Expr) && return default\n+    lnn_i = findfirst(a->isa(a, LineNumberNode), b.args)\n+    return isnothing(lnn_i) ? default : b.args[lnn_i]\n+end\n+\n+# Get kind by string if exists.  TODO relies on internals\n+function find_kind(s::String)\n+    out = get(JS._kind_str_to_int, s, nothing)\n+    return isnothing(out) ? nothing : JS.Kind(out)\n+end\n+\n+function is_dotted_operator(s::AbstractString)\n+    return length(s) >= 2 &&\n+        s[1] === '.' &&\n+        JS.is_operator(something(find_kind(s[2:end]), K\"None\"))\n+end\n+\n+function is_eventually_call(e)\n+    return e isa Expr && (e.head === :call ||\n+        e.head in (:escape, :where, :(::)) && is_eventually_call(e.args[1]))\n+end\n+\n+function rewrap_escapes(hyg, ex)\n+    if hyg isa Expr && hyg.head in (:escape, :var\"hygienic-scope\")\n+        ex = Expr(hyg.head, rewrap_escapes(hyg.args[1], ex))\n+        if hyg.head === :var\"hygienic-scope\"\n+            append!(ex.args, @view hyg.args[2:end])\n+        end\n+    end\n+    return ex\n+end\n+\n+# Unwrap Expr(:escape) and Expr(:hygienic-scope). Return the unwrapped\n+# expression and a function which will rewrap a derived expression in the\n+# correct hygiene wrapper.\n+function unwrap_esc(ex)\n+    orig_ex = ex\n+    while ex isa Expr && ex.head in (:escape, :var\"hygienic-scope\")\n+        @assert length(ex.args) >= 1\n+        ex = ex.args[1]\n+    end\n+    return ex, e->rewrap_escapes(orig_ex, e)\n+end\n+\n+function unwrap_esc_(e)\n+    unwrap_esc(e)[1]\n+end\n+\n+\"\"\"\n+Insert `e` converted to a syntaxtree into graph and recurse on children.  Return\n+a pair (my_node_id, last_srcloc).  Should not mutate `e`.\n+\n+`src` is the latest location found in the pre-order traversal, and is the line\n+number node to be associated with `e`.\n+\"\"\"\n+function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceAttrType)\n+    #---------------------------------------------------------------------------\n+    # Non-expr types\n+    if isnothing(e)\n+        st_id = _insert_tree_node(graph, K\"core\", src; name_val=\"nothing\")\n+        return st_id, src\n+    elseif e isa LineNumberNode\n+        # A LineNumberNode in value position evaluates to nothing\n+        st_id = _insert_tree_node(graph, K\"core\", src; name_val=\"nothing\")\n+        return st_id, e\n+    elseif e isa Symbol\n+        st_id = _insert_tree_node(graph, K\"Identifier\", src; name_val=String(e))\n+        return st_id, src\n+    elseif e isa QuoteNode\n+        if e.value isa Symbol\n+            return _insert_convert_expr(Expr(:quoted_symbol, e.value), graph, src)\n+        elseif e.value isa Expr\n+            return _insert_convert_expr(Expr(:inert, e.value), graph, src)\n+        elseif e.value isa LineNumberNode\n+            return _insert_tree_node(graph, K\"Value\", src; value=e.value), src\n+        else\n+            return _insert_convert_expr(e.value, graph, src)\n+        end\n+    elseif e isa String\n+        st_id = _insert_tree_node(graph, K\"string\", src)\n+        id_inner = _insert_tree_node(graph, K\"String\", src; value=e)\n+        setchildren!(graph, st_id, [id_inner])\n+        return st_id, src\n+    elseif !(e isa Expr)\n+        # There are other kinds we could potentially back-convert (e.g. Float),\n+        # but Value should work fine.\n+        st_k = e isa Bool ? K\"Bool\" :\n+            e isa Integer ? K\"Integer\" :\n+            find_kind(string(typeof(e)))\n+        st_id = _insert_tree_node(graph, isnothing(st_k) ? K\"Value\" : st_k, src; value=e)\n+        return st_id, src\n+    end\n+\n+    #---------------------------------------------------------------------------\n+    # `e` is an expr.  In many cases, it suffices to\n+    # - guess that the kind name is the same as the expr head\n+    # - add no syntax flags or attrs\n+    # - map e.args to syntax tree children one-to-one\n+    e::Expr\n+    nargs = length(e.args)\n+    maybe_kind = find_kind(string(e.head))\n+    st_k = isnothing(maybe_kind) ? K\"None\" : maybe_kind\n+    st_flags = 0x0000\n+    st_attrs = Dict{Symbol, Any}()\n+    # Note that SyntaxTree/Node differentiate 0-child non-terminals and leaves\n+    child_exprs::Union{Nothing, Vector{Any}} = copy(e.args)\n+\n+    # However, the following are (many) special cases where the kind, flags,\n+    # children, or attributes are different from what we guessed above\n+    if Base.isoperator(e.head) && st_k === K\"None\"\n+        # e.head is an updating assignment operator (+=, .-=, etc).  Non-=\n+        # dotted ops are wrapped in a call, so we don't reach this.\n+        s = string(e.head)\n+        @assert s[end] === '=' && nargs === 2\n+        if s[1] === '.'\n+            st_k = K\".op=\"\n+            op = s[2:end-1]\n+        else\n+            st_k = K\"op=\"\n+            op = s[1:end-1]\n+        end\n+        child_exprs = Any[e.args[1], Symbol(op), e.args[2]]\n+    elseif e.head === :comparison\n+        for i = 2:2:length(child_exprs)\n+            op,op_esc = unwrap_esc(child_exprs[i])\n+            @assert op isa Symbol\n+            op_s = string(op)\n+            if is_dotted_operator(op_s)\n+                child_exprs[i] = Expr(:., op_esc(Symbol(op_s[2:end])))\n+            end\n+        end\n+    elseif e.head === :macrocall\n+        @assert nargs >= 2\n+        a1,a1_esc = unwrap_esc(e.args[1])\n+        child_exprs = collect_expr_parameters(e, 3)\n+        if child_exprs[2] isa LineNumberNode\n+            src = child_exprs[2]\n+        end\n+        deleteat!(child_exprs, 2)\n+        if a1 isa Symbol\n+            child_exprs[1] = a1_esc(Expr(:macro_name, a1))\n+        elseif a1 isa Expr && a1.head === :(.)\n+            a12,a12_esc = unwrap_esc(a1.args[2])\n+            if a12 isa QuoteNode\n+                child_exprs[1] = a1_esc(Expr(:(.), a1.args[1],\n+                                             Expr(:macro_name, a12_esc(a12.value))))\n+            end\n+        elseif a1 isa GlobalRef && a1.mod === Core\n+            # Syntax-introduced macrocalls are listed here for reference.  We\n+            # probably don't need to convert these.\n+            if a1.name === Symbol(\"@cmd\")\n+            elseif a1.name === Symbol(\"@doc\") && nargs === 4 # two macro args only\n+                # Single-arg @doc is a lookup not corresponding to K\"doc\"\n+                # Revise sometimes calls @doc with three args, but probably shouldn't\n+                st_k = K\"doc\"\n+                child_exprs = child_exprs[2:3]\n+            elseif a1.name === Symbol(\"@int128_str\")\n+            elseif a1.name === Symbol(\"@int128_str\")\n+            elseif a1.name === Symbol(\"@big_str\")\n+            end\n+        end\n+    elseif e.head === Symbol(\"'\")\n+        @assert nargs === 1\n+        st_k = K\"call\"\n+        child_exprs = Any[e.head, e.args[1]]\n+    elseif e.head === :. && nargs === 2\n+        a2, a2_esc = unwrap_esc(e.args[2])\n+        if a2 isa Expr && a2.head === :tuple\n+            st_k = K\"dotcall\"\n+            tuple_exprs = collect_expr_parameters(a2_esc(a2), 1)\n+            child_exprs = pushfirst!(tuple_exprs, e.args[1])\n+        elseif a2 isa QuoteNode\n+            child_exprs[2] = a2_esc(a2.value)\n+        end\n+    elseif e.head === :for\n+        @assert nargs === 2\n+        child_exprs = Any[_to_iterspec(Any[e.args[1]], false), e.args[2]]\n+    elseif e.head === :where\n+        @assert nargs >= 2\n+        e2,_ = unwrap_esc(e.args[2])\n+        if !(e2 isa Expr && e2.head === :braces)\n+            child_exprs = Any[e.args[1], Expr(:braces, e.args[2:end]...)]\n+        end\n+    elseif e.head in (:tuple, :vect, :braces)\n+        child_exprs = collect_expr_parameters(e, 1)\n+    elseif e.head in (:curly, :ref)\n+        child_exprs = collect_expr_parameters(e, 2)\n+    elseif e.head === :try\n+        child_exprs = Any[e.args[1]]\n+        # Expr:\n+        # (try (block ...) var       (block ...) [block ...] [block ...])\n+        # #     try        catch_var  catch       finally     else\n+        # SyntaxTree:\n+        #   (try (block ...)\n+        #        [catch var (block ...)]\n+        #        [else (block ...)]\n+        #        [finally (block ...)])\n+        e2 = unwrap_esc_(e.args[2])\n+        e3 = unwrap_esc_(e.args[3])\n+        if e2 !== false || e3 !== false\n+            push!(child_exprs,\n+                  Expr(:catch,\n+                       e2 === false ? Expr(:catch_var_placeholder) : e.args[2],\n+                       e3 === false ? nothing : e.args[3]))\n+        end\n+        if nargs >= 5\n+            push!(child_exprs, Expr(:else, e.args[5]))\n+        end\n+        if nargs >= 4 && unwrap_esc_(e.args[4]) !== false\n+            push!(child_exprs, Expr(:finally, e.args[4]))\n+        end\n+    elseif e.head === :flatten || e.head === :generator\n+        st_k = K\"generator\"\n+        child_exprs = Any[]\n+        next = e\n+        while next.head === :flatten\n+            @assert next.args[1].head === :generator\n+            push!(child_exprs, _to_iterspec(next.args[1].args[2:end], true))\n+            next = next.args[1].args[1]\n+        end\n+        @assert next.head === :generator\n+        push!(child_exprs, _to_iterspec(next.args[2:end], true))\n+        pushfirst!(child_exprs, next.args[1])\n+    elseif e.head === :ncat || e.head === :nrow\n+        dim = unwrap_esc_(popfirst!(child_exprs))\n+        st_flags |= JS.set_numeric_flags(dim)\n+    elseif e.head === :typed_ncat\n+        st_flags |= JS.set_numeric_flags(unwrap_esc_(e.args[2]))\n+        deleteat!(child_exprs, 2)\n+    elseif e.head === :(->)\n+        @assert nargs === 2\n+        a1, a1_esc = unwrap_esc(e.args[1])\n+        if a1 isa Expr && a1.head === :block\n+            # Expr parsing fails to make :parameters here...\n+            lam_args = Any[]\n+            lam_eqs = Any[]\n+            for a in a1.args\n+                a isa LineNumberNode && continue\n+                a isa Expr && a.head === :(=) ? push!(lam_eqs, a) : push!(lam_args, a)\n+            end\n+            !isempty(lam_eqs) && push!(lam_args, Expr(:parameters, lam_eqs...))\n+            child_exprs[1] = a1_esc(Expr(:tuple, lam_args...))\n+        elseif !(a1 isa Expr && (a1.head in (:tuple, :where)))\n+            child_exprs[1] = a1_esc(Expr(:tuple, a1))\n+        end\n+        src = maybe_extract_lnn(e.args[2], src)\n+        child_exprs[2] = maybe_unwrap_arg(e.args[2])\n+    elseif e.head === :call\n+        child_exprs = collect_expr_parameters(e, 2)\n+        a1,a1_esc = unwrap_esc(child_exprs[1])\n+        if a1 isa Symbol\n+            a1s = string(a1)\n+            if is_dotted_operator(a1s)\n+                # non-assigning dotop like .+ or .==\n+                st_k = K\"dotcall\"\n+                child_exprs[1] = a1_esc(Symbol(a1s[2:end]))\n+            end\n+        end\n+    elseif e.head === :function\n+        if nargs >= 2\n+            src = maybe_extract_lnn(e.args[2], src)\n+        end\n+    elseif e.head === :(=)\n+        if is_eventually_call(e.args[1])\n+            st_k = K\"function\"\n+            st_flags |= JS.SHORT_FORM_FUNCTION_FLAG\n+            src = maybe_extract_lnn(e.args[2], src)\n+            child_exprs[2] = maybe_unwrap_arg(e.args[2])\n+        end\n+    elseif e.head === :module\n+        @assert nargs === 3\n+        if !e.args[1]\n+            st_flags |= JS.BARE_MODULE_FLAG\n+        end\n+        child_exprs = Any[e.args[2], e.args[3]]\n+    elseif e.head === :do\n+        # Expr:\n+        # (do (call f args...) (-> (tuple lam_args...) (block ...)))\n+        # SyntaxTree:\n+        # (call f args... (do (tuple lam_args...) (block ...)))\n+        callargs = collect_expr_parameters(e.args[1], 2)\n+        if e.args[1].head === :macrocall\n+            st_k = K\"macrocall\"\n+            if callargs[2] isa LineNumberNode\n+                src = callargs[2]\n+            end\n+            deleteat!(callargs, 2)\n+            c1,c1_esc = unwrap_esc(callargs[1])\n+            callargs[1] = c1_esc(Expr(:macro_name, c1))\n+        else\n+            st_k = K\"call\"\n+        end\n+        child_exprs = Any[callargs..., Expr(:do_lambda, e.args[2].args...)]\n+    elseif e.head === :let\n+        if nargs >= 1\n+            a1,_ = unwrap_esc(e.args[1])\n+            if !(a1 isa Expr && a1.head === :block)\n+                child_exprs[1] = Expr(:block, e.args[1])\n+            end\n+        end\n+    elseif e.head === :struct\n+        e.args[1] && (st_flags |= JS.MUTABLE_FLAG)\n+        child_exprs = child_exprs[2:end]\n+        # TODO handle docstrings after refactor\n+    elseif (e.head === :using || e.head === :import)\n+        _expr_replace!(e,\n+                       (e)->(e isa Expr && e.head === :.),\n+                       (e)->(e.head = :importpath))\n+    elseif e.head === :kw\n+        st_k = K\"=\"\n+    elseif e.head in (:local, :global) && nargs > 1\n+        # Possible normalization\n+        # child_exprs = Any[Expr(:tuple, child_exprs...)]\n+    elseif e.head === :error\n+        # Zero-child errors from parsing are leaf nodes.  We could change this\n+        # upstream for consistency.\n+        if nargs === 0\n+            child_exprs = nothing\n+            st_attrs[:value] = JS.ErrorVal()\n+            st_flags |= JS.TRIVIA_FLAG\n+        end\n+    end\n+\n+    #---------------------------------------------------------------------------\n+    # The following heads are not emitted from parsing, but old macros could\n+    # produce these and they would historically be accepted by flisp lowering.\n+    if e.head === Symbol(\"latestworld-if-toplevel\")\n+        st_k = K\"latestworld_if_toplevel\"\n+    elseif e.head === Symbol(\"hygienic-scope\")\n+        st_k = K\"hygienic_scope\"\n+    elseif e.head === :meta\n+        # Messy and undocumented.  Only sometimes we want a K\"meta\".\n+        if e.args[1] isa Expr && e.args[1].head === :purity\n+            st_k = K\"meta\"\n+            child_exprs = [Expr(:quoted_symbol, :purity), Base.EffectsOverride(e.args[1].args...)]\n+        elseif nargs === 0\n+            # pass\n+        elseif e.args[1] === :nospecialize\n+            if nargs === 1\n+                child_exprs[1] = Expr(:quoted_symbol, :nospecialize)\n+            elseif nargs > 2\n+                st_k = K\"block\"\n+                # Kick the can down the road (should only be simple atoms?)\n+                child_exprs = map(c->Expr(:meta, :nospecialize, c), child_exprs[2:end])\n+            elseif nargs === 2\n+                st_id, src = _insert_convert_expr(e.args[2], graph, src)\n+                setmeta!(SyntaxTree(graph, st_id); nospecialize=true)\n+                return st_id, src\n+            end\n+        elseif e.args[1] in (:inline, :noinline, :generated, :generated_only,\n+                             :max_methods, :optlevel, :toplevel, :push_loc, :pop_loc,\n+                             :no_constprop, :aggressive_constprop, :specialize, :compile, :infer,\n+                             :nospecializeinfer, :force_compile, :propagate_inbounds, :doc)\n+            # TODO: Some need to be handled in lowering\n+            for (i, ma) in enumerate(e.args)\n+                if ma isa Symbol\n+                    # @propagate_inbounds becomes (meta inline propagate_inbounds)\n+                    child_exprs[i] = Expr(:quoted_symbol, e.args[i])\n+                end\n+            end\n+        else\n+            # Can't throw a hard error; it is explicitly tested that meta can take arbitrary keys.\n+            @error(\"Unknown meta form at $src: `$e`\\n$(sprint(dump, e))\")\n+            child_exprs[1] = Expr(:quoted_symbol, e.args[1])\n+        end\n+    elseif e.head === :scope_layer\n+        @assert nargs === 2\n+        @assert e.args[1] isa Symbol\n+        @assert e.args[2] isa LayerId\n+        st_id, src = _insert_convert_expr(e.args[1], graph, src)\n+        setattr!(graph, st_id, scope_layer=e.args[2])\n+        return st_id, src\n+    elseif e.head === :symbolicgoto || e.head === :symboliclabel\n+        @assert nargs === 1\n+        st_k = e.head === :symbolicgoto ? K\"symbolic_label\" : K\"symbolic_goto\"\n+        st_attrs[:name_val] = string(e.args[1])\n+        child_exprs = nothing\n+    elseif e.head in (:inline, :noinline)\n+        @assert nargs === 1 && e.args[1] isa Bool\n+        # TODO: JuliaLowering doesn't accept this (non-:meta) form yet\n+        st_k = K\"TOMBSTONE\"\n+        child_exprs = nothing\n+    elseif e.head === :inbounds\n+        @assert nargs === 1 && typeof(e.args[1]) in (Symbol, Bool)\n+        # TODO: JuliaLowering doesn't accept this form yet\n+        st_k = K\"TOMBSTONE\"\n+        child_exprs = nothing\n+    elseif e.head === :core\n+        @assert nargs === 1\n+        @assert e.args[1] isa Symbol\n+        st_attrs[:name_val] = string(e.args[1])\n+        child_exprs = nothing\n+    elseif e.head === :islocal || e.head === :isglobal\n+        st_k = K\"extension\"\n+        child_exprs = [Expr(:quoted_symbol, e.head), e.args[1]]\n+    elseif e.head === :block && nargs >= 1 &&\n+        e.args[1] isa Expr && e.args[1].head === :softscope\n+        # (block (softscope true) ex) produced with every REPL prompt.\n+        # :hardscope exists too, but should just be a let, and appears to be\n+        # unused in the wild.\n+        ensure_attributes!(graph; scope_type=Symbol)\n+        st_k = K\"scope_block\"\n+        st_attrs[:scope_type] = :soft\n+        child_exprs = e.args[2:end]\n+    end\n+\n+    #---------------------------------------------------------------------------\n+    # Possibly-temporary heads introduced by us converting the parent expr\n+    if e.head === :macro_name\n+        @assert nargs === 1\n+        # Trim `@` for a correct SyntaxTree, although we need to add it back\n+        # later for finding the macro\n+        if e.args[1] === :(.)\n+            mac_name = string(e.args[1][2])\n+            mac_name = mac_name == \"@__dot__\" ? \".\" : mac_name[2:end]\n+            child_exprs[1] = Expr(:(.), e.args[1][1], Symbol(mac_name))\n+        else\n+            mac_name = string(e.args[1])\n+            mac_name = mac_name == \"@__dot__\" ? \".\" : mac_name[2:end]\n+            child_exprs[1] = Symbol(mac_name)\n+        end\n+    elseif e.head === :catch_var_placeholder\n+        st_k = K\"Placeholder\"\n+        st_attrs[:name_val] = \"\"\n+        child_exprs = nothing\n+    elseif e.head === :quoted_symbol\n+        st_k = K\"Symbol\"\n+        st_attrs[:name_val] = String(e.args[1])\n+        child_exprs = nothing\n+    elseif e.head === :do_lambda\n+        st_k = K\"do\"\n+    end\n+\n+    #---------------------------------------------------------------------------\n+    # Throw if this function isn't complete.  Finally, insert a new node into the\n+    # graph and recurse on child_exprs\n+    if st_k === K\"None\"\n+        error(\"Unknown expr head at $src: `$(e.head)`\\n$(sprint(dump, e))\")\n+    elseif st_k === K\"TOMBSTONE\"\n+        return nothing, src\n+    end\n+\n+    st_id = _insert_tree_node(graph, st_k, src, st_flags; st_attrs...)\n+\n+    # child_exprs === nothing means we want a leaf.  Note that setchildren! with\n+    # an empty list makes a node non-leaf.\n+    if isnothing(child_exprs)\n+        return st_id, src\n+    else\n+        st_child_ids, last_src = _insert_child_exprs(e.head, child_exprs, graph, src)\n+        setchildren!(graph, st_id, st_child_ids)\n+        return st_id, last_src\n+    end\n+end\n+\n+function _insert_child_exprs(head::Symbol, child_exprs::Vector{Any},\n+                             graph::SyntaxGraph, src::SourceAttrType)\n+    st_child_ids = NodeId[]\n+    last_src = src\n+    for (i, c) in enumerate(child_exprs)\n+        c_unwrapped, _ = unwrap_esc(c)\n+        # If c::LineNumberNode is anywhere in a block OR c is not in tail\n+        # position, we don't need to insert `nothing` here\n+        if c_unwrapped isa LineNumberNode && (head === :block || head === :toplevel && i != length(child_exprs))\n+            last_src = c_unwrapped\n+        else\n+            (c_id, last_src) = _insert_convert_expr(c, graph, last_src)\n+            if !isnothing(c_id)\n+                push!(st_child_ids, c_id)\n+            end\n+        end\n+    end\n+    return st_child_ids, last_src\n+end"
    },
    {
      "sha": "30b10d2dbf766e7d72a6327fa9f88b0c746cb130",
      "filename": "JuliaLowering/src/desugaring.jl",
      "status": "added",
      "additions": 4608,
      "deletions": 0,
      "changes": 4608,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fdesugaring.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "cef07133b2f5ebfa79262015cbbc9073dc9e879a",
      "filename": "JuliaLowering/src/eval.jl",
      "status": "added",
      "additions": 568,
      "deletions": 0,
      "changes": 568,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Feval.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Feval.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Feval.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,568 @@\n+# Non-incremental lowering API for non-toplevel non-module expressions.\n+# May be removed?\n+\n+function lower(mod::Module, ex0; expr_compat_mode=false, world=Base.get_world_counter())\n+    ctx1, ex1 = expand_forms_1(  mod,  ex0, expr_compat_mode, world)\n+    ctx2, ex2 = expand_forms_2(  ctx1, ex1)\n+    ctx3, ex3 = resolve_scopes(  ctx2, ex2)\n+    ctx4, ex4 = convert_closures(ctx3, ex3)\n+    ctx5, ex5 = linearize_ir(    ctx4, ex4)\n+    ex5\n+end\n+\n+function macroexpand(mod::Module, ex; expr_compat_mode=false, world=Base.get_world_counter())\n+    ctx1, ex1 = expand_forms_1(mod, ex, expr_compat_mode, world)\n+    ex1\n+end\n+\n+# Incremental lowering API which can manage toplevel and module expressions.\n+#\n+# This iteration API is oddly bespoke and arguably somewhat non-Julian for two\n+# reasons:\n+#\n+# * Lowering knows when new modules are required, and may request them with\n+#   `:begin_module`. However `eval()` generates those modules so they need to\n+#   be passed back into lowering. So we can't just use `Base.iterate()`. (Put a\n+#   different way, we have a situation which is suited to coroutines but we\n+#   don't want to use full Julia `Task`s for this.)\n+# * We might want to implement this `eval()` in Julia's C runtime code or early\n+#   in bootstrap. Hence using SimpleVector and Symbol as the return values of\n+#   `lower_step()`\n+#\n+# We might consider changing at least the second of these choices, depending on\n+# how we end up putting this into Base.\n+\n+struct LoweringIterator{GraphType}\n+    ctx::MacroExpansionContext{GraphType}\n+    todo::Vector{Tuple{SyntaxTree{GraphType}, Bool, Int}}\n+end\n+\n+function lower_init(ex::SyntaxTree, mod::Module, macro_world::UInt; expr_compat_mode::Bool=false)\n+    graph = ensure_macro_attributes(syntax_graph(ex))\n+    ctx = MacroExpansionContext(graph, mod, expr_compat_mode, macro_world)\n+    ex = reparent(ctx, ex)\n+    LoweringIterator{typeof(graph)}(ctx, [(ex, false, 0)])\n+end\n+\n+function lower_step(iter, push_mod=nothing)\n+    if !isnothing(push_mod)\n+        push_layer!(iter.ctx, push_mod, false)\n+    end\n+\n+    if isempty(iter.todo)\n+        return Core.svec(:done)\n+    end\n+\n+    ex, is_module_body, child_idx = pop!(iter.todo)\n+    if child_idx > 0\n+        next_child = child_idx + 1\n+        if child_idx <= numchildren(ex)\n+            push!(iter.todo, (ex, is_module_body, next_child))\n+            ex = ex[child_idx]\n+        else\n+            if is_module_body\n+                pop_layer!(iter.ctx)\n+                return Core.svec(:end_module)\n+            else\n+                return lower_step(iter)\n+            end\n+        end\n+    end\n+\n+    k = kind(ex)\n+    if !(k in KSet\"toplevel module\")\n+        ex = expand_forms_1(iter.ctx, ex)\n+        k = kind(ex)\n+    end\n+    if k == K\"toplevel\"\n+        push!(iter.todo, (ex, false, 1))\n+        return lower_step(iter)\n+    elseif k == K\"module\"\n+        name = ex[1]\n+        if kind(name) != K\"Identifier\"\n+            throw(LoweringError(name, \"Expected module name\"))\n+        end\n+        newmod_name = Symbol(name.name_val)\n+        body = ex[2]\n+        if kind(body) != K\"block\"\n+            throw(LoweringError(body, \"Expected block in module body\"))\n+        end\n+        std_defs = !has_flags(ex, JuliaSyntax.BARE_MODULE_FLAG)\n+        loc = source_location(LineNumberNode, ex)\n+        push!(iter.todo, (body, true, 1))\n+        return Core.svec(:begin_module, newmod_name, std_defs, loc)\n+    else\n+        # Non macro expansion parts of lowering\n+        ctx2, ex2 = expand_forms_2(iter.ctx, ex)\n+        ctx3, ex3 = resolve_scopes(ctx2, ex2)\n+        ctx4, ex4 = convert_closures(ctx3, ex3)\n+        ctx5, ex5 = linearize_ir(ctx4, ex4)\n+        thunk = to_lowered_expr(ex5)\n+        return Core.svec(:thunk, thunk)\n+    end\n+end\n+\n+\n+#-------------------------------------------------------------------------------\n+\n+function codeinfo_has_image_globalref(@nospecialize(e))\n+    if e isa GlobalRef\n+        return 0x00 !== @ccall jl_object_in_image(e.mod::Any)::UInt8\n+    elseif e isa Core.CodeInfo\n+        return any(codeinfo_has_image_globalref, e.code)\n+    else\n+        return false\n+    end\n+end\n+\n+_CodeInfo_need_ver = v\"1.12.0-DEV.512\"\n+if VERSION < _CodeInfo_need_ver\n+    function _CodeInfo(args...)\n+        error(\"Constructing a CodeInfo using JuliaLowering currently requires Julia version $_CodeInfo_need_ver or greater\")\n+    end\n+else\n+    # debuginfo changed completely as of https://github.com/JuliaLang/julia/pull/52415\n+    # nargs / isva was added as of       https://github.com/JuliaLang/julia/pull/54341\n+    # field rettype added in             https://github.com/JuliaLang/julia/pull/54655\n+    # field has_image_globalref added in https://github.com/JuliaLang/julia/pull/57433\n+    # CodeInfo constructor. TODO: Should be in Core\n+    let\n+        fns = fieldnames(Core.CodeInfo)\n+        fts = fieldtypes(Core.CodeInfo)\n+        conversions = [:(convert($t, $n)) for (t,n) in zip(fts, fns)]\n+\n+        expected_fns = (:code, :debuginfo, :ssavaluetypes, :ssaflags, :slotnames, :slotflags, :slottypes, :rettype, :parent, :edges, :min_world, :max_world, :method_for_inference_limit_heuristics, :nargs, :propagate_inbounds, :has_fcall, :has_image_globalref, :nospecializeinfer, :isva, :inlining, :constprop, :purity, :inlining_cost)\n+        expected_fts = (Vector{Any}, Core.DebugInfo, Any, Vector{UInt32}, Vector{Symbol}, Vector{UInt8}, Any, Any, Any, Any, UInt, UInt, Any, UInt, Bool, Bool, Bool, Bool, Bool, UInt8, UInt8, UInt16, UInt16)\n+\n+        code = if fns != expected_fns\n+            unexpected_fns = collect(setdiff(Set(fns), Set(expected_fns)))\n+            missing_fns = collect(setdiff(Set(expected_fns), Set(fns)))\n+            :(function _CodeInfo(args...)\n+                  error(\"Unrecognized CodeInfo fields: Maybe version $VERSION is too new for this version of JuliaLowering?\"\n+                         * isempty(unexpected_fns) ? \"\" : \"\\nUnexpected fields found: $($unexpected_fns)\"\n+                         * isempty(missing_fns)    ? \"\" : \"\\nMissing fields:          $($missing_fns)\")\n+              end)\n+        elseif fts != expected_fts\n+            :(function _CodeInfo(args...)\n+                  error(\"Unrecognized CodeInfo field types: Maybe version $VERSION is too new for this version of JuliaLowering?\")\n+              end)\n+        else\n+            :(function _CodeInfo($(fns...))\n+                $(Expr(:new, :(Core.CodeInfo), conversions...))\n+            end)\n+        end\n+\n+        Core.eval(@__MODULE__, code)\n+    end\n+end\n+\n+function _compress_debuginfo(info)\n+    filename, edges, codelocs = info\n+    edges = Core.svec(map(_compress_debuginfo, edges)...)\n+    codelocs = @ccall jl_compress_codelocs((-1)::Int32, codelocs::Any,\n+                                           div(length(codelocs),3)::Csize_t)::String\n+    Core.DebugInfo(Symbol(filename), nothing, edges, codelocs)\n+end\n+\n+function ir_debug_info_state(ex)\n+    e1 = first(flattened_provenance(ex))\n+    topfile = filename(e1)\n+    [(topfile, [], Vector{Int32}())]\n+end\n+\n+function add_ir_debug_info!(current_codelocs_stack, stmt)\n+    locstk = [(filename(e), source_location(e)[1]) for e in flattened_provenance(stmt)]\n+    for j in 1:length(locstk)\n+        if j === 1 && current_codelocs_stack[j][1] != locstk[j][1]\n+            # dilemma: the filename stack here shares no prefix with that of the\n+            # previous statement, where differing filenames usually (j > 1) mean\n+            # a different macro expansion has started at this statement.  guess\n+            # that both files are the same, and inherit the previous filename.\n+            locstk[j] = (current_codelocs_stack[j][1], locstk[j][2])\n+        end\n+        if j < length(current_codelocs_stack) && (j === length(locstk) ||\n+                current_codelocs_stack[j+1][1] != locstk[j+1][1])\n+            while j < length(current_codelocs_stack)\n+                info = pop!(current_codelocs_stack)\n+                push!(last(current_codelocs_stack)[2], info)\n+            end\n+        elseif j > length(current_codelocs_stack)\n+            push!(current_codelocs_stack, (locstk[j][1], [], Vector{Int32}()))\n+        end\n+    end\n+    @assert length(locstk) === length(current_codelocs_stack)\n+    for (j, (file,line)) in enumerate(locstk)\n+        fn, edges, codelocs = current_codelocs_stack[j]\n+        @assert fn == file\n+        if j < length(locstk)\n+            edge_index = length(edges) + 1\n+            edge_codeloc_index = fld1(length(current_codelocs_stack[j+1][3]) + 1, 3)\n+        else\n+            edge_index = 0\n+            edge_codeloc_index = 0\n+        end\n+        push!(codelocs, line)\n+        push!(codelocs, edge_index)\n+        push!(codelocs, edge_codeloc_index)\n+    end\n+end\n+\n+function finish_ir_debug_info!(current_codelocs_stack)\n+    while length(current_codelocs_stack) > 1\n+        info = pop!(current_codelocs_stack)\n+        push!(last(current_codelocs_stack)[2], info)\n+    end\n+\n+    _compress_debuginfo(only(current_codelocs_stack))\n+end\n+\n+# Convert SyntaxTree to the CodeInfo+Expr data structures understood by the\n+# Julia runtime\n+function to_code_info(ex::SyntaxTree, slots::Vector{Slot}, meta::CompileHints)\n+    stmts = Any[]\n+\n+    current_codelocs_stack = ir_debug_info_state(ex)\n+\n+    nargs = sum((s.kind==:argument for s in slots), init=0)\n+    slotnames = Vector{Symbol}(undef, length(slots))\n+    slot_rename_inds = Dict{String,Int}()\n+    slotflags = Vector{UInt8}(undef, length(slots))\n+    for (i, slot) in enumerate(slots)\n+        name = slot.name\n+        # TODO: Do we actually want unique names here? The C code in\n+        # `jl_new_code_info_from_ir` has logic to simplify gensym'd names and\n+        # use the empty string for compiler-generated bindings.\n+        ni = get(slot_rename_inds, name, 0)\n+        slot_rename_inds[name] = ni + 1\n+        if ni > 0\n+            name = \"$name@$ni\"\n+        end\n+        sname = Symbol(name)\n+        slotnames[i] = sname\n+        slotflags[i] =                   # Inference          | Codegen\n+            slot.is_read          << 3 | # SLOT_USED          | jl_vinfo_sa\n+            slot.is_single_assign << 4 | # SLOT_ASSIGNEDONCE  | -\n+            slot.is_maybe_undef   << 5 | # SLOT_USEDUNDEF     | jl_vinfo_usedundef\n+            slot.is_called        << 6   # SLOT_CALLED        | -\n+        if slot.is_nospecialize\n+            # Ideally this should be a slot flag instead\n+            add_ir_debug_info!(current_codelocs_stack, ex)\n+            push!(stmts, Expr(:meta, :nospecialize, Core.SlotNumber(i)))\n+        end\n+    end\n+\n+    stmt_offset = length(stmts)\n+    for stmt in children(ex)\n+        push!(stmts, _to_lowered_expr(stmt, stmt_offset))\n+        add_ir_debug_info!(current_codelocs_stack, stmt)\n+    end\n+\n+    debuginfo = finish_ir_debug_info!(current_codelocs_stack)\n+\n+    has_image_globalref = any(codeinfo_has_image_globalref, stmts)\n+\n+    # TODO: Set ssaflags based on call site annotations:\n+    # - @inbounds annotations\n+    # - call site @inline / @noinline\n+    # - call site @assume_effects\n+    ssaflags = zeros(UInt32, length(stmts))\n+\n+    propagate_inbounds =\n+        get(meta, :propagate_inbounds, false)\n+    # TODO: Set true if there's a foreigncall\n+    has_fcall = false\n+    nospecializeinfer =\n+        get(meta, :nospecializeinfer, false)\n+    inlining =\n+        get(meta, :inline, false) ? 0x01 :\n+        get(meta, :noinline, false) ? 0x02 : 0x00\n+    constprop =\n+        get(meta, :aggressive_constprop, false) ? 0x01 :\n+        get(meta, :no_constprop, false) ? 0x02 : 0x00\n+    purity =\n+        let eo = get(meta, :purity, nothing)\n+            isnothing(eo) ? 0x0000 : Base.encode_effects_override(eo)\n+        end\n+\n+    # The following CodeInfo fields always get their default values for\n+    # uninferred code.\n+    ssavaluetypes      = length(stmts) # Why does the runtime code do this?\n+    slottypes          = nothing\n+    parent             = nothing\n+    method_for_inference_limit_heuristics = nothing\n+    edges               = nothing\n+    min_world           = Csize_t(1)\n+    max_world           = typemax(Csize_t)\n+    isva                = false\n+    inlining_cost       = 0xffff\n+    rettype             = Any\n+\n+    _CodeInfo(\n+        stmts,\n+        debuginfo,\n+        ssavaluetypes,\n+        ssaflags,\n+        slotnames,\n+        slotflags,\n+        slottypes,\n+        rettype,\n+        parent,\n+        edges,\n+        min_world,\n+        max_world,\n+        method_for_inference_limit_heuristics,\n+        nargs,\n+        propagate_inbounds,\n+        has_fcall,\n+        has_image_globalref,\n+        nospecializeinfer,\n+        isva,\n+        inlining,\n+        constprop,\n+        purity,\n+        inlining_cost\n+    )\n+end\n+\n+@fzone \"JL: to_lowered_expr\" function to_lowered_expr(ex::SyntaxTree)\n+    _to_lowered_expr(ex, 0)\n+end\n+\n+function _to_lowered_expr(ex::SyntaxTree, stmt_offset::Int)\n+    k = kind(ex)\n+    if is_literal(k)\n+        ex.value\n+    elseif k == K\"core\"\n+        name = ex.name_val\n+        if name == \"cglobal\"\n+            # Inference expects cglobal as call argument to be `GlobalRef`,\n+            # so we resolve that name as a symbol of `Core.Intrinsics` here.\n+            # https://github.com/JuliaLang/julia/blob/7a8cd6e202f1d1216a6c0c0b928fb43a123cada8/Compiler/src/validation.jl#L87\n+            GlobalRef(Core.Intrinsics, :cglobal)\n+        elseif name == \"nothing\"\n+            # Translate Core.nothing into literal `nothing`s (flisp uses a\n+            # special form (null) for this during desugaring, etc)\n+            nothing\n+        else\n+            GlobalRef(Core, Symbol(name))\n+        end\n+    elseif k == K\"top\"\n+        GlobalRef(Base, Symbol(ex.name_val))\n+    elseif k == K\"globalref\"\n+        GlobalRef(ex.mod, Symbol(ex.name_val))\n+    elseif k == K\"Identifier\"\n+        # Implicitly refers to name in parent module\n+        # TODO: Should we even have plain identifiers at this point or should\n+        # they all effectively be resolved into GlobalRef earlier?\n+        Symbol(ex.name_val)\n+    elseif k == K\"SourceLocation\"\n+        QuoteNode(source_location(LineNumberNode, ex))\n+    elseif k == K\"Symbol\"\n+        QuoteNode(Symbol(ex.name_val))\n+    elseif k == K\"slot\"\n+        Core.SlotNumber(ex.var_id)\n+    elseif k == K\"static_parameter\"\n+        Expr(:static_parameter, ex.var_id)\n+    elseif k == K\"SSAValue\"\n+        Core.SSAValue(ex.var_id + stmt_offset)\n+    elseif k == K\"return\"\n+        Core.ReturnNode(_to_lowered_expr(ex[1], stmt_offset))\n+    elseif k == K\"inert\"\n+        e1 = ex[1]\n+        getmeta(ex, :as_Expr, false) ? QuoteNode(Expr(e1)) : e1\n+    elseif k == K\"code_info\"\n+        ir = to_code_info(ex[1], ex.slots, ex.meta)\n+        if ex.is_toplevel_thunk\n+            Expr(:thunk, ir) # TODO: Maybe nice to just return a CodeInfo here?\n+        else\n+            ir\n+        end\n+    elseif k == K\"Value\"\n+        ex.value\n+    elseif k == K\"goto\"\n+        Core.GotoNode(ex[1].id + stmt_offset)\n+    elseif k == K\"gotoifnot\"\n+        Core.GotoIfNot(_to_lowered_expr(ex[1], stmt_offset), ex[2].id + stmt_offset)\n+    elseif k == K\"enter\"\n+        catch_idx = ex[1].id\n+        numchildren(ex) == 1 ?\n+            Core.EnterNode(catch_idx) :\n+            Core.EnterNode(catch_idx, _to_lowered_expr(ex[2], stmt_offset))\n+    elseif k == K\"method\"\n+        cs = map(e->_to_lowered_expr(e, stmt_offset), children(ex))\n+        # Ad-hoc unwrapping to satisfy `Expr(:method)` expectations\n+        cs1 = cs[1]\n+        c1 = cs1 isa QuoteNode ? cs1.value : cs1\n+        Expr(:method, c1, cs[2:end]...)\n+    elseif k == K\"newvar\"\n+        Core.NewvarNode(_to_lowered_expr(ex[1], stmt_offset))\n+    elseif k == K\"opaque_closure_method\"\n+        args = map(e->_to_lowered_expr(e, stmt_offset), children(ex))\n+        # opaque_closure_method has special non-evaluated semantics for the\n+        # `functionloc` line number node so we need to undo a level of quoting\n+        arg4 = args[4]\n+        @assert arg4 isa QuoteNode\n+        args[4] = arg4.value\n+        Expr(:opaque_closure_method, args...)\n+    elseif k == K\"meta\"\n+        args = Any[_to_lowered_expr(e, stmt_offset) for e in children(ex)]\n+        # Unpack K\"Symbol\" QuoteNode as `Expr(:meta)` requires an identifier here.\n+        arg1 = args[1]\n+        @assert arg1 isa QuoteNode\n+        args[1] = arg1.value\n+        Expr(:meta, args...)\n+    elseif k == K\"static_eval\"\n+        @assert numchildren(ex) == 1\n+        _to_lowered_expr(ex[1], stmt_offset)\n+    elseif k == K\"cfunction\"\n+        args = Any[_to_lowered_expr(e, stmt_offset) for e in children(ex)]\n+        if kind(ex[2]) == K\"static_eval\"\n+            args[2] = QuoteNode(args[2])\n+        end\n+        Expr(:cfunction, args...)\n+    else\n+        # Allowed forms according to https://docs.julialang.org/en/v1/devdocs/ast/\n+        #\n+        # call invoke static_parameter `=` method struct_type abstract_type\n+        # primitive_type global const new splatnew isdefined\n+        # enter leave pop_exception inbounds boundscheck loopinfo copyast meta\n+        # lambda\n+        head = k == K\"call\"      ? :call       :\n+               k == K\"new\"       ? :new        :\n+               k == K\"splatnew\"  ? :splatnew   :\n+               k == K\"=\"         ? :(=)        :\n+               k == K\"leave\"     ? :leave      :\n+               k == K\"isdefined\" ? :isdefined  :\n+               k == K\"latestworld\"       ? :latestworld       :\n+               k == K\"pop_exception\"     ? :pop_exception     :\n+               k == K\"captured_local\"    ? :captured_local    :\n+               k == K\"gc_preserve_begin\" ? :gc_preserve_begin :\n+               k == K\"gc_preserve_end\"   ? :gc_preserve_end   :\n+               k == K\"foreigncall\"       ? :foreigncall       :\n+               k == K\"new_opaque_closure\" ? :new_opaque_closure :\n+               nothing\n+        if isnothing(head)\n+            throw(LoweringError(ex, \"Unhandled form for kind $k\"))\n+        end\n+        ret = Expr(head)\n+        for e in children(ex)\n+            push!(ret.args, _to_lowered_expr(e, stmt_offset))\n+        end\n+        return ret\n+    end\n+end\n+\n+#-------------------------------------------------------------------------------\n+# Our version of eval - should be upstreamed though?\n+@fzone \"JL: eval\" function eval(mod::Module, ex::SyntaxTree;\n+                                macro_world::UInt=Base.get_world_counter(),\n+                                opts...)\n+    iter = lower_init(ex, mod, macro_world; opts...)\n+    _eval(mod, iter)\n+end\n+\n+# Version of eval() taking `Expr` (or Expr tree leaves of any type)\n+function eval(mod::Module, ex; opts...)\n+    eval(mod, expr_to_syntaxtree(ex); opts...)\n+end\n+\n+if VERSION >= v\"1.13.0-DEV.1199\" # https://github.com/JuliaLang/julia/pull/59604\n+\n+function _eval(mod, iter)\n+    modules = Module[]\n+    new_mod = nothing\n+    result = nothing\n+    while true\n+        thunk = lower_step(iter, new_mod)::Core.SimpleVector\n+        new_mod = nothing\n+        type = thunk[1]::Symbol\n+        if type == :done\n+            break\n+        elseif type == :begin_module\n+            push!(modules, mod)\n+            filename = something(thunk[4].file, :none)\n+            mod = @ccall jl_begin_new_module(mod::Any, thunk[2]::Symbol, thunk[3]::Cint,\n+                                             filename::Cstring, thunk[4].line::Cint)::Module\n+            new_mod = mod\n+        elseif type == :end_module\n+            @ccall jl_end_new_module(mod::Module)::Cvoid\n+            result = mod\n+            mod = pop!(modules)\n+        else\n+            @assert type == :thunk\n+            result = Core.eval(mod, thunk[2])\n+        end\n+    end\n+    @assert isempty(modules)\n+    return result\n+end\n+\n+else\n+\n+function _eval(mod, iter, new_mod=nothing)\n+    in_new_mod = !isnothing(new_mod)\n+    result = nothing\n+    while true\n+        thunk = lower_step(iter, new_mod)::Core.SimpleVector\n+        new_mod = nothing\n+        type = thunk[1]::Symbol\n+        if type == :done\n+            @assert !in_new_mod\n+            break\n+        elseif type == :begin_module\n+            name = thunk[2]::Symbol\n+            std_defs = thunk[3]\n+            result = Core.eval(mod,\n+                Expr(:module, std_defs, name,\n+                     Expr(:block, thunk[4], Expr(:call, m->_eval(m, iter, m), name)))\n+            )\n+        elseif type == :end_module\n+            @assert in_new_mod\n+            return mod\n+        else\n+            @assert type == :thunk\n+            result = Core.eval(mod, thunk[2])\n+        end\n+    end\n+    return result\n+end\n+\n+end\n+\n+\"\"\"\n+    include(mod::Module, path::AbstractString)\n+\n+Evaluate the contents of the input source file in the global scope of module\n+`mod`. Every module (except those defined with baremodule) has its own\n+definition of `include()` omitting the `mod` argument, which evaluates the file\n+in that module. Returns the result of the last evaluated expression of the\n+input file. During including, a task-local include path is set to the directory\n+containing the file. Nested calls to include will search relative to that path.\n+This function is typically used to load source interactively, or to combine\n+files in packages that are broken into multiple source files.\n+\"\"\"\n+function include(mod::Module, path::AbstractString)\n+    path, prev = Base._include_dependency(mod, path)\n+    code = read(path, String)\n+    tls = task_local_storage()\n+    tls[:SOURCE_PATH] = path\n+    try\n+        return include_string(mod, code, path)\n+    finally\n+        if prev === nothing\n+            delete!(tls, :SOURCE_PATH)\n+        else\n+            tls[:SOURCE_PATH] = prev\n+        end\n+    end\n+end\n+\n+\"\"\"\n+    include_string(mod::Module, code::AbstractString, filename::AbstractString=\"string\")\n+\n+Like `include`, except reads code from the given string rather than from a file.\n+\"\"\"\n+function include_string(mod::Module, code::AbstractString, filename::AbstractString=\"string\";\n+                        expr_compat_mode=false)\n+    eval(mod, parseall(SyntaxTree, code; filename=filename); expr_compat_mode)\n+end"
    },
    {
      "sha": "ca7ba9a0c3de1b1111f45b87ee82546e31956521",
      "filename": "JuliaLowering/src/hooks.jl",
      "status": "added",
      "additions": 62,
      "deletions": 0,
      "changes": 62,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fhooks.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fhooks.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fhooks.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,62 @@\n+\"\"\"\n+Becomes `Core._lower()` upon activating JuliaLowering.\n+\n+Returns an svec with the lowered code (usually expr) as its first element, and\n+(until integration is less experimental) whatever we want after it\n+\"\"\"\n+function core_lowering_hook(@nospecialize(code), mod::Module,\n+                            file=\"none\", line=0, world=typemax(Csize_t), warn=false)\n+    if !(code isa SyntaxTree || code isa Expr)\n+        # e.g. LineNumberNode, integer...\n+        return Core.svec(code)\n+    end\n+\n+    # TODO: fix in base\n+    file = file isa Ptr{UInt8} ? unsafe_string(file) : file\n+    line = !(line isa Int) ? Int(line) : line\n+\n+    local st0 = nothing\n+    try\n+        st0 = code isa Expr ? expr_to_syntaxtree(code, LineNumberNode(line, file)) : code\n+        if kind(st0) in KSet\"toplevel module\"\n+            return Core.svec(code)\n+        elseif kind(st0) === K\"doc\" && numchildren(st0) >= 2 && kind(st0[2]) === K\"module\"\n+            # TODO: this ignores module docstrings for now\n+            return Core.svec(Expr(st0[2]))\n+        end\n+        ctx1, st1 = expand_forms_1(  mod,  st0, true, world)\n+        ctx2, st2 = expand_forms_2(  ctx1, st1)\n+        ctx3, st3 = resolve_scopes(  ctx2, st2)\n+        ctx4, st4 = convert_closures(ctx3, st3)\n+        ctx5, st5 = linearize_ir(    ctx4, st4)\n+        ex = to_lowered_expr(st5)\n+        return Core.svec(ex, st5, ctx5)\n+    catch exc\n+        @info(\"JuliaLowering threw given input:\", code=code, st0=st0, file=file, line=line, mod=mod)\n+        rethrow(exc)\n+\n+        # TODO: Re-enable flisp fallback once we're done collecting errors\n+        # @error(\"JuliaLowering failed \u2014 falling back to flisp!\",\n+        #        exception=(exc,catch_backtrace()),\n+        #        code=code, file=file, line=line, mod=mod)\n+        # return Base.fl_lower(code, mod, file, line, world, warn)\n+    end\n+end\n+\n+# TODO: Write a parser hook here.  The input to `core_lowering_hook` should\n+# eventually be a (convertible to) SyntaxTree, but we need to make updates to\n+# the parsing API to include a parameter for AST type.\n+\n+const _has_v1_13_hooks = isdefined(Core, :_lower)\n+\n+function activate!(enable=true)\n+    if !_has_v1_13_hooks\n+        error(\"Cannot use JuliaLowering without `Core._lower` binding or in $VERSION < 1.13\")\n+    end\n+\n+    if enable\n+        Core._setlowerer!(core_lowering_hook)\n+    else\n+        Core._setlowerer!(Base.fl_lower)\n+    end\n+end"
    },
    {
      "sha": "22a243f12f0d5dfaf7c541d83ebcf28ae8fc3e87",
      "filename": "JuliaLowering/src/kinds.jl",
      "status": "added",
      "additions": 172,
      "deletions": 0,
      "changes": 172,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fkinds.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fkinds.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fkinds.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,172 @@\n+# The following kinds are used in intermediate forms by lowering but are not\n+# part of the surface syntax\n+function _register_kinds()\n+    JuliaSyntax.register_kinds!(JuliaLowering, 1, [\n+        # \"Syntax extensions\" - expression kinds emitted by macros or macro\n+        # expansion, and known to lowering. These are part of the AST API but\n+        # without having surface syntax.\n+        \"BEGIN_EXTENSION_KINDS\"\n+            # atomic fields or accesses (see `@atomic`)\n+            \"atomic\"\n+            # Flag for @generated parts of a function\n+            \"generated\"\n+            # Temporary rooting of identifiers (GC.@preserve)\n+            \"gc_preserve\"\n+            \"gc_preserve_begin\"\n+            \"gc_preserve_end\"\n+            # A literal Julia value of any kind, as might be inserted into the\n+            # AST during macro expansion\n+            \"Value\"\n+            # A (quoted) `Symbol`\n+            \"Symbol\"\n+            # QuoteNode; not quasiquote\n+            \"inert\"\n+            # Compiler metadata hints\n+            \"meta\"\n+            # TODO: Use `meta` for inbounds and loopinfo etc?\n+            \"inbounds\"\n+            \"boundscheck\"\n+            \"inline\"\n+            \"noinline\"\n+            \"loopinfo\"\n+            # Call into foreign code. Emitted by `@ccall`\n+            \"foreigncall\"\n+            # Special form for constructing a function callable from C\n+            \"cfunction\"\n+            # Special form emitted by `Base.Experimental.@opaque`\n+            \"opaque_closure\"\n+            # Test whether a variable is defined\n+            \"isdefined\"\n+            # [K\"throw_undef_if_not\" var cond]\n+            # This form is used internally in Core.Compiler but might be\n+            # emitted by packages such as Diffractor. In principle it needs to\n+            # be passed through lowering in a similar way to `isdefined`\n+            \"throw_undef_if_not\"\n+            # named labels for `@label` and `@goto`\n+            \"symbolic_label\"\n+            # Goto named label\n+            \"symbolic_goto\"\n+            # Internal initializer for struct types, for inner constructors/functions\n+            \"new\"\n+            \"splatnew\"\n+            # Used for converting `esc()`'d expressions arising from old macro\n+            # invocations during macro expansion (gone after macro expansion)\n+            \"escape\"\n+            # Used for converting the old-style macro hygienic-scope form (gone\n+            # after macro expansion)\n+            \"hygienic_scope\"\n+            # An expression which will eventually be evaluated \"statically\" in\n+            # the context of a CodeInfo and thus allows access only to globals\n+            # and static parameters. Used for ccall, cfunction, cglobal\n+            # TODO: Use this for GeneratedFunctionStub also?\n+            \"static_eval\"\n+            # Catch-all for additional syntax extensions without the need to\n+            # extend `Kind`. Known extensions include:\n+            #   locals, islocal, isglobal\n+            # The content of an assertion is not considered to be quoted, so\n+            # use K\"Symbol\" or K\"inert\" inside where necessary.\n+            \"extension\"\n+        \"END_EXTENSION_KINDS\"\n+\n+        # The following kinds are internal to lowering\n+        \"BEGIN_LOWERING_KINDS\"\n+            # Semantic assertions used by lowering. The content of an assertion\n+            # is not considered to be quoted, so use K\"Symbol\" etc inside where necessary.\n+            \"assert\"\n+            # Unique identifying integer for bindings (of variables, constants, etc)\n+            \"BindingId\"\n+            # Various heads harvested from flisp lowering.\n+            # (TODO: May or may not need all these - assess later)\n+            \"break_block\"\n+            # Like block, but introduces a lexical scope; used during scope resolution.\n+            \"scope_block\"\n+            # [K\"always_defined\" x] is an assertion that variable `x` is assigned before use\n+            # ('local-def in flisp implementation is K\"local\" plus K\"always_defined\"\n+            \"always_defined\"\n+            \"_while\"\n+            \"_do_while\"\n+            \"_typevars\" # used for supplying already-allocated `TypeVar`s to `where`\n+            \"with_static_parameters\"\n+            \"top\"\n+            \"core\"\n+            \"lambda\"\n+            # \"A source location literal\" - a node which exists only to record\n+            # a sourceref\n+            \"SourceLocation\"\n+            # [K\"function_decl\" name]\n+            # Declare a zero-method generic function with global `name` or\n+            # creates a closure object and assigns it to the local `name`.\n+            \"function_decl\"\n+            # [K\"function_type name]\n+            # Evaluates to the type of the function or closure with given `name`\n+            \"function_type\"\n+            # [K\"method_defs\" name block]\n+            # The code in `block` defines methods for generic function `name`\n+            \"method_defs\"\n+            # The code in `block` defines methods for generic function `name`\n+            \"_opaque_closure\"\n+            # The enclosed statements must be executed at top level\n+            \"toplevel_butfirst\"\n+            \"assign_or_constdecl_if_global\"\n+            \"moved_local\"\n+            \"label\"\n+            \"trycatchelse\"\n+            \"tryfinally\"\n+            # The contained block of code causes no side effects and can be\n+            # removed by a later lowering pass if its value isn't used.\n+            # (That is, it's removable in the same sense as\n+            #  `@assume_effects :removable`.)\n+            \"removable\"\n+            # Variable type declaration; `x::T = rhs` will be temporarily\n+            # desugared to include `(decl x T)`\n+            \"decl\"\n+            # [K\"captured_local\" index]\n+            # A local variable captured into a global method. Contains the\n+            # `index` of the associated `Box` in the rewrite list.\n+            \"captured_local\"\n+            # Causes the linearization pass to conditionally emit a world age increment\n+            \"latestworld_if_toplevel\"\n+            # This has two forms:\n+            #   [K\"constdecl\" var val] => declare and assign constant\n+            #   [K\"constdecl\" var]     => declare undefined constant\n+            #                             var is GlobalRef Value or Identifier\n+            \"constdecl\"\n+            # Returned from statements that should error if the result is used.\n+            \"unused_only\"\n+        \"END_LOWERING_KINDS\"\n+\n+        # The following kinds are emitted by lowering and used in Julia's untyped IR\n+        \"BEGIN_IR_KINDS\"\n+            # Identifier for a value which is only assigned once\n+            \"SSAValue\"\n+            # Local variable in a `CodeInfo` code object (including lambda arguments)\n+            \"slot\"\n+            # Static parameter to a `CodeInfo` code object (\"type parameters\" to methods)\n+            \"static_parameter\"\n+            # References/declares a global variable within a module\n+            \"globalref\"\n+            # Unconditional goto\n+            \"goto\"\n+            # Conditional goto\n+            \"gotoifnot\"\n+            # Exception handling\n+            \"enter\"\n+            \"leave\"\n+            \"pop_exception\"\n+            # Lowering targets for method definitions arising from `function` etc\n+            \"method\"\n+            # (re-)initialize a slot to undef\n+            # See Core.NewvarNode\n+            \"newvar\"\n+            # Result of lowering a `K\"lambda\"` after bindings have been\n+            # converted to slot/globalref/SSAValue.\n+            \"code_info\"\n+            # Internal initializer for opaque closures\n+            \"new_opaque_closure\"\n+            # Wrapper for the lambda of around opaque closure methods\n+            \"opaque_closure_method\"\n+            # World age increment (TODO: use top level assertion and only one latestworld kind)\n+            \"latestworld\"\n+        \"END_IR_KINDS\"\n+    ])\n+end"
    },
    {
      "sha": "2b6838f9e97d32fada2173efa9c06f95e58020d1",
      "filename": "JuliaLowering/src/linear_ir.jl",
      "status": "added",
      "additions": 1140,
      "deletions": 0,
      "changes": 1140,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Flinear_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Flinear_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Flinear_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,1140 @@\n+#-------------------------------------------------------------------------------\n+# Lowering pass 5: Flatten to linear IR\n+\n+function is_valid_ir_argument(ctx, ex)\n+    k = kind(ex)\n+    if is_simple_atom(ctx, ex) || k in KSet\"inert top core quote static_eval\"\n+        true\n+    elseif k == K\"BindingId\"\n+        binfo = lookup_binding(ctx, ex)\n+        bk = binfo.kind\n+        bk === :slot\n+        # TODO: We should theoretically be able to allow `bk ===\n+        # :static_parameter` for slightly more compact IR, but it's uncertain\n+        # what the compiler is built to tolerate.  Notably, flisp allows\n+        # static_parameter, but doesn't produce this form until a later pass, so\n+        # it doesn't end up in the IR.\n+    else\n+        false\n+    end\n+end\n+\n+function is_ssa(ctx, ex)\n+    kind(ex) == K\"BindingId\" && lookup_binding(ctx, ex).is_ssa\n+end\n+\n+# Target to jump to, including info on try handler nesting and catch block\n+# nesting\n+struct JumpTarget{GraphType}\n+    label::SyntaxTree{GraphType}\n+    handler_token_stack::SyntaxList{GraphType, Vector{NodeId}}\n+    catch_token_stack::SyntaxList{GraphType, Vector{NodeId}}\n+end\n+\n+function JumpTarget(label::SyntaxTree{GraphType}, ctx) where {GraphType}\n+    JumpTarget{GraphType}(label, copy(ctx.handler_token_stack), copy(ctx.catch_token_stack))\n+end\n+\n+struct JumpOrigin{GraphType}\n+    goto::SyntaxTree{GraphType}\n+    index::Int\n+    handler_token_stack::SyntaxList{GraphType, Vector{NodeId}}\n+    catch_token_stack::SyntaxList{GraphType, Vector{NodeId}}\n+end\n+\n+function JumpOrigin(goto::SyntaxTree{GraphType}, index, ctx) where {GraphType}\n+    JumpOrigin{GraphType}(goto, index, copy(ctx.handler_token_stack), copy(ctx.catch_token_stack))\n+end\n+\n+struct FinallyHandler{GraphType}\n+    tagvar::SyntaxTree{GraphType}\n+    target::JumpTarget{GraphType}\n+    exit_actions::Vector{Tuple{Symbol,Union{Nothing,SyntaxTree{GraphType}}}}\n+end\n+\n+function FinallyHandler(tagvar::SyntaxTree{GraphType}, target::JumpTarget) where {GraphType}\n+    FinallyHandler{GraphType}(tagvar, target,\n+        Vector{Tuple{Symbol, Union{Nothing,SyntaxTree{GraphType}}}}())\n+end\n+\n+\n+\"\"\"\n+Context for creating linear IR.\n+\n+One of these is created per lambda expression to flatten the body down to\n+a sequence of statements (linear IR), which eventually becomes one CodeInfo.\n+\"\"\"\n+struct LinearIRContext{GraphType} <: AbstractLoweringContext\n+    graph::GraphType\n+    code::SyntaxList{GraphType, Vector{NodeId}}\n+    bindings::Bindings\n+    next_label_id::Ref{Int}\n+    is_toplevel_thunk::Bool\n+    lambda_bindings::LambdaBindings\n+    return_type::Union{Nothing, SyntaxTree{GraphType}}\n+    break_targets::Dict{String, JumpTarget{GraphType}}\n+    handler_token_stack::SyntaxList{GraphType, Vector{NodeId}}\n+    catch_token_stack::SyntaxList{GraphType, Vector{NodeId}}\n+    finally_handlers::Vector{FinallyHandler{GraphType}}\n+    symbolic_jump_targets::Dict{String,JumpTarget{GraphType}}\n+    symbolic_jump_origins::Vector{JumpOrigin{GraphType}}\n+    meta::Dict{Symbol, Any}\n+    mod::Module\n+end\n+\n+function LinearIRContext(ctx, is_toplevel_thunk, lambda_bindings, return_type)\n+    graph = syntax_graph(ctx)\n+    rett = isnothing(return_type) ? nothing : reparent(graph, return_type)\n+    GraphType = typeof(graph)\n+    LinearIRContext(graph, SyntaxList(ctx), ctx.bindings, Ref(0),\n+                    is_toplevel_thunk, lambda_bindings, rett,\n+                    Dict{String,JumpTarget{GraphType}}(), SyntaxList(ctx), SyntaxList(ctx),\n+                    Vector{FinallyHandler{GraphType}}(), Dict{String,JumpTarget{GraphType}}(),\n+                    Vector{JumpOrigin{GraphType}}(), Dict{Symbol, Any}(), ctx.mod)\n+end\n+\n+function current_lambda_bindings(ctx::LinearIRContext)\n+    ctx.lambda_bindings\n+end\n+\n+function is_valid_body_ir_argument(ctx, ex)\n+    if is_valid_ir_argument(ctx, ex)\n+        true\n+    elseif kind(ex) == K\"BindingId\"\n+        binfo = lookup_binding(ctx, ex)\n+        # Arguments are always defined\n+        # TODO: use equiv of vinfo:never-undef when we have it\n+        binfo.kind == :argument\n+    else\n+        false\n+    end\n+end\n+\n+function is_simple_arg(ctx, ex)\n+    k = kind(ex)\n+    return is_simple_atom(ctx, ex) || k == K\"BindingId\" || k == K\"quote\" || k == K\"inert\" ||\n+           k == K\"top\" || k == K\"core\" || k == K\"globalref\" || k == K\"static_eval\"\n+end\n+\n+function is_single_assign_var(ctx::LinearIRContext, ex)\n+    kind(ex) == K\"BindingId\" || return false\n+    binfo = lookup_binding(ctx, ex)\n+    # Arguments are always single-assign\n+    # TODO: Use equiv of vinfo:sa when we have it\n+    return binfo.kind == :argument\n+end\n+\n+function is_const_read_arg(ctx, ex)\n+    k = kind(ex)\n+    # Even if we have side effects, we know that singly-assigned\n+    # locals cannot be affected by them so we can inline them anyway.\n+    # TODO from flisp: \"We could also allow const globals here\"\n+    return k == K\"inert\" || k == K\"top\" || k == K\"core\" || k == K\"static_eval\" ||\n+        is_simple_atom(ctx, ex) || is_single_assign_var(ctx, ex)\n+end\n+\n+function is_valid_ir_rvalue(ctx, lhs, rhs)\n+    return is_ssa(ctx, lhs) ||\n+           is_valid_ir_argument(ctx, rhs) ||\n+           (kind(lhs) == K\"BindingId\" &&\n+            # FIXME: add: invoke ?\n+            kind(rhs) in KSet\"new splatnew cfunction isdefined call foreigncall gc_preserve_begin foreigncall new_opaque_closure\")\n+end\n+\n+function check_no_local_bindings(ctx, ex, msg)\n+    contains_nonglobal_binding = contains_unquoted(ex) do e\n+        kind(e) == K\"BindingId\" && lookup_binding(ctx, e).kind !== :global\n+    end\n+    if contains_nonglobal_binding\n+        throw(LoweringError(ex, msg))\n+    end\n+end\n+\n+# evaluate the arguments of a call, creating temporary locations as needed\n+function compile_args(ctx, args)\n+    # First check if all the arguments are simple (and therefore side-effect free).\n+    # Otherwise, we need to use ssa values for all arguments to ensure proper\n+    # left-to-right evaluation semantics.\n+    all_simple = all(a->is_simple_arg(ctx, a), args)\n+    args_out = SyntaxList(ctx)\n+    for arg in args\n+        arg_val = compile(ctx, arg, true, false)\n+        if (all_simple || is_const_read_arg(ctx, arg_val)) && is_valid_body_ir_argument(ctx, arg_val)\n+            push!(args_out, arg_val)\n+        else\n+            push!(args_out, emit_assign_tmp(ctx, arg_val))\n+        end\n+    end\n+    return args_out\n+end\n+\n+function emit(ctx::LinearIRContext, ex)\n+    push!(ctx.code, ex)\n+    return ex\n+end\n+\n+function emit(ctx::LinearIRContext, srcref, k, args...)\n+    emit(ctx, makenode(ctx, srcref, k, args...))\n+end\n+\n+# Emit computation of ex, assigning the result to an ssavar and returning that\n+function emit_assign_tmp(ctx::LinearIRContext, ex, name=\"tmp\")\n+    tmp = ssavar(ctx, ex, name)\n+    emit(ctx, @ast ctx ex [K\"=\" tmp ex])\n+    return tmp\n+end\n+\n+function compile_pop_exception(ctx, srcref, src_tokens, dest_tokens)\n+    # It's valid to leave the context of src_tokens for the context of\n+    # dest_tokens when src_tokens is the same or nested within dest_tokens.\n+    # It's enough to check the token on the top of the dest stack.\n+    n = length(dest_tokens)\n+    jump_ok = n == 0 || (n <= length(src_tokens) && dest_tokens[n].var_id == src_tokens[n].var_id)\n+    jump_ok || throw(LoweringError(srcref, \"Attempt to jump into catch block\"))\n+    if n < length(src_tokens)\n+        @ast ctx srcref [K\"pop_exception\" src_tokens[n+1]]\n+    else\n+        nothing\n+    end\n+end\n+\n+function compile_leave_handler(ctx, srcref, src_tokens, dest_tokens)\n+    n = length(dest_tokens)\n+    jump_ok = n == 0 || (n <= length(src_tokens) && dest_tokens[n].var_id == src_tokens[n].var_id)\n+    jump_ok || throw(LoweringError(srcref, \"Attempt to jump into try block\"))\n+    if n < length(src_tokens)\n+        @ast ctx srcref [K\"leave\" src_tokens[n+1:end]...]\n+    else\n+        nothing\n+    end\n+end\n+\n+function emit_pop_exception(ctx::LinearIRContext, srcref, dest_tokens)\n+    pexc = compile_pop_exception(ctx, srcref, ctx.catch_token_stack, dest_tokens)\n+    if !isnothing(pexc)\n+        emit(ctx, pexc)\n+    end\n+end\n+\n+function emit_leave_handler(ctx::LinearIRContext, srcref, dest_tokens)\n+    ex = compile_leave_handler(ctx, srcref, ctx.handler_token_stack, dest_tokens)\n+    if !isnothing(ex)\n+        emit(ctx, ex)\n+    end\n+end\n+\n+function emit_jump(ctx, srcref, target::JumpTarget)\n+    emit_pop_exception(ctx, srcref, target.catch_token_stack)\n+    emit_leave_handler(ctx, srcref, target.handler_token_stack)\n+    emit(ctx, @ast ctx srcref [K\"goto\" target.label])\n+end\n+\n+# Enter the current finally block, either through the landing pad (on_exit ==\n+# :rethrow) or via a jump (on_exit \u2208 (:return, :break)).\n+#\n+# An integer tag is created to identify the current code path and select the\n+# on_exit action to be taken at finally handler exit.\n+function enter_finally_block(ctx, srcref, on_exit, value)\n+    @assert on_exit \u2208 (:rethrow, :break, :return)\n+    handler = last(ctx.finally_handlers)\n+    push!(handler.exit_actions, (on_exit, value))\n+    tag = length(handler.exit_actions)\n+    emit(ctx, @ast ctx srcref [K\"=\" handler.tagvar tag::K\"Integer\"])\n+    if on_exit != :rethrow\n+        emit_jump(ctx, srcref, handler.target)\n+    end\n+end\n+\n+# Helper function for emit_return\n+function _actually_return(ctx, ex)\n+    # TODO: Handle the implicit return coverage hack for #53354 ?\n+    rett = ctx.return_type\n+    if !isnothing(rett)\n+        ex = compile(ctx, convert_for_type_decl(ctx, rett, ex, rett, true), true, false)\n+    end\n+    simple_ret_val = isempty(ctx.catch_token_stack) ?\n+        # returning lambda directly is needed for @generated\n+        (is_valid_ir_argument(ctx, ex) || kind(ex) == K\"lambda\") :\n+        is_simple_atom(ctx, ex)\n+    if !simple_ret_val\n+        ex = emit_assign_tmp(ctx, ex, \"return_tmp\")\n+    end\n+    emit_pop_exception(ctx, ex, ())\n+    emit(ctx, @ast ctx ex [K\"return\" ex])\n+    return nothing\n+end\n+\n+function emit_return(ctx, srcref, ex)\n+    # todo: Mark implicit returns\n+    if isnothing(ex)\n+        return\n+    elseif isempty(ctx.handler_token_stack)\n+        _actually_return(ctx, ex)\n+        return\n+    end\n+    # TODO: What's this !is_ssa(ctx, ex) here about?\n+    x = if is_simple_atom(ctx, ex) && !(is_ssa(ctx, ex) && !isempty(ctx.finally_handlers))\n+        ex\n+    elseif !isempty(ctx.finally_handlers)\n+        # todo: Why does flisp lowering create a mutable variable here even\n+        # though we don't mutate it?\n+        # tmp = ssavar(ctx, srcref, \"returnval_via_finally\") # <- can we use this?\n+        tmp = new_local_binding(ctx, srcref, \"returnval_via_finally\")\n+        emit(ctx, @ast ctx srcref [K\"=\" tmp ex])\n+        tmp\n+    else\n+        emit_assign_tmp(ctx, ex, \"returnval_via_finally\")\n+    end\n+    if !isempty(ctx.finally_handlers)\n+        enter_finally_block(ctx, srcref, :return, x)\n+    else\n+        emit(ctx, @ast ctx srcref [K\"leave\" ctx.handler_token_stack...])\n+        _actually_return(ctx, x)\n+    end\n+    return nothing\n+end\n+\n+function emit_return(ctx, ex)\n+    emit_return(ctx, ex, ex)\n+end\n+\n+function emit_break(ctx, ex)\n+    name = ex[1].name_val\n+    target = get(ctx.break_targets, name, nothing)\n+    if isnothing(target)\n+        ty = name == \"loop_exit\" ? \"break\" : \"continue\"\n+        throw(LoweringError(ex, \"$ty must be used inside a `while` or `for` loop\"))\n+    end\n+    if !isempty(ctx.finally_handlers)\n+        handler = last(ctx.finally_handlers)\n+        if length(target.handler_token_stack) < length(handler.target.handler_token_stack)\n+            enter_finally_block(ctx, ex, :break, ex)\n+            return\n+        end\n+    end\n+    emit_jump(ctx, ex, target)\n+end\n+\n+# `op` may be either K\"=\" (where global assignments are converted to setglobal!)\n+# or K\"constdecl\".  flisp: emit-assignment-or-setglobal\n+function emit_simple_assignment(ctx, srcref, lhs, rhs, op=K\"=\")\n+    binfo = lookup_binding(ctx, lhs.var_id)\n+    if binfo.kind == :global\n+        emit(ctx, @ast ctx srcref [\n+            K\"call\"\n+            op == K\"constdecl\" ? \"declare_const\"::K\"core\" : \"setglobal!\"::K\"core\"\n+            binfo.mod::K\"Value\"\n+            binfo.name::K\"Symbol\"\n+            rhs\n+        ])\n+    else\n+        emit(ctx, srcref, op, lhs, rhs)\n+    end\n+end\n+\n+function emit_assignment(ctx, srcref, lhs, rhs, op=K\"=\")\n+    if !isnothing(rhs)\n+        if is_valid_ir_rvalue(ctx, lhs, rhs)\n+            emit_simple_assignment(ctx, srcref, lhs, rhs, op)\n+        else\n+            r = emit_assign_tmp(ctx, rhs)\n+            emit_simple_assignment(ctx, srcref, lhs, r, op)\n+        end\n+    else\n+        # in unreachable code (such as after return); still emit the assignment\n+        # so that the structure of those uses is preserved\n+        emit_simple_assignment(ctx, srcref, lhs, nothing_(ctx, srcref), op)\n+        nothing\n+    end\n+end\n+\n+function make_label(ctx, srcref)\n+    id = ctx.next_label_id[]\n+    ctx.next_label_id[] += 1\n+    makeleaf(ctx, srcref, K\"label\", id=id)\n+end\n+\n+# flisp: make&mark-label\n+function emit_label(ctx, srcref)\n+    if !isempty(ctx.code)\n+        # Use current label if available\n+        e = ctx.code[end]\n+        if kind(e) == K\"label\"\n+            return e\n+        end\n+    end\n+    l = make_label(ctx, srcref)\n+    emit(ctx, l)\n+    l\n+end\n+\n+function emit_latestworld(ctx, srcref)\n+    (isempty(ctx.code) || kind(last(ctx.code)) != K\"latestworld\") &&\n+        emit(ctx, makeleaf(ctx, srcref, K\"latestworld\"))\n+end\n+\n+function compile_condition_term(ctx, ex)\n+    cond = compile(ctx, ex, true, false)\n+    if !is_valid_body_ir_argument(ctx, cond)\n+        cond = emit_assign_tmp(ctx, cond)\n+    end\n+    return cond\n+end\n+\n+# flisp: emit-cond\n+function compile_conditional(ctx, ex, false_label)\n+    if kind(ex) == K\"block\"\n+        for i in 1:numchildren(ex)-1\n+            compile(ctx, ex[i], false, false)\n+        end\n+        test = ex[end]\n+    else\n+        test = ex\n+    end\n+    k = kind(test)\n+    if k == K\"||\"\n+        true_label = make_label(ctx, test)\n+        for (i,e) in enumerate(children(test))\n+            c = compile_condition_term(ctx, e)\n+            if i < numchildren(test)\n+                next_term_label = make_label(ctx, test)\n+                # Jump over short circuit\n+                emit(ctx, @ast ctx e [K\"gotoifnot\" c next_term_label])\n+                # Short circuit to true\n+                emit(ctx, @ast ctx e [K\"goto\" true_label])\n+                emit(ctx, next_term_label)\n+            else\n+                emit(ctx, @ast ctx e [K\"gotoifnot\" c false_label])\n+            end\n+        end\n+        emit(ctx, true_label)\n+    elseif k == K\"&&\"\n+        for e in children(test)\n+            c = compile_condition_term(ctx, e)\n+            emit(ctx, @ast ctx e [K\"gotoifnot\" c false_label])\n+        end\n+    else\n+        c = compile_condition_term(ctx, test)\n+        emit(ctx, @ast ctx test [K\"gotoifnot\" c false_label])\n+    end\n+end\n+\n+# Lowering of exception handling must ensure that\n+#\n+# * Each `enter` is matched with a `leave` on every possible non-exceptional\n+#   program path (including implicit returns generated in tail position).\n+# * Each catch block which is entered and handles the exception - by exiting\n+#   via a non-exceptional program path - leaves the block with `pop_exception`.\n+# * Each `finally` block runs, regardless of any early `return` or jumps\n+#   via `break`/`continue`/`goto` etc.\n+#\n+# These invariants are upheld by tracking the nesting using\n+# `handler_token_stack` and `catch_token_stack` and using these when emitting\n+# any control flow (return / goto) which leaves the associated block.\n+#\n+# The following special forms are emitted into the IR:\n+#\n+#   (= tok (enter catch_label dynscope))\n+#     push exception handler with catch block at `catch_label` and dynamic\n+#     scope `dynscope`, yielding a token which is used by `leave` and\n+#     `pop_exception`. `dynscope` is only used in the special `tryfinally` form\n+#     without associated source level syntax (see the `@with` macro)\n+#\n+#   (leave tok)\n+#     pop exception handler back to the state of the `tok` from the associated\n+#     `enter`. Multiple tokens can be supplied to pop multiple handlers using\n+#     `(leave tok1 tok2 ...)`.\n+#\n+#   (pop_exception tok) - pop exception stack back to state of associated enter\n+#\n+# See the devdocs for further discussion.\n+function compile_try(ctx::LinearIRContext, ex, needs_value, in_tail_pos)\n+    @chk numchildren(ex) <= 3\n+    try_block = ex[1]\n+    if kind(ex) == K\"trycatchelse\"\n+        catch_block = ex[2]\n+        else_block = numchildren(ex) == 2 ? nothing : ex[3]\n+        finally_block = nothing\n+        catch_label = make_label(ctx, catch_block)\n+    else\n+        catch_block = nothing\n+        else_block = nothing\n+        finally_block = ex[2]\n+        catch_label = make_label(ctx, finally_block)\n+    end\n+\n+    end_label = !in_tail_pos || !isnothing(finally_block) ? make_label(ctx, ex) : nothing\n+    try_result = needs_value && !in_tail_pos ? new_local_binding(ctx, ex, \"try_result\") : nothing\n+\n+    # Exception handler block prefix\n+    handler_token = ssavar(ctx, ex, \"handler_token\")\n+    emit(ctx, @ast ctx ex [K\"=\"\n+        handler_token\n+        [K\"enter\" catch_label]  # TODO: dynscope\n+    ])\n+    if !isnothing(finally_block)\n+        # TODO: Trivial finally block optimization from JuliaLang/julia#52593 (or\n+        # support a special form for @with)?\n+        finally_handler = FinallyHandler(new_local_binding(ctx, finally_block, \"finally_tag\"),\n+                                         JumpTarget(end_label, ctx))\n+        push!(ctx.finally_handlers, finally_handler)\n+        emit(ctx, @ast ctx finally_block [K\"=\" finally_handler.tagvar (-1)::K\"Integer\"])\n+    end\n+    push!(ctx.handler_token_stack, handler_token)\n+\n+    # Try block code.\n+    try_val = compile(ctx, try_block, needs_value, false)\n+    # Exception handler block postfix\n+    if isnothing(else_block)\n+        if in_tail_pos\n+            if !isnothing(try_val)\n+                emit_return(ctx, try_val)\n+            end\n+        else\n+            if needs_value && !isnothing(try_val)\n+                emit_assignment(ctx, ex, try_result, try_val)\n+            end\n+            emit(ctx, @ast ctx ex [K\"leave\" handler_token])\n+        end\n+        pop!(ctx.handler_token_stack)\n+    else\n+        if !isnothing(try_val) && (in_tail_pos || needs_value)\n+            emit(ctx, try_val) # TODO: Only for any side effects ?\n+        end\n+        emit(ctx, @ast ctx ex [K\"leave\" handler_token])\n+        pop!(ctx.handler_token_stack)\n+        # Else block code\n+        else_val = compile(ctx, else_block, needs_value, in_tail_pos)\n+        if !in_tail_pos\n+            if needs_value && !isnothing(else_val)\n+                emit_assignment(ctx, ex, try_result, else_val)\n+            end\n+        end\n+    end\n+    if !in_tail_pos\n+        emit(ctx, @ast ctx ex [K\"goto\" end_label])\n+    end\n+\n+    # Catch pad\n+    # Emit either catch or finally block. A combined try/catch/finally block\n+    # was split into separate trycatchelse and tryfinally blocks earlier.\n+    emit(ctx, catch_label) # <- Exceptional control flow enters here\n+    if !isnothing(finally_block)\n+        # Attribute the postfix and prefix to the finally block as a whole.\n+        srcref = finally_block\n+        enter_finally_block(ctx, srcref, :rethrow, nothing)\n+        emit(ctx, end_label) # <- Non-exceptional control flow enters here\n+        pop!(ctx.finally_handlers)\n+        compile(ctx, finally_block, false, false)\n+        # Finally block postfix: Emit a branch for every code path which enters\n+        # the block to dynamically decide which return/break/rethrow exit action to take\n+        for (tag, (on_exit, value)) in Iterators.reverse(enumerate(finally_handler.exit_actions))\n+            next_action_label = !in_tail_pos || tag != 1 || on_exit != :return ?\n+                make_label(ctx, srcref) : nothing\n+            if !isnothing(next_action_label)\n+                next_action_label = make_label(ctx, srcref)\n+                tmp = ssavar(ctx, srcref, \"do_finally_action\")\n+                emit(ctx, @ast ctx srcref [K\"=\" tmp\n+                    [K\"call\"\n+                        \"===\"::K\"core\"\n+                        finally_handler.tagvar\n+                        tag::K\"Integer\"\n+                    ]\n+                ])\n+                emit(ctx, @ast ctx srcref [K\"gotoifnot\" tmp next_action_label])\n+            end\n+            if on_exit === :return\n+                emit_return(ctx, value)\n+            elseif on_exit === :break\n+                emit_break(ctx, value)\n+            elseif on_exit === :rethrow\n+                emit(ctx, @ast ctx srcref [K\"call\" \"rethrow\"::K\"top\"])\n+            else\n+                @assert false\n+            end\n+            if !isnothing(next_action_label)\n+                emit(ctx, next_action_label)\n+            end\n+        end\n+    else\n+        push!(ctx.catch_token_stack, handler_token)\n+        catch_val = compile(ctx, catch_block, needs_value, in_tail_pos)\n+        if !isnothing(try_result) && !isnothing(catch_val)\n+            emit_assignment(ctx, ex, try_result, catch_val)\n+        end\n+        if !in_tail_pos\n+            emit(ctx, @ast ctx ex [K\"pop_exception\" handler_token])\n+            emit(ctx, end_label)\n+        else\n+            # (pop_exception done in emit_return)\n+        end\n+        pop!(ctx.catch_token_stack)\n+    end\n+    try_result\n+end\n+\n+# This pass behaves like an interpreter on the given code.\n+# To perform stateful operations, it calls `emit` to record that something\n+# needs to be done. In value position, it returns an expression computing\n+# the needed value.\n+function compile(ctx::LinearIRContext, ex, needs_value, in_tail_pos)\n+    k = kind(ex)\n+    if k == K\"BindingId\" || is_literal(k) || k == K\"quote\" || k == K\"inert\" ||\n+            k == K\"top\" || k == K\"core\" || k == K\"Value\" || k == K\"Symbol\" ||\n+            k == K\"SourceLocation\" || k == K\"static_eval\"\n+        if in_tail_pos\n+            emit_return(ctx, ex)\n+        elseif needs_value\n+            ex\n+        else\n+            if k == K\"BindingId\" && !is_ssa(ctx, ex)\n+                emit(ctx, ex) # keep identifiers for undefined-var checking\n+            end\n+            nothing\n+        end\n+    elseif k == K\"Placeholder\"\n+        if needs_value\n+            throw(LoweringError(ex, \"all-underscore identifiers are write-only and their values cannot be used in expressions\"))\n+        end\n+        nothing\n+    elseif k == K\"TOMBSTONE\"\n+        @chk !needs_value (ex,\"TOMBSTONE encountered in value position\")\n+        nothing\n+    elseif k == K\"call\" || k == K\"new\" || k == K\"splatnew\" || k == K\"foreigncall\" ||\n+            k == K\"new_opaque_closure\" || k == K\"cfunction\"\n+        callex = makenode(ctx, ex, k, compile_args(ctx, children(ex)))\n+        if in_tail_pos\n+            emit_return(ctx, ex, callex)\n+        elseif needs_value\n+            callex\n+        else\n+            emit(ctx, callex)\n+            nothing\n+        end\n+    elseif k == K\"=\" || k == K\"constdecl\"\n+        lhs = ex[1]\n+        res = if kind(lhs) == K\"Placeholder\"\n+            compile(ctx, ex[2], needs_value, in_tail_pos)\n+        elseif k == K\"constdecl\" && numchildren(ex) == 1\n+            # No RHS - make undefined constant\n+            mod, name = if kind(ex[1]) == K\"BindingId\"\n+                binfo = lookup_binding(ctx, ex[1])\n+                binfo.mod, binfo.name\n+            else\n+                @assert kind(ex[1]) == K\"Value\" && typeof(ex[1].value) === GlobalRef\n+                gr = ex[1].value\n+                gr.mod, String(gr.name)\n+            end\n+            emit(ctx, @ast ctx ex [K\"call\" \"declare_const\"::K\"core\"\n+                                   mod::K\"Value\" name::K\"Symbol\"])\n+        else\n+            rhs = compile(ctx, ex[2], true, false)\n+            # TODO look up arg-map for renaming if lhs was reassigned\n+            if needs_value && !isnothing(rhs)\n+                r = emit_assign_tmp(ctx, rhs)\n+                emit_simple_assignment(ctx, ex, lhs, r, k)\n+                if in_tail_pos\n+                    emit_return(ctx, ex, r)\n+                else\n+                    r\n+                end\n+            else\n+                emit_assignment(ctx, ex, lhs, rhs, k)\n+            end\n+        end\n+        k == K\"constdecl\" && emit_latestworld(ctx, ex)\n+        res\n+    elseif k == K\"block\" || k == K\"scope_block\"\n+        nc = numchildren(ex)\n+        if nc == 0\n+            if in_tail_pos\n+                emit_return(ctx, nothing_(ctx, ex))\n+            elseif needs_value\n+                nothing_(ctx, ex)\n+            else\n+                nothing\n+            end\n+        else\n+            res = nothing\n+            for i in 1:nc\n+                islast = i == nc\n+                res = compile(ctx, ex[i], islast && needs_value, islast && in_tail_pos)\n+            end\n+            res\n+        end\n+    elseif k == K\"break_block\"\n+        end_label = make_label(ctx, ex)\n+        name = ex[1].name_val\n+        outer_target = get(ctx.break_targets, name, nothing)\n+        ctx.break_targets[name] = JumpTarget(end_label, ctx)\n+        compile(ctx, ex[2], false, false)\n+        if isnothing(outer_target)\n+            delete!(ctx.break_targets, name)\n+        else\n+            ctx.break_targets[name] = outer_target\n+        end\n+        emit(ctx, end_label)\n+        if needs_value\n+            compile(ctx, nothing_(ctx, ex), needs_value, in_tail_pos)\n+        end\n+    elseif k == K\"break\"\n+        emit_break(ctx, ex)\n+    elseif k == K\"symbolic_label\"\n+        label = emit_label(ctx, ex)\n+        name = ex.name_val\n+        if haskey(ctx.symbolic_jump_targets, name)\n+            throw(LoweringError(ex, \"Label `$name` defined multiple times\"))\n+        end\n+        push!(ctx.symbolic_jump_targets, name=>JumpTarget(label, ctx))\n+        if in_tail_pos\n+            emit_return(ctx, ex, nothing_(ctx, ex))\n+        elseif needs_value\n+            throw(LoweringError(ex, \"misplaced label in value position\"))\n+        end\n+    elseif k == K\"symbolic_goto\"\n+        push!(ctx.symbolic_jump_origins, JumpOrigin(ex, length(ctx.code)+1, ctx))\n+        emit(ctx, makeleaf(ctx, ex, K\"TOMBSTONE\")) # ? pop_exception\n+        emit(ctx, makeleaf(ctx, ex, K\"TOMBSTONE\")) # ? leave\n+        emit(ctx, makeleaf(ctx, ex, K\"TOMBSTONE\")) # ? goto\n+        nothing\n+    elseif k == K\"return\"\n+        compile(ctx, ex[1], true, true)\n+        nothing\n+    elseif k == K\"removable\"\n+        if needs_value\n+            compile(ctx, ex[1], needs_value, in_tail_pos)\n+        else\n+            nothing\n+        end\n+    elseif k == K\"if\" || k == K\"elseif\"\n+        @chk numchildren(ex) <= 3\n+        has_else = numchildren(ex) > 2\n+        else_label = make_label(ctx, ex)\n+        compile_conditional(ctx, ex[1], else_label)\n+        if in_tail_pos\n+            compile(ctx, ex[2], needs_value, in_tail_pos)\n+            emit(ctx, else_label)\n+            if has_else\n+                compile(ctx, ex[3], needs_value, in_tail_pos)\n+            else\n+                emit_return(ctx, ex, nothing_(ctx, ex))\n+            end\n+            nothing\n+        else\n+            val = needs_value && new_local_binding(ctx, ex, \"if_val\")\n+            v1 = compile(ctx, ex[2], needs_value, in_tail_pos)\n+            if needs_value\n+                emit_assignment(ctx, ex, val, v1)\n+            end\n+            if has_else || needs_value\n+                end_label = make_label(ctx, ex)\n+                emit(ctx, @ast ctx ex [K\"goto\" end_label])\n+            else\n+                end_label = nothing\n+            end\n+            emit(ctx, else_label)\n+            v2 = if has_else\n+                compile(ctx, ex[3], needs_value, in_tail_pos)\n+            elseif needs_value\n+                nothing_(ctx, ex)\n+            end\n+            if needs_value\n+                emit_assignment(ctx, ex, val, v2)\n+            end\n+            if !isnothing(end_label)\n+                emit(ctx, end_label)\n+            end\n+            val\n+        end\n+    elseif k == K\"trycatchelse\" || k == K\"tryfinally\"\n+        compile_try(ctx, ex, needs_value, in_tail_pos)\n+    elseif k == K\"method\"\n+        # TODO\n+        # throw(LoweringError(ex,\n+        #     \"Global method definition needs to be placed at the top level, or use `eval`\"))\n+        res = if numchildren(ex) == 1\n+            if in_tail_pos\n+                emit_return(ctx, ex)\n+            elseif needs_value\n+                ex\n+            else\n+                emit(ctx, ex)\n+            end\n+        else\n+            @chk numchildren(ex) == 3\n+            fname = ex[1]\n+            sig = compile(ctx, ex[2], true, false)\n+            if !is_valid_ir_argument(ctx, sig)\n+                sig = emit_assign_tmp(ctx, sig)\n+            end\n+            lam = ex[3]\n+            if kind(lam) == K\"lambda\"\n+                lam = compile_lambda(ctx, lam)\n+            else\n+                lam = emit_assign_tmp(ctx, compile(ctx, lam, true, false))\n+            end\n+            emit(ctx, ex, K\"method\", fname, sig, lam)\n+            @assert !needs_value && !in_tail_pos\n+            nothing\n+        end\n+        emit_latestworld(ctx, ex)\n+        res\n+    elseif k == K\"opaque_closure_method\"\n+        @ast ctx ex [K\"opaque_closure_method\"\n+            ex[1]\n+            ex[2]\n+            ex[3]\n+            ex[4]\n+            compile_lambda(ctx, ex[5])\n+        ]\n+    elseif k == K\"lambda\"\n+        lam = compile_lambda(ctx, ex)\n+        if in_tail_pos\n+            emit_return(ctx, lam)\n+        elseif needs_value\n+            lam\n+        else\n+            emit(ctx, lam)\n+        end\n+    elseif k == K\"gc_preserve_begin\"\n+        makenode(ctx, ex, k, compile_args(ctx, children(ex)))\n+    elseif k == K\"gc_preserve_end\"\n+        if needs_value\n+            throw(LoweringError(ex, \"misplaced kind $k in value position\"))\n+        end\n+        emit(ctx, ex)\n+        nothing\n+    elseif k == K\"meta\"\n+        @chk numchildren(ex) >= 1\n+        if ex[1].name_val in (\"inline\", \"noinline\", \"propagate_inbounds\",\n+                              \"nospecializeinfer\", \"aggressive_constprop\", \"no_constprop\")\n+            for c in children(ex)\n+                ctx.meta[Symbol(c.name_val)] = true\n+            end\n+        elseif ex[1].name_val === \"purity\"\n+            ctx.meta[Symbol(ex[1].name_val)] = ex[2].value::Base.EffectsOverride\n+        else\n+            emit(ctx, ex)\n+        end\n+        if needs_value\n+            val = @ast ctx ex \"nothing\"::K\"core\"\n+            if in_tail_pos\n+                emit_return(ctx, val)\n+            else\n+                val\n+            end\n+        end\n+    elseif k == K\"_while\"\n+        end_label = make_label(ctx, ex)\n+        top_label = emit_label(ctx, ex)\n+        compile_conditional(ctx, ex[1], end_label)\n+        compile(ctx, ex[2], false, false)\n+        emit(ctx, @ast ctx ex [K\"goto\" top_label])\n+        emit(ctx, end_label)\n+        if needs_value\n+            compile(ctx, nothing_(ctx, ex), needs_value, in_tail_pos)\n+        end\n+    elseif k == K\"_do_while\"\n+        end_label = make_label(ctx, ex)\n+        top_label = emit_label(ctx, ex)\n+        compile(ctx, ex[1], false, false)\n+        compile_conditional(ctx, ex[2], end_label)\n+        emit(ctx, @ast ctx ex [K\"goto\" top_label])\n+        emit(ctx, end_label)\n+        if needs_value\n+            compile(ctx, nothing_(ctx, ex), needs_value, in_tail_pos)\n+        end\n+    elseif k == K\"isdefined\" || k == K\"captured_local\" || k == K\"throw_undef_if_not\" ||\n+            k == K\"boundscheck\"\n+        if in_tail_pos\n+            emit_return(ctx, ex)\n+        elseif needs_value\n+            ex\n+        end\n+    elseif k == K\"newvar\"\n+        @assert !needs_value\n+        is_duplicate = !isempty(ctx.code) &&\n+            (e = last(ctx.code); kind(e) == K\"newvar\" && e[1].var_id == ex[1].var_id)\n+        if !is_duplicate\n+            # TODO: also exclude deleted vars\n+            emit(ctx, ex)\n+        end\n+    elseif k == K\"latestworld\"\n+        if needs_value\n+            throw(LoweringError(ex, \"misplaced latestsworld\"))\n+        end\n+        emit_latestworld(ctx, ex)\n+    elseif k == K\"latestworld_if_toplevel\"\n+        ctx.is_toplevel_thunk && emit_latestworld(ctx, ex)\n+    elseif k == K\"unused_only\"\n+        if needs_value && !(in_tail_pos && ctx.is_toplevel_thunk)\n+            throw(LoweringError(ex,\n+                \"global declaration doesn't read the variable and can't return a value\"))\n+        end\n+        compile(ctx, ex[1], needs_value, in_tail_pos)\n+    else\n+        throw(LoweringError(ex, \"Invalid syntax; $(repr(k))\"))\n+    end\n+end\n+\n+function _remove_vars_with_isdefined_check!(vars, ex)\n+    if is_leaf(ex) || is_quoted(ex) || kind(ex) == K\"static_eval\"\n+        return\n+    elseif kind(ex) == K\"isdefined\"\n+        delete!(vars, ex[1].var_id)\n+    else\n+        for e in children(ex)\n+            _remove_vars_with_isdefined_check!(vars, e)\n+        end\n+    end\n+end\n+\n+# Find newvar nodes that are unnecessary because\n+# 1. The variable is not captured and\n+# 2. The variable is assigned before any branches.\n+#\n+# This is used to remove newvar nodes that are not needed for re-initializing\n+# variables to undefined (see Julia issue #11065). It doesn't look for variable\n+# *uses*, because any variables used-before-def that also pass this test are\n+# *always* used undefined, and therefore don't need to be reinitialized. The\n+# one exception to that is `@isdefined`, which can observe an undefined\n+# variable without throwing an error.\n+function unnecessary_newvar_ids(ctx, stmts)\n+    vars = Set{IdTag}()\n+    ids_assigned_before_branch = Set{IdTag}()\n+    for ex in stmts\n+        _remove_vars_with_isdefined_check!(vars, ex)\n+        k = kind(ex)\n+        if k == K\"newvar\"\n+            id = ex[1].var_id\n+            if !lookup_binding(ctx, id).is_captured\n+                push!(vars, id)\n+            end\n+        elseif k == K\"goto\" || k == K\"gotoifnot\" || (k == K\"=\" && kind(ex[2]) == K\"enter\")\n+            empty!(vars)\n+        elseif k == K\"=\"\n+            id = ex[1].var_id\n+            if id in vars\n+                delete!(vars, id)\n+                push!(ids_assigned_before_branch, id)\n+            end\n+        end\n+    end\n+    ids_assigned_before_branch\n+end\n+\n+# flisp: compile-body\n+function compile_body(ctx, ex)\n+    compile(ctx, ex, true, true)\n+\n+    # Fix up any symbolic gotos. (We can't do this earlier because the goto\n+    # might precede the label definition in unstructured control flow.)\n+    for origin in ctx.symbolic_jump_origins\n+        name = origin.goto.name_val\n+        target = get(ctx.symbolic_jump_targets, name, nothing)\n+        if isnothing(target)\n+            throw(LoweringError(origin.goto, \"label `$name` referenced but not defined\"))\n+        end\n+        i = origin.index\n+        pop_ex = compile_pop_exception(ctx, origin.goto, origin.catch_token_stack,\n+                                     target.catch_token_stack)\n+        if !isnothing(pop_ex)\n+            @assert kind(ctx.code[i]) == K\"TOMBSTONE\"\n+            ctx.code[i] = pop_ex\n+            i += 1\n+        end\n+        leave_ex = compile_leave_handler(ctx, origin.goto, origin.handler_token_stack,\n+                                         target.handler_token_stack)\n+        if !isnothing(leave_ex)\n+            @assert kind(ctx.code[i]) == K\"TOMBSTONE\"\n+            ctx.code[i] = leave_ex\n+            i += 1\n+        end\n+        @assert kind(ctx.code[i]) == K\"TOMBSTONE\"\n+        ctx.code[i] = @ast ctx origin.goto [K\"goto\" target.label]\n+    end\n+\n+    # Filter out unnecessary newvar nodes\n+    ids_assigned_before_branch = unnecessary_newvar_ids(ctx, ctx.code)\n+    filter!(ctx.code) do ex\n+        !(kind(ex) == K\"newvar\" && ex[1].var_id in ids_assigned_before_branch)\n+    end\n+end\n+\n+#-------------------------------------------------------------------------------\n+\n+# Recursively renumber an expression within linear IR\n+# flisp: renumber-stuff\n+function _renumber(ctx, ssa_rewrites, slot_rewrites, label_table, ex)\n+    k = kind(ex)\n+    if k == K\"BindingId\"\n+        id = ex.var_id\n+        if haskey(ssa_rewrites, id)\n+            makeleaf(ctx, ex, K\"SSAValue\"; var_id=ssa_rewrites[id])\n+        else\n+            new_id = get(slot_rewrites, id, nothing)\n+            binfo = lookup_binding(ctx, id)\n+            if !isnothing(new_id)\n+                sk = binfo.kind == :local || binfo.kind == :argument ? K\"slot\"             :\n+                     binfo.kind == :static_parameter                 ? K\"static_parameter\" :\n+                     throw(LoweringError(ex, \"Found unexpected binding of kind $(binfo.kind)\"))\n+                makeleaf(ctx, ex, sk; var_id=new_id)\n+            else\n+                if binfo.kind !== :global\n+                    throw(LoweringError(ex, \"Found unexpected binding of kind $(binfo.kind)\"))\n+                end\n+                makeleaf(ctx, ex, K\"globalref\", binfo.name, mod=binfo.mod)\n+            end\n+        end\n+    elseif k == K\"meta\" || k == K\"static_eval\"\n+        # Somewhat-hack for Expr(:meta, :generated, gen) which has\n+        # weird top-level semantics for `gen`, but we still need to translate\n+        # the binding it contains to a globalref. (TODO: use\n+        # static_eval for this meta, somehow)\n+        mapchildren(ctx, ex) do e\n+            _renumber(ctx, ssa_rewrites, slot_rewrites, label_table, e)\n+        end\n+    elseif is_literal(k) || is_quoted(k)\n+        ex\n+    elseif k == K\"label\"\n+        @ast ctx ex label_table[ex.id]::K\"label\"\n+    elseif k == K\"code_info\"\n+        ex\n+    else\n+        mapchildren(ctx, ex) do e\n+            _renumber(ctx, ssa_rewrites, slot_rewrites, label_table, e)\n+        end\n+    end\n+end\n+\n+# flisp: renumber-lambda, compact-ir\n+function renumber_body(ctx, input_code, slot_rewrites)\n+    # Step 1: Remove any assignments to SSA variables, record the indices of labels\n+    ssa_rewrites = Dict{IdTag,IdTag}()\n+    label_table = Dict{Int,Int}()\n+    code = SyntaxList(ctx)\n+    for ex in input_code\n+        k = kind(ex)\n+        ex_out = nothing\n+        if k == K\"=\" && is_ssa(ctx, ex[1])\n+            lhs_id = ex[1].var_id\n+            if is_ssa(ctx, ex[2])\n+                # For SSA\u2081 = SSA\u2082, record that all uses of SSA\u2081 should be replaced by SSA\u2082\n+                ssa_rewrites[lhs_id] = ssa_rewrites[ex[2].var_id]\n+            else\n+                # Otherwise, record which `code` index this SSA value refers to\n+                ssa_rewrites[lhs_id] = length(code) + 1\n+                ex_out = ex[2]\n+            end\n+        elseif k == K\"label\"\n+            label_table[ex.id] = length(code) + 1\n+        elseif k == K\"TOMBSTONE\"\n+            # remove statement\n+        else\n+            ex_out = ex\n+        end\n+        if !isnothing(ex_out)\n+            push!(code, ex_out)\n+        end\n+    end\n+\n+    # Step 2:\n+    # * Translate any SSA uses and labels into indices in the code table\n+    # * Translate locals into slot indices\n+    for i in 1:length(code)\n+        code[i] = _renumber(ctx, ssa_rewrites, slot_rewrites, label_table, code[i])\n+    end\n+    code\n+end\n+\n+struct Slot\n+    name::String\n+    kind::Symbol\n+    is_nospecialize::Bool\n+    is_read::Bool\n+    is_single_assign::Bool\n+    is_maybe_undef::Bool\n+    is_called::Bool\n+end\n+\n+function compile_lambda(outer_ctx, ex)\n+    lambda_args = ex[1]\n+    static_parameters = ex[2]\n+    ret_var = numchildren(ex) == 4 ? ex[4] : nothing\n+    # TODO: Add assignments for reassigned arguments to body\n+    lambda_bindings = ex.lambda_bindings\n+    ctx = LinearIRContext(outer_ctx, ex.is_toplevel_thunk, lambda_bindings, ret_var)\n+    compile_body(ctx, ex[3])\n+    slots = Vector{Slot}()\n+    slot_rewrites = Dict{IdTag,Int}()\n+    for arg in children(lambda_args)\n+        if kind(arg) == K\"Placeholder\"\n+            # Unused functions arguments like: `_` or `::T`\n+            push!(slots, Slot(arg.name_val, :argument, false, false, false, false, false))\n+        else\n+            @assert kind(arg) == K\"BindingId\"\n+            id = arg.var_id\n+            binfo = lookup_binding(ctx, id)\n+            lbinfo = lookup_lambda_binding(ctx, id)\n+            @assert binfo.kind == :local || binfo.kind == :argument\n+            # FIXME: is_single_assign, is_maybe_undef\n+            push!(slots, Slot(binfo.name, :argument, binfo.is_nospecialize,\n+                              lbinfo.is_read, false, false, lbinfo.is_called))\n+            slot_rewrites[id] = length(slots)\n+        end\n+    end\n+    # Sorting the lambda locals is required to remove dependence on Dict iteration order.\n+    for (id, lbinfo) in sort(collect(pairs(lambda_bindings.bindings)), by=first)\n+        if !lbinfo.is_captured\n+            binfo = lookup_binding(ctx.bindings, id)\n+            if binfo.kind == :local\n+                # FIXME: is_single_assign, is_maybe_undef\n+                push!(slots, Slot(binfo.name, :local, false,\n+                                  lbinfo.is_read, false, false, lbinfo.is_called))\n+                slot_rewrites[id] = length(slots)\n+            end\n+        end\n+    end\n+    for (i,arg) in enumerate(children(static_parameters))\n+        @assert kind(arg) == K\"BindingId\"\n+        id = arg.var_id\n+        info = lookup_binding(ctx.bindings, id)\n+        @assert info.kind == :static_parameter\n+        slot_rewrites[id] = i\n+    end\n+    code = renumber_body(ctx, ctx.code, slot_rewrites)\n+    @ast ctx ex [K\"code_info\"(is_toplevel_thunk=ex.is_toplevel_thunk,\n+                              slots=slots, meta=CompileHints(ctx.meta))\n+        [K\"block\"(ex[3])\n+            code...\n+        ]\n+    ]\n+end\n+\n+\"\"\"\n+This pass converts nested ASTs in the body of a lambda into a list of\n+statements (ie, Julia's linear/untyped IR).\n+\n+Most of the compliexty of this pass is in lowering structured control flow (if,\n+loops, etc) to gotos and exception handling to enter/leave. We also convert\n+`K\"BindingId\"` into K\"slot\", `K\"globalref\"` or `K\"SSAValue` as appropriate.\n+\"\"\"\n+@fzone \"JL: linearize\" function linearize_ir(ctx, ex)\n+    graph = ensure_attributes(ctx.graph,\n+                              slots=Vector{Slot},\n+                              mod=Module,\n+                              id=Int)\n+    # TODO: Cleanup needed - `_ctx` is just a dummy context here. But currently\n+    # required to call reparent() ...\n+    GraphType = typeof(graph)\n+    _ctx = LinearIRContext(graph, SyntaxList(graph), ctx.bindings,\n+                           Ref(0), false, LambdaBindings(), nothing,\n+                           Dict{String,JumpTarget{typeof(graph)}}(),\n+                           SyntaxList(graph), SyntaxList(graph),\n+                           Vector{FinallyHandler{GraphType}}(),\n+                           Dict{String, JumpTarget{GraphType}}(),\n+                           Vector{JumpOrigin{GraphType}}(),\n+                           Dict{Symbol, Any}(), ctx.mod)\n+    res = compile_lambda(_ctx, reparent(_ctx, ex))\n+    _ctx, res\n+end"
    },
    {
      "sha": "6ea642e376508005ba66d6aba8439a4b0e9704d2",
      "filename": "JuliaLowering/src/macro_expansion.jl",
      "status": "added",
      "additions": 561,
      "deletions": 0,
      "changes": 561,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fmacro_expansion.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,561 @@\n+# Lowering pass 1: Macro expansion, simple normalizations and quote expansion\n+\n+struct MacroExpansionContext{GraphType} <: AbstractLoweringContext\n+    graph::GraphType\n+    bindings::Bindings\n+    scope_layers::Vector{ScopeLayer}\n+    scope_layer_stack::Vector{LayerId}\n+    expr_compat_mode::Bool\n+    macro_world::UInt\n+end\n+\n+function MacroExpansionContext(graph::SyntaxGraph, mod::Module, expr_compat_mode::Bool, world::UInt)\n+    layers = ScopeLayer[ScopeLayer(1, mod, 0, false)]\n+    MacroExpansionContext(graph, Bindings(), layers, LayerId[length(layers)], expr_compat_mode, world)\n+end\n+\n+function push_layer!(ctx::MacroExpansionContext, mod::Module, is_macro_expansion::Bool)\n+    new_layer = ScopeLayer(length(ctx.scope_layers)+1, mod,\n+                           current_layer_id(ctx), is_macro_expansion)\n+    push!(ctx.scope_layers, new_layer)\n+    push!(ctx.scope_layer_stack, new_layer.id)\n+end\n+function pop_layer!(ctx::MacroExpansionContext)\n+    pop!(ctx.scope_layer_stack)\n+end\n+\n+current_layer(ctx::MacroExpansionContext) = ctx.scope_layers[last(ctx.scope_layer_stack)]\n+current_layer_id(ctx::MacroExpansionContext) = last(ctx.scope_layer_stack)\n+\n+#--------------------------------------------------\n+# Expansion of quoted expressions\n+function collect_unquoted!(ctx, unquoted, ex, depth)\n+    if kind(ex) == K\"$\" && depth == 0\n+        # children(ex) is usually length 1, but for double interpolation it may\n+        # be longer and the children may contain K\"...\" expressions. Wrapping\n+        # in a tuple groups the arguments together correctly in those cases.\n+        push!(unquoted, @ast ctx ex [K\"tuple\" children(ex)...])\n+    else\n+        inner_depth = kind(ex) == K\"quote\" ? depth + 1 :\n+                      kind(ex) == K\"$\"     ? depth - 1 :\n+                      depth\n+        for e in children(ex)\n+            collect_unquoted!(ctx, unquoted, e, inner_depth)\n+        end\n+    end\n+    return unquoted\n+end\n+\n+function expand_quote(ctx, ex)\n+    unquoted = SyntaxList(ctx)\n+    collect_unquoted!(ctx, unquoted, ex, 0)\n+    # Unlike user-defined macro expansion, we don't call append_sourceref for\n+    # the entire expression produced by `quote` expansion. We could, but it\n+    # seems unnecessary for `quote` because the surface syntax is a transparent\n+    # representation of the expansion process. However, it's useful to add the\n+    # extra srcref in a more targeted way for $ interpolations inside\n+    # interpolate_ast, so we do that there.\n+    #\n+    # In principle, particular user-defined macros could opt into a similar\n+    # mechanism.\n+    #\n+    # TODO: Should we try adding a srcref to the `quote` node only for the\n+    # extra syntax generated by expand_quote so srcref essentially becomes\n+    # (ex, @HERE) ?\n+    @ast ctx ex [K\"call\"\n+        interpolate_ast::K\"Value\"\n+        (ctx.expr_compat_mode ? Expr : SyntaxTree)::K\"Value\"\n+        [K\"inert\"(meta=CompileHints(:as_Expr, ctx.expr_compat_mode)) ex]\n+        unquoted...\n+    ]\n+end\n+\n+#--------------------------------------------------\n+struct MacroContext <: AbstractLoweringContext\n+    graph::SyntaxGraph\n+    macrocall::Union{SyntaxTree,LineNumberNode,SourceRef}\n+    scope_layer::ScopeLayer\n+    expr_compat_mode::Bool\n+end\n+\n+function adopt_scope(ex, ctx::MacroContext)\n+    adopt_scope(ex, ctx.scope_layer.id)\n+end\n+\n+struct MacroExpansionError <: Exception\n+    context::Union{Nothing,MacroContext}\n+    ex::SyntaxTree\n+    msg::String\n+    \"The source position relative to the node - may be `:begin` or `:end` or `:all`\"\n+    position::Symbol\n+    \"Error that occurred inside the macro function call (`nothing` if no inner exception)\"\n+    err\n+    MacroExpansionError(\n+        context::Union{Nothing,MacroContext}, ex::SyntaxTree, msg::AbstractString, position::Symbol,\n+        @nospecialize err = nothing\n+    ) = new(context, ex, msg, position, err)\n+end\n+\n+function MacroExpansionError(ex::SyntaxTree, msg::AbstractString; position=:all)\n+    MacroExpansionError(nothing, ex, msg, position)\n+end\n+\n+function Base.showerror(io::IO, exc::MacroExpansionError)\n+    print(io, \"MacroExpansionError\")\n+    ctx = exc.context\n+    if !isnothing(ctx)\n+        # Use `Expr` formatting to pretty print the macro name for now -\n+        # there's quite a lot of special cases. We could alternatively consider\n+        # calling sourcetext() though that won't work well if it's a\n+        # synthetically-generated macro name path.\n+        macname_str = string(Expr(:macrocall, Expr(ctx.macrocall[1]), nothing))\n+        print(io, \" while expanding \", macname_str,\n+              \" in module \", ctx.scope_layer.mod)\n+    end\n+    print(io, \":\\n\")\n+    # TODO: Display niceties:\n+    # * Show the full provenance tree somehow, in addition to the primary\n+    #   source location we're showing here?\n+    # * What if the expression doesn't arise from a source file?\n+    # * How to deal with highlighting trivia? Could provide a token kind or\n+    #   child position within the raw tree? How to abstract this??\n+    src = sourceref(exc.ex)\n+    if src isa LineNumberNode\n+        highlight(io, src, note=exc.msg)\n+    else\n+        fb = first_byte(src)\n+        lb = last_byte(src)\n+        pos = exc.position\n+        byterange = pos == :all     ? (fb:lb)   :\n+            pos == :begin   ? (fb:fb-1) :\n+            pos == :end     ? (lb+1:lb) :\n+            error(\"Unknown position $pos\")\n+        highlight(io, src.file, byterange, note=exc.msg)\n+    end\n+    if !isnothing(exc.err)\n+        print(io, \"\\nCaused by:\\n\")\n+        showerror(io, exc.err)\n+    end\n+end\n+\n+function fixup_macro_name(ctx::MacroExpansionContext, ex::SyntaxTree)\n+    k = kind(ex)\n+    if k == K\"StrMacroName\" || k == K\"CmdMacroName\"\n+        layerid = get(ex, :scope_layer, current_layer_id(ctx))\n+        newname = JuliaSyntax.lower_identifier_name(ex.name_val, k)\n+        makeleaf(ctx, ex, ex, kind=K\"Identifier\", scope_layer=layerid, name_val=newname)\n+    elseif k == K\"macro_name\"\n+        @chk numchildren(ex) === 1\n+        if kind(ex[1]) === K\".\"\n+            @ast ctx ex [K\".\" ex[1][1] [K\"macro_name\" ex[1][2]]]\n+        else\n+            layerid = get(ex, :scope_layer, current_layer_id(ctx))\n+            newname = JuliaSyntax.lower_identifier_name(ex[1].name_val, K\"macro_name\")\n+            makeleaf(ctx, ex[1], ex[1], kind=kind(ex[1]), name_val=newname)\n+        end\n+    else\n+        mapchildren(e->fixup_macro_name(ctx,e), ctx, ex)\n+    end\n+end\n+\n+function eval_macro_name(ctx::MacroExpansionContext, mctx::MacroContext, ex::SyntaxTree)\n+    # `ex1` might contain a nontrivial mix of scope layers so we can't just\n+    # `eval()` it, as it's already been partially lowered by this point.\n+    # Instead, we repeat the latter parts of `lower()` here.\n+    ex1 = expand_forms_1(ctx, fixup_macro_name(ctx, ex))\n+    ctx2, ex2 = expand_forms_2(ctx, ex1)\n+    ctx3, ex3 = resolve_scopes(ctx2, ex2)\n+    ctx4, ex4 = convert_closures(ctx3, ex3)\n+    ctx5, ex5 = linearize_ir(ctx4, ex4)\n+    mod = current_layer(ctx).mod\n+    expr_form = to_lowered_expr(ex5)\n+    try\n+        # Using Core.eval here fails when precompiling packages since we hit the\n+        # user-facing error (in `jl_check_top_level_effect`) that warns that\n+        # effects won't persist when eval-ing into a closed module.\n+        # `jl_invoke_julia_macro` bypasses this by calling `jl_toplevel_eval` on\n+        # the macro name.  This is fine assuming the first argument to the\n+        # macrocall is effect-free.\n+        ccall(:jl_toplevel_eval, Any, (Any, Any), mod, expr_form)\n+    catch err\n+        throw(MacroExpansionError(mctx, ex, \"Macro not found\", :all, err))\n+    end\n+end\n+\n+# Record scope layer information for symbols passed to a macro by setting\n+# scope_layer for each expression and also processing any K\"escape\" arising\n+# from previous expansion of old-style macros.\n+#\n+# See also set_scope_layer()\n+function set_macro_arg_hygiene(ctx, ex, layer_ids, layer_idx)\n+    k = kind(ex)\n+    scope_layer = get(ex, :scope_layer, layer_ids[layer_idx])\n+    if is_leaf(ex)\n+        makeleaf(ctx, ex, ex; scope_layer=scope_layer)\n+    else\n+        inner_layer_idx = layer_idx\n+        if k == K\"escape\"\n+            inner_layer_idx = layer_idx - 1\n+            if inner_layer_idx < 1\n+                # If we encounter too many escape nodes, there's probably been\n+                # an error in the previous macro expansion.\n+                # todo: The error here isn't precise about that - maybe we\n+                # should record that macro call expression with the scope layer\n+                # if we want to report the error against the macro call?\n+                throw(MacroExpansionError(ex, \"`escape` node in outer context\"))\n+            end\n+        end\n+        mapchildren(e->set_macro_arg_hygiene(ctx, e, layer_ids, inner_layer_idx),\n+                    ctx, ex; scope_layer=scope_layer)\n+    end\n+end\n+\n+function prepare_macro_args(ctx, mctx, raw_args)\n+    macro_args = Any[mctx]\n+    for arg in raw_args\n+        # Add hygiene information to be carried along with macro arguments.\n+        #\n+        # Macro call arguments may be either\n+        # * Unprocessed by the macro expansion pass\n+        # * Previously processed, but spliced into a further macro call emitted by\n+        #   a macro expansion.\n+        # In either case, we need to set scope layers before passing the\n+        # arguments to the macro call.\n+        push!(macro_args, set_macro_arg_hygiene(ctx, arg, ctx.scope_layer_stack,\n+                                                length(ctx.scope_layer_stack)))\n+    end\n+    return macro_args\n+end\n+\n+# TODO: Do we need to handle :scope_layer or multiple escapes here?\n+# See https://github.com/c42f/JuliaLowering.jl/issues/39\n+\"\"\"\n+Insert a hygienic-scope around each arg of K\"toplevel\" returned from a macro.\n+\n+It isn't correct for macro expansion to recurse into a K\"toplevel\" expression\n+since one child may define a macro and the next may use it.  However, not\n+recursing now means we lose some important context: the module of the macro we\n+just expanded, which is necessary for resolving the identifiers in the\n+K\"toplevel\" AST.  The solution implemented in JuliaLang/julia#53515 was to save\n+our place and expand later using `Expr(:hygienic-scope toplevel_child mod)`.\n+\n+Of course, these hygienic-scopes are also necessary because existing user code\n+contains the corresponding escaping, which would otherwise cause errors. We\n+already consumed the hygienic-scope that comes with every expansion, but won't\n+be looking for escapes under :toplevel, so push hygienic-scope under toplevel\n+\"\"\"\n+function fix_toplevel_expansion(ctx, ex::SyntaxTree, mod::Module, lnn::LineNumberNode)\n+    if kind(ex) === K\"toplevel\"\n+        mapchildren(ctx, ex) do e\n+            @ast ctx ex [K\"hygienic_scope\" e mod::K\"Value\" lnn::K\"Value\"]\n+        end\n+    else\n+        mapchildren(e->fix_toplevel_expansion(ctx, e, mod, lnn), ctx, ex)\n+    end\n+end\n+\n+function expand_macro(ctx, ex)\n+    @assert kind(ex) == K\"macrocall\"\n+\n+    macname = ex[1]\n+    mctx = MacroContext(ctx.graph, ex, current_layer(ctx), ctx.expr_compat_mode)\n+    macfunc = eval_macro_name(ctx, mctx, macname)\n+    raw_args = ex[2:end]\n+    macro_loc = let loc = source_location(LineNumberNode, ex)\n+        # Some macros, e.g. @cmd, don't play nicely with file == nothing\n+        isnothing(loc.file) ? LineNumberNode(loc.line, :none) : loc\n+    end\n+    # We use a specific well defined world age for the next checks and macro\n+    # expansion invocations. This avoids inconsistencies if the latest world\n+    # age changes concurrently.\n+    #\n+    # TODO: Allow this to be passed in\n+    if hasmethod(macfunc, Tuple{typeof(mctx), typeof.(raw_args)...}; world=ctx.macro_world)\n+        macro_args = prepare_macro_args(ctx, mctx, raw_args)\n+        expanded = try\n+            Base.invoke_in_world(ctx.macro_world, macfunc, macro_args...)\n+        catch exc\n+            newexc = exc isa MacroExpansionError ?\n+                MacroExpansionError(mctx, exc.ex, exc.msg, exc.position, exc.err) :\n+                MacroExpansionError(mctx, ex, \"Error expanding macro\", :all, exc)\n+            # TODO: We can delete this rethrow when we move to AST-based error propagation.\n+            rethrow(newexc)\n+        end\n+        if expanded isa SyntaxTree\n+            if !is_compatible_graph(ctx, expanded)\n+                # If the macro has produced syntax outside the macro context,\n+                # copy it over. TODO: Do we expect this always to happen?  What\n+                # is the API for access to the macro expansion context?\n+                expanded = copy_ast(ctx, expanded)\n+            end\n+        else\n+            expanded = @ast ctx ex expanded::K\"Value\"\n+        end\n+    else\n+        # Compat: attempt to invoke an old-style macro if there's no applicable\n+        # method for new-style macro arguments.\n+        macro_args = Any[macro_loc, current_layer(ctx).mod]\n+        for arg in raw_args\n+            # For hygiene in old-style macros, we omit any additional scope\n+            # layer information from macro arguments. Old-style macros will\n+            # handle that using manual escaping in the macro itself.\n+            #\n+            # Note that there's one slight incompatibility here for identifiers\n+            # interpolated into the `raw_args` from outer macro expansions of\n+            # new-style macros which call old-style macros. Instead of seeing\n+            # `Expr(:escape)` in such situations, old-style macros will now see\n+            # `Expr(:scope_layer)` inside `macro_args`.\n+            push!(macro_args, Expr(arg))\n+        end\n+        expanded = try\n+            Base.invoke_in_world(ctx.macro_world, macfunc, macro_args...)\n+        catch exc\n+            if exc isa MethodError && exc.f === macfunc\n+                if !isempty(methods_in_world(macfunc, Tuple{typeof(mctx), Vararg{Any}}, ctx.macro_world))\n+                    # If the macro has at least some methods implemented in the\n+                    # new style, assume the user meant to call one of those\n+                    # rather than any old-style macro methods which might exist\n+                    exc = MethodError(macfunc, (prepare_macro_args(ctx, mctx, raw_args)..., ), ctx.macro_world)\n+                end\n+            end\n+            rethrow(MacroExpansionError(mctx, ex, \"Error expanding macro\", :all, exc))\n+        end\n+        expanded = expr_to_syntaxtree(ctx, expanded, macro_loc)\n+    end\n+\n+    if kind(expanded) != K\"Value\"\n+        expanded = append_sourceref(ctx, expanded, ex)\n+        # Module scope for the returned AST is the module where this particular\n+        # method was defined (may be different from `parentmodule(macfunc)`)\n+        mod_for_ast = lookup_method_instance(macfunc, macro_args,\n+                                             ctx.macro_world).def.module\n+        expanded = fix_toplevel_expansion(ctx, expanded, mod_for_ast, macro_loc)\n+        new_layer = ScopeLayer(length(ctx.scope_layers)+1, mod_for_ast,\n+                               current_layer_id(ctx), true)\n+        push_layer!(ctx, mod_for_ast, true)\n+        expanded = expand_forms_1(ctx, expanded)\n+        pop_layer!(ctx)\n+    end\n+    return expanded\n+end\n+\n+# Add a secondary source of provenance to each expression in the tree `ex`.\n+function append_sourceref(ctx, ex, secondary_prov)\n+    srcref = (ex, secondary_prov)\n+    if !is_leaf(ex)\n+        if kind(ex) == K\"macrocall\"\n+            makenode(ctx, srcref, ex, children(ex)...)\n+        else\n+            makenode(ctx, srcref, ex,\n+                     map(e->append_sourceref(ctx, e, secondary_prov), children(ex))...)\n+        end\n+    else\n+        makeleaf(ctx, srcref, ex)\n+    end\n+end\n+\n+function remove_scope_layer!(ex)\n+    if !is_leaf(ex)\n+        for c in children(ex)\n+            remove_scope_layer!(c)\n+        end\n+    end\n+    deleteattr!(ex, :scope_layer)\n+    ex\n+end\n+\n+function remove_scope_layer(ctx, ex)\n+    remove_scope_layer!(copy_ast(ctx, ex))\n+end\n+\n+\"\"\"\n+Lowering pass 1\n+\n+This pass contains some simple expansion to make the rest of desugaring easier\n+to write and expands user defined macros. Macros see the surface syntax, so\n+need to be dealt with before other lowering.\n+\n+* Does identifier normalization\n+* Strips semantically irrelevant \"container\" nodes like parentheses\n+* Expands macros\n+* Processes quoted syntax turning `K\"quote\"` into `K\"inert\"` (eg, expanding\n+  interpolations)\n+\"\"\"\n+function expand_forms_1(ctx::MacroExpansionContext, ex::SyntaxTree)\n+    k = kind(ex)\n+    if k == K\"Identifier\"\n+        name_str = ex.name_val\n+        if all(==('_'), name_str)\n+            @ast ctx ex ex=>K\"Placeholder\"\n+        elseif is_ccall_or_cglobal(name_str)\n+            # Lower special identifiers `cglobal` and `ccall` to `K\"core\"`\n+            # pseudo-refs very early so that cglobal and ccall can never be\n+            # turned into normal bindings (eg, assigned to)\n+            @ast ctx ex name_str::K\"core\"\n+        else\n+            layerid = get(ex, :scope_layer, current_layer_id(ctx))\n+            makeleaf(ctx, ex, ex, kind=K\"Identifier\", scope_layer=layerid)\n+        end\n+    elseif k == K\"StrMacroName\" || k == K\"CmdMacroName\" || k == K\"macro_name\"\n+        # These can appear outside of a macrocall, e.g. in `import`\n+        e2 = fixup_macro_name(ctx, ex)\n+        expand_forms_1(ctx, e2)\n+    elseif k == K\"var\" || k == K\"char\" || k == K\"parens\"\n+        # Strip \"container\" nodes\n+        @chk numchildren(ex) == 1\n+        expand_forms_1(ctx, ex[1])\n+    elseif k == K\"escape\"\n+        # For processing of old-style macros\n+        @chk numchildren(ex) >= 1 \"`escape` requires an argument\"\n+        if length(ctx.scope_layer_stack) === 1\n+            throw(MacroExpansionError(ex, \"`escape` node in outer context\"))\n+        end\n+        top_layer = pop!(ctx.scope_layer_stack)\n+        escaped_ex = expand_forms_1(ctx, ex[1])\n+        push!(ctx.scope_layer_stack, top_layer)\n+        escaped_ex\n+    elseif k == K\"hygienic_scope\"\n+        @chk numchildren(ex) >= 2 && ex[2].value isa Module (ex,\"`hygienic_scope` requires an AST and a module\")\n+        new_layer = ScopeLayer(length(ctx.scope_layers)+1, ex[2].value,\n+                               current_layer_id(ctx), true)\n+        push!(ctx.scope_layers, new_layer)\n+        push!(ctx.scope_layer_stack, new_layer.id)\n+        hyg_ex = expand_forms_1(ctx, ex[1])\n+        pop!(ctx.scope_layer_stack)\n+        hyg_ex\n+    elseif k == K\"juxtapose\"\n+        layerid = get(ex, :scope_layer, current_layer_id(ctx))\n+        @chk numchildren(ex) == 2\n+        @ast ctx ex [K\"call\"\n+            \"*\"::K\"Identifier\"(scope_layer=layerid)\n+            expand_forms_1(ctx, ex[1])\n+            expand_forms_1(ctx, ex[2])\n+        ]\n+    elseif k == K\"quote\"\n+        @chk numchildren(ex) == 1\n+        # TODO: Upstream should set a general flag for detecting parenthesized\n+        # expressions so we don't need to dig into `green_tree` here. Ugh!\n+        plain_symbol = has_flags(ex, JuliaSyntax.COLON_QUOTE) &&\n+                       kind(ex[1]) == K\"Identifier\" &&\n+                       (sr = sourceref(ex); sr isa SourceRef && kind(sr.green_tree[2]) != K\"parens\")\n+        if plain_symbol\n+            # As a compromise for compatibility, we treat non-parenthesized\n+            # colon quoted identifiers like `:x` as plain Symbol literals\n+            # because these are ubiquitiously used in Julia programs as ad hoc\n+            # enum-like entities rather than pieces of AST.\n+            @ast ctx ex[1] ex[1]=>K\"Symbol\"\n+        else\n+            expand_forms_1(ctx, expand_quote(ctx, ex[1]))\n+        end\n+    elseif k == K\"macrocall\"\n+        expand_macro(ctx, ex)\n+    elseif k == K\"module\" || k == K\"toplevel\" || k == K\"inert\"\n+        # Remove scope layer information from any inert syntax which survives\n+        # macro expansion so that it doesn't contaminate lowering passes which\n+        # are later run against the quoted code. TODO: This works as a first\n+        # approximation but is incorrect in general. We need to revisit such\n+        # \"deferred hygiene\" situations (see https://github.com/c42f/JuliaLowering.jl/issues/111)\n+        remove_scope_layer(ctx, ex)\n+    elseif k == K\".\" && numchildren(ex) == 2\n+        # Handle quoted property access like `x.:(foo)` or `Core.:(!==)`\n+        # Unwrap the quote to get the identifier before expansion\n+        rhs = ex[2]\n+        if kind(rhs) == K\"quote\" && numchildren(rhs) == 1\n+            rhs = rhs[1]\n+        end\n+        e2 = expand_forms_1(ctx, rhs)\n+        if kind(e2) == K\"Identifier\" || kind(e2) == K\"Placeholder\"\n+            # FIXME: Do the K\"Symbol\" transformation in the parser??\n+            e2 = @ast ctx e2 e2=>K\"Symbol\"\n+        end\n+        @ast ctx ex [K\".\" expand_forms_1(ctx, ex[1]) e2]\n+    elseif k == K\"cmdstring\"\n+        @chk numchildren(ex) == 1\n+        e2 = @ast ctx ex [K\"macrocall\" [K\"macro_name\" \"cmd\"::K\"core\"] ex[1]]\n+        expand_macro(ctx, e2)\n+    elseif (k == K\"call\" || k == K\"dotcall\")\n+        # Do some initial desugaring of call and dotcall here to simplify\n+        # the later desugaring pass\n+        args = SyntaxList(ctx)\n+        if is_infix_op_call(ex) || is_postfix_op_call(ex)\n+            @chk numchildren(ex) >= 2 \"Postfix/infix operators must have at least two positional arguments\"\n+            farg = ex[2]\n+            push!(args, ex[1])\n+            append!(args, ex[3:end])\n+        else\n+            @chk numchildren(ex) > 0 \"Call expressions must have a function name\"\n+            farg = ex[1]\n+            append!(args, ex[2:end])\n+        end\n+        if !isempty(args)\n+            if kind(args[end]) == K\"do\"\n+                # move do block into first argument location\n+                pushfirst!(args, pop!(args))\n+            end\n+        end\n+        if length(args) == 2 && is_same_identifier_like(farg, \"^\") && kind(args[2]) == K\"Integer\"\n+            # Do literal-pow expansion here as it's later used in both call and\n+            # dotcall expansion.\n+            @ast ctx ex [k\n+                \"literal_pow\"::K\"top\"\n+                expand_forms_1(ctx, farg)\n+                expand_forms_1(ctx, args[1])\n+                [K\"call\"\n+                    [K\"call\"\n+                        \"apply_type\"::K\"core\"\n+                        \"Val\"::K\"top\"\n+                        args[2]\n+                    ]\n+                ]\n+            ]\n+        else\n+            if kind(farg) == K\".\" && numchildren(farg) == 1\n+                # (.+)(x,y) is treated as a dotcall\n+                k = K\"dotcall\"\n+                farg = farg[1]\n+            end\n+            # Preserve call type flags (mostly ignored in the next pass as\n+            # we've already reordered arguments.)\n+            callflags = JuliaSyntax.call_type_flags(ex)\n+            @ast ctx ex [k(syntax_flags=(callflags == 0 ? nothing : callflags))\n+                expand_forms_1(ctx, farg)\n+                (expand_forms_1(ctx, a) for a in args)...\n+            ]\n+        end\n+    elseif is_leaf(ex)\n+        ex\n+    elseif k == K\"<:\" || k == K\">:\" || k == K\"-->\"\n+        # TODO: Should every form get layerid systematically? Or only the ones\n+        # which expand_forms_2 needs?\n+        layerid = get(ex, :scope_layer, current_layer_id(ctx))\n+        mapchildren(e->expand_forms_1(ctx,e), ctx, ex; scope_layer=layerid)\n+    else\n+        mapchildren(e->expand_forms_1(ctx,e), ctx, ex)\n+    end\n+end\n+\n+function ensure_macro_attributes(graph)\n+    ensure_attributes(graph,\n+                      var_id=IdTag,\n+                      scope_layer=LayerId,\n+                      __macro_ctx__=Nothing,\n+                      meta=CompileHints)\n+end\n+\n+@fzone \"JL: macroexpand\" function expand_forms_1(mod::Module, ex::SyntaxTree, expr_compat_mode::Bool, macro_world::UInt)\n+    if kind(ex) == K\"local\"\n+        # This error assumes we're expanding the body of a top level thunk but\n+        # we might want to make that more explicit in the pass system.\n+        throw(LoweringError(ex, \"local declarations have no effect outside a scope\"))\n+    end\n+    graph = ensure_macro_attributes(syntax_graph(ex))\n+    ctx = MacroExpansionContext(graph, mod, expr_compat_mode, macro_world)\n+    ex2 = expand_forms_1(ctx, reparent(ctx, ex))\n+    graph2 = delete_attributes(graph, :__macro_ctx__)\n+    # TODO: Returning the context with pass-specific mutable data is a bad way\n+    # to carry state into the next pass. We might fix this by attaching such\n+    # data to the graph itself as global attributes?\n+    ctx2 = MacroExpansionContext(graph2, ctx.bindings, ctx.scope_layers, ctx.scope_layer_stack,\n+                                 expr_compat_mode, macro_world)\n+    return ctx2, reparent(ctx2, ex2)\n+end"
    },
    {
      "sha": "7a5fccaded4b5427405843cb7510b76e580ed2f3",
      "filename": "JuliaLowering/src/precompile.jl",
      "status": "added",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fprecompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fprecompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fprecompile.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,27 @@\n+# exercise the whole lowering pipeline\n+if Base.get_bool_env(\"JULIA_LOWERING_PRECOMPILE\", true)\n+    thunks = String[\n+        \"\"\"\n+        function foo(xxx, yyy)\n+            @nospecialize xxx\n+            return Pair{Any,Any}(typeof(xxx), typeof(yyy))\n+        end\n+        \"\"\"\n+\n+        \"\"\"\n+        struct Foo\n+            x::Int\n+            Foo(x::Int) = new(x)\n+            # Foo() = new()\n+        end\n+        \"\"\"\n+    ]\n+    for thunk in thunks\n+        stream = JuliaSyntax.ParseStream(thunk)\n+        JuliaSyntax.parse!(stream; rule=:all)\n+        st0 = JuliaSyntax.build_tree(SyntaxTree, stream; filename=@__FILE__)\n+        lwrst = lower(@__MODULE__, st0[1])\n+        lwr = to_lowered_expr(lwrst)\n+        @assert Meta.isexpr(lwr, :thunk) && only(lwr.args) isa Core.CodeInfo\n+    end\n+end"
    },
    {
      "sha": "c98b71639a74343f2ed23fc77f7387a65af24b34",
      "filename": "JuliaLowering/src/runtime.jl",
      "status": "added",
      "additions": 455,
      "deletions": 0,
      "changes": 455,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fruntime.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fruntime.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fruntime.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,455 @@\n+# Runtime support for\n+# 1. Functions called by the code emitted from lowering\n+# 2. Introspecting Julia's state during lowering\n+#\n+# These should probably all move to `Core` at some point.\n+\n+#-------------------------------------------------------------------------------\n+# Functions/types used by code emitted from lowering, but not called by it directly\n+\n+# Return the current exception. In JuliaLowering we use this rather than the\n+# special form `K\"the_exception\"` to reduces the number of special forms.\n+Base.@assume_effects :removable function current_exception()\n+    @ccall jl_current_exception(current_task()::Any)::Any\n+end\n+\n+#--------------------------------------------------\n+# Supporting functions for AST interpolation (`quote`)\n+struct InterpolationContext{Graph} <: AbstractLoweringContext\n+    graph::Graph\n+    values::Tuple\n+    current_index::Ref{Int}\n+end\n+\n+# Context for `Expr`-based AST interpolation in compat mode\n+struct ExprInterpolationContext <: AbstractLoweringContext\n+    values::Tuple\n+    current_index::Ref{Int}\n+end\n+\n+# Helper functions to make shared interpolation code which works with both\n+# SyntaxTree and Expr data structures.\n+_interp_kind(ex::SyntaxTree) = kind(ex)\n+function _interp_kind(@nospecialize(ex))\n+    return (ex isa Expr && ex.head === :quote) ? K\"quote\" :\n+           (ex isa Expr && ex.head === :$)     ? K\"$\"     :\n+           K\"None\" # Other cases irrelevant to interpolation\n+end\n+\n+_children(ex::SyntaxTree) = children(ex)\n+_children(@nospecialize(ex)) = ex isa Expr ? ex.args : ()\n+\n+_numchildren(ex::SyntaxTree) = numchildren(ex)\n+_numchildren(@nospecialize(ex)) = ex isa Expr ? length(ex.args) : 0\n+\n+_syntax_list(ctx::InterpolationContext) = SyntaxList(ctx)\n+_syntax_list(ctx::ExprInterpolationContext) = Any[]\n+\n+_interp_makenode(ctx::InterpolationContext, ex, args) = makenode(ctx, ex, ex, args)\n+_interp_makenode(ctx::ExprInterpolationContext, ex, args) = Expr((ex::Expr).head, args...)\n+\n+_is_leaf(ex::SyntaxTree) = is_leaf(ex)\n+_is_leaf(ex::Expr) = false\n+_is_leaf(@nospecialize(ex)) = true\n+\n+# Produce interpolated node for `$x` syntax\n+function _interpolated_value(ctx::InterpolationContext, srcref, ex)\n+    if ex isa SyntaxTree\n+        if !is_compatible_graph(ctx, ex)\n+            ex = copy_ast(ctx, ex)\n+        end\n+        append_sourceref(ctx, ex, srcref)\n+    elseif ex isa Symbol\n+        # Plain symbols become identifiers. This is an accommodation for\n+        # compatibility to allow `:x` (a Symbol) and `:(x)` (a SyntaxTree) to\n+        # be used interchangeably in macros.\n+        makeleaf(ctx, srcref, K\"Identifier\", string(ex))\n+    else\n+        makeleaf(ctx, srcref, K\"Value\", ex)\n+    end\n+end\n+\n+function _interpolated_value(::ExprInterpolationContext, _, ex)\n+    ex\n+end\n+\n+function _interpolate_ast(ctx::ExprInterpolationContext, ex::QuoteNode, depth)\n+    out = _interpolate_ast(ctx, Expr(:inert, ex.value), depth)\n+    QuoteNode(only(out.args))\n+end\n+\n+function _interpolate_ast(ctx, @nospecialize(ex), depth)\n+    _is_leaf(ex) && return ex\n+    k = _interp_kind(ex)\n+    inner_depth = k == K\"quote\" ? depth + 1 :\n+                  k == K\"$\"     ? depth - 1 :\n+                  depth\n+    expanded_children = _syntax_list(ctx)\n+\n+    for e in _children(ex)\n+        if _interp_kind(e) == K\"$\" && inner_depth == 0\n+            vals = ctx.values[ctx.current_index[]]::Tuple\n+            ctx.current_index[] += 1\n+            for (i,v) in enumerate(vals)\n+                srcref = _numchildren(e) == 1 ? e : _children(e)[i]\n+                push!(expanded_children, _interpolated_value(ctx, srcref, v))\n+            end\n+        else\n+            push!(expanded_children, _interpolate_ast(ctx, e, inner_depth))\n+        end\n+    end\n+\n+    _interp_makenode(ctx, ex, expanded_children)\n+end\n+\n+# Produced by expanding K\"quote\".  Must create a copy of the AST.  Note that\n+# wrapping `ex` in an extra node handles the edge case where the root `ex` is\n+# `$` (our recursion is one step removed due to forms like `($ a b)`.)\n+function interpolate_ast(::Type{SyntaxTree}, ex::SyntaxTree, values...)\n+    # Construct graph for interpolation context. We inherit this from the macro\n+    # context where possible by detecting it using __macro_ctx__. This feels\n+    # hacky though.\n+    #\n+    # Perhaps we should use a ScopedValue for this instead or get it from\n+    # the macro __context__? None of the options feel great here.\n+    graph = nothing\n+    for vals in values\n+        for v in vals\n+            if v isa SyntaxTree && hasattr(syntax_graph(v), :__macro_ctx__)\n+                graph = syntax_graph(v)\n+                break\n+            end\n+        end\n+    end\n+    if isnothing(graph)\n+        graph = ensure_attributes(\n+            SyntaxGraph(), kind=Kind, syntax_flags=UInt16, source=SourceAttrType,\n+            value=Any, name_val=String, scope_layer=LayerId)\n+    end\n+    ctx = InterpolationContext(graph, values, Ref(1))\n+\n+    # We must copy the AST into our context to use it as the source reference of\n+    # generated expressions.\n+    ex1 = copy_ast(ctx, ex)\n+    out = _interpolate_ast(ctx, @ast(ctx, ex1, [K\"None\" ex1]), 0)\n+    length(children(out)) === 1 || throw(\n+        LoweringError(ex1, \"More than one value in bare `\\$` expression\"))\n+    return only(children(out))\n+end\n+\n+function interpolate_ast(::Type{Expr}, @nospecialize(ex), values...)\n+    ctx = ExprInterpolationContext(values, Ref(1))\n+    if ex isa Expr && ex.head === :$\n+        @assert length(values) === 1\n+        if length(ex.args) !== 1\n+            throw(LoweringError(\n+                expr_to_syntaxtree(ex), \"More than one value in bare `\\$` expression\"))\n+        end\n+        only(values[1])\n+    else\n+        _interpolate_ast(ctx, ex, 0)\n+    end\n+end\n+\n+#--------------------------------------------------\n+# Functions called by closure conversion\n+function eval_closure_type(mod::Module, closure_type_name::Symbol, field_names, field_is_box)\n+    type_params = Core.TypeVar[]\n+    field_types = []\n+    for (name, isbox) in zip(field_names, field_is_box)\n+        if !isbox\n+            T = Core.TypeVar(Symbol(name, \"_type\"))\n+            push!(type_params, T)\n+            push!(field_types, T)\n+        else\n+            push!(field_types, Core.Box)\n+        end\n+    end\n+    type = Core._structtype(mod, closure_type_name,\n+                            Core.svec(type_params...),\n+                            Core.svec(field_names...),\n+                            Core.svec(),\n+                            false,\n+                            length(field_names))\n+    Core._setsuper!(type, Core.Function)\n+    Core.declare_const(mod, closure_type_name, type)\n+    Core._typebody!(false, type, Core.svec(field_types...))\n+    type\n+end\n+\n+# Interpolate captured local variables into the CodeInfo for a global method\n+function replace_captured_locals!(codeinfo::Core.CodeInfo, locals::Core.SimpleVector)\n+    for (i, ex) in enumerate(codeinfo.code)\n+        if Meta.isexpr(ex, :captured_local)\n+            codeinfo.code[i] = locals[ex.args[1]::Int]\n+        end\n+    end\n+    codeinfo\n+end\n+\n+#--------------------------------------------------\n+# Functions which create modules or mutate their bindings\n+\n+const _Base_has_eval_import = isdefined(Base, :_eval_import)\n+\n+function eval_import(imported::Bool, to::Module, from::Union{Expr, Nothing}, paths::Expr...)\n+    if _Base_has_eval_import\n+        Base._eval_import(imported, to, from, paths...)\n+    else\n+        head = imported ? :import : :using\n+        ex = isnothing(from) ?\n+            Expr(head, paths...) :\n+            Expr(head, Expr(Symbol(\":\"), from, paths...))\n+        Core.eval(to, ex)\n+    end\n+end\n+\n+function eval_using(to::Module, path::Expr)\n+    if _Base_has_eval_import\n+        Base._eval_using(to, path)\n+    else\n+        Core.eval(to, Expr(:using, path))\n+    end\n+end\n+\n+function eval_public(mod::Module, is_exported::Bool, identifiers)\n+    # symbol jl_module_public is no longer exported as of #57765\n+    Core.eval(mod, Expr((is_exported ? :export : :public), map(Symbol, identifiers)...))\n+end\n+\n+#--------------------------------------------------\n+# Docsystem integration\n+function _bind_func_docs!(f, docstr, method_metadata::Core.SimpleVector)\n+    mod = parentmodule(f)\n+    bind = Base.Docs.Binding(mod, nameof(f))\n+    full_sig = method_metadata[1]\n+    arg_sig = Tuple{full_sig[2:end]...}\n+    lineno = method_metadata[3]\n+    metadata = Dict{Symbol, Any}(\n+        :linenumber => lineno.line,\n+        :module => mod,\n+    )\n+    if !isnothing(lineno.file)\n+        push!(metadata, :path => string(lineno.file))\n+    end\n+    Docs.doc!(mod, bind, Base.Docs.docstr(docstr, metadata), arg_sig)\n+end\n+\n+function bind_docs!(f::Function, docstr, method_metadata::Core.SimpleVector)\n+    _bind_func_docs!(f, docstr, method_metadata)\n+end\n+\n+# Document constructors\n+function bind_docs!(::Type{Type{T}}, docstr, method_metadata::Core.SimpleVector) where T\n+    _bind_func_docs!(T, docstr, method_metadata)\n+end\n+\n+function bind_docs!(type::Type, docstr, method_metadata::Core.SimpleVector)\n+    _bind_func_docs!(type, docstr, method_metadata)\n+end\n+\n+function bind_docs!(type::Type, docstr, lineno::LineNumberNode; field_docs=Core.svec())\n+    mod = parentmodule(type)\n+    bind = Base.Docs.Binding(mod, nameof(type))\n+    metadata = Dict{Symbol, Any}(\n+        :linenumber => lineno,\n+        :module => mod,\n+    )\n+    if !isnothing(lineno.file)\n+        push!(metadata, :path => string(lineno.file))\n+    end\n+    if !isempty(field_docs)\n+        fd = Dict{Symbol, Any}()\n+        fns = fieldnames(type)\n+        for i = 1:2:length(field_docs)\n+            fd[fns[field_docs[i]]] = field_docs[i+1]\n+        end\n+        metadata[:fields] = fd\n+    end\n+    Docs.doc!(mod, bind, Base.Docs.docstr(docstr, metadata), Union{})\n+end\n+\n+\"\"\"\n+Called in the unfortunate cases (K\"call\", K\".\", K\"Identifier\") where docstrings\n+change the semantics of the expressions they annotate, no longer requiring the\n+expression to execute.\n+\"\"\"\n+function bind_static_docs!(mod::Module, name::Symbol, docstr, lnn::LineNumberNode, sigtypes::Type)\n+    metadata = Dict{Symbol, Any}(\n+        :linenumber => lnn.line,\n+        :module => mod,\n+        :path => something(lnn.file, \"none\"),\n+    )\n+    bind = Base.Docs.Binding(mod, name)\n+    Docs.doc!(mod, bind, Base.Docs.docstr(docstr, metadata), sigtypes)\n+end\n+\n+#--------------------------------------------------\n+# Runtime support infrastructure for `@generated`\n+\n+# An alternative to Core.GeneratedFunctionStub which works on SyntaxTree rather\n+# than Expr.\n+struct GeneratedFunctionStub\n+    gen\n+    srcref\n+    argnames::Core.SimpleVector\n+    spnames::Core.SimpleVector\n+end\n+\n+# Call the `@generated` code generator function and wrap the results of the\n+# expression into a CodeInfo.\n+#\n+# `args` passed into stub by the Julia runtime are (parent_func, static_params..., arg_types...)\n+function (g::GeneratedFunctionStub)(world::UInt, source::Method, @nospecialize args...)\n+    # Some of the lowering pipeline from lower() and the pass-specific setup is\n+    # re-implemented here because generated functions are very much (but not\n+    # entirely) like macro expansion.\n+    #\n+    # TODO: Reduce duplication where possible.\n+\n+    # Attributes from parsing\n+    graph = ensure_attributes(SyntaxGraph(), kind=Kind, syntax_flags=UInt16, source=SourceAttrType,\n+                              value=Any, name_val=String)\n+    # Attributes for macro expansion\n+    graph = ensure_attributes(ensure_macro_attributes(graph),\n+                              # Additional attribute for resolve_scopes, for\n+                              # adding our custom lambda below\n+                              is_toplevel_thunk=Bool,\n+                              toplevel_pure=Bool,\n+                              )\n+\n+    __module__ = source.module\n+\n+    # Macro expansion. Looking at Core.GeneratedFunctionStub, it seems that\n+    # macros emitted by the generator are currently expanded in the latest\n+    # world, so do that for compatibility.\n+    macro_world = typemax(UInt)\n+    ctx1 = MacroExpansionContext(graph, __module__, false, macro_world)\n+\n+    layer = only(ctx1.scope_layers)\n+\n+    # Run code generator - this acts like a macro expander and like a macro\n+    # expander it gets a MacroContext.\n+    mctx = MacroContext(syntax_graph(ctx1), g.srcref, layer, false)\n+    ex0 = g.gen(mctx, args...)\n+    if ex0 isa SyntaxTree\n+        if !is_compatible_graph(ctx1, ex0)\n+            # If the macro has produced syntax outside the macro context, copy it over.\n+            # TODO: Do we expect this always to happen?  What is the API for access\n+            # to the macro expansion context?\n+            ex0 = copy_ast(ctx1, ex0)\n+        end\n+    else\n+        ex0 = @ast ctx ex expanded::K\"Value\"\n+    end\n+    # Expand any macros emitted by the generator\n+    ex1 = expand_forms_1(ctx1, reparent(ctx1, ex0))\n+    ctx1 = MacroExpansionContext(delete_attributes(graph, :__macro_ctx__),\n+                                 ctx1.bindings, ctx1.scope_layers,\n+                                 ctx1.scope_layer_stack, false, macro_world)\n+    ex1 = reparent(ctx1, ex1)\n+\n+    # Desugaring\n+    ctx2, ex2 = expand_forms_2(ctx1, ex1)\n+\n+    # Wrap expansion in a non-toplevel lambda and run scope resolution\n+    ex2 = @ast ctx2 ex0 [K\"lambda\"(is_toplevel_thunk=false, toplevel_pure=true)\n+        [K\"block\"\n+            (adopt_scope(string(n)::K\"Identifier\", layer) for n in g.argnames)...\n+        ]\n+        [K\"block\"\n+            (adopt_scope(string(n)::K\"Identifier\", layer) for n in g.spnames)...\n+        ]\n+        ex2\n+    ]\n+    ctx3, ex3 = resolve_scopes(ctx2, ex2)\n+\n+    # Rest of lowering\n+    ctx4, ex4 = convert_closures(ctx3, ex3)\n+    ctx5, ex5 = linearize_ir(ctx4, ex4)\n+    ci = to_lowered_expr(ex5)\n+    @assert ci isa Core.CodeInfo\n+\n+    # See GeneratedFunctionStub code in base/expr.jl\n+    ci.isva = source.isva\n+    code = ci.code\n+    bindings = IdSet{Core.Binding}()\n+    for i = 1:length(code)\n+        stmt = code[i]\n+        if isa(stmt, GlobalRef)\n+            push!(bindings, convert(Core.Binding, stmt))\n+        end\n+    end\n+    if !isempty(bindings)\n+        ci.edges = Core.svec(bindings...)\n+    end\n+\n+    return ci\n+end\n+\n+\n+#-------------------------------------------------------------------------------\n+# The following functions are called directly by lowering to inspect Julia's state.\n+\n+# Get the binding for `name` if one is already resolved in module `mod`. Note\n+# that we cannot use `isdefined(::Module, ::Symbol)` here, because that causes\n+# binding resolution which is a massive side effect we must avoid in lowering.\n+function _get_module_binding(mod, name; create=false)\n+    b = @ccall jl_get_module_binding(mod::Module, name::Symbol, create::Cint)::Ptr{Core.Binding}\n+    b == C_NULL ? nothing : unsafe_pointer_to_objref(b)\n+end\n+\n+# Return true if a `name` is defined in and *by* the module `mod`.\n+# Has no side effects, unlike isdefined()\n+#\n+# (This should do what fl_defined_julia_global does for flisp lowering)\n+function is_defined_and_owned_global(mod, name)\n+    Base.binding_kind(mod, name) === Base.PARTITION_KIND_GLOBAL\n+end\n+\n+# \"Reserve\" a binding: create the binding if it doesn't exist but do not assign\n+# to it.\n+function reserve_module_binding(mod, name)\n+    # TODO: Fix the race condition here: We should really hold the Module's\n+    # binding lock during this test-and-set type operation. But the binding\n+    # lock is only accessible from C. See also the C code in\n+    # `fl_module_unique_name`.\n+    if _get_module_binding(mod, name; create=false) === nothing\n+        _get_module_binding(mod, name; create=true) !== nothing\n+    else\n+        return false\n+    end\n+end\n+\n+# Reserve a global binding named \"$basename#$i\" in module `mod` for the\n+# smallest `i` starting at `0`.\n+#\n+# TODO: Remove the use of this where possible. Currently this is used within\n+# lowering to create unique global names for keyword function bodies and\n+# closure types as a more local alternative to current-julia-module-counter.\n+# However, we should ideally defer it to eval-time to make lowering itself\n+# completely non-mutating.\n+function reserve_module_binding_i(mod, basename)\n+    i = 0\n+    while true\n+        name = \"$basename$i\"\n+        if reserve_module_binding(mod, Symbol(name))\n+            return name\n+        end\n+        i += 1\n+    end\n+end\n+\n+function lookup_method_instance(func, args, world::Integer)\n+    allargs = Vector{Any}(undef, length(args) + 1)\n+    allargs[1] = func\n+    allargs[2:end] = args\n+    mi = @ccall jl_method_lookup(allargs::Ptr{Any}, length(allargs)::Csize_t,\n+                                 world::Csize_t)::Ptr{Cvoid}\n+    return mi == C_NULL ? nothing : unsafe_pointer_to_objref(mi)\n+end\n+\n+# Like `Base.methods()` but with world age support\n+function methods_in_world(func, arg_sig, world)\n+    Base._methods(func, arg_sig, -1, world)\n+end"
    },
    {
      "sha": "ce3f0fba23b76b1b98b37cb48f2771a9d3c86188",
      "filename": "JuliaLowering/src/scope_analysis.jl",
      "status": "added",
      "additions": 814,
      "deletions": 0,
      "changes": 814,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fscope_analysis.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fscope_analysis.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fscope_analysis.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,814 @@\n+# Lowering pass 3: scope and variable analysis\n+\n+\"\"\"\n+Key to use when transforming names into bindings\n+\"\"\"\n+struct NameKey\n+    name::String\n+    layer::LayerId\n+end\n+\n+function Base.isless(a::NameKey, b::NameKey)\n+    (a.name, a.layer) < (b.name, b.layer)\n+end\n+\n+function NameKey(ex::SyntaxTree)\n+    @chk kind(ex) == K\"Identifier\"\n+    NameKey(ex.name_val, ex.scope_layer)\n+end\n+\n+#-------------------------------------------------------------------------------\n+_insert_if_not_present!(dict, key, val) = get!(dict, key, val)\n+\n+function _find_scope_vars!(ctx, assignments, locals, destructured_args, globals, used_names, used_bindings, ex)\n+    k = kind(ex)\n+    if k == K\"Identifier\"\n+        _insert_if_not_present!(used_names, NameKey(ex), ex)\n+    elseif k == K\"BindingId\"\n+        push!(used_bindings, ex.var_id)\n+    elseif is_leaf(ex) || is_quoted(k) ||\n+            k in KSet\"scope_block lambda module toplevel\"\n+        return\n+    elseif k == K\"local\"\n+        if getmeta(ex, :is_destructured_arg, false)\n+            push!(destructured_args, ex[1])\n+        else\n+            _insert_if_not_present!(locals, NameKey(ex[1]), ex)\n+        end\n+    elseif k == K\"global\"\n+        if !(kind(ex[1]) == K\"Value\" && ex[1].value isa GlobalRef)\n+            _insert_if_not_present!(globals, NameKey(ex[1]), ex)\n+        end\n+    elseif k == K\"assign_or_constdecl_if_global\"\n+        # like v = val, except that if `v` turns out global(either implicitly or\n+        # by explicit `global`), it gains an implicit `const`\n+        _insert_if_not_present!(assignments, NameKey(ex[1]), ex)\n+    elseif k == K\"=\" || k == K\"constdecl\"\n+        v = decl_var(ex[1])\n+        if !(kind(v) in KSet\"BindingId globalref Value Placeholder\")\n+            _insert_if_not_present!(assignments, NameKey(v), v)\n+        end\n+        if k != K\"constdecl\" || numchildren(ex) == 2\n+            _find_scope_vars!(ctx, assignments, locals, destructured_args, globals, used_names, used_bindings, ex[2])\n+        end\n+    elseif k == K\"function_decl\"\n+        v = ex[1]\n+        kv = kind(v)\n+        if kv == K\"Identifier\"\n+            _insert_if_not_present!(assignments, NameKey(v), v)\n+        elseif kv == K\"BindingId\"\n+            binfo = lookup_binding(ctx, v)\n+            if !binfo.is_ssa && binfo.kind != :global\n+                @assert false \"allow local BindingId as function name?\"\n+            end\n+        else\n+            @assert false\n+        end\n+    else\n+        for e in children(ex)\n+            _find_scope_vars!(ctx, assignments, locals, destructured_args, globals, used_names, used_bindings, e)\n+        end\n+    end\n+end\n+\n+# Find names of all identifiers used in the given expression, grouping them\n+# into sets by type of usage.\n+#\n+# NB: This only works properly after desugaring\n+function find_scope_vars(ctx, ex)\n+    ExT = typeof(ex)\n+    assignments = Dict{NameKey,ExT}()\n+    locals = Dict{NameKey,ExT}()\n+    destructured_args = Vector{ExT}()\n+    globals = Dict{NameKey,ExT}()\n+    used_names = Dict{NameKey,ExT}()\n+    used_bindings = Set{IdTag}()\n+    for e in children(ex)\n+        _find_scope_vars!(ctx, assignments, locals, destructured_args, globals, used_names, used_bindings, e)\n+    end\n+\n+    # Sort by key so that id generation is deterministic\n+    assignments = sort!(collect(pairs(assignments)), by=first)\n+    locals      = sort!(collect(pairs(locals)),      by=first)\n+    globals     = sort!(collect(pairs(globals)),     by=first)\n+    used_names  = sort!(collect(pairs(used_names)),  by=first)\n+    used_bindings = sort!(collect(used_bindings))\n+\n+    return assignments, locals, destructured_args, globals, used_names, used_bindings\n+end\n+\n+struct ScopeInfo\n+    # True if scope is the global top level scope\n+    is_toplevel_global_scope::Bool\n+    # True if scope is part of top level code, or a non-lambda scope nested\n+    # inside top level code. Thus requiring special scope resolution rules.\n+    in_toplevel_thunk::Bool\n+    # Soft/hard scope. For top level thunks only\n+    is_soft::Bool\n+    is_hard::Bool\n+    # Map from variable names to IDs which appear in this scope but not in the\n+    # parent scope\n+    # TODO: Rename to `locals` or local_bindings?\n+    var_ids::Dict{NameKey,IdTag}\n+    # Bindings used by the enclosing lambda\n+    lambda_bindings::LambdaBindings\n+end\n+\n+struct ScopeResolutionContext{GraphType} <: AbstractLoweringContext\n+    graph::GraphType\n+    bindings::Bindings\n+    mod::Module\n+    scope_layers::Vector{ScopeLayer}\n+    # name=>id mappings for all discovered global vars\n+    global_vars::Dict{NameKey,IdTag}\n+    # Stack of name=>id mappings for each scope, innermost scope last.\n+    scope_stack::Vector{ScopeInfo}\n+    # Variables which were implicitly global due to being assigned to in top\n+    # level code\n+    implicit_toplevel_globals::Set{NameKey}\n+end\n+\n+function ScopeResolutionContext(ctx)\n+    graph = ensure_attributes(ctx.graph, lambda_bindings=LambdaBindings)\n+    ScopeResolutionContext(graph,\n+                           ctx.bindings,\n+                           ctx.mod,\n+                           ctx.scope_layers,\n+                           Dict{NameKey,IdTag}(),\n+                           Vector{ScopeInfo}(),\n+                           Set{NameKey}())\n+end\n+\n+function current_lambda_bindings(ctx::ScopeResolutionContext)\n+    last(ctx.scope_stack).lambda_bindings\n+end\n+\n+function lookup_var(ctx, varkey::NameKey, exclude_toplevel_globals=false)\n+    for i in lastindex(ctx.scope_stack):-1:1\n+        ids = ctx.scope_stack[i].var_ids\n+        id = get(ids, varkey, nothing)\n+        if !isnothing(id) && (!exclude_toplevel_globals ||\n+                              i > 1 || lookup_binding(ctx, id).kind != :global)\n+            return id\n+        end\n+    end\n+    return exclude_toplevel_globals ? nothing : get(ctx.global_vars, varkey, nothing)\n+end\n+\n+function var_kind(ctx, id::IdTag)\n+    lookup_binding(ctx, id).kind\n+end\n+\n+function var_kind(ctx, varkey::NameKey, exclude_toplevel_globals=false)\n+    id = lookup_var(ctx, varkey, exclude_toplevel_globals)\n+    isnothing(id) ? nothing : lookup_binding(ctx, id).kind\n+end\n+\n+function init_binding(ctx, srcref, varkey::NameKey, kind::Symbol; kws...)\n+    id = kind === :global ? get(ctx.global_vars, varkey, nothing) : nothing\n+    if isnothing(id)\n+        mod = kind === :global ? ctx.scope_layers[varkey.layer].mod : nothing\n+        ex = new_binding(ctx, srcref, varkey.name, kind; mod=mod, kws...)\n+        id = ex.var_id\n+    end\n+    if kind === :global\n+        ctx.global_vars[varkey] = id\n+    end\n+    id\n+end\n+\n+# Add lambda arguments and static parameters\n+function add_lambda_args(ctx, var_ids, args, args_kind)\n+    for arg in args\n+        ka = kind(arg)\n+        if ka == K\"Identifier\"\n+            varkey = NameKey(arg)\n+            if haskey(var_ids, varkey)\n+                vk = lookup_binding(ctx, var_ids[varkey]).kind\n+                _is_arg(k) = k == :argument || k == :local\n+                msg = _is_arg(vk) && _is_arg(args_kind) ? \"function argument name not unique\"         :\n+                      vk == :static_parameter && args_kind == :static_parameter ? \"function static parameter name not unique\" :\n+                      \"static parameter name not distinct from function argument\"\n+                throw(LoweringError(arg, msg))\n+            end\n+            is_always_defined = args_kind == :argument\n+            id = init_binding(ctx, arg, varkey, args_kind;\n+                              is_nospecialize=getmeta(arg, :nospecialize, false),\n+                              is_always_defined=is_always_defined)\n+            var_ids[varkey] = id\n+        elseif ka != K\"BindingId\" && ka != K\"Placeholder\"\n+            throw(LoweringError(arg, \"Unexpected lambda arg kind\"))\n+        end\n+    end\n+end\n+\n+# Analyze identifier usage within a scope\n+# * Allocate a new binding for each identifier which the scope introduces.\n+# * Record the identifier=>binding mapping in a lookup table\n+# * Return a `ScopeInfo` with the mapping plus additional scope metadata\n+function analyze_scope(ctx, ex, scope_type, is_toplevel_global_scope=false,\n+                       lambda_args=nothing, lambda_static_parameters=nothing)\n+    parentscope = isempty(ctx.scope_stack) ? nothing : ctx.scope_stack[end]\n+    is_outer_lambda_scope = kind(ex) == K\"lambda\"\n+    in_toplevel_thunk = is_toplevel_global_scope ||\n+        (!is_outer_lambda_scope && parentscope.in_toplevel_thunk)\n+\n+    assignments, locals, destructured_args, globals,\n+        used_names, used_bindings = find_scope_vars(ctx, ex)\n+\n+    # Construct a mapping from identifiers to bindings\n+    #\n+    # This will contain a binding ID for each variable which is introduced by\n+    # the scope, including\n+    # * Explicit locals\n+    # * Explicit globals\n+    # * Implicit locals created by assignment\n+    var_ids = Dict{NameKey,IdTag}()\n+\n+    if !isnothing(lambda_args)\n+        add_lambda_args(ctx, var_ids, lambda_args, :argument)\n+        add_lambda_args(ctx, var_ids, lambda_static_parameters, :static_parameter)\n+        add_lambda_args(ctx, var_ids, destructured_args, :local)\n+    end\n+\n+    # Add explicit locals\n+    for (varkey,e) in locals\n+        if haskey(var_ids, varkey)\n+            vk = lookup_binding(ctx, var_ids[varkey]).kind\n+            if vk === :argument && is_outer_lambda_scope\n+                throw(LoweringError(e, \"local variable name `$(varkey.name)` conflicts with an argument\"))\n+            elseif vk === :static_parameter\n+                throw(LoweringError(e, \"local variable name `$(varkey.name)` conflicts with a static parameter\"))\n+            end\n+        elseif var_kind(ctx, varkey) === :static_parameter\n+            throw(LoweringError(e, \"local variable name `$(varkey.name)` conflicts with a static parameter\"))\n+        else\n+            var_ids[varkey] = init_binding(ctx, e[1], varkey, :local)\n+        end\n+    end\n+\n+    # Add explicit globals\n+    for (varkey,e) in globals\n+        if haskey(var_ids, varkey)\n+            vk = lookup_binding(ctx, var_ids[varkey]).kind\n+            if vk === :local\n+                throw(LoweringError(e, \"Variable `$(varkey.name)` declared both local and global\"))\n+            elseif vk === :argument && is_outer_lambda_scope\n+                throw(LoweringError(e, \"global variable name `$(varkey.name)` conflicts with an argument\"))\n+            elseif vk === :static_parameter\n+                throw(LoweringError(e, \"global variable name `$(varkey.name)` conflicts with a static parameter\"))\n+            end\n+        elseif var_kind(ctx, varkey) === :static_parameter\n+            throw(LoweringError(e, \"global variable name `$(varkey.name)` conflicts with a static parameter\"))\n+        end\n+        var_ids[varkey] = init_binding(ctx, e[1], varkey, :global)\n+    end\n+\n+    # Compute implicit locals and globals\n+    if is_toplevel_global_scope\n+        is_hard_scope = false\n+        is_soft_scope = false\n+\n+        # Assignments are implicitly global at top level, unless they come from\n+        # a macro expansion\n+        for (varkey,e) in assignments\n+            vk = haskey(var_ids, varkey) ?\n+                 lookup_binding(ctx, var_ids[varkey]).kind :\n+                 var_kind(ctx, varkey, true)\n+            if vk === nothing\n+                if ctx.scope_layers[varkey.layer].is_macro_expansion\n+                    var_ids[varkey] = init_binding(ctx, e, varkey, :local)\n+                else\n+                    init_binding(ctx, e, varkey, :global)\n+                    push!(ctx.implicit_toplevel_globals, varkey)\n+                end\n+            end\n+        end\n+    else\n+        is_hard_scope = in_toplevel_thunk && (parentscope.is_hard || scope_type === :hard)\n+        is_soft_scope = in_toplevel_thunk && !is_hard_scope &&\n+                        (scope_type === :neutral ? parentscope.is_soft : scope_type === :soft)\n+\n+        # Outside top level code, most assignments create local variables implicitly\n+        for (varkey,e) in assignments\n+            vk = haskey(var_ids, varkey) ?\n+                 lookup_binding(ctx, var_ids[varkey]).kind :\n+                 var_kind(ctx, varkey, true)\n+            if vk === :static_parameter\n+                throw(LoweringError(e, \"local variable name `$(varkey.name)` conflicts with a static parameter\"))\n+            elseif vk !== nothing\n+                continue\n+            end\n+            # Assignment is to a newly discovered variable name\n+            is_ambiguous_local = false\n+            if in_toplevel_thunk && !is_hard_scope\n+                # In a top level thunk but *inside* a nontrivial scope\n+                layer = ctx.scope_layers[varkey.layer]\n+                if !layer.is_macro_expansion && (varkey in ctx.implicit_toplevel_globals ||\n+                        is_defined_and_owned_global(layer.mod, Symbol(varkey.name)))\n+                    # Special scope rules to make assignments to globals work\n+                    # like assignments to locals do inside a function.\n+                    if is_soft_scope\n+                        # Soft scope (eg, for loop in REPL) => treat as a global\n+                        init_binding(ctx, e, varkey, :global)\n+                        continue\n+                    else\n+                        # Ambiguous case (eg, nontrivial scopes in package top level code)\n+                        # => Treat as local but generate warning when assigned to\n+                        is_ambiguous_local = true\n+                    end\n+                end\n+            end\n+            var_ids[varkey] = init_binding(ctx, e, varkey, :local;\n+                                           is_ambiguous_local=is_ambiguous_local)\n+        end\n+    end\n+\n+    #--------------------------------------------------\n+    # At this point we've discovered all the bindings defined in this scope and\n+    # added them to `var_ids`.\n+    #\n+    # Next we record information about how the new bindings relate to the\n+    # enclosing lambda\n+    # * All non-globals are recorded (kind :local and :argument will later be turned into slots)\n+    # * Captured variables are detected and recorded\n+    #\n+    # TODO: Move most or-all of this to the VariableAnalysis sub-pass\n+    lambda_bindings = if is_outer_lambda_scope\n+        if isempty(lambda_args)\n+            LambdaBindings()\n+        else\n+            selfarg = first(lambda_args)\n+            selfid = kind(selfarg) == K\"BindingId\" ?\n+                     selfarg.var_id : var_ids[NameKey(selfarg)]\n+            LambdaBindings(selfid)\n+        end\n+    else\n+        parentscope.lambda_bindings\n+    end\n+\n+    for id in values(var_ids)\n+        binfo = lookup_binding(ctx, id)\n+        if !binfo.is_ssa && binfo.kind !== :global\n+            init_lambda_binding(lambda_bindings, id)\n+        end\n+    end\n+\n+    # FIXME: This assumes used bindings are internal to the lambda and cannot\n+    # be from the environment, and also assumes they are assigned. That's\n+    # correct for now but in general we should go by the same code path that\n+    # identifiers do.\n+    for id in used_bindings\n+        binfo = lookup_binding(ctx, id)\n+        if (binfo.kind === :local && !binfo.is_ssa) || binfo.kind === :argument ||\n+                binfo.kind === :static_parameter\n+            if !has_lambda_binding(lambda_bindings, id)\n+                init_lambda_binding(lambda_bindings, id)\n+            end\n+        end\n+    end\n+\n+    for (varkey, e) in used_names\n+        id = haskey(var_ids, varkey) ? var_ids[varkey] : lookup_var(ctx, varkey)\n+        if id === nothing\n+            # Identifiers which are used but not defined in some scope are\n+            # newly discovered global bindings\n+            init_binding(ctx, e, varkey, :global)\n+        elseif !in_toplevel_thunk\n+            binfo = lookup_binding(ctx, id)\n+            if binfo.kind !== :global\n+                if !has_lambda_binding(lambda_bindings, id)\n+                    # Used vars from a scope *outside* the current lambda are captured\n+                    init_lambda_binding(lambda_bindings, id, is_captured=true)\n+                    update_binding!(ctx, id; is_captured=true)\n+                end\n+            end\n+        end\n+    end\n+\n+    if !in_toplevel_thunk\n+        for (varkey,_) in assignments\n+            id = haskey(var_ids, varkey) ? var_ids[varkey] : lookup_var(ctx, varkey)\n+            binfo = lookup_binding(ctx, id)\n+            if binfo.kind !== :global\n+                if !has_lambda_binding(lambda_bindings, id)\n+                    # Assigned vars from a scope *outside* the current lambda are captured\n+                    init_lambda_binding(lambda_bindings, id, is_captured=true)\n+                    update_binding!(ctx, id; is_captured=true)\n+                end\n+            end\n+        end\n+    end\n+\n+    return ScopeInfo(is_toplevel_global_scope, in_toplevel_thunk, is_soft_scope,\n+                     is_hard_scope, var_ids, lambda_bindings)\n+end\n+\n+function add_local_decls!(ctx, stmts, srcref, scope)\n+    # Add local decls to start of block so that closure conversion can\n+    # initialize if necessary.\n+    for id in sort!(collect(values(scope.var_ids)))\n+        binfo = lookup_binding(ctx, id)\n+        if binfo.kind == :local\n+            push!(stmts, @ast ctx srcref [K\"local\" binding_ex(ctx, id)])\n+        end\n+    end\n+end\n+\n+function _resolve_scopes(ctx, ex::SyntaxTree)\n+    k = kind(ex)\n+    if k == K\"Identifier\"\n+        @ast ctx ex lookup_var(ctx, NameKey(ex))::K\"BindingId\"\n+    elseif is_leaf(ex) || is_quoted(ex) || k == K\"toplevel\"\n+        ex\n+    # elseif k == K\"global\"\n+    #     ex\n+    elseif k == K\"local\"\n+        # Local declarations have a value of `nothing` according to flisp\n+        # lowering.\n+        # TODO: Should local decls be disallowed in value position?\n+        @ast ctx ex \"nothing\"::K\"core\"\n+    elseif k == K\"decl\"\n+        ex_out = mapchildren(e->_resolve_scopes(ctx, e), ctx, ex)\n+        name = ex_out[1]\n+        if kind(name) != K\"Placeholder\"\n+            binfo = lookup_binding(ctx, name)\n+            if binfo.kind == :global && !ctx.scope_stack[end].in_toplevel_thunk\n+                throw(LoweringError(ex, \"type declarations for global variables must be at top level, not inside a function\"))\n+            end\n+        end\n+        id = ex_out[1]\n+        if kind(id) != K\"Placeholder\"\n+            binfo = lookup_binding(ctx, id)\n+            if !isnothing(binfo.type)\n+                throw(LoweringError(ex, \"multiple type declarations found for `$(binfo.name)`\"))\n+            end\n+            update_binding!(ctx, id; type=ex_out[2])\n+        end\n+        ex_out\n+    elseif k == K\"always_defined\"\n+        id = lookup_var(ctx, NameKey(ex[1]))\n+        update_binding!(ctx, id; is_always_defined=true)\n+        makeleaf(ctx, ex, K\"TOMBSTONE\")\n+    elseif k == K\"lambda\"\n+        is_toplevel_thunk = ex.is_toplevel_thunk\n+        scope = analyze_scope(ctx, ex, nothing, is_toplevel_thunk,\n+                              children(ex[1]), children(ex[2]))\n+\n+        push!(ctx.scope_stack, scope)\n+        arg_bindings = _resolve_scopes(ctx, ex[1])\n+        sparm_bindings = _resolve_scopes(ctx, ex[2])\n+        body_stmts = SyntaxList(ctx)\n+        add_local_decls!(ctx, body_stmts, ex, scope)\n+        body = _resolve_scopes(ctx, ex[3])\n+        if kind(body) == K\"block\"\n+            append!(body_stmts, children(body))\n+        else\n+            push!(body_stmts, body)\n+        end\n+        ret_var = numchildren(ex) == 4 ? _resolve_scopes(ctx, ex[4]) : nothing\n+        pop!(ctx.scope_stack)\n+\n+        @ast ctx ex [K\"lambda\"(lambda_bindings=scope.lambda_bindings,\n+                               is_toplevel_thunk=is_toplevel_thunk,\n+                               toplevel_pure=false)\n+            arg_bindings\n+            sparm_bindings\n+            [K\"block\"\n+                body_stmts...\n+            ]\n+            ret_var\n+        ]\n+    elseif k == K\"scope_block\"\n+        scope = analyze_scope(ctx, ex, ex.scope_type)\n+        push!(ctx.scope_stack, scope)\n+        stmts = SyntaxList(ctx)\n+        add_local_decls!(ctx, stmts, ex, scope)\n+        for e in children(ex)\n+            push!(stmts, _resolve_scopes(ctx, e))\n+        end\n+        pop!(ctx.scope_stack)\n+        @ast ctx ex [K\"block\" stmts...]\n+    elseif k == K\"extension\"\n+        etype = extension_type(ex)\n+        if etype == \"islocal\"\n+            id = lookup_var(ctx, NameKey(ex[2]))\n+            islocal = !isnothing(id) && var_kind(ctx, id) != :global\n+            @ast ctx ex islocal::K\"Bool\"\n+        elseif etype == \"isglobal\"\n+            e2 = ex[2]\n+            @chk kind(e2) in KSet\"Identifier Placeholder\"\n+            isglobal = if kind(e2) == K\"Identifier\"\n+                id = lookup_var(ctx, NameKey(e2))\n+                isnothing(id) || var_kind(ctx, id) == :global\n+            else\n+                false\n+            end\n+            @ast ctx ex isglobal::K\"Bool\"\n+        elseif etype == \"locals\"\n+            stmts = SyntaxList(ctx)\n+            locals_dict = ssavar(ctx, ex, \"locals_dict\")\n+            push!(stmts, @ast ctx ex [K\"=\"\n+                locals_dict\n+                [K\"call\"\n+                    [K\"call\"\n+                        \"apply_type\"::K\"core\"\n+                        \"Dict\"::K\"top\"\n+                        \"Symbol\"::K\"core\"\n+                        \"Any\"::K\"core\"\n+                    ]\n+                ]\n+            ])\n+            for scope in ctx.scope_stack\n+                for id in values(scope.var_ids)\n+                    binfo = lookup_binding(ctx, id)\n+                    if binfo.kind == :global || binfo.is_internal\n+                        continue\n+                    end\n+                    binding = binding_ex(ctx, id)\n+                    push!(stmts, @ast ctx ex [K\"if\"\n+                        [K\"isdefined\" binding]\n+                        [K\"call\"\n+                            \"setindex!\"::K\"top\"\n+                            locals_dict\n+                            binding\n+                            binfo.name::K\"Symbol\"\n+                        ]\n+                    ])\n+                end\n+            end\n+            push!(stmts, locals_dict)\n+            makenode(ctx, ex, K\"block\", stmts)\n+        end\n+    elseif k == K\"assert\"\n+        etype = extension_type(ex)\n+        if etype == \"require_existing_locals\"\n+            for v in ex[2:end]\n+                vk = var_kind(ctx, NameKey(v))\n+                if vk !== :local\n+                    throw(LoweringError(v, \"`outer` annotations must match with a local variable in an outer scope but no such variable was found\"))\n+                end\n+            end\n+        elseif etype == \"global_toplevel_only\"\n+            if !ctx.scope_stack[end].is_toplevel_global_scope\n+                e = ex[2][1]\n+                throw(LoweringError(e, \"$(kind(e)) is only allowed in global scope\"))\n+            end\n+        elseif etype == \"toplevel_only\"\n+            if !ctx.scope_stack[end].in_toplevel_thunk\n+                e = ex[2][1]\n+                throw(LoweringError(e, \"this syntax is only allowed in top level code\"))\n+            end\n+        else\n+            throw(LoweringError(ex, \"Unknown syntax assertion\"))\n+        end\n+        makeleaf(ctx, ex, K\"TOMBSTONE\")\n+    elseif k == K\"function_decl\"\n+        resolved = mapchildren(e->_resolve_scopes(ctx, e), ctx, ex)\n+        name = resolved[1]\n+        if kind(name) == K\"BindingId\"\n+            bk = lookup_binding(ctx, name).kind\n+            if bk == :argument\n+                throw(LoweringError(name, \"Cannot add method to a function argument\"))\n+            elseif bk == :global && !ctx.scope_stack[end].in_toplevel_thunk\n+                throw(LoweringError(name,\n+                    \"Global method definition needs to be placed at the top level, or use `eval()`\"))\n+            end\n+        end\n+        resolved\n+    elseif k == K\"assign_or_constdecl_if_global\"\n+        id = _resolve_scopes(ctx, ex[1])\n+        bk = lookup_binding(ctx, id).kind\n+        @assert numchildren(ex) === 2\n+        assignment_kind = bk == :global ? K\"constdecl\" : K\"=\"\n+        @ast ctx ex _resolve_scopes(ctx, [assignment_kind ex[1] ex[2]])\n+    else\n+        mapchildren(e->_resolve_scopes(ctx, e), ctx, ex)\n+    end\n+end\n+\n+function _resolve_scopes(ctx, exs::AbstractVector)\n+    out = SyntaxList(ctx)\n+    for e in exs\n+        push!(out, _resolve_scopes(ctx, e))\n+    end\n+    out\n+end\n+\n+#-------------------------------------------------------------------------------\n+# Sub-pass to compute additional information about variable usage as required\n+# by closure conversion, etc\n+struct ClosureBindings\n+    name_stack::Vector{String}      # Names of functions the closure is nested within\n+    lambdas::Vector{LambdaBindings} # Bindings for each method of the closure\n+end\n+\n+ClosureBindings(name_stack) = ClosureBindings(name_stack, Vector{LambdaBindings}())\n+\n+struct VariableAnalysisContext{GraphType} <: AbstractLoweringContext\n+    graph::GraphType\n+    bindings::Bindings\n+    mod::Module\n+    lambda_bindings::LambdaBindings\n+    # Stack of method definitions for closure naming\n+    method_def_stack::SyntaxList{GraphType}\n+    # Collection of information about each closure, principally which methods\n+    # are part of the closure (and hence captures).\n+    closure_bindings::Dict{IdTag,ClosureBindings}\n+end\n+\n+function VariableAnalysisContext(graph, bindings, mod, lambda_bindings)\n+    VariableAnalysisContext(graph, bindings, mod, lambda_bindings,\n+                            SyntaxList(graph), Dict{IdTag,ClosureBindings}())\n+end\n+\n+function current_lambda_bindings(ctx::VariableAnalysisContext)\n+    ctx.lambda_bindings\n+end\n+\n+function init_closure_bindings!(ctx, fname)\n+    func_name_id = fname.var_id\n+    @assert lookup_binding(ctx, func_name_id).kind === :local\n+    get!(ctx.closure_bindings, func_name_id) do\n+        name_stack = Vector{String}()\n+        for parentname in ctx.method_def_stack\n+            if kind(parentname) == K\"BindingId\"\n+                push!(name_stack, lookup_binding(ctx, parentname).name)\n+            end\n+        end\n+        push!(name_stack, lookup_binding(ctx, func_name_id).name)\n+        ClosureBindings(name_stack)\n+    end\n+end\n+\n+function find_any_local_binding(ctx, ex)\n+    k = kind(ex)\n+    if k == K\"BindingId\"\n+        bkind = lookup_binding(ctx, ex.var_id).kind\n+        if bkind != :global && bkind != :static_parameter\n+            return ex\n+        end\n+    elseif !is_leaf(ex) && !is_quoted(ex)\n+        for e in children(ex)\n+            r = find_any_local_binding(ctx, e)\n+            if !isnothing(r)\n+                return r\n+            end\n+        end\n+    end\n+    return nothing\n+end\n+\n+# Update ctx.bindings and ctx.lambda_bindings metadata based on binding usage\n+function analyze_variables!(ctx, ex)\n+    k = kind(ex)\n+    if k == K\"BindingId\"\n+        if has_lambda_binding(ctx, ex)\n+            # TODO: Move this after closure conversion so that we don't need\n+            # to model the closure conversion transformations here.\n+            update_lambda_binding!(ctx, ex, is_read=true)\n+        else\n+            binfo = lookup_binding(ctx, ex.var_id)\n+            if !binfo.is_ssa && binfo.kind != :global\n+                # The type of typed locals is invisible in the previous pass,\n+                # but is filled in here.\n+                init_lambda_binding(ctx.lambda_bindings, ex.var_id, is_captured=true, is_read=true)\n+                update_binding!(ctx, ex, is_captured=true)\n+            end\n+        end\n+    elseif is_leaf(ex) || is_quoted(ex)\n+        return\n+    elseif k == K\"static_eval\"\n+        badvar = find_any_local_binding(ctx, ex[1])\n+        if !isnothing(badvar)\n+            name_hint = getmeta(ex, :name_hint, \"syntax\")\n+            throw(LoweringError(badvar, \"$(name_hint) cannot reference local variable\"))\n+        end\n+        return\n+    elseif k == K\"local\" || k == K\"global\"\n+        # Presence of BindingId within local/global is ignored.\n+        return\n+    elseif k == K\"=\"\n+        lhs = ex[1]\n+        if kind(lhs) != K\"Placeholder\"\n+            update_binding!(ctx, lhs, add_assigned=1)\n+            if has_lambda_binding(ctx, lhs)\n+                update_lambda_binding!(ctx, lhs, is_assigned=true)\n+            end\n+            lhs_binfo = lookup_binding(ctx, lhs)\n+            if !isnothing(lhs_binfo.type)\n+                # Assignments introduce a variable's type later during closure\n+                # conversion, but we must model that explicitly here.\n+                analyze_variables!(ctx, lhs_binfo.type)\n+            end\n+        end\n+        analyze_variables!(ctx, ex[2])\n+    elseif k == K\"function_decl\"\n+        name = ex[1]\n+        if lookup_binding(ctx, name.var_id).kind === :local\n+            init_closure_bindings!(ctx, name)\n+        end\n+        update_binding!(ctx, name, add_assigned=1)\n+        if has_lambda_binding(ctx, name)\n+            update_lambda_binding!(ctx, name, is_assigned=true)\n+        end\n+    elseif k == K\"function_type\"\n+        if kind(ex[1]) != K\"BindingId\" || lookup_binding(ctx, ex[1]).kind !== :local\n+            analyze_variables!(ctx, ex[1])\n+        end\n+    elseif k == K\"constdecl\"\n+        id = ex[1]\n+        if kind(id) == K\"BindingId\"\n+            if lookup_binding(ctx, id).kind == :local\n+                throw(LoweringError(ex, \"unsupported `const` declaration on local variable\"))\n+            end\n+            update_binding!(ctx, id; is_const=true)\n+        end\n+    elseif k == K\"call\"\n+        name = ex[1]\n+        if kind(name) == K\"BindingId\"\n+            id = name.var_id\n+            if has_lambda_binding(ctx, id)\n+                # TODO: Move this after closure conversion so that we don't need\n+                # to model the closure conversion transformations.\n+                update_lambda_binding!(ctx, id, is_called=true)\n+            end\n+        end\n+        foreach(e->analyze_variables!(ctx, e), children(ex))\n+    elseif k == K\"method_defs\"\n+        push!(ctx.method_def_stack, ex[1])\n+        analyze_variables!(ctx, ex[2])\n+        pop!(ctx.method_def_stack)\n+    elseif k == K\"_opaque_closure\"\n+        name = ex[1]\n+        init_closure_bindings!(ctx, name)\n+        push!(ctx.method_def_stack, name)\n+        analyze_variables!(ctx, ex[2])\n+        analyze_variables!(ctx, ex[3])\n+        analyze_variables!(ctx, ex[4])\n+        analyze_variables!(ctx, ex[9])\n+        pop!(ctx.method_def_stack)\n+    elseif k == K\"lambda\"\n+        lambda_bindings = ex.lambda_bindings\n+        if !ex.is_toplevel_thunk && !isempty(ctx.method_def_stack)\n+            # Record all lambdas for the same closure type in one place\n+            func_name = last(ctx.method_def_stack)\n+            if kind(func_name) == K\"BindingId\"\n+                func_name_id = func_name.var_id\n+                if lookup_binding(ctx, func_name_id).kind === :local\n+                    push!(ctx.closure_bindings[func_name_id].lambdas, lambda_bindings)\n+                end\n+            end\n+        end\n+        ctx2 = VariableAnalysisContext(ctx.graph, ctx.bindings, ctx.mod, lambda_bindings,\n+                                       ctx.method_def_stack, ctx.closure_bindings)\n+        foreach(e->analyze_variables!(ctx2, e), ex[3:end]) # body & return type\n+        for (id,lbinfo) in pairs(lambda_bindings.bindings)\n+            if lbinfo.is_captured\n+                # Add any captured bindings to the enclosing lambda, if necessary.\n+                outer_lbinfo = lookup_lambda_binding(ctx.lambda_bindings, id)\n+                if isnothing(outer_lbinfo)\n+                    # Inner lambda captures a variable. If it's not yet present\n+                    # in the outer lambda, the outer lambda must capture it as\n+                    # well so that the closure associated to the inner lambda\n+                    # can be initialized when `function_decl` is hit.\n+                    init_lambda_binding(ctx.lambda_bindings, id, is_captured=true, is_read=true)\n+                end\n+            end\n+        end\n+    else\n+        foreach(e->analyze_variables!(ctx, e), children(ex))\n+    end\n+    nothing\n+end\n+\n+function resolve_scopes(ctx::ScopeResolutionContext, ex)\n+    if kind(ex) != K\"lambda\"\n+        # Wrap in a top level thunk if we're not already expanding a lambda.\n+        # (Maybe this should be done elsewhere?)\n+        ex = @ast ctx ex [K\"lambda\"(is_toplevel_thunk=true, toplevel_pure=false)\n+            [K\"block\"]\n+            [K\"block\"]\n+            ex\n+        ]\n+    end\n+    _resolve_scopes(ctx, ex)\n+end\n+\n+\"\"\"\n+This pass analyzes scopes and the names (locals/globals etc) used within them.\n+\n+Names of kind `K\"Identifier\"` are transformed into binding identifiers of\n+kind `K\"BindingId\"`. The associated `Bindings` table in the context records\n+metadata about each binding.\n+\n+This pass also records the set of binding IDs used locally within the\n+enclosing lambda form and information about variables captured by closures.\n+\"\"\"\n+@fzone \"JL: resolve_scopes\" function resolve_scopes(ctx::DesugaringContext, ex)\n+    ctx2 = ScopeResolutionContext(ctx)\n+    ex2 = resolve_scopes(ctx2, reparent(ctx2, ex))\n+    ctx3 = VariableAnalysisContext(ctx2.graph, ctx2.bindings, ctx2.mod, ex2.lambda_bindings)\n+    analyze_variables!(ctx3, ex2)\n+    ctx3, ex2\n+end"
    },
    {
      "sha": "c8145aa1b93c3a5fcd928a9508a82140b0d60dda",
      "filename": "JuliaLowering/src/syntax_graph.jl",
      "status": "added",
      "additions": 828,
      "deletions": 0,
      "changes": 828,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fsyntax_graph.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,828 @@\n+const NodeId = Int\n+\n+\"\"\"\n+Directed graph with arbitrary attributes on nodes. Used here for representing\n+one or several syntax trees.\n+\n+TODO: Global attributes!\n+\"\"\"\n+mutable struct SyntaxGraph{Attrs}\n+    edge_ranges::Vector{UnitRange{Int}}\n+    edges::Vector{NodeId}\n+    attributes::Attrs\n+end\n+\n+SyntaxGraph() = SyntaxGraph{Dict{Symbol,Any}}(Vector{UnitRange{Int}}(),\n+                                              Vector{NodeId}(), Dict{Symbol,Any}())\n+\n+# \"Freeze\" attribute names and types, encoding them in the type of the returned\n+# SyntaxGraph.\n+function freeze_attrs(graph::SyntaxGraph)\n+    frozen_attrs = (; pairs(graph.attributes)...)\n+    SyntaxGraph(graph.edge_ranges, graph.edges, frozen_attrs)\n+end\n+\n+# Create a copy of `graph` where the attribute list is mutable\n+function unfreeze_attrs(graph::SyntaxGraph)\n+    unfrozen_attrs = Dict{Symbol,Any}(pairs(graph.attributes)...)\n+    SyntaxGraph(graph.edge_ranges, graph.edges, unfrozen_attrs)\n+end\n+\n+function _show_attrs(io, attributes::Dict)\n+    show(io, MIME(\"text/plain\"), attributes)\n+end\n+function _show_attrs(io, attributes::NamedTuple)\n+    show(io, MIME(\"text/plain\"), Dict(pairs(attributes)...))\n+end\n+\n+function attrnames(graph::SyntaxGraph)\n+    keys(graph.attributes)\n+end\n+\n+function attrdefs(graph::SyntaxGraph)\n+    [(k=>typeof(v).parameters[2]) for (k, v) in pairs(graph.attributes)]\n+end\n+\n+function Base.show(io::IO, ::MIME\"text/plain\", graph::SyntaxGraph)\n+    print(io, typeof(graph),\n+          \" with $(length(graph.edge_ranges)) vertices, $(length(graph.edges)) edges, and attributes:\\n\")\n+    _show_attrs(io, graph.attributes)\n+end\n+\n+function ensure_attributes!(graph::SyntaxGraph; kws...)\n+    for (k,v) in pairs(kws)\n+        @assert k isa Symbol\n+        @assert v isa Type\n+        if haskey(graph.attributes, k)\n+            v0 = valtype(graph.attributes[k])\n+            v == v0 || throw(ErrorException(\"Attribute type mismatch $v != $v0\"))\n+        elseif graph.attributes isa NamedTuple\n+            throw(ErrorException(\"\"\"\n+                ensure_attributes!: $k is not an existing attribute, and the graph's attributes are frozen. \\\n+                Consider calling non-mutating `ensure_attributes` instead.\"\"\"))\n+        else\n+            graph.attributes[k] = Dict{NodeId,v}()\n+        end\n+    end\n+    graph\n+end\n+\n+function ensure_attributes(graph::SyntaxGraph{<:Dict}; kws...)\n+    g = unfreeze_attrs(graph)\n+    ensure_attributes!(g; kws...)\n+end\n+\n+function ensure_attributes(graph::SyntaxGraph{<:NamedTuple}; kws...)\n+    g = unfreeze_attrs(graph)\n+    ensure_attributes!(g; kws...)\n+    freeze_attrs(g)\n+end\n+\n+function delete_attributes!(graph::SyntaxGraph{<:Dict}, attr_names::Symbol...)\n+    for name in attr_names\n+        delete!(graph.attributes, name)\n+    end\n+    graph\n+end\n+\n+function delete_attributes(graph::SyntaxGraph{<:Dict}, attr_names::Symbol...)\n+    delete_attributes!(unfreeze_attrs(graph), attr_names...)\n+end\n+\n+function delete_attributes(graph::SyntaxGraph{<:NamedTuple}, attr_names::Symbol...)\n+    g = delete_attributes!(unfreeze_attrs(graph), attr_names...)\n+    freeze_attrs(g)\n+end\n+\n+function newnode!(graph::SyntaxGraph)\n+    push!(graph.edge_ranges, 0:-1) # Invalid range start => leaf node\n+    return length(graph.edge_ranges)\n+end\n+\n+function setchildren!(graph::SyntaxGraph, id, children::NodeId...)\n+    setchildren!(graph, id, children)\n+end\n+\n+function setchildren!(graph::SyntaxGraph, id, children)\n+    n = length(graph.edges)\n+    graph.edge_ranges[id] = n+1:(n+length(children))\n+    # TODO: Reuse existing edges if possible\n+    append!(graph.edges, children)\n+end\n+\n+function JuliaSyntax.is_leaf(graph::SyntaxGraph, id)\n+    first(graph.edge_ranges[id]) == 0\n+end\n+\n+function JuliaSyntax.numchildren(graph::SyntaxGraph, id)\n+    length(graph.edge_ranges[id])\n+end\n+\n+function JuliaSyntax.children(graph::SyntaxGraph, id)\n+    @view graph.edges[graph.edge_ranges[id]]\n+end\n+\n+function JuliaSyntax.children(graph::SyntaxGraph, id, r::UnitRange)\n+    @view graph.edges[graph.edge_ranges[id][r]]\n+end\n+\n+function child(graph::SyntaxGraph, id::NodeId, i::Integer)\n+    graph.edges[graph.edge_ranges[id][i]]\n+end\n+\n+function getattr(graph::SyntaxGraph{<:Dict}, name::Symbol)\n+    getfield(graph, :attributes)[name]\n+end\n+\n+function getattr(graph::SyntaxGraph{<:NamedTuple}, name::Symbol)\n+    getfield(getfield(graph, :attributes), name)\n+end\n+\n+function getattr(graph::SyntaxGraph, name::Symbol, default)\n+    get(getfield(graph, :attributes), name, default)\n+end\n+\n+function hasattr(graph::SyntaxGraph, name::Symbol)\n+    getattr(graph, name, nothing) !== nothing\n+end\n+\n+# TODO: Probably terribly non-inferable?\n+function setattr!(graph::SyntaxGraph, id; attrs...)\n+    for (k,v) in pairs(attrs)\n+        if !isnothing(v)\n+            getattr(graph, k)[id] = v\n+        end\n+    end\n+end\n+\n+function deleteattr!(graph::SyntaxGraph, id::NodeId, name::Symbol)\n+    delete!(getattr(graph, name), id)\n+end\n+\n+function Base.getproperty(graph::SyntaxGraph, name::Symbol)\n+    # TODO: Remove access to internals?\n+    name === :edge_ranges && return getfield(graph, :edge_ranges)\n+    name === :edges       && return getfield(graph, :edges)\n+    name === :attributes  && return getfield(graph, :attributes)\n+    return getattr(graph, name)\n+end\n+\n+function sethead!(graph, id::NodeId, h::JuliaSyntax.SyntaxHead)\n+    sethead!(graph, id, kind(h))\n+    setflags!(graph, id, flags(h))\n+end\n+\n+function sethead!(graph, id::NodeId, k::Kind)\n+    graph.kind[id] = k\n+end\n+\n+function setflags!(graph, id::NodeId, f::UInt16)\n+    graph.syntax_flags[id] = f\n+end\n+\n+function _convert_nodes(graph::SyntaxGraph, node::SyntaxNode)\n+    id = newnode!(graph)\n+    sethead!(graph, id, head(node))\n+    if !isnothing(node.val)\n+        v = node.val\n+        if v isa Symbol\n+            # TODO: Fixes in JuliaSyntax to avoid ever converting to Symbol\n+            setattr!(graph, id, name_val=string(v))\n+        else\n+            setattr!(graph, id, value=v)\n+        end\n+    end\n+    setattr!(graph, id, source=SourceRef(node.source, node.position, node.raw))\n+    if !is_leaf(node)\n+        cs = map(children(node)) do n\n+            _convert_nodes(graph, n)\n+        end\n+        setchildren!(graph, id, cs)\n+    end\n+    return id\n+end\n+\n+\"\"\"\n+    syntax_graph(ctx)\n+\n+Return `SyntaxGraph` associated with `ctx`\n+\"\"\"\n+syntax_graph(graph::SyntaxGraph) = graph\n+\n+function check_same_graph(x, y)\n+    if syntax_graph(x) !== syntax_graph(y)\n+        error(\"Mismatching syntax graphs\")\n+    end\n+end\n+\n+function check_compatible_graph(x, y)\n+    if !is_compatible_graph(x, y)\n+        error(\"Incompatible syntax graphs\")\n+    end\n+end\n+\n+function is_compatible_graph(x, y)\n+    syntax_graph(x).edges === syntax_graph(y).edges\n+end\n+\n+#-------------------------------------------------------------------------------\n+struct SyntaxTree{GraphType}\n+    _graph::GraphType\n+    _id::NodeId\n+end\n+\n+function Base.getproperty(ex::SyntaxTree, name::Symbol)\n+    name === :_graph && return getfield(ex, :_graph)\n+    name === :_id  && return getfield(ex, :_id)\n+    _id = getfield(ex, :_id)\n+    return get(getproperty(getfield(ex, :_graph), name), _id) do\n+        attrstr = join([\"\\n    $n = $(getproperty(ex, n))\"\n+                        for n in attrnames(ex)], \",\")\n+        error(\"Property `$name[$_id]` not found. Available attributes:$attrstr\")\n+    end\n+end\n+\n+function Base.setproperty!(ex::SyntaxTree, name::Symbol, val)\n+    return setattr!(ex._graph, ex._id; name=>val)\n+end\n+\n+function Base.propertynames(ex::SyntaxTree)\n+    attrnames(ex)\n+end\n+\n+function Base.get(ex::SyntaxTree, name::Symbol, default)\n+    attr = getattr(getfield(ex, :_graph), name, nothing)\n+    return isnothing(attr) ? default :\n+           get(attr, getfield(ex, :_id), default)\n+end\n+\n+function Base.getindex(ex::SyntaxTree, i::Integer)\n+    SyntaxTree(ex._graph, child(ex._graph, ex._id, i))\n+end\n+\n+function Base.getindex(ex::SyntaxTree, r::UnitRange)\n+    SyntaxList(ex._graph, children(ex._graph, ex._id, r))\n+end\n+\n+Base.firstindex(ex::SyntaxTree) = 1\n+Base.lastindex(ex::SyntaxTree) = numchildren(ex)\n+\n+function hasattr(ex::SyntaxTree, name::Symbol)\n+    attr = getattr(ex._graph, name, nothing)\n+    return !isnothing(attr) && haskey(attr, ex._id)\n+end\n+\n+function attrnames(ex::SyntaxTree)\n+    attrs = ex._graph.attributes\n+    [name for (name, value) in pairs(attrs) if haskey(value, ex._id)]\n+end\n+\n+function copy_node(ex::SyntaxTree)\n+    graph = syntax_graph(ex)\n+    id = newnode!(graph)\n+    if !is_leaf(ex)\n+        setchildren!(graph, id, _node_ids(graph, children(ex)...))\n+    end\n+    ex2 = SyntaxTree(graph, id)\n+    copy_attrs!(ex2, ex, true)\n+    ex2\n+end\n+\n+function setattr(ex::SyntaxTree; extra_attrs...)\n+    ex2 = copy_node(ex)\n+    setattr!(ex2; extra_attrs...)\n+    ex2\n+end\n+\n+function setattr!(ex::SyntaxTree; attrs...)\n+    setattr!(ex._graph, ex._id; attrs...)\n+end\n+\n+function deleteattr!(ex::SyntaxTree, name::Symbol)\n+    deleteattr!(ex._graph, ex._id, name)\n+end\n+\n+# JuliaSyntax tree API\n+\n+function JuliaSyntax.is_leaf(ex::SyntaxTree)\n+    is_leaf(ex._graph, ex._id)\n+end\n+\n+function JuliaSyntax.numchildren(ex::SyntaxTree)\n+    numchildren(ex._graph, ex._id)\n+end\n+\n+function JuliaSyntax.children(ex::SyntaxTree)\n+    SyntaxList(ex._graph, children(ex._graph, ex._id))\n+end\n+\n+function JuliaSyntax.head(ex::SyntaxTree)\n+    JuliaSyntax.SyntaxHead(kind(ex), flags(ex))\n+end\n+\n+function JuliaSyntax.kind(ex::SyntaxTree)\n+    ex.kind::JuliaSyntax.Kind\n+end\n+\n+function JuliaSyntax.flags(ex::SyntaxTree)\n+    get(ex, :syntax_flags, 0x0000)\n+end\n+\n+\n+# Reference to bytes within a source file\n+struct SourceRef\n+    file::SourceFile\n+    first_byte::Int\n+    # TODO: Do we need the green node, or would last_byte suffice?\n+    green_tree::JuliaSyntax.GreenNode\n+end\n+\n+JuliaSyntax.sourcefile(src::SourceRef) = src.file\n+JuliaSyntax.byte_range(src::SourceRef) = src.first_byte:(src.first_byte + span(src.green_tree) - 1)\n+\n+# TODO: Adding these methods to support LineNumberNode is kind of hacky but we\n+# can remove these after JuliaLowering becomes self-bootstrapping for macros\n+# and we a proper SourceRef for @ast's @HERE form.\n+JuliaSyntax.byte_range(src::LineNumberNode) = 0:0\n+JuliaSyntax.source_location(src::LineNumberNode) = (src.line, 0)\n+JuliaSyntax.source_location(::Type{LineNumberNode}, src::LineNumberNode) = src\n+JuliaSyntax.source_line(src::LineNumberNode) = src.line\n+# The follow somewhat strange cases are for where LineNumberNode is standing in\n+# for SourceFile because we've only got Expr-based provenance info\n+JuliaSyntax.sourcefile(src::LineNumberNode) = src\n+JuliaSyntax.sourcetext(src::LineNumberNode) = SubString(\"\")\n+JuliaSyntax.source_location(src::LineNumberNode, byte_index::Integer) = (src.line, 0)\n+JuliaSyntax.source_location(::Type{LineNumberNode}, src::LineNumberNode, byte_index::Integer) = src\n+JuliaSyntax.filename(src::LineNumberNode) = string(src.file)\n+\n+function JuliaSyntax.highlight(io::IO, src::LineNumberNode; note=\"\")\n+    print(io, src, \" - \", note)\n+end\n+\n+function JuliaSyntax.highlight(io::IO, src::SourceRef; kws...)\n+    highlight(io, src.file, first_byte(src):last_byte(src); kws...)\n+end\n+\n+function Base.show(io::IO, ::MIME\"text/plain\", src::SourceRef)\n+    highlight(io, src; note=\"these are the bytes you're looking for \ud83d\ude0a\", context_lines_inner=20)\n+end\n+\n+\n+function provenance(ex::SyntaxTree)\n+    s = ex.source\n+    if s isa NodeId\n+        return (SyntaxTree(ex._graph, s),)\n+    elseif s isa Tuple\n+        return SyntaxTree.((ex._graph,), s)\n+    else\n+        return (s,)\n+    end\n+end\n+\n+\n+function _sourceref(sources, id)\n+    i = 1\n+    while true\n+        i += 1\n+        s = sources[id]\n+        if s isa NodeId\n+            id = s\n+        else\n+            return s, id\n+        end\n+    end\n+end\n+\n+function sourceref(ex::SyntaxTree)\n+    sources = ex._graph.source\n+    id::NodeId = ex._id\n+    while true\n+        s, _ = _sourceref(sources, id)\n+        if s isa Tuple\n+            s = s[1]\n+        end\n+        if s isa NodeId\n+            id = s\n+        else\n+            return s\n+        end\n+    end\n+end\n+\n+function _flattened_provenance(refs, graph, sources, id)\n+    # TODO: Implement in terms of `provenance()`?\n+    s, id2 = _sourceref(sources, id)\n+    if s isa Tuple\n+        for i in s\n+            _flattened_provenance(refs, graph, sources, i)\n+        end\n+    else\n+        push!(refs, SyntaxTree(graph, id2))\n+    end\n+end\n+\n+function flattened_provenance(ex::SyntaxTree)\n+    refs = SyntaxList(ex)\n+    _flattened_provenance(refs, ex._graph, ex._graph.source, ex._id)\n+    return reverse(refs)\n+end\n+\n+\n+function is_ancestor(ex, ancestor)\n+    if !is_compatible_graph(ex, ancestor)\n+        return false\n+    end\n+    sources = ex._graph.source\n+    id::NodeId = ex._id\n+    while true\n+        s = get(sources, id, nothing)\n+        if s isa NodeId\n+            id = s\n+            if id == ancestor._id\n+                return true\n+            end\n+        else\n+            return false\n+        end\n+    end\n+end\n+\n+const SourceAttrType = Union{SourceRef,LineNumberNode,NodeId,Tuple}\n+\n+function SyntaxTree(graph::SyntaxGraph, node::SyntaxNode)\n+    ensure_attributes!(graph, kind=Kind, syntax_flags=UInt16, source=SourceAttrType,\n+                       value=Any, name_val=String)\n+    id = _convert_nodes(graph, node)\n+    return SyntaxTree(graph, id)\n+end\n+\n+function SyntaxTree(node::SyntaxNode)\n+    return SyntaxTree(SyntaxGraph(), node)\n+end\n+\n+attrsummary(name, value) = string(name)\n+attrsummary(name, value::Number) = \"$name=$value\"\n+\n+function _value_string(ex)\n+    k = kind(ex)\n+    str = k in KSet\"Identifier StrMacroName CmdMacroName\" || is_operator(k) ? ex.name_val :\n+          k == K\"Placeholder\" ? ex.name_val           :\n+          k == K\"SSAValue\"    ? \"%\"                   :\n+          k == K\"BindingId\"   ? \"#\"                   :\n+          k == K\"label\"       ? \"label\"               :\n+          k == K\"core\"        ? \"core.$(ex.name_val)\" :\n+          k == K\"top\"         ? \"top.$(ex.name_val)\"  :\n+          k == K\"Symbol\"      ? \":$(ex.name_val)\" :\n+          k == K\"globalref\"   ? \"$(ex.mod).$(ex.name_val)\" :\n+          k == K\"slot\"        ? \"slot\" :\n+          k == K\"latestworld\" ? \"latestworld\" :\n+          k == K\"static_parameter\" ? \"static_parameter\" :\n+          k == K\"symbolic_label\" ? \"label:$(ex.name_val)\" :\n+          k == K\"symbolic_goto\" ? \"goto:$(ex.name_val)\" :\n+          k == K\"SourceLocation\" ? \"SourceLocation:$(JuliaSyntax.filename(ex)):$(join(source_location(ex), ':'))\" :\n+          repr(get(ex, :value, nothing))\n+    id = get(ex, :var_id, nothing)\n+    if isnothing(id)\n+        id = get(ex, :id, nothing)\n+    end\n+    if !isnothing(id)\n+        idstr = subscript_str(id)\n+        str = \"$(str)$idstr\"\n+    end\n+    if k == K\"slot\" || k == K\"BindingId\"\n+        p = provenance(ex)[1]\n+        while p isa SyntaxTree\n+            if kind(p) == K\"Identifier\"\n+                str = \"$(str)/$(p.name_val)\"\n+                break\n+            end\n+            p = provenance(p)[1]\n+        end\n+    end\n+    return str\n+end\n+\n+function _show_syntax_tree(io, ex, indent, show_kinds)\n+    val = get(ex, :value, nothing)\n+    nodestr = !is_leaf(ex) ? \"[$(untokenize(head(ex)))]\" : _value_string(ex)\n+\n+    treestr = rpad(string(indent, nodestr), 40)\n+    if show_kinds && is_leaf(ex)\n+        treestr = treestr*\" :: \"*string(kind(ex))\n+    end\n+\n+    std_attrs = Set([:name_val,:value,:kind,:syntax_flags,:source,:var_id])\n+    attrstr = join([attrsummary(n, getproperty(ex, n))\n+                    for n in attrnames(ex) if n \u2209 std_attrs], \",\")\n+    treestr = string(rpad(treestr, 60), \" \u2502 $attrstr\")\n+\n+    println(io, treestr)\n+    if !is_leaf(ex)\n+        new_indent = indent*\"  \"\n+        for n in children(ex)\n+            _show_syntax_tree(io, n, new_indent, show_kinds)\n+        end\n+    end\n+end\n+\n+function Base.show(io::IO, ::MIME\"text/plain\", ex::SyntaxTree, show_kinds=true)\n+    anames = join(string.(attrnames(syntax_graph(ex))), \",\")\n+    println(io, \"SyntaxTree with attributes $anames\")\n+    _show_syntax_tree(io, ex, \"\", show_kinds)\n+end\n+\n+function _show_syntax_tree_sexpr(io, ex)\n+    if is_leaf(ex)\n+        if is_error(ex)\n+            print(io, \"(\", untokenize(head(ex)), \")\")\n+        else\n+            print(io, _value_string(ex))\n+        end\n+    else\n+        print(io, \"(\", untokenize(head(ex)))\n+        first = true\n+        for n in children(ex)\n+            print(io, ' ')\n+            _show_syntax_tree_sexpr(io, n)\n+            first = false\n+        end\n+        print(io, ')')\n+    end\n+end\n+\n+function Base.show(io::IO, ::MIME\"text/x.sexpression\", node::SyntaxTree)\n+    _show_syntax_tree_sexpr(io, node)\n+end\n+\n+function Base.show(io::IO, node::SyntaxTree)\n+    _show_syntax_tree_sexpr(io, node)\n+end\n+\n+function reparent(ctx, ex::SyntaxTree)\n+    # Ensure `ex` has the same parent graph, in a somewhat loose sense.\n+    # Could relax by copying if necessary?\n+    # In that case, would we copy all the attributes? That would have slightly\n+    # different semantics.\n+    graph = syntax_graph(ctx)\n+    @assert graph.edge_ranges === ex._graph.edge_ranges\n+    SyntaxTree(graph, ex._id)\n+end\n+\n+function ensure_attributes(ex::SyntaxTree; kws...)\n+    reparent(ensure_attributes(syntax_graph(ex); kws...), ex)\n+end\n+\n+syntax_graph(ex::SyntaxTree) = ex._graph\n+\n+function JuliaSyntax.build_tree(::Type{SyntaxTree}, stream::JuliaSyntax.ParseStream; kws...)\n+    SyntaxTree(JuliaSyntax.build_tree(SyntaxNode, stream; kws...))\n+end\n+\n+JuliaSyntax.sourcefile(ex::SyntaxTree) = sourcefile(sourceref(ex))\n+JuliaSyntax.byte_range(ex::SyntaxTree) = byte_range(sourceref(ex))\n+\n+function JuliaSyntax._expr_leaf_val(ex::SyntaxTree, _...)\n+    name = get(ex, :name_val, nothing)\n+    if !isnothing(name)\n+        n = Symbol(name)\n+        if kind(ex) === K\"Symbol\"\n+            return QuoteNode(n)\n+        elseif hasattr(ex, :scope_layer)\n+            Expr(:scope_layer, n, ex.scope_layer)\n+        else\n+            n\n+        end\n+    else\n+        val = get(ex, :value, nothing)\n+        if kind(ex) == K\"Value\" && val isa Expr || val isa LineNumberNode\n+            # Expr AST embedded in a SyntaxTree should be quoted rather than\n+            # becoming part of the output AST.\n+            QuoteNode(val)\n+        else\n+            val\n+        end\n+    end\n+end\n+\n+Base.Expr(ex::SyntaxTree) = JuliaSyntax.to_expr(ex)\n+\n+#--------------------------------------------------\n+function _find_SyntaxTree_macro(ex, line)\n+    @assert !is_leaf(ex)\n+    for c in children(ex)\n+        rng = byte_range(c)\n+        firstline = JuliaSyntax.source_line(sourcefile(c), first(rng))\n+        lastline = JuliaSyntax.source_line(sourcefile(c), last(rng))\n+        if line < firstline || lastline < line\n+            continue\n+        end\n+        # We're in the line range. Either\n+        if firstline == line && kind(c) == K\"macrocall\" && begin\n+                    name = c[1]\n+                    if kind(name) == K\"macro_name\"\n+                        name = name[1]\n+                    end\n+                    if kind(name) == K\".\"\n+                        name = name[2]\n+                        if kind(name) == K\"macro_name\"\n+                            name = name[1]\n+                        end\n+                    end\n+                    @assert kind(name) == K\"Identifier\"\n+                    name.name_val == \"SyntaxTree\"\n+                end\n+            # We find the node we're looking for. NB: Currently assuming a max\n+            # of one @SyntaxTree invocation per line. Though we could relax\n+            # this with more heuristic matching of the Expr-AST...\n+            @assert numchildren(c) == 2\n+            return c[2]\n+        elseif !is_leaf(c)\n+            # Recurse\n+            ex1 = _find_SyntaxTree_macro(c, line)\n+            if !isnothing(ex1)\n+                return ex1\n+            end\n+        end\n+    end\n+    return nothing # Will get here if multiple children are on the same line.\n+end\n+\n+# Translate JuliaLowering hygiene to esc() for use in @SyntaxTree\n+function _scope_layer_1_to_esc!(ex)\n+    if ex isa Expr\n+        if ex.head == :scope_layer\n+            @assert ex.args[2] === 1\n+            return esc(_scope_layer_1_to_esc!(ex.args[1]))\n+        else\n+            map!(_scope_layer_1_to_esc!, ex.args, ex.args)\n+            return ex\n+        end\n+    else\n+        return ex\n+    end\n+end\n+\n+\"\"\"\n+Macro to construct quoted SyntaxTree literals (instead of quoted Expr literals)\n+in normal Julia source code.\n+\n+Example:\n+\n+```julia\n+tree1 = @SyntaxTree :(some_unique_identifier)\n+tree2 = @SyntaxTree quote\n+    x = 1\n+    \\$tree1 = x\n+end\n+```\n+\"\"\"\n+macro SyntaxTree(ex_old)\n+    # The implementation here is hilarious and arguably very janky: we\n+    # 1. Briefly check but throw away the Expr-AST\n+    if !(Meta.isexpr(ex_old, :quote) || ex_old isa QuoteNode)\n+        throw(ArgumentError(\"@SyntaxTree expects a `quote` block or `:`-quoted expression\"))\n+    end\n+    # 2. Re-parse the current source file as SyntaxTree instead\n+    fname = isnothing(__source__.file) ? error(\"No current file\") : String(__source__.file)\n+    if occursin(r\"REPL\\[\\d+\\]\", fname)\n+        # Assume we should look at last history entry in REPL\n+        try\n+            # Wow digging in like this is an awful hack but `@SyntaxTree` is\n+            # already a hack so let's go for it I guess \ud83d\ude06\n+            text = Base.active_repl.mistate.interface.modes[1].hist.history[end]\n+            if !occursin(\"@SyntaxTree\", text)\n+                error(\"Text not found in last REPL history line\")\n+            end\n+        catch\n+            error(\"Text not found in REPL history\")\n+        end\n+    else\n+        text = read(fname, String)\n+    end\n+    full_ex = parseall(SyntaxTree, text)\n+    # 3. Using the current file and line number, dig into the re-parsed tree and\n+    # discover the piece of AST which should be returned.\n+    ex = _find_SyntaxTree_macro(full_ex, __source__.line)\n+    isnothing(ex) && error(\"_find_SyntaxTree_macro failed\")\n+    # 4. Do the first step of JuliaLowering's syntax lowering to get\n+    # syntax interpolations to work\n+    _, ex1 = expand_forms_1(__module__, ex, false, Base.tls_world_age())\n+    @assert kind(ex1) == K\"call\" && ex1[1].value == interpolate_ast\n+    Expr(:call, :interpolate_ast, SyntaxTree, ex1[3][1],\n+         map(e->_scope_layer_1_to_esc!(Expr(e)), ex1[4:end])...)\n+end\n+\n+#-------------------------------------------------------------------------------\n+# Lightweight vector of nodes ids with associated pointer to graph stored separately.\n+mutable struct SyntaxList{GraphType, NodeIdVecType} <: AbstractVector{SyntaxTree}\n+    graph::GraphType\n+    ids::NodeIdVecType\n+end\n+\n+function SyntaxList(graph::SyntaxGraph, ids::AbstractVector{NodeId})\n+    SyntaxList{typeof(graph), typeof(ids)}(graph, ids)\n+end\n+\n+SyntaxList(graph::SyntaxGraph) = SyntaxList(graph, Vector{NodeId}())\n+SyntaxList(ctx) = SyntaxList(syntax_graph(ctx))\n+\n+syntax_graph(lst::SyntaxList) = lst.graph\n+\n+Base.size(v::SyntaxList) = size(v.ids)\n+\n+Base.IndexStyle(::Type{<:SyntaxList}) = IndexLinear()\n+\n+Base.getindex(v::SyntaxList, i::Int) = SyntaxTree(v.graph, v.ids[i])\n+\n+function Base.getindex(v::SyntaxList, r::UnitRange)\n+    SyntaxList(v.graph, view(v.ids, r))\n+end\n+\n+function Base.setindex!(v::SyntaxList, ex::SyntaxTree, i::Int)\n+    check_compatible_graph(v, ex)\n+    v.ids[i] = ex._id\n+end\n+\n+function Base.setindex!(v::SyntaxList, id::NodeId, i::Int)\n+    v.ids[i] = id\n+end\n+\n+function Base.push!(v::SyntaxList, ex::SyntaxTree)\n+    check_compatible_graph(v, ex)\n+    push!(v.ids, ex._id)\n+end\n+\n+function Base.pushfirst!(v::SyntaxList, ex::SyntaxTree)\n+    check_compatible_graph(v, ex)\n+    pushfirst!(v.ids, ex._id)\n+end\n+\n+function Base.similar(v::SyntaxList, size::Tuple=Base.size(v.ids))\n+    SyntaxList(v.graph, zeros(NodeId, size))\n+end\n+\n+function Base.isassigned(v::SyntaxList, i::Integer)\n+    v.ids[i] > 0\n+end\n+\n+function Base.append!(v::SyntaxList, exs)\n+    for e in exs\n+        push!(v, e)\n+    end\n+    v\n+end\n+\n+function Base.append!(v::SyntaxList, exs::SyntaxList)\n+    check_compatible_graph(v, exs)\n+    append!(v.ids, exs.ids)\n+    v\n+end\n+\n+function Base.push!(v::SyntaxList, id::NodeId)\n+    push!(v.ids, id)\n+end\n+\n+function Base.pop!(v::SyntaxList)\n+    SyntaxTree(v.graph, pop!(v.ids))\n+end\n+\n+function Base.resize!(v::SyntaxList, n)\n+    resize!(v.ids, n)\n+    v\n+end\n+\n+function Base.empty!(v::SyntaxList)\n+    empty!(v.ids)\n+    v\n+end\n+\n+function Base.deleteat!(v::SyntaxList, inds)\n+    deleteat!(v.ids, inds)\n+    v\n+end\n+\n+function Base.copy(v::SyntaxList)\n+    SyntaxList(v.graph, copy(v.ids))\n+end\n+\n+function Base.filter(f, exs::SyntaxList)\n+    out = SyntaxList(syntax_graph(exs))\n+    for ex in exs\n+        if f(ex)\n+            push!(out, ex)\n+        end\n+    end\n+    out\n+end\n+\n+# Would like the following to be an overload of Base.map() ... but need\n+# somewhat arcane trickery to ensure that this only tries to collect into a\n+# SyntaxList when `f` yields a SyntaxTree.\n+#\n+# function mapsyntax(f, exs::SyntaxList)\n+#     out = SyntaxList(syntax_graph(exs))\n+#     for ex in exs\n+#         push!(out, f(ex))\n+#     end\n+#     out\n+# end"
    },
    {
      "sha": "a08ddde1fba67b6d7a7ecf79ba3d2ac9b3b0e1e3",
      "filename": "JuliaLowering/src/syntax_macros.jl",
      "status": "added",
      "additions": 377,
      "deletions": 0,
      "changes": 377,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fsyntax_macros.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Fsyntax_macros.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fsyntax_macros.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,377 @@\n+# The following are versions of macros from Base which act as \"standard syntax\n+# extensions\":\n+#\n+# * They emit syntactic forms with special `Kind`s and semantics known to\n+#   lowering\n+# * There is no other Julia surface syntax for these `Kind`s.\n+\n+# In order to implement these here without getting into bootstrapping problems,\n+# we just write them as plain old macro-named functions and add the required\n+# __context__ argument ourselves.\n+#\n+# TODO: @inline, @noinline, @inbounds, @simd, @ccall, @assume_effects\n+#\n+# TODO: Eventually move these to proper `macro` definitions and use\n+# `JuliaLowering.include()` or something. Then we'll be in the fun little world\n+# of bootstrapping but it shouldn't be too painful :)\n+\n+function _apply_nospecialize(ctx, ex)\n+    k = kind(ex)\n+    if k == K\"Identifier\" || k == K\"Placeholder\" || k == K\"tuple\"\n+        setmeta(ex; nospecialize=true)\n+    elseif k == K\"...\" || k == K\"::\" || k == K\"=\"\n+        if k == K\"::\" && numchildren(ex) == 1\n+            ex = @ast ctx ex [K\"::\" \"_\"::K\"Placeholder\" ex[1]]\n+        end\n+        mapchildren(c->_apply_nospecialize(ctx, c), ctx, ex, 1:1)\n+    else\n+        throw(LoweringError(ex, \"Invalid function argument\"))\n+    end\n+end\n+\n+function Base.var\"@nospecialize\"(__context__::MacroContext, ex, exs...)\n+    # TODO support multi-arg version properly\n+    _apply_nospecialize(__context__, ex)\n+end\n+\n+function Base.var\"@atomic\"(__context__::MacroContext, ex)\n+    @chk kind(ex) == K\"Identifier\" || kind(ex) == K\"::\" (ex, \"Expected identifier or declaration\")\n+    @ast __context__ __context__.macrocall [K\"atomic\" ex]\n+end\n+\n+function Base.var\"@label\"(__context__::MacroContext, ex)\n+    @chk kind(ex) == K\"Identifier\"\n+    @ast __context__ ex ex=>K\"symbolic_label\"\n+end\n+\n+function Base.var\"@goto\"(__context__::MacroContext, ex)\n+    @chk kind(ex) == K\"Identifier\"\n+    @ast __context__ ex ex=>K\"symbolic_goto\"\n+end\n+\n+function Base.var\"@locals\"(__context__::MacroContext)\n+    @ast __context__ __context__.macrocall [K\"extension\" \"locals\"::K\"Symbol\"]\n+end\n+\n+function Base.var\"@isdefined\"(__context__::MacroContext, ex)\n+    @ast __context__ __context__.macrocall [K\"isdefined\" ex]\n+end\n+\n+function Base.var\"@generated\"(__context__::MacroContext)\n+    @ast __context__ __context__.macrocall [K\"generated\"]\n+end\n+function Base.var\"@generated\"(__context__::MacroContext, ex)\n+    if kind(ex) != K\"function\"\n+        throw(LoweringError(ex, \"Expected a function argument to `@generated`\"))\n+    end\n+    @ast __context__ __context__.macrocall [K\"function\"\n+        ex[1]\n+        [K\"if\" [K\"generated\"]\n+            ex[2]\n+            [K\"block\"\n+                [K\"meta\" \"generated_only\"::K\"Symbol\"]\n+                [K\"return\"]\n+            ]\n+        ]\n+    ]\n+end\n+\n+function Base.var\"@cfunction\"(__context__::MacroContext, callable, return_type, arg_types)\n+    if kind(arg_types) != K\"tuple\"\n+        throw(MacroExpansionError(arg_types, \"@cfunction argument types must be a literal tuple\"))\n+    end\n+    arg_types_svec = @ast __context__ arg_types [K\"call\"\n+        \"svec\"::K\"core\"\n+        children(arg_types)...\n+    ]\n+    if kind(callable) == K\"$\"\n+        fptr = callable[1]\n+        typ = Base.CFunction\n+    else\n+        # Kinda weird semantics here - without `$`, the callable is a top level\n+        # expression which will be evaluated by `jl_resolve_globals_in_ir`,\n+        # implicitly within the module where the `@cfunction` is expanded into.\n+        fptr = @ast __context__ callable [K\"static_eval\"(\n+                meta=name_hint(\"cfunction function name\"))\n+            callable\n+        ]\n+        typ = Ptr{Cvoid}\n+    end\n+    @ast __context__ __context__.macrocall [K\"cfunction\"\n+        typ::K\"Value\"\n+        fptr\n+        [K\"static_eval\"(meta=name_hint(\"cfunction return type\"))\n+            return_type\n+        ]\n+        [K\"static_eval\"(meta=name_hint(\"cfunction argument type\"))\n+            arg_types_svec\n+        ]\n+        \"ccall\"::K\"Symbol\"\n+    ]\n+end\n+\n+function ccall_macro_parse(ctx, ex, opts)\n+    gc_safe=false\n+    for opt in opts\n+        if kind(opt) != K\"=\" || numchildren(opt) != 2 ||\n+                kind(opt[1]) != K\"Identifier\"\n+            throw(MacroExpansionError(opt, \"Bad option to ccall\"))\n+        else\n+            optname = opt[1].name_val\n+            if optname == \"gc_safe\"\n+                if kind(opt[2]) == K\"Bool\"\n+                    gc_safe = opt[2].value::Bool\n+                else\n+                    throw(MacroExpansionError(opt[2], \"gc_safe must be true or false\"))\n+                end\n+            else\n+                throw(MacroExpansionError(opt[1], \"Unknown option name for ccall\"))\n+            end\n+        end\n+    end\n+\n+    if kind(ex) != K\"::\"\n+        throw(MacroExpansionError(ex, \"Expected a return type annotation `::SomeType`\", position=:end))\n+    end\n+\n+    rettype = ex[2]\n+    call = ex[1]\n+    if kind(call) != K\"call\"\n+        throw(MacroExpansionError(call, \"Expected function call syntax `f()`\"))\n+    end\n+\n+    func = call[1]\n+    varargs = numchildren(call) > 1 && kind(call[end]) == K\"parameters\" ?\n+        children(call[end]) : nothing\n+\n+    # collect args and types\n+    args = SyntaxList(ctx)\n+    types = SyntaxList(ctx)\n+    function pusharg!(arg)\n+        if kind(arg) != K\"::\"\n+            throw(MacroExpansionError(arg, \"argument needs a type annotation\"))\n+        end\n+        push!(args, arg[1])\n+        push!(types, arg[2])\n+    end\n+\n+    for e in call[2:(isnothing(varargs) ? end : end-1)]\n+        kind(e) != K\"parameters\" || throw(MacroExpansionError(call[end], \"Multiple parameter blocks not allowed\"))\n+        pusharg!(e)\n+    end\n+\n+    if !isnothing(varargs)\n+        num_required_args = length(args)\n+        if num_required_args == 0\n+            throw(MacroExpansionError(call[end], \"C ABI prohibits varargs without one required argument\"))\n+        end\n+        for e in varargs\n+            pusharg!(e)\n+        end\n+    else\n+        num_required_args = 0 # Non-vararg call\n+    end\n+\n+    return func, rettype, types, args, gc_safe, num_required_args\n+end\n+\n+function ccall_macro_lower(ctx, ex, convention, func, rettype, types, args, gc_safe, num_required_args)\n+    statements = SyntaxTree[]\n+    kf = kind(func)\n+    if kf == K\"Identifier\"\n+        lowered_func = @ast ctx func func=>K\"Symbol\"\n+    elseif kf == K\".\"\n+        lowered_func = @ast ctx func [K\"tuple\"\n+            func[2]=>K\"Symbol\"\n+            [K\"static_eval\"(meta=name_hint(\"@ccall library name\"))\n+                func[1]\n+            ]\n+        ]\n+    elseif kf == K\"$\"\n+        check = @SyntaxTree quote\n+            func = $(func[1])\n+            if !isa(func, Ptr{Cvoid})\n+                name = :($(func[1]))\n+                throw(ArgumentError(\"interpolated function `$name` was not a `Ptr{Cvoid}`, but $(typeof(func))\"))\n+            end\n+        end\n+        push!(statements, check)\n+        lowered_func = check[1][1]\n+    else\n+        throw(MacroExpansionError(func,\n+            \"Function name must be a symbol like `foo`, a library and function name like `libc.printf` or an interpolated function pointer like `\\$ptr`\"))\n+    end\n+\n+    roots = SyntaxTree[]\n+    cargs = SyntaxTree[]\n+    for (i, (type, arg)) in enumerate(zip(types, args))\n+        argi = @ast ctx arg \"arg$i\"::K\"Identifier\"\n+        # TODO: Does it help to emit ssavar() here for the `argi`?\n+        push!(statements, @SyntaxTree :(local $argi = Base.cconvert($type, $arg)))\n+        push!(roots, argi)\n+        push!(cargs, @SyntaxTree :(Base.unsafe_convert($type, $argi)))\n+    end\n+    effect_flags = UInt16(0)\n+    push!(statements, @ast ctx ex [K\"foreigncall\"\n+        lowered_func\n+        [K\"static_eval\"(meta=name_hint(\"@ccall return type\"))\n+            rettype\n+        ]\n+        [K\"static_eval\"(meta=name_hint(\"@ccall argument type\"))\n+            [K\"call\"\n+                \"svec\"::K\"core\"\n+                types...\n+            ]\n+        ]\n+        num_required_args::K\"Integer\"\n+        QuoteNode((convention, effect_flags, gc_safe))::K\"Value\"\n+        cargs...\n+        roots...\n+    ])\n+\n+    @ast ctx ex [K\"block\"\n+        statements...\n+    ]\n+end\n+\n+function Base.var\"@ccall\"(ctx::MacroContext, ex, opts...)\n+    ccall_macro_lower(ctx, ex, :ccall, ccall_macro_parse(ctx, ex, opts)...)\n+end\n+\n+function Base.GC.var\"@preserve\"(__context__::MacroContext, exs...)\n+    idents = exs[1:end-1]\n+    for e in idents\n+        if kind(e) != K\"Identifier\"\n+            throw(MacroExpansionError(e, \"Preserved variable must be a symbol\"))\n+        end\n+    end\n+    @ast __context__ __context__.macrocall [K\"block\"\n+        [K\"=\"\n+            \"s\"::K\"Identifier\"\n+            [K\"gc_preserve_begin\"\n+                idents...\n+            ]\n+        ]\n+        [K\"=\"\n+            \"r\"::K\"Identifier\"\n+            exs[end]\n+        ]\n+        [K\"gc_preserve_end\" \"s\"::K\"Identifier\"]\n+        \"r\"::K\"Identifier\"\n+    ]\n+end\n+\n+function Base.Experimental.var\"@opaque\"(__context__::MacroContext, ex)\n+    @chk kind(ex) == K\"->\"\n+    @ast __context__ __context__.macrocall [K\"opaque_closure\"\n+        \"nothing\"::K\"core\"\n+        \"nothing\"::K\"core\"\n+        \"nothing\"::K\"core\"\n+        true::K\"Bool\"\n+        ex\n+    ]\n+end\n+\n+function _at_eval_code(ctx, srcref, mod, ex)\n+    @ast ctx srcref [K\"block\"\n+        [K\"local\"\n+            [K\"=\"\n+                \"eval_result\"::K\"Identifier\"\n+                [K\"call\"\n+                    # TODO: Call \"eval\"::K\"core\" here\n+                    JuliaLowering.eval::K\"Value\"\n+                    mod\n+                    [K\"quote\" ex]\n+                    [K\"parameters\"\n+                        [K\"=\"\n+                            \"expr_compat_mode\"::K\"Identifier\"\n+                            ctx.expr_compat_mode::K\"Bool\"\n+                        ]\n+                    ]\n+                ]\n+            ]\n+        ]\n+        (::K\"latestworld_if_toplevel\")\n+        \"eval_result\"::K\"Identifier\"\n+    ]\n+end\n+\n+function Base.var\"@eval\"(__context__::MacroContext, ex)\n+    mod = @ast __context__ __context__.macrocall __context__.scope_layer.mod::K\"Value\"\n+    _at_eval_code(__context__, __context__.macrocall, mod, ex)\n+end\n+\n+function Base.var\"@eval\"(__context__::MacroContext, mod, ex)\n+    _at_eval_code(__context__, __context__.macrocall, mod, ex)\n+end\n+\n+#--------------------------------------------------------------------------------\n+# The following `@islocal` and `@inert` are macros for special syntax known to\n+# lowering which don't exist in Base but arguably should.\n+#\n+# For now we have our own versions\n+function var\"@islocal\"(__context__::MacroContext, ex)\n+    @chk kind(ex) == K\"Identifier\"\n+    @ast __context__ __context__.macrocall [K\"extension\"\n+        \"islocal\"::K\"Symbol\"\n+        ex\n+    ]\n+end\n+\n+\"\"\"\n+A non-interpolating quoted expression.\n+\n+For example,\n+\n+```julia\n+@inert quote\n+    \\$x\n+end\n+```\n+\n+does not take `x` from the surrounding scope - instead it leaves the\n+interpolation `\\$x` intact as part of the expression tree.\n+\n+TODO: What is the correct way for `@inert` to work? ie which of the following\n+should work?\n+\n+```julia\n+@inert quote\n+   body\n+end\n+\n+@inert begin\n+   body\n+end\n+\n+@inert x\n+\n+@inert \\$x\n+```\n+\n+The especially tricky cases involve nested interpolation ...\n+```julia\n+quote\n+    @inert \\$x\n+end\n+\n+@inert quote\n+    quote\n+        \\$x\n+    end\n+end\n+\n+@inert quote\n+    quote\n+        \\$\\$x\n+    end\n+end\n+```\n+\n+etc. Needs careful thought - we should probably just copy what lisp does with\n+quote+quasiquote \ud83d\ude05\n+\"\"\"\n+function var\"@inert\"(__context__::MacroContext, ex)\n+    @chk kind(ex) == K\"quote\"\n+    @ast __context__ __context__.macrocall [K\"inert\" ex]\n+end"
    },
    {
      "sha": "a3807ae24a09ee834a8b45ccec63a4943348469e",
      "filename": "JuliaLowering/src/utils.jl",
      "status": "added",
      "additions": 185,
      "deletions": 0,
      "changes": 185,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Futils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Fsrc%2Futils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Futils.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,185 @@\n+# Error handling\n+\n+TODO(msg::AbstractString) = throw(ErrorException(\"Lowering TODO: $msg\"))\n+TODO(ex::SyntaxTree, msg=\"\") = throw(LoweringError(ex, \"Lowering TODO: $msg\"))\n+\n+# Errors found during lowering will result in LoweringError being thrown to\n+# indicate the syntax causing the error.\n+struct LoweringError <: Exception\n+    ex::SyntaxTree\n+    msg::String\n+end\n+\n+function Base.showerror(io::IO, exc::LoweringError; show_detail=true)\n+    print(io, \"LoweringError:\\n\")\n+    src = sourceref(exc.ex)\n+    highlight(io, src; note=exc.msg)\n+\n+    if show_detail\n+        print(io, \"\\n\\nDetailed provenance:\\n\")\n+        showprov(io, exc.ex, tree=true)\n+    end\n+end\n+\n+#-------------------------------------------------------------------------------\n+function _show_provtree(io::IO, ex::SyntaxTree, indent)\n+    print(io, ex, \"\\n\")\n+    prov = provenance(ex)\n+    for (i, e) in enumerate(prov)\n+        islast = i == length(prov)\n+        printstyled(io, \"$indent$(islast ? \"\u2514\u2500 \" : \"\u251c\u2500 \")\", color=:light_black)\n+        inner_indent = indent * (islast ? \"   \" : \"\u2502  \")\n+        _show_provtree(io, e, inner_indent)\n+    end\n+end\n+\n+function _show_provtree(io::IO, prov, indent)\n+    fn = filename(prov)\n+    line, _ = source_location(prov)\n+    printstyled(io, \"@ $fn:$line\\n\", color=:light_black)\n+end\n+\n+function showprov(io::IO, exs::AbstractVector;\n+                  note=nothing, include_location::Bool=true, highlight_kwargs...)\n+    for (i,ex) in enumerate(Iterators.reverse(exs))\n+        sr = sourceref(ex)\n+        if i > 1\n+            print(io, \"\\n\\n\")\n+        end\n+        k = kind(ex)\n+        ex_note = !isnothing(note) ? note :\n+            i > 1 && k == K\"macrocall\"  ? \"in macro expansion\" :\n+            i > 1 && k == K\"$\"          ? \"interpolated here\"  :\n+            \"in source\"\n+        highlight(io, sr; note=ex_note, highlight_kwargs...)\n+\n+        if include_location\n+            line, _ = source_location(sr)\n+            locstr = \"$(filename(sr)):$line\"\n+            JuliaSyntax._printstyled(io, \"\\n# @ $locstr\", fgcolor=:light_black)\n+        end\n+    end\n+end\n+\n+function showprov(io::IO, ex::SyntaxTree; tree::Bool=false, showprov_kwargs...)\n+    if tree\n+        _show_provtree(io, ex, \"\")\n+    else\n+        showprov(io, flattened_provenance(ex); showprov_kwargs...)\n+    end\n+end\n+\n+function showprov(x; kws...)\n+    showprov(stdout, x; kws...)\n+end\n+\n+function subscript_str(i)\n+     replace(string(i),\n+             \"0\"=>\"\u2080\", \"1\"=>\"\u2081\", \"2\"=>\"\u2082\", \"3\"=>\"\u2083\", \"4\"=>\"\u2084\",\n+             \"5\"=>\"\u2085\", \"6\"=>\"\u2086\", \"7\"=>\"\u2087\", \"8\"=>\"\u2088\", \"9\"=>\"\u2089\")\n+end\n+\n+function _deref_ssa(stmts, ex)\n+    while kind(ex) == K\"SSAValue\"\n+        ex = stmts[ex.var_id]\n+    end\n+    ex\n+end\n+\n+function _find_method_lambda(ex, name)\n+    @assert kind(ex) == K\"code_info\"\n+    # Heuristic search through outer thunk for the method in question.\n+    method_found = false\n+    stmts = children(ex[1])\n+    for e in stmts\n+        if kind(e) == K\"method\" && numchildren(e) >= 2\n+            sig = _deref_ssa(stmts, e[2])\n+            @assert kind(sig) == K\"call\"\n+            arg_types = _deref_ssa(stmts, sig[2])\n+            @assert kind(arg_types) == K\"call\"\n+            self_type = _deref_ssa(stmts, arg_types[2])\n+            if kind(self_type) == K\"globalref\" && occursin(name, self_type.name_val)\n+                return e[3]\n+            end\n+        end\n+    end\n+end\n+\n+function print_ir(io::IO, ex, method_filter=nothing)\n+    @assert kind(ex) == K\"code_info\"\n+    if !isnothing(method_filter)\n+        filtered = _find_method_lambda(ex, method_filter)\n+        if isnothing(filtered)\n+            @warn \"Method not found with method filter $method_filter\"\n+        else\n+            ex = filtered\n+        end\n+    end\n+    _print_ir(io, ex, \"\")\n+end\n+\n+function _print_ir(io::IO, ex, indent)\n+    added_indent = \"    \"\n+    @assert (kind(ex) == K\"lambda\" || kind(ex) == K\"code_info\") && kind(ex[1]) == K\"block\"\n+    if !ex.is_toplevel_thunk && kind(ex) == K\"code_info\"\n+        slots = ex.slots\n+        print(io, indent, \"slots: [\")\n+        for (i,slot) in enumerate(slots)\n+            print(io, \"slot$(subscript_str(i))/$(slot.name)\")\n+            flags = String[]\n+            slot.is_nospecialize   && push!(flags, \"nospecialize\")\n+            !slot.is_read          && push!(flags, \"!read\")\n+            slot.is_single_assign  && push!(flags, \"single_assign\")\n+            slot.is_maybe_undef    && push!(flags, \"maybe_undef\")\n+            slot.is_called         && push!(flags, \"called\")\n+            if !isempty(flags)\n+                print(io, \"($(join(flags, \",\")))\")\n+            end\n+            if i < length(slots)\n+                print(io, \" \")\n+            end\n+        end\n+        println(io, \"]\")\n+    end\n+    stmts = children(ex[1])\n+    for (i, e) in enumerate(stmts)\n+        lno = rpad(i, 3)\n+        if kind(e) == K\"method\" && numchildren(e) == 3\n+            print(io, indent, lno, \" --- method \", string(e[1]), \" \", string(e[2]))\n+            if kind(e[3]) == K\"lambda\" || kind(e[3]) == K\"code_info\"\n+                println(io)\n+                _print_ir(io, e[3], indent*added_indent)\n+            else\n+                println(io, \" \", string(e[3]))\n+            end\n+        elseif kind(e) == K\"opaque_closure_method\"\n+            @assert numchildren(e) == 5\n+            print(io, indent, lno, \" --- opaque_closure_method \")\n+            for i=1:4\n+                print(io, \" \", e[i])\n+            end\n+            println(io)\n+            _print_ir(io, e[5], indent*added_indent)\n+        elseif kind(e) == K\"code_info\"\n+            println(io, indent, lno, \" --- \", e.is_toplevel_thunk ? \"thunk\" : \"code_info\")\n+            _print_ir(io, e, indent*added_indent)\n+        else\n+            code = string(e)\n+            println(io, indent, lno, \" \", code)\n+        end\n+    end\n+end\n+\n+# Wrap a function body in Base.Compiler.@zone for profiling\n+if isdefined(Base.Compiler, Symbol(\"@zone\"))\n+    macro fzone(str, f)\n+        @assert f isa Expr && f.head === :function && length(f.args) === 2 && str isa String\n+        esc(Expr(:function, f.args[1],\n+                 # Use source of our caller, not of this macro.\n+                 Expr(:macrocall, :(Base.Compiler.var\"@zone\"), __source__, str, f.args[2])))\n+    end\n+else\n+    macro fzone(str, f)\n+        esc(f)\n+    end\n+end"
    },
    {
      "sha": "bc3e43af0b089bdd6e39649d831c2b2d2279a3c6",
      "filename": "JuliaLowering/test/arrays.jl",
      "status": "added",
      "additions": 148,
      "deletions": 0,
      "changes": 148,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Farrays.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Farrays.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Farrays.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,148 @@\n+using Test, JuliaLowering\n+\n+@testset \"Array syntax\" begin\n+\n+test_mod = Module()\n+\n+# Test that two array element types are equal and that they are also equal\n+# elementwise\n+function \u2245(a, b)\n+    eltype(a) == eltype(b) && a == b\n+end\n+\n+# vect\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+[1,2,3]\n+\"\"\") \u2245 [1,2,3]\n+\n+# hcat\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+[1 2 3]\n+\"\"\") \u2245 [1 2 3]\n+\n+# typed_hcat\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+Int[1.0 2.0 3.0]\n+\"\"\") \u2245 [1 2 3]\n+\n+# splat with vect/hcat/typed_hcat\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let xs = [1,2,3]\n+    [0, xs...]\n+end\n+\"\"\") \u2245 [0,1,2,3]\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let xs = [1,2,3]\n+    [0 xs...]\n+end\n+\"\"\") \u2245 [0 1 2 3]\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let xs = [1,2,3]\n+    Int[0 xs...]\n+end\n+\"\"\") \u2245 Int[0 1 2 3]\n+\n+# vcat\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+[1;2;3]\n+\"\"\") \u2245 [1; 2; 3]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    xs = (1,2)\n+    [xs...; xs...]\n+end\n+\"\"\") \u2245 [1,2,1,2]\n+\n+# hvcat\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+[1 2 3; 4 5 6]\n+\"\"\") \u2245 [1 2 3;\n+        4 5 6]\n+\n+# hvcat_rows\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    xs = (1,2)\n+    [xs... 3; 4 xs...]\n+end\n+\"\"\") \u2245 [1 2 3;\n+        4 1 2]\n+\n+# typed_vcat\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+Int[1.0; 2.0; 3.0]\n+\"\"\") \u2245 [1; 2; 3]\n+\n+# typed_hvcat\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+Int[1.0 2.0 3.0; 4.0 5.0 6.0]\n+\"\"\") \u2245 [1 2 3;\n+        4 5 6]\n+\n+# typed_hvcat_rows\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    xs = (1.0,2.0)\n+    Int[xs... 3; 4 xs...]\n+end\n+\"\"\") \u2245 [1 2 3;\n+        4 1 2]\n+\n+# ncat with a single dimension\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+[1 ;;; 2 ;;; 3]\n+\"\"\") \u2245 [1 ;;; 2 ;;; 3]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+Int[1.0 ;;; 2.0 ;;; 3.0]\n+\"\"\") \u2245 [1 ;;; 2 ;;; 3]\n+\n+# Lowering of ref to setindex\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    as = [0,0,0,0]\n+    as[begin] = 1\n+    as[2] = 2\n+    as[end] = 4\n+    as\n+end\n+\"\"\") == [1, 2, 0, 4]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    as = zeros(Int, 2,3)\n+    as[begin, end] = 1\n+    as[end, begin] = 2\n+    js = (2,)\n+    as[js..., end] = 3\n+    as\n+end\n+\"\"\") == [0 0 1;\n+         2 0 3]\n+\n+# getindex\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = [1 2;\n+         3 4]\n+    (x[end,begin], x[begin,end])\n+end\n+\"\"\") == (3, 2)\n+\n+# getindex with splats\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = [1 2;\n+         3 4\n+         ;;;\n+         5 6;\n+         7 8]\n+    inds = (2,1)\n+    ind1 = (1,)\n+    (x[inds..., begin], x[inds..., end], x[1, inds...],\n+     x[ind1..., ind1..., end])\n+end\n+\"\"\") == (3, 7, 2, 5)\n+\n+end # @testset \"Array syntax\" begin"
    },
    {
      "sha": "4595603e4b79de1c938bc4d14756b6ad5152d225",
      "filename": "JuliaLowering/test/arrays_ir.jl",
      "status": "added",
      "additions": 498,
      "deletions": 0,
      "changes": 498,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Farrays_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Farrays_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Farrays_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,498 @@\n+########################################\n+# vect syntax\n+[10, 20, 30]\n+#---------------------\n+1   (call top.vect 10 20 30)\n+2   (return %\u2081)\n+\n+########################################\n+# vect with splat\n+[x, xs...]\n+#---------------------\n+1   TestMod.x\n+2   (call core.tuple %\u2081)\n+3   TestMod.xs\n+4   (call core._apply_iterate top.iterate top.vect %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# vect with splats\n+[x, xs..., y, ys...]\n+#---------------------\n+1   TestMod.x\n+2   (call core.tuple %\u2081)\n+3   TestMod.xs\n+4   TestMod.y\n+5   (call core.tuple %\u2084)\n+6   TestMod.ys\n+7   (call core._apply_iterate top.iterate top.vect %\u2082 %\u2083 %\u2085 %\u2086)\n+8   (return %\u2087)\n+\n+########################################\n+# Error: vect syntax with parameters\n+[10, 20; 30]\n+#---------------------\n+LoweringError:\n+[10, 20; 30]\n+#      \u2514\u2500\u2500\u2518 \u2500\u2500 unexpected semicolon in array expression\n+\n+########################################\n+# Error: vect syntax with embedded assignments\n+[a=20, 30]\n+#---------------------\n+LoweringError:\n+[a=20, 30]\n+#\u2514\u2500\u2500\u2518 \u2500\u2500 misplaced assignment statement in `[ ... ]`\n+\n+########################################\n+# hcat syntax\n+[10 20 30]\n+#---------------------\n+1   (call top.hcat 10 20 30)\n+2   (return %\u2081)\n+\n+########################################\n+# hcat with splat\n+[x xs...]\n+#---------------------\n+1   TestMod.x\n+2   (call core.tuple %\u2081)\n+3   TestMod.xs\n+4   (call core._apply_iterate top.iterate top.hcat %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# typed hcat syntax\n+T[10 20 30]\n+#---------------------\n+1   TestMod.T\n+2   (call top.typed_hcat %\u2081 10 20 30)\n+3   (return %\u2082)\n+\n+########################################\n+# typed hcat syntax with splat\n+T[x xs...]\n+#---------------------\n+1   TestMod.T\n+2   TestMod.x\n+3   (call core.tuple %\u2081 %\u2082)\n+4   TestMod.xs\n+5   (call core._apply_iterate top.iterate top.typed_hcat %\u2083 %\u2084)\n+6   (return %\u2085)\n+\n+########################################\n+# Error: hcat syntax with embedded assignments\n+[10 20 a=40]\n+#---------------------\n+LoweringError:\n+[10 20 a=40]\n+#     \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 misplaced assignment statement in `[ ... ]`\n+\n+########################################\n+# vcat syntax\n+[10; 20; 30]\n+#---------------------\n+1   (call top.vcat 10 20 30)\n+2   (return %\u2081)\n+\n+########################################\n+# vcat with splats\n+[a...; 20; 30]\n+#---------------------\n+1   TestMod.a\n+2   (call core.tuple 20 30)\n+3   (call core._apply_iterate top.iterate top.vcat %\u2081 %\u2082)\n+4   (return %\u2083)\n+\n+########################################\n+# hvcat syntax\n+[10; 20 30; 40 e f]\n+#---------------------\n+1   (call core.tuple 1 2 3)\n+2   TestMod.e\n+3   TestMod.f\n+4   (call top.hvcat %\u2081 10 20 30 40 %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# hvcat with splats nested within rows\n+[10; 20 a...]\n+#---------------------\n+1   (call core.tuple 10)\n+2   (call core.tuple 20)\n+3   TestMod.a\n+4   (call core._apply_iterate top.iterate core.tuple %\u2082 %\u2083)\n+5   (call top.hvcat_rows %\u2081 %\u2084)\n+6   (return %\u2085)\n+\n+########################################\n+# Error: vcat syntax with assignments\n+[a=20; 30]\n+#---------------------\n+LoweringError:\n+[a=20; 30]\n+#\u2514\u2500\u2500\u2518 \u2500\u2500 misplaced assignment statement in `[ ... ]`\n+\n+########################################\n+# typed_vcat syntax\n+T[10; 20; 30]\n+#---------------------\n+1   TestMod.T\n+2   (call top.typed_vcat %\u2081 10 20 30)\n+3   (return %\u2082)\n+\n+########################################\n+# typed_hvcat syntax\n+T[10; 20 30; 40 50 60]\n+#---------------------\n+1   TestMod.T\n+2   (call core.tuple 1 2 3)\n+3   (call top.typed_hvcat %\u2081 %\u2082 10 20 30 40 50 60)\n+4   (return %\u2083)\n+\n+########################################\n+# typed_hvcat with splats nested within rows\n+T[10; 20 a...]\n+#---------------------\n+1   TestMod.T\n+2   (call core.tuple 10)\n+3   (call core.tuple 20)\n+4   TestMod.a\n+5   (call core._apply_iterate top.iterate core.tuple %\u2083 %\u2084)\n+6   (call top.typed_hvcat_rows %\u2081 %\u2082 %\u2085)\n+7   (return %\u2086)\n+\n+########################################\n+# ncat with a single dimension\n+[10 ;;; 20 ;;; 30]\n+#---------------------\n+1   (call top.hvncat 3 10 20 30)\n+2   (return %\u2081)\n+\n+########################################\n+# typed_ncat with a single dimension\n+T[10 ;;; 20 ;;; 30]\n+#---------------------\n+1   TestMod.T\n+2   (call top.typed_hvncat %\u2081 3 10 20 30)\n+3   (return %\u2082)\n+\n+########################################\n+# ncat with balanced column major element layout\n+[10 ; 20 ; 30 ;;; 40 ; 50 ; 60]\n+#---------------------\n+1   (call core.tuple 3 1 2)\n+2   (call top.hvncat %\u2081 false 10 20 30 40 50 60)\n+3   (return %\u2082)\n+\n+########################################\n+# typed multidimensional ncat\n+T[10 ; 20 ; 30 ;;; 40 ; 50 ; 60]\n+#---------------------\n+1   TestMod.T\n+2   (call core.tuple 3 1 2)\n+3   (call top.typed_hvncat %\u2081 %\u2082 false 10 20 30 40 50 60)\n+4   (return %\u2083)\n+\n+########################################\n+# ncat with balanced row major element layout\n+[10 20 30 ; 40 50 60 ;;;]\n+#---------------------\n+1   (call core.tuple 2 3 1)\n+2   (call top.hvncat %\u2081 true 10 20 30 40 50 60)\n+3   (return %\u2082)\n+\n+########################################\n+# ncat of 3D array with balanced layout\n+[10 ; 20 ;; 30 ; 40 ;;; 50 ; 60 ;; 70 ; 80]\n+#---------------------\n+1   (call core.tuple 2 2 2)\n+2   (call top.hvncat %\u2081 false 10 20 30 40 50 60 70 80)\n+3   (return %\u2082)\n+\n+########################################\n+# ncat with unbalanced column major layout\n+[10 ; 20 ;; 30 ;;; 40 ;;;;]\n+#---------------------\n+1   (call core.tuple 2 1 1)\n+2   (call core.tuple 3 1)\n+3   (call core.tuple 4)\n+4   (call core.tuple 4)\n+5   (call core.tuple %\u2081 %\u2082 %\u2083 %\u2084)\n+6   (call top.hvncat %\u2085 false 10 20 30 40)\n+7   (return %\u2086)\n+\n+########################################\n+# ncat with unbalanced row major layout\n+[10 20 ; 30 40 ; 50 60 ;;; 70 ;;; 80 ;;;;]\n+#---------------------\n+1   (call core.tuple 2 2 2 1 1)\n+2   (call core.tuple 6 1 1)\n+3   (call core.tuple 8)\n+4   (call core.tuple 8)\n+5   (call core.tuple %\u2081 %\u2082 %\u2083 %\u2084)\n+6   (call top.hvncat %\u2085 true 10 20 30 40 50 60 70 80)\n+7   (return %\u2086)\n+\n+########################################\n+# Splatting with 1D ncat\n+[xs ;;; ys... ;;; zs]\n+#---------------------\n+1   TestMod.xs\n+2   (call core.tuple 3 %\u2081)\n+3   TestMod.ys\n+4   TestMod.zs\n+5   (call core.tuple %\u2084)\n+6   (call core._apply_iterate top.iterate top.hvncat %\u2082 %\u2083 %\u2085)\n+7   (return %\u2086)\n+\n+########################################\n+# Error: splatting with multi-dimensional ncat\n+[xs ; ys ;;; zs...]\n+#---------------------\n+LoweringError:\n+[xs ; ys ;;; zs...]\n+#            \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 Splatting ... in an `ncat` with multiple dimensions is not supported\n+\n+########################################\n+# Error: bad nrow nesting\n+@ast_ [K\"ncat\"(syntax_flags=set_numeric_flags(3))\n+    [K\"nrow\"(syntax_flags=set_numeric_flags(1))\n+        [K\"nrow\"(syntax_flags=set_numeric_flags(1))\n+            1::K\"Integer\"\n+        ]\n+    ]\n+]\n+#---------------------\n+LoweringError:\n+#= line 1 =# - Badly nested rows in `ncat`\n+\n+########################################\n+# Error: bad nrow nesting\n+@ast_ [K\"ncat\"(syntax_flags=set_numeric_flags(3))\n+    [K\"nrow\"(syntax_flags=set_numeric_flags(2))\n+        [K\"row\"\n+            1::K\"Integer\"\n+        ]\n+    ]\n+]\n+#---------------------\n+LoweringError:\n+#= line 1 =# - 2D `nrow` cannot be mixed with `row` in `ncat`\n+\n+########################################\n+# Error: bad nrow nesting\n+@ast_ [K\"ncat\"(syntax_flags=set_numeric_flags(3))\n+    [K\"row\"\n+        [K\"row\"\n+            1::K\"Integer\"\n+        ]\n+    ]\n+]\n+#---------------------\n+LoweringError:\n+#= line 1 =# - Badly nested rows in `ncat`\n+\n+########################################\n+# Simple getindex\n+a[i]\n+#---------------------\n+1   TestMod.a\n+2   TestMod.i\n+3   (call top.getindex %\u2081 %\u2082)\n+4   (return %\u2083)\n+\n+########################################\n+# simple 1D getindex with begin\n+a[begin]\n+#---------------------\n+1   TestMod.a\n+2   (call top.firstindex %\u2081)\n+3   (call top.getindex %\u2081 %\u2082)\n+4   (return %\u2083)\n+\n+########################################\n+# simple 1D getindex with end\n+a[end]\n+#---------------------\n+1   TestMod.a\n+2   (call top.lastindex %\u2081)\n+3   (call top.getindex %\u2081 %\u2082)\n+4   (return %\u2083)\n+\n+########################################\n+# multidimensional getindex with begin\n+a[i, begin]\n+#---------------------\n+1   TestMod.a\n+2   TestMod.i\n+3   (call top.firstindex %\u2081 2)\n+4   (call top.getindex %\u2081 %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# multidimensional getindex with end\n+a[i, end]\n+#---------------------\n+1   TestMod.a\n+2   TestMod.i\n+3   (call top.lastindex %\u2081 2)\n+4   (call top.getindex %\u2081 %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# multidimensional getindex with begin/end and splats\n+a[is..., end, js..., begin]\n+#---------------------\n+1   TestMod.a\n+2   TestMod.is\n+3   (call top.length %\u2082)\n+4   (call top.+ 1 %\u2083)\n+5   (call top.lastindex %\u2081 %\u2084)\n+6   TestMod.js\n+7   (call top.length %\u2082)\n+8   (call top.length %\u2086)\n+9   (call top.+ 2 %\u2087 %\u2088)\n+10  (call top.firstindex %\u2081 %\u2089)\n+11  (call core.tuple %\u2081)\n+12  (call core.tuple %\u2085)\n+13  (call core.tuple %\u2081\u2080)\n+14  (call core._apply_iterate top.iterate top.getindex %\u2081\u2081 %\u2082 %\u2081\u2082 %\u2086 %\u2081\u2083)\n+15  (return %\u2081\u2084)\n+\n+########################################\n+# getindex with nontrivial array expression and begin/end\n+f()[end]\n+#---------------------\n+1   TestMod.f\n+2   (call %\u2081)\n+3   (call top.lastindex %\u2082)\n+4   (call top.getindex %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# nested refs with getindex and begin/end\n+b[a[begin, end], begin, end]\n+#---------------------\n+1   TestMod.b\n+2   TestMod.a\n+3   (call top.firstindex %\u2082 1)\n+4   (call top.lastindex %\u2082 2)\n+5   (call top.getindex %\u2082 %\u2083 %\u2084)\n+6   (call top.firstindex %\u2081 2)\n+7   (call top.lastindex %\u2081 3)\n+8   (call top.getindex %\u2081 %\u2085 %\u2086 %\u2087)\n+9   (return %\u2088)\n+\n+########################################\n+# Error: parameters in array ref\n+a[i, j; w=1]\n+#---------------------\n+LoweringError:\n+a[i, j; w=1]\n+#     \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 unexpected semicolon in array expression\n+\n+########################################\n+# simple setindex!\n+a[i] = x\n+#---------------------\n+1   TestMod.x\n+2   TestMod.a\n+3   TestMod.i\n+4   (call top.setindex! %\u2082 %\u2081 %\u2083)\n+5   (return %\u2081)\n+\n+########################################\n+# simple setindex! with begin\n+a[begin] = x\n+#---------------------\n+1   TestMod.a\n+2   TestMod.x\n+3   (call top.firstindex %\u2081)\n+4   (call top.setindex! %\u2081 %\u2082 %\u2083)\n+5   (return %\u2082)\n+\n+########################################\n+# simple setindex! with end\n+a[end] = x\n+#---------------------\n+1   TestMod.a\n+2   TestMod.x\n+3   (call top.lastindex %\u2081)\n+4   (call top.setindex! %\u2081 %\u2082 %\u2083)\n+5   (return %\u2082)\n+\n+########################################\n+# multidimensional setindex! with begin\n+a[i, begin] = x\n+#---------------------\n+1   TestMod.a\n+2   TestMod.x\n+3   TestMod.i\n+4   (call top.firstindex %\u2081 2)\n+5   (call top.setindex! %\u2081 %\u2082 %\u2083 %\u2084)\n+6   (return %\u2082)\n+\n+########################################\n+# multidimensional setindex! with end\n+a[i, end] = x\n+#---------------------\n+1   TestMod.a\n+2   TestMod.x\n+3   TestMod.i\n+4   (call top.lastindex %\u2081 2)\n+5   (call top.setindex! %\u2081 %\u2082 %\u2083 %\u2084)\n+6   (return %\u2082)\n+\n+########################################\n+# multidimensional setindex! with begin/end and splats\n+a[is..., end, js..., begin] = x\n+#---------------------\n+1   TestMod.a\n+2   TestMod.is\n+3   (call top.length %\u2082)\n+4   (call top.+ 1 %\u2083)\n+5   (call top.lastindex %\u2081 %\u2084)\n+6   TestMod.js\n+7   (call top.length %\u2082)\n+8   (call top.length %\u2086)\n+9   (call top.+ 2 %\u2087 %\u2088)\n+10  (call top.firstindex %\u2081 %\u2089)\n+11  TestMod.x\n+12  (call core.tuple %\u2081 %\u2081\u2081)\n+13  (call core.tuple %\u2085)\n+14  (call core.tuple %\u2081\u2080)\n+15  (call core._apply_iterate top.iterate top.setindex! %\u2081\u2082 %\u2082 %\u2081\u2083 %\u2086 %\u2081\u2084)\n+16  (return %\u2081\u2081)\n+\n+########################################\n+# setindex! with nontrivial array expression and begin/end\n+f()[end] = x\n+#---------------------\n+1   TestMod.f\n+2   (call %\u2081)\n+3   TestMod.x\n+4   (call top.lastindex %\u2082)\n+5   (call top.setindex! %\u2082 %\u2083 %\u2084)\n+6   (return %\u2083)\n+\n+########################################\n+# nested refs\n+b[a[begin]] = x\n+#---------------------\n+1   TestMod.b\n+2   TestMod.x\n+3   TestMod.a\n+4   (call top.firstindex %\u2083)\n+5   (call top.getindex %\u2083 %\u2084)\n+6   (call top.setindex! %\u2081 %\u2082 %\u2085)\n+7   (return %\u2082)\n+\n+########################################\n+# empty ref and setindex!\n+a[] = rhs\n+#---------------------\n+1   TestMod.rhs\n+2   TestMod.a\n+3   (call top.setindex! %\u2082 %\u2081)\n+4   (return %\u2081)"
    },
    {
      "sha": "d15706c2f8d7040c66818ad5e21fd908c09544ec",
      "filename": "JuliaLowering/test/assignments.jl",
      "status": "added",
      "additions": 98,
      "deletions": 0,
      "changes": 98,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fassignments.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fassignments.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fassignments.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,98 @@\n+@testset \"assignments\" begin\n+\n+test_mod = Module()\n+\n+Base.include_string(test_mod,\n+\"\"\"\n+mutable struct X\n+    a\n+    b\n+end\n+\"\"\")\n+\n+# TODO: Desugaring of assignment done, but needs `where` lowering\n+JuliaLowering.include_string(test_mod, \"\"\"\n+MyVector{T} = Array{1,T}\n+\"\"\")\n+@test test_mod.MyVector{Int} == Array{1,Int}\n+\n+# Chained assignment\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = b = 42\n+end\n+\"\"\") == 42\n+\n+# Assignment in value but not tail position\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = begin\n+        y = 42\n+    end\n+    x\n+end\n+\"\"\") == 42\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = []\n+    a = b = (push!(x, 1); 42)\n+    (a,b,x)\n+end\n+\"\"\") == (42,42,[1])\n+\n+# setproperty!\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = X(1,2)\n+    x.a = 10\n+    (x.a, x.b)\n+end\n+\"\"\") == (10,2)\n+\n+# Declarations\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x::Int = 1\n+    x = 10.0\n+    x\n+end\n+\"\"\") === 10\n+\n+# Updating assignments\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x = \"hi\"\n+    x *= \" ho\"\n+    x\n+end\n+\"\"\") == \"hi ho\"\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x = [1,3]\n+    x .-= [0,1]\n+    x\n+end\n+\"\"\") == [1,2]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x = [1 2; 3 4]\n+    x[begin, 1:end] .-= 1\n+    x\n+end\n+\"\"\") == [0 1 ; 3 4]\n+\n+# Test that side effects of computing indices in left hand side only occur\n+# once.\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = [1, 2]\n+    n_calls = 0\n+    the_index() = (n_calls = n_calls + 1; 1)\n+    x[the_index()] += 1\n+    x[the_index()]::Int += 1\n+    x[the_index():end] .+= 1\n+    n_calls\n+end\n+\"\"\") == 3\n+\n+end"
    },
    {
      "sha": "2b002fbcef61e82e94df3fd3bc2a0825fce0cb88",
      "filename": "JuliaLowering/test/assignments_ir.jl",
      "status": "added",
      "additions": 361,
      "deletions": 0,
      "changes": 361,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fassignments_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fassignments_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fassignments_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,361 @@\n+########################################\n+# chain of assignments\n+let\n+    a = b = c = 1\n+end\n+#---------------------\n+1   1\n+2   (= slot\u2081/a %\u2081)\n+3   (= slot\u2082/b %\u2081)\n+4   (= slot\u2083/c %\u2081)\n+5   (return %\u2081)\n+\n+########################################\n+# chain of assignments with nontrivial rhs\n+let\n+    a = b = c = f()\n+end\n+#---------------------\n+1   TestMod.f\n+2   (call %\u2081)\n+3   (= slot\u2081/a %\u2082)\n+4   (= slot\u2082/b %\u2082)\n+5   (= slot\u2083/c %\u2082)\n+6   (return %\u2082)\n+\n+########################################\n+# Assignment in value but not tail position\n+let\n+    x = begin\n+        y = 42\n+    end\n+    x\n+end\n+#---------------------\n+1   42\n+2   (= slot\u2082/y %\u2081)\n+3   (= slot\u2081/x %\u2081)\n+4   slot\u2081/x\n+5   (return %\u2084)\n+\n+########################################\n+# short form function def, not chain of assignments\n+begin\n+    local a\n+    a = b() = c = d\n+end\n+#---------------------\n+1   (method TestMod.b)\n+2   latestworld\n+3   TestMod.b\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::3:9\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/c(!read)]\n+    1   TestMod.d\n+    2   (= slot\u2082/c %\u2081)\n+    3   (return %\u2081)\n+10  latestworld\n+11  TestMod.b\n+12  (= slot\u2081/a %\u2081\u2081)\n+13  (return %\u2081\u2081)\n+\n+########################################\n+# a.b = ... => setproperty! assignment\n+let\n+    a.b = c\n+end\n+#---------------------\n+1   TestMod.a\n+2   TestMod.c\n+3   (call top.setproperty! %\u2081 :b %\u2082)\n+4   TestMod.c\n+5   (return %\u2084)\n+\n+########################################\n+# a.b.c = f() => setproperty! assignment, complex case\n+let\n+    a.b.c = f()\n+end\n+#---------------------\n+1   TestMod.a\n+2   (call top.getproperty %\u2081 :b)\n+3   TestMod.f\n+4   (call %\u2083)\n+5   (call top.setproperty! %\u2082 :c %\u2084)\n+6   (return %\u2084)\n+\n+########################################\n+# declarations of typed locals\n+let\n+    x::T = f()\n+    x\n+end\n+#---------------------\n+1   (newvar slot\u2081/x)\n+2   TestMod.f\n+3   (call %\u2082)\n+4   TestMod.T\n+5   (= slot\u2082/tmp %\u2083)\n+6   slot\u2082/tmp\n+7   (call core.isa %\u2086 %\u2084)\n+8   (gotoifnot %\u2087 label\u2081\u2080)\n+9   (goto label\u2081\u2083)\n+10  slot\u2082/tmp\n+11  (call top.convert %\u2084 %\u2081\u2080)\n+12  (= slot\u2082/tmp (call core.typeassert %\u2081\u2081 %\u2084))\n+13  slot\u2082/tmp\n+14  (= slot\u2081/x %\u2081\u2083)\n+15  slot\u2081/x\n+16  (return %\u2081\u2085)\n+\n+########################################\n+# \"complex lhs\" of `::T` => type-assert, not decl\n+let\n+    a.b::T = f()\n+    x\n+end\n+#---------------------\n+1   TestMod.a\n+2   (call top.getproperty %\u2081 :b)\n+3   TestMod.T\n+4   (call core.typeassert %\u2082 %\u2083)\n+5   TestMod.f\n+6   (call %\u2085)\n+7   TestMod.a\n+8   (call top.setproperty! %\u2087 :b %\u2086)\n+9   TestMod.x\n+10  (return %\u2089)\n+\n+########################################\n+# UnionAll expansion at global scope results in const decl\n+X{T} = Y{T,T}\n+#---------------------\n+1   (call core.TypeVar :T)\n+2   (= slot\u2081/T %\u2081)\n+3   slot\u2081/T\n+4   TestMod.Y\n+5   slot\u2081/T\n+6   slot\u2081/T\n+7   (call core.apply_type %\u2084 %\u2085 %\u2086)\n+8   (call core.UnionAll %\u2083 %\u2087)\n+9   (call core.declare_const TestMod :X %\u2088)\n+10  latestworld\n+11  (return %\u2088)\n+\n+########################################\n+# UnionAll expansion in local scope\n+let\n+    X{T} = Y{T,T}\n+end\n+#---------------------\n+1   (call core.TypeVar :T)\n+2   (= slot\u2082/T %\u2081)\n+3   slot\u2082/T\n+4   TestMod.Y\n+5   slot\u2082/T\n+6   slot\u2082/T\n+7   (call core.apply_type %\u2084 %\u2085 %\u2086)\n+8   (call core.UnionAll %\u2083 %\u2087)\n+9   (= slot\u2081/X %\u2088)\n+10  (return %\u2088)\n+\n+########################################\n+# Error: Invalid lhs in `=`\n+a.(b) = rhs\n+#---------------------\n+LoweringError:\n+a.(b) = rhs\n+\u2514\u2500\u2500\u2500\u2518 \u2500\u2500 invalid dot call syntax on left hand side of assignment\n+\n+########################################\n+# Error: Invalid lhs in `=`\n+T[x y] = rhs\n+#---------------------\n+LoweringError:\n+T[x y] = rhs\n+\u2514\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 invalid spacing in left side of indexed assignment\n+\n+########################################\n+# Error: Invalid lhs in `=`\n+T[x; y] = rhs\n+#---------------------\n+LoweringError:\n+T[x; y] = rhs\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 unexpected `;` in left side of indexed assignment\n+\n+########################################\n+# Error: Invalid lhs in `=`\n+T[x ;;; y] = rhs\n+#---------------------\n+LoweringError:\n+T[x ;;; y] = rhs\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 unexpected `;` in left side of indexed assignment\n+\n+########################################\n+# Error: Invalid lhs in `=`\n+[x, y] = rhs\n+#---------------------\n+LoweringError:\n+[x, y] = rhs\n+\u2514\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 use `(a, b) = ...` to assign multiple values\n+\n+########################################\n+# Error: Invalid lhs in `=`\n+[x y] = rhs\n+#---------------------\n+LoweringError:\n+[x y] = rhs\n+\u2514\u2500\u2500\u2500\u2518 \u2500\u2500 use `(a, b) = ...` to assign multiple values\n+\n+########################################\n+# Error: Invalid lhs in `=`\n+[x; y] = rhs\n+#---------------------\n+LoweringError:\n+[x; y] = rhs\n+\u2514\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 use `(a, b) = ...` to assign multiple values\n+\n+########################################\n+# Error: Invalid lhs in `=`\n+[x ;;; y] = rhs\n+#---------------------\n+LoweringError:\n+[x ;;; y] = rhs\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 use `(a, b) = ...` to assign multiple values\n+\n+########################################\n+# Error: Invalid lhs in `=`\n+1 = rhs\n+#---------------------\n+LoweringError:\n+1 = rhs\n+\u2559 \u2500\u2500 invalid assignment location\n+\n+########################################\n+# Basic updating assignment\n+begin\n+    local x\n+    x += y\n+end\n+#---------------------\n+1   TestMod.+\n+2   slot\u2081/x\n+3   TestMod.y\n+4   (call %\u2081 %\u2082 %\u2083)\n+5   (= slot\u2081/x %\u2084)\n+6   (return %\u2084)\n+\n+########################################\n+# Broadcasted updating assignment\n+begin\n+    local x\n+    x .+= y\n+end\n+#---------------------\n+1   (newvar slot\u2081/x)\n+2   slot\u2081/x\n+3   TestMod.+\n+4   TestMod.y\n+5   (call top.broadcasted %\u2083 %\u2082 %\u2084)\n+6   (call top.materialize! %\u2082 %\u2085)\n+7   (return %\u2086)\n+\n+########################################\n+# Broadcasted updating assignment with general left hand side permitted\n+f() .+= y\n+#---------------------\n+1   TestMod.f\n+2   (call %\u2081)\n+3   TestMod.+\n+4   TestMod.y\n+5   (call top.broadcasted %\u2083 %\u2082 %\u2084)\n+6   (call top.materialize! %\u2082 %\u2085)\n+7   (return %\u2086)\n+\n+########################################\n+# Updating assignment with basic ref as left hand side\n+x[i] += y\n+#---------------------\n+1   TestMod.+\n+2   TestMod.x\n+3   TestMod.i\n+4   (call top.getindex %\u2082 %\u2083)\n+5   TestMod.y\n+6   (call %\u2081 %\u2084 %\u2085)\n+7   TestMod.x\n+8   TestMod.i\n+9   (call top.setindex! %\u2087 %\u2086 %\u2088)\n+10  (return %\u2086)\n+\n+########################################\n+# Updating assignment with complex ref as left hand side\n+g()[f(), end] += y\n+#---------------------\n+1   TestMod.g\n+2   (call %\u2081)\n+3   TestMod.f\n+4   (call %\u2083)\n+5   (call top.lastindex %\u2082 2)\n+6   TestMod.+\n+7   (call top.getindex %\u2082 %\u2084 %\u2085)\n+8   TestMod.y\n+9   (call %\u2086 %\u2087 %\u2088)\n+10  (call top.setindex! %\u2082 %\u2089 %\u2084 %\u2085)\n+11  (return %\u2089)\n+\n+########################################\n+# Updating assignment with type assert on left hand side\n+begin\n+    local x\n+    x::T += y\n+end\n+#---------------------\n+1   TestMod.+\n+2   slot\u2081/x\n+3   TestMod.T\n+4   (call core.typeassert %\u2082 %\u2083)\n+5   TestMod.y\n+6   (call %\u2081 %\u2084 %\u2085)\n+7   (= slot\u2081/x %\u2086)\n+8   (return %\u2086)\n+\n+########################################\n+# Updating assignment with ref and type assert on left hand side\n+begin\n+    local x\n+    x[f()]::T += y\n+end\n+#---------------------\n+1   (newvar slot\u2081/x)\n+2   TestMod.f\n+3   (call %\u2082)\n+4   TestMod.+\n+5   slot\u2081/x\n+6   (call top.getindex %\u2085 %\u2083)\n+7   TestMod.T\n+8   (call core.typeassert %\u2086 %\u2087)\n+9   TestMod.y\n+10  (call %\u2084 %\u2088 %\u2089)\n+11  slot\u2081/x\n+12  (call top.setindex! %\u2081\u2081 %\u2081\u2080 %\u2083)\n+13  (return %\u2081\u2080)\n+\n+########################################\n+# Error: Updating assignment with invalid left hand side\n+f() += y\n+#---------------------\n+LoweringError:\n+f() += y\n+\u2514\u2500\u2518 \u2500\u2500 invalid assignment location\n+\n+########################################\n+# Error: Updating assignment with invalid tuple destructuring on left hand side\n+(if false end, b) += 2\n+#---------------------\n+LoweringError:\n+(if false end, b) += 2\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 invalid multiple assignment location"
    },
    {
      "sha": "2b7eac29f348ca6e06b4498eed28aad8da60d743",
      "filename": "JuliaLowering/test/branching.jl",
      "status": "added",
      "additions": 317,
      "deletions": 0,
      "changes": 317,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fbranching.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fbranching.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fbranching.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,317 @@\n+# Branching\n+\n+@testset \"branching\" begin\n+\n+test_mod = Module()\n+\n+#-------------------------------------------------------------------------------\n+@testset \"Tail position\" begin\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = true\n+    if a\n+        1\n+    end\n+end\n+\"\"\") === 1\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false\n+    if a\n+        1\n+    end\n+end\n+\"\"\") === nothing\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = true\n+    if a\n+        1\n+    else\n+        2\n+    end\n+end\n+\"\"\") === 1\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false\n+    if a\n+        1\n+    else\n+        2\n+    end\n+end\n+\"\"\") === 2\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false, b = true\n+    if a\n+        1\n+    elseif b\n+        2\n+    else\n+        3\n+    end\n+end\n+\"\"\") === 2\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false, b = false\n+    if a\n+        1\n+    elseif b\n+        2\n+    else\n+        3\n+    end\n+end\n+\"\"\") === 3\n+\n+end\n+\n+#-------------------------------------------------------------------------------\n+@testset \"Value required but not tail position\" begin\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = true\n+    x = if a\n+        1\n+    end\n+    x\n+end\n+\"\"\") === 1\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false\n+    x = if a\n+        1\n+    end\n+    x\n+end\n+\"\"\") === nothing\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = true\n+    x = if a\n+        1\n+    else\n+        2\n+    end\n+    x\n+end\n+\"\"\") === 1\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false\n+    x = if a\n+        1\n+    else\n+        2\n+    end\n+    x\n+end\n+\"\"\") === 2\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false, b = true\n+    x = if a\n+        1\n+    elseif b\n+        2\n+    else\n+        3\n+    end\n+    x\n+end\n+\"\"\") === 2\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false, b = false\n+    x = if a\n+        1\n+    elseif b\n+        2\n+    else\n+        3\n+    end\n+    x\n+end\n+\"\"\") === 3\n+\n+end\n+\n+#-------------------------------------------------------------------------------\n+@testset \"Side effects (not value or tail position)\" begin\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = true\n+    x = nothing\n+    if a\n+        x = 1\n+    end\n+    x\n+end\n+\"\"\") === 1\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false\n+    x = nothing\n+    if a\n+        x = 1\n+    end\n+    x\n+end\n+\"\"\") === nothing\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = true\n+    x = nothing\n+    if a\n+        x = 1\n+    else\n+        x = 2\n+    end\n+    x\n+end\n+\"\"\") === 1\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false\n+    x = nothing\n+    if a\n+        x = 1\n+    else\n+        x = 2\n+    end\n+    x\n+end\n+\"\"\") === 2\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false, b = true\n+    x = nothing\n+    if a\n+        x = 1\n+    elseif b\n+        x = 2\n+    else\n+        x = 3\n+    end\n+    x\n+end\n+\"\"\") === 2\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = false, b = false\n+    x = nothing\n+    if a\n+        x = 1\n+    elseif b\n+        x = 2\n+    else\n+        x = 3\n+    end\n+    x\n+end\n+\"\"\") === 3\n+\n+end\n+#-------------------------------------------------------------------------------\n+# Block condition\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = true\n+    if begin; x = 2; a; end\n+        x\n+    end\n+end\n+\"\"\") === 2\n+\n+#-------------------------------------------------------------------------------\n+@testset \"`&&` and `||` chains\" begin\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+true && \"hi\"\n+\"\"\") == \"hi\"\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+true && true && \"hi\"\n+\"\"\") == \"hi\"\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+false && \"hi\"\n+\"\"\") == false\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+true && false && \"hi\"\n+\"\"\") == false\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    z = true && \"hi\"\n+    z\n+end\n+\"\"\") == \"hi\"\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    z = false && \"hi\"\n+    z\n+end\n+\"\"\") == false\n+\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+true || \"hi\"\n+\"\"\") == true\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+true || true || \"hi\"\n+\"\"\") == true\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+false || \"hi\"\n+\"\"\") == \"hi\"\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+false || true || \"hi\"\n+\"\"\") == true\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+false || false || \"hi\"\n+\"\"\") == \"hi\"\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    z = false || \"hi\"\n+    z\n+end\n+\"\"\") == \"hi\"\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    z = true || \"hi\"\n+    z\n+end\n+\"\"\") == true\n+\n+end\n+\n+@testset \"symbolic goto/label\" begin\n+\n+JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    i = 1\n+    @label foo\n+    push!(a, i)\n+    i = i + 1\n+    if i <= 2\n+        @goto foo\n+    end\n+    a\n+end\n+\"\"\") == [1,2]\n+\n+end\n+\n+end"
    },
    {
      "sha": "f7a63f40291e6fcce3e9f8cb40f49d697e392477",
      "filename": "JuliaLowering/test/branching_ir.jl",
      "status": "added",
      "additions": 239,
      "deletions": 0,
      "changes": 239,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fbranching_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fbranching_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fbranching_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,239 @@\n+########################################\n+# Basic branching tail && value\n+begin\n+    local a, b\n+    if a\n+        b\n+    end\n+end\n+#---------------------\n+1   (newvar slot\u2081/a)\n+2   (newvar slot\u2082/b)\n+3   slot\u2081/a\n+4   (gotoifnot %\u2083 label\u2087)\n+5   slot\u2082/b\n+6   (return %\u2085)\n+7   (return core.nothing)\n+\n+########################################\n+# Branching, !tail && !value\n+begin\n+    local a, b, c\n+    if a\n+        b\n+    end\n+    c\n+end\n+#---------------------\n+1   (newvar slot\u2081/a)\n+2   (newvar slot\u2082/b)\n+3   (newvar slot\u2083/c)\n+4   slot\u2081/a\n+5   (gotoifnot %\u2084 label\u2087)\n+6   slot\u2082/b\n+7   slot\u2083/c\n+8   (return %\u2087)\n+\n+########################################\n+# Branching with else\n+begin\n+    local a, b, c\n+    if a\n+        b\n+    else\n+        c\n+    end\n+end\n+#---------------------\n+1   (newvar slot\u2081/a)\n+2   (newvar slot\u2082/b)\n+3   (newvar slot\u2083/c)\n+4   slot\u2081/a\n+5   (gotoifnot %\u2084 label\u2088)\n+6   slot\u2082/b\n+7   (return %\u2086)\n+8   slot\u2083/c\n+9   (return %\u2088)\n+\n+########################################\n+# Branching with else, !tail && !value\n+begin\n+    local a, b, c, d\n+    if a\n+        b\n+    else\n+        c\n+    end\n+    d\n+end\n+#---------------------\n+1   (newvar slot\u2081/a)\n+2   (newvar slot\u2082/b)\n+3   (newvar slot\u2083/c)\n+4   (newvar slot\u2084/d)\n+5   slot\u2081/a\n+6   (gotoifnot %\u2085 label\u2089)\n+7   slot\u2082/b\n+8   (goto label\u2081\u2080)\n+9   slot\u2083/c\n+10  slot\u2084/d\n+11  (return %\u2081\u2080)\n+\n+########################################\n+# Blocks compile directly to branches\n+begin\n+   local a, b, c, d\n+   if (a; b && c)\n+       d\n+   end\n+end\n+#---------------------\n+1   (newvar slot\u2081/a)\n+2   (newvar slot\u2082/b)\n+3   (newvar slot\u2083/c)\n+4   (newvar slot\u2084/d)\n+5   slot\u2081/a\n+6   slot\u2082/b\n+7   (gotoifnot %\u2086 label\u2081\u2082)\n+8   slot\u2083/c\n+9   (gotoifnot %\u2088 label\u2081\u2082)\n+10  slot\u2084/d\n+11  (return %\u2081\u2080)\n+12  (return core.nothing)\n+\n+########################################\n+# symbolic goto forward jump\n+begin\n+    a\n+    @goto foo\n+    b\n+    @label foo\n+end\n+#---------------------\n+1   TestMod.a\n+2   (goto label\u2084)\n+3   TestMod.b\n+4   (return core.nothing)\n+\n+########################################\n+# symbolic goto backward jump\n+begin\n+    a\n+    @label foo\n+    b\n+    @goto foo\n+end\n+#---------------------\n+1   TestMod.a\n+2   TestMod.b\n+3   (goto label\u2082)\n+\n+########################################\n+# Jumping out of try and catch blocks using @goto\n+begin\n+    try\n+        a\n+        @goto lab\n+        b\n+    catch\n+        c\n+        @goto lab\n+        d\n+    end\n+    @label lab\n+end\n+#---------------------\n+1   (enter label\u2088)\n+2   TestMod.a\n+3   (leave %\u2081)\n+4   (goto label\u2081\u2083)\n+5   TestMod.b\n+6   (leave %\u2081)\n+7   (goto label\u2081\u2083)\n+8   TestMod.c\n+9   (pop_exception %\u2081)\n+10  (goto label\u2081\u2083)\n+11  TestMod.d\n+12  (pop_exception %\u2081)\n+13  (return core.nothing)\n+\n+########################################\n+# Jumping out of nested try/catch and catch/try\n+begin\n+    try\n+        try\n+            a\n+        catch\n+            b\n+            @goto lab\n+            c\n+        end\n+    catch\n+        try\n+            d\n+            @goto lab\n+            e\n+        catch\n+        end\n+    end\n+    @label lab\n+end\n+#---------------------\n+1   (enter label\u2081\u2084)\n+2   (enter label\u2086)\n+3   TestMod.a\n+4   (leave %\u2082)\n+5   (goto label\u2081\u2082)\n+6   TestMod.b\n+7   (pop_exception %\u2082)\n+8   (leave %\u2081)\n+9   (goto label\u2082\u2084)\n+10  TestMod.c\n+11  (pop_exception %\u2082)\n+12  (leave %\u2081)\n+13  (goto label\u2082\u2084)\n+14  (enter label\u2082\u2082)\n+15  TestMod.d\n+16  (pop_exception %\u2081)\n+17  (leave %\u2081\u2084)\n+18  (goto label\u2082\u2084)\n+19  TestMod.e\n+20  (leave %\u2081\u2084)\n+21  (goto label\u2082\u2083)\n+22  (pop_exception %\u2081\u2084)\n+23  (pop_exception %\u2081)\n+24  (return core.nothing)\n+\n+########################################\n+# Error: no symbolic label\n+begin\n+    @goto foo\n+end\n+#---------------------\n+LoweringError:\n+begin\n+    @goto foo\n+#         \u2514\u2500\u2518 \u2500\u2500 label `foo` referenced but not defined\n+end\n+\n+########################################\n+# Error: duplicate symbolic label\n+begin\n+    @label foo\n+    @label foo\n+end\n+#---------------------\n+LoweringError:\n+begin\n+    @label foo\n+    @label foo\n+#          \u2514\u2500\u2518 \u2500\u2500 Label `foo` defined multiple times\n+end\n+\n+########################################\n+# Error: using value of symbolic label\n+x = @label foo\n+#---------------------\n+LoweringError:\n+x = @label foo\n+#          \u2514\u2500\u2518 \u2500\u2500 misplaced label in value position"
    },
    {
      "sha": "3999b1a2c486acd006b1ab9ddfd50da2c9aeaf35",
      "filename": "JuliaLowering/test/closures.jl",
      "status": "added",
      "additions": 244,
      "deletions": 0,
      "changes": 244,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fclosures.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fclosures.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fclosures.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,244 @@\n+@testset \"Closures\" begin\n+\n+test_mod = Module()\n+\n+# Capture assigned before closure\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = 1\n+    f(y) = x+y\n+    f(2), f(3)\n+end\n+\"\"\") == (3,4)\n+\n+# Capture assigned after closure\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    f(y) = x+y\n+    x = 1\n+    f(2)\n+end\n+\"\"\") == 3\n+\n+# Capture assigned inside closure\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = 1\n+    function f(y)\n+        x = y\n+    end\n+    f(100)\n+    x\n+end\n+\"\"\") == 100\n+\n+Base.eval(test_mod, :(call_it(f, args...) = f(args...)))\n+\n+# Closure where a local `x` is captured but not boxed\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function f_unboxed_test(x)\n+        z = 0\n+        function g()\n+            y = x  # x will not be boxed\n+            (y + 1, z)\n+        end\n+        z = 2 # will be boxed\n+        (x, g())\n+    end\n+    f_unboxed_test(10)\n+end\n+\"\"\") == (10,(11,2))\n+\n+# Use of isdefined\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function f_isdefined(x)\n+        local w\n+        function g()\n+            z = 3\n+            (@isdefined(x), # unboxed, always defined capture\n+             @isdefined(y), # boxed capture\n+             @isdefined(z), # normal local var\n+             @isdefined(w)) # boxed undefined var\n+        end\n+        y = 2\n+        (@isdefined(y), @isdefined(w), g())\n+    end\n+    f_isdefined(1)\n+end\n+\"\"\") == (true, false, (true, true, true, false))\n+\n+# Mutually recursive closures (closure capturing a closure)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    function recursive_a(n)\n+        here = (:a, n)\n+        n <= 0 ? here  : (here, recursive_b(n-1))\n+    end\n+    function recursive_b(n)\n+        ((:b, n), recursive_a(n-1))\n+    end\n+    recursive_a(2)\n+end\n+\"\"\") == ((:a, 2), ((:b, 1), (:a, 0)))\n+\n+# Global method capturing local variables\n+JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    local x = 1\n+    function f_global_method_capturing_local()\n+        x = x + 1\n+    end\n+end\n+\"\"\")\n+@test test_mod.f_global_method_capturing_local() == 2\n+@test test_mod.f_global_method_capturing_local() == 3\n+\n+# Closure with multiple methods depending on local variables\n+f_closure_local_var_types = JuliaLowering.include_string(test_mod, \"\"\"\n+let T=Int, S=Float64\n+    function f_closure_local_var_types(::T)\n+        1\n+    end\n+    function f_closure_local_var_types(::S)\n+        1.0\n+    end\n+end\n+\"\"\")\n+@test f_closure_local_var_types(2) == 1\n+@test f_closure_local_var_types(2.0) == 1.0\n+@test_throws MethodError f_closure_local_var_types(\"hi\")\n+\n+# Multiply nested closures. In this case g_nest needs to capture `x` in order\n+# to construct an instance of `h_nest()` inside it.\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function f_nest(x)\n+        function g_nest(y)\n+            function h_nest(z)\n+                (x,y,z)\n+            end\n+        end\n+    end\n+\n+    f_nest(1)(2)(3)\n+end\n+\"\"\") === (1,2,3)\n+\n+# Closure with return type must capture the return type\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let T = Int\n+    function f_captured_return_type()::T\n+        2.0\n+    end\n+    f_captured_return_type()\n+end\n+\"\"\") === 2\n+\n+# Capturing a typed local\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let T = Int\n+    x::T = 1.0\n+    function f_captured_typed_local()\n+        x = 2.0\n+    end\n+    f_captured_typed_local()\n+    x\n+end\n+\"\"\") === 2\n+\n+# Capturing a typed local where the type is a nontrivial expression\n+@test begin\n+    res = JuliaLowering.include_string(test_mod, \"\"\"\n+    let T = Int, V=Vector\n+        x::V{T} = [1,2]\n+        function f_captured_typed_local_composite()\n+            x = [100.0, 200.0]\n+        end\n+        f_captured_typed_local_composite()\n+        x\n+    end\n+    \"\"\")\n+    res == [100, 200] && eltype(res) == Int\n+end\n+\n+# Evil case where we mutate `T` which is the type of `x`, such that x is\n+# eventually set to a Float64.\n+#\n+# Completely dynamic types for variables should be disallowed somehow?? For\n+# example, by emitting the expression computing the type of `x` alongside the\n+# newvar node. However, for now we verify that this potentially evil behavior\n+# is compatible with the existing implementation :)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let T = Int\n+    x::T = 1.0\n+    function f_captured_mutating_typed_local()\n+        x = 2\n+    end\n+    T = Float64\n+    f_captured_mutating_typed_local()\n+    x\n+end\n+\"\"\") === 2.0\n+\n+# Anon function syntax\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    local y = 2\n+    call_it(x->x+y, 3)\n+end\n+\"\"\") == 5\n+\n+# Anon function syntax with `where`\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    local y = 2\n+    call_it((x::T where {T<:Integer})->x+y, 3)\n+end\n+\"\"\") == 5\n+\n+# Do block syntax\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    local y = 2\n+    call_it(3) do x\n+        x + y\n+    end\n+end\n+\"\"\") == 5\n+\n+# Attempt to reference capture which is not assigned\n+@test_throws UndefVarError(:x, :local) JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    function f()\n+        x\n+    end\n+    f()\n+    x = 1\n+end\n+\"\"\")\n+\n+# Opaque closure\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let y = 1\n+    oc = Base.Experimental.@opaque x->2x + y\n+    oc(3)\n+end\n+\"\"\") == 7\n+\n+# Opaque closure with `...`\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    oc = Base.Experimental.@opaque (xs...)->xs\n+    oc(3,4,5)\n+end\n+\"\"\") == (3,4,5)\n+\n+# opaque_closure_method internals\n+method_ex = lower_str(test_mod, \"Base.Experimental.@opaque x -> 2x\").args[1].code[3]\n+@test method_ex.head === :opaque_closure_method\n+@test method_ex.args[1] === nothing\n+@test method_ex.args[4] isa LineNumberNode\n+\n+end"
    },
    {
      "sha": "0916e3133c97b58856e75810b5fa1c816d4440c1",
      "filename": "JuliaLowering/test/closures_ir.jl",
      "status": "added",
      "additions": 765,
      "deletions": 0,
      "changes": 765,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fclosures_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fclosures_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fclosures_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,765 @@\n+########################################\n+# Simple closure\n+# (FIXME: #self# should have `read` flag set)\n+let\n+    x = 1\n+    function f(y)\n+        x + y\n+    end\n+end\n+#---------------------\n+1   (= slot\u2082/x (call core.Box))\n+2   1\n+3   slot\u2082/x\n+4   (call core.setfield! %\u2083 :contents %\u2082)\n+5   (call core.svec :x)\n+6   (call core.svec true)\n+7   (call JuliaLowering.eval_closure_type TestMod :#f##0 %\u2085 %\u2086)\n+8   latestworld\n+9   TestMod.#f##0\n+10  slot\u2082/x\n+11  (new %\u2089 %\u2081\u2080)\n+12  (= slot\u2081/f %\u2081\u2081)\n+13  TestMod.#f##0\n+14  (call core.svec %\u2081\u2083 core.Any)\n+15  (call core.svec)\n+16  SourceLocation::3:14\n+17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n+18  --- method core.nothing %\u2081\u2087\n+    slots: [slot\u2081/#self#(!read) slot\u2082/y slot\u2083/x(!read)]\n+    1   TestMod.+\n+    2   (call core.getfield slot\u2081/#self# :x)\n+    3   (call core.isdefined %\u2082 :contents)\n+    4   (gotoifnot %\u2083 label\u2086)\n+    5   (goto label\u2088)\n+    6   (newvar slot\u2083/x)\n+    7   slot\u2083/x\n+    8   (call core.getfield %\u2082 :contents)\n+    9   (call %\u2081 %\u2088 slot\u2082/y)\n+    10  (return %\u2089)\n+19  latestworld\n+20  slot\u2081/f\n+21  (return %\u2082\u2080)\n+\n+########################################\n+# Closure declaration with no methods\n+begin\n+    local no_method_f\n+    function no_method_f\n+    end\n+end\n+#---------------------\n+1   (call core.svec)\n+2   (call core.svec)\n+3   (call JuliaLowering.eval_closure_type TestMod :#no_method_f##0 %\u2081 %\u2082)\n+4   latestworld\n+5   TestMod.#no_method_f##0\n+6   (new %\u2085)\n+7   (= slot\u2081/no_method_f %\u2086)\n+8   slot\u2081/no_method_f\n+9   (return %\u2088)\n+\n+########################################\n+# Closure which sets the value of a captured variable\n+let\n+    x = 1\n+    function f(y)\n+        x = 2\n+    end\n+end\n+#---------------------\n+1   (= slot\u2082/x (call core.Box))\n+2   1\n+3   slot\u2082/x\n+4   (call core.setfield! %\u2083 :contents %\u2082)\n+5   (call core.svec :x)\n+6   (call core.svec true)\n+7   (call JuliaLowering.eval_closure_type TestMod :#f##1 %\u2085 %\u2086)\n+8   latestworld\n+9   TestMod.#f##1\n+10  slot\u2082/x\n+11  (new %\u2089 %\u2081\u2080)\n+12  (= slot\u2081/f %\u2081\u2081)\n+13  TestMod.#f##1\n+14  (call core.svec %\u2081\u2083 core.Any)\n+15  (call core.svec)\n+16  SourceLocation::3:14\n+17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n+18  --- method core.nothing %\u2081\u2087\n+    slots: [slot\u2081/#self#(!read) slot\u2082/y(!read)]\n+    1   2\n+    2   (call core.getfield slot\u2081/#self# :x)\n+    3   (call core.setfield! %\u2082 :contents %\u2081)\n+    4   (return %\u2081)\n+19  latestworld\n+20  slot\u2081/f\n+21  (return %\u2082\u2080)\n+\n+########################################\n+# Function where arguments are captured into a closure and assigned\n+function f(x)\n+    function g()\n+        x = 10\n+    end\n+    g()\n+    x\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   (call core.svec :x)\n+4   (call core.svec true)\n+5   (call JuliaLowering.eval_closure_type TestMod :#f#g##0 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#f#g##0\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::2:14\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read)]\n+    1   10\n+    2   (call core.getfield slot\u2081/#self# :x)\n+    3   (call core.setfield! %\u2082 :contents %\u2081)\n+    4   (return %\u2081)\n+13  latestworld\n+14  TestMod.f\n+15  (call core.Typeof %\u2081\u2084)\n+16  (call core.svec %\u2081\u2085 core.Any)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/g(called) slot\u2084/x(!read)]\n+    1   (= slot\u2082/x (call core.Box slot\u2082/x))\n+    2   TestMod.#f#g##0\n+    3   (new %\u2082 slot\u2082/x)\n+    4   (= slot\u2083/g %\u2083)\n+    5   slot\u2083/g\n+    6   (call %\u2085)\n+    7   slot\u2082/x\n+    8   (call core.isdefined %\u2087 :contents)\n+    9   (gotoifnot %\u2088 label\u2081\u2081)\n+    10  (goto label\u2081\u2083)\n+    11  (newvar slot\u2084/x)\n+    12  slot\u2084/x\n+    13  (call core.getfield %\u2087 :contents)\n+    14  (return %\u2081\u2083)\n+21  latestworld\n+22  TestMod.f\n+23  (return %\u2082\u2082)\n+\n+########################################\n+# Closure where a local `x` is captured but not boxed\n+function f(x)\n+    function g()\n+        y = x\n+    end\n+    z = x\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   (call core.svec :x)\n+4   (call core.svec false)\n+5   (call JuliaLowering.eval_closure_type TestMod :#f#g##1 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#f#g##1\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::2:14\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read) slot\u2082/y(!read)]\n+    1   (call core.getfield slot\u2081/#self# :x)\n+    2   (= slot\u2082/y %\u2081)\n+    3   (return %\u2081)\n+13  latestworld\n+14  TestMod.f\n+15  (call core.Typeof %\u2081\u2084)\n+16  (call core.svec %\u2081\u2085 core.Any)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/g slot\u2084/z(!read)]\n+    1   TestMod.#f#g##1\n+    2   (call core.typeof slot\u2082/x)\n+    3   (call core.apply_type %\u2081 %\u2082)\n+    4   (new %\u2083 slot\u2082/x)\n+    5   (= slot\u2083/g %\u2084)\n+    6   slot\u2082/x\n+    7   (= slot\u2084/z %\u2086)\n+    8   (return %\u2086)\n+21  latestworld\n+22  TestMod.f\n+23  (return %\u2082\u2082)\n+\n+########################################\n+# Closure where a static parameter of an outer function is captured\n+function f(::T) where T\n+    function g()\n+        use(T)\n+    end\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   (call core.svec :T)\n+4   (call core.svec true)\n+5   (call JuliaLowering.eval_closure_type TestMod :#f#g##2 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#f#g##2\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::2:14\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read) slot\u2082/T(!read)]\n+    1   TestMod.use\n+    2   (call core.getfield slot\u2081/#self# :T)\n+    3   (call core.isdefined %\u2082 :contents)\n+    4   (gotoifnot %\u2083 label\u2086)\n+    5   (goto label\u2088)\n+    6   (newvar slot\u2082/T)\n+    7   slot\u2082/T\n+    8   (call core.getfield %\u2082 :contents)\n+    9   (call %\u2081 %\u2088)\n+    10  (return %\u2089)\n+13  latestworld\n+14  (= slot\u2081/T (call core.TypeVar :T))\n+15  TestMod.f\n+16  (call core.Typeof %\u2081\u2085)\n+17  slot\u2081/T\n+18  (call core.svec %\u2081\u2086 %\u2081\u2087)\n+19  slot\u2081/T\n+20  (call core.svec %\u2081\u2089)\n+21  SourceLocation::1:10\n+22  (call core.svec %\u2081\u2088 %\u2082\u2080 %\u2082\u2081)\n+23  --- method core.nothing %\u2082\u2082\n+    slots: [slot\u2081/#self#(!read) slot\u2082/_(!read) slot\u2083/g]\n+    1   TestMod.#f#g##2\n+    2   static_parameter\u2081\n+    3   (new %\u2081 %\u2082)\n+    4   (= slot\u2083/g %\u2083)\n+    5   slot\u2083/g\n+    6   (return %\u2085)\n+24  latestworld\n+25  TestMod.f\n+26  (return %\u2082\u2085)\n+\n+########################################\n+# Closure captures with `isdefined`\n+function f(x)\n+    function g()\n+        z = 3\n+        (@isdefined(x), # unboxed, always defined capture\n+         @isdefined(y), # boxed capture\n+         @isdefined(z)) # normal local var\n+    end\n+    y = 2\n+    (@isdefined(y), # boxed local\n+     @isdefined(x)) # always defined local (function arg)\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   (call core.svec :x :y)\n+4   (call core.svec false true)\n+5   (call JuliaLowering.eval_closure_type TestMod :#f#g##3 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#f#g##3\n+8   (call core.svec %\u2087)\n+9   (call core.svec)\n+10  SourceLocation::2:14\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read) slot\u2082/z]\n+    1   (= slot\u2082/z 3)\n+    2   (call core.getfield slot\u2081/#self# :y)\n+    3   (call core.isdefined %\u2082 :contents)\n+    4   (isdefined slot\u2082/z)\n+    5   (call core.tuple true %\u2083 %\u2084)\n+    6   (return %\u2085)\n+13  latestworld\n+14  TestMod.f\n+15  (call core.Typeof %\u2081\u2084)\n+16  (call core.svec %\u2081\u2085 core.Any)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/g slot\u2084/y]\n+    1   (= slot\u2084/y (call core.Box))\n+    2   TestMod.#f#g##3\n+    3   (call core.typeof slot\u2082/x)\n+    4   (call core.apply_type %\u2082 %\u2083)\n+    5   slot\u2084/y\n+    6   (new %\u2084 slot\u2082/x %\u2085)\n+    7   (= slot\u2083/g %\u2086)\n+    8   2\n+    9   slot\u2084/y\n+    10  (call core.setfield! %\u2089 :contents %\u2088)\n+    11  slot\u2084/y\n+    12  (call core.isdefined %\u2081\u2081 :contents)\n+    13  (call core.tuple %\u2081\u2082 true)\n+    14  (return %\u2081\u2083)\n+21  latestworld\n+22  TestMod.f\n+23  (return %\u2082\u2082)\n+\n+########################################\n+# Nested captures - here `g` captures `x` because it is needed to initialize\n+# the closure `h` which captures both `x` and `y`.\n+# [method_filter: #f_nest#g_nest##0]\n+function f_nest(x)\n+    function g_nest(y)\n+        function h_nest(z)\n+            (x,y,z)\n+        end\n+    end\n+end\n+#---------------------\n+slots: [slot\u2081/#self#(!read) slot\u2082/y(!read) slot\u2083/h_nest]\n+1   TestMod.#f_nest#g_nest#h_nest##0\n+2   (call core.getfield slot\u2081/#self# :x)\n+3   (call core.typeof %\u2082)\n+4   (call core.typeof slot\u2082/y)\n+5   (call core.apply_type %\u2081 %\u2083 %\u2084)\n+6   (call core.getfield slot\u2081/#self# :x)\n+7   (new %\u2085 %\u2086 slot\u2082/y)\n+8   (= slot\u2083/h_nest %\u2087)\n+9   slot\u2083/h_nest\n+10  (return %\u2089)\n+\n+########################################\n+# Global method capturing local variables\n+begin\n+    local x = 1\n+    function f()\n+        x = x + 1\n+    end\n+end\n+#---------------------\n+1   (= slot\u2081/x (call core.Box))\n+2   1\n+3   slot\u2081/x\n+4   (call core.setfield! %\u2083 :contents %\u2082)\n+5   (method TestMod.f)\n+6   latestworld\n+7   TestMod.f\n+8   (call core.Typeof %\u2087)\n+9   (call core.svec %\u2088)\n+10  (call core.svec)\n+11  SourceLocation::3:14\n+12  (call core.svec %\u2089 %\u2081\u2080 %\u2081\u2081)\n+13  --- code_info\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read)]\n+    1   TestMod.+\n+    2   (captured_local 1)\n+    3   (call core.isdefined %\u2082 :contents)\n+    4   (gotoifnot %\u2083 label\u2086)\n+    5   (goto label\u2088)\n+    6   (newvar slot\u2082/x)\n+    7   slot\u2082/x\n+    8   (call core.getfield %\u2082 :contents)\n+    9   (call %\u2081 %\u2088 1)\n+    10  (captured_local 1)\n+    11  (call core.setfield! %\u2081\u2080 :contents %\u2089)\n+    12  (return %\u2089)\n+14  slot\u2081/x\n+15  (call core.svec %\u2081\u2084)\n+16  (call JuliaLowering.replace_captured_locals! %\u2081\u2083 %\u2081\u2085)\n+17  --- method core.nothing %\u2081\u2082 %\u2081\u2086\n+18  latestworld\n+19  TestMod.f\n+20  (return %\u2081\u2089)\n+\n+########################################\n+# Anonymous function syntax with ->\n+x -> x*x\n+#---------------------\n+1   (call core.svec)\n+2   (call core.svec)\n+3   (call JuliaLowering.eval_closure_type TestMod :#->##0 %\u2081 %\u2082)\n+4   latestworld\n+5   TestMod.#->##0\n+6   (new %\u2085)\n+7   TestMod.#->##0\n+8   (call core.svec %\u2087 core.Any)\n+9   (call core.svec)\n+10  SourceLocation::1:1\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x]\n+    1   TestMod.*\n+    2   (call %\u2081 slot\u2082/x slot\u2082/x)\n+    3   (return %\u2082)\n+13  latestworld\n+14  (return %\u2086)\n+\n+########################################\n+# Anonymous function syntax with `function`\n+function (x)\n+    x*x\n+end\n+#---------------------\n+1   (call core.svec)\n+2   (call core.svec)\n+3   (call JuliaLowering.eval_closure_type TestMod :##anon###0 %\u2081 %\u2082)\n+4   latestworld\n+5   TestMod.##anon###0\n+6   (new %\u2085)\n+7   TestMod.##anon###0\n+8   (call core.svec %\u2087 core.Any)\n+9   (call core.svec)\n+10  SourceLocation::1:10\n+11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n+12  --- method core.nothing %\u2081\u2081\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x]\n+    1   TestMod.*\n+    2   (call %\u2081 slot\u2082/x slot\u2082/x)\n+    3   (return %\u2082)\n+13  latestworld\n+14  (return %\u2086)\n+\n+########################################\n+# `do` blocks\n+f(x; a=1) do y\n+    y + 2\n+end\n+#---------------------\n+1   TestMod.f\n+2   (call core.tuple :a)\n+3   (call core.apply_type core.NamedTuple %\u2082)\n+4   (call core.tuple 1)\n+5   (call %\u2083 %\u2084)\n+6   (call core.svec)\n+7   (call core.svec)\n+8   (call JuliaLowering.eval_closure_type TestMod :#do##0 %\u2086 %\u2087)\n+9   latestworld\n+10  TestMod.#do##0\n+11  (call core.svec %\u2081\u2080 core.Any)\n+12  (call core.svec)\n+13  SourceLocation::1:13\n+14  (call core.svec %\u2081\u2081 %\u2081\u2082 %\u2081\u2083)\n+15  --- method core.nothing %\u2081\u2084\n+    slots: [slot\u2081/#self#(!read) slot\u2082/y]\n+    1   TestMod.+\n+    2   (call %\u2081 slot\u2082/y 2)\n+    3   (return %\u2082)\n+16  latestworld\n+17  TestMod.#do##0\n+18  (new %\u2081\u2087)\n+19  TestMod.x\n+20  (call core.kwcall %\u2085 %\u2081 %\u2081\u2088 %\u2081\u2089)\n+21  (return %\u2082\u2080)\n+\n+########################################\n+# Error: Static parameter clashing with closure name\n+function f(::g) where {g}\n+    function g()\n+    end\n+end\n+#---------------------\n+LoweringError:\n+function f(::g) where {g}\n+    function g()\n+#            \u2559 \u2500\u2500 local variable name `g` conflicts with a static parameter\n+    end\n+end\n+\n+########################################\n+# Opaque closure\n+let y = 1\n+    Base.Experimental.@opaque (x, z::T)->2x + y - z\n+end\n+#---------------------\n+1   1\n+2   (= slot\u2081/y (call core.Box))\n+3   slot\u2081/y\n+4   (call core.setfield! %\u2083 :contents %\u2081)\n+5   TestMod.T\n+6   (call core.apply_type core.Tuple core.Any %\u2085)\n+7   (call core.apply_type core.Union)\n+8   --- opaque_closure_method  core.nothing 2 false SourceLocation::2:31\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/z slot\u2084/y(!read)]\n+    1   TestMod.-\n+    2   TestMod.+\n+    3   TestMod.*\n+    4   (call %\u2083 2 slot\u2082/x)\n+    5   (call core.getfield slot\u2081/#self# 1)\n+    6   (call core.isdefined %\u2085 :contents)\n+    7   (gotoifnot %\u2086 label\u2089)\n+    8   (goto label\u2081\u2081)\n+    9   (newvar slot\u2084/y)\n+    10  slot\u2084/y\n+    11  (call core.getfield %\u2085 :contents)\n+    12  (call %\u2082 %\u2084 %\u2081\u2081)\n+    13  (call %\u2081 %\u2081\u2082 slot\u2083/z)\n+    14  (return %\u2081\u2083)\n+9   slot\u2081/y\n+10  (new_opaque_closure %\u2086 %\u2087 core.Any true %\u2088 %\u2089)\n+11  (return %\u2081\u2080)\n+\n+########################################\n+# Opaque closure with `...`\n+let\n+    Base.Experimental.@opaque (x, ys...)->ys\n+end\n+#---------------------\n+1   (call core.apply_type core.Vararg core.Any)\n+2   (call core.apply_type core.Tuple core.Any %\u2081)\n+3   (call core.apply_type core.Union)\n+4   --- opaque_closure_method  core.nothing 2 true SourceLocation::2:31\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/ys]\n+    1   slot\u2083/ys\n+    2   (return %\u2081)\n+5   (new_opaque_closure %\u2082 %\u2083 core.Any true %\u2084)\n+6   (return %\u2085)\n+\n+########################################\n+# Error: Opaque closure with default args\n+Base.Experimental.@opaque (x=1)->2x\n+#---------------------\n+LoweringError:\n+Base.Experimental.@opaque (x=1)->2x\n+#                            \u2559 \u2500\u2500 Default positional arguments cannot be used in an opaque closure\n+\n+########################################\n+# Mutually recursive closures\n+let\n+    function recursive_a()\n+        recursive_b()\n+    end\n+    function recursive_b()\n+        recursive_a()\n+    end\n+end\n+#---------------------\n+1   (= slot\u2081/recursive_a (call core.Box))\n+2   (= slot\u2082/recursive_b (call core.Box))\n+3   (call core.svec :recursive_b)\n+4   (call core.svec true)\n+5   (call JuliaLowering.eval_closure_type TestMod :#recursive_a##0 %\u2083 %\u2084)\n+6   latestworld\n+7   TestMod.#recursive_a##0\n+8   slot\u2082/recursive_b\n+9   (new %\u2087 %\u2088)\n+10  slot\u2081/recursive_a\n+11  (call core.setfield! %\u2081\u2080 :contents %\u2089)\n+12  TestMod.#recursive_a##0\n+13  (call core.svec %\u2081\u2082)\n+14  (call core.svec)\n+15  SourceLocation::2:14\n+16  (call core.svec %\u2081\u2083 %\u2081\u2084 %\u2081\u2085)\n+17  --- method core.nothing %\u2081\u2086\n+    slots: [slot\u2081/#self#(!read) slot\u2082/recursive_b(!read)]\n+    1   (call core.getfield slot\u2081/#self# :recursive_b)\n+    2   (call core.isdefined %\u2081 :contents)\n+    3   (gotoifnot %\u2082 label\u2085)\n+    4   (goto label\u2087)\n+    5   (newvar slot\u2082/recursive_b)\n+    6   slot\u2082/recursive_b\n+    7   (call core.getfield %\u2081 :contents)\n+    8   (call %\u2087)\n+    9   (return %\u2088)\n+18  latestworld\n+19  (call core.svec :recursive_a)\n+20  (call core.svec true)\n+21  (call JuliaLowering.eval_closure_type TestMod :#recursive_b##0 %\u2081\u2089 %\u2082\u2080)\n+22  latestworld\n+23  TestMod.#recursive_b##0\n+24  slot\u2081/recursive_a\n+25  (new %\u2082\u2083 %\u2082\u2084)\n+26  slot\u2082/recursive_b\n+27  (call core.setfield! %\u2082\u2086 :contents %\u2082\u2085)\n+28  TestMod.#recursive_b##0\n+29  (call core.svec %\u2082\u2088)\n+30  (call core.svec)\n+31  SourceLocation::5:14\n+32  (call core.svec %\u2082\u2089 %\u2083\u2080 %\u2083\u2081)\n+33  --- method core.nothing %\u2083\u2082\n+    slots: [slot\u2081/#self#(!read) slot\u2082/recursive_a(!read)]\n+    1   (call core.getfield slot\u2081/#self# :recursive_a)\n+    2   (call core.isdefined %\u2081 :contents)\n+    3   (gotoifnot %\u2082 label\u2085)\n+    4   (goto label\u2087)\n+    5   (newvar slot\u2082/recursive_a)\n+    6   slot\u2082/recursive_a\n+    7   (call core.getfield %\u2081 :contents)\n+    8   (call %\u2087)\n+    9   (return %\u2088)\n+34  latestworld\n+35  slot\u2082/recursive_b\n+36  (call core.isdefined %\u2083\u2085 :contents)\n+37  (gotoifnot %\u2083\u2086 label\u2083\u2089)\n+38  (goto label\u2084\u2081)\n+39  (newvar slot\u2084/recursive_b)\n+40  slot\u2084/recursive_b\n+41  (call core.getfield %\u2083\u2085 :contents)\n+42  (return %\u2084\u2081)\n+\n+########################################\n+# Closure with keywords\n+let y = y_init\n+    function f_kw_closure(; x::X=x_default)\n+        x + y\n+    end\n+end\n+#---------------------\n+1   TestMod.y_init\n+2   (= slot\u2081/y (call core.Box))\n+3   (= slot\u2082/#f_kw_closure#0 (call core.Box))\n+4   slot\u2081/y\n+5   (call core.setfield! %\u2084 :contents %\u2081)\n+6   (call core.svec :#f_kw_closure#0)\n+7   (call core.svec true)\n+8   (call JuliaLowering.eval_closure_type TestMod :#f_kw_closure##0 %\u2086 %\u2087)\n+9   latestworld\n+10  TestMod.#f_kw_closure##0\n+11  slot\u2082/#f_kw_closure#0\n+12  (new %\u2081\u2080 %\u2081\u2081)\n+13  (= slot\u2083/f_kw_closure %\u2081\u2082)\n+14  (call core.svec :y)\n+15  (call core.svec true)\n+16  (call JuliaLowering.eval_closure_type TestMod :##f_kw_closure#0##0 %\u2081\u2084 %\u2081\u2085)\n+17  latestworld\n+18  TestMod.##f_kw_closure#0##0\n+19  slot\u2081/y\n+20  (new %\u2081\u2088 %\u2081\u2089)\n+21  slot\u2082/#f_kw_closure#0\n+22  (call core.setfield! %\u2082\u2081 :contents %\u2082\u2080)\n+23  TestMod.##f_kw_closure#0##0\n+24  TestMod.X\n+25  TestMod.#f_kw_closure##0\n+26  (call core.svec %\u2082\u2083 %\u2082\u2084 %\u2082\u2085)\n+27  (call core.svec)\n+28  SourceLocation::2:14\n+29  (call core.svec %\u2082\u2086 %\u2082\u2087 %\u2082\u2088)\n+30  --- method core.nothing %\u2082\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/#self#(!read) slot\u2084/y(!read)]\n+    1   (meta :nkw 1)\n+    2   TestMod.+\n+    3   (call core.getfield slot\u2081/#self# :y)\n+    4   (call core.isdefined %\u2083 :contents)\n+    5   (gotoifnot %\u2084 label\u2087)\n+    6   (goto label\u2089)\n+    7   (newvar slot\u2084/y)\n+    8   slot\u2084/y\n+    9   (call core.getfield %\u2083 :contents)\n+    10  (call %\u2082 slot\u2082/x %\u2089)\n+    11  (return %\u2081\u2080)\n+31  latestworld\n+32  (call core.typeof core.kwcall)\n+33  TestMod.#f_kw_closure##0\n+34  (call core.svec %\u2083\u2082 core.NamedTuple %\u2083\u2083)\n+35  (call core.svec)\n+36  SourceLocation::2:14\n+37  (call core.svec %\u2083\u2084 %\u2083\u2085 %\u2083\u2086)\n+38  --- code_info\n+    slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/kwtmp slot\u2085/x(!read) slot\u2086/#f_kw_closure#0(!read)]\n+    1   (newvar slot\u2085/x)\n+    2   (call core.isdefined slot\u2082/kws :x)\n+    3   (gotoifnot %\u2082 label\u2081\u2084)\n+    4   (call core.getfield slot\u2082/kws :x)\n+    5   TestMod.X\n+    6   (call core.isa %\u2084 %\u2085)\n+    7   (gotoifnot %\u2086 label\u2089)\n+    8   (goto label\u2081\u2082)\n+    9   TestMod.X\n+    10  (new core.TypeError :keyword argument :x %\u2089 %\u2084)\n+    11  (call core.throw %\u2081\u2080)\n+    12  (= slot\u2084/kwtmp %\u2084)\n+    13  (goto label\u2081\u2086)\n+    14  TestMod.x_default\n+    15  (= slot\u2084/kwtmp %\u2081\u2084)\n+    16  slot\u2084/kwtmp\n+    17  (call top.keys slot\u2082/kws)\n+    18  (call core.tuple :x)\n+    19  (call top.diff_names %\u2081\u2087 %\u2081\u2088)\n+    20  (call top.isempty %\u2081\u2089)\n+    21  (gotoifnot %\u2082\u2080 label\u2082\u2083)\n+    22  (goto label\u2082\u2084)\n+    23  (call top.kwerr slot\u2082/kws slot\u2083/#self#)\n+    24  (captured_local 1)\n+    25  (call core.isdefined %\u2082\u2084 :contents)\n+    26  (gotoifnot %\u2082\u2085 label\u2082\u2088)\n+    27  (goto label\u2083\u2080)\n+    28  (newvar slot\u2086/#f_kw_closure#0)\n+    29  slot\u2086/#f_kw_closure#0\n+    30  (call core.getfield %\u2082\u2084 :contents)\n+    31  (call %\u2083\u2080 %\u2081\u2086 slot\u2083/#self#)\n+    32  (return %\u2083\u2081)\n+39  slot\u2082/#f_kw_closure#0\n+40  (call core.svec %\u2083\u2089)\n+41  (call JuliaLowering.replace_captured_locals! %\u2083\u2088 %\u2084\u2080)\n+42  --- method core.nothing %\u2083\u2087 %\u2084\u2081\n+43  latestworld\n+44  TestMod.#f_kw_closure##0\n+45  (call core.svec %\u2084\u2084)\n+46  (call core.svec)\n+47  SourceLocation::2:14\n+48  (call core.svec %\u2084\u2085 %\u2084\u2086 %\u2084\u2087)\n+49  --- method core.nothing %\u2084\u2088\n+    slots: [slot\u2081/#self# slot\u2082/#f_kw_closure#0(!read)]\n+    1   (call core.getfield slot\u2081/#self# :#f_kw_closure#0)\n+    2   (call core.isdefined %\u2081 :contents)\n+    3   (gotoifnot %\u2082 label\u2085)\n+    4   (goto label\u2087)\n+    5   (newvar slot\u2082/#f_kw_closure#0)\n+    6   slot\u2082/#f_kw_closure#0\n+    7   (call core.getfield %\u2081 :contents)\n+    8   TestMod.x_default\n+    9   (call %\u2087 %\u2088 slot\u2081/#self#)\n+    10  (return %\u2089)\n+50  latestworld\n+51  slot\u2083/f_kw_closure\n+52  (return %\u2085\u2081)\n+\n+########################################\n+# Closure capturing a typed local must also capture the type expression\n+# [method_filter: #f_captured_typed_local##0]\n+let T=Blah\n+    x::T = 1.0\n+    function f_captured_typed_local()\n+        x = 2.0\n+    end\n+    f_captured_typed_local()\n+    x\n+end\n+#---------------------\n+slots: [slot\u2081/#self#(!read) slot\u2082/T(!read) slot\u2083/tmp(!read)]\n+1   2.0\n+2   (call core.getfield slot\u2081/#self# :x)\n+3   (call core.getfield slot\u2081/#self# :T)\n+4   (call core.isdefined %\u2083 :contents)\n+5   (gotoifnot %\u2084 label\u2087)\n+6   (goto label\u2089)\n+7   (newvar slot\u2082/T)\n+8   slot\u2082/T\n+9   (call core.getfield %\u2083 :contents)\n+10  (= slot\u2083/tmp %\u2081)\n+11  slot\u2083/tmp\n+12  (call core.isa %\u2081\u2081 %\u2089)\n+13  (gotoifnot %\u2081\u2082 label\u2081\u2085)\n+14  (goto label\u2081\u2088)\n+15  slot\u2083/tmp\n+16  (call top.convert %\u2089 %\u2081\u2085)\n+17  (= slot\u2083/tmp (call core.typeassert %\u2081\u2086 %\u2089))\n+18  slot\u2083/tmp\n+19  (call core.setfield! %\u2082 :contents %\u2081\u2088)\n+20  (return %\u2081)\n+\n+########################################\n+# Error: Closure outside any top level context\n+# (Should only happen in a user-visible way when lowering code emitted\n+#  from a `@generated` function code generator.)\n+@ast_ [K\"lambda\"(is_toplevel_thunk=false, toplevel_pure=false)\n+    [K\"block\"]\n+    [K\"block\"]\n+    [K\"->\" [K\"tuple\"] [K\"block\"]]\n+]\n+#---------------------\n+LoweringError:\n+#= line 1 =# - Top level code was found outside any top level context. `@generated` functions may not contain closures, including `do` syntax and generators/comprehension"
    },
    {
      "sha": "a7fce558e9f409ad7e809e89a8eae7a8fca58aa4",
      "filename": "JuliaLowering/test/compat.jl",
      "status": "added",
      "additions": 629,
      "deletions": 0,
      "changes": 629,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fcompat.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,629 @@\n+using Test\n+const JS = JuliaSyntax\n+const JL = JuliaLowering\n+\n+@testset \"expr->syntaxtree\" begin\n+    @testset \"semantics only\" begin\n+        # Test that `s` evaluates to the same thing both under normal parsing\n+        # and with the expr->tree->expr transformation\n+\n+        programs = [\n+            \"let x = 2; x += 5; x -= 1; [1] .*= 1; end\",\n+            \"let var\\\"x\\\" = 123; x; end\",\n+            \"try; 1; catch e; e; else; 2; finally; 3; end\",\n+            \"for x in 1:2, y in 3:4; x + y; end\",\n+            \"[x+y for x in 1:2, y in 3:4]\",\n+            \"Int[x+y for x in 1:2, y in 3:4 if true]\",\n+            \"for x in 1; x+=1\\n if true\\n continue \\n elseif false \\n break\\n end\\n end\",\n+            \"Base.Meta.@lower 1\",\n+            \"function foo(x, y=1; z, what::Int=5); x + y + z + what; end; foo(1,2;z=3)\",\n+            \"(()->1)()\",\n+            \"((x)->2)(3)\",\n+            \"((x,y)->4)(5,6)\",\n+            \"filter([1,2,3]) do x; x > 1; end\",\n+            \"\"\"\n+            struct X\n+                f1::Int # hi\n+                \"foo\"\n+                f2::Int\n+                f3::Int\n+                X(y) = new(y,y,y)\n+            end\n+            \"\"\",\n+            \"global x,y\",\n+            \"global (x,y)\",\n+            \"999999999999999999999999999999999999999\",\n+            \"0x00000000000000001\",\n+            \"(0x00000000000000001)\",\n+            \"let x = 1; 2x; end\",\n+            \"let x = 1; (2)(3)x; end\",\n+            \"if false\\n1\\nelseif true\\n 3\\nend\",\n+            \"\\\"str\\\"\",\n+            \"\\\"\\$(\\\"str\\\")\\\"\",\n+            \"'a'\",\n+            \"'\u03b1'\",\n+            \"'\\\\xce\\\\xb1'\",\n+            \"let x = 1; \\\"\\\"\\\"\\n  a\\n  \\$x\\n  b\\n  c\\\"\\\"\\\"; end\",\n+            \"try throw(0) catch e; 1 end\",\n+            \"try 0 finally 1 end\",\n+            \"try throw(0) catch e; 1 finally 2 end\",\n+            \"try throw(0) catch e; 1 else 2 end\",\n+            \"try throw(0) catch e; 1 else 2 finally 3 end\",\n+            \"try throw(0) finally 1 catch e; 2 end\",\n+            \":.+\",\n+            \":.=\",\n+            \":(.=)\",\n+            \":+=\",\n+            \":(+=)\",\n+            \":.+=\",\n+            \":(.+=)\",\n+        ]\n+\n+        test_mod_1 = Module()\n+        test_mod_2 = Module()\n+\n+        for p in programs\n+            @testset \"`$p`\" begin\n+                local good_expr, good_out, test_st, test_expr, test_out\n+                try\n+                    good_expr = JS.parseall(Expr, p; ignore_errors=true)\n+                    good_out = Core.eval(test_mod_1, good_expr)\n+                catch e\n+                    @error \"Couldn't eval the reference expression---fix your test\"\n+                    rethrow(e)\n+                end\n+\n+                test_st = JuliaLowering.expr_to_syntaxtree(good_expr)\n+                test_expr = Expr(test_st)\n+                test_out = Core.eval(test_mod_2, test_expr)\n+\n+                @test good_out == test_out\n+            end\n+        end\n+    end\n+\n+    # Remove any information that can't be recovered from an Expr\n+    function normalize_st!(st)\n+        k = JS.kind(st)\n+        args = JS.children(st)\n+\n+        if JS.is_infix_op_call(st) && (k === K\"call\" || k === K\"dotcall\")\n+            # Infix calls are not preserved in Expr; we need to re-order the children\n+            pre_st_args = JL.NodeId[st[2]._id, st[1]._id]\n+            for c in st[3:end]\n+                push!(pre_st_args, c._id)\n+            end\n+            pre_st_flags = (JS.flags(st) & ~JS.INFIX_FLAG) | JS.PREFIX_CALL_FLAG\n+            JL.setchildren!(st._graph, st._id, pre_st_args)\n+            JL.setflags!(st._graph, st._id, pre_st_flags)\n+        elseif JS.is_postfix_op_call(st) && (k === K\"call\" || k === K\"dotcall\")\n+            pre_st_args = JL.NodeId[st[end]._id]\n+            for c in st[1:end-1]\n+                push!(pre_st_args, c._id)\n+            end\n+            pre_st_flags = (JS.flags(st) & ~JS.POSTFIX_OP_FLAG) | JS.PREFIX_CALL_FLAG\n+            JL.setchildren!(st._graph, st._id, pre_st_args)\n+            JL.setflags!(st._graph, st._id, pre_st_flags)\n+        elseif k in JS.KSet\"tuple block macrocall\"\n+            JL.setflags!(st._graph, st._id, JS.flags(st) & ~JS.PARENS_FLAG)\n+        elseif k === K\"toplevel\"\n+            JL.setflags!(st._graph, st._id, JS.flags(st) & ~JS.TOPLEVEL_SEMICOLONS_FLAG)\n+        end\n+\n+        if k in JS.KSet\"tuple call dotcall macrocall vect curly braces <: >:\"\n+            JL.setflags!(st._graph, st._id, JS.flags(st) & ~JS.TRAILING_COMMA_FLAG)\n+        end\n+\n+        k === K\"quote\" && JL.setflags!(st._graph, st._id, JS.flags(st) & ~JS.COLON_QUOTE)\n+        k === K\"wrapper\" && JL.sethead!(st._graph, st._id, K\"block\")\n+\n+        # All ops are prefix ops in an expr.\n+        # Ignore trivia (shows up on some K\"error\"s)\n+        JL.setflags!(st._graph, st._id, JS.flags(st) &\n+            ~JS.PREFIX_OP_FLAG & ~JS.INFIX_FLAG & ~JS.TRIVIA_FLAG & ~JS.NON_TERMINAL_FLAG)\n+\n+        for c in JS.children(st)\n+            normalize_st!(c)\n+        end\n+        return st\n+    end\n+\n+    function st_roughly_equal(; st_good, st_test)\n+        normalize_st!(st_good)\n+\n+        if kind(st_good) === kind(st_test) === K\"error\"\n+            # We could consider some sort of equivalence later, but we would\n+            # need to specify within JS what the error node contains.\n+            return true\n+        end\n+\n+        out = kind(st_good) === kind(st_test) &&\n+            JS.flags(st_good) === JS.flags(st_test) &&\n+            JS.numchildren(st_good) === JS.numchildren(st_test) &&\n+            JS.is_leaf(st_good) === JS.is_leaf(st_test) &&\n+            get(st_good, :value, nothing) === get(st_test, :value, nothing) &&\n+            get(st_good, :name_val, nothing) === get(st_test, :name_val, nothing) &&\n+            all(map((cg, ct)->st_roughly_equal(;st_good=cg, st_test=ct),\n+                    JS.children(st_good), JS.children(st_test)))\n+\n+        !out && @warn(\"!st_roughly_equal (normalized_reference, st_test):\",\n+                      JS.sourcetext(st_good), st_good, st_test)\n+        return out\n+    end\n+\n+    @testset \"SyntaxTree equivalence (tests taken from JuliaSyntax expr.jl)\" begin\n+        # test that string->tree->expr->tree ~= string->tree\n+        #                             ^^\n+        programs = [\n+            \"begin a\\nb\\n\\nc\\nend\",\n+            \"(a;b;c)\",\n+            \"begin end\",\n+            \"(;;)\",\n+            \"a;b\",\n+            \"module A\\n\\nbody\\nend\",\n+            \"function f()\\na\\n\\nb\\nend\",\n+            \"f() = 1\",\n+            \"macro f()\\na\\nend\",\n+            \"function f end\",\n+            \"macro f end\",\n+            \"function (f() where {T}) end\",\n+            \"function (f()::S) end\",\n+            \"a -> b\",\n+            \"(a,) -> b\",\n+            \"(a where {T}) -> b\",\n+            \"a -> (\\nb;c)\",\n+            \"a -> begin\\nb\\nc\\nend\",\n+            \"(a;b=1) -> c\",\n+            \"(a...;b...) -> c\",\n+            \"(;) -> c\",\n+            \"a::T -> b\",\n+            \"let i=is, j=js\\nbody\\nend\",\n+            \"for x=xs\\n\\nend\",\n+            \"for x=xs\\ny\\nend\",\n+            \"while cond\\n\\nend\",\n+            \"while cond\\ny\\nend\",\n+            \"f() = xs\",\n+            \"f() =\\n(a;b)\",\n+            \"f() =\\nbegin\\na\\nb\\nend\",\n+            \"let f(x) =\\ng(x)=1\\nend\",\n+            \"f() .= xs\",\n+            \"for i=is body end\",\n+            \"for i=is, j=js\\nbody\\nend\",\n+            \"f(x) do y\\n body end\",\n+            \"@f(x) do y body end\",\n+            \"f(x; a=1) do y body end\",\n+            \"g(f(x) do y\\n body end)\",\n+            \"f(a=1)\",\n+            \"f(; b=2)\",\n+            \"f(a=1; b=2)\",\n+            \"f(a; b; c)\",\n+            \"+(a=1,)\",\n+            \"(a=1)()\",\n+            \"(x=1) != 2\",\n+            \"+(a=1)\",\n+            \"(a=1)'\",\n+            \"f.(a=1; b=2)\",\n+            \"(a=1,)\",\n+            \"(a=1,; b=2)\",\n+            \"(a=1,; b=2; c=3)\",\n+            \"x[i=j]\",\n+            \"(i=j)[x]\",\n+            \"x[a, b; i=j]\",\n+            \"(i=j){x}\",\n+            \"x{a, b; i=j}\",\n+            \"[a=1,; b=2]\",\n+            \"{a=1,; b=2}\",\n+            \"f(a .= 1)\",\n+            \"f(((a = 1)))\",\n+            \"(((a = 1)),)\",\n+            \"(;((a = 1)),)\",\n+            \"a.b\",\n+            \"a.@b x\",\n+            \"f.(x,y)\",\n+            \"f.(x=1)\",\n+            \"f.(a=1; b=2)\",\n+            \"(a=1).()\",\n+            \"x .+ y\",\n+            \"(x=1) .+ y\",\n+            \"a .< b .< c\",\n+            \"a .< (.<) .< c\",\n+            \"quote .+ end\",\n+            \".+(x)\",\n+            \".+x\",\n+            \"f(.+)\",\n+            \"(a, .+)\",\n+            \"x += y\",\n+            \"x .+= y\",\n+            \"x \\u2212= y\",\n+            \"let x=1\\n end\",\n+            \"let x=1 ; end\",\n+            \"let x ; end\",\n+            \"let x::1 ; end\",\n+            \"let x=1,y=2 end\",\n+            \"let x+=1 ; end\",\n+            \"let ; end\",\n+            \"let ; body end\",\n+            \"let\\na\\nb\\nend\",\n+            \"A where {T}\",\n+            \"A where {S, T}\",\n+            \"A where {X, Y; Z}\",\n+            \"@m\\n\",\n+            \"\\n@m\",\n+            \"@m(x; a)\",\n+            \"@m(a=1; b=2)\",\n+            \"@S[a,b]\",\n+            \"@S[a b]\",\n+            \"@S[a; b]\",\n+            \"@S[a ;; b]\",\n+            \"[x,y ; z]\",\n+            \"[a ;;; b ;;;; c]\",\n+            \"[a b ; c d]\",\n+            \"[a\\nb]\",\n+            \"[a b]\",\n+            \"[a b ; c d]\",\n+            \"T[a ;;; b ;;;; c]\",\n+            \"T[a b ; c d]\",\n+            \"T[a\\nb]\",\n+            \"T[a b]\",\n+            \"T[a b ; c d]\",\n+            \"(x for a in as for b in bs)\",\n+            \"(x for a in as, b in bs)\",\n+            \"(x for a in as, b in bs if z)\",\n+            \"(x for a in as, b in bs for c in cs, d in ds)\",\n+            \"(x for a in as for b in bs if z)\",\n+            \"(x for a in as if z for b in bs)\",\n+            \"[x for a = as for b = bs if cond1 for c = cs if cond2]\" ,\n+            \"[x for a = as if begin cond2 end]\" ,\n+            \"(x for a in as if z)\",\n+            \"return x\",\n+            \"struct A end\",\n+            \"mutable struct A end\",\n+            \"struct A <: B \\n a::X \\n end\",\n+            \"struct A \\n a \\n b \\n end\",\n+            \"struct A const a end\",\n+            \"export a\",\n+            \"export +, ==\",\n+            \"export \\n a\",\n+            \"global x\",\n+            \"local x\",\n+            \"global x,y\",\n+            \"const x,y = 1,2\",\n+            \"const x = 1\",\n+            \"global x ~ 1\",\n+            \"global x += 1\",\n+            \"(;)\",\n+            \"(; a=1)\",\n+            \"(; a=1; b=2)\",\n+            \"(a; b; c,d)\",\n+            \"module A end\",\n+            \"baremodule A end\",\n+            \"import A\",\n+            \"A.x\",\n+            \"A.\\$x\",\n+            \"try x catch e; y end\",\n+            \"try x finally y end\",\n+            \"try x catch e; y finally z end\",\n+            \"try x catch e; y else z end\",\n+            \"try x catch e; y else z finally w end\",\n+        ]\n+\n+        for p in programs\n+            @testset \"`$(repr(p))`\" begin\n+                st_good = JS.parsestmt(JL.SyntaxTree, p; ignore_errors=true)\n+                st_test = JL.expr_to_syntaxtree(Expr(st_good))\n+                @test st_roughly_equal(;st_good, st_test)\n+            end\n+        end\n+\n+        # toplevel has a special parsing mode where docstrings and a couple of\n+        # other things are enabled\n+        toplevel_programs = [\n+            \"\\\"docstr\\\"\\nthing_to_be_documented\",\n+        ]\n+        for p in toplevel_programs\n+            @testset \"`$(repr(p))`\" begin\n+                st_good = JS.parseall(JL.SyntaxTree, p; ignore_errors=true)\n+                st_test = JL.expr_to_syntaxtree(Expr(st_good))\n+                @test st_roughly_equal(;st_good, st_test)\n+            end\n+        end\n+    end\n+\n+    @testset \"provenance via scavenging for LineNumberNodes\" begin\n+        # Provenenance of a node should be the last seen LineNumberNode in the\n+        # depth-first traversal of the Expr, or the initial line given if none\n+        # have been seen yet.  If none have been seen and no initial line was\n+        # given, .source should still be defined on all nodes (of unspecified\n+        # value, but hopefully a helpful value for the user.)\n+        ex = Expr(:block,\n+                  LineNumberNode(123),\n+                  Expr(:block,\n+                       Expr(:block, LineNumberNode(456)),\n+                       Expr(:block)),\n+                  Expr(:block,\n+                       Expr(:block),\n+                       Expr(:block)))\n+\n+        # No initial line provided\n+        st = JuliaLowering.expr_to_syntaxtree(ex)\n+        for i in length(st._graph.edge_ranges)\n+            @test !isnothing(get(SyntaxTree(st._graph, i), :source, nothing))\n+        end\n+        @test let lnn = st[1].source;    lnn isa LineNumberNode && lnn.line === 123; end\n+        @test let lnn = st[1][1].source; lnn isa LineNumberNode && lnn.line === 123; end\n+        @test let lnn = st[1][2].source; lnn isa LineNumberNode && lnn.line === 456; end\n+        @test let lnn = st[2].source;    lnn isa LineNumberNode && lnn.line === 456; end\n+        @test let lnn = st[2][1].source; lnn isa LineNumberNode && lnn.line === 456; end\n+        @test let lnn = st[2][2].source; lnn isa LineNumberNode && lnn.line === 456; end\n+\n+        # Same tree, but provide an initial line\n+        st = JuliaLowering.expr_to_syntaxtree(ex, LineNumberNode(789))\n+        @test let lnn = st.source;       lnn isa LineNumberNode && lnn.line === 789; end\n+        @test let lnn = st[1].source;    lnn isa LineNumberNode && lnn.line === 123; end\n+        @test let lnn = st[1][1].source; lnn isa LineNumberNode && lnn.line === 123; end\n+        @test let lnn = st[1][2].source; lnn isa LineNumberNode && lnn.line === 456; end\n+        @test let lnn = st[2].source;    lnn isa LineNumberNode && lnn.line === 456; end\n+        @test let lnn = st[2][1].source; lnn isa LineNumberNode && lnn.line === 456; end\n+        @test let lnn = st[2][2].source; lnn isa LineNumberNode && lnn.line === 456; end\n+\n+        ex = parsestmt(Expr, \"\"\"\n+        begin\n+            try\n+                maybe\n+                lots\n+                of\n+                lines\n+            catch exc\n+                y\n+            end\n+        end\"\"\")\n+        st = JuliaLowering.expr_to_syntaxtree(ex, LineNumberNode(1))\n+\n+        # sanity: ensure we're testing the tree we expect\n+        @test st \u2248 @ast_ [K\"block\"\n+            [K\"try\"\n+                [K\"block\"\n+                    \"maybe\"::K\"Identifier\"\n+                    \"lots\"::K\"Identifier\"\n+                    \"of\"::K\"Identifier\"\n+                    \"lines\"::K\"Identifier\"\n+                ]\n+                [K\"catch\"\n+                    \"exc\"::K\"Identifier\"\n+                    [K\"block\"\n+                        \"y\"::K\"Identifier\"\n+                    ]\n+                ]\n+            ]\n+        ]\n+\n+        @test let lnn = st.source;             lnn isa LineNumberNode && lnn.line === 1; end\n+        @test let lnn = st[1].source;          lnn isa LineNumberNode && lnn.line === 2; end\n+        @test let lnn = st[1][1].source;       lnn isa LineNumberNode && lnn.line === 2; end\n+        @test let lnn = st[1][1][1].source;    lnn isa LineNumberNode && lnn.line === 3; end\n+        @test let lnn = st[1][1][2].source;    lnn isa LineNumberNode && lnn.line === 4; end\n+        @test let lnn = st[1][1][3].source;    lnn isa LineNumberNode && lnn.line === 5; end\n+        @test let lnn = st[1][1][4].source;    lnn isa LineNumberNode && lnn.line === 6; end\n+        @test let lnn = st[1][2].source;       lnn isa LineNumberNode && lnn.line === 6; end\n+        @test let lnn = st[1][2][1].source;    lnn isa LineNumberNode && lnn.line === 6; end\n+        @test let lnn = st[1][2][2].source;    lnn isa LineNumberNode && lnn.line === 6; end\n+        @test let lnn = st[1][2][2][1].source; lnn isa LineNumberNode && lnn.line === 8; end\n+\n+        st_shortfunc = JuliaLowering.expr_to_syntaxtree(\n+            Expr(:block,\n+                 LineNumberNode(11),\n+                 Expr(:(=),\n+                      Expr(:call, :f),\n+                      :body))\n+        )\n+        @test st_shortfunc \u2248 @ast_ [K\"block\"\n+            [K\"function\"\n+                [K\"call\" \"f\"::K\"Identifier\"]\n+                \"body\"::K\"Identifier\"\n+            ]\n+        ]\n+        @test let lnn = st_shortfunc[1][1].source; lnn isa LineNumberNode && lnn.line === 11; end\n+\n+        st_shortfunc_2 = JuliaLowering.expr_to_syntaxtree(\n+            Expr(:block,\n+                 LineNumberNode(11),\n+                 Expr(:(=),\n+                      Expr(:call, :f),\n+                      Expr(:block,\n+                         LineNumberNode(22),\n+                         :body)))\n+        )\n+        @test st_shortfunc_2 \u2248 @ast_ [K\"block\"\n+            [K\"function\"\n+                [K\"call\" \"f\"::K\"Identifier\"]\n+                \"body\"::K\"Identifier\"\n+            ]\n+        ]\n+        @test let lnn = st_shortfunc_2[1][1].source; lnn isa LineNumberNode && lnn.line === 22; end\n+    end\n+\n+    @testset \"`Expr(:escape)` handling\" begin\n+        # `x.y` with quoted y escaped (this esc does nothing, but is permitted by\n+        # the existing expander)\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:(.), :x, esc(QuoteNode(:y)))) \u2248\n+            @ast_ [K\".\"\n+                \"x\"::K\"Identifier\"\n+                [K\"escape\"\n+                    \"y\"::K\"Identifier\"\n+                ]\n+            ]\n+\n+        # `f(x; y)` with parameters escaped\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:call, :f, esc(Expr(:parameters, :y)), :x)) \u2248\n+            @ast_ [K\"call\"\n+                \"f\"::K\"Identifier\"\n+                \"x\"::K\"Identifier\"\n+                [K\"escape\"\n+                    [K\"parameters\"\n+                        \"y\"::K\"Identifier\"\n+                    ]\n+                ]\n+            ]\n+\n+        # `.+(x)` with operator escaped\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:call, esc(Symbol(\".+\")), :x)) \u2248\n+            @ast_ [K\"dotcall\"\n+                [K\"escape\" \"+\"::K\"Identifier\"]\n+                \"x\"::K\"Identifier\"\n+            ]\n+\n+        # `let x \\n end` with binding escaped\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:let, esc(:x), Expr(:block))) \u2248\n+            @ast_ [K\"let\"\n+                [K\"block\" [K\"escape\" \"x\"::K\"Identifier\"]]\n+                [K\"block\"]\n+            ]\n+\n+        # `x .+ y` with .+ escaped\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:comparison, :x, esc(Symbol(\".+\")), :y)) \u2248\n+            @ast_ [K\"comparison\"\n+                \"x\"::K\"Identifier\"\n+                [K\".\"\n+                    [K\"escape\" \"+\"::K\"Identifier\"]\n+                ]\n+                \"y\"::K\"Identifier\"\n+            ]\n+\n+        # `@mac x` with macro name escaped\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:macrocall, esc(Symbol(\"@mac\")), nothing, :x)) \u2248\n+            @ast_ [K\"macrocall\"\n+                [K\"escape\" [K\"macro_name\" \"mac\"::K\"Identifier\"]]\n+                \"x\"::K\"Identifier\"\n+            ]\n+\n+        # `@mac x` with macro name escaped\n+        @test JuliaLowering.expr_to_syntaxtree(\n+            Expr(:macrocall, esc(Expr(:(.), :A, QuoteNode(Symbol(\"@mac\")))), nothing, :x)\n+        ) \u2248 @ast_ [K\"macrocall\"\n+            [K\"escape\"\n+                [K\".\"\n+                    \"A\"::K\"Identifier\"\n+                    [K\"macro_name\" \"mac\"::K\"Identifier\"]\n+                ]\n+            ]\n+            \"x\"::K\"Identifier\"\n+        ]\n+\n+        # `x where y`\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:where, :x, esc(:y))) \u2248\n+            @ast_ [K\"where\"\n+                \"x\"::K\"Identifier\"\n+                [K\"braces\"\n+                    [K\"escape\" \"y\"::K\"Identifier\"]\n+                ]\n+            ]\n+\n+        # Some weirdly placed esc's in try-catch\n+        # `try body1 catch exc \\n end`\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:try, :body1, :exc, esc(false))) \u2248\n+            @ast_ [K\"try\"\n+                \"body1\"::K\"Identifier\"\n+                [K\"catch\"\n+                    \"exc\"::K\"Identifier\"\n+                    \"nothing\"::K\"core\"\n+                ]\n+            ]\n+        # `try body1 catch \\n body2 \\n end`\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:try, :body1, esc(false), :body2)) \u2248\n+            @ast_ [K\"try\"\n+                \"body1\"::K\"Identifier\"\n+                [K\"catch\"\n+                    \"\"::K\"Placeholder\"\n+                    \"body2\"::K\"Identifier\"\n+                ]\n+            ]\n+        # `try body1 finally body2 end`\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:try, :body1, esc(false), esc(false), :body2)) \u2248\n+            @ast_ [K\"try\"\n+                \"body1\"::K\"Identifier\"\n+                [K\"finally\"\n+                    \"body2\"::K\"Identifier\"\n+                ]\n+            ]\n+\n+        # `try body1 finally body2 end`\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:try, :body1, esc(false), esc(false), esc(false), :body2)) \u2248\n+            @ast_ [K\"try\"\n+                \"body1\"::K\"Identifier\"\n+                [K\"else\"\n+                    \"body2\"::K\"Identifier\"\n+                ]\n+            ]\n+\n+        # [x ;;; y] with dim escaped\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:ncat, esc(3), :x, :y)) \u2248\n+            @ast_ [K\"ncat\"(syntax_flags=JuliaSyntax.set_numeric_flags(3))\n+                \"x\"::K\"Identifier\"\n+                \"y\"::K\"Identifier\"\n+            ]\n+\n+        # T[x ;;; y] with dim escaped\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:typed_ncat, :T, esc(3), :x, :y)) \u2248\n+            @ast_ [K\"typed_ncat\"(syntax_flags=JuliaSyntax.set_numeric_flags(3))\n+                \"T\"::K\"Identifier\"\n+                \"x\"::K\"Identifier\"\n+                \"y\"::K\"Identifier\"\n+            ]\n+\n+        # One example of hygienic-scope (handled with the same mechanism as escape)\n+        @test JuliaLowering.expr_to_syntaxtree(\n+            Expr(:macrocall, Expr(:var\"hygienic-scope\", Symbol(\"@mac\"), :other, :args), nothing, :x)) \u2248\n+            @ast_ [K\"macrocall\"\n+                [K\"hygienic_scope\"\n+                    [K\"macro_name\" \"mac\"::K\"Identifier\"]\n+                    \"other\"::K\"Identifier\" # (<- normally a Module)\n+                    \"args\"::K\"Identifier\" # (<- normally a LineNumberNode)\n+                ]\n+                \"x\"::K\"Identifier\"\n+            ]\n+\n+        # One example of double escaping\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:macrocall, esc(esc(Symbol(\"@mac\"))), nothing, :x)) \u2248\n+            @ast_ [K\"macrocall\"\n+                [K\"escape\" [K\"escape\" [K\"macro_name\" \"mac\"::K\"Identifier\"]]]\n+                \"x\"::K\"Identifier\"\n+            ]\n+\n+        # One example of nested escape and hygienic-scope\n+        @test JuliaLowering.expr_to_syntaxtree(\n+            Expr(:macrocall,\n+                 Expr(:var\"hygienic-scope\", esc(Symbol(\"@mac\")), :other, :args),\n+                 nothing,\n+                 :x)) \u2248\n+            @ast_ [K\"macrocall\"\n+                [K\"hygienic_scope\"\n+                    [K\"escape\"\n+                        [K\"macro_name\" \"mac\"::K\"Identifier\"]\n+                    ]\n+                    \"other\"::K\"Identifier\" # (<- normally a Module)\n+                    \"args\"::K\"Identifier\" # (<- normally a LineNumberNode)\n+                ]\n+                \"x\"::K\"Identifier\"\n+            ]\n+\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:block, LineNumberNode(1))) \u2248\n+            @ast_ [K\"block\"]\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:block, esc(LineNumberNode(1)))) \u2248\n+            @ast_ [K\"block\"]\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:block, QuoteNode(LineNumberNode(1)))) \u2248\n+            @ast_ [K\"block\" LineNumberNode(1)::K\"Value\"]\n+\n+        # toplevel (and all other non-block forms) keep LineNumberNodes in value position\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:toplevel, esc(LineNumberNode(1)))) \u2248\n+            @ast_ [K\"toplevel\"  [K\"escape\" \"nothing\"::K\"core\"]]\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:toplevel, LineNumberNode(1))) \u2248\n+            @ast_ [K\"toplevel\" \"nothing\"::K\"core\"]\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:toplevel, QuoteNode(LineNumberNode(1)))) \u2248\n+            @ast_ [K\"toplevel\" LineNumberNode(1)::K\"Value\"]\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:call, :identity, LineNumberNode(1))) \u2248\n+            @ast_ [K\"call\" \"identity\"::K\"Identifier\" \"nothing\"::K\"core\"]\n+        @test JuliaLowering.expr_to_syntaxtree(Expr(:call, :identity, QuoteNode(LineNumberNode(1)))) \u2248\n+            @ast_ [K\"call\" \"identity\"::K\"Identifier\" LineNumberNode(1)::K\"Value\"]\n+\n+    end\n+end"
    },
    {
      "sha": "ab25aaa0b70155948ca2f6d02e7598f296559d64",
      "filename": "JuliaLowering/test/decls.jl",
      "status": "added",
      "additions": 121,
      "deletions": 0,
      "changes": 121,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdecls.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdecls.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fdecls.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,121 @@\n+@testset \"Declarations\" begin\n+\n+test_mod = Module()\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    local x::Int = 1.0\n+    x\n+end\n+\"\"\") === 1\n+\n+# In value position, yield the right hand side, not `x`\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    local x::Int = 1.0\n+end\n+\"\"\") === 1.0\n+\n+# Global decl in value position without assignment returns nothing\n+@test JuliaLowering.include_string(test_mod, \"global x_no_assign\") === nothing\n+\n+# Unadorned declarations\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = 0.0\n+    x::Int = a\n+    x\n+end\n+\"\"\") === 0\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    local x::Int = 1\n+    x1 = x\n+    x = 20.0\n+    x2 = x\n+    (x1,x2)\n+end\n+\"\"\") === (1, 20)\n+\n+# Global const mixes\n+@test JuliaLowering.include_string(test_mod, \"global x_g = 1\") === 1\n+@test Base.isdefinedglobal(test_mod, :x_g)\n+@test !Base.isconst(test_mod, :x_g)\n+@test test_mod.x_g === 1\n+\n+@test JuliaLowering.include_string(test_mod, \"const x_c = 1\") === 1\n+@test Base.isdefinedglobal(test_mod, :x_c)\n+@test Base.isconst(test_mod, :x_c)\n+@test test_mod.x_c === 1\n+\n+@test JuliaLowering.include_string(test_mod, \"global const x_gc = 1\") === 1\n+@test Base.isdefinedglobal(test_mod, :x_gc)\n+@test Base.isconst(test_mod, :x_gc)\n+@test test_mod.x_gc === 1\n+\n+@test JuliaLowering.include_string(test_mod, \"const global x_cg = 1\") === 1\n+@test Base.isdefinedglobal(test_mod, :x_cg)\n+@test Base.isconst(test_mod, :x_cg)\n+@test test_mod.x_cg === 1\n+# Possibly worth testing excessive global/const keywords or invalid combinations\n+# (local + global/const) once we decide whether that's a parse error or a\n+# lowering error\n+\n+# Global decls with types\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+global a_typed_global::Int = 10.0\n+\"\"\") === 10.0\n+@test Core.get_binding_type(test_mod, :a_typed_global) === Int\n+@test test_mod.a_typed_global === 10\n+\n+# Also allowed in nontrivial scopes in a top level thunk\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    global a_typed_global_2::Int = 10.0\n+end\n+\"\"\") === 10.0\n+@test Core.get_binding_type(test_mod, :a_typed_global_2) === Int\n+@test test_mod.a_typed_global_2 === 10\n+\n+@test JuliaLowering.include_string(test_mod, \"const x_c_T::Int = 9\") === 9\n+@test Base.isdefinedglobal(test_mod, :x_c_T)\n+@test Base.isconst(test_mod, :x_c_T)\n+\n+@testset \"typed const redeclaration\" begin\n+    # redeclaration of the same value used to be allowed\n+    @test_throws ErrorException JuliaLowering.include_string(test_mod, \"x_c_T = 9\")\n+    @test_throws ErrorException JuliaLowering.include_string(test_mod, \"x_c_T = 10\")\n+    # redeclaration with const should be OK\n+    @test JuliaLowering.include_string(test_mod, \"const x_c_T::Int = 0\") === 0\n+end\n+\n+# Tuple/destructuring assignments\n+@test JuliaLowering.include_string(test_mod, \"(a0, a1, a2) = [1,2,3]\") == [1,2,3]\n+\n+@test JuliaLowering.include_string(test_mod, \"const a,b,c = 1,2,3\") === (1, 2, 3)\n+\n+test_mod_2 = Module()\n+@testset \"toplevel-preserving syntax\" begin\n+    JuliaLowering.include_string(test_mod_2, \"if true; global v1::Bool; else const v1 = 1; end\")\n+    @test !isdefined(test_mod_2, :v1)\n+    @test Base.binding_kind(test_mod_2, :v1) == Base.PARTITION_KIND_GLOBAL\n+    @test Core.get_binding_type(test_mod_2, :v1) == Bool\n+\n+    JuliaLowering.include_string(test_mod_2, \"if false; global v2::Bool; else const v2 = 2; end\")\n+    @test test_mod_2.v2 === 2\n+    @test Base.binding_kind(test_mod_2, :v2) == Base.PARTITION_KIND_CONST\n+\n+    JuliaLowering.include_string(test_mod_2, \"v3 = if true; global v4::Bool; 4 else const v4 = 5; 6; end\")\n+    @test test_mod_2.v3 == 4\n+    @test !isdefined(test_mod_2, :v4)\n+    @test Base.binding_kind(test_mod_2, :v4) == Base.PARTITION_KIND_GLOBAL\n+    @test Core.get_binding_type(test_mod_2, :v4) == Bool\n+\n+    JuliaLowering.include_string(test_mod_2, \"v5 = if false; global v6::Bool; 4 else const v6 = 5; 6; end\")\n+    @test test_mod_2.v5 === 6\n+    @test test_mod_2.v6 === 5\n+    @test Base.binding_kind(test_mod_2, :v6) == Base.PARTITION_KIND_CONST\n+end\n+\n+end"
    },
    {
      "sha": "1092b4d70d3f58a1b2af99feb3573c349fba02e7",
      "filename": "JuliaLowering/test/decls_ir.jl",
      "status": "added",
      "additions": 299,
      "deletions": 0,
      "changes": 299,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdecls_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdecls_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fdecls_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,299 @@\n+########################################\n+# Local declaration with type\n+begin\n+    local x::T = 1\n+end\n+#---------------------\n+1   (newvar slot\u2081/x)\n+2   1\n+3   TestMod.T\n+4   (= slot\u2082/tmp %\u2082)\n+5   slot\u2082/tmp\n+6   (call core.isa %\u2085 %\u2083)\n+7   (gotoifnot %\u2086 label\u2089)\n+8   (goto label\u2081\u2082)\n+9   slot\u2082/tmp\n+10  (call top.convert %\u2083 %\u2089)\n+11  (= slot\u2082/tmp (call core.typeassert %\u2081\u2080 %\u2083))\n+12  slot\u2082/tmp\n+13  (= slot\u2081/x %\u2081\u2082)\n+14  (return %\u2082)\n+\n+########################################\n+# Error: Local declarations outside a scope are disallowed\n+# See https://github.com/JuliaLang/julia/issues/57483\n+local x\n+#---------------------\n+LoweringError:\n+local x\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 local declarations have no effect outside a scope\n+\n+########################################\n+# Local declaration allowed in tail position\n+begin\n+    local x\n+end\n+#---------------------\n+1   (newvar slot\u2081/x)\n+2   (return core.nothing)\n+\n+########################################\n+# Local declaration allowed in value position\n+# TODO: This may be a bug in flisp lowering - should we reconsider this?\n+let\n+    y = local x\n+end\n+#---------------------\n+1   (newvar slot\u2081/x)\n+2   core.nothing\n+3   (= slot\u2082/y %\u2082)\n+4   (return %\u2082)\n+\n+########################################\n+# Global declaration allowed in tail position\n+global x\n+#---------------------\n+1   (call core.declare_global TestMod :x false)\n+2   latestworld\n+3   (return core.nothing)\n+\n+########################################\n+# Global declaration allowed in tail position, nested\n+begin\n+    global x\n+end\n+#---------------------\n+1   (call core.declare_global TestMod :x false)\n+2   latestworld\n+3   (return core.nothing)\n+\n+########################################\n+# Error: Global declaration not allowed in tail position in functions\n+function f()\n+    global x\n+end\n+#---------------------\n+LoweringError:\n+function f()\n+    global x\n+#          \u2559 \u2500\u2500 global declaration doesn't read the variable and can't return a value\n+end\n+\n+########################################\n+# Error: Global declaration not allowed in value position\n+y = global x\n+#---------------------\n+LoweringError:\n+y = global x\n+#          \u2559 \u2500\u2500 global declaration doesn't read the variable and can't return a value\n+\n+########################################\n+# const\n+const xx = 10\n+#---------------------\n+1   10\n+2   (call core.declare_const TestMod :xx %\u2081)\n+3   latestworld\n+4   (return %\u2081)\n+\n+########################################\n+# Typed const\n+const xx::T = 10\n+#---------------------\n+1   TestMod.T\n+2   (= slot\u2081/tmp 10)\n+3   slot\u2081/tmp\n+4   (call core.isa %\u2083 %\u2081)\n+5   (gotoifnot %\u2084 label\u2087)\n+6   (goto label\u2081\u2080)\n+7   slot\u2081/tmp\n+8   (call top.convert %\u2081 %\u2087)\n+9   (= slot\u2081/tmp (call core.typeassert %\u2088 %\u2081))\n+10  slot\u2081/tmp\n+11  (call core.declare_const TestMod :xx %\u2081\u2080)\n+12  latestworld\n+13  (return %\u2081\u2080)\n+\n+########################################\n+# Const tuple\n+const xxx,xxxx,xxxxx = 10,20,30\n+#---------------------\n+1   10\n+2   (call core.declare_const TestMod :xxx %\u2081)\n+3   latestworld\n+4   20\n+5   (call core.declare_const TestMod :xxxx %\u2084)\n+6   latestworld\n+7   30\n+8   (call core.declare_const TestMod :xxxxx %\u2087)\n+9   latestworld\n+10  (call core.tuple 10 20 30)\n+11  (return %\u2081\u2080)\n+\n+########################################\n+# Const in chain: only first is const\n+const c0 = v0 = v1 = 123\n+#---------------------\n+1   123\n+2   (call core.declare_const TestMod :c0 %\u2081)\n+3   latestworld\n+4   (call core.declare_global TestMod :v0 true)\n+5   latestworld\n+6   (call core.get_binding_type TestMod :v0)\n+7   (= slot\u2081/tmp %\u2081)\n+8   slot\u2081/tmp\n+9   (call core.isa %\u2088 %\u2086)\n+10  (gotoifnot %\u2089 label\u2081\u2082)\n+11  (goto label\u2081\u2084)\n+12  slot\u2081/tmp\n+13  (= slot\u2081/tmp (call top.convert %\u2086 %\u2081\u2082))\n+14  slot\u2081/tmp\n+15  (call core.setglobal! TestMod :v0 %\u2081\u2084)\n+16  (call core.declare_global TestMod :v1 true)\n+17  latestworld\n+18  (call core.get_binding_type TestMod :v1)\n+19  (= slot\u2082/tmp %\u2081)\n+20  slot\u2082/tmp\n+21  (call core.isa %\u2082\u2080 %\u2081\u2088)\n+22  (gotoifnot %\u2082\u2081 label\u2082\u2084)\n+23  (goto label\u2082\u2086)\n+24  slot\u2082/tmp\n+25  (= slot\u2082/tmp (call top.convert %\u2081\u2088 %\u2082\u2084))\n+26  slot\u2082/tmp\n+27  (call core.setglobal! TestMod :v1 %\u2082\u2086)\n+28  (return %\u2081)\n+\n+########################################\n+# Global assignment\n+xx = 10\n+#---------------------\n+1   (call core.declare_global TestMod :xx true)\n+2   latestworld\n+3   (call core.get_binding_type TestMod :xx)\n+4   (= slot\u2081/tmp 10)\n+5   slot\u2081/tmp\n+6   (call core.isa %\u2085 %\u2083)\n+7   (gotoifnot %\u2086 label\u2089)\n+8   (goto label\u2081\u2081)\n+9   slot\u2081/tmp\n+10  (= slot\u2081/tmp (call top.convert %\u2083 %\u2089))\n+11  slot\u2081/tmp\n+12  (call core.setglobal! TestMod :xx %\u2081\u2081)\n+13  (return 10)\n+\n+########################################\n+# Typed global assignment\n+global xx::T = 10\n+#---------------------\n+1   (call core.declare_global TestMod :xx false)\n+2   latestworld\n+3   TestMod.T\n+4   (call core.declare_global TestMod :xx true %\u2083)\n+5   latestworld\n+6   (call core.declare_global TestMod :xx true)\n+7   latestworld\n+8   (call core.get_binding_type TestMod :xx)\n+9   (= slot\u2081/tmp 10)\n+10  slot\u2081/tmp\n+11  (call core.isa %\u2081\u2080 %\u2088)\n+12  (gotoifnot %\u2081\u2081 label\u2081\u2084)\n+13  (goto label\u2081\u2086)\n+14  slot\u2081/tmp\n+15  (= slot\u2081/tmp (call top.convert %\u2088 %\u2081\u2084))\n+16  slot\u2081/tmp\n+17  (call core.setglobal! TestMod :xx %\u2081\u2086)\n+18  (return 10)\n+\n+########################################\n+# Error: x declared twice\n+begin\n+    local x::T = 1\n+    local x::S = 1\n+end\n+#---------------------\n+LoweringError:\n+begin\n+    local x::T = 1\n+    local x::S = 1\n+#        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 multiple type declarations found for `x`\n+end\n+\n+########################################\n+# Error: Const not supported on locals\n+const local x = 1\n+#---------------------\n+LoweringError:\n+const local x = 1\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 unsupported `const local` declaration\n+\n+########################################\n+# Error: Const not supported on locals\n+let\n+    const x = 1\n+end\n+#---------------------\n+LoweringError:\n+let\n+    const x = 1\n+#        \u2514\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 unsupported `const` declaration on local variable\n+end\n+\n+########################################\n+# Type decl on function argument\n+function f(x)\n+    x::Int = 1\n+    x = 2.0\n+    x\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084 core.Any)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/tmp(!read) slot\u2084/tmp(!read)]\n+    1   1\n+    2   TestMod.Int\n+    3   (= slot\u2083/tmp %\u2081)\n+    4   slot\u2083/tmp\n+    5   (call core.isa %\u2084 %\u2082)\n+    6   (gotoifnot %\u2085 label\u2088)\n+    7   (goto label\u2081\u2081)\n+    8   slot\u2083/tmp\n+    9   (call top.convert %\u2082 %\u2088)\n+    10  (= slot\u2083/tmp (call core.typeassert %\u2089 %\u2082))\n+    11  slot\u2083/tmp\n+    12  (= slot\u2082/x %\u2081\u2081)\n+    13  2.0\n+    14  TestMod.Int\n+    15  (= slot\u2084/tmp %\u2081\u2083)\n+    16  slot\u2084/tmp\n+    17  (call core.isa %\u2081\u2086 %\u2081\u2084)\n+    18  (gotoifnot %\u2081\u2087 label\u2082\u2080)\n+    19  (goto label\u2082\u2083)\n+    20  slot\u2084/tmp\n+    21  (call top.convert %\u2081\u2084 %\u2082\u2080)\n+    22  (= slot\u2084/tmp (call core.typeassert %\u2082\u2081 %\u2081\u2084))\n+    23  slot\u2084/tmp\n+    24  (= slot\u2082/x %\u2082\u2083)\n+    25  slot\u2082/x\n+    26  (return %\u2082\u2085)\n+10  latestworld\n+11  TestMod.f\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Error: global type decls only allowed at top level\n+function f()\n+    global x::Int = 1\n+end\n+#---------------------\n+LoweringError:\n+function f()\n+    global x::Int = 1\n+#         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 type declarations for global variables must be at top level, not inside a function\n+end"
    },
    {
      "sha": "0b2fe25a82cc24aa7e9cbe0a4212524b1e528f2b",
      "filename": "JuliaLowering/test/demo.jl",
      "status": "added",
      "additions": 910,
      "deletions": 0,
      "changes": 910,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdemo.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdemo.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fdemo.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,910 @@\n+# Just some hacking\n+\n+using JuliaSyntax\n+using JuliaLowering\n+\n+using JuliaLowering: SyntaxGraph, SyntaxTree, ensure_attributes!, ensure_attributes, newnode!, setchildren!, is_leaf, @ast, numchildren, children, child, setattr!, sourceref, makenode, sourcetext, showprov, lookup_binding\n+\n+using JuliaSyntaxFormatter\n+\n+# Extract variable kind for highlighting purposes\n+function var_kind(ctx, ex)\n+    id = get(ex, :var_id, nothing)\n+    if isnothing(id)\n+        return nothing\n+    end\n+    binfo = lookup_binding(ctx, id)\n+    return binfo.kind == :local ?\n+        (binfo.is_captured ? :local_captured : :local) :\n+        binfo.kind\n+end\n+\n+# Extract module of globals for highlighting\n+function var_mod(ctx, ex)\n+    id = get(ex, :var_id, nothing)\n+    if isnothing(id)\n+        return nothing\n+    end\n+    return lookup_binding(ctx, id).mod\n+end\n+\n+function formatsrc(ex; kws...)\n+    Text(JuliaSyntaxFormatter.formatsrc(ex; kws...))\n+end\n+\n+function debug_lower(mod::Module, ex::SyntaxTree; expr_compat_mode::Bool=false, verbose::Bool=false, do_eval::Bool=false)\n+    ctx1, ex_macroexpand = JuliaLowering.expand_forms_1(mod, ex, expr_compat_mode, Base.get_world_counter())\n+\n+    verbose && @info \"Macro expanded\" formatsrc(ex_macroexpand, color_by=:scope_layer)\n+\n+    ctx2, ex_desugar = JuliaLowering.expand_forms_2(ctx1, ex_macroexpand)\n+    verbose && @info \"Desugared\" formatsrc(ex_desugar, color_by=:scope_layer)\n+\n+    ctx3, ex_scoped = JuliaLowering.resolve_scopes(ctx2, ex_desugar)\n+    verbose && @info \"Resolved scopes\" formatsrc(ex_scoped, color_by=e->var_kind(ctx2,e))\n+\n+    ctx4, ex_converted = JuliaLowering.convert_closures(ctx3, ex_scoped)\n+    verbose && @info \"Closure converted\" formatsrc(ex_converted, color_by=:var_id)\n+\n+    ctx5, ex_compiled = JuliaLowering.linearize_ir(ctx4, ex_converted)\n+    verbose && @info \"Linear IR\" formatsrc(ex_compiled, color_by=:var_id) Text(sprint(JuliaLowering.print_ir, ex_compiled))\n+\n+    ex_expr = JuliaLowering.to_lowered_expr(ex_compiled)\n+    verbose && @info \"CodeInfo\" ex_expr\n+\n+    if do_eval\n+        eval_result = Base.eval(mod, ex_expr)\n+        verbose && @info \"Eval\" eval_result\n+    else\n+        eval_result = nothing\n+    end\n+\n+    (ctx1, ex_macroexpand, ctx2, ex_desugar, ctx3, ex_scoped, ctx4, ex_converted, ctx5, ex_compiled, ex_expr, eval_result)\n+end\n+\n+\n+# Currently broken - need to push info back onto src\n+# function annotate_scopes(mod, ex)\n+#     ex = ensure_attributes(ex, var_id=Int)\n+#     ctx1, ex_macroexpand = JuliaLowering.expand_forms_1(mod, ex, false)\n+#     ctx2, ex_desugar = JuliaLowering.expand_forms_2(ctx1, ex_macroexpand)\n+#     ctx3, ex_scoped = JuliaLowering.resolve_scopes(ctx2, ex_desugar)\n+#     ex\n+# end\n+\n+#-------------------------------------------------------------------------------\n+# Module containing macros used in the demo.\n+define_macros = false\n+if !define_macros\n+    eval(:(module M end))\n+else\n+eval(JuliaLowering.@SyntaxTree :(baremodule M\n+    using Base\n+\n+    using JuliaLowering: JuliaLowering, @ast, @chk, adopt_scope, MacroExpansionError, makenode\n+    using JuliaSyntax\n+    using JuliaLowering: @inert, @label, @goto, @islocal\n+    using Base: @locals\n+\n+    macro K_str(str)\n+        JuliaSyntax.Kind(str)\n+    end\n+\n+    # Introspection\n+    macro __MODULE__()\n+        __context__.scope_layer.mod\n+    end\n+\n+    macro __FILE__()\n+        JuliaLowering.filename(__context__.macrocall)\n+    end\n+\n+    macro __LINE__()\n+        JuliaLowering.source_location(__context__.macrocall)[1]\n+    end\n+\n+    # Macro with local variables\n+    module A\n+        another_global = \"global in A\"\n+\n+        macro bar(ex)\n+            quote\n+                x = \"`x` in @bar\"\n+                (x, another_global, $ex)\n+            end\n+        end\n+    end\n+\n+    someglobal = \"global in module M\"\n+\n+    # Macro with local variables\n+    macro foo(ex)\n+        quote\n+            x = \"`x` from @foo\"\n+            (x, someglobal, A.@bar $ex)\n+            #(x, someglobal, $ex, A.@bar($ex), A.@bar(x))\n+        end\n+    end\n+\n+    macro call_show(x)\n+        quote\n+            z = \"z in @call_show\"\n+            @show z $x\n+        end\n+    end\n+\n+    macro call_info(x)\n+        quote\n+            z = \"z in @call_info\"\n+            @info \"hi\" z $x\n+        end\n+    end\n+\n+    macro call_oldstyle_macro(y)\n+        quote\n+            x = \"x in call_oldstyle_macro\"\n+            @oldstyle $y x\n+        end\n+    end\n+\n+    macro newstyle(x, y, z)\n+        quote\n+            x = \"x in @newstyle\"\n+            ($x, $y, $z, x)\n+        end\n+    end\n+\n+    macro set_a_global(val)\n+        quote\n+            global a_global = $val\n+        end\n+    end\n+\n+    macro set_global_in_parent(ex)\n+        e1 = adopt_scope(:(sym_introduced_from_M), __context__)\n+        quote\n+            $e1 = $ex\n+        end\n+    end\n+\n+    macro baz(ex)\n+        quote\n+            let $ex = 10\n+                $ex\n+            end\n+        end\n+    end\n+\n+    macro make_module()\n+        :(module X\n+              blah = 10\n+          end)\n+    end\n+\n+    macro return_a_value()\n+        42\n+    end\n+\n+    macro nested_return_a_value()\n+        :(\n+            @return_a_value\n+        )\n+    end\n+\n+    macro inner()\n+        :(2)\n+    end\n+\n+    macro outer()\n+        :((1, @inner))\n+    end\n+\n+    macro K_str(str)\n+        JuliaSyntax.Kind(str[1].value)\n+    end\n+\n+    # Recursive macro call\n+    macro recursive(N)\n+        Nval = if kind(N) == K\"Integer\" || kind(N) == K\"Value\"\n+            N.value\n+        end\n+        if !(Nval isa Integer)\n+            throw(MacroExpansionError(N, \"argument must be an integer\"))\n+        end\n+        if Nval < 1\n+            return N\n+        end\n+        quote\n+            x = $N\n+            (@recursive($(Nval-1)), x)\n+        end\n+    end\n+\n+    xx = \"xx in M\"\n+\n+    macro test_inert_quote()\n+        println(xx)\n+        @inert quote\n+            ($xx, xx)\n+        end\n+    end\n+\n+    macro mmm(ex)\n+        :(let\n+              local x\n+              function f()\n+                  (x, $ex)\n+              end\n+              f()\n+          end)\n+    end\n+\n+end))\n+end\n+\n+Base.eval(M, :(\n+macro oldstyle(a, b)\n+    quote\n+        x = \"x in @oldstyle\"\n+        @newstyle $(esc(a)) $(esc(b)) x\n+    end\n+end\n+))\n+\n+#\n+#-------------------------------------------------------------------------------\n+# Demos of the prototype\n+\n+# src = \"\"\"\n+# let\n+#     local x, (y = 2), (w::T = ww), q::S\n+# end\n+# \"\"\"\n+\n+# src = \"\"\"\n+# function foo(x::f(T), y::w(let ; S end))\n+#     \"a \\$(\"b \\$(\"c\")\")\"\n+# end\n+# \"\"\"\n+\n+src = \"\"\"\n+begin\n+    function f(x)\n+        nothing\n+    end\n+\n+    f(1)\n+end\n+\"\"\"\n+\n+# src = \"\"\"\n+#     x + y\n+# \"\"\"\n+\n+# src = \"\"\"\n+# module A\n+#     function f(x)::Int\n+#         x + 1\n+#     end\n+#\n+#     b = f(2)\n+# end\n+# \"\"\"\n+\n+# src = \"\"\"\n+# function f()\n+# end\n+# \"\"\"\n+#\n+# src = \"\"\"\n+# # import A.B: C.c as d, E.e as f\n+# # import JuliaLowering\n+# using JuliaLowering\n+# \"\"\"\n+#\n+# src = \"\"\"\n+# module A\n+#     z = 1 + 1\n+# end\n+# \"\"\"\n+\n+src = raw\"\"\"\n+begin\n+    x = 10\n+    y = :(g(z))\n+    quote\n+        f($(x+1), $y)\n+    end\n+end\n+\"\"\"\n+\n+function wrapscope(ex, scope_type)\n+    makenode(ex, ex, K\"scope_block\", ex; scope_type=scope_type)\n+end\n+\n+function softscope_test(ex)\n+    g = ensure_attributes(ex._graph, scope_type=Symbol)\n+    wrapscope(wrapscope(JuliaLowering.reparent(g, ex), :neutral), :soft)\n+end\n+\n+# src = \"\"\"\n+# M.@test_inert_quote()\n+# \"\"\"\n+\n+# src = \"\"\"\n+# macro mmm(a; b=2)\n+# end\n+# macro A.b(ex)\n+# end\n+# \"\"\"\n+\n+# src = \"\"\"\n+# M.@set_global_in_parent \"bent hygiene!\"\n+# \"\"\"\n+\n+# src = \"\"\"\n+# begin\n+# M.@__LINE__\n+# end\n+# \"\"\"\n+\n+# src = \"\"\"@foo z\"\"\"\n+\n+src = \"\"\"\n+M.@recursive 3\n+\"\"\"\n+\n+# src = \"\"\"\n+# M.@set_global_in_parent \"bent hygiene!\"\n+# \"\"\"\n+\n+# src = \"\"\"\n+# begin\n+#    x = 10\n+#    y = 20\n+#    let x = y + x\n+#        z = \"some string \\$x \\$y\"\n+#\n+#        function f(y)\n+#            a = M.@foo z\n+#            \"\\$z \\$y \\$a \\$x\"\n+#        end\n+#        print(x)\n+#    end\n+#    print(x)\n+# end\n+# \"\"\"\n+\n+# src = \"\"\"\n+# begin\n+#     x = -1\n+#     M.@baz x\n+# end\n+# \"\"\"\n+\n+# src = \"\"\"\n+#     _ = -1\n+# \"\"\"\n+\n+# src = \"\"\"\n+# M.@make_module\n+# \"\"\"\n+\n+# src = \"\"\"\n+# M.@nested_return_a_value\n+# \"\"\"\n+\n+# src = \"\"\"\n+# function f(y)\n+#     x = 42 + y\n+#     M.@foo error(x)\n+# end\n+# \"\"\"\n+\n+src = \"\"\"\n+let\n+    y = 0\n+    x = 1\n+    let x = x + 1\n+        y = x\n+    end\n+    (x, y)\n+end\n+\"\"\"\n+\n+#src = \"\"\"M.@outer\"\"\"\n+\n+src = \"\"\"\n+begin\n+    local a, b, c\n+    if a\n+        b\n+    else\n+        c\n+    end\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+begin\n+    local i = 0\n+    while i < 10\n+        i = i + 1\n+        if isodd(i)\n+            continue\n+        end\n+        println(i)\n+    end\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+for i in [3,1,2]\n+    println(\"i = \", i, \", j = \", j)\n+end\n+\"\"\"\n+\n+# src = \"\"\"\n+# @ccall f()::T\n+# \"\"\"\n+#\n+# src = \"\"\"\n+# begin\n+#     a = 1\n+#     xs = [:(a),]\n+#     x = :(:(\\$(\\$(xs...))))\n+# end\n+# \"\"\"\n+\n+# src = \"\"\"\n+# try\n+#     a\n+# catch exc\n+#     b\n+# end\n+# \"\"\"\n+\n+src = \"\"\"\n+let\n+    a = []\n+    for i = 1:2, j = 3:4\n+        push!(a, (i,j))\n+        i = 100\n+    end\n+    a\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+begin\n+    function f(x)\n+        y = x + 1\n+        \"hi\", x, y\n+    end\n+\n+    f(1)\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    x = try\n+        error(\"hi\")\n+        1\n+    catch exc\n+        current_exceptions()\n+    else\n+        3\n+    end\n+    x\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+function f(y)\n+    x =\n+    try\n+        try\n+            error(\"hi\")\n+            1\n+        catch exc\n+            if y\n+                return 2\n+            end\n+            3\n+        else\n+            4\n+        end\n+    catch\n+        5\n+    end\n+    x\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+function f(x)::Int\n+    if x\n+        42.0\n+    end\n+    0xff\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let x = 10\n+    global a = []\n+    try\n+        try\n+            return 100\n+        finally\n+            push!(a, 1)\n+        end\n+    finally\n+        push!(a, 2)\n+    end\n+    x\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    for outer i = 1:2\n+        body\n+    end\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    i = \"hi\"\n+    j = 1\n+    M.@label foo\n+    try\n+        println(\"i = \", i)\n+        i = i + 1\n+        if i <= 2\n+            M.@goto foo\n+        end\n+    catch exc\n+        println(\"Caught exception \", exc)\n+        j = j + 1\n+        if j <= 2\n+            println(\"Trying again \", exc)\n+            M.@goto foo\n+        end\n+    end\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    M.@goto foo\n+    M.@label foo\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+x = M.@label foo\n+\"\"\"\n+\n+src = \"\"\"\n+begin\n+    local x::T = 1\n+    local x::S = 1\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+begin\n+    local a, b\n+    if a\n+        b\n+    end\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    A{S} = B{S}\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    a = b = c = sin(1)\n+    (a,b,c)\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+a.b = c\n+\"\"\"\n+\n+src = \"\"\"\n+a[i j] = c\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    as = [1,2,3,4]\n+    (x,ys...,z) = as\n+    (x,ys,z)\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    x = (1,2)\n+    (y,x) = x\n+    (x,y)\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    a = b = c = sin(1)\n+    (a,b,c)\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+begin\n+    as = [(1,2), (3,4)]\n+    ((x,y), (z,w)) = as\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+(x, y) = (y,x)\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let x = 1\n+    M.@islocal x\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let x = 1\n+    local y\n+    M.@locals\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    (a, bs...,) = (1,2,3)\n+    bs\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+(; a=1, a=2)\n+\"\"\"\n+\n+src = \"\"\"\n+begin\n+    kws = (c=3, d=4)\n+    xs = 1:3\n+    f(xs...; kws..., a=1, b=2)\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+\"some docs\"\n+function f()\n+    println(\"hi\")\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+function f(::T, ::U, ::S) where T where {U,S}\n+    println(T)\n+    println(U)\n+    println(S)\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+function (x::XXX)(y)\n+    println(\"hi\", \" \", x, \" \", y)\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+struct X\n+    x\n+    y::String\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+struct X{U,V}\n+    x::U\n+    y::V\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+struct S9{T}\n+    x\n+    y\n+\n+    \"Docs for S9\"\n+    S9{Int}(xs) = new(xs...)\n+end\n+\"\"\"\n+\n+# Default positional args with missing arg names\n+src = \"\"\"\n+function f(::Int, y=1, z=2)\n+    (y, z)\n+end\n+\"\"\"\n+\n+# Default positional args with placeholders\n+src = \"\"\"\n+function f(_::Int, x=1)\n+    x\n+end\n+\"\"\"\n+\n+# Positional args and type parameters with transitive dependencies\n+# Bug in flisp lowering - see https://github.com/JuliaLang/julia/issues/49275\n+src = \"\"\"\n+function f(x, y::S=[1], z) where {T, S<:AbstractVector{T}}\n+    (x, y, z, T)\n+end\n+\"\"\"\n+\n+# Default positional args before trailing slurp are allowed\n+src = \"\"\"\n+function f(x=1, ys...)\n+    ys\n+end\n+\"\"\"\n+\n+# Default positional args after a slurp is an error\n+src = \"\"\"\n+function f(x=1, ys..., z=2)\n+    ys\n+end\n+\"\"\"\n+\n+# Positional arg with slurp and default\n+src = \"\"\"\n+function f(x=1, ys...=\"hi\")\n+    ys\n+end\n+\"\"\"\n+\n+# Positional arg with slurp and splat\n+src = \"\"\"\n+function f(x=1, ys...=(1,2)...)\n+    ys\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    x = 10\n+    function f(y)\n+        x + y\n+    end\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+begin\n+    local f, set_x\n+    local x = 10\n+    local y = 100\n+    function f()\n+        z = 1 + y - x\n+        z\n+    end\n+    function set_x()\n+        x = 1\n+    end\n+    println(\"f = \", f())\n+    set_x()\n+    y = 10\n+    println(\"f = \", f())\n+end\n+\"\"\"\n+\n+# TODO: fix this - it's interpreted in a bizarre way as a kw call.\n+# src = \"\"\"\n+# function f(x=y=1)\n+#     x\n+# end\n+# \"\"\"\n+\n+function gen_stuff(ctx, N, x)\n+    JuliaLowering.@ast ctx ctx.macrocall [K\"tuple\"\n+        (i::K\"Integer\" for i in 1:N)...\n+    ]\n+end\n+\n+src = raw\"\"\"\n+function gen(x::NTuple{N}) where {N}\n+    nongen_stuff = :nongen\n+    if @generated\n+        quote\n+            maybe_gen_stuff = ($N, $x)\n+        end\n+    else\n+        maybe_gen_stuff = :nongen_2\n+    end\n+    (nongen_stuff, maybe_gen_stuff)\n+end\n+\"\"\"\n+\n+src = raw\"\"\"\n+begin\n+    function partially_gen(x::NTuple{N,T}) where {N,T}\n+        shared = :shared_stuff\n+        if @generated\n+            quote\n+                unshared = ($x, $N, $T)\n+            end\n+        else\n+            # Uuuum. How do we test both sides of this branch??\n+            unshared = :nongen # (typeof(x), N, T)\n+        end\n+        (shared, unshared)\n+    end\n+\n+    partially_gen((1,2,3,4,5))\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    z = \"z in outer ctx\"\n+    @call_show z\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    x = \"x in outer ctx\"\n+    @call_oldstyle_macro x\n+end\n+\"\"\"\n+\n+src = \"\"\"\n+let\n+    z = \"z in outer ctx\"\n+    @call_info z\n+end\n+\"\"\"\n+\n+ex = parsestmt(SyntaxTree, src, filename=\"foo.jl\")\n+#ex = ensure_attributes(ex, var_id=Int)\n+#ex = softscope_test(ex)\n+@info \"Input code\" formatsrc(ex)\n+\n+(ctx1, ex_macroexpand,\n+ ctx2, ex_desugar,\n+ ctx3, ex_scoped,\n+ ctx4, ex_converted,\n+ ctx5, ex_compiled,\n+ ex_expr, eval_result) = debug_lower(M, ex; verbose=true, do_eval=true)\n+\n+# Automatic test reduction\n+# bad = reduce_any_failing_toplevel(JuliaLowering, joinpath(@__DIR__, \"../src/desugaring.jl\"))\n+# if !isnothing(bad)\n+#     @error \"Reduced expression as code\" formatsrc(bad)\n+#     write(\"bad.jl\", JuliaSyntaxFormatter.formatsrc(bad))\n+# end\n+\n+# Old lowering\n+# text = read(joinpath(@__DIR__, \"../src/desugaring.jl\"), String)\n+# ex = parseall(SyntaxTree, text, filename=\"desugaring.jl\")\n+# for e in Meta.parseall(text).args\n+#     Meta.lower(JuliaLowering, e)\n+# end"
    },
    {
      "sha": "6158d8bc28ebf5a271205b7dcc40e2963e0487df",
      "filename": "JuliaLowering/test/destructuring.jl",
      "status": "added",
      "additions": 225,
      "deletions": 0,
      "changes": 225,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdestructuring.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdestructuring.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fdestructuring.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,225 @@\n+@testset \"Destructuring\" begin\n+\n+test_mod = Module()\n+\n+@testset \"Destructuring via iteration\" begin\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    as = [1,2,3]\n+    (x,y) = as\n+    (x,y)\n+end\n+\"\"\") == (1,2)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    as = [1,2,3]\n+    (x,ys...) = as\n+    (x,ys)\n+end\n+\"\"\") == (1, [2,3])\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    as = [1,2,3,4]\n+    (x,ys...,z) = as\n+    (x,ys,z)\n+end\n+\"\"\") == (1, [2, 3], 4)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    as = [1,2,3,4]\n+    (xs...,y) = as\n+    (xs,y)\n+end\n+\"\"\") == ([1, 2, 3], 4)\n+\n+# Case where indexed_iterate is just iteration\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    (x,ys...,z) = \"a\u03b2c\u03b4e\"\n+    (x,ys,z)\n+end\n+\"\"\") == ('a', \"\u03b2c\u03b4\", 'e')\n+\n+\n+# Use in value position yields rhs\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    as = [1,2]\n+    zs = begin\n+        (x,y) = as\n+    end\n+    (x,y, as === zs)\n+end\n+\"\"\") == (1, 2, true)\n+\n+# lhs variable name in rhs\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = (1,2)\n+    (x,y) = x\n+    (x,y)\n+end\n+\"\"\") == (1, 2)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = (1,2)\n+    (x...,y) = x\n+    (x,y)\n+end\n+\"\"\") == ((1,), 2)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    zs = [(1,2), (3,(4,5))]\n+    ((a,b), (c,(d,e))) = zs\n+    (a,b,c,d,e)\n+end\n+\"\"\") == (1,2,3,4,5)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    zs = [[1,2,3], 4]\n+    ((a,bs...), c) = zs\n+    (a, bs, c)\n+end\n+\"\"\") == (1, [2,3], 4)\n+\n+end\n+\n+\n+@testset \"Tuple elimination with tuples on both sides\" begin\n+\n+# Simple case\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = 1, b = 2\n+    (x,y) = (a,b)\n+    (x,y)\n+end\n+\"\"\") == (1, 2)\n+\n+# lhs variable name in rhs\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x = 1, y = 2\n+    (x,y) = (y,x)\n+    (x,y)\n+end\n+\"\"\") == (2, 1)\n+\n+# Slurps and splats\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = 1, b = 2, c = 3\n+    (x, ys..., z) = (a, b, c)\n+    (x, ys, z)\n+end\n+\"\"\") == (1, (2,), 3)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = 1, b = 2, cs = (3,4)\n+    (x, ys...) = (a, b, cs...)\n+    (x, ys)\n+end\n+\"\"\") == (1, (2,3,4))\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = 1, bs = (2,3), c = 4\n+    (x, ys...) = (a, bs..., c)\n+    (x, ys)\n+end\n+\"\"\") == (1, (2,3,4))\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = 1, b = 2, cs = (3,4)\n+    (x, ys..., z) = (a, b, cs...)\n+    (x, ys, z)\n+end\n+\"\"\") == (1, (2,3), 4)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let a = 1\n+    (x, ys...) = (a,)\n+    (x, ys)\n+end\n+\"\"\") == (1, ())\n+\n+# dotted rhs in last place\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    rh = (2, 3)\n+    (x,y,z) = (1,rh...)\n+    (x,y,z)\n+end\n+\"\"\") == (1, 2, 3)\n+\n+# in value position\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    rh = (2, 3)\n+    (x,y) = (1,rh...)\n+end\n+\"\"\") == (1, 2, 3)\n+\n+# Side effects in the right hand tuple can affect the previous left hand side\n+# bindings, for example, `x`, below. In this case we need to ensure `f()` is\n+# called before `x` is assigned the value from the right hand side.\n+# (the flisp implementation fails this test.)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+   function f()\n+       x=100\n+       2\n+   end\n+   (x,y) = (1,f())\n+   x,y\n+end\n+\"\"\") == (1,2)\n+\n+# `x` is not assigned and no side effect from `f()` happens when the right hand\n+# side throws an UndefVarError\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x=1, y=2, z=3, side_effect=false, a\n+    exc = try\n+        function f()\n+            side_effect=true\n+        end\n+        (x,y,z) = (100, a, f())\n+    catch e\n+        e\n+    end\n+    (x, y, z, side_effect, exc.var)\n+end\n+\"\"\") == (1, 2, 3, false, :a)\n+\n+# Require that rhs is evaluated before any assignments, thus `x` is not defined\n+# here because accessing `a` first throws an UndefVarError\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x, y, a\n+    try\n+        (x, y) = (1, a)\n+    catch\n+    end\n+    @isdefined(x)\n+end\n+\"\"\") == false\n+\n+end\n+\n+\n+@testset \"Property destructuring\" begin\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    ab = (a=1, b=2)\n+    (; a, b) = ab\n+    (a, b)\n+end\n+\"\"\") == (1, 2)\n+\n+end\n+\n+end"
    },
    {
      "sha": "990096a87e916faa3c50f6d02049286c1f3eaeb9",
      "filename": "JuliaLowering/test/destructuring_ir.jl",
      "status": "added",
      "additions": 387,
      "deletions": 0,
      "changes": 387,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdestructuring_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdestructuring_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fdestructuring_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,387 @@\n+########################################\n+# Simple destructuring\n+let\n+    (x,y) = as\n+end\n+#---------------------\n+1   TestMod.as\n+2   (call top.indexed_iterate %\u2081 1)\n+3   (= slot\u2082/x (call core.getfield %\u2082 1))\n+4   (= slot\u2081/iterstate (call core.getfield %\u2082 2))\n+5   TestMod.as\n+6   slot\u2081/iterstate\n+7   (call top.indexed_iterate %\u2085 2 %\u2086)\n+8   (= slot\u2083/y (call core.getfield %\u2087 1))\n+9   TestMod.as\n+10  (return %\u2089)\n+\n+########################################\n+# Trivial slurping\n+let\n+    (xs...,) = as\n+end\n+#---------------------\n+1   TestMod.as\n+2   (= slot\u2081/xs (call top.rest %\u2081))\n+3   TestMod.as\n+4   (return %\u2083)\n+\n+########################################\n+# Slurping last arg\n+let\n+    (x, ys...) = as\n+end\n+#---------------------\n+1   TestMod.as\n+2   (call top.indexed_iterate %\u2081 1)\n+3   (= slot\u2082/x (call core.getfield %\u2082 1))\n+4   (= slot\u2081/iterstate (call core.getfield %\u2082 2))\n+5   TestMod.as\n+6   slot\u2081/iterstate\n+7   (= slot\u2083/ys (call top.rest %\u2085 %\u2086))\n+8   TestMod.as\n+9   (return %\u2088)\n+\n+########################################\n+# Slurping, first arg\n+let\n+    (xs..., y, z) = as\n+end\n+#---------------------\n+1   TestMod.as\n+2   (call top.split_rest %\u2081 2)\n+3   (= slot\u2082/xs (call core.getfield %\u2082 1))\n+4   (call core.getfield %\u2082 2)\n+5   (call top.indexed_iterate %\u2084 1)\n+6   (= slot\u2083/y (call core.getfield %\u2085 1))\n+7   (= slot\u2081/iterstate (call core.getfield %\u2085 2))\n+8   slot\u2081/iterstate\n+9   (call top.indexed_iterate %\u2084 2 %\u2088)\n+10  (= slot\u2084/z (call core.getfield %\u2089 1))\n+11  TestMod.as\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Slurping, middle arg\n+let\n+    (x, ys..., z) = as\n+end\n+#---------------------\n+1   TestMod.as\n+2   (call top.indexed_iterate %\u2081 1)\n+3   (= slot\u2082/x (call core.getfield %\u2082 1))\n+4   (= slot\u2081/iterstate (call core.getfield %\u2082 2))\n+5   TestMod.as\n+6   slot\u2081/iterstate\n+7   (call top.split_rest %\u2085 1 %\u2086)\n+8   (= slot\u2083/ys (call core.getfield %\u2087 1))\n+9   (call core.getfield %\u2087 2)\n+10  (call top.indexed_iterate %\u2089 1)\n+11  (= slot\u2084/z (call core.getfield %\u2081\u2080 1))\n+12  TestMod.as\n+13  (return %\u2081\u2082)\n+\n+########################################\n+# Error: Slurping multiple args\n+(xs..., ys...) = x\n+#---------------------\n+LoweringError:\n+(xs..., ys...) = x\n+#      \u2514\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 multiple `...` in destructuring assignment are ambiguous\n+\n+########################################\n+# Recursive destructuring\n+let\n+    ((x,y), (z,w)) = as\n+end\n+#---------------------\n+1   TestMod.as\n+2   (call top.indexed_iterate %\u2081 1)\n+3   (call core.getfield %\u2082 1)\n+4   (= slot\u2081/iterstate (call core.getfield %\u2082 2))\n+5   TestMod.as\n+6   slot\u2081/iterstate\n+7   (call top.indexed_iterate %\u2085 2 %\u2086)\n+8   (call core.getfield %\u2087 1)\n+9   (call top.indexed_iterate %\u2083 1)\n+10  (= slot\u2085/x (call core.getfield %\u2089 1))\n+11  (= slot\u2082/iterstate (call core.getfield %\u2089 2))\n+12  slot\u2082/iterstate\n+13  (call top.indexed_iterate %\u2083 2 %\u2081\u2082)\n+14  (= slot\u2086/y (call core.getfield %\u2081\u2083 1))\n+15  (call top.indexed_iterate %\u2088 1)\n+16  (= slot\u2087/z (call core.getfield %\u2081\u2085 1))\n+17  (= slot\u2083/iterstate (call core.getfield %\u2081\u2085 2))\n+18  slot\u2083/iterstate\n+19  (call top.indexed_iterate %\u2088 2 %\u2081\u2088)\n+20  (= slot\u2084/w (call core.getfield %\u2081\u2089 1))\n+21  TestMod.as\n+22  (return %\u2082\u2081)\n+\n+########################################\n+# Recursive destructuring with slurping\n+let\n+    ((x,ys...), z) = as\n+end\n+#---------------------\n+1   TestMod.as\n+2   (call top.indexed_iterate %\u2081 1)\n+3   (call core.getfield %\u2082 1)\n+4   (= slot\u2081/iterstate (call core.getfield %\u2082 2))\n+5   TestMod.as\n+6   slot\u2081/iterstate\n+7   (call top.indexed_iterate %\u2085 2 %\u2086)\n+8   (= slot\u2085/z (call core.getfield %\u2087 1))\n+9   (call top.indexed_iterate %\u2083 1)\n+10  (= slot\u2083/x (call core.getfield %\u2089 1))\n+11  (= slot\u2082/iterstate (call core.getfield %\u2089 2))\n+12  slot\u2082/iterstate\n+13  (= slot\u2084/ys (call top.rest %\u2083 %\u2081\u2082))\n+14  TestMod.as\n+15  (return %\u2081\u2084)\n+\n+########################################\n+# Destructuring with simple tuple elimination\n+let\n+    (x, y) = (a, b)\n+end\n+#---------------------\n+1   TestMod.a\n+2   TestMod.b\n+3   (= slot\u2081/x %\u2081)\n+4   (= slot\u2082/y %\u2082)\n+5   (call core.tuple %\u2081 %\u2082)\n+6   (return %\u2085)\n+\n+########################################\n+# Destructuring with tuple elimination where variables are repeated\n+let\n+    (x, y, z) = (y, a, x)\n+end\n+#---------------------\n+1   slot\u2082/y\n+2   TestMod.a\n+3   slot\u2081/x\n+4   (= slot\u2081/x %\u2081)\n+5   (= slot\u2082/y %\u2082)\n+6   (= slot\u2083/z %\u2083)\n+7   (call core.tuple %\u2081 %\u2082 %\u2083)\n+8   (return %\u2087)\n+\n+########################################\n+# Destructuring with simple tuple elimination and rhs with side effects\n+let\n+    (x, y) = (f(), b)\n+end\n+#---------------------\n+1   TestMod.f\n+2   (call %\u2081)\n+3   TestMod.b\n+4   (= slot\u2081/x %\u2082)\n+5   (= slot\u2082/y %\u2083)\n+6   (call core.tuple %\u2082 %\u2083)\n+7   (return %\u2086)\n+\n+########################################\n+# Destructuring with simple tuple elimination and lhs with side effects\n+let\n+    (x[10], y[20]) = (1,2)\n+end\n+#---------------------\n+1   1\n+2   TestMod.x\n+3   (call top.setindex! %\u2082 %\u2081 10)\n+4   2\n+5   TestMod.y\n+6   (call top.setindex! %\u2085 %\u2084 20)\n+7   (call core.tuple 1 2)\n+8   (return %\u2087)\n+\n+########################################\n+# Destructuring with tuple elimination and trailing rhs ...\n+let\n+    (x, y) = (a, rhs...)\n+end\n+#---------------------\n+1   TestMod.a\n+2   TestMod.rhs\n+3   (= slot\u2081/x %\u2081)\n+4   (call top.indexed_iterate %\u2082 1)\n+5   (= slot\u2082/y (call core.getfield %\u2084 1))\n+6   (call core.tuple %\u2081)\n+7   (call core._apply_iterate top.iterate core.tuple %\u2086 %\u2082)\n+8   (return %\u2087)\n+\n+########################################\n+# Destructuring with with non-trailing rhs `...` does not use tuple elimination\n+# (though we could do it for the `x = a` part here)\n+let\n+    (x, y, z) = (a, rhs..., b)\n+end\n+#---------------------\n+1   TestMod.a\n+2   (call core.tuple %\u2081)\n+3   TestMod.rhs\n+4   TestMod.b\n+5   (call core.tuple %\u2084)\n+6   (call core._apply_iterate top.iterate core.tuple %\u2082 %\u2083 %\u2085)\n+7   (call top.indexed_iterate %\u2086 1)\n+8   (= slot\u2082/x (call core.getfield %\u2087 1))\n+9   (= slot\u2081/iterstate (call core.getfield %\u2087 2))\n+10  slot\u2081/iterstate\n+11  (call top.indexed_iterate %\u2086 2 %\u2081\u2080)\n+12  (= slot\u2083/y (call core.getfield %\u2081\u2081 1))\n+13  (= slot\u2081/iterstate (call core.getfield %\u2081\u2081 2))\n+14  slot\u2081/iterstate\n+15  (call top.indexed_iterate %\u2086 3 %\u2081\u2084)\n+16  (= slot\u2084/z (call core.getfield %\u2081\u2085 1))\n+17  (return %\u2086)\n+\n+########################################\n+# Destructuring with tuple elimination and final ... on lhs\n+let\n+    (x, ys...) = (a,b,c)\n+end\n+#---------------------\n+1   TestMod.a\n+2   TestMod.b\n+3   TestMod.c\n+4   (= slot\u2081/x %\u2081)\n+5   (call core.tuple %\u2082 %\u2083)\n+6   (= slot\u2082/ys %\u2085)\n+7   (call core.tuple %\u2081 %\u2082 %\u2083)\n+8   (return %\u2087)\n+\n+########################################\n+# Destructuring with tuple elimination, slurping, and completely effect free right hand sides\n+let\n+    (x, ys...) = (1,2,3)\n+end\n+#---------------------\n+1   (= slot\u2081/x 1)\n+2   (call core.tuple 2 3)\n+3   (= slot\u2082/ys %\u2082)\n+4   (call core.tuple 1 2 3)\n+5   (return %\u2084)\n+\n+########################################\n+# Destructuring with tuple elimination and non-final ... on lhs\n+let\n+    (x, ys..., z) = (a,b,c)\n+end\n+#---------------------\n+1   TestMod.a\n+2   TestMod.b\n+3   TestMod.c\n+4   (= slot\u2081/x %\u2081)\n+5   (call core.tuple %\u2082)\n+6   (= slot\u2082/ys %\u2085)\n+7   (= slot\u2083/z %\u2083)\n+8   (call core.tuple %\u2081 %\u2082 %\u2083)\n+9   (return %\u2088)\n+\n+########################################\n+# Error: Destructuring with tuple elimination and too few RHS elements\n+(x,) = ()\n+#---------------------\n+LoweringError:\n+(x,) = ()\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 More variables on left hand side than right hand in tuple assignment\n+\n+########################################\n+# Error: Destructuring with tuple elimination, slurping, and too few RHS elements\n+(x,y,ys...) = (1,)\n+#---------------------\n+LoweringError:\n+(x,y,ys...) = (1,)\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 More variables on left hand side than right hand in tuple assignment\n+\n+########################################\n+# Destructuring with tuple elimination but not in value position never creates\n+# the tuple\n+let\n+    (x, ys...) = (a,b,c)\n+    nothing\n+end\n+#---------------------\n+1   TestMod.a\n+2   TestMod.b\n+3   TestMod.c\n+4   (= slot\u2081/x %\u2081)\n+5   (call core.tuple %\u2082 %\u2083)\n+6   (= slot\u2082/ys %\u2085)\n+7   TestMod.nothing\n+8   (return %\u2087)\n+\n+########################################\n+# Property destructuring\n+let\n+    (; x, y) = rhs\n+end\n+#---------------------\n+1   TestMod.rhs\n+2   (= slot\u2081/x (call top.getproperty %\u2081 :x))\n+3   (= slot\u2082/y (call top.getproperty %\u2081 :y))\n+4   (return %\u2081)\n+\n+########################################\n+# Property destructuring with colliding symbolic lhs/rhs\n+let\n+    local x\n+    (; x, y) = x\n+end\n+#---------------------\n+1   slot\u2081/x\n+2   (= slot\u2081/x (call top.getproperty %\u2081 :x))\n+3   (= slot\u2082/y (call top.getproperty %\u2081 :y))\n+4   (return %\u2081)\n+\n+########################################\n+# Property destructuring with nontrivial rhs\n+let\n+    (; x, y) = f()\n+end\n+#---------------------\n+1   TestMod.f\n+2   (call %\u2081)\n+3   (= slot\u2081/x (call top.getproperty %\u2082 :x))\n+4   (= slot\u2082/y (call top.getproperty %\u2082 :y))\n+5   (return %\u2082)\n+\n+########################################\n+# Property destructuring with type decl\n+let\n+    (; x::T) = rhs\n+end\n+#---------------------\n+1   (newvar slot\u2081/x)\n+2   TestMod.rhs\n+3   (call top.getproperty %\u2082 :x)\n+4   TestMod.T\n+5   (= slot\u2082/tmp %\u2083)\n+6   slot\u2082/tmp\n+7   (call core.isa %\u2086 %\u2084)\n+8   (gotoifnot %\u2087 label\u2081\u2080)\n+9   (goto label\u2081\u2083)\n+10  slot\u2082/tmp\n+11  (call top.convert %\u2084 %\u2081\u2080)\n+12  (= slot\u2082/tmp (call core.typeassert %\u2081\u2081 %\u2084))\n+13  slot\u2082/tmp\n+14  (= slot\u2081/x %\u2081\u2083)\n+15  (return %\u2082)\n+\n+########################################\n+# Error: Property destructuring with frankentuple\n+(x ; a, b) = rhs\n+#---------------------\n+LoweringError:\n+(x ; a, b) = rhs\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Property destructuring must use a single `;` before the property names, eg `(; a, b) = rhs`\n+\n+########################################\n+# Error: Property destructuring with values for properties\n+(; a=1, b) = rhs\n+#---------------------\n+LoweringError:\n+(; a=1, b) = rhs\n+#  \u2514\u2500\u2518 \u2500\u2500 invalid assignment location"
    },
    {
      "sha": "66a1766b342cb0dd64dafd720c46e99702482e21",
      "filename": "JuliaLowering/test/desugaring.jl",
      "status": "added",
      "additions": 57,
      "deletions": 0,
      "changes": 57,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdesugaring.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fdesugaring.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fdesugaring.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,57 @@\n+@testset \"Desugaring\" begin\n+\n+test_mod = Module(:TestMod)\n+\n+# @test desugar(test_mod, \"\"\"\n+# let\n+#     y = 0\n+#     x = 1\n+#     let x = x + 1\n+#         y = x\n+#     end\n+#     (x, y)\n+# end\n+# \"\"\") \u2248 @ast_ [K\"block\"\n+#     [K\"block\"\n+#         [K\"=\"\n+#             \"y\"::K\"Identifier\"\n+#             0::K\"Integer\"\n+#         ]\n+#         [K\"=\"\n+#             \"x\"::K\"Identifier\"\n+#             1::K\"Integer\"\n+#         ]\n+#         [K\"block\"\n+#             [K\"=\"\n+#                 1::K\"BindingId\"\n+#                 [K\"call\"\n+#                     \"+\"::K\"Identifier\"\n+#                     \"x\"::K\"Identifier\"\n+#                     1::K\"Integer\"\n+#                 ]\n+#             ]\n+#             [K\"block\"\n+#                 [K\"local_def\"\n+#                     \"x\"::K\"Identifier\"\n+#                 ]\n+#                 [K\"=\"\n+#                     \"x\"::K\"Identifier\"\n+#                     1::K\"BindingId\"\n+#                 ]\n+#                 [K\"block\"\n+#                     [K\"=\"\n+#                         \"y\"::K\"Identifier\"\n+#                         \"x\"::K\"Identifier\"\n+#                     ]\n+#                 ]\n+#             ]\n+#         ]\n+#         [K\"call\"\n+#             \"tuple\"::K\"core\"\n+#             \"x\"::K\"Identifier\"\n+#             \"y\"::K\"Identifier\"\n+#         ]\n+#     ]\n+# ]\n+\n+end"
    },
    {
      "sha": "e270ae38944f75dbb31f609f3713cd91814c6d75",
      "filename": "JuliaLowering/test/exceptions.jl",
      "status": "added",
      "additions": 338,
      "deletions": 0,
      "changes": 338,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fexceptions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fexceptions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fexceptions.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,338 @@\n+@testset \"try/catch\" begin\n+\n+test_mod = Module()\n+\n+@test isempty(current_exceptions())\n+\n+@testset \"tail position\" begin\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    try\n+        1\n+    catch\n+        2\n+    end\n+    \"\"\") == 1\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    try\n+        error(\"hi\")\n+        1\n+    catch\n+        2\n+    end\n+    \"\"\") == 2\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    try\n+        error(\"hi\")\n+    catch exc\n+        exc\n+    end\n+    \"\"\") == ErrorException(\"hi\")\n+\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    try\n+        1\n+    catch\n+        2\n+    else\n+        3\n+    end\n+    \"\"\") == 3\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    try\n+        error(\"hi\")\n+        1\n+    catch\n+        2\n+    else\n+        3\n+    end\n+    \"\"\") == 2\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f()\n+            try\n+                return 1\n+            catch\n+            end\n+            return 2\n+        end\n+        f()\n+    end\n+    \"\"\") == 1\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function g()\n+            try\n+                return 1\n+            catch\n+            end\n+        end\n+        g()\n+    end\n+    \"\"\") == 1\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let x = -1\n+        while true\n+            try\n+                error(\"hi\")\n+            catch\n+                x = 2\n+                break\n+            end\n+        end\n+        x\n+    end\n+    \"\"\") == 2\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let x = -1\n+        while true\n+            try\n+                x = 2\n+                break\n+            catch\n+            end\n+        end\n+        x\n+    end\n+    \"\"\") == 2\n+end\n+\n+@testset \"value position\" begin\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let\n+        x = try\n+            1\n+        catch\n+            2\n+        end\n+        x\n+    end\n+    \"\"\") == 1\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let\n+        x = try\n+            error(\"hi\")\n+            1\n+        catch\n+            2\n+        end\n+        x\n+    end\n+    \"\"\") == 2\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let\n+        x = try\n+            error(\"hi\")\n+        catch exc\n+            exc\n+        end\n+        x\n+    end\n+    \"\"\") == ErrorException(\"hi\")\n+\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let\n+        x = try\n+            1\n+        catch\n+            2\n+        else\n+            3\n+        end\n+        x\n+    end\n+    \"\"\") == 3\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let\n+        x = try\n+            error(\"hi\")\n+            1\n+        catch\n+            2\n+        else\n+            3\n+        end\n+        x\n+    end\n+    \"\"\") == 2\n+\n+end\n+\n+@testset \"not value/tail position\" begin\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let x = -1\n+        try\n+            x = 1\n+        catch\n+            x = 2\n+        end\n+        x\n+    end\n+    \"\"\") == 1\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let x = -1\n+        try\n+            error(\"hi\")\n+            x = 1\n+        catch\n+            x = 2\n+        end\n+        x\n+    end\n+    \"\"\") == 2\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let x = -1\n+        try\n+            x = error(\"hi\")\n+        catch exc\n+            x = exc\n+        end\n+        x\n+    end\n+    \"\"\") == ErrorException(\"hi\")\n+\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let x = -1\n+        try\n+            x = 1\n+        catch\n+            x = 2\n+        else\n+            x = 3\n+        end\n+        x\n+    end\n+    \"\"\") == 3\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let x = -1\n+        try\n+            error(\"hi\")\n+            x = 1\n+        catch\n+            x = 2\n+        else\n+            x = 3\n+        end\n+        x\n+    end\n+    \"\"\") == 2\n+\n+end\n+\n+@testset \"exception stack\" begin\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    try\n+        try\n+            error(\"hi\")\n+        catch\n+            error(\"ho\")\n+        end\n+    catch\n+        a = []\n+        for x in current_exceptions()\n+            push!(a, x.exception)\n+        end\n+        a\n+    end\n+    \"\"\") == [ErrorException(\"hi\"), ErrorException(\"ho\")]\n+\n+end\n+\n+@test isempty(current_exceptions())\n+\n+end\n+\n+#-------------------------------------------------------------------------------\n+@testset \"try/finally\" begin\n+\n+test_mod = Module()\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x = -1\n+    try\n+        x = 1\n+    finally\n+        x = 2\n+    end\n+    x\n+end\n+\"\"\") == 2\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x = -1\n+    try\n+        try\n+            error(\"hi\")\n+            x = 1\n+        finally\n+            x = 2\n+        end\n+    catch\n+    end\n+    x\n+end\n+\"\"\") == 2\n+\n+JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function nested_finally(a, x, b, c)\n+        try\n+            try\n+                if x\n+                    return b\n+                end\n+                c\n+            finally\n+                push!(a, 1)\n+            end\n+        finally\n+            push!(a, 2)\n+        end\n+    end\n+end\n+\"\"\")\n+@test (a = []; res = test_mod.nested_finally(a, true, 100, 200); (a, res)) == ([1,2], 100)\n+@test (a = []; res = test_mod.nested_finally(a, false, 100, 200); (a, res)) == ([1,2], 200)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+try\n+    1\n+catch\n+    2\n+finally\n+    3\n+end\n+\"\"\") == 1\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+try\n+    error(\"hi\")\n+    1\n+catch\n+    2\n+finally\n+    3\n+end\n+\"\"\") == 2\n+\n+end"
    },
    {
      "sha": "8cf423258f0c5f5664cb43a547afef9fd7b17ba3",
      "filename": "JuliaLowering/test/exceptions_ir.jl",
      "status": "added",
      "additions": 357,
      "deletions": 0,
      "changes": 357,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fexceptions_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fexceptions_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fexceptions_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,357 @@\n+########################################\n+# Return from inside try/catch\n+try\n+    f\n+    return x\n+catch\n+    g\n+    return y\n+end\n+#---------------------\n+1   (enter label\u2086)\n+2   TestMod.f\n+3   TestMod.x\n+4   (leave %\u2081)\n+5   (return %\u2083)\n+6   TestMod.g\n+7   TestMod.y\n+8   (pop_exception %\u2081)\n+9   (return %\u2087)\n+\n+########################################\n+# Return from inside try/catch with simple return vals\n+try\n+    f\n+    return 10\n+catch\n+    g\n+    return 20\n+end\n+#---------------------\n+1   (enter label\u2085)\n+2   TestMod.f\n+3   (leave %\u2081)\n+4   (return 10)\n+5   TestMod.g\n+6   (pop_exception %\u2081)\n+7   (return 20)\n+\n+########################################\n+# Return from multiple try + try/catch\n+try\n+    try\n+        return 10\n+    catch\n+        return 20\n+    end\n+catch\n+end\n+#---------------------\n+1   (enter label\u2081\u2084)\n+2   (enter label\u2087)\n+3   (leave %\u2081 %\u2082)\n+4   (return 10)\n+5   (leave %\u2082)\n+6   (goto label\u2081\u2081)\n+7   (leave %\u2081)\n+8   (pop_exception %\u2082)\n+9   (return 20)\n+10  (pop_exception %\u2082)\n+11  slot\u2081/try_result\n+12  (leave %\u2081)\n+13  (return %\u2081\u2081)\n+14  (pop_exception %\u2081)\n+15  (return core.nothing)\n+\n+########################################\n+# Return from multiple catch + try/catch\n+try\n+catch\n+    try\n+        return 10\n+    catch\n+        return 20\n+    end\n+end\n+#---------------------\n+1   (enter label\u2084)\n+2   (leave %\u2081)\n+3   (return core.nothing)\n+4   (enter label\u2088)\n+5   (leave %\u2084)\n+6   (pop_exception %\u2081)\n+7   (return 10)\n+8   (pop_exception %\u2081)\n+9   (return 20)\n+\n+########################################\n+# try/catch/else, tail position\n+try\n+    a\n+catch\n+    b\n+else\n+    c\n+end\n+#---------------------\n+1   (enter label\u2086)\n+2   TestMod.a\n+3   (leave %\u2081)\n+4   TestMod.c\n+5   (return %\u2084)\n+6   TestMod.b\n+7   (pop_exception %\u2081)\n+8   (return %\u2086)\n+\n+########################################\n+# try/catch/else, value position\n+let\n+    z = try\n+        a\n+    catch\n+        b\n+    else\n+        c\n+    end\n+end\n+#---------------------\n+1   (newvar slot\u2081/z)\n+2   (enter label\u2088)\n+3   TestMod.a\n+4   (leave %\u2082)\n+5   TestMod.c\n+6   (= slot\u2082/try_result %\u2085)\n+7   (goto label\u2081\u2081)\n+8   TestMod.b\n+9   (= slot\u2082/try_result %\u2088)\n+10  (pop_exception %\u2082)\n+11  slot\u2082/try_result\n+12  (= slot\u2081/z %\u2081\u2081)\n+13  (return %\u2081\u2081)\n+\n+########################################\n+# try/catch/else, not value/tail\n+begin\n+    try\n+        a\n+    catch\n+        b\n+    else\n+        c\n+    end\n+    z\n+end\n+#---------------------\n+1   (enter label\u2086)\n+2   TestMod.a\n+3   (leave %\u2081)\n+4   TestMod.c\n+5   (goto label\u2088)\n+6   TestMod.b\n+7   (pop_exception %\u2081)\n+8   TestMod.z\n+9   (return %\u2088)\n+\n+########################################\n+# basic try/finally, tail position\n+try\n+    a\n+finally\n+    b\n+end\n+#---------------------\n+1   (enter label\u2087)\n+2   (= slot\u2081/finally_tag -1)\n+3   (= slot\u2082/returnval_via_finally TestMod.a)\n+4   (= slot\u2081/finally_tag 1)\n+5   (leave %\u2081)\n+6   (goto label\u2088)\n+7   (= slot\u2081/finally_tag 2)\n+8   TestMod.b\n+9   (call core.=== slot\u2081/finally_tag 2)\n+10  (gotoifnot %\u2089 label\u2081\u2082)\n+11  (call top.rethrow)\n+12  slot\u2082/returnval_via_finally\n+13  (return %\u2081\u2082)\n+\n+########################################\n+# basic try/finally, value position\n+let\n+    z = try\n+        a\n+    finally\n+        b\n+    end\n+end\n+#---------------------\n+1   (newvar slot\u2081/z)\n+2   (enter label\u2088)\n+3   (= slot\u2083/finally_tag -1)\n+4   TestMod.a\n+5   (= slot\u2082/try_result %\u2084)\n+6   (leave %\u2082)\n+7   (goto label\u2089)\n+8   (= slot\u2083/finally_tag 1)\n+9   TestMod.b\n+10  (call core.=== slot\u2083/finally_tag 1)\n+11  (gotoifnot %\u2081\u2080 label\u2081\u2083)\n+12  (call top.rethrow)\n+13  slot\u2082/try_result\n+14  (= slot\u2081/z %\u2081\u2083)\n+15  (return %\u2081\u2083)\n+\n+########################################\n+# basic try/finally, not value/tail\n+begin\n+    try\n+        a\n+    finally\n+        b\n+    end\n+    z\n+end\n+#---------------------\n+1   (enter label\u2086)\n+2   (= slot\u2081/finally_tag -1)\n+3   TestMod.a\n+4   (leave %\u2081)\n+5   (goto label\u2087)\n+6   (= slot\u2081/finally_tag 1)\n+7   TestMod.b\n+8   (call core.=== slot\u2081/finally_tag 1)\n+9   (gotoifnot %\u2088 label\u2081\u2081)\n+10  (call top.rethrow)\n+11  TestMod.z\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# try/finally + break\n+while true\n+    try\n+        a\n+        break\n+    finally\n+        b\n+    end\n+end\n+#---------------------\n+1   (gotoifnot true label\u2081\u2085)\n+2   (enter label\u2089)\n+3   (= slot\u2081/finally_tag -1)\n+4   TestMod.a\n+5   (leave %\u2082)\n+6   (goto label\u2081\u2085)\n+7   (leave %\u2082)\n+8   (goto label\u2081\u2080)\n+9   (= slot\u2081/finally_tag 1)\n+10  TestMod.b\n+11  (call core.=== slot\u2081/finally_tag 1)\n+12  (gotoifnot %\u2081\u2081 label\u2081\u2084)\n+13  (call top.rethrow)\n+14  (goto label\u2081)\n+15  (return core.nothing)\n+\n+########################################\n+# try/catch/finally\n+try\n+    a\n+catch\n+    b\n+finally\n+    c\n+end\n+#---------------------\n+1   (enter label\u2081\u2085)\n+2   (= slot\u2081/finally_tag -1)\n+3   (enter label\u2088)\n+4   TestMod.a\n+5   (= slot\u2082/try_result %\u2084)\n+6   (leave %\u2083)\n+7   (goto label\u2081\u2081)\n+8   TestMod.b\n+9   (= slot\u2082/try_result %\u2088)\n+10  (pop_exception %\u2083)\n+11  (= slot\u2083/returnval_via_finally slot\u2082/try_result)\n+12  (= slot\u2081/finally_tag 1)\n+13  (leave %\u2081)\n+14  (goto label\u2081\u2086)\n+15  (= slot\u2081/finally_tag 2)\n+16  TestMod.c\n+17  (call core.=== slot\u2081/finally_tag 2)\n+18  (gotoifnot %\u2081\u2087 label\u2082\u2080)\n+19  (call top.rethrow)\n+20  slot\u2083/returnval_via_finally\n+21  (return %\u2082\u2080)\n+\n+########################################\n+# Nested finally blocks\n+try\n+    try\n+        if x\n+            return a\n+        end\n+        b\n+    finally\n+        c\n+    end\n+finally\n+    d\n+end\n+#---------------------\n+1   (enter label\u2083\u2080)\n+2   (= slot\u2081/finally_tag -1)\n+3   (enter label\u2081\u2085)\n+4   (= slot\u2083/finally_tag -1)\n+5   TestMod.x\n+6   (gotoifnot %\u2085 label\u2081\u2081)\n+7   (= slot\u2084/returnval_via_finally TestMod.a)\n+8   (= slot\u2083/finally_tag 1)\n+9   (leave %\u2083)\n+10  (goto label\u2081\u2086)\n+11  TestMod.b\n+12  (= slot\u2082/try_result %\u2081\u2081)\n+13  (leave %\u2083)\n+14  (goto label\u2081\u2086)\n+15  (= slot\u2083/finally_tag 2)\n+16  TestMod.c\n+17  (call core.=== slot\u2083/finally_tag 2)\n+18  (gotoifnot %\u2081\u2087 label\u2082\u2080)\n+19  (call top.rethrow)\n+20  (call core.=== slot\u2083/finally_tag 1)\n+21  (gotoifnot %\u2082\u2080 label\u2082\u2086)\n+22  (= slot\u2085/returnval_via_finally slot\u2084/returnval_via_finally)\n+23  (= slot\u2081/finally_tag 1)\n+24  (leave %\u2081)\n+25  (goto label\u2083\u2081)\n+26  (= slot\u2086/returnval_via_finally slot\u2082/try_result)\n+27  (= slot\u2081/finally_tag 2)\n+28  (leave %\u2081)\n+29  (goto label\u2083\u2081)\n+30  (= slot\u2081/finally_tag 3)\n+31  TestMod.d\n+32  (call core.=== slot\u2081/finally_tag 3)\n+33  (gotoifnot %\u2083\u2082 label\u2083\u2085)\n+34  (call top.rethrow)\n+35  (call core.=== slot\u2081/finally_tag 2)\n+36  (gotoifnot %\u2083\u2085 label\u2083\u2089)\n+37  slot\u2086/returnval_via_finally\n+38  (return %\u2083\u2087)\n+39  slot\u2085/returnval_via_finally\n+40  (return %\u2083\u2089)\n+\n+########################################\n+# Access to the exception object\n+try\n+    a\n+catch exc\n+    b\n+end\n+#---------------------\n+1   (enter label\u2085)\n+2   TestMod.a\n+3   (leave %\u2081)\n+4   (return %\u2082)\n+5   (= slot\u2081/exc (call JuliaLowering.current_exception))\n+6   TestMod.b\n+7   (pop_exception %\u2081)\n+8   (return %\u2086)"
    },
    {
      "sha": "1426ed228ddc85b69272bcacc8d9fa6cdd8714af",
      "filename": "JuliaLowering/test/function_calls_ir.jl",
      "status": "added",
      "additions": 664,
      "deletions": 0,
      "changes": 664,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Ffunction_calls_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Ffunction_calls_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Ffunction_calls_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,664 @@\n+########################################\n+# Simple call\n+f(x, y)\n+#---------------------\n+1   TestMod.f\n+2   TestMod.x\n+3   TestMod.y\n+4   (call %\u2081 %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# Keyword calls\n+f(x; a=1, b=2)\n+#---------------------\n+1   TestMod.f\n+2   (call core.tuple :a :b)\n+3   (call core.apply_type core.NamedTuple %\u2082)\n+4   (call core.tuple 1 2)\n+5   (call %\u2083 %\u2084)\n+6   TestMod.x\n+7   (call core.kwcall %\u2085 %\u2081 %\u2086)\n+8   (return %\u2087)\n+\n+########################################\n+# Keyword call with only splats for kws\n+f(; ks1..., ks2...)\n+#---------------------\n+1   TestMod.f\n+2   (call core.NamedTuple)\n+3   TestMod.ks1\n+4   (call top.merge %\u2082 %\u2083)\n+5   TestMod.ks2\n+6   (call top.merge %\u2084 %\u2085)\n+7   (call top.isempty %\u2086)\n+8   (gotoifnot %\u2087 label\u2081\u2081)\n+9   (call %\u2081)\n+10  (return %\u2089)\n+11  (call core.kwcall %\u2086 %\u2081)\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Error: Call with repeated keywords\n+f(x; a=1, a=2)\n+#---------------------\n+LoweringError:\n+f(x; a=1, a=2)\n+#         \u2559 \u2500\u2500 Repeated keyword argument name\n+\n+########################################\n+# literal_pow lowering\n+x^42\n+#---------------------\n+1   TestMod.^\n+2   TestMod.x\n+3   (call core.apply_type top.Val 42)\n+4   (call %\u2083)\n+5   (call top.literal_pow %\u2081 %\u2082 %\u2084)\n+6   (return %\u2085)\n+\n+########################################\n+# almost but not quite literal_pow lowering :)\n+x^42.0\n+#---------------------\n+1   TestMod.^\n+2   TestMod.x\n+3   (call %\u2081 %\u2082 42.0)\n+4   (return %\u2083)\n+\n+########################################\n+# Error: infix call without enough arguments\n+@ast_ [K\"call\"(syntax_flags=JuliaSyntax.INFIX_FLAG)\n+    \"x\"::K\"Identifier\"\n+]\n+#---------------------\n+LoweringError:\n+#= line 1 =# - Postfix/infix operators must have at least two positional arguments\n+\n+########################################\n+# Error: postfix call without enough arguments\n+@ast_ [K\"call\"(syntax_flags=JuliaSyntax.POSTFIX_OP_FLAG)\n+    \"x\"::K\"Identifier\"\n+]\n+#---------------------\n+LoweringError:\n+#= line 1 =# - Postfix/infix operators must have at least two positional arguments\n+\n+########################################\n+# Error: Call with no function name\n+@ast_ [K\"call\"]\n+#---------------------\n+LoweringError:\n+#= line 1 =# - Call expressions must have a function name\n+\n+########################################\n+# Simple broadcast\n+x .* y .+ f.(z)\n+#---------------------\n+1   TestMod.+\n+2   TestMod.*\n+3   TestMod.x\n+4   TestMod.y\n+5   (call top.broadcasted %\u2082 %\u2083 %\u2084)\n+6   TestMod.f\n+7   TestMod.z\n+8   (call top.broadcasted %\u2086 %\u2087)\n+9   (call top.broadcasted %\u2081 %\u2085 %\u2088)\n+10  (call top.materialize %\u2089)\n+11  (return %\u2081\u2080)\n+\n+########################################\n+# Broadcast with unary function calls\n+.+x\n+#---------------------\n+1   TestMod.+\n+2   TestMod.x\n+3   (call top.broadcasted %\u2081 %\u2082)\n+4   (call top.materialize %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# Broadcast with short circuit operators\n+x .&& y .|| z\n+#---------------------\n+1   TestMod.x\n+2   TestMod.y\n+3   (call top.broadcasted top.andand %\u2081 %\u2082)\n+4   TestMod.z\n+5   (call top.broadcasted top.oror %\u2083 %\u2084)\n+6   (call top.materialize %\u2085)\n+7   (return %\u2086)\n+\n+########################################\n+# Scalar comparison chain\n+x < y < z\n+#---------------------\n+1   TestMod.<\n+2   TestMod.x\n+3   TestMod.y\n+4   (call %\u2081 %\u2082 %\u2083)\n+5   (gotoifnot %\u2084 label\u2081\u2081)\n+6   TestMod.<\n+7   TestMod.y\n+8   TestMod.z\n+9   (call %\u2086 %\u2087 %\u2088)\n+10  (return %\u2089)\n+11  (return false)\n+\n+########################################\n+# Broadcasted comparison chain\n+x .< y .< z\n+#---------------------\n+1   TestMod.<\n+2   TestMod.x\n+3   TestMod.y\n+4   (call top.broadcasted %\u2081 %\u2082 %\u2083)\n+5   TestMod.<\n+6   TestMod.y\n+7   TestMod.z\n+8   (call top.broadcasted %\u2085 %\u2086 %\u2087)\n+9   (call top.broadcasted top.& %\u2084 %\u2088)\n+10  (call top.materialize %\u2089)\n+11  (return %\u2081\u2080)\n+\n+########################################\n+# Mixed scalar / broadcasted comparison chain\n+a < b < c .< d .< e\n+#---------------------\n+1   TestMod.<\n+2   TestMod.a\n+3   TestMod.b\n+4   (call %\u2081 %\u2082 %\u2083)\n+5   (gotoifnot %\u2084 label\u2081\u2081)\n+6   TestMod.<\n+7   TestMod.b\n+8   TestMod.c\n+9   (= slot\u2081/if_val (call %\u2086 %\u2087 %\u2088))\n+10  (goto label\u2081\u2082)\n+11  (= slot\u2081/if_val false)\n+12  slot\u2081/if_val\n+13  TestMod.<\n+14  TestMod.c\n+15  TestMod.d\n+16  (call top.broadcasted %\u2081\u2083 %\u2081\u2084 %\u2081\u2085)\n+17  (call top.broadcasted top.& %\u2081\u2082 %\u2081\u2086)\n+18  TestMod.<\n+19  TestMod.d\n+20  TestMod.e\n+21  (call top.broadcasted %\u2081\u2088 %\u2081\u2089 %\u2082\u2080)\n+22  (call top.broadcasted top.& %\u2081\u2087 %\u2082\u2081)\n+23  (call top.materialize %\u2082\u2082)\n+24  (return %\u2082\u2083)\n+\n+########################################\n+# Mixed scalar / broadcasted comparison chain\n+a .< b .< c < d < e\n+#---------------------\n+1   TestMod.<\n+2   TestMod.a\n+3   TestMod.b\n+4   (call top.broadcasted %\u2081 %\u2082 %\u2083)\n+5   TestMod.<\n+6   TestMod.b\n+7   TestMod.c\n+8   (call top.broadcasted %\u2085 %\u2086 %\u2087)\n+9   (call top.broadcasted top.& %\u2084 %\u2088)\n+10  TestMod.<\n+11  TestMod.c\n+12  TestMod.d\n+13  (call %\u2081\u2080 %\u2081\u2081 %\u2081\u2082)\n+14  (gotoifnot %\u2081\u2083 label\u2082\u2080)\n+15  TestMod.<\n+16  TestMod.d\n+17  TestMod.e\n+18  (= slot\u2081/if_val (call %\u2081\u2085 %\u2081\u2086 %\u2081\u2087))\n+19  (goto label\u2082\u2081)\n+20  (= slot\u2081/if_val false)\n+21  slot\u2081/if_val\n+22  (call top.broadcasted top.& %\u2089 %\u2082\u2081)\n+23  (call top.materialize %\u2082\u2082)\n+24  (return %\u2082\u2083)\n+\n+########################################\n+# Comparison chain fused with other broadcasting\n+x .+ (a .< b .< c)\n+#---------------------\n+1   TestMod.+\n+2   TestMod.x\n+3   TestMod.<\n+4   TestMod.a\n+5   TestMod.b\n+6   (call top.broadcasted %\u2083 %\u2084 %\u2085)\n+7   TestMod.<\n+8   TestMod.b\n+9   TestMod.c\n+10  (call top.broadcasted %\u2087 %\u2088 %\u2089)\n+11  (call top.broadcasted top.& %\u2086 %\u2081\u2080)\n+12  (call top.broadcasted %\u2081 %\u2082 %\u2081\u2081)\n+13  (call top.materialize %\u2081\u2082)\n+14  (return %\u2081\u2083)\n+\n+########################################\n+# Broadcast with literal_pow\n+x.^3\n+#---------------------\n+1   TestMod.^\n+2   TestMod.x\n+3   (call core.apply_type top.Val 3)\n+4   (call %\u2083)\n+5   (call top.broadcasted top.literal_pow %\u2081 %\u2082 %\u2084)\n+6   (call top.materialize %\u2085)\n+7   (return %\u2086)\n+\n+########################################\n+# Broadcast with keywords\n+f.(x, y, z = 1; w = 2)\n+#---------------------\n+1   top.broadcasted_kwsyntax\n+2   (call core.tuple :z :w)\n+3   (call core.apply_type core.NamedTuple %\u2082)\n+4   (call core.tuple 1 2)\n+5   (call %\u2083 %\u2084)\n+6   TestMod.f\n+7   TestMod.x\n+8   TestMod.y\n+9   (call core.kwcall %\u2085 %\u2081 %\u2086 %\u2087 %\u2088)\n+10  (call top.materialize %\u2089)\n+11  (return %\u2081\u2080)\n+\n+########################################\n+# Broadcast with unary dot syntax\n+(.+)(x,y)\n+#---------------------\n+1   TestMod.+\n+2   TestMod.x\n+3   TestMod.y\n+4   (call top.broadcasted %\u2081 %\u2082 %\u2083)\n+5   (call top.materialize %\u2084)\n+6   (return %\u2085)\n+\n+########################################\n+# Trivial in-place broadcast update\n+x .= y\n+#---------------------\n+1   TestMod.x\n+2   TestMod.y\n+3   (call top.broadcasted top.identity %\u2082)\n+4   (call top.materialize! %\u2081 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# Fused in-place broadcast update\n+x .= y .+ z\n+#---------------------\n+1   TestMod.x\n+2   TestMod.+\n+3   TestMod.y\n+4   TestMod.z\n+5   (call top.broadcasted %\u2082 %\u2083 %\u2084)\n+6   (call top.materialize! %\u2081 %\u2085)\n+7   (return %\u2086)\n+\n+########################################\n+# In-place broadcast update with property assignment on left hand side\n+x.prop .= y\n+#---------------------\n+1   TestMod.x\n+2   (call top.dotgetproperty %\u2081 :prop)\n+3   TestMod.y\n+4   (call top.broadcasted top.identity %\u2083)\n+5   (call top.materialize! %\u2082 %\u2084)\n+6   (return %\u2085)\n+\n+########################################\n+# In-place broadcast update with ref on left hand side\n+x[i,end] .= y\n+#---------------------\n+1   TestMod.x\n+2   TestMod.i\n+3   (call top.lastindex %\u2081 2)\n+4   (call top.dotview %\u2081 %\u2082 %\u2083)\n+5   TestMod.y\n+6   (call top.broadcasted top.identity %\u2085)\n+7   (call top.materialize! %\u2084 %\u2086)\n+8   (return %\u2087)\n+\n+########################################\n+# <: as a function call\n+x <: y\n+#---------------------\n+1   TestMod.<:\n+2   TestMod.x\n+3   TestMod.y\n+4   (call %\u2081 %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# >: as a function call\n+x >: y\n+#---------------------\n+1   TestMod.>:\n+2   TestMod.x\n+3   TestMod.y\n+4   (call %\u2081 %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# --> as a function call\n+x --> y\n+#---------------------\n+1   TestMod.-->\n+2   TestMod.x\n+3   TestMod.y\n+4   (call %\u2081 %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# basic ccall\n+ccall(:strlen, Csize_t, (Cstring,), \"asdfg\")\n+#---------------------\n+1   TestMod.Cstring\n+2   (call top.cconvert %\u2081 \"asdfg\")\n+3   (call top.unsafe_convert %\u2081 %\u2082)\n+4   (foreigncall :strlen (static_eval TestMod.Csize_t) (static_eval (call core.svec TestMod.Cstring)) 0 :ccall %\u2083 %\u2082)\n+5   (return %\u2084)\n+\n+########################################\n+# ccall with library name as a global var\n+ccall((:strlen, libc), Csize_t, (Cstring,), \"asdfg\")\n+#---------------------\n+1   TestMod.Cstring\n+2   (call top.cconvert %\u2081 \"asdfg\")\n+3   (call top.unsafe_convert %\u2081 %\u2082)\n+4   (foreigncall (static_eval (call core.tuple :strlen TestMod.libc)) (static_eval TestMod.Csize_t) (static_eval (call core.svec TestMod.Cstring)) 0 :ccall %\u2083 %\u2082)\n+5   (return %\u2084)\n+\n+########################################\n+# ccall with a calling convention\n+ccall(:foo, stdcall, Csize_t, ())\n+#---------------------\n+1   (foreigncall :foo (static_eval TestMod.Csize_t) (static_eval (call core.svec)) 0 :stdcall)\n+2   (return %\u2081)\n+\n+########################################\n+# ccall with Any args become core.Any and don't need conversion or GC roots\n+ccall(:foo, stdcall, Csize_t, (Any,), x)\n+#---------------------\n+1   core.Any\n+2   TestMod.x\n+3   (foreigncall :foo (static_eval TestMod.Csize_t) (static_eval (call core.svec core.Any)) 0 :stdcall %\u2082)\n+4   (return %\u2083)\n+\n+########################################\n+# ccall with variable as function name (must eval to a pointer)\n+ccall(ptr, Csize_t, (Cstring,), \"asdfg\")\n+#---------------------\n+1   TestMod.Cstring\n+2   (call top.cconvert %\u2081 \"asdfg\")\n+3   TestMod.ptr\n+4   (call top.unsafe_convert %\u2081 %\u2082)\n+5   (foreigncall %\u2083 (static_eval TestMod.Csize_t) (static_eval (call core.svec TestMod.Cstring)) 0 :ccall %\u2084 %\u2082)\n+6   (return %\u2085)\n+\n+########################################\n+# ccall with varargs\n+ccall(:printf, Cint, (Cstring, Cstring...), \"%s = %s\\n\", \"2 + 2\", \"5\")\n+#---------------------\n+1   TestMod.Cstring\n+2   TestMod.Cstring\n+3   TestMod.Cstring\n+4   (call top.cconvert %\u2081 \"%s = %s\\n\")\n+5   (call top.cconvert %\u2082 \"2 + 2\")\n+6   (call top.cconvert %\u2083 \"5\")\n+7   (call top.unsafe_convert %\u2081 %\u2084)\n+8   (call top.unsafe_convert %\u2082 %\u2085)\n+9   (call top.unsafe_convert %\u2083 %\u2086)\n+10  (foreigncall :printf (static_eval TestMod.Cint) (static_eval (call core.svec TestMod.Cstring TestMod.Cstring TestMod.Cstring)) 1 :ccall %\u2087 %\u2088 %\u2089 %\u2084 %\u2085 %\u2086)\n+11  (return %\u2081\u2080)\n+\n+########################################\n+# Error: ccall with too few arguments\n+ccall(:foo, Csize_t)\n+#---------------------\n+LoweringError:\n+ccall(:foo, Csize_t)\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 too few arguments to ccall\n+\n+########################################\n+# Error: ccall with calling conv and too few arguments\n+ccall(:foo, thiscall, Csize_t)\n+#---------------------\n+LoweringError:\n+ccall(:foo, thiscall, Csize_t)\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 too few arguments to ccall with calling convention specified\n+\n+########################################\n+# Error: ccall without tuple for argument types\n+ccall(:foo, Csize_t, Cstring)\n+#---------------------\n+LoweringError:\n+ccall(:foo, Csize_t, Cstring)\n+#                    \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 ccall argument types must be a tuple; try `(T,)`\n+\n+########################################\n+# Error: ccall without tuple for argument types\n+ccall(:foo, (Csize_t,), \"arg\")\n+#---------------------\n+LoweringError:\n+ccall(:foo, (Csize_t,), \"arg\")\n+#           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 ccall argument types must be a tuple; try `(T,)` and check if you specified a correct return type\n+\n+########################################\n+# Error: ccall with library name which is a local variable\n+let libc = \"libc\"\n+    ccall((:strlen, libc), Csize_t, (Cstring,), \"asdfg\")\n+end\n+#---------------------\n+LoweringError:\n+let libc = \"libc\"\n+    ccall((:strlen, libc), Csize_t, (Cstring,), \"asdfg\")\n+#                   \u2514\u2500\u2500\u2518 \u2500\u2500 function name and library expression cannot reference local variable\n+end\n+\n+########################################\n+# Error: ccall with return type which is a local variable\n+let Csize_t = 1\n+    ccall(:strlen, Csize_t, (Cstring,), \"asdfg\")\n+end\n+#---------------------\n+LoweringError:\n+let Csize_t = 1\n+    ccall(:strlen, Csize_t, (Cstring,), \"asdfg\")\n+#                  \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 ccall return type cannot reference local variable\n+end\n+\n+########################################\n+# Error: ccall with argument type which is a local variable\n+let Cstring = 1\n+    ccall(:strlen, Csize_t, (Cstring,), \"asdfg\")\n+end\n+#---------------------\n+LoweringError:\n+let Cstring = 1\n+    ccall(:strlen, Csize_t, (Cstring,), \"asdfg\")\n+#                            \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 ccall argument type cannot reference local variable\n+end\n+\n+########################################\n+# Error: ccall with too few arguments\n+ccall(:strlen, Csize_t, (Cstring,))\n+#---------------------\n+LoweringError:\n+ccall(:strlen, Csize_t, (Cstring,))\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Too few arguments in ccall compared to argument types\n+\n+########################################\n+# Error: ccall with too many arguments\n+ccall(:strlen, Csize_t, (Cstring,), \"asdfg\", \"blah\")\n+#---------------------\n+LoweringError:\n+ccall(:strlen, Csize_t, (Cstring,), \"asdfg\", \"blah\")\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 More arguments than types in ccall\n+\n+########################################\n+# Error: ccall varargs with too few args\n+ccall(:foo, Csize_t, (Cstring...,), \"asdfg\")\n+#---------------------\n+LoweringError:\n+ccall(:foo, Csize_t, (Cstring...,), \"asdfg\")\n+#                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 C ABI prohibits vararg without one required argument\n+\n+########################################\n+# Error: ccall with multiple varargs\n+ccall(:foo, Csize_t, (Cstring..., Cstring...), \"asdfg\", \"blah\")\n+#---------------------\n+LoweringError:\n+ccall(:foo, Csize_t, (Cstring..., Cstring...), \"asdfg\", \"blah\")\n+#                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 only the trailing ccall argument type should have `...`\n+\n+########################################\n+# cglobal special support for (sym, lib) tuple\n+cglobal((:sym, lib), Int)\n+#---------------------\n+1   TestMod.Int\n+2   (call core.cglobal (static_eval (call core.tuple :sym TestMod.lib)) %\u2081)\n+3   (return %\u2082)\n+\n+########################################\n+# cglobal - non-tuple expressions in first arg are lowered as normal\n+cglobal(f(), Int)\n+#---------------------\n+1   TestMod.f\n+2   (call %\u2081)\n+3   TestMod.Int\n+4   (call core.cglobal %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# Error: cglobal with library name referencing local variable\n+let func=\"myfunc\"\n+    cglobal((func, \"somelib\"), Int)\n+end\n+#---------------------\n+LoweringError:\n+let func=\"myfunc\"\n+    cglobal((func, \"somelib\"), Int)\n+#            \u2514\u2500\u2500\u2518 \u2500\u2500 function name and library expression cannot reference local variable\n+end\n+\n+########################################\n+# Error: cglobal too many arguments\n+cglobal(:sym, Int, blah)\n+#---------------------\n+LoweringError:\n+cglobal(:sym, Int, blah)\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 cglobal must have one or two arguments\n+\n+########################################\n+# Error: assigning to `cglobal`\n+cglobal = 10\n+#---------------------\n+LoweringError:\n+cglobal = 10\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 invalid assignment location\n+\n+########################################\n+# Error: assigning to `ccall`\n+ccall = 10\n+#---------------------\n+LoweringError:\n+ccall = 10\n+\u2514\u2500\u2500\u2500\u2518 \u2500\u2500 invalid assignment location\n+\n+########################################\n+# Error: assigning to `var\"ccall\"`\n+var\"ccall\" = 10\n+#---------------------\n+LoweringError:\n+var\"ccall\" = 10\n+#   \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 invalid assignment location\n+\n+########################################\n+# Error: Invalid function name ccall\n+function ccall()\n+end\n+#---------------------\n+LoweringError:\n+function ccall()\n+#        \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 Invalid function name\n+end\n+\n+########################################\n+# Error: Invalid function name ccall\n+function A.ccall()\n+end\n+#---------------------\n+LoweringError:\n+function A.ccall()\n+#        \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Invalid function name\n+end\n+\n+########################################\n+# Error: Invalid function name ccall\n+function ccall{<:T}()\n+end\n+#---------------------\n+LoweringError:\n+function ccall{<:T}()\n+#        \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 Invalid function name\n+end\n+\n+########################################\n+# Nested splat: simple case\n+tuple((xs...)...)\n+#---------------------\n+1   TestMod.tuple\n+2   (call core.tuple top.iterate %\u2081)\n+3   TestMod.xs\n+4   (call core._apply_iterate top.iterate core._apply_iterate %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# Nested splat: with mixed arguments\n+tuple(a, (xs...)..., b)\n+#---------------------\n+1   TestMod.tuple\n+2   TestMod.a\n+3   (call core.tuple %\u2082)\n+4   (call core.tuple top.iterate %\u2081 %\u2083)\n+5   TestMod.xs\n+6   TestMod.b\n+7   (call core.tuple %\u2086)\n+8   (call core.tuple %\u2087)\n+9   (call core._apply_iterate top.iterate core._apply_iterate %\u2084 %\u2085 %\u2088)\n+10  (return %\u2089)\n+\n+########################################\n+# Nested splat: multiple nested splats\n+tuple((xs...)..., (ys...)...)\n+#---------------------\n+1   TestMod.tuple\n+2   (call core.tuple top.iterate %\u2081)\n+3   TestMod.xs\n+4   TestMod.ys\n+5   (call core._apply_iterate top.iterate core._apply_iterate %\u2082 %\u2083 %\u2084)\n+6   (return %\u2085)\n+\n+########################################\n+# Nested splat: triple nesting\n+tuple(((xs...)...)...)\n+#---------------------\n+1   TestMod.tuple\n+2   (call core.tuple top.iterate %\u2081)\n+3   (call core.tuple top.iterate core._apply_iterate %\u2082)\n+4   TestMod.xs\n+5   (call core._apply_iterate top.iterate core._apply_iterate %\u2083 %\u2084)\n+6   (return %\u2085)\n+\n+########################################\n+# Error: Standalone splat expression\n+(xs...)\n+#---------------------\n+LoweringError:\n+(xs...)\n+#\u2514\u2500\u2500\u2500\u2518 \u2500\u2500 `...` expression outside call"
    },
    {
      "sha": "8193d2c7b2efe9f82fa148f928e0df20d568b0f5",
      "filename": "JuliaLowering/test/functions.jl",
      "status": "added",
      "additions": 553,
      "deletions": 0,
      "changes": 553,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Ffunctions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Ffunctions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Ffunctions.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,553 @@\n+@testset \"Functions\" begin\n+\n+test_mod = Module()\n+\n+# Function calls\n+# Splatting\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = 1\n+    y = 2\n+    zs = (3,4)\n+    w = 5\n+    (tuple(zs...),\n+     tuple(zs..., w),\n+     tuple(y, zs...),\n+     tuple(x, y, zs..., w))\n+end\n+\"\"\") == ((3,4),\n+         (3,4,5),\n+         (2,3,4),\n+         (1,2,3,4,5))\n+\n+# Nested splatting\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    xs = [[1, 2], [3, 4]]\n+    tuple((xs...)...)\n+end\n+\"\"\") == (1, 2, 3, 4)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    xs = [[1, 2]]\n+    ys = [[3, 4]]\n+    tuple((xs...)..., (ys...)...)\n+end\n+\"\"\") == (1, 2, 3, 4)\n+\n+# Multiple (>2) nested splat\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    xs = [[[1, 2]]]\n+    tuple(((xs...)...)...)\n+end\n+\"\"\") == (1, 2)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    xs = [[[1, 2]]]\n+    ys = [[[3, 4]]]\n+    tuple(((xs...)...)..., ((ys...)...)...)\n+end\n+\"\"\") == (1, 2, 3, 4)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    xs = [[[1, 2]]]\n+    ys = [[[3, 4]]]\n+    tuple(((xs...)...)..., ((ys...)...))\n+end\n+\"\"\") == (1, 2, [3, 4])\n+\n+# Trailing comma case should still work (different semantics)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    xs = [[1, 2], [3, 4]]\n+    tuple((xs...,)...)\n+end\n+\"\"\") == ([1, 2], [3, 4])\n+\n+# Keyword calls\n+Base.eval(test_mod, :(\n+begin\n+    function kwtest(; kws...)\n+        values(kws)\n+    end\n+\n+    # Note this definition generates an arguably-spurious warning when run via\n+    # `Pkg.test()` due to the use of `--warn-override=true` in the test\n+    # harness.\n+    function kwtest()\n+        \"non-kw version of kwtest\"\n+    end\n+end\n+))\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    kws = (c=3,d=4)\n+    kwtest(; kws..., a=1, d=0, e=5)\n+end\n+\"\"\") == (c=3, d=0, a=1, e=5)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    kws = (;)\n+    kwtest(; kws..., kws...)\n+end\n+\"\"\") == \"non-kw version of kwtest\"\n+\n+# literal_pow\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+2^4\n+\"\"\") == 16\n+\n+#-------------------------------------------------------------------------------\n+# Arrow syntax\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    f = ((x::T, y::T) where T) -> x + y\n+    f(1, 2)\n+end\n+\"\"\") === 3\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    f = ((x::T; y=2) where T) -> x + y\n+    f(1)\n+end\n+\"\"\") === 3\n+\n+# Passes desugaring, but T is detected as unused and throws an error.\n+# Is it clear whether this should be `f(x::T) where T` or `f(x::T where T)`?\n+@test_broken JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    f = ((x::T) where T) -> x\n+    f(1)\n+end\n+\"\"\") === 1\n+\n+#-------------------------------------------------------------------------------\n+# Function definitions\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function f(x)\n+        y = x + 1\n+        \"hi\", x, y\n+    end\n+\n+    f(1)\n+end\n+\"\"\") == (\"hi\", 1, 2)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function unused_arg(x, _, y)\n+        x + y\n+    end\n+    unused_arg(1,2,3)\n+end\n+\"\"\") == 4\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function g(x)::Int\n+        if x == 1\n+            return 42.0\n+        end\n+        0xff\n+    end\n+    (g(1), g(2))\n+end\n+\"\"\") === (42, 255)\n+\n+# static parameters\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function h(x, y)\n+        \"fallback\"\n+    end\n+    function h(::Vector{T}, ::S) where {T, S <: T}\n+        T, S\n+    end\n+    (h(1, 2), h(Number[0xff], 1.0), h(Int[1], 1), h(Int[1], 1.0))\n+end\n+\"\"\") === (\"fallback\", (Number, Float64), (Int, Int), \"fallback\")\n+\n+Base.eval(test_mod,\n+:(struct X1{T} end)\n+)\n+\n+# `where` params used in function obj type\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function (x::X1{T})() where T\n+        T\n+    end\n+    X1{Int}()()\n+end\n+\"\"\") === Int\n+\n+Base.include_string(test_mod,\n+\"\"\"\n+    struct X end\n+\n+    # Erroneous `convert` to test type assert in function return values\n+    Base.convert(::Type{X}, y) = y\n+\"\"\")\n+\n+@test_throws TypeError JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    function h()::X\n+        return nothing\n+    end\n+    h()\n+end\n+\"\"\")\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+x = 0\n+function f_return_in_value_pos()\n+    global x\n+    x = return 42\n+end\n+\n+(f_return_in_value_pos(), x)\n+\"\"\") === (42, 0)\n+\n+@testset \"Default positional arguments\" begin\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_def_simple(x=1, y=2, z=x)\n+            (x,y,z)\n+        end\n+\n+        (f_def_simple(), f_def_simple(10), f_def_simple(10,20), f_def_simple(10,20,30))\n+    end\n+    \"\"\") == ((1,2,1), (10,2,10), (10,20,10), (10,20,30))\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_def_placeholders(::T=1, _::S=1.0) where {T,S}\n+            (T,S)\n+        end\n+\n+        (f_def_placeholders(), f_def_placeholders(1.0), f_def_placeholders(1.0, 1))\n+    end\n+    \"\"\") == ((Int,Float64), (Float64,Float64), (Float64,Int))\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_def_typevars(x, y::S=[1], z::U=2) where {T, S<:AbstractVector{T}, U}\n+            (x, y, z, T, S, U)\n+        end\n+\n+        (f_def_typevars(1), f_def_typevars(1,[1.0]), f_def_typevars(1,[1.0],-1.0))\n+    end\n+    \"\"\") == ((1, [1], 2, Int, Vector{Int}, Int),\n+             (1, [1.0], 2, Float64, Vector{Float64}, Int),\n+             (1, [1.0], -1.0, Float64, Vector{Float64}, Float64))\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_def_typevar_vararg_undef(x::T, y::Vararg{S}) where {T,S}\n+            (x, y, @isdefined S)\n+        end\n+\n+        (f_def_typevar_vararg_undef(1), f_def_typevar_vararg_undef(1,2), f_def_typevar_vararg_undef(1,2,3))\n+    end\n+    \"\"\") === ((1, (), false), (1, (2,), true), (1, (2, 3), true))\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        f_def_typevar_with_lowerbound(x::T) where {T>:Int} =\n+            (x, @isdefined(T))\n+        (f_def_typevar_with_lowerbound(1), f_def_typevar_with_lowerbound(1.0))\n+    end\n+    \"\"\") == ((1, true), (1.0, false))\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_def_slurp(x=1, ys...)\n+            (x, ys)\n+        end\n+\n+        (f_def_slurp(), f_def_slurp(2), f_def_slurp(2,3))\n+    end\n+    \"\"\") == ((1, ()),\n+             (2, ()),\n+             (2, (3,)))\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_def_ret_type(x=1.0)::Int\n+            x\n+        end\n+\n+        (f_def_ret_type(), f_def_ret_type(10.0))\n+    end\n+    \"\"\") === (1,10)\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_def_slurp_splat(ys...=(1,2)...)\n+            ys\n+        end\n+\n+        (f_def_slurp_splat(), f_def_slurp_splat(10,20))\n+    end\n+    \"\"\") == ((1,2),\n+             (10,20))\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_def_destructure(x, (y,z)::Tuple{Int,Int}, (w,)...=(4,)...)\n+            (x,y,z,w)\n+        end\n+\n+        f_def_destructure(1, (2,3))\n+    end\n+    \"\"\") == (1,2,3,4)\n+\n+end\n+\n+@testset \"Slot flags\" begin\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_nospecialize(u, v, @nospecialize(x), y, @nospecialize(z))\n+            (u, v, x, y, z)\n+        end\n+\n+        f_nospecialize(1,2,3,4,5)\n+    end\n+    \"\"\") == (1,2,3,4,5)\n+    # We dig into the internal of `Method` here to check which slots have been\n+    # flagged as nospecialize.\n+    @test only(methods(test_mod.f_nospecialize)).nospecialize == 0b10100\n+\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    function f_slotflags(x, y, f, z)\n+        f() + x + y\n+    end\n+    \"\"\")\n+    @test only(methods(test_mod.f_slotflags)).called == 0b0100\n+\n+    # Branching combined with nospecialize meta in CodeInfo\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        function f_branch_meta(@nospecialize(x), cond)\n+            if cond\n+                x + 1\n+            else\n+                x + 2\n+            end\n+        end\n+\n+        (f_branch_meta(10, false), f_branch_meta(20, true))\n+    end\n+    \"\"\") == (12, 21)\n+end\n+\n+@testset \"Keyword functions\" begin\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    function f_kw_simple(a::Int=1, b::Float64=1.0; x::Char='a', y::Bool=true)\n+        (a, b, x, y)\n+    end\n+    \"\"\")\n+\n+    @test test_mod.f_kw_simple()               === (1, 1.0, 'a', true)\n+    @test test_mod.f_kw_simple(x='b')          === (1, 1.0, 'b', true)\n+    @test test_mod.f_kw_simple(y=false)        === (1, 1.0, 'a', false)\n+    @test test_mod.f_kw_simple(x='b', y=false) === (1, 1.0, 'b', false)\n+\n+    @test test_mod.f_kw_simple(20)                 === (20, 1.0, 'a', true)\n+    @test test_mod.f_kw_simple(20; x='b')          === (20, 1.0, 'b', true)\n+    @test test_mod.f_kw_simple(20; y=false)        === (20, 1.0, 'a', false)\n+    @test test_mod.f_kw_simple(20; x='b', y=false) === (20, 1.0, 'b', false)\n+\n+    @test test_mod.f_kw_simple(20, 2.0)                 === (20, 2.0, 'a', true)\n+    @test test_mod.f_kw_simple(20, 2.0; x='b')          === (20, 2.0, 'b', true)\n+    @test test_mod.f_kw_simple(20, 2.0; y=false)        === (20, 2.0, 'a', false)\n+    @test test_mod.f_kw_simple(20, 2.0; x='b', y=false) === (20, 2.0, 'b', false)\n+\n+    # Bad types for keyword args throw a type error\n+    @test_throws(TypeError(Symbol(\"keyword argument\"), :x, Char, 100),\n+                 test_mod.f_kw_simple(x=100))\n+    @test_throws(TypeError(Symbol(\"keyword argument\"), :y, Bool, 100),\n+                 test_mod.f_kw_simple(y=100))\n+\n+    # Keywords which aren't present throw an error\n+    try\n+        test_mod.f_kw_simple(20; not_present=100)\n+        @test false\n+    catch exc\n+        @test exc isa MethodError\n+        @test exc.f == Core.kwcall\n+        @test exc.args == ((; not_present=100), test_mod.f_kw_simple, 20, 1.0)\n+    end\n+\n+    # Slurping of positional args with keywords\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    function f_pos_slurp_with_kws(z, args...; x=1,y=2)\n+        args\n+    end\n+    \"\"\")\n+    @test test_mod.f_pos_slurp_with_kws(3, 2, 1; x = 100) === (2,1)\n+    @test test_mod.f_pos_slurp_with_kws(3, 2, 1) === (2,1)\n+\n+    # Slurping of keyword args\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    function f_kw_slurp_all(; kws...)\n+        kws\n+    end\n+    \"\"\")\n+    @test values(test_mod.f_kw_slurp_all(x = 1, y = 2)) === (x=1, y=2)\n+    @test values(test_mod.f_kw_slurp_all()) === (;)\n+\n+    # Slurping of keyword args\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    function f_kw_slurp_some(; x=1, y=2, kws...)\n+        kws\n+    end\n+    \"\"\")\n+    @test values(test_mod.f_kw_slurp_some(z=3, x = 1, y = 2, w=4)) === (z=3, w=4)\n+    @test values(test_mod.f_kw_slurp_some(x = 1)) === (;)\n+    @test values(test_mod.f_kw_slurp_some()) === (;)\n+\n+    # Keyword defaults which depend on other keywords.\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    begin\n+        aaa = :outer\n+        function f_kw_default_dependencies(; x=1, y=x, bbb=aaa, aaa=:aaa_kw, ccc=aaa)\n+            (x, y, bbb, aaa, ccc)\n+        end\n+    end\n+    \"\"\")\n+    @test values(test_mod.f_kw_default_dependencies()) === (1, 1, :outer, :aaa_kw, :aaa_kw)\n+    @test values(test_mod.f_kw_default_dependencies(x = 10)) === (10, 10, :outer, :aaa_kw, :aaa_kw)\n+    @test values(test_mod.f_kw_default_dependencies(x = 10, aaa=:blah)) === (10, 10, :outer, :blah, :blah)\n+\n+    # Keywords with static parameters\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    function f_kw_sparams(x::X, y::Y; a::A, b::B) where {X,Y,A,B}\n+        (X,Y,A,B)\n+    end\n+    \"\"\")\n+    @test values(test_mod.f_kw_sparams(1, 1.0; a=\"a\", b='b')) === (Int, Float64, String, Char)\n+\n+    # Keywords with static parameters, where some keyword types can be inferred\n+    # based on the positional parameters and others cannot.\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    function f_kw_type_errors(x::X; a::F, b::X) where {X<:Integer,F<:AbstractFloat}\n+        (X,F)\n+    end\n+    \"\"\")\n+    @test values(test_mod.f_kw_type_errors(1; a=1.0, b=10)) === (Int, Float64)\n+    # The following is a keyword TypeError because we can infer `X` based on\n+    # the positional parameters and use that to check the type of `b`.\n+    @test_throws TypeError values(test_mod.f_kw_type_errors(1; a=1.0, b=\"str\"))\n+    # The following is only a method error as we can't infer `F` prior to\n+    # dispatching to the body function.\n+    @test_throws MethodError values(test_mod.f_kw_type_errors(1; a=\"str\", b=10))\n+\n+    # Throwing of UndefKeywordError\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    function f_kw_no_default(; x)\n+        x\n+    end\n+    \"\"\")\n+    @test test_mod.f_kw_no_default(x = 10) == 10\n+    @test_throws UndefKeywordError(:x) test_mod.f_kw_no_default() == 10\n+\n+    # Closure with keywords\n+    cl = JuliaLowering.include_string(test_mod, \"\"\"\n+    let y = 1\n+        function f_kw_closure(; x=10)\n+            x + y\n+        end\n+    end\n+    \"\"\")\n+    @test cl() == 11\n+    @test cl(x = 20) == 21\n+end\n+\n+@testset \"Generated functions\" begin\n+    @test JuliaLowering.include_string(test_mod, raw\"\"\"\n+    begin\n+        @generated function f_gen(x::NTuple{N,T}) where {N,T}\n+            quote\n+                ($x, $N, $T)\n+            end\n+        end\n+\n+        f_gen((1,2,3,4,5))\n+    end\n+    \"\"\") == (NTuple{5,Int}, 5, Int)\n+\n+    @test JuliaLowering.include_string(test_mod, raw\"\"\"\n+    begin\n+        function f_partially_gen(x::NTuple{N,T}) where {N,T}\n+            shared = :shared_stuff\n+            if @generated\n+                if N == 2\n+                    error(\"intentionally broken codegen (will trigger nongen branch)\")\n+                end\n+                quote\n+                    unshared = (:gen, ($x, $N, $T))\n+                end\n+            else\n+                unshared = (:nongen, (typeof(x), N, T))\n+            end\n+            (shared, unshared)\n+        end\n+\n+        (f_partially_gen((1,2)), f_partially_gen((1,2,3,4,5)))\n+    end\n+    \"\"\") == ((:shared_stuff, (:nongen, (NTuple{2,Int}, 2, Int))),\n+             (:shared_stuff, (:gen, (NTuple{5,Int}, 5, Int))))\n+\n+    # Test generated function edges to bindings\n+    # (see also https://github.com/JuliaLang/julia/pull/57230)\n+    JuliaLowering.include_string(test_mod, raw\"\"\"\n+    const delete_me = 4\n+    @generated f_generated_return_delete_me() = return :(delete_me)\n+    \"\"\")\n+    @test test_mod.f_generated_return_delete_me() == 4\n+    Base.delete_binding(test_mod, :delete_me)\n+    @test_throws UndefVarError test_mod.f_generated_return_delete_me()\n+end\n+\n+@testset \"Broadcast\" begin\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let x = [1,2], y = [3,4], z = [5,6]\n+        x .* y .+ z\n+    end\n+    \"\"\") == [8, 14]\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let nums = [1, 2, 3]\n+        string.(nums, base=2; pad=2)\n+    end\n+    \"\"\") == [\"01\", \"10\", \"11\"]\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let lhs = [0,0], x = [1,2], y = [3,4], z = [5,6]\n+        lhs .= x .* y .+ z\n+        lhs\n+    end\n+    \"\"\") == [8, 14]\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    [1,2] .+ ([3,4] .< [5,6] .< [7,1])\n+    \"\"\") == [2, 2]\n+\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let\n+        x = [0,0,0,0]\n+        x[begin+1:end-1] .= [1,2] .+ [3,4]\n+        x\n+    end\n+    \"\"\") == [0,4,6,0]\n+end\n+\n+end"
    },
    {
      "sha": "a537757b881baa6110b299afc2e8fc17582b9c24",
      "filename": "JuliaLowering/test/functions_ir.jl",
      "status": "added",
      "additions": 1592,
      "deletions": 0,
      "changes": 1592,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Ffunctions_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Ffunctions_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Ffunctions_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,1592 @@\n+########################################\n+# Function declaration with no methods\n+function f\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (return %\u2083)\n+\n+########################################\n+# Functions with placeholder arg\n+function f(x, _, y)\n+    x + y\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084 core.Any core.Any core.Any)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/_(!read) slot\u2084/y]\n+    1   TestMod.+\n+    2   (call %\u2081 slot\u2082/x slot\u2084/y)\n+    3   (return %\u2082)\n+10  latestworld\n+11  TestMod.f\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Functions with argument types only, no name\n+function f(::T, x)\n+    x\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   TestMod.T\n+6   (call core.svec %\u2084 %\u2085 core.Any)\n+7   (call core.svec)\n+8   SourceLocation::1:10\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/_(!read) slot\u2083/x]\n+    1   slot\u2083/x\n+    2   (return %\u2081)\n+11  latestworld\n+12  TestMod.f\n+13  (return %\u2081\u2082)\n+\n+########################################\n+# Functions argument types\n+function f(x, y::T)\n+    body\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   TestMod.T\n+6   (call core.svec %\u2084 core.Any %\u2085)\n+7   (call core.svec)\n+8   SourceLocation::1:10\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/y(!read)]\n+    1   TestMod.body\n+    2   (return %\u2081)\n+11  latestworld\n+12  TestMod.f\n+13  (return %\u2081\u2082)\n+\n+########################################\n+# Functions with slurp of Any\n+function f(x, ys...)\n+    body\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.apply_type core.Vararg core.Any)\n+6   (call core.svec %\u2084 core.Any %\u2085)\n+7   (call core.svec)\n+8   SourceLocation::1:10\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/ys(!read)]\n+    1   TestMod.body\n+    2   (return %\u2081)\n+11  latestworld\n+12  TestMod.f\n+13  (return %\u2081\u2082)\n+\n+########################################\n+# Functions with slurp of T\n+function f(x, ys::T...)\n+    body\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   TestMod.T\n+6   (call core.apply_type core.Vararg %\u2085)\n+7   (call core.svec %\u2084 core.Any %\u2086)\n+8   (call core.svec)\n+9   SourceLocation::1:10\n+10  (call core.svec %\u2087 %\u2088 %\u2089)\n+11  --- method core.nothing %\u2081\u2080\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/ys(!read)]\n+    1   TestMod.body\n+    2   (return %\u2081)\n+12  latestworld\n+13  TestMod.f\n+14  (return %\u2081\u2083)\n+\n+########################################\n+# Error: Function with slurp not in last position arg\n+function f(xs..., y)\n+    body\n+end\n+#---------------------\n+LoweringError:\n+function f(xs..., y)\n+#          \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 `...` may only be used for the last positional argument\n+    body\n+end\n+\n+########################################\n+# Basic static parameters\n+function f(::T, ::U, ::V) where T where {U,V}\n+    (T,U,V)\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   (= slot\u2082/U (call core.TypeVar :U))\n+4   (= slot\u2083/V (call core.TypeVar :V))\n+5   (= slot\u2081/T (call core.TypeVar :T))\n+6   TestMod.f\n+7   (call core.Typeof %\u2086)\n+8   slot\u2081/T\n+9   slot\u2082/U\n+10  slot\u2083/V\n+11  (call core.svec %\u2087 %\u2088 %\u2089 %\u2081\u2080)\n+12  slot\u2082/U\n+13  slot\u2083/V\n+14  slot\u2081/T\n+15  (call core.svec %\u2081\u2082 %\u2081\u2083 %\u2081\u2084)\n+16  SourceLocation::1:10\n+17  (call core.svec %\u2081\u2081 %\u2081\u2085 %\u2081\u2086)\n+18  --- method core.nothing %\u2081\u2087\n+    slots: [slot\u2081/#self#(!read) slot\u2082/_(!read) slot\u2083/_(!read) slot\u2084/_(!read)]\n+    1   static_parameter\u2083\n+    2   static_parameter\u2081\n+    3   static_parameter\u2082\n+    4   (call core.tuple %\u2081 %\u2082 %\u2083)\n+    5   (return %\u2084)\n+19  latestworld\n+20  TestMod.f\n+21  (return %\u2082\u2080)\n+\n+########################################\n+# Static parameter with bounds and used with apply_type in argument\n+function f(::S{T}) where X <: T <: Y\n+    T\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.X\n+4   TestMod.Y\n+5   (= slot\u2081/T (call core.TypeVar :T %\u2083 %\u2084))\n+6   TestMod.f\n+7   (call core.Typeof %\u2086)\n+8   TestMod.S\n+9   slot\u2081/T\n+10  (call core.apply_type %\u2088 %\u2089)\n+11  (call core.svec %\u2087 %\u2081\u2080)\n+12  slot\u2081/T\n+13  (call core.svec %\u2081\u2082)\n+14  SourceLocation::1:10\n+15  (call core.svec %\u2081\u2081 %\u2081\u2083 %\u2081\u2084)\n+16  --- method core.nothing %\u2081\u2085\n+    slots: [slot\u2081/#self#(!read) slot\u2082/_(!read)]\n+    1   static_parameter\u2081\n+    2   (return %\u2081)\n+17  latestworld\n+18  TestMod.f\n+19  (return %\u2081\u2088)\n+\n+########################################\n+# Static parameter with lower bound\n+function f(::S{T}) where T >: X\n+    T\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.X\n+4   (= slot\u2081/T (call core.TypeVar :T %\u2083 core.Any))\n+5   TestMod.f\n+6   (call core.Typeof %\u2085)\n+7   TestMod.S\n+8   slot\u2081/T\n+9   (call core.apply_type %\u2087 %\u2088)\n+10  (call core.svec %\u2086 %\u2089)\n+11  slot\u2081/T\n+12  (call core.svec %\u2081\u2081)\n+13  SourceLocation::1:10\n+14  (call core.svec %\u2081\u2080 %\u2081\u2082 %\u2081\u2083)\n+15  --- method core.nothing %\u2081\u2084\n+    slots: [slot\u2081/#self#(!read) slot\u2082/_(!read)]\n+    1   static_parameter\u2081\n+    2   (return %\u2081)\n+16  latestworld\n+17  TestMod.f\n+18  (return %\u2081\u2087)\n+\n+########################################\n+# Static parameter which is used only in the bounds of another static parameter\n+# See https://github.com/JuliaLang/julia/issues/49275\n+function f(x, y::S) where {T, S<:AbstractVector{T}}\n+    (T,S)\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   (= slot\u2082/T (call core.TypeVar :T))\n+4   TestMod.AbstractVector\n+5   slot\u2082/T\n+6   (call core.apply_type %\u2084 %\u2085)\n+7   (= slot\u2081/S (call core.TypeVar :S %\u2086))\n+8   TestMod.f\n+9   (call core.Typeof %\u2088)\n+10  slot\u2081/S\n+11  (call core.svec %\u2089 core.Any %\u2081\u2080)\n+12  slot\u2082/T\n+13  slot\u2081/S\n+14  (call core.svec %\u2081\u2082 %\u2081\u2083)\n+15  SourceLocation::1:10\n+16  (call core.svec %\u2081\u2081 %\u2081\u2084 %\u2081\u2085)\n+17  --- method core.nothing %\u2081\u2086\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/y(!read)]\n+    1   static_parameter\u2081\n+    2   static_parameter\u2082\n+    3   (call core.tuple %\u2081 %\u2082)\n+    4   (return %\u2083)\n+18  latestworld\n+19  TestMod.f\n+20  (return %\u2081\u2089)\n+\n+########################################\n+# Error: Static parameter which is unused\n+function f(::T) where {T,S}\n+    (T,S)\n+end\n+#---------------------\n+LoweringError:\n+function f(::T) where {T,S}\n+#                        \u2559 \u2500\u2500 Method definition declares type variable but does not use it in the type of any function parameter\n+    (T,S)\n+end\n+\n+########################################\n+# Return types\n+function f(x)::Int\n+    if x\n+        42.0\n+    end\n+    0xff\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084 core.Any)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/tmp(!read)]\n+    1   TestMod.Int\n+    2   (gotoifnot slot\u2082/x label\u2083)\n+    3   (= slot\u2083/tmp 0xff)\n+    4   slot\u2083/tmp\n+    5   (call core.isa %\u2084 %\u2081)\n+    6   (gotoifnot %\u2085 label\u2088)\n+    7   (goto label\u2081\u2081)\n+    8   slot\u2083/tmp\n+    9   (call top.convert %\u2081 %\u2088)\n+    10  (= slot\u2083/tmp (call core.typeassert %\u2089 %\u2081))\n+    11  slot\u2083/tmp\n+    12  (return %\u2081\u2081)\n+10  latestworld\n+11  TestMod.f\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Callable type\n+function (::T)(x)\n+    x\n+end\n+#---------------------\n+1   TestMod.T\n+2   (call core.svec %\u2081 core.Any)\n+3   (call core.svec)\n+4   SourceLocation::1:10\n+5   (call core.svec %\u2082 %\u2083 %\u2084)\n+6   --- method core.nothing %\u2085\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x]\n+    1   slot\u2082/x\n+    2   (return %\u2081)\n+7   latestworld\n+8   (return core.nothing)\n+\n+########################################\n+# Callable type with instance\n+function (y::T)(x)\n+    (y, x)\n+end\n+#---------------------\n+1   TestMod.T\n+2   (call core.svec %\u2081 core.Any)\n+3   (call core.svec)\n+4   SourceLocation::1:10\n+5   (call core.svec %\u2082 %\u2083 %\u2084)\n+6   --- method core.nothing %\u2085\n+    slots: [slot\u2081/y slot\u2082/x]\n+    1   (call core.tuple slot\u2081/y slot\u2082/x)\n+    2   (return %\u2081)\n+7   latestworld\n+8   (return core.nothing)\n+\n+########################################\n+# `where` params used in callable object type\n+function (x::X1{T})() where T\n+    T\n+end\n+#---------------------\n+1   (= slot\u2081/T (call core.TypeVar :T))\n+2   TestMod.X1\n+3   slot\u2081/T\n+4   (call core.apply_type %\u2082 %\u2083)\n+5   (call core.svec %\u2084)\n+6   slot\u2081/T\n+7   (call core.svec %\u2086)\n+8   SourceLocation::1:10\n+9   (call core.svec %\u2085 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/x(!read)]\n+    1   static_parameter\u2081\n+    2   (return %\u2081)\n+11  latestworld\n+12  (return core.nothing)\n+\n+########################################\n+# Function with module ref in name\n+function A.f()\n+end\n+#---------------------\n+1   TestMod.A\n+2   (call top.getproperty %\u2081 :f)\n+3   (call core.Typeof %\u2082)\n+4   (call core.svec %\u2083)\n+5   (call core.svec)\n+6   SourceLocation::1:10\n+7   (call core.svec %\u2084 %\u2085 %\u2086)\n+8   --- method core.nothing %\u2087\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (return core.nothing)\n+9   latestworld\n+10  (return core.nothing)\n+\n+########################################\n+# Error: Invalid dotop function name\n+function (.+)(x,y)\n+end\n+#---------------------\n+LoweringError:\n+function (.+)(x,y)\n+#        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Cannot define function using `.` broadcast syntax\n+end\n+\n+########################################\n+# Error: Invalid function name\n+function f[](x,y)\n+end\n+#---------------------\n+LoweringError:\n+function f[](x,y)\n+#        \u2514\u2500\u2518 \u2500\u2500 Invalid function name\n+end\n+\n+########################################\n+# Simple positional args with defaults\n+function f(x::T, y::S=1, z::U=2)\n+    (x,y)\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   TestMod.T\n+6   (call core.svec %\u2084 %\u2085)\n+7   (call core.svec)\n+8   SourceLocation::1:10\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(called) slot\u2082/x]\n+    1   (call slot\u2081/#self# slot\u2082/x 1 2)\n+    2   (return %\u2081)\n+11  latestworld\n+12  TestMod.f\n+13  (call core.Typeof %\u2081\u2082)\n+14  TestMod.T\n+15  TestMod.S\n+16  (call core.svec %\u2081\u2083 %\u2081\u2084 %\u2081\u2085)\n+17  (call core.svec)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(called) slot\u2082/x slot\u2083/y]\n+    1   (call slot\u2081/#self# slot\u2082/x slot\u2083/y 2)\n+    2   (return %\u2081)\n+21  latestworld\n+22  TestMod.f\n+23  (call core.Typeof %\u2082\u2082)\n+24  TestMod.T\n+25  TestMod.S\n+26  TestMod.U\n+27  (call core.svec %\u2082\u2083 %\u2082\u2084 %\u2082\u2085 %\u2082\u2086)\n+28  (call core.svec)\n+29  SourceLocation::1:10\n+30  (call core.svec %\u2082\u2087 %\u2082\u2088 %\u2082\u2089)\n+31  --- method core.nothing %\u2083\u2080\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/z(!read)]\n+    1   (call core.tuple slot\u2082/x slot\u2083/y)\n+    2   (return %\u2081)\n+32  latestworld\n+33  TestMod.f\n+34  (return %\u2083\u2083)\n+\n+########################################\n+# Default positional args which depend on other args\n+function f(x=1, y=x)\n+    (x,y)\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(called)]\n+    1   (call slot\u2081/#self# 1)\n+    2   (return %\u2081)\n+10  latestworld\n+11  TestMod.f\n+12  (call core.Typeof %\u2081\u2081)\n+13  (call core.svec %\u2081\u2082 core.Any)\n+14  (call core.svec)\n+15  SourceLocation::1:10\n+16  (call core.svec %\u2081\u2083 %\u2081\u2084 %\u2081\u2085)\n+17  --- method core.nothing %\u2081\u2086\n+    slots: [slot\u2081/#self#(called) slot\u2082/x]\n+    1   (call slot\u2081/#self# slot\u2082/x slot\u2082/x)\n+    2   (return %\u2081)\n+18  latestworld\n+19  TestMod.f\n+20  (call core.Typeof %\u2081\u2089)\n+21  (call core.svec %\u2082\u2080 core.Any core.Any)\n+22  (call core.svec)\n+23  SourceLocation::1:10\n+24  (call core.svec %\u2082\u2081 %\u2082\u2082 %\u2082\u2083)\n+25  --- method core.nothing %\u2082\u2084\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y]\n+    1   (call core.tuple slot\u2082/x slot\u2083/y)\n+    2   (return %\u2081)\n+26  latestworld\n+27  TestMod.f\n+28  (return %\u2082\u2087)\n+\n+########################################\n+# Default positional args with missing arg names (implicit placeholders)\n+function f(::Int, y=1, z=2)\n+    (y, z)\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   TestMod.Int\n+6   (call core.svec %\u2084 %\u2085)\n+7   (call core.svec)\n+8   SourceLocation::1:10\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(called) slot\u2082/_]\n+    1   (call slot\u2081/#self# slot\u2082/_ 1 2)\n+    2   (return %\u2081)\n+11  latestworld\n+12  TestMod.f\n+13  (call core.Typeof %\u2081\u2082)\n+14  TestMod.Int\n+15  (call core.svec %\u2081\u2083 %\u2081\u2084 core.Any)\n+16  (call core.svec)\n+17  SourceLocation::1:10\n+18  (call core.svec %\u2081\u2085 %\u2081\u2086 %\u2081\u2087)\n+19  --- method core.nothing %\u2081\u2088\n+    slots: [slot\u2081/#self#(called) slot\u2082/_ slot\u2083/y]\n+    1   (call slot\u2081/#self# slot\u2082/_ slot\u2083/y 2)\n+    2   (return %\u2081)\n+20  latestworld\n+21  TestMod.f\n+22  (call core.Typeof %\u2082\u2081)\n+23  TestMod.Int\n+24  (call core.svec %\u2082\u2082 %\u2082\u2083 core.Any core.Any)\n+25  (call core.svec)\n+26  SourceLocation::1:10\n+27  (call core.svec %\u2082\u2084 %\u2082\u2085 %\u2082\u2086)\n+28  --- method core.nothing %\u2082\u2087\n+    slots: [slot\u2081/#self#(!read) slot\u2082/_(!read) slot\u2083/y slot\u2084/z]\n+    1   (call core.tuple slot\u2083/y slot\u2084/z)\n+    2   (return %\u2081)\n+29  latestworld\n+30  TestMod.f\n+31  (return %\u2083\u2080)\n+\n+########################################\n+# Default positional args with placeholders\n+function f(_::Int, x=1)\n+    x\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   TestMod.Int\n+6   (call core.svec %\u2084 %\u2085)\n+7   (call core.svec)\n+8   SourceLocation::1:10\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(called) slot\u2082/_]\n+    1   (call slot\u2081/#self# slot\u2082/_ 1)\n+    2   (return %\u2081)\n+11  latestworld\n+12  TestMod.f\n+13  (call core.Typeof %\u2081\u2082)\n+14  TestMod.Int\n+15  (call core.svec %\u2081\u2083 %\u2081\u2084 core.Any)\n+16  (call core.svec)\n+17  SourceLocation::1:10\n+18  (call core.svec %\u2081\u2085 %\u2081\u2086 %\u2081\u2087)\n+19  --- method core.nothing %\u2081\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/_(!read) slot\u2083/x]\n+    1   slot\u2083/x\n+    2   (return %\u2081)\n+20  latestworld\n+21  TestMod.f\n+22  (return %\u2082\u2081)\n+\n+########################################\n+# Positional args with defaults and `where` clauses\n+function f(x::T, y::S=1, z::U=2) where {T,S<:T,U<:S}\n+    (x,y,z)\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   (= slot\u2082/T (call core.TypeVar :T))\n+4   slot\u2082/T\n+5   (= slot\u2081/S (call core.TypeVar :S %\u2084))\n+6   slot\u2081/S\n+7   (= slot\u2083/U (call core.TypeVar :U %\u2086))\n+8   TestMod.f\n+9   (call core.Typeof %\u2088)\n+10  slot\u2082/T\n+11  (call core.svec %\u2089 %\u2081\u2080)\n+12  slot\u2082/T\n+13  (call core.svec %\u2081\u2082)\n+14  SourceLocation::1:10\n+15  (call core.svec %\u2081\u2081 %\u2081\u2083 %\u2081\u2084)\n+16  --- method core.nothing %\u2081\u2085\n+    slots: [slot\u2081/#self#(called) slot\u2082/x]\n+    1   (call slot\u2081/#self# slot\u2082/x 1 2)\n+    2   (return %\u2081)\n+17  latestworld\n+18  TestMod.f\n+19  (call core.Typeof %\u2081\u2088)\n+20  slot\u2082/T\n+21  slot\u2081/S\n+22  (call core.svec %\u2081\u2089 %\u2082\u2080 %\u2082\u2081)\n+23  slot\u2082/T\n+24  slot\u2081/S\n+25  (call core.svec %\u2082\u2083 %\u2082\u2084)\n+26  SourceLocation::1:10\n+27  (call core.svec %\u2082\u2082 %\u2082\u2085 %\u2082\u2086)\n+28  --- method core.nothing %\u2082\u2087\n+    slots: [slot\u2081/#self#(called) slot\u2082/x slot\u2083/y]\n+    1   (call slot\u2081/#self# slot\u2082/x slot\u2083/y 2)\n+    2   (return %\u2081)\n+29  latestworld\n+30  TestMod.f\n+31  (call core.Typeof %\u2083\u2080)\n+32  slot\u2082/T\n+33  slot\u2081/S\n+34  slot\u2083/U\n+35  (call core.svec %\u2083\u2081 %\u2083\u2082 %\u2083\u2083 %\u2083\u2084)\n+36  slot\u2082/T\n+37  slot\u2081/S\n+38  slot\u2083/U\n+39  (call core.svec %\u2083\u2086 %\u2083\u2087 %\u2083\u2088)\n+40  SourceLocation::1:10\n+41  (call core.svec %\u2083\u2085 %\u2083\u2089 %\u2084\u2080)\n+42  --- method core.nothing %\u2084\u2081\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/z]\n+    1   (call core.tuple slot\u2082/x slot\u2083/y slot\u2084/z)\n+    2   (return %\u2081)\n+43  latestworld\n+44  TestMod.f\n+45  (return %\u2084\u2084)\n+\n+########################################\n+# Positional args and type parameters with transitive dependencies\n+# See https://github.com/JuliaLang/julia/issues/49275 - the first method\n+# generated here for only `x` should contain zero type parameters.\n+function f(x, y::S=[1], z::U=2) where {T, S<:AbstractVector{T}, U}\n+    (x, y, z, T, S, U)\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   (= slot\u2082/T (call core.TypeVar :T))\n+4   TestMod.AbstractVector\n+5   slot\u2082/T\n+6   (call core.apply_type %\u2084 %\u2085)\n+7   (= slot\u2081/S (call core.TypeVar :S %\u2086))\n+8   (= slot\u2083/U (call core.TypeVar :U))\n+9   TestMod.f\n+10  (call core.Typeof %\u2089)\n+11  (call core.svec %\u2081\u2080 core.Any)\n+12  (call core.svec)\n+13  SourceLocation::1:10\n+14  (call core.svec %\u2081\u2081 %\u2081\u2082 %\u2081\u2083)\n+15  --- method core.nothing %\u2081\u2084\n+    slots: [slot\u2081/#self#(called) slot\u2082/x]\n+    1   (call top.vect 1)\n+    2   (call slot\u2081/#self# slot\u2082/x %\u2081 2)\n+    3   (return %\u2082)\n+16  latestworld\n+17  TestMod.f\n+18  (call core.Typeof %\u2081\u2087)\n+19  slot\u2081/S\n+20  (call core.svec %\u2081\u2088 core.Any %\u2081\u2089)\n+21  slot\u2082/T\n+22  slot\u2081/S\n+23  (call core.svec %\u2082\u2081 %\u2082\u2082)\n+24  SourceLocation::1:10\n+25  (call core.svec %\u2082\u2080 %\u2082\u2083 %\u2082\u2084)\n+26  --- method core.nothing %\u2082\u2085\n+    slots: [slot\u2081/#self#(called) slot\u2082/x slot\u2083/y]\n+    1   (call slot\u2081/#self# slot\u2082/x slot\u2083/y 2)\n+    2   (return %\u2081)\n+27  latestworld\n+28  TestMod.f\n+29  (call core.Typeof %\u2082\u2088)\n+30  slot\u2081/S\n+31  slot\u2083/U\n+32  (call core.svec %\u2082\u2089 core.Any %\u2083\u2080 %\u2083\u2081)\n+33  slot\u2082/T\n+34  slot\u2081/S\n+35  slot\u2083/U\n+36  (call core.svec %\u2083\u2083 %\u2083\u2084 %\u2083\u2085)\n+37  SourceLocation::1:10\n+38  (call core.svec %\u2083\u2082 %\u2083\u2086 %\u2083\u2087)\n+39  --- method core.nothing %\u2083\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/z]\n+    1   static_parameter\u2081\n+    2   static_parameter\u2082\n+    3   static_parameter\u2083\n+    4   (call core.tuple slot\u2082/x slot\u2083/y slot\u2084/z %\u2081 %\u2082 %\u2083)\n+    5   (return %\u2084)\n+40  latestworld\n+41  TestMod.f\n+42  (return %\u2084\u2081)\n+\n+########################################\n+# Default positional args are allowed before trailing slurp with no default\n+function f(x=1, ys...)\n+    ys\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(called)]\n+    1   (call slot\u2081/#self# 1)\n+    2   (return %\u2081)\n+10  latestworld\n+11  TestMod.f\n+12  (call core.Typeof %\u2081\u2081)\n+13  (call core.apply_type core.Vararg core.Any)\n+14  (call core.svec %\u2081\u2082 core.Any %\u2081\u2083)\n+15  (call core.svec)\n+16  SourceLocation::1:10\n+17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n+18  --- method core.nothing %\u2081\u2087\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/ys]\n+    1   slot\u2083/ys\n+    2   (return %\u2081)\n+19  latestworld\n+20  TestMod.f\n+21  (return %\u2082\u2080)\n+\n+########################################\n+# Error: Default positional args before non-default arg\n+function f(x=1, ys, z=2)\n+    ys\n+end\n+#---------------------\n+LoweringError:\n+function f(x=1, ys, z=2)\n+#          \u2514\u2500\u2518 \u2500\u2500 optional positional arguments must occur at end\n+    ys\n+end\n+\n+########################################\n+# Positional arg with slurp and default\n+function f(xs...=1)\n+    xs\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(called)]\n+    1   (call slot\u2081/#self# 1)\n+    2   (return %\u2081)\n+10  latestworld\n+11  TestMod.f\n+12  (call core.Typeof %\u2081\u2081)\n+13  (call core.apply_type core.Vararg core.Any)\n+14  (call core.svec %\u2081\u2082 %\u2081\u2083)\n+15  (call core.svec)\n+16  SourceLocation::1:10\n+17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n+18  --- method core.nothing %\u2081\u2087\n+    slots: [slot\u2081/#self#(!read) slot\u2082/xs]\n+    1   slot\u2082/xs\n+    2   (return %\u2081)\n+19  latestworld\n+20  TestMod.f\n+21  (return %\u2082\u2080)\n+\n+########################################\n+# Positional arg with slurp and splatted default value\n+function f(xs...=(1,2)...)\n+    xs\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#]\n+    1   (call core.tuple 1 2)\n+    2   (call core._apply_iterate top.iterate slot\u2081/#self# %\u2081)\n+    3   (return %\u2082)\n+10  latestworld\n+11  TestMod.f\n+12  (call core.Typeof %\u2081\u2081)\n+13  (call core.apply_type core.Vararg core.Any)\n+14  (call core.svec %\u2081\u2082 %\u2081\u2083)\n+15  (call core.svec)\n+16  SourceLocation::1:10\n+17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n+18  --- method core.nothing %\u2081\u2087\n+    slots: [slot\u2081/#self#(!read) slot\u2082/xs]\n+    1   slot\u2082/xs\n+    2   (return %\u2081)\n+19  latestworld\n+20  TestMod.f\n+21  (return %\u2082\u2080)\n+\n+########################################\n+# Trivial function argument destructuring\n+function f(x, (y,z), w)\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084 core.Any core.Any core.Any)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/destructured_arg slot\u2084/w(!read) slot\u2085/iterstate slot\u2086/y(!read) slot\u2087/z(!read)]\n+    1   (call top.indexed_iterate slot\u2083/destructured_arg 1)\n+    2   (= slot\u2086/y (call core.getfield %\u2081 1))\n+    3   (= slot\u2085/iterstate (call core.getfield %\u2081 2))\n+    4   slot\u2085/iterstate\n+    5   (call top.indexed_iterate slot\u2083/destructured_arg 2 %\u2084)\n+    6   (= slot\u2087/z (call core.getfield %\u2085 1))\n+    7   (return core.nothing)\n+10  latestworld\n+11  TestMod.f\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Function argument destructuring combined with splats, types and and defaults\n+function f((x,)::T...=rhs)\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(called)]\n+    1   TestMod.rhs\n+    2   (call slot\u2081/#self# %\u2081)\n+    3   (return %\u2082)\n+10  latestworld\n+11  TestMod.f\n+12  (call core.Typeof %\u2081\u2081)\n+13  TestMod.T\n+14  (call core.apply_type core.Vararg %\u2081\u2083)\n+15  (call core.svec %\u2081\u2082 %\u2081\u2084)\n+16  (call core.svec)\n+17  SourceLocation::1:10\n+18  (call core.svec %\u2081\u2085 %\u2081\u2086 %\u2081\u2087)\n+19  --- method core.nothing %\u2081\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/x(!read)]\n+    1   (call top.indexed_iterate slot\u2082/destructured_arg 1)\n+    2   (= slot\u2083/x (call core.getfield %\u2081 1))\n+    3   (return core.nothing)\n+20  latestworld\n+21  TestMod.f\n+22  (return %\u2082\u2081)\n+\n+########################################\n+# Function argument destructuring combined with splats, types and and defaults\n+function f(x=default_x)::T\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(called)]\n+    1   TestMod.default_x\n+    2   (call slot\u2081/#self# %\u2081)\n+    3   (return %\u2082)\n+10  latestworld\n+11  TestMod.f\n+12  (call core.Typeof %\u2081\u2081)\n+13  (call core.svec %\u2081\u2082 core.Any)\n+14  (call core.svec)\n+15  SourceLocation::1:10\n+16  (call core.svec %\u2081\u2083 %\u2081\u2084 %\u2081\u2085)\n+17  --- method core.nothing %\u2081\u2086\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/tmp(!read)]\n+    1   TestMod.T\n+    2   (= slot\u2083/tmp core.nothing)\n+    3   slot\u2083/tmp\n+    4   (call core.isa %\u2083 %\u2081)\n+    5   (gotoifnot %\u2084 label\u2087)\n+    6   (goto label\u2081\u2080)\n+    7   slot\u2083/tmp\n+    8   (call top.convert %\u2081 %\u2087)\n+    9   (= slot\u2083/tmp (call core.typeassert %\u2088 %\u2081))\n+    10  slot\u2083/tmp\n+    11  (return %\u2081\u2080)\n+18  latestworld\n+19  TestMod.f\n+20  (return %\u2081\u2089)\n+\n+########################################\n+# Duplicate destructured placeholders ok\n+function f((_,), (_,))\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084 core.Any core.Any)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/destructured_arg]\n+    1   (call top.indexed_iterate slot\u2082/destructured_arg 1)\n+    2   (call core.getfield %\u2081 1)\n+    3   (call top.indexed_iterate slot\u2083/destructured_arg 1)\n+    4   (call core.getfield %\u2083 1)\n+    5   (return core.nothing)\n+10  latestworld\n+11  TestMod.f\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Slot flags\n+function f(@nospecialize(x), g, y)\n+    g() + y\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084 core.Any core.Any core.Any)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(nospecialize,!read) slot\u2083/g(called) slot\u2084/y]\n+    1   TestMod.+\n+    2   (call slot\u2083/g)\n+    3   (call %\u2081 %\u2082 slot\u2084/y)\n+    4   (return %\u2083)\n+10  latestworld\n+11  TestMod.f\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Function return without arguments\n+function f()\n+    return\n+    after_return # <- distinguish output from implicit return\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (return core.nothing)\n+    2   TestMod.after_return\n+    3   (return %\u2082)\n+10  latestworld\n+11  TestMod.f\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Function return in value position is allowed\n+function f()\n+    x = return 1\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read)]\n+    1   (return 1)\n+    2   (= slot\u2082/x core.nothing)\n+10  latestworld\n+11  TestMod.f\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Binding docs to functions\n+\"\"\"\n+some docs\n+\"\"\"\n+function f()\n+end\n+#---------------------\n+1   (method TestMod.f)\n+2   latestworld\n+3   TestMod.f\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::4:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (return core.nothing)\n+10  latestworld\n+11  TestMod.f\n+12  (call JuliaLowering.bind_docs! %\u2081\u2081 \"some docs\\n\" %\u2088)\n+13  TestMod.f\n+14  (return %\u2081\u2083)\n+\n+########################################\n+# Binding docs to callable type\n+\"\"\"\n+some docs\n+\"\"\"\n+function (x::T)()\n+end\n+#---------------------\n+1   TestMod.T\n+2   (call core.svec %\u2081)\n+3   (call core.svec)\n+4   SourceLocation::4:10\n+5   (call core.svec %\u2082 %\u2083 %\u2084)\n+6   --- method core.nothing %\u2085\n+    slots: [slot\u2081/x(!read)]\n+    1   (return core.nothing)\n+7   latestworld\n+8   TestMod.T\n+9   (call JuliaLowering.bind_docs! %\u2088 \"some docs\\n\" %\u2085)\n+10  (return core.nothing)\n+\n+########################################\n+# Keyword function with defaults.\n+# Order of methods\n+# 1. #f_kw_simple#0(x, y, ::typeof(f_kw_simple), a, b)  (body)\n+# 2. Core.kwcall(kws, ::typeof(f_kw_simple))\n+# 3. Core.kwcall(kws, ::typeof(f_kw_simple), a)\n+# 4. Core.kwcall(kws, ::typeof(f_kw_simple), a, b)      (kwcall body)\n+# 5. f_kw_simple()\n+# 6. f_kw_simple(a)\n+# 7. f_kw_simple(a, b)\n+function f_kw_simple(a::Int=1, b::Float64=1.0; x::Char='a', y::Bool=true)\n+    (a, b, x, y)\n+end\n+#---------------------\n+1   (method TestMod.f_kw_simple)\n+2   latestworld\n+3   (method TestMod.#f_kw_simple#0)\n+4   latestworld\n+5   TestMod.#f_kw_simple#0\n+6   (call core.Typeof %\u2085)\n+7   TestMod.Char\n+8   TestMod.Bool\n+9   TestMod.f_kw_simple\n+10  (call core.Typeof %\u2089)\n+11  TestMod.Int\n+12  TestMod.Float64\n+13  (call core.svec %\u2086 %\u2087 %\u2088 %\u2081\u2080 %\u2081\u2081 %\u2081\u2082)\n+14  (call core.svec)\n+15  SourceLocation::1:10\n+16  (call core.svec %\u2081\u2083 %\u2081\u2084 %\u2081\u2085)\n+17  --- method core.nothing %\u2081\u2086\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/#self#(!read) slot\u2085/a slot\u2086/b]\n+    1   (meta :nkw 2)\n+    2   (call core.tuple slot\u2085/a slot\u2086/b slot\u2082/x slot\u2083/y)\n+    3   (return %\u2082)\n+18  latestworld\n+19  (call core.typeof core.kwcall)\n+20  TestMod.f_kw_simple\n+21  (call core.Typeof %\u2082\u2080)\n+22  (call core.svec %\u2081\u2089 core.NamedTuple %\u2082\u2081)\n+23  (call core.svec)\n+24  SourceLocation::1:10\n+25  (call core.svec %\u2082\u2082 %\u2082\u2083 %\u2082\u2084)\n+26  --- method core.nothing %\u2082\u2085\n+    slots: [slot\u2081/#self#(called) slot\u2082/kws slot\u2083/#self#]\n+    1   (call slot\u2081/#self# slot\u2082/kws slot\u2083/#self# 1 1.0)\n+    2   (return %\u2081)\n+27  latestworld\n+28  (call core.typeof core.kwcall)\n+29  TestMod.f_kw_simple\n+30  (call core.Typeof %\u2082\u2089)\n+31  TestMod.Int\n+32  (call core.svec %\u2082\u2088 core.NamedTuple %\u2083\u2080 %\u2083\u2081)\n+33  (call core.svec)\n+34  SourceLocation::1:10\n+35  (call core.svec %\u2083\u2082 %\u2083\u2083 %\u2083\u2084)\n+36  --- method core.nothing %\u2083\u2085\n+    slots: [slot\u2081/#self#(called) slot\u2082/kws slot\u2083/#self# slot\u2084/a]\n+    1   (call slot\u2081/#self# slot\u2082/kws slot\u2083/#self# slot\u2084/a 1.0)\n+    2   (return %\u2081)\n+37  latestworld\n+38  (call core.typeof core.kwcall)\n+39  TestMod.f_kw_simple\n+40  (call core.Typeof %\u2083\u2089)\n+41  TestMod.Int\n+42  TestMod.Float64\n+43  (call core.svec %\u2083\u2088 core.NamedTuple %\u2084\u2080 %\u2084\u2081 %\u2084\u2082)\n+44  (call core.svec)\n+45  SourceLocation::1:10\n+46  (call core.svec %\u2084\u2083 %\u2084\u2084 %\u2084\u2085)\n+47  --- method core.nothing %\u2084\u2086\n+    slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/a slot\u2085/b slot\u2086/kwtmp slot\u2087/x(!read) slot\u2088/y(!read)]\n+    1   (newvar slot\u2087/x)\n+    2   (newvar slot\u2088/y)\n+    3   (call core.isdefined slot\u2082/kws :x)\n+    4   (gotoifnot %\u2083 label\u2081\u2085)\n+    5   (call core.getfield slot\u2082/kws :x)\n+    6   TestMod.Char\n+    7   (call core.isa %\u2085 %\u2086)\n+    8   (gotoifnot %\u2087 label\u2081\u2080)\n+    9   (goto label\u2081\u2083)\n+    10  TestMod.Char\n+    11  (new core.TypeError :keyword argument :x %\u2081\u2080 %\u2085)\n+    12  (call core.throw %\u2081\u2081)\n+    13  (= slot\u2086/kwtmp %\u2085)\n+    14  (goto label\u2081\u2086)\n+    15  (= slot\u2086/kwtmp 'a')\n+    16  slot\u2086/kwtmp\n+    17  (call core.isdefined slot\u2082/kws :y)\n+    18  (gotoifnot %\u2081\u2087 label\u2082\u2089)\n+    19  (call core.getfield slot\u2082/kws :y)\n+    20  TestMod.Bool\n+    21  (call core.isa %\u2081\u2089 %\u2082\u2080)\n+    22  (gotoifnot %\u2082\u2081 label\u2082\u2084)\n+    23  (goto label\u2082\u2087)\n+    24  TestMod.Bool\n+    25  (new core.TypeError :keyword argument :y %\u2082\u2084 %\u2081\u2089)\n+    26  (call core.throw %\u2082\u2085)\n+    27  (= slot\u2086/kwtmp %\u2081\u2089)\n+    28  (goto label\u2083\u2080)\n+    29  (= slot\u2086/kwtmp true)\n+    30  slot\u2086/kwtmp\n+    31  (call top.keys slot\u2082/kws)\n+    32  (call core.tuple :x :y)\n+    33  (call top.diff_names %\u2083\u2081 %\u2083\u2082)\n+    34  (call top.isempty %\u2083\u2083)\n+    35  (gotoifnot %\u2083\u2084 label\u2083\u2087)\n+    36  (goto label\u2083\u2088)\n+    37  (call top.kwerr slot\u2082/kws slot\u2083/#self# slot\u2084/a slot\u2085/b)\n+    38  TestMod.#f_kw_simple#0\n+    39  (call %\u2083\u2088 %\u2081\u2086 %\u2083\u2080 slot\u2083/#self# slot\u2084/a slot\u2085/b)\n+    40  (return %\u2083\u2089)\n+48  latestworld\n+49  TestMod.f_kw_simple\n+50  (call core.Typeof %\u2084\u2089)\n+51  (call core.svec %\u2085\u2080)\n+52  (call core.svec)\n+53  SourceLocation::1:10\n+54  (call core.svec %\u2085\u2081 %\u2085\u2082 %\u2085\u2083)\n+55  --- method core.nothing %\u2085\u2084\n+    slots: [slot\u2081/#self#(called)]\n+    1   (call slot\u2081/#self# 1 1.0)\n+    2   (return %\u2081)\n+56  latestworld\n+57  TestMod.f_kw_simple\n+58  (call core.Typeof %\u2085\u2087)\n+59  TestMod.Int\n+60  (call core.svec %\u2085\u2088 %\u2085\u2089)\n+61  (call core.svec)\n+62  SourceLocation::1:10\n+63  (call core.svec %\u2086\u2080 %\u2086\u2081 %\u2086\u2082)\n+64  --- method core.nothing %\u2086\u2083\n+    slots: [slot\u2081/#self#(called) slot\u2082/a]\n+    1   (call slot\u2081/#self# slot\u2082/a 1.0)\n+    2   (return %\u2081)\n+65  latestworld\n+66  TestMod.f_kw_simple\n+67  (call core.Typeof %\u2086\u2086)\n+68  TestMod.Int\n+69  TestMod.Float64\n+70  (call core.svec %\u2086\u2087 %\u2086\u2088 %\u2086\u2089)\n+71  (call core.svec)\n+72  SourceLocation::1:10\n+73  (call core.svec %\u2087\u2080 %\u2087\u2081 %\u2087\u2082)\n+74  --- method core.nothing %\u2087\u2083\n+    slots: [slot\u2081/#self# slot\u2082/a slot\u2083/b]\n+    1   TestMod.#f_kw_simple#0\n+    2   (call %\u2081 'a' true slot\u2081/#self# slot\u2082/a slot\u2083/b)\n+    3   (return %\u2082)\n+75  latestworld\n+76  TestMod.f_kw_simple\n+77  (return %\u2087\u2086)\n+\n+########################################\n+# Keyword slurping - simple forwarding of all kws\n+function f_kw_slurp_simple(; all_kws...)\n+    all_kws\n+end\n+#---------------------\n+1   (method TestMod.f_kw_slurp_simple)\n+2   latestworld\n+3   (method TestMod.#f_kw_slurp_simple#0)\n+4   latestworld\n+5   TestMod.#f_kw_slurp_simple#0\n+6   (call core.Typeof %\u2085)\n+7   (call top.pairs core.NamedTuple)\n+8   TestMod.f_kw_slurp_simple\n+9   (call core.Typeof %\u2088)\n+10  (call core.svec %\u2086 %\u2087 %\u2089)\n+11  (call core.svec)\n+12  SourceLocation::1:10\n+13  (call core.svec %\u2081\u2080 %\u2081\u2081 %\u2081\u2082)\n+14  --- method core.nothing %\u2081\u2083\n+    slots: [slot\u2081/#self#(!read) slot\u2082/all_kws slot\u2083/#self#(!read)]\n+    1   (meta :nkw 1)\n+    2   slot\u2082/all_kws\n+    3   (return %\u2082)\n+15  latestworld\n+16  (call core.typeof core.kwcall)\n+17  TestMod.f_kw_slurp_simple\n+18  (call core.Typeof %\u2081\u2087)\n+19  (call core.svec %\u2081\u2086 core.NamedTuple %\u2081\u2088)\n+20  (call core.svec)\n+21  SourceLocation::1:10\n+22  (call core.svec %\u2081\u2089 %\u2082\u2080 %\u2082\u2081)\n+23  --- method core.nothing %\u2082\u2082\n+    slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/all_kws(!read)]\n+    1   (newvar slot\u2084/all_kws)\n+    2   (call top.pairs slot\u2082/kws)\n+    3   TestMod.#f_kw_slurp_simple#0\n+    4   (call %\u2083 %\u2082 slot\u2083/#self#)\n+    5   (return %\u2084)\n+24  latestworld\n+25  TestMod.f_kw_slurp_simple\n+26  (call core.Typeof %\u2082\u2085)\n+27  (call core.svec %\u2082\u2086)\n+28  (call core.svec)\n+29  SourceLocation::1:10\n+30  (call core.svec %\u2082\u2087 %\u2082\u2088 %\u2082\u2089)\n+31  --- method core.nothing %\u2083\u2080\n+    slots: [slot\u2081/#self#]\n+    1   TestMod.#f_kw_slurp_simple#0\n+    2   (call core.NamedTuple)\n+    3   (call top.pairs %\u2082)\n+    4   (call %\u2081 %\u2083 slot\u2081/#self#)\n+    5   (return %\u2084)\n+32  latestworld\n+33  TestMod.f_kw_slurp_simple\n+34  (return %\u2083\u2083)\n+\n+########################################\n+# Keyword slurping\n+function f_kw_slurp(; x=x_default, non_x_kws...)\n+    all_kws\n+end\n+#---------------------\n+1   (method TestMod.f_kw_slurp)\n+2   latestworld\n+3   (method TestMod.#f_kw_slurp#0)\n+4   latestworld\n+5   TestMod.#f_kw_slurp#0\n+6   (call core.Typeof %\u2085)\n+7   (call top.pairs core.NamedTuple)\n+8   TestMod.f_kw_slurp\n+9   (call core.Typeof %\u2088)\n+10  (call core.svec %\u2086 core.Any %\u2087 %\u2089)\n+11  (call core.svec)\n+12  SourceLocation::1:10\n+13  (call core.svec %\u2081\u2080 %\u2081\u2081 %\u2081\u2082)\n+14  --- method core.nothing %\u2081\u2083\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/non_x_kws(!read) slot\u2084/#self#(!read)]\n+    1   (meta :nkw 2)\n+    2   TestMod.all_kws\n+    3   (return %\u2082)\n+15  latestworld\n+16  (call core.typeof core.kwcall)\n+17  TestMod.f_kw_slurp\n+18  (call core.Typeof %\u2081\u2087)\n+19  (call core.svec %\u2081\u2086 core.NamedTuple %\u2081\u2088)\n+20  (call core.svec)\n+21  SourceLocation::1:10\n+22  (call core.svec %\u2081\u2089 %\u2082\u2080 %\u2082\u2081)\n+23  --- method core.nothing %\u2082\u2082\n+    slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/kwtmp slot\u2085/non_x_kws(!read) slot\u2086/x(!read)]\n+    1   (newvar slot\u2085/non_x_kws)\n+    2   (newvar slot\u2086/x)\n+    3   (call core.isdefined slot\u2082/kws :x)\n+    4   (gotoifnot %\u2083 label\u2088)\n+    5   (call core.getfield slot\u2082/kws :x)\n+    6   (= slot\u2084/kwtmp %\u2085)\n+    7   (goto label\u2081\u2080)\n+    8   TestMod.x_default\n+    9   (= slot\u2084/kwtmp %\u2088)\n+    10  slot\u2084/kwtmp\n+    11  (call core.tuple :x)\n+    12  (call core.apply_type core.NamedTuple %\u2081\u2081)\n+    13  (call top.structdiff slot\u2082/kws %\u2081\u2082)\n+    14  (call top.pairs %\u2081\u2083)\n+    15  TestMod.#f_kw_slurp#0\n+    16  (call %\u2081\u2085 %\u2081\u2080 %\u2081\u2084 slot\u2083/#self#)\n+    17  (return %\u2081\u2086)\n+24  latestworld\n+25  TestMod.f_kw_slurp\n+26  (call core.Typeof %\u2082\u2085)\n+27  (call core.svec %\u2082\u2086)\n+28  (call core.svec)\n+29  SourceLocation::1:10\n+30  (call core.svec %\u2082\u2087 %\u2082\u2088 %\u2082\u2089)\n+31  --- method core.nothing %\u2083\u2080\n+    slots: [slot\u2081/#self#]\n+    1   TestMod.#f_kw_slurp#0\n+    2   TestMod.x_default\n+    3   (call core.NamedTuple)\n+    4   (call top.pairs %\u2083)\n+    5   (call %\u2081 %\u2082 %\u2084 slot\u2081/#self#)\n+    6   (return %\u2085)\n+32  latestworld\n+33  TestMod.f_kw_slurp\n+34  (return %\u2083\u2083)\n+\n+########################################\n+# Static parameters used in keywords, with and without the static parameter\n+# being present in positional argument types.\n+#\n+# Here the wrong type for `b` will get a `TypeError` but `A` will need to rely\n+# on a MethodError.\n+function f_kw_sparams(x::X; a::A=a_def, b::X=b_def) where {X,A}\n+    (X,A)\n+end\n+#---------------------\n+1   (method TestMod.f_kw_sparams)\n+2   latestworld\n+3   (method TestMod.#f_kw_sparams#0)\n+4   latestworld\n+5   (= slot\u2082/X (call core.TypeVar :X))\n+6   (= slot\u2081/A (call core.TypeVar :A))\n+7   TestMod.#f_kw_sparams#0\n+8   (call core.Typeof %\u2087)\n+9   slot\u2081/A\n+10  slot\u2082/X\n+11  TestMod.f_kw_sparams\n+12  (call core.Typeof %\u2081\u2081)\n+13  slot\u2082/X\n+14  (call core.svec %\u2088 %\u2089 %\u2081\u2080 %\u2081\u2082 %\u2081\u2083)\n+15  slot\u2082/X\n+16  slot\u2081/A\n+17  (call core.svec %\u2081\u2085 %\u2081\u2086)\n+18  SourceLocation::1:10\n+19  (call core.svec %\u2081\u2084 %\u2081\u2087 %\u2081\u2088)\n+20  --- method core.nothing %\u2081\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/a(!read) slot\u2083/b(!read) slot\u2084/#self#(!read) slot\u2085/x(!read)]\n+    1   (meta :nkw 2)\n+    2   static_parameter\u2081\n+    3   static_parameter\u2082\n+    4   (call core.tuple %\u2082 %\u2083)\n+    5   (return %\u2084)\n+21  latestworld\n+22  (= slot\u2084/X (call core.TypeVar :X))\n+23  (= slot\u2083/A (call core.TypeVar :A))\n+24  (call core.typeof core.kwcall)\n+25  TestMod.f_kw_sparams\n+26  (call core.Typeof %\u2082\u2085)\n+27  slot\u2084/X\n+28  (call core.svec %\u2082\u2084 core.NamedTuple %\u2082\u2086 %\u2082\u2087)\n+29  slot\u2084/X\n+30  (call core.svec %\u2082\u2089)\n+31  SourceLocation::1:10\n+32  (call core.svec %\u2082\u2088 %\u2083\u2080 %\u2083\u2081)\n+33  --- method core.nothing %\u2083\u2082\n+    slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/x slot\u2085/kwtmp slot\u2086/a(!read) slot\u2087/b(!read)]\n+    1   (newvar slot\u2086/a)\n+    2   (newvar slot\u2087/b)\n+    3   (call core.isdefined slot\u2082/kws :a)\n+    4   (gotoifnot %\u2083 label\u2088)\n+    5   (call core.getfield slot\u2082/kws :a)\n+    6   (= slot\u2085/kwtmp %\u2085)\n+    7   (goto label\u2081\u2080)\n+    8   TestMod.a_def\n+    9   (= slot\u2085/kwtmp %\u2088)\n+    10  slot\u2085/kwtmp\n+    11  (call core.isdefined slot\u2082/kws :b)\n+    12  (gotoifnot %\u2081\u2081 label\u2082\u2083)\n+    13  (call core.getfield slot\u2082/kws :b)\n+    14  static_parameter\u2081\n+    15  (call core.isa %\u2081\u2083 %\u2081\u2084)\n+    16  (gotoifnot %\u2081\u2085 label\u2081\u2088)\n+    17  (goto label\u2082\u2081)\n+    18  static_parameter\u2081\n+    19  (new core.TypeError :keyword argument :b %\u2081\u2088 %\u2081\u2083)\n+    20  (call core.throw %\u2081\u2089)\n+    21  (= slot\u2085/kwtmp %\u2081\u2083)\n+    22  (goto label\u2082\u2085)\n+    23  TestMod.b_def\n+    24  (= slot\u2085/kwtmp %\u2082\u2083)\n+    25  slot\u2085/kwtmp\n+    26  (call top.keys slot\u2082/kws)\n+    27  (call core.tuple :a :b)\n+    28  (call top.diff_names %\u2082\u2086 %\u2082\u2087)\n+    29  (call top.isempty %\u2082\u2088)\n+    30  (gotoifnot %\u2082\u2089 label\u2083\u2082)\n+    31  (goto label\u2083\u2083)\n+    32  (call top.kwerr slot\u2082/kws slot\u2083/#self# slot\u2084/x)\n+    33  TestMod.#f_kw_sparams#0\n+    34  (call %\u2083\u2083 %\u2081\u2080 %\u2082\u2085 slot\u2083/#self# slot\u2084/x)\n+    35  (return %\u2083\u2084)\n+34  latestworld\n+35  (= slot\u2086/X (call core.TypeVar :X))\n+36  (= slot\u2085/A (call core.TypeVar :A))\n+37  TestMod.f_kw_sparams\n+38  (call core.Typeof %\u2083\u2087)\n+39  slot\u2086/X\n+40  (call core.svec %\u2083\u2088 %\u2083\u2089)\n+41  slot\u2086/X\n+42  (call core.svec %\u2084\u2081)\n+43  SourceLocation::1:10\n+44  (call core.svec %\u2084\u2080 %\u2084\u2082 %\u2084\u2083)\n+45  --- method core.nothing %\u2084\u2084\n+    slots: [slot\u2081/#self# slot\u2082/x]\n+    1   TestMod.#f_kw_sparams#0\n+    2   TestMod.a_def\n+    3   TestMod.b_def\n+    4   (call %\u2081 %\u2082 %\u2083 slot\u2081/#self# slot\u2082/x)\n+    5   (return %\u2084)\n+46  latestworld\n+47  TestMod.f_kw_sparams\n+48  (return %\u2084\u2087)\n+\n+########################################\n+# Error: Static parameter which is unused in keyword body arg types\n+function f_kw_sparams(x::X; a::A) where {X,Y,A}\n+    (X,A)\n+end\n+#---------------------\n+LoweringError:\n+function f_kw_sparams(x::X; a::A) where {X,Y,A}\n+#                                          \u2559 \u2500\u2500 Method definition declares type variable but does not use it in the type of any function parameter\n+    (X,A)\n+end\n+\n+########################################\n+# Error: argument unpacking in keywords\n+function f_kw_destruct(; (x,y)=10)\n+end\n+#---------------------\n+LoweringError:\n+function f_kw_destruct(; (x,y)=10)\n+#                        \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 Invalid keyword name\n+end\n+\n+########################################\n+# Error: keyword slurping combined with a default\n+function f_kw_slurp_default(; kws...=def)\n+end\n+#---------------------\n+LoweringError:\n+function f_kw_slurp_default(; kws...=def)\n+#                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 keyword argument with `...` cannot have a default value\n+end\n+\n+########################################\n+# Error: keyword slurping combined with type\n+function f_kw_slurp_type(; kws::T...)\n+end\n+#---------------------\n+LoweringError:\n+function f_kw_slurp_type(; kws::T...)\n+#                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 keyword argument with `...` may not be given a type\n+end\n+\n+########################################\n+# Error: keyword slurping on non-final argument\n+function f_kw_slurp_not_last(; kws..., x=1)\n+end\n+#---------------------\n+LoweringError:\n+function f_kw_slurp_not_last(; kws..., x=1)\n+#                              \u2514\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 `...` may only be used for the last keyword argument\n+end\n+\n+########################################\n+# Fully generated function\n+@generated function f_only_generated(x, y)\n+    generator_code(x,y)\n+end\n+#---------------------\n+1   (method TestMod.f_only_generated)\n+2   latestworld\n+3   (method TestMod.#f_only_generated@generator#0)\n+4   latestworld\n+5   TestMod.#f_only_generated@generator#0\n+6   (call core.Typeof %\u2085)\n+7   (call core.svec %\u2086 JuliaLowering.MacroContext core.Any core.Any core.Any)\n+8   (call core.svec)\n+9   SourceLocation::1:21\n+10  (call core.svec %\u2087 %\u2088 %\u2089)\n+11  --- method core.nothing %\u2081\u2080\n+    slots: [slot\u2081/#self#(!read) slot\u2082/__context__(!read) slot\u2083/#self#(!read) slot\u2084/x(nospecialize) slot\u2085/y(nospecialize)]\n+    1   TestMod.generator_code\n+    2   (call %\u2081 slot\u2084/x slot\u2085/y)\n+    3   (return %\u2082)\n+12  latestworld\n+13  TestMod.f_only_generated\n+14  (call core.Typeof %\u2081\u2083)\n+15  (call core.svec %\u2081\u2084 core.Any core.Any)\n+16  (call core.svec)\n+17  SourceLocation::1:21\n+18  (call core.svec %\u2081\u2085 %\u2081\u2086 %\u2081\u2087)\n+19  --- method core.nothing %\u2081\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/y(!read)]\n+    1   (meta :generated (new JuliaLowering.GeneratedFunctionStub TestMod.#f_only_generated@generator#0 SourceRef(SourceFile(\"@generated function f_only_generated(x, y)\\n    generator_code(x,y)\\nend\", 0, nothing, 1, [1, 44, 68]), 1, (macrocall (macro_name 1-1::@-t 2-10::Identifier) 11-11::Whitespace-t (function 12-19::function-t 20-20::Whitespace-t (call 21-36::Identifier 37-37::(-t 38-38::Identifier 39-39::,-t 40-40::Whitespace-t 41-41::Identifier 42-42::)-t) (block 43-47::NewlineWs-t (call 48-61::Identifier 62-62::(-t 63-63::Identifier 64-64::,-t 65-65::Identifier 66-66::)-t) 67-67::NewlineWs-t) 68-70::end-t))) (call core.svec :#self# :x :y) (call core.svec)))\n+    2   (meta :generated_only)\n+    3   (return core.nothing)\n+20  latestworld\n+21  TestMod.f_only_generated\n+22  (return %\u2082\u2081)\n+\n+########################################\n+# Partially generated function with `if @generated`\n+function f_partially_generated(x, y)\n+    nongen_stuff = bothgen(x, y)\n+    if @generated\n+        quote\n+            maybe_gen_stuff = some_gen_stuff(x, y)\n+        end\n+    else\n+        maybe_gen_stuff = some_nongen_stuff(x, y)\n+    end\n+    (nongen_stuff, maybe_gen_stuff)\n+end\n+#---------------------\n+1   (method TestMod.f_partially_generated)\n+2   latestworld\n+3   (method TestMod.#f_partially_generated@generator#0)\n+4   latestworld\n+5   TestMod.#f_partially_generated@generator#0\n+6   (call core.Typeof %\u2085)\n+7   (call core.svec %\u2086 JuliaLowering.MacroContext core.Any core.Any core.Any)\n+8   (call core.svec)\n+9   SourceLocation::1:10\n+10  (call core.svec %\u2087 %\u2088 %\u2089)\n+11  --- method core.nothing %\u2081\u2080\n+    slots: [slot\u2081/#self#(!read) slot\u2082/__context__(!read) slot\u2083/#self#(!read) slot\u2084/x(nospecialize,!read) slot\u2085/y(nospecialize,!read)]\n+    1   (call JuliaLowering.interpolate_ast SyntaxTree (inert (block (= maybe_gen_stuff (call some_gen_stuff x y)))))\n+    2   (call core.tuple %\u2081)\n+    3   (call JuliaLowering.interpolate_ast SyntaxTree (inert (block (block (= nongen_stuff (call bothgen x y)) ($ (block (call JuliaLowering.interpolate_ast SyntaxTree (inert (block (= maybe_gen_stuff (call some_gen_stuff x y))))))) (tuple-p nongen_stuff maybe_gen_stuff)))) %\u2082)\n+    4   (return %\u2083)\n+12  latestworld\n+13  TestMod.f_partially_generated\n+14  (call core.Typeof %\u2081\u2083)\n+15  (call core.svec %\u2081\u2084 core.Any core.Any)\n+16  (call core.svec)\n+17  SourceLocation::1:10\n+18  (call core.svec %\u2081\u2085 %\u2081\u2086 %\u2081\u2087)\n+19  --- method core.nothing %\u2081\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/maybe_gen_stuff slot\u2085/nongen_stuff]\n+    1   (meta :generated (new JuliaLowering.GeneratedFunctionStub TestMod.#f_partially_generated@generator#0 SourceRef(SourceFile(\"function f_partially_generated(x, y)\\n    nongen_stuff = bothgen(x, y)\\n    if @generated\\n        quote\\n            maybe_gen_stuff = some_gen_stuff(x, y)\\n        end\\n    else\\n        maybe_gen_stuff = some_nongen_stuff(x, y)\\n    end\\n    (nongen_stuff, maybe_gen_stuff)\\nend\", 0, nothing, 1, [1, 38, 71, 89, 103, 154, 166, 175, 225, 233, 269]), 1, (function 1-8::function-t 9-9::Whitespace-t (call 10-30::Identifier 31-31::(-t 32-32::Identifier 33-33::,-t 34-34::Whitespace-t 35-35::Identifier 36-36::)-t) (block 37-41::NewlineWs-t (= 42-53::Identifier 54-54::Whitespace-t 55-55::=-t 56-56::Whitespace-t (call 57-63::Identifier 64-64::(-t 65-65::Identifier 66-66::,-t 67-67::Whitespace-t 68-68::Identifier 69-69::)-t)) 70-74::NewlineWs-t (if 75-76::if-t 77-77::Whitespace-t (macrocall (macro_name 78-78::@-t 79-87::Identifier)) (block 88-96::NewlineWs-t (quote (block 97-101::quote-t 102-114::NewlineWs-t (= 115-129::Identifier 130-130::Whitespace-t 131-131::=-t 132-132::Whitespace-t (call 133-146::Identifier 147-147::(-t 148-148::Identifier 149-149::,-t 150-150::Whitespace-t 151-151::Identifier 152-152::)-t)) 153-161::NewlineWs-t 162-164::end-t)) 165-169::NewlineWs-t) 170-173::else-t (block 174-182::NewlineWs-t (= 183-197::Identifier 198-198::Whitespace-t 199-199::=-t 200-200::Whitespace-t (call 201-217::Identifier 218-218::(-t 219-219::Identifier 220-220::,-t 221-221::Whitespace-t 222-222::Identifier 223-223::)-t)) 224-228::NewlineWs-t) 229-231::end-t) 232-236::NewlineWs-t (tuple-p 237-237::(-t 238-249::Identifier 250-250::,-t 251-251::Whitespace-t 252-266::Identifier 267-267::)-t) 268-268::NewlineWs-t) 269-271::end-t)) (call core.svec :#self# :x :y) (call core.svec)))\n+    2   TestMod.bothgen\n+    3   (= slot\u2085/nongen_stuff (call %\u2082 slot\u2082/x slot\u2083/y))\n+    4   TestMod.some_nongen_stuff\n+    5   (= slot\u2084/maybe_gen_stuff (call %\u2084 slot\u2082/x slot\u2083/y))\n+    6   slot\u2085/nongen_stuff\n+    7   slot\u2084/maybe_gen_stuff\n+    8   (call core.tuple %\u2086 %\u2087)\n+    9   (return %\u2088)\n+20  latestworld\n+21  TestMod.f_partially_generated\n+22  (return %\u2082\u2081)"
    },
    {
      "sha": "7dce6236afe2080c4dc5aae7dcdc0b8fd8be7739",
      "filename": "JuliaLowering/test/generators.jl",
      "status": "added",
      "additions": 76,
      "deletions": 0,
      "changes": 76,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fgenerators.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fgenerators.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fgenerators.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,76 @@\n+@testset \"Generators\" begin\n+\n+test_mod = Module()\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+collect(x^2 for x in 1:3)\n+\"\"\") == [1,4,9]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+collect(x for x in 1:5 if isodd(x))\n+\"\"\") == [1,3,5]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+collect((y,x) for (x,y) in zip(1:3, 2:4) if y != 3)\n+\"\"\") == [(2,1), (4,3)]\n+\n+# product iterator\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+collect((x,y) for x in 1:3, y in 1:2)\n+\"\"\") == [(1,1)  (1,2)\n+         (2,1)  (2,2)\n+         (3,1)  (3,2)]\n+\n+# flattened iterator\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+collect((x,y,z) for x in 1:3, y in 4:5 for z in 6:7)\n+\"\"\") == [\n+    (1,4,6)\n+    (1,4,7)\n+    (2,4,6)\n+    (2,4,7)\n+    (3,4,6)\n+    (3,4,7)\n+    (1,5,6)\n+    (1,5,7)\n+    (2,5,6)\n+    (2,5,7)\n+    (3,5,6)\n+    (3,5,7)\n+]\n+\n+# Duplicate iteration variables - body sees only innermost\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+collect(x for x in 1:3 for x in 1:2)\n+\"\"\") == [1, 2, 1, 2, 1, 2]\n+\n+# Outer iteration variables are protected from mutation\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+collect((z=y; y=100; z) for y in 1:3 for x in 1:2)\n+\"\"\") == [1, 1, 2, 2, 3, 3]\n+\n+# Simple typed comprehension lowered to for loops\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+Tuple{Int,Int}[(x,y) for x in 1:2, y in 1:3]\n+\"\"\") == [(1,1) (1,2) (1,3)\n+         (2,1) (2,2) (2,3)]\n+\n+# Triply nested comprehension\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+[(x,y,z) for x in 1:3 for y in 4:5 for z in 6:7]\n+\"\"\") == [\n+    (1, 4, 6)\n+    (1, 4, 7)\n+    (1, 5, 6)\n+    (1, 5, 7)\n+    (2, 4, 6)\n+    (2, 4, 7)\n+    (2, 5, 6)\n+    (2, 5, 7)\n+    (3, 4, 6)\n+    (3, 4, 7)\n+    (3, 5, 6)\n+    (3, 5, 7)\n+]\n+\n+end"
    },
    {
      "sha": "28f0241c92e9316b51811b52a8d7b2691f6e9c73",
      "filename": "JuliaLowering/test/generators_ir.jl",
      "status": "added",
      "additions": 299,
      "deletions": 0,
      "changes": 299,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fgenerators_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fgenerators_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fgenerators_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,299 @@\n+########################################\n+# Simple 1D generator\n+(x+1 for x in xs)\n+#---------------------\n+1   (call core.svec)\n+2   (call core.svec)\n+3   (call JuliaLowering.eval_closure_type TestMod :#->##0 %\u2081 %\u2082)\n+4   latestworld\n+5   TestMod.#->##0\n+6   (call core.svec %\u2085 core.Any)\n+7   (call core.svec)\n+8   SourceLocation::1:2\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x]\n+    1   TestMod.+\n+    2   (call %\u2081 slot\u2082/x 1)\n+    3   (return %\u2082)\n+11  latestworld\n+12  TestMod.#->##0\n+13  (new %\u2081\u2082)\n+14  TestMod.xs\n+15  (call top.Generator %\u2081\u2083 %\u2081\u2084)\n+16  (return %\u2081\u2085)\n+\n+########################################\n+# Product iteration\n+(x+y for x in xs, y in ys)\n+#---------------------\n+1   (call core.svec)\n+2   (call core.svec)\n+3   (call JuliaLowering.eval_closure_type TestMod :#->##1 %\u2081 %\u2082)\n+4   latestworld\n+5   TestMod.#->##1\n+6   (call core.svec %\u2085 core.Any)\n+7   (call core.svec)\n+8   SourceLocation::1:2\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/iterstate slot\u2084/x slot\u2085/y]\n+    1   (call top.indexed_iterate slot\u2082/destructured_arg 1)\n+    2   (= slot\u2084/x (call core.getfield %\u2081 1))\n+    3   (= slot\u2083/iterstate (call core.getfield %\u2081 2))\n+    4   slot\u2083/iterstate\n+    5   (call top.indexed_iterate slot\u2082/destructured_arg 2 %\u2084)\n+    6   (= slot\u2085/y (call core.getfield %\u2085 1))\n+    7   TestMod.+\n+    8   slot\u2084/x\n+    9   slot\u2085/y\n+    10  (call %\u2087 %\u2088 %\u2089)\n+    11  (return %\u2081\u2080)\n+11  latestworld\n+12  TestMod.#->##1\n+13  (new %\u2081\u2082)\n+14  TestMod.xs\n+15  TestMod.ys\n+16  (call top.product %\u2081\u2084 %\u2081\u2085)\n+17  (call top.Generator %\u2081\u2083 %\u2081\u2086)\n+18  (return %\u2081\u2087)\n+\n+########################################\n+# Use `identity` as the Generator function when possible eg in filters\n+((x,y) for (x,y) in iter if f(x))\n+#---------------------\n+1   (call core.svec)\n+2   (call core.svec)\n+3   (call JuliaLowering.eval_closure_type TestMod :#->##2 %\u2081 %\u2082)\n+4   latestworld\n+5   TestMod.#->##2\n+6   (call core.svec %\u2085 core.Any)\n+7   (call core.svec)\n+8   SourceLocation::1:29\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/iterstate slot\u2084/x slot\u2085/y(!read)]\n+    1   (call top.indexed_iterate slot\u2082/destructured_arg 1)\n+    2   (= slot\u2084/x (call core.getfield %\u2081 1))\n+    3   (= slot\u2083/iterstate (call core.getfield %\u2081 2))\n+    4   slot\u2083/iterstate\n+    5   (call top.indexed_iterate slot\u2082/destructured_arg 2 %\u2084)\n+    6   (= slot\u2085/y (call core.getfield %\u2085 1))\n+    7   TestMod.f\n+    8   slot\u2084/x\n+    9   (call %\u2087 %\u2088)\n+    10  (return %\u2089)\n+11  latestworld\n+12  TestMod.#->##2\n+13  (new %\u2081\u2082)\n+14  TestMod.iter\n+15  (call top.Filter %\u2081\u2083 %\u2081\u2084)\n+16  (call top.Generator top.identity %\u2081\u2085)\n+17  (return %\u2081\u2086)\n+\n+########################################\n+# Use of placeholders in iteration vars\n+(1 for _ in xs)\n+#---------------------\n+1   (call core.svec)\n+2   (call core.svec)\n+3   (call JuliaLowering.eval_closure_type TestMod :#->##3 %\u2081 %\u2082)\n+4   latestworld\n+5   TestMod.#->##3\n+6   (call core.svec %\u2085 core.Any)\n+7   (call core.svec)\n+8   SourceLocation::1:2\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/_(!read)]\n+    1   (return 1)\n+11  latestworld\n+12  TestMod.#->##3\n+13  (new %\u2081\u2082)\n+14  TestMod.xs\n+15  (call top.Generator %\u2081\u2083 %\u2081\u2084)\n+16  (return %\u2081\u2085)\n+\n+########################################\n+# Error: Use of placeholders in body\n+(_ for _ in xs)\n+#---------------------\n+LoweringError:\n+(_ for _ in xs)\n+#\u2559 \u2500\u2500 all-underscore identifiers are write-only and their values cannot be used in expressions\n+\n+########################################\n+# 1D generator with destructuring\n+(body for (x,_,y) in iter)\n+#---------------------\n+1   (call core.svec)\n+2   (call core.svec)\n+3   (call JuliaLowering.eval_closure_type TestMod :#->##5 %\u2081 %\u2082)\n+4   latestworld\n+5   TestMod.#->##5\n+6   (call core.svec %\u2085 core.Any)\n+7   (call core.svec)\n+8   SourceLocation::1:2\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/iterstate slot\u2084/x(!read) slot\u2085/y(!read)]\n+    1   (call top.indexed_iterate slot\u2082/destructured_arg 1)\n+    2   (= slot\u2084/x (call core.getfield %\u2081 1))\n+    3   (= slot\u2083/iterstate (call core.getfield %\u2081 2))\n+    4   slot\u2083/iterstate\n+    5   (call top.indexed_iterate slot\u2082/destructured_arg 2 %\u2084)\n+    6   (call core.getfield %\u2085 1)\n+    7   (= slot\u2083/iterstate (call core.getfield %\u2085 2))\n+    8   slot\u2083/iterstate\n+    9   (call top.indexed_iterate slot\u2082/destructured_arg 3 %\u2088)\n+    10  (= slot\u2085/y (call core.getfield %\u2089 1))\n+    11  TestMod.body\n+    12  (return %\u2081\u2081)\n+11  latestworld\n+12  TestMod.#->##5\n+13  (new %\u2081\u2082)\n+14  TestMod.iter\n+15  (call top.Generator %\u2081\u2083 %\u2081\u2084)\n+16  (return %\u2081\u2085)\n+\n+########################################\n+# return permitted in quoted syntax in generator\n+(:(return x) for _ in iter)\n+#---------------------\n+1   (call core.svec)\n+2   (call core.svec)\n+3   (call JuliaLowering.eval_closure_type TestMod :#->##6 %\u2081 %\u2082)\n+4   latestworld\n+5   TestMod.#->##6\n+6   (call core.svec %\u2085 core.Any)\n+7   (call core.svec)\n+8   SourceLocation::1:4\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n+    slots: [slot\u2081/#self#(!read) slot\u2082/_(!read)]\n+    1   (call JuliaLowering.interpolate_ast SyntaxTree (inert (return x)))\n+    2   (return %\u2081)\n+11  latestworld\n+12  TestMod.#->##6\n+13  (new %\u2081\u2082)\n+14  TestMod.iter\n+15  (call top.Generator %\u2081\u2083 %\u2081\u2084)\n+16  (return %\u2081\u2085)\n+\n+########################################\n+# Error: `return` not permitted in generator body\n+((return x) + y for x in iter)\n+#---------------------\n+LoweringError:\n+((return x) + y for x in iter)\n+# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 `return` not allowed inside comprehension or generator\n+\n+########################################\n+# Nested case with duplicate iteration variables\n+(x for x in 1:3 for x in 1:2)\n+#---------------------\n+1   (call core.svec)\n+2   (call core.svec)\n+3   (call JuliaLowering.eval_closure_type TestMod :#->##7 %\u2081 %\u2082)\n+4   latestworld\n+5   (call core.svec)\n+6   (call core.svec)\n+7   (call JuliaLowering.eval_closure_type TestMod :#->#->##0 %\u2085 %\u2086)\n+8   latestworld\n+9   TestMod.#->#->##0\n+10  (call core.svec %\u2089 core.Any)\n+11  (call core.svec)\n+12  SourceLocation::1:2\n+13  (call core.svec %\u2081\u2080 %\u2081\u2081 %\u2081\u2082)\n+14  --- method core.nothing %\u2081\u2083\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/x]\n+    1   slot\u2082/x\n+    2   (= slot\u2083/x %\u2081)\n+    3   slot\u2083/x\n+    4   (return %\u2083)\n+15  latestworld\n+16  TestMod.#->##7\n+17  (call core.svec %\u2081\u2086 core.Any)\n+18  (call core.svec)\n+19  SourceLocation::1:2\n+20  (call core.svec %\u2081\u2087 %\u2081\u2088 %\u2081\u2089)\n+21  --- method core.nothing %\u2082\u2080\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read)]\n+    1   TestMod.#->#->##0\n+    2   (new %\u2081)\n+    3   TestMod.:\n+    4   (call %\u2083 1 2)\n+    5   (call top.Generator %\u2082 %\u2084)\n+    6   (return %\u2085)\n+22  latestworld\n+23  TestMod.#->##7\n+24  (new %\u2082\u2083)\n+25  TestMod.:\n+26  (call %\u2082\u2085 1 3)\n+27  (call top.Generator %\u2082\u2084 %\u2082\u2086)\n+28  (call top.Flatten %\u2082\u2087)\n+29  (return %\u2082\u2088)\n+\n+########################################\n+# Comprehension lowers to generator with collect\n+[x for x in xs]\n+#---------------------\n+1   TestMod.xs\n+2   (call top.Generator top.identity %\u2081)\n+3   (call top.collect %\u2082)\n+4   (return %\u2083)\n+\n+########################################\n+# Simple typed comprehension lowers to for loop\n+T[(x,y) for x in xs, y in ys]\n+#---------------------\n+1   TestMod.xs\n+2   TestMod.ys\n+3   (call top.product %\u2081 %\u2082)\n+4   (call top.IteratorSize %\u2083)\n+5   (call core.isa %\u2084 top.SizeUnknown)\n+6   TestMod.T\n+7   (call top._array_for %\u2086 %\u2083 %\u2084)\n+8   (call top.LinearIndices %\u2087)\n+9   (= slot\u2081/idx (call top.first %\u2088))\n+10  (= slot\u2083/next (call top.iterate %\u2082))\n+11  slot\u2083/next\n+12  (call core.=== %\u2081\u2081 core.nothing)\n+13  (call top.not_int %\u2081\u2082)\n+14  (gotoifnot %\u2081\u2083 label\u2085\u2080)\n+15  slot\u2083/next\n+16  (= slot\u2084/y (call core.getfield %\u2081\u2085 1))\n+17  (call core.getfield %\u2081\u2085 2)\n+18  (= slot\u2082/next (call top.iterate %\u2081))\n+19  slot\u2082/next\n+20  (call core.=== %\u2081\u2089 core.nothing)\n+21  (call top.not_int %\u2082\u2080)\n+22  (gotoifnot %\u2082\u2081 label\u2084\u2084)\n+23  slot\u2084/y\n+24  (= slot\u2086/y %\u2082\u2083)\n+25  slot\u2082/next\n+26  (= slot\u2085/x (call core.getfield %\u2082\u2085 1))\n+27  (call core.getfield %\u2082\u2085 2)\n+28  slot\u2085/x\n+29  slot\u2086/y\n+30  (call core.tuple %\u2082\u2088 %\u2082\u2089)\n+31  (gotoifnot %\u2085 label\u2083\u2084)\n+32  (call top.push! %\u2087 %\u2083\u2080)\n+33  (goto label\u2083\u2086)\n+34  slot\u2081/idx\n+35  (call top.setindex! %\u2087 %\u2083\u2080 %\u2083\u2084)\n+36  slot\u2081/idx\n+37  (= slot\u2081/idx (call top.add_int %\u2083\u2086 1))\n+38  (= slot\u2082/next (call top.iterate %\u2081 %\u2082\u2087))\n+39  slot\u2082/next\n+40  (call core.=== %\u2083\u2089 core.nothing)\n+41  (call top.not_int %\u2084\u2080)\n+42  (gotoifnot %\u2084\u2081 label\u2084\u2084)\n+43  (goto label\u2082\u2083)\n+44  (= slot\u2083/next (call top.iterate %\u2082 %\u2081\u2087))\n+45  slot\u2083/next\n+46  (call core.=== %\u2084\u2085 core.nothing)\n+47  (call top.not_int %\u2084\u2086)\n+48  (gotoifnot %\u2084\u2087 label\u2085\u2080)\n+49  (goto label\u2081\u2085)\n+50  (return %\u2087)"
    },
    {
      "sha": "823e9b60279064ede5839aaca91626ba68a9c43b",
      "filename": "JuliaLowering/test/hooks.jl",
      "status": "added",
      "additions": 86,
      "deletions": 0,
      "changes": 86,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fhooks.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fhooks.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fhooks.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,86 @@\n+const JL = JuliaLowering\n+\n+@testset \"hooks\" begin\n+    test_mod = Module()\n+\n+    @testset \"`core_lowering_hook`\" begin\n+        # Non-AST types are often sent through lowering\n+        stuff = Any[LineNumberNode(1), 123, 123.123, true, \"foo\", test_mod]\n+        for s in stuff\n+            @test JL.core_lowering_hook(s, test_mod) == Core.svec(s)\n+        end\n+\n+        for ast_type in (Expr, JL.SyntaxTree)\n+            ex = parsestmt(ast_type, \"[1,2,3] .+= 1\")\n+            out = JL.core_lowering_hook(ex, test_mod)\n+            @test out isa Core.SimpleVector && out[1] isa Expr\n+            val = Core.eval(test_mod, out[1])\n+            @test val == [2,3,4]\n+        end\n+\n+        # file argument mismatch with embedded linenumbernodes shouldn't crash\n+        ex = Expr(:block, LineNumberNode(111), :(x = 1), LineNumberNode(222), :(x + 1))\n+        lwr = JuliaLowering.core_lowering_hook(ex, test_mod, \"foo.jl\", 333)[1]\n+        @test Core.eval(test_mod, lwr) === 2\n+    end\n+\n+    if isdefined(Core, :_lower)\n+        function jeval(str)\n+            prog = parseall(Expr, str)\n+            local out\n+            try\n+                JL.activate!()\n+                out = Core.eval(test_mod, prog)\n+            finally\n+                JL.activate!(false)\n+            end\n+        end\n+        @testset \"integration: `JuliaLowering.activate!`\" begin\n+            out = jeval(\"global asdf = 1\")\n+            @test out === 1\n+            @test isdefined(test_mod, :asdf)\n+\n+            out = jeval(\"module M; x = 1; end\")\n+            @test out isa Module\n+            @test isdefined(test_mod, :M)\n+            @test isdefined(test_mod.M, :x)\n+\n+            # Tricky cases with symbols\n+            out = jeval(\"\"\"module M2\n+                Base.@constprop :aggressive function f(x); x; end\n+                const what = ccall(:jl_value_ptr, Ptr{Cvoid}, (Any,), Core.nothing)\n+            end\"\"\")\n+            @test out isa Module\n+            @test isdefined(test_mod, :M2)\n+            @test isdefined(test_mod.M2, :f)\n+            @test isdefined(test_mod.M2, :what)\n+\n+            out = jeval(\"\"\" \"docstring\" module M3 end \"\"\")\n+            @test out isa Module\n+            @test isdefined(test_mod, :M3)\n+\n+            # Macros may produce toplevel expressions.  Note that julia handles\n+            # this case badly (macro expansion replaces M5_inner with a\n+            # globalref) and we handle esc(:M5_inner) badly\n+            out = jeval(\"\"\"module M5\n+            macro newmod()\n+                return quote\n+                    let a = 1\n+                        $(Expr(:toplevel,\n+                               Expr(:module, true, :M5_inner,\n+                                    Expr(:block, :(global asdf = 1)))))\n+                    end\n+                end\n+            end\n+            @newmod()\n+            end\"\"\")\n+            @test out isa Module\n+            @test isdefined(test_mod, :M5)\n+            @test isdefined(test_mod.M5, :M5_inner)\n+            @test isdefined(test_mod.M5.M5_inner, :asdf)\n+\n+            # TODO: broken, commented to prevent error logging\n+            # @test jeval(\"Base.@propagate_inbounds @inline meta_double_quote_issue(x) = x\") isa Function\n+        end\n+    end\n+end"
    },
    {
      "sha": "74cdd9260149e04e97a83eb2dc4205ca7713d4de",
      "filename": "JuliaLowering/test/import.jl",
      "status": "added",
      "additions": 80,
      "deletions": 0,
      "changes": 80,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fimport.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fimport.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fimport.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,80 @@\n+@testset \"using / import\" begin\n+\n+test_mod = Module()\n+\n+# Test attributes are correctly set for export/public\n+JuliaLowering.include_string(test_mod, \"\"\"\n+x = 1\n+y = 2\n+export x\n+public y\n+\"\"\")\n+@test Base.isexported(test_mod, :x)\n+@test Base.ispublic(test_mod, :x)\n+@test Base.ispublic(test_mod, :y)\n+@test !Base.isexported(test_mod, :y)\n+\n+# Test various forms of `using`\n+C = JuliaLowering.include_string(test_mod, \"\"\"\n+module C\n+    module D\n+        export x\n+        public y, f\n+        x = [101]\n+        y = [202]\n+\n+        function f()\n+            \"hi\"\n+        end\n+    end\n+    module E\n+        using ..D: f\n+        using ..D\n+        using .D: y as D_y\n+        using .D: x as D_x_2, y as D_y_2\n+        import .D.y as D_y_3\n+    end\n+end\n+\"\"\")\n+@test C.D.f === C.E.f\n+@test C.D.x === C.E.x\n+@test C.D.y === C.E.D_y\n+@test C.D.x === C.E.D_x_2\n+@test C.D.y === C.E.D_y_2\n+@test C.D.y === C.E.D_y_3\n+\n+# Test that using F brings in the exported symbol G immediately and that it can\n+# be used next in the import list.\n+F = JuliaLowering.include_string(test_mod, \"\"\"\n+module F\n+    export G\n+    module G\n+        export G_global\n+        G_global = \"exported from G\"\n+    end\n+end\n+\"\"\")\n+JuliaLowering.include_string(test_mod, \"\"\"\n+using .F, .G\n+\"\"\")\n+@test test_mod.F === F\n+@test test_mod.G === F.G\n+@test test_mod.G_global === \"exported from G\"\n+\n+# Similarly, that import makes symbols available immediately\n+H = JuliaLowering.include_string(test_mod, \"\"\"\n+module H\n+    module I\n+        module J\n+        end\n+    end\n+end\n+\"\"\")\n+JuliaLowering.include_string(test_mod, \"\"\"\n+import .H.I, .I.J\n+\"\"\")\n+@test test_mod.I === H.I\n+@test test_mod.J === H.I.J\n+@test test_mod.G_global === \"exported from G\"\n+\n+end"
    },
    {
      "sha": "8f34f5f0c49399e49c8173c1031469b6d957ab95",
      "filename": "JuliaLowering/test/import_ir.jl",
      "status": "added",
      "additions": 69,
      "deletions": 0,
      "changes": 69,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fimport_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fimport_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fimport_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,69 @@\n+########################################\n+# Basic import\n+import A: b\n+#---------------------\n+1   (call JuliaLowering.eval_import true TestMod :($(QuoteNode(:($(Expr(:., :A)))))) :($(QuoteNode(:($(Expr(:., :b)))))))\n+2   latestworld\n+3   (return core.nothing)\n+\n+########################################\n+# Import with paths and `as`\n+import A.B.C: b, c.d as e\n+#---------------------\n+1   (call JuliaLowering.eval_import true TestMod :($(QuoteNode(:($(Expr(:., :A, :B, :C)))))) :($(QuoteNode(:($(Expr(:., :b)))))) :($(QuoteNode(:(c.d as e)))))\n+2   latestworld\n+3   (return core.nothing)\n+\n+########################################\n+# Imports without `from` module need separating with latestworld\n+import A, B\n+#---------------------\n+1   (call JuliaLowering.eval_import true TestMod top.nothing :($(QuoteNode(:($(Expr(:., :A)))))))\n+2   latestworld\n+3   (call JuliaLowering.eval_import true TestMod top.nothing :($(QuoteNode(:($(Expr(:., :B)))))))\n+4   latestworld\n+5   (return core.nothing)\n+\n+########################################\n+# Multiple usings need separating with latestworld\n+using A, B\n+#---------------------\n+1   (call JuliaLowering.eval_using TestMod :($(QuoteNode(:($(Expr(:., :A)))))))\n+2   latestworld\n+3   (call JuliaLowering.eval_using TestMod :($(QuoteNode(:($(Expr(:., :B)))))))\n+4   latestworld\n+5   (return core.nothing)\n+\n+########################################\n+# Using with paths and `as`\n+using A.B.C: b, c.d as e\n+#---------------------\n+1   (call JuliaLowering.eval_import false TestMod :($(QuoteNode(:($(Expr(:., :A, :B, :C)))))) :($(QuoteNode(:($(Expr(:., :b)))))) :($(QuoteNode(:(c.d as e)))))\n+2   latestworld\n+3   (return core.nothing)\n+\n+########################################\n+# Error: Import not at top level\n+function f()\n+    import A: b\n+end\n+#---------------------\n+LoweringError:\n+function f()\n+    import A: b\n+#   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 this syntax is only allowed in top level code\n+end\n+\n+########################################\n+# Export\n+export a, b, c\n+#---------------------\n+1   (call JuliaLowering.eval_public TestMod true [\"a\", \"b\", \"c\"])\n+2   (return %\u2081)\n+\n+########################################\n+# Public\n+public a, b, c\n+#---------------------\n+1   (call JuliaLowering.eval_public TestMod false [\"a\", \"b\", \"c\"])\n+2   (return %\u2081)"
    },
    {
      "sha": "3035a6f3a7bc49dd239afed7673fd322d1118b2d",
      "filename": "JuliaLowering/test/ir_tests.jl",
      "status": "added",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fir_tests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fir_tests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fir_tests.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,10 @@\n+@testset \"IR tests\" begin\n+    testdir = @__DIR__\n+    for filename in readdir(testdir)\n+        if endswith(filename, \"_ir.jl\")\n+            @testset \"$filename\" begin\n+                test_ir_cases(joinpath(testdir, filename))\n+            end\n+        end\n+    end\n+end"
    },
    {
      "sha": "6f63b28cc2b0e018aa669de4bbcf796c5c2d5070",
      "filename": "JuliaLowering/test/loops.jl",
      "status": "added",
      "additions": 279,
      "deletions": 0,
      "changes": 279,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Floops.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Floops.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Floops.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,279 @@\n+\n+@testset \"while loops\" begin\n+\n+test_mod = Module()\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    i = 0\n+    while i < 5\n+        i = i + 1\n+        push!(a, i)\n+    end\n+    a\n+end\n+\"\"\") == [1,2,3,4,5]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    i = 0\n+    while i < 5\n+        i = i + 1\n+        if i == 3\n+            break\n+        end\n+        push!(a, i)\n+    end\n+    a\n+end\n+\"\"\") == [1,2]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    i = 0\n+    while i < 5\n+        i = i + 1\n+        if isodd(i)\n+            continue\n+        end\n+        push!(a, i)\n+    end\n+    a\n+end\n+\"\"\") == [2,4]\n+\n+end\n+\n+@testset \"for loops\" begin\n+\n+test_mod = Module()\n+\n+# iteration\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i = 1:3\n+        push!(a, i)\n+    end\n+    a\n+end\n+\"\"\") == [1,2,3]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i = 1:0\n+        push!(a, i)\n+    end\n+    a\n+end\n+\"\"\") == []\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for _ = 1:3\n+        push!(a, 1)\n+    end\n+    a\n+end\n+\"\"\") == [1, 1, 1]\n+\n+# break\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i = 1:6\n+        if i == 3\n+            break\n+        end\n+        push!(a, i)\n+    end\n+    a\n+end\n+\"\"\") == [1, 2]\n+# Break from inner nested loop\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i in 1:2\n+       for j in 3:4\n+           push!(a, (i, j))\n+           j == 6 && break\n+       end\n+    end\n+    a\n+end\n+\"\"\") == [(1, 3), (1, 4), (2, 3), (2, 4)]\n+\n+# continue\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i = 1:6\n+        if isodd(i)\n+            continue\n+        end\n+        push!(a, i)\n+    end\n+    a\n+end\n+\"\"\") == [2, 4, 6]\n+\n+# Loop variable scope\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i = 1:3\n+        push!(a, i)\n+        i = 100\n+    end\n+    a\n+end\n+\"\"\") == [1,2,3]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    i = 100\n+    for i = 1:3\n+    end\n+    i\n+end\n+\"\"\") == 100\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    i = 100\n+    for outer i = 1:2\n+        nothing\n+    end\n+    i\n+end\n+\"\"\") == 2\n+\n+# Fancy for loop left hand side - unpacking and scoping\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    i = 100\n+    j = 200\n+    for (i,j) in [('a', 'b'), (1,2)]\n+        push!(a, (i,j))\n+    end\n+    (a, i, j)\n+end\n+\"\"\") == ([('a', 'b'), (1,2)], 100, 200)\n+\n+end\n+\n+\n+@testset \"multidimensional for loops\" begin\n+\n+test_mod = Module()\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i = 1:2, j = 3:4\n+        push!(a, (i,j))\n+    end\n+    a\n+end\n+\"\"\") == [(1,3), (1,4), (2,3), (2,4)]\n+\n+@testset \"break/continue\" begin\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i = 1:2, j = 3:4\n+        push!(a, (i,j))\n+        break\n+    end\n+    a\n+end\n+\"\"\") == [(1,3)]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i = 1:4, j = 3:4\n+        if isodd(i)\n+            continue\n+        end\n+        push!(a, (i,j))\n+    end\n+    a\n+end\n+\"\"\") == [(2,3), (2,4), (4,3), (4,4)]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i = 1:2, j = 1:4\n+        if isodd(j)\n+            continue\n+        end\n+        push!(a, (i,j))\n+    end\n+    a\n+end\n+\"\"\") == [(1,2), (1,4), (2,2), (2,4)]\n+\n+\n+end\n+\n+\n+@testset \"Loop variable scope\" begin\n+\n+# Test that `i` is copied in the inner loop\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    a = []\n+    for i = 1:2, j = 3:4\n+        push!(a, (i,j))\n+        i = 100\n+    end\n+    a\n+end\n+\"\"\") == [(1,3), (1,4), (2,3), (2,4)]\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    i = 100\n+    j = 200\n+    for i = 1:2, j = 3:4\n+        nothing\n+    end\n+    (i,j)\n+end\n+\"\"\") == (100,200)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    i = 100\n+    j = 200\n+    for outer i = 1:2, j = 3:4\n+        nothing\n+    end\n+    (i,j)\n+end\n+\"\"\") == (2,200)\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    i = 100\n+    j = 200\n+    for i = 1:2, outer j = 3:4\n+        nothing\n+    end\n+    (i,j)\n+end\n+\"\"\") == (100,4)\n+\n+end\n+\n+end"
    },
    {
      "sha": "709322a084c68c05aa6cd7655db61eaa271d9a9a",
      "filename": "JuliaLowering/test/loops_ir.jl",
      "status": "added",
      "additions": 146,
      "deletions": 0,
      "changes": 146,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Floops_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Floops_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Floops_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,146 @@\n+########################################\n+# Basic while loop\n+while f(a)\n+    body1\n+    body2\n+end\n+#---------------------\n+1   TestMod.f\n+2   TestMod.a\n+3   (call %\u2081 %\u2082)\n+4   (gotoifnot %\u2083 label\u2088)\n+5   TestMod.body1\n+6   TestMod.body2\n+7   (goto label\u2081)\n+8   (return core.nothing)\n+\n+########################################\n+# While loop with short circuit condition\n+while a && b\n+    body\n+end\n+#---------------------\n+1   TestMod.a\n+2   (gotoifnot %\u2081 label\u2087)\n+3   TestMod.b\n+4   (gotoifnot %\u2083 label\u2087)\n+5   TestMod.body\n+6   (goto label\u2081)\n+7   (return core.nothing)\n+\n+########################################\n+# While loop with with break and continue\n+while cond\n+    body1\n+    break\n+    body2\n+    continue\n+    body3\n+end\n+#---------------------\n+1   TestMod.cond\n+2   (gotoifnot %\u2081 label\u2089)\n+3   TestMod.body1\n+4   (goto label\u2089)\n+5   TestMod.body2\n+6   (goto label\u2088)\n+7   TestMod.body3\n+8   (goto label\u2081)\n+9   (return core.nothing)\n+\n+########################################\n+# Basic for loop\n+for x in xs\n+    body\n+end\n+#---------------------\n+1   TestMod.xs\n+2   (= slot\u2081/next (call top.iterate %\u2081))\n+3   slot\u2081/next\n+4   (call core.=== %\u2083 core.nothing)\n+5   (call top.not_int %\u2084)\n+6   (gotoifnot %\u2085 label\u2081\u2087)\n+7   slot\u2081/next\n+8   (= slot\u2082/x (call core.getfield %\u2087 1))\n+9   (call core.getfield %\u2087 2)\n+10  TestMod.body\n+11  (= slot\u2081/next (call top.iterate %\u2081 %\u2089))\n+12  slot\u2081/next\n+13  (call core.=== %\u2081\u2082 core.nothing)\n+14  (call top.not_int %\u2081\u2083)\n+15  (gotoifnot %\u2081\u2084 label\u2081\u2087)\n+16  (goto label\u2087)\n+17  (return core.nothing)\n+\n+########################################\n+# Syntax sugar for nested for loop\n+for x in xs, y in ys\n+    x = 10 # Copy of x; does not overwrite x iteration var\n+end\n+#---------------------\n+1   TestMod.xs\n+2   (= slot\u2082/next (call top.iterate %\u2081))\n+3   slot\u2082/next\n+4   (call core.=== %\u2083 core.nothing)\n+5   (call top.not_int %\u2084)\n+6   (gotoifnot %\u2085 label\u2083\u2084)\n+7   slot\u2082/next\n+8   (= slot\u2083/x (call core.getfield %\u2087 1))\n+9   (call core.getfield %\u2087 2)\n+10  TestMod.ys\n+11  (= slot\u2081/next (call top.iterate %\u2081\u2080))\n+12  slot\u2081/next\n+13  (call core.=== %\u2081\u2082 core.nothing)\n+14  (call top.not_int %\u2081\u2083)\n+15  (gotoifnot %\u2081\u2084 label\u2082\u2088)\n+16  slot\u2083/x\n+17  (= slot\u2084/x %\u2081\u2086)\n+18  slot\u2081/next\n+19  (= slot\u2085/y (call core.getfield %\u2081\u2088 1))\n+20  (call core.getfield %\u2081\u2088 2)\n+21  (= slot\u2084/x 10)\n+22  (= slot\u2081/next (call top.iterate %\u2081\u2080 %\u2082\u2080))\n+23  slot\u2081/next\n+24  (call core.=== %\u2082\u2083 core.nothing)\n+25  (call top.not_int %\u2082\u2084)\n+26  (gotoifnot %\u2082\u2085 label\u2082\u2088)\n+27  (goto label\u2081\u2086)\n+28  (= slot\u2082/next (call top.iterate %\u2081 %\u2089))\n+29  slot\u2082/next\n+30  (call core.=== %\u2082\u2089 core.nothing)\n+31  (call top.not_int %\u2083\u2080)\n+32  (gotoifnot %\u2083\u2081 label\u2083\u2084)\n+33  (goto label\u2087)\n+34  (return core.nothing)\n+\n+########################################\n+# Error: break outside for/while\n+break\n+#---------------------\n+LoweringError:\n+break\n+\u2514\u2500\u2500\u2500\u2518 \u2500\u2500 break must be used inside a `while` or `for` loop\n+\n+########################################\n+# Error: continue outside for/while\n+continue\n+#---------------------\n+LoweringError:\n+continue\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 continue must be used inside a `while` or `for` loop\n+\n+########################################\n+# Error: `outer` without outer local variable\n+let\n+    for outer i = 1:2\n+        nothing\n+    end\n+    i\n+end\n+#---------------------\n+LoweringError:\n+let\n+    for outer i = 1:2\n+#             \u2559 \u2500\u2500 `outer` annotations must match with a local variable in an outer scope but no such variable was found\n+        nothing\n+    end"
    },
    {
      "sha": "d92b3243a76b4a6a78d2cba2c37c0b74757d13c8",
      "filename": "JuliaLowering/test/macros.jl",
      "status": "added",
      "additions": 486,
      "deletions": 0,
      "changes": 486,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fmacros.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fmacros.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmacros.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,486 @@\n+@testset \"macro tests\" begin\n+\n+test_mod = Module(:macro_test)\n+Base.eval(test_mod, :(const var\"@ast\" = $(JuliaLowering.var\"@ast\")))\n+Base.eval(test_mod, :(const var\"@K_str\" = $(JuliaLowering.var\"@K_str\")))\n+\n+# These libraries may either be packages or vendored into Base - need to pull\n+# them in via relative paths in the `using` statements below.\n+Base.eval(test_mod, :(const JuliaLowering = $(JuliaLowering)))\n+Base.eval(test_mod, :(const JuliaSyntax = $(JuliaSyntax)))\n+\n+JuliaLowering.include_string(test_mod, raw\"\"\"\n+module M\n+    using ..JuliaLowering: JuliaLowering, adopt_scope\n+    using ..JuliaSyntax\n+\n+    # Introspection\n+    macro __MODULE__()\n+        __context__.scope_layer.mod\n+    end\n+\n+    macro __FILE__()\n+        JuliaLowering.filename(__context__.macrocall)\n+    end\n+\n+    macro __LINE__()\n+        JuliaLowering.source_location(__context__.macrocall)[1]\n+    end\n+\n+    someglobal = \"global in module M\"\n+\n+    # Macro with local variables\n+    macro foo(ex)\n+        :(begin\n+            x = \"`x` from @foo\"\n+            (x, someglobal, $ex)\n+        end)\n+    end\n+\n+    # Set `a_global` in M\n+    macro set_a_global(val)\n+        :(begin\n+            global a_global = $val\n+        end)\n+    end\n+\n+    macro set_other_global(ex, val)\n+        :(begin\n+            global $ex = $val\n+        end)\n+    end\n+\n+    macro set_global_in_parent(ex)\n+        e1 = adopt_scope(:(sym_introduced_from_M), __context__)\n+        quote\n+            $e1 = $ex\n+            nothing\n+        end\n+    end\n+\n+    macro inner()\n+        :(y)\n+    end\n+\n+    macro outer()\n+        :((x, @inner))\n+    end\n+\n+    macro recursive(N)\n+        Nval = N.value::Int\n+        if Nval < 1\n+            return N\n+        end\n+        quote\n+            x = $N\n+            (x, @recursive $(Nval-1))\n+        end\n+    end\n+end\n+\"\"\")\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let\n+    x = \"`x` from outer scope\"\n+    M.@foo x\n+end\n+\"\"\") == (\"`x` from @foo\", \"global in module M\", \"`x` from outer scope\")\n+@test !isdefined(test_mod.M, :x)\n+\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+#line1\n+(M.@__MODULE__(), M.@__FILE__(), M.@__LINE__())\n+\"\"\", \"foo.jl\") == (test_mod, \"foo.jl\", 2)\n+\n+@test !isdefined(test_mod.M, :a_global)\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    M.@set_a_global 42\n+    M.a_global\n+end\n+\"\"\") == 42\n+\n+JuliaLowering.include_string(test_mod, \"\"\"\n+M.@set_global_in_parent \"bent hygiene!\"\n+\"\"\")\n+@test test_mod.sym_introduced_from_M == \"bent hygiene!\"\n+\n+JuliaLowering.include_string(test_mod, \"M.@set_other_global global_in_test_mod 100\")\n+@test !isdefined(test_mod.M, :global_in_test_mod)\n+@test test_mod.global_in_test_mod == 100\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+M.@recursive 3\n+\"\"\") == (3, (2, (1, 0)))\n+\n+ex = JuliaLowering.parsestmt(JuliaLowering.SyntaxTree, \"M.@outer()\", filename=\"foo.jl\")\n+ctx, expanded = JuliaLowering.expand_forms_1(test_mod, ex, false, Base.get_world_counter())\n+@test JuliaLowering.sourcetext.(JuliaLowering.flattened_provenance(expanded[2])) == [\n+    \"M.@outer()\"\n+    \"@inner\"\n+    \"y\"\n+]\n+\n+# World age support for macro expansion\n+JuliaLowering.include_string(test_mod, raw\"\"\"\n+macro world_age_test()\n+    :(world1)\n+end\n+\"\"\")\n+world1 = Base.get_world_counter()\n+JuliaLowering.include_string(test_mod, raw\"\"\"\n+macro world_age_test()\n+    :(world2)\n+end\n+\"\"\")\n+world2 = Base.get_world_counter()\n+\n+call_world_arg_test = JuliaLowering.parsestmt(JuliaLowering.SyntaxTree, \"@world_age_test()\")\n+@test JuliaLowering.expand_forms_1(test_mod, call_world_arg_test, false, world1)[2] \u2248\n+    @ast_ \"world1\"::K\"Identifier\"\n+@test JuliaLowering.expand_forms_1(test_mod, call_world_arg_test, false, world2)[2] \u2248\n+    @ast_ \"world2\"::K\"Identifier\"\n+\n+# Layer parenting\n+@test expanded[1].scope_layer == 2\n+@test expanded[2].scope_layer == 3\n+@test getfield.(ctx.scope_layers, :parent_layer) == [0,1,2]\n+\n+JuliaLowering.include_string(test_mod, \"\"\"\n+f_throw(x) = throw(x)\n+macro m_throw(x)\n+    :(\\$(f_throw(x)))\n+end\n+\"\"\")\n+let (err, st) = try\n+        JuliaLowering.include_string(test_mod, \"_never_exist = @m_throw 42\")\n+    catch e\n+        e, stacktrace(catch_backtrace())\n+    end\n+    @test err isa JuliaLowering.MacroExpansionError\n+    @test !isnothing(err.err)\n+    # Check that `catch_backtrace` can capture the stacktrace of the macro functions\n+    @test any(sf->sf.func===:f_throw, st)\n+    @test any(sf->sf.func===Symbol(\"@m_throw\"), st)\n+end\n+\n+let err = try\n+        JuliaLowering.include_string(test_mod, \"_never_exist = @m_not_exist 42\")\n+    catch e\n+        e\n+    end\n+    @test err isa JuliaLowering.MacroExpansionError\n+    @test err.msg == \"Macro not found\"\n+    @test err.err isa UndefVarError\n+end\n+\n+@test JuliaLowering.include_string(test_mod, \"@ccall strlen(\\\"foo\\\"::Cstring)::Csize_t\") == 3\n+@test JuliaLowering.include_string(test_mod, \"@ccall strlen(\\\"asdf\\\"::Cstring)::Csize_t gc_safe=true\") == 4\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+    buf = zeros(UInt8, 20)\n+    @ccall sprintf(buf::Ptr{UInt8}, \"num:%d str:%s\"::Cstring; 42::Cint, \"hello\"::Cstring)::Cint\n+    String(buf)\n+end\n+\"\"\") == \"num:42 str:hello\\0\\0\\0\\0\"\n+\n+let (err, st) = try\n+        JuliaLowering.include_string(test_mod, \"@ccall strlen(\\\"foo\\\"::Cstring)\")\n+    catch e\n+        e, stacktrace(catch_backtrace())\n+    end\n+    @test err isa JuliaLowering.MacroExpansionError\n+    @test err.msg == \"Expected a return type annotation `::SomeType`\"\n+    @test isnothing(err.err)\n+    # Check that `catch_backtrace` can capture the stacktrace of the macro function\n+    @test any(sf->sf.func===:ccall_macro_parse, st)\n+end\n+\n+# Tests for interop between old and new-style macros\n+\n+# Hygiene interop\n+JuliaLowering.include_string(test_mod, raw\"\"\"\n+    macro call_oldstyle_macro(a)\n+        quote\n+            x = \"x in call_oldstyle_macro\"\n+            @oldstyle $a x\n+        end\n+    end\n+\n+    macro newstyle(a, b, c)\n+        quote\n+            x = \"x in @newstyle\"\n+            ($a, $b, $c, x)\n+        end\n+    end\n+\"\"\")\n+# TODO: Make this macro lowering go via JuliaSyntax rather than the flisp code\n+# (JuliaSyntax needs support for old-style quasiquote processing)\n+Base.eval(test_mod, :(\n+macro oldstyle(a, b)\n+    quote\n+        x = \"x in @oldstyle\"\n+        @newstyle $(esc(a)) $(esc(b)) x\n+    end\n+end\n+))\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x = \"x in outer scope\"\n+    @call_oldstyle_macro x\n+end\n+\"\"\") == (\"x in outer scope\",\n+         \"x in call_oldstyle_macro\",\n+         \"x in @oldstyle\",\n+         \"x in @newstyle\")\n+\n+# Old style unhygenic escaping with esc()\n+Base.eval(test_mod, :(\n+macro oldstyle_unhygenic()\n+    esc(:x)\n+end\n+))\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x = \"x in outer scope\"\n+    @oldstyle_unhygenic\n+end\n+\"\"\") == \"x in outer scope\"\n+\n+# Exceptions in old style macros\n+Base.eval(test_mod, :(\n+macro oldstyle_error()\n+    error(\"Some error in old style macro\")\n+end\n+))\n+@test try\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    @oldstyle_error\n+    \"\"\")\n+catch exc\n+    sprint(showerror, exc)\n+end == \"\"\"\n+MacroExpansionError while expanding @oldstyle_error in module Main.macro_test:\n+@oldstyle_error\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Error expanding macro\n+Caused by:\n+Some error in old style macro\"\"\"\n+\n+@test sprint(\n+    showerror,\n+    JuliaLowering.MacroExpansionError(\n+        JuliaLowering.expr_to_syntaxtree(:(foo), LineNumberNode(1)),\n+        \"fake error\")) ==\n+            \"MacroExpansionError:\\n#= line 1 =# - fake error\"\n+\n+# Old-style macros returning non-Expr values\n+Base.eval(test_mod, :(\n+macro oldstyle_non_Expr()\n+    42\n+end\n+))\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+@oldstyle_non_Expr\n+\"\"\") === 42\n+\n+# New-style macros called with the wrong arguments\n+JuliaLowering.include_string(test_mod, raw\"\"\"\n+macro method_error_test(a)\n+end\n+\"\"\")\n+Base.eval(test_mod, :(\n+macro method_error_test()\n+end\n+))\n+try\n+    JuliaLowering.include_string(test_mod, raw\"\"\"\n+    @method_error_test x y\n+    \"\"\")\n+    @test false\n+catch exc\n+    @test exc isa JuliaLowering.MacroExpansionError\n+    mexc = exc.err\n+    @test mexc isa MethodError\n+    @test mexc.args isa Tuple{JuliaLowering.MacroContext, JuliaLowering.SyntaxTree, JuliaLowering.SyntaxTree}\n+end\n+\n+@testset \"calling with old/new macro signatures\" begin\n+    # Old defined with 1 arg, new with 2 args, both with 3 (but with different values)\n+    Base.eval(test_mod, :(macro sig_mismatch(x); x; end))\n+    Base.eval(test_mod, :(macro sig_mismatch(x, y, z); z; end))\n+    JuliaLowering.include_string(test_mod, \"macro sig_mismatch(x, y); x; end\")\n+    JuliaLowering.include_string(test_mod, \"macro sig_mismatch(x, y, z); x; end\")\n+\n+    @test JuliaLowering.include_string(test_mod, \"@sig_mismatch(1)\") === 1\n+    @test JuliaLowering.include_string(test_mod, \"@sig_mismatch(1, 2)\") === 1\n+    @test JuliaLowering.include_string(test_mod, \"@sig_mismatch(1, 2, 3)\") === 1 # 3 if we prioritize old sig\n+    err = try\n+        JuliaLowering.include_string(test_mod, \"@sig_mismatch(1, 2, 3, 4)\") === 1\n+    catch exc\n+        sprint(showerror, exc, context=:module=>test_mod)\n+    end\n+    @test startswith(err, \"\"\"\n+    MacroExpansionError while expanding @sig_mismatch in module Main.macro_test:\n+    @sig_mismatch(1, 2, 3, 4)\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Error expanding macro\n+    Caused by:\n+    MethodError: no method matching var\"@sig_mismatch\"(::JuliaLowering.MacroContext, ::JuliaLowering.SyntaxTree\"\"\")\n+end\n+\n+@testset \"old macros producing exotic expr heads\" begin\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    let # example from @preserve docstring\n+        x = Ref{Int}(101)\n+        p = Base.unsafe_convert(Ptr{Int}, x)\n+        GC.@preserve x unsafe_load(p)\n+    end\"\"\") === 101 # Expr(:gc_preserve)\n+\n+    # only invokelatest produces :isglobal now, so MWE here\n+    Base.eval(test_mod, :(macro isglobal(x); esc(Expr(:isglobal, x)); end))\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    some_global = 1\n+    function isglobal_chk(some_arg)\n+       local some_local = 1\n+       (@isglobal(some_undefined), @isglobal(some_global), @isglobal(some_arg), @isglobal(some_local))\n+    end\n+    isglobal_chk(1)\n+    \"\"\") === (true, true, false, false)\n+    # with K\"Placeholder\"s\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    __ = 1\n+    function isglobal_chk(___)\n+       local ____ = 1\n+       (@isglobal(_), @isglobal(__), @isglobal(___), @isglobal(____))\n+    end\n+    isglobal_chk(1)\n+    \"\"\") === (false, false, false, false)\n+\n+    # @test appears to be the only macro in base to use :inert\n+    test_result = JuliaLowering.include_string(test_mod, \"\"\"\n+    using Test\n+    @test identity(123) === 123\n+    \"\"\"; expr_compat_mode=true)\n+    @test test_result.value === true\n+\n+    # @enum produces Expr(:toplevel)\n+    JuliaLowering.include_string(test_mod, \"\"\"\n+    @enum SOME_ENUM X1 X2 X3\n+    \"\"\"; expr_compat_mode=true)\n+    @test test_mod.SOME_ENUM <: Enum\n+    @test test_mod.X1 isa Enum\n+end\n+\n+@testset \"macros producing meta forms\" begin\n+    function find_method_ci(thunk)\n+        ci = thunk.args[1]::Core.CodeInfo\n+        m = findfirst(x->(x isa Expr && x.head === :method && length(x.args) === 3), ci.code)\n+        ci.code[m].args[3]\n+    end\n+    jlower_e(s) = JuliaLowering.to_lowered_expr(\n+        JuliaLowering.lower(\n+            test_mod, JuliaLowering.parsestmt(\n+                JuliaLowering.SyntaxTree, s);\n+            expr_compat_mode=true))\n+\n+    prog = \"Base.@assume_effects :foldable function foo(); end\"\n+    ref = Meta.lower(test_mod, Meta.parse(prog))\n+    our = jlower_e(prog)\n+    @test find_method_ci(ref).purity === find_method_ci(our).purity\n+\n+    prog = \"Base.@inline function foo(); end\"\n+    ref = Meta.lower(test_mod, Meta.parse(prog))\n+    our = jlower_e(prog)\n+    @test find_method_ci(ref).inlining === find_method_ci(our).inlining\n+\n+    prog = \"Base.@noinline function foo(); end\"\n+    ref = Meta.lower(test_mod, Meta.parse(prog))\n+    our = jlower_e(prog)\n+    @test find_method_ci(ref).inlining === find_method_ci(our).inlining\n+\n+    prog = \"Base.@constprop :none function foo(); end\"\n+    ref = Meta.lower(test_mod, Meta.parse(prog))\n+    our = jlower_e(prog)\n+    @test find_method_ci(ref).constprop === find_method_ci(our).constprop\n+\n+    prog = \"Base.@nospecializeinfer function foo(); end\"\n+    ref = Meta.lower(test_mod, Meta.parse(prog))\n+    our = jlower_e(prog)\n+    @test find_method_ci(ref).nospecializeinfer === find_method_ci(our).nospecializeinfer\n+\n+    prog = \"Base.@propagate_inbounds function foo(); end\"\n+    ref = Meta.lower(test_mod, Meta.parse(prog))\n+    our = jlower_e(prog)\n+    @test find_method_ci(ref).propagate_inbounds === find_method_ci(our).propagate_inbounds\n+\n+end\n+\n+@testset \"scope layers for normally-inert ASTs\" begin\n+    # Right hand side of `.`\n+    @test JuliaLowering.include_string(test_mod, raw\"\"\"\n+    let x = :(hi)\n+        :(A.$x)\n+    end\n+    \"\"\") \u2248 @ast_ [K\".\"\n+        \"A\"::K\"Identifier\"\n+        \"hi\"::K\"Identifier\"\n+    ]\n+    # module\n+    @test JuliaLowering.include_string(test_mod, raw\"\"\"\n+    let x = :(AA)\n+        :(module $x\n+        end\n+        )\n+    end\n+    \"\"\") \u2248 @ast_ [K\"module\"\n+        \"AA\"::K\"Identifier\"\n+        [K\"block\"\n+        ]\n+    ]\n+\n+    # In macro expansion, require that expressions passed in as macro\n+    # *arguments* get the lexical scope of the calling context, even for the\n+    # `x` in `M.$x` where the right hand side of `.` is normally quoted.\n+    @test JuliaLowering.include_string(test_mod, raw\"\"\"\n+        let x = :(someglobal)\n+            @eval M.$x\n+        end\n+    \"\"\") == \"global in module M\"\n+\n+    JuliaLowering.include_string(test_mod, raw\"\"\"\n+        let y = 101\n+            @eval module AA\n+                x = $y\n+            end\n+        end\n+    \"\"\")\n+    @test test_mod.AA.x == 101\n+\n+    # \"Deferred hygiene\" in macros which emit quoted code currently doesn't\n+    # work as might be expected.\n+    #\n+    # The old macro system also doesn't handle this - here's the equivalent\n+    # implementation\n+    # macro make_quoted_code(init, y)\n+    #     QuoteNode(:(let\n+    #         x = \"inner x\"\n+    #         $(esc(init))\n+    #         ($(esc(y)), x)\n+    #     end))\n+    # end\n+    #\n+    # TODO: The following should throw an error rather than producing a\n+    # surprising value, or work \"as expected\" whatever that is!\n+    JuliaLowering.include_string(test_mod, raw\"\"\"\n+    macro make_quoted_code(init, y)\n+        q = :(let\n+            x = \"inner x\"\n+            $init\n+            ($y, x)\n+        end)\n+        @ast q q [K\"inert\" q]\n+    end\n+    \"\"\")\n+    code = JuliaLowering.include_string(test_mod, \"\"\"@make_quoted_code(x=\"outer x\", x)\"\"\")\n+    @test_broken JuliaLowering.eval(test_mod, code) == (\"outer x\", \"inner x\")\n+end\n+\n+end"
    },
    {
      "sha": "2889023a14b3bf6092a62bfd21e643adbecaf578",
      "filename": "JuliaLowering/test/macros_ir.jl",
      "status": "added",
      "additions": 210,
      "deletions": 0,
      "changes": 210,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fmacros_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fmacros_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmacros_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,210 @@\n+module MacroMethods\n+    macro some_macro()\n+        quote\n+            some_global\n+        end\n+    end\n+\n+    module ExtraMacroMethods\n+        using ..MacroMethods\n+        macro MacroMethods.some_macro(ex)\n+            quote\n+                some_global\n+            end\n+        end\n+    end\n+end\n+\n+macro strmac_str(ex, suff=nothing)\n+    s = \"$(ex[1].value) from strmac\"\n+    if !isnothing(suff)\n+        s = \"$s with suffix $(suff.value)\"\n+    end\n+    s\n+end\n+\n+macro cmdmac_cmd(ex, suff=nothing)\n+    s = \"$(ex[1].value) from cmdmac\"\n+    if !isnothing(suff)\n+        s = \"$s with suffix $(suff.value)\"\n+    end\n+    s\n+end\n+\n+#*******************************************************************************\n+########################################\n+# Simple macro\n+macro add_one(ex)\n+    quote\n+        $ex + 1\n+    end\n+end\n+#---------------------\n+1   (method TestMod.@add_one)\n+2   latestworld\n+3   TestMod.@add_one\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084 JuliaLowering.MacroContext core.Any)\n+6   (call core.svec)\n+7   SourceLocation::1:7\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/__context__(!read) slot\u2083/ex]\n+    1   (call core.tuple slot\u2083/ex)\n+    2   (call JuliaLowering.interpolate_ast SyntaxTree (inert (block (call-i ($ ex) + 1))) %\u2081)\n+    3   (return %\u2082)\n+10  latestworld\n+11  TestMod.@add_one\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Macro using `__context__`\n+macro foo(ex)\n+    ctx = __context__\n+end\n+#---------------------\n+1   (method TestMod.@foo)\n+2   latestworld\n+3   TestMod.@foo\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084 JuliaLowering.MacroContext core.Any)\n+6   (call core.svec)\n+7   SourceLocation::1:7\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read) slot\u2082/__context__ slot\u2083/ex(!read) slot\u2084/ctx(!read)]\n+    1   slot\u2082/__context__\n+    2   (= slot\u2084/ctx %\u2081)\n+    3   (return %\u2081)\n+10  latestworld\n+11  TestMod.@foo\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Scope for symbols emitted by macros is the module where the method was\n+# defined, thus two different modules in this case, even though `@some_macro`\n+# belongs to the MacroMethods module.\n+(MacroMethods.@some_macro(), MacroMethods.@some_macro(unused))\n+#---------------------\n+1   TestMod.MacroMethods.some_global\n+2   TestMod.MacroMethods.ExtraMacroMethods.some_global\n+3   (call core.tuple %\u2081 %\u2082)\n+4   (return %\u2083)\n+\n+########################################\n+# Error: Macro with kw args\n+macro mmm(a; b=2)\n+end\n+#---------------------\n+LoweringError:\n+macro mmm(a; b=2)\n+#          \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 macros cannot accept keyword arguments\n+end\n+\n+########################################\n+# Error: Bad macro name\n+macro mmm[](ex)\n+end\n+#---------------------\n+LoweringError:\n+macro mmm[](ex)\n+#     \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 invalid macro name\n+end\n+\n+########################################\n+# Error: Macros not allowed in local scope\n+let\n+    macro foo(ex)\n+    end\n+end\n+#---------------------\n+LoweringError:\n+let\n+#   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+    macro foo(ex)\n+    end\n+#\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 macro is only allowed in global scope\n+end\n+\n+########################################\n+# Error: Macros not allowed in local scope\n+function f()\n+    macro foo()\n+    end\n+end\n+#---------------------\n+LoweringError:\n+function f()\n+#   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+    macro foo()\n+    end\n+#\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 macro is only allowed in global scope\n+end\n+\n+########################################\n+# Error: Macros not found\n+_never_exist = @m_not_exist 42\n+#---------------------\n+MacroExpansionError while expanding @m_not_exist in module Main.TestMod:\n+_never_exist = @m_not_exist 42\n+#              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Macro not found\n+Caused by:\n+UndefVarError: `@m_not_exist` not defined in `Main.TestMod`\n+Suggestion: check for spelling errors or missing imports.\n+\n+########################################\n+# Simple cmdstring\n+`echo 1`\n+#---------------------\n+1   Base.cmd_gen\n+2   (call core.tuple \"echo\")\n+3   (call core.tuple \"1\")\n+4   (call core.tuple %\u2082 %\u2083)\n+5   (call %\u2081 %\u2084)\n+6   (return %\u2085)\n+\n+########################################\n+# Simple string macro\n+strmac\"hello\"\n+#---------------------\n+1   (return \"hello from strmac\")\n+\n+########################################\n+# String macro with suffix\n+strmac\"hello\"blah\n+#---------------------\n+1   (return \"hello from strmac with suffix blah\")\n+\n+########################################\n+# Simple cmd macro\n+cmdmac`hello`\n+#---------------------\n+1   (return \"hello from cmdmac\")\n+\n+########################################\n+# Cmd macro with suffix\n+cmdmac`hello`12345\n+#---------------------\n+1   (return \"hello from cmdmac with suffix 12345\")\n+\n+########################################\n+# @nospecialize (zero args)\n+function foo()\n+    @nospecialize\n+end\n+#---------------------\n+1   (method TestMod.foo)\n+2   latestworld\n+3   TestMod.foo\n+4   (call core.Typeof %\u2083)\n+5   (call core.svec %\u2084)\n+6   (call core.svec)\n+7   SourceLocation::1:10\n+8   (call core.svec %\u2085 %\u2086 %\u2087)\n+9   --- method core.nothing %\u2088\n+    slots: [slot\u2081/#self#(!read)]\n+    1   (meta :nospecialize)\n+    2   (return core.nothing)\n+10  latestworld\n+11  TestMod.foo\n+12  (return %\u2081\u2081)"
    },
    {
      "sha": "75bb26e9a6f92db0ea50b2e3e46882795034a2cc",
      "filename": "JuliaLowering/test/misc.jl",
      "status": "added",
      "additions": 216,
      "deletions": 0,
      "changes": 216,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fmisc.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fmisc.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmisc.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,216 @@\n+@testset \"Miscellaneous\" begin\n+\n+test_mod = Module()\n+\n+# Blocks\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+begin\n+end\n+\"\"\") == nothing\n+\n+# Placeholders\n+@test JuliaLowering.include_string(test_mod, \"\"\"_ = 10\"\"\") == 10\n+\n+# GC.@preserve\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x = [1,2]\n+    GC.@preserve x begin\n+        x\n+    end\n+end\n+\"\"\") == [1,2]\n+\n+@test JuliaLowering.include_string(test_mod, raw\"\"\"\n+let\n+    x = 10\n+    @eval $x + 2\n+end\n+\"\"\") == 12\n+\n+@test JuliaLowering.include_string(test_mod, raw\"\"\"\n+module EvalTest\n+    _some_var = 2\n+end\n+let\n+    x = 10\n+    @eval EvalTest $x + _some_var\n+end\n+\"\"\") == 12\n+\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+let x=11\n+    20x\n+end\n+\"\"\") == 220\n+\n+# ccall\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+ccall(:strlen, Csize_t, (Cstring,), \"asdfg\")\n+\"\"\") == 5\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+function cvarargs_0()\n+    strp = Ref{Ptr{Cchar}}(0)\n+    fmt = \"hi\"\n+    len = ccall(:asprintf, Cint, (Ptr{Ptr{Cchar}}, Cstring, Cfloat...), strp, fmt)\n+    str = unsafe_string(strp[], len)\n+    Libc.free(strp[])\n+    return str\n+end\n+\"\"\") isa Function\n+@test test_mod.cvarargs_0() == \"hi\"\n+@test JuliaLowering.include_string(test_mod, \"\"\"\n+function cvarargs_2(arg1::Float64, arg2::Float64)\n+    strp = Ref{Ptr{Cchar}}(0)\n+    fmt = \"%3.1f %3.1f\"\n+    len = ccall(:asprintf, Cint, (Ptr{Ptr{Cchar}}, Cstring, Cfloat...), strp, fmt, arg1, arg2)\n+    str = unsafe_string(strp[], len)\n+    Libc.free(strp[])\n+    return str\n+end\n+\"\"\") isa Function\n+@test test_mod.cvarargs_2(1.1, 2.2) == \"1.1 2.2\"\n+\n+# cfunction\n+JuliaLowering.include_string(test_mod, \"\"\"\n+function f_ccallable(x, y)\n+    x + y * 10\n+end\n+\"\"\")\n+cf_int = JuliaLowering.include_string(test_mod, \"\"\"\n+@cfunction(f_ccallable, Int, (Int,Int))\n+\"\"\")\n+@test @ccall($cf_int(2::Int, 3::Int)::Int) == 32\n+cf_float = JuliaLowering.include_string(test_mod, \"\"\"\n+@cfunction(f_ccallable, Float64, (Float64,Float64))\n+\"\"\")\n+@test @ccall($cf_float(2::Float64, 3::Float64)::Float64) == 32.0\n+\n+# Test that hygiene works with @ccallable function names (this is broken in\n+# Base)\n+JuliaLowering.include_string(test_mod, raw\"\"\"\n+f_ccallable_hygiene() = 1\n+\n+module Nested\n+    f_ccallable_hygiene() = 2\n+    macro cfunction_hygiene()\n+        :(@cfunction(f_ccallable_hygiene, Int, ()))\n+    end\n+end\n+\"\"\")\n+cf_hygiene = JuliaLowering.include_string(test_mod, \"\"\"\n+Nested.@cfunction_hygiene\n+\"\"\")\n+@test @ccall($cf_hygiene()::Int) == 2\n+\n+# Test that ccall can be passed static parameters in type signatures.\n+#\n+# Note that the cases where this works are extremely limited and tend to look\n+# like `Ptr{T}` or `Ref{T}` (`T` doesn't work!?) because of the compilation\n+# order in which the runtime inspects the arguments to ccall (`Ptr{T}` has a\n+# well defined C ABI even when `T` is not yet determined). See also\n+# https://github.com/JuliaLang/julia/issues/29400\n+# https://github.com/JuliaLang/julia/pull/40947\n+JuliaLowering.include_string(test_mod, raw\"\"\"\n+function sparam_ccallable(x::Ptr{T}) where {T}\n+    unsafe_store!(x, one(T))\n+    nothing\n+end\n+\n+function ccall_with_sparams(::Type{T}) where {T}\n+    x = T[zero(T)]\n+    cf = @cfunction(sparam_ccallable, Cvoid, (Ptr{T},))\n+    @ccall $cf(x::Ptr{T})::Cvoid\n+    x[1]\n+end\n+\"\"\")\n+@test test_mod.ccall_with_sparams(Int) === 1\n+@test test_mod.ccall_with_sparams(Float64) === 1.0\n+\n+# FIXME Currently JL cannot handle `@generated` functions, so the following test cases are commented out.\n+# # Test that ccall can be passed static parameters in the function name\n+# # Note that this only works with `@generated` functions from 1.13 onwards,\n+# # where the function name can be evaluated at code generation time.\n+# JuliaLowering.include_string(test_mod, raw\"\"\"\n+# # In principle, may add other strlen-like functions here for different string\n+# # types\n+# ccallable_sptest_name(::Type{String}) = :strlen\n+#\n+# @generated function ccall_with_sparams_in_name(s::T) where {T}\n+#     name = QuoteNode(ccallable_sptest_name(T))\n+#     :(ccall($name, Csize_t, (Cstring,), s))\n+# end\n+# \"\"\")\n+# @test test_mod.ccall_with_sparams_in_name(\"hii\") == 3\n+\n+@testset \"CodeInfo: has_image_globalref\" begin\n+    @test lower_str(test_mod, \"x + y\").args[1].has_image_globalref === false\n+    @test lower_str(Main, \"x + y\").args[1].has_image_globalref === true\n+end\n+\n+@testset \"docstrings: doc-only expressions\" begin\n+    local jeval(mod, str) = JuliaLowering.include_string(mod, str; expr_compat_mode=true)\n+    jeval(test_mod, \"function fun_exists(x); x; end\")\n+    jeval(test_mod, \"module M end; module M2 end\")\n+    # TODO: return values are to be determined, currently Base.Docs.Binding for\n+    # both lowering implementations.  We can't return the value of the\n+    # expression in these special cases.\n+    jeval(test_mod, \"\\\"docstr1\\\" sym_noexist\")\n+    jeval(test_mod, \"\\\"docstr2\\\" fun_noexist()\")\n+    jeval(test_mod, \"\\\"docstr3\\\" fun_exists(sym_noexist)\")\n+    jeval(test_mod, \"\\\"docstr4\\\" M.sym_noexist\")\n+    jeval(test_mod, \"\\\"docstr5\\\" M.fun_noexist()\")\n+    jeval(test_mod, \"\\\"docstr6\\\" M.fun_exists(sym_noexist)\")\n+    @test jeval(test_mod, \"@doc sym_noexist\")               |> string === \"docstr1\\n\"\n+    @test jeval(test_mod, \"@doc fun_noexist()\")             |> string === \"docstr2\\n\"\n+    @test jeval(test_mod, \"@doc fun_exists(sym_noexist)\")   |> string === \"docstr3\\n\"\n+    @test jeval(test_mod, \"@doc M.sym_noexist\")             |> string === \"docstr4\\n\"\n+    @test jeval(test_mod, \"@doc M.fun_noexist()\")           |> string === \"docstr5\\n\"\n+    @test jeval(test_mod, \"@doc M.fun_exists(sym_noexist)\") |> string === \"docstr6\\n\"\n+    @test jeval(test_mod.M, \"@doc M.sym_noexist\")             |> string === \"docstr4\\n\"\n+    @test jeval(test_mod.M, \"@doc M.fun_noexist()\")           |> string === \"docstr5\\n\"\n+    @test jeval(test_mod.M, \"@doc M.fun_exists(sym_noexist)\") |> string === \"docstr6\\n\"\n+\n+    jeval(test_mod.M2, \"\\\"docstr7\\\" M2.M2.sym_noexist\")\n+    jeval(test_mod.M2, \"\\\"docstr8\\\" M2.M2.fun_noexist()\")\n+    jeval(test_mod.M2, \"\\\"docstr9\\\" M2.M2.fun_exists(sym_noexist)\")\n+    @test jeval(test_mod, \"@doc M2.M2.sym_noexist\")             |> string === \"docstr7\\n\"\n+    @test jeval(test_mod, \"@doc M2.M2.fun_noexist()\")           |> string === \"docstr8\\n\"\n+    @test jeval(test_mod, \"@doc M2.M2.fun_exists(sym_noexist)\") |> string === \"docstr9\\n\"\n+    @test jeval(test_mod.M2, \"@doc M2.M2.sym_noexist\")             |> string === \"docstr7\\n\"\n+    @test jeval(test_mod.M2, \"@doc M2.M2.fun_noexist()\")           |> string === \"docstr8\\n\"\n+    @test jeval(test_mod.M2, \"@doc M2.M2.fun_exists(sym_noexist)\") |> string === \"docstr9\\n\"\n+\n+    # Try with signatures and type variables\n+    jeval(test_mod, \"abstract type T_exists end\")\n+\n+    jeval(test_mod, \"\\\"docstr10\\\" f10(x::Int, y, z::T_exists)\")\n+    d = jeval(test_mod, \"@doc f10\")\n+    @test d |> string === \"docstr10\\n\"\n+    # TODO: Is there a better way of accessing this? Feel free to change tests\n+    # if docsystem storage changes.\n+    @test d.meta[:results][1].data[:typesig] === Tuple{Int, Any, test_mod.T_exists}\n+\n+    jeval(test_mod, \"\\\"docstr11\\\" f11(x::T_exists, y::U, z::T) where {T, U<:Number}\")\n+    d = jeval(test_mod, \"@doc f11\")\n+    @test d |> string === \"docstr11\\n\"\n+    @test d.meta[:results][1].data[:typesig] === Tuple{test_mod.T_exists, U, T} where {T, U<:Number}\n+\n+    jeval(test_mod, \"\\\"docstr12\\\" f12(x::Int, y::U, z::T=1) where {T, U<:Number}\")\n+    d = jeval(test_mod, \"@doc f12\")\n+    @test d |> string === \"docstr12\\n\"\n+    @test d.meta[:results][1].data[:typesig] === Union{Tuple{Int, U, T}, Tuple{Int, U}} where {T, U<:Number}\n+\n+end\n+\n+# SyntaxTree @eval should pass along expr_compat_mode\n+@test JuliaLowering.include_string(test_mod, \"@eval quote x end\";\n+                                   expr_compat_mode=false) isa SyntaxTree\n+@test JuliaLowering.include_string(test_mod, \"@eval quote x end\";\n+                                   expr_compat_mode=true) isa Expr\n+@test JuliaLowering.include_string(test_mod, raw\"\"\"\n+    let T = :foo\n+        @eval @doc $\"This is a $T\" $T = 1\n+    end\n+\"\"\"; expr_compat_mode=true) === 1\n+\n+end"
    },
    {
      "sha": "436ff984537ba6bfb8aed1a375f10fe9701a5c15",
      "filename": "JuliaLowering/test/misc_ir.jl",
      "status": "added",
      "additions": 593,
      "deletions": 0,
      "changes": 593,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fmisc_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fmisc_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmisc_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,593 @@\n+module JuxtuposeTest\n+    macro emit_juxtupose()\n+        :(10x)\n+    end\n+end\n+\n+#*******************************************************************************\n+########################################\n+# Getproperty syntax\n+x.a\n+#---------------------\n+1   TestMod.x\n+2   (call top.getproperty %\u2081 :a)\n+3   (return %\u2082)\n+\n+########################################\n+# Getproperty syntax with a string on right hand side\n+x.\"b\"\n+#---------------------\n+1   TestMod.x\n+2   (call top.getproperty %\u2081 \"b\")\n+3   (return %\u2082)\n+\n+########################################\n+# Standalone dot syntax\n+.*\n+#---------------------\n+1   TestMod.*\n+2   (call top.BroadcastFunction %\u2081)\n+3   (return %\u2082)\n+\n+########################################\n+# Error: Wrong number of children in `.`\n+@ast_ [K\".\" \"x\"::K\"Identifier\" \"a\"::K\"Identifier\" 3::K\"Integer\"]\n+#---------------------\n+LoweringError:\n+#= line 1 =# - `.` form requires either one or two children\n+\n+########################################\n+# Error: Placeholder value used\n+_ + 1\n+#---------------------\n+LoweringError:\n+_ + 1\n+\u2559 \u2500\u2500 all-underscore identifiers are write-only and their values cannot be used in expressions\n+\n+########################################\n+# Named tuple\n+(a=1, b=2)\n+#---------------------\n+1   (call core.tuple :a :b)\n+2   (call core.apply_type core.NamedTuple %\u2081)\n+3   (call core.tuple 1 2)\n+4   (call %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# Named tuple with parameters\n+(; a=1, b=2)\n+#---------------------\n+1   (call core.tuple :a :b)\n+2   (call core.apply_type core.NamedTuple %\u2081)\n+3   (call core.tuple 1 2)\n+4   (call %\u2082 %\u2083)\n+5   (return %\u2084)\n+\n+########################################\n+# Empty named tuple\n+(;)\n+#---------------------\n+1   (call core.NamedTuple)\n+2   (return %\u2081)\n+\n+########################################\n+# Named tuple with implicit field names\n+(;x, a.b.c, y._)\n+#---------------------\n+1   (call core.tuple :x :c :_)\n+2   (call core.apply_type core.NamedTuple %\u2081)\n+3   TestMod.x\n+4   TestMod.a\n+5   (call top.getproperty %\u2084 :b)\n+6   (call top.getproperty %\u2085 :c)\n+7   TestMod.y\n+8   (call top.getproperty %\u2087 :_)\n+9   (call core.tuple %\u2083 %\u2086 %\u2088)\n+10  (call %\u2082 %\u2089)\n+11  (return %\u2081\u2080)\n+\n+########################################\n+# Named tuple with splats\n+(; a=1, b=2, bs..., c=3, ds...)\n+#---------------------\n+1   (call core.tuple :a :b)\n+2   (call core.apply_type core.NamedTuple %\u2081)\n+3   (call core.tuple 1 2)\n+4   (call %\u2082 %\u2083)\n+5   TestMod.bs\n+6   (call top.merge %\u2084 %\u2085)\n+7   (call core.tuple :c)\n+8   (call core.apply_type core.NamedTuple %\u2087)\n+9   (call core.tuple 3)\n+10  (call %\u2088 %\u2089)\n+11  (call top.merge %\u2086 %\u2081\u2080)\n+12  TestMod.ds\n+13  (call top.merge %\u2081\u2081 %\u2081\u2082)\n+14  (return %\u2081\u2083)\n+\n+########################################\n+# Named tuple with only splats\n+(; as..., bs...)\n+#---------------------\n+1   (call core.NamedTuple)\n+2   TestMod.as\n+3   (call top.merge %\u2081 %\u2082)\n+4   TestMod.bs\n+5   (call top.merge %\u2083 %\u2084)\n+6   (return %\u2085)\n+\n+########################################\n+# Named tuple with dynamic names\n+(; a=1, b=2, c=>d)\n+#---------------------\n+1   (call core.tuple :a :b)\n+2   (call core.apply_type core.NamedTuple %\u2081)\n+3   (call core.tuple 1 2)\n+4   (call %\u2082 %\u2083)\n+5   TestMod.c\n+6   (call core.tuple %\u2085)\n+7   (call core.apply_type core.NamedTuple %\u2086)\n+8   TestMod.d\n+9   (call core.tuple %\u2088)\n+10  (call %\u2087 %\u2089)\n+11  (call top.merge %\u2084 %\u2081\u2080)\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# Error: Named tuple with repeated fields\n+(; a=1, bs..., c=3, a=2)\n+#---------------------\n+LoweringError:\n+(; a=1, bs..., c=3, a=2)\n+#                   \u2559 \u2500\u2500 Repeated named tuple field name\n+\n+########################################\n+# Error: Named tuple frankentuple\n+(a=1; b=2, c=3)\n+#---------------------\n+LoweringError:\n+(a=1; b=2, c=3)\n+#   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 unexpected semicolon in tuple - use `,` to separate tuple elements\n+\n+########################################\n+# Error: Named tuple field dots in rhs\n+(; a=xs...)\n+#---------------------\n+LoweringError:\n+(; a=xs...)\n+#    \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 `...` cannot be used in a value for a named tuple field\n+\n+########################################\n+# Error: Named tuple field invalid lhs\n+(; a[]=1)\n+#---------------------\n+LoweringError:\n+(; a[]=1)\n+#  \u2514\u2500\u2518 \u2500\u2500 invalid named tuple field name\n+\n+########################################\n+# Error: Named tuple element with weird dot syntax\n+(; a.\"b\")\n+#---------------------\n+LoweringError:\n+(; a.\"b\")\n+#  \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 invalid named tuple element\n+\n+########################################\n+# Error: Named tuple element without valid name\n+(; a=1, f())\n+#---------------------\n+LoweringError:\n+(; a=1, f())\n+#       \u2514\u2500\u2518 \u2500\u2500 Invalid named tuple element\n+\n+########################################\n+# Error: Modules not allowed inside blocks\n+begin\n+    module C\n+    end\n+end\n+#---------------------\n+LoweringError:\n+begin\n+#   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+    module C\n+    end\n+#\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 `module` is only allowed at top level\n+end\n+\n+########################################\n+# Error: Modules not allowed in local scope\n+function f()\n+    module C\n+    end\n+end\n+#---------------------\n+LoweringError:\n+function f()\n+#   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+    module C\n+    end\n+#\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 `module` is only allowed at top level\n+end\n+\n+########################################\n+# Basic type assert\n+x::T\n+#---------------------\n+1   TestMod.x\n+2   TestMod.T\n+3   (call core.typeassert %\u2081 %\u2082)\n+4   (return %\u2083)\n+\n+########################################\n+# Error: Invalid :: syntax outside function arg list\n+::T\n+#---------------------\n+LoweringError:\n+::T\n+\u2514\u2500\u2518 \u2500\u2500 `::` must be written `value::type` outside function argument lists\n+\n+########################################\n+# Error: braces vector syntax\n+{x, y}\n+#---------------------\n+LoweringError:\n+{x, y}\n+\u2514\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 { } syntax is reserved for future use\n+\n+########################################\n+# Error: braces matrix syntax\n+{x y; y z}\n+#---------------------\n+LoweringError:\n+{x y; y z}\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 { } syntax is reserved for future use\n+\n+########################################\n+# Error: Test AST which has no source form and thus must have been constructed\n+# programmatically (eg, a malformed if)\n+@ast_ [K\"if\"]\n+#---------------------\n+LoweringError:\n+#= line 1 =# - expected `numchildren(ex) >= 2`\n+\n+########################################\n+# Error: @atomic in wrong position\n+let\n+    @atomic x\n+end\n+#---------------------\n+LoweringError:\n+let\n+    @atomic x\n+#   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 unimplemented or unsupported atomic declaration\n+end\n+\n+########################################\n+# GC.@preserve support\n+GC.@preserve a b begin\n+    f(a,b)\n+end\n+#---------------------\n+1   TestMod.a\n+2   TestMod.b\n+3   (= slot\u2082/s (gc_preserve_begin %\u2081 %\u2082))\n+4   TestMod.f\n+5   TestMod.a\n+6   TestMod.b\n+7   (= slot\u2081/r (call %\u2084 %\u2085 %\u2086))\n+8   (gc_preserve_end slot\u2082/s)\n+9   slot\u2081/r\n+10  (return %\u2089)\n+\n+########################################\n+# Error: GC.@preserve bad args\n+GC.@preserve a b g() begin\n+    body\n+end\n+#---------------------\n+MacroExpansionError while expanding GC.@preserve in module Main.TestMod:\n+GC.@preserve a b g() begin\n+#                \u2514\u2500\u2518 \u2500\u2500 Preserved variable must be a symbol\n+    body\n+end\n+\n+########################################\n+# @eval without module\n+@eval $f(x, y)\n+#---------------------\n+1   JuliaLowering.eval\n+2   (call core.tuple :expr_compat_mode)\n+3   (call core.apply_type core.NamedTuple %\u2082)\n+4   (call core.tuple false)\n+5   (call %\u2083 %\u2084)\n+6   TestMod.f\n+7   (call core.tuple %\u2086)\n+8   (call JuliaLowering.interpolate_ast SyntaxTree (inert (call ($ f) x y)) %\u2087)\n+9   (= slot\u2081/eval_result (call core.kwcall %\u2085 %\u2081 TestMod %\u2088))\n+10  latestworld\n+11  slot\u2081/eval_result\n+12  (return %\u2081\u2081)\n+\n+########################################\n+# @eval with module\n+@eval mod $f(x, y)\n+#---------------------\n+1   JuliaLowering.eval\n+2   (call core.tuple :expr_compat_mode)\n+3   (call core.apply_type core.NamedTuple %\u2082)\n+4   (call core.tuple false)\n+5   (call %\u2083 %\u2084)\n+6   TestMod.mod\n+7   TestMod.f\n+8   (call core.tuple %\u2087)\n+9   (call JuliaLowering.interpolate_ast SyntaxTree (inert (call ($ f) x y)) %\u2088)\n+10  (= slot\u2081/eval_result (call core.kwcall %\u2085 %\u2081 %\u2086 %\u2089))\n+11  latestworld\n+12  slot\u2081/eval_result\n+13  (return %\u2081\u2082)\n+\n+########################################\n+# Juxtaposition\n+20x\n+#---------------------\n+1   TestMod.*\n+2   TestMod.x\n+3   (call %\u2081 20 %\u2082)\n+4   (return %\u2083)\n+\n+########################################\n+# Juxtaposition - check the juxtapose multiply is resolved to `JuxtuposeTest.*` when\n+# emitted by the macro in the JuxtuposeTest module.\n+#\n+# This is consistent with Julia's existing system but it's not entirely clear\n+# this is good - perhaps we should resolve to Base.* instead? Resolving to the\n+# module-local version makes it exactly equivalent to `*`. But one might argue\n+# this is confusing because the symbol `*` appears nowhere in the user's source\n+# code.\n+JuxtuposeTest.@emit_juxtupose\n+#---------------------\n+1   TestMod.JuxtuposeTest.*\n+2   TestMod.JuxtuposeTest.x\n+3   (call %\u2081 10 %\u2082)\n+4   (return %\u2083)\n+\n+########################################\n+# @cfunction expansion with global generic function as function argument\n+@cfunction(callable, Int, (Int, Float64))\n+#---------------------\n+1   (cfunction Ptr{Nothing} (static_eval TestMod.callable) (static_eval TestMod.Int) (static_eval (call core.svec TestMod.Int TestMod.Float64)) :ccall)\n+2   (return %\u2081)\n+\n+########################################\n+# @cfunction expansion with closed-over callable argument\n+@cfunction($close_over, Int, (Int, Float64))\n+#---------------------\n+1   TestMod.close_over\n+2   (cfunction Base.CFunction %\u2081 (static_eval TestMod.Int) (static_eval (call core.svec TestMod.Int TestMod.Float64)) :ccall)\n+3   (return %\u2082)\n+\n+########################################\n+# Error: Bad arg types to @cfunction\n+@cfunction(f, Int, NotATuple)\n+#---------------------\n+MacroExpansionError while expanding @cfunction in module Main.TestMod:\n+@cfunction(f, Int, NotATuple)\n+#                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 @cfunction argument types must be a literal tuple\n+\n+########################################\n+# Error: Locals used in @cfunction return type\n+let T=Float64\n+    @cfunction(f, T, (Float64,))\n+end\n+#---------------------\n+LoweringError:\n+let T=Float64\n+    @cfunction(f, T, (Float64,))\n+#                 \u2559 \u2500\u2500 cfunction return type cannot reference local variable\n+end\n+\n+########################################\n+# Error: Locals used in @cfunction arg type\n+let T=Float64\n+    @cfunction(f, Float64, (Float64,T))\n+end\n+#---------------------\n+LoweringError:\n+let T=Float64\n+    @cfunction(f, Float64, (Float64,T))\n+#                                   \u2559 \u2500\u2500 cfunction argument type cannot reference local variable\n+end\n+\n+########################################\n+# Basic @ccall lowering\n+@ccall foo(x::X, y::Y)::R\n+#---------------------\n+1   JuliaLowering.Base\n+2   (call top.getproperty %\u2081 :cconvert)\n+3   TestMod.X\n+4   TestMod.x\n+5   (= slot\u2081/arg1 (call %\u2082 %\u2083 %\u2084))\n+6   JuliaLowering.Base\n+7   (call top.getproperty %\u2086 :cconvert)\n+8   TestMod.Y\n+9   TestMod.y\n+10  (= slot\u2082/arg2 (call %\u2087 %\u2088 %\u2089))\n+11  JuliaLowering.Base\n+12  (call top.getproperty %\u2081\u2081 :unsafe_convert)\n+13  TestMod.X\n+14  slot\u2081/arg1\n+15  (call %\u2081\u2082 %\u2081\u2083 %\u2081\u2084)\n+16  JuliaLowering.Base\n+17  (call top.getproperty %\u2081\u2086 :unsafe_convert)\n+18  TestMod.Y\n+19  slot\u2082/arg2\n+20  (call %\u2081\u2087 %\u2081\u2088 %\u2081\u2089)\n+21  slot\u2081/arg1\n+22  slot\u2082/arg2\n+23  (foreigncall :foo (static_eval TestMod.R) (static_eval (call core.svec TestMod.X TestMod.Y)) 0 :($(QuoteNode((:ccall, 0x0000, false)))) %\u2081\u2085 %\u2082\u2080 %\u2082\u2081 %\u2082\u2082)\n+24  (return %\u2082\u2083)\n+\n+########################################\n+# @ccall lowering with gc_safe\n+@ccall foo(x::X; y::Y)::R gc_safe=true\n+#---------------------\n+1   JuliaLowering.Base\n+2   (call top.getproperty %\u2081 :cconvert)\n+3   TestMod.X\n+4   TestMod.x\n+5   (= slot\u2081/arg1 (call %\u2082 %\u2083 %\u2084))\n+6   JuliaLowering.Base\n+7   (call top.getproperty %\u2086 :cconvert)\n+8   TestMod.Y\n+9   TestMod.y\n+10  (= slot\u2082/arg2 (call %\u2087 %\u2088 %\u2089))\n+11  JuliaLowering.Base\n+12  (call top.getproperty %\u2081\u2081 :unsafe_convert)\n+13  TestMod.X\n+14  slot\u2081/arg1\n+15  (call %\u2081\u2082 %\u2081\u2083 %\u2081\u2084)\n+16  JuliaLowering.Base\n+17  (call top.getproperty %\u2081\u2086 :unsafe_convert)\n+18  TestMod.Y\n+19  slot\u2082/arg2\n+20  (call %\u2081\u2087 %\u2081\u2088 %\u2081\u2089)\n+21  slot\u2081/arg1\n+22  slot\u2082/arg2\n+23  (foreigncall :foo (static_eval TestMod.R) (static_eval (call core.svec TestMod.X TestMod.Y)) 1 :($(QuoteNode((:ccall, 0x0000, true)))) %\u2081\u2085 %\u2082\u2080 %\u2082\u2081 %\u2082\u2082)\n+24  (return %\u2082\u2083)\n+\n+########################################\n+# non-macro ccall with vararg in signature, but none provided\n+ccall(:fcntl, Cint, (RawFD, Cint, Cint...), s, F_GETFL)\n+#---------------------\n+1   TestMod.RawFD\n+2   TestMod.Cint\n+3   TestMod.s\n+4   (call top.cconvert %\u2081 %\u2083)\n+5   TestMod.F_GETFL\n+6   (call top.cconvert %\u2082 %\u2085)\n+7   (call top.unsafe_convert %\u2081 %\u2084)\n+8   (call top.unsafe_convert %\u2082 %\u2086)\n+9   (foreigncall :fcntl (static_eval TestMod.Cint) (static_eval (call core.svec TestMod.RawFD TestMod.Cint)) 2 :ccall %\u2087 %\u2088 %\u2084 %\u2086)\n+10  (return %\u2089)\n+\n+########################################\n+# Error: No return annotation on @ccall\n+@ccall strlen(\"foo\"::Cstring)\n+#---------------------\n+MacroExpansionError while expanding @ccall in module Main.TestMod:\n+@ccall strlen(\"foo\"::Cstring)\n+#                            \u2514 \u2500\u2500 Expected a return type annotation `::SomeType`\n+\n+########################################\n+# Error: No argument type on @ccall\n+@ccall foo(\"blah\"::Cstring, \"bad\")::Int\n+#---------------------\n+MacroExpansionError while expanding @ccall in module Main.TestMod:\n+@ccall foo(\"blah\"::Cstring, \"bad\")::Int\n+#                           \u2514\u2500\u2500\u2500\u2518 \u2500\u2500 argument needs a type annotation\n+\n+########################################\n+# Error: @ccall varags without one fixed argument\n+@ccall foo(; x::Int)::Int\n+#---------------------\n+MacroExpansionError while expanding @ccall in module Main.TestMod:\n+@ccall foo(; x::Int)::Int\n+#          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 C ABI prohibits varargs without one required argument\n+\n+########################################\n+# Error: Multiple varargs blocks\n+@ccall foo(; x::Int; y::Float64)::Int\n+#---------------------\n+MacroExpansionError while expanding @ccall in module Main.TestMod:\n+@ccall foo(; x::Int; y::Float64)::Int\n+#                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Multiple parameter blocks not allowed\n+\n+########################################\n+# Error: Bad @ccall option\n+@ccall foo(x::Int)::Int bad_opt\n+#---------------------\n+MacroExpansionError while expanding @ccall in module Main.TestMod:\n+@ccall foo(x::Int)::Int bad_opt\n+#                       \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Bad option to ccall\n+\n+########################################\n+# Error: Unknown @ccall option name\n+@ccall foo(x::Int)::Int bad_opt=true\n+#---------------------\n+MacroExpansionError while expanding @ccall in module Main.TestMod:\n+@ccall foo(x::Int)::Int bad_opt=true\n+#                       \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Unknown option name for ccall\n+\n+########################################\n+# Error: Unknown option type\n+@ccall foo(x::Int)::Int gc_safe=\"hi\"\n+#---------------------\n+MacroExpansionError while expanding @ccall in module Main.TestMod:\n+@ccall foo(x::Int)::Int gc_safe=\"hi\"\n+#                               \u2514\u2500\u2500\u2518 \u2500\u2500 gc_safe must be true or false\n+\n+########################################\n+# Error: unary & syntax\n+&x\n+#---------------------\n+LoweringError:\n+&x\n+\u2514\u2518 \u2500\u2500 invalid syntax\n+\n+########################################\n+# Error: $ outside quote/string\n+$x\n+#---------------------\n+LoweringError:\n+$x\n+\u2514\u2518 \u2500\u2500 `$` expression outside string or quote block\n+\n+########################################\n+# Error: splat outside call\n+x...\n+#---------------------\n+LoweringError:\n+x...\n+\u2514\u2500\u2500\u2518 \u2500\u2500 `...` expression outside call\n+\n+########################################\n+# `include` should increment world age\n+include(\"hi.jl\")\n+#---------------------\n+1   TestMod.include\n+2   (call %\u2081 \"hi.jl\")\n+3   latestworld\n+4   (return %\u2082)\n+\n+########################################\n+# Const function assignment syntax (legacy)\n+const f(x::Int)::Int = x+1\n+#---------------------\n+1   TestMod.f\n+2   TestMod.x\n+3   TestMod.Int\n+4   (call core.typeassert %\u2082 %\u2083)\n+5   (call %\u2081 %\u2084)\n+6   TestMod.Int\n+7   (call core.typeassert %\u2085 %\u2086)\n+8   (return %\u2087)\n+\n+########################################\n+# Error: Destructuring assignment method definitions (broken, legacy)\n+f(x)::Int, g() = [1.0, 2.0]\n+#---------------------\n+LoweringError:\n+f(x)::Int, g() = [1.0, 2.0]\n+\u2514\u2500\u2500\u2518 \u2500\u2500 invalid assignment location\n+\n+########################################\n+# Error: Destructuring assignment typedef, variable, and function (broken, legacy)\n+T{U}, (x::Float64, g()) = [Bool, (1, 2)]\n+#---------------------\n+LoweringError:\n+T{U}, (x::Float64, g()) = [Bool, (1, 2)]\n+#                  \u2514\u2500\u2518 \u2500\u2500 invalid assignment location"
    },
    {
      "sha": "a68c5f8a8b6e2660be2f90de23163ba4b6826d9d",
      "filename": "JuliaLowering/test/modules.jl",
      "status": "added",
      "additions": 54,
      "deletions": 0,
      "changes": 54,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fmodules.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fmodules.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmodules.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,54 @@\n+@testset \"modules\" begin\n+\n+test_mod = Module()\n+\n+A = JuliaLowering.include_string(test_mod, \"\"\"\n+module A\n+    function g()\n+        return \"hi\"\n+    end\n+end\n+\"\"\", \"module_test\")\n+@test A isa Module\n+@test A.g() == \"hi\"\n+@test A.include isa Base.IncludeInto\n+@test A.eval isa Core.EvalInto\n+@test A.Base === Base\n+@test A.eval(:(x = -2)) == -2\n+@test A.x == -2\n+\n+B = JuliaLowering.include_string(test_mod, \"\"\"\n+baremodule B\n+end\n+\"\"\", \"baremodule_test\")\n+@test B.Core === Core\n+@test !isdefined(B, :include)\n+@test !isdefined(B, :eval)\n+@test !isdefined(B, :Base)\n+\n+# Module init order\n+Amod = JuliaLowering.include_string(test_mod, \"\"\"\n+module A\n+    init_order = []\n+    __init__() = push!(init_order, \"A\")\n+    module B\n+        using ..A\n+        __init__() = push!(A.init_order, \"B\")\n+    end\n+    module C\n+        using ..A\n+        __init__() = push!(A.init_order, \"C\")\n+        module D\n+            using ...A\n+            __init__() = push!(A.init_order, \"D\")\n+        end\n+        module E\n+            using ...A\n+            __init__() = push!(A.init_order, \"E\")\n+        end\n+    end\n+end\n+\"\"\")\n+@test Amod.init_order == [\"B\", \"D\", \"E\", \"C\", \"A\"]\n+\n+end"
    },
    {
      "sha": "93ace74e948f29a930187e84c32eef3c9ff7cf01",
      "filename": "JuliaLowering/test/quoting.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fquoting.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fquoting.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fquoting.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "ccc61be3cf796e08751fd54fbd9eb22754a06269",
      "filename": "JuliaLowering/test/quoting_ir.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fquoting_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fquoting_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fquoting_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "cf85717c03cbf58f4603ee9e06bef0d9bb3ba2c7",
      "filename": "JuliaLowering/test/repl_mode.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Frepl_mode.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Frepl_mode.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Frepl_mode.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "7451ecb5c179f9e50be975796bda92d9581f9256",
      "filename": "JuliaLowering/test/runtests.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fruntests.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "84efaa15bffb751964252784c48bd7a48e152400",
      "filename": "JuliaLowering/test/runtests_vendored.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fruntests_vendored.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fruntests_vendored.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fruntests_vendored.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "e327343eb03e6c51a2079ba34afb24edfcfb9069",
      "filename": "JuliaLowering/test/scopes.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fscopes.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fscopes.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fscopes.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "fc00174f144ffdbc33c512979d7d90f07cb9534b",
      "filename": "JuliaLowering/test/scopes_ir.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fscopes_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fscopes_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fscopes_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "60fd10dde0c20ad3259d65dc149eb1e759de93a4",
      "filename": "JuliaLowering/test/syntax_graph.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fsyntax_graph.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "f995d0ed1c9b56ad5b39f74611487e201ffdcdba",
      "filename": "JuliaLowering/test/typedefs.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Ftypedefs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Ftypedefs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Ftypedefs.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "280f2719d6d6c8bcaa3738c46ddddf5213c3b489",
      "filename": "JuliaLowering/test/typedefs_ir.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Ftypedefs_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Ftypedefs_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Ftypedefs_ir.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "16f2f30294ffe1b7379218861218d055809dcc8a",
      "filename": "JuliaLowering/test/utils.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Futils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaLowering%2Ftest%2Futils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Futils.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "8a934c09e33c3bfdf00d742da4ea0bd8dcd85a22",
      "filename": "JuliaSyntax/.gitignore",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2F.gitignore",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2F.gitignore",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2F.gitignore?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "a16a55c644b31260d4bc8fe9e65e5963b5db4581",
      "filename": "JuliaSyntax/.mailmap",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2F.mailmap",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2F.mailmap",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2F.mailmap?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "7efd19088a06fb77f44bcabcd77cbafe090d94d7",
      "filename": "JuliaSyntax/LICENSE.md",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2FLICENSE.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2FLICENSE.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2FLICENSE.md?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "6ab84fdfb47331a4c2621f3e0c85c2dbf9843370",
      "filename": "JuliaSyntax/Project.toml",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2FProject.toml?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "ae9b2b9760b36c86d5330d3787444ef23e68c7c7",
      "filename": "JuliaSyntax/README.md",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2FREADME.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2FREADME.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2FREADME.md?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "ce4d6bed870e82004d96738effce0320b1450736",
      "filename": "JuliaSyntax/docs/Manifest.toml",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2FManifest.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2FManifest.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fdocs%2FManifest.toml?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "1814eb3304f3c73d1a6324d0f51c5beefe61467e",
      "filename": "JuliaSyntax/docs/Project.toml",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fdocs%2FProject.toml?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "5c3a094ba86911fcdcf3cfd6b567a6e3da1441bd",
      "filename": "JuliaSyntax/docs/make.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fmake.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fmake.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fdocs%2Fmake.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "5dfbec6e4fcc36b8ab723e3014038f883496580c",
      "filename": "JuliaSyntax/docs/src/api.md",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fsrc%2Fapi.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fsrc%2Fapi.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fdocs%2Fsrc%2Fapi.md?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "a11d1b64140eda9156c77418c4754e14faaa94bc",
      "filename": "JuliaSyntax/docs/src/design.md",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fsrc%2Fdesign.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fsrc%2Fdesign.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fdocs%2Fsrc%2Fdesign.md?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "c8bd0503591d5683ea3133f39d494112325aafe4",
      "filename": "JuliaSyntax/docs/src/howto.md",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fsrc%2Fhowto.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fsrc%2Fhowto.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fdocs%2Fsrc%2Fhowto.md?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "79b8d83b62e6acc948a0fa2f4f1c0009a78b26a5",
      "filename": "JuliaSyntax/docs/src/index.md",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fsrc%2Findex.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fsrc%2Findex.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fdocs%2Fsrc%2Findex.md?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "086bc57ad822447c620f730dd6ae928e5973e1ad",
      "filename": "JuliaSyntax/docs/src/reference.md",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fsrc%2Freference.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fdocs%2Fsrc%2Freference.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fdocs%2Fsrc%2Freference.md?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "06a408a26860a8d58fbaefdaa2446223b441e6dd",
      "filename": "JuliaSyntax/prototypes/simple_parser.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fprototypes%2Fsimple_parser.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fprototypes%2Fsimple_parser.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fprototypes%2Fsimple_parser.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "eddf6748bd423a4ff6888c1ce9cd1043cff1e30d",
      "filename": "JuliaSyntax/prototypes/syntax_interpolation.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fprototypes%2Fsyntax_interpolation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fprototypes%2Fsyntax_interpolation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fprototypes%2Fsyntax_interpolation.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "da5861c0d5b62925d08b90a5e79e07cd6d471a16",
      "filename": "JuliaSyntax/src/JuliaSyntax.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2FJuliaSyntax.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2FJuliaSyntax.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2FJuliaSyntax.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "39fa473fed2f9e1b52d0f87b6cfe554e0df07abe",
      "filename": "JuliaSyntax/src/core/diagnostics.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fcore%2Fdiagnostics.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fcore%2Fdiagnostics.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fcore%2Fdiagnostics.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "7bcd5745b8a486ab9159cddaf6fd04e99b683424",
      "filename": "JuliaSyntax/src/core/parse_stream.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fcore%2Fparse_stream.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fcore%2Fparse_stream.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fcore%2Fparse_stream.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "87019aa81e594033801d05d991a93dc9a9800c59",
      "filename": "JuliaSyntax/src/core/source_files.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fcore%2Fsource_files.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fcore%2Fsource_files.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fcore%2Fsource_files.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "75a5c0e44008f0fe30d41b5e7a6e45ab59178e36",
      "filename": "JuliaSyntax/src/core/tree_cursors.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fcore%2Ftree_cursors.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fcore%2Ftree_cursors.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fcore%2Ftree_cursors.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "53de5f55f0ee4f1203fbbe697322675c4510659e",
      "filename": "JuliaSyntax/src/integration/expr.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "2d1e4df852c18dfac353a4d00d46a8e72fb293ec",
      "filename": "JuliaSyntax/src/integration/hooks.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fintegration%2Fhooks.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fintegration%2Fhooks.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fintegration%2Fhooks.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "87ad038699a7773d0bfd71c4d3b7bd5f512e12e5",
      "filename": "JuliaSyntax/src/julia/julia_parse_stream.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Fjulia_parse_stream.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Fjulia_parse_stream.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fjulia_parse_stream.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "dd25663b14ef34e46b3c091267af0d15978471ec",
      "filename": "JuliaSyntax/src/julia/kinds.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "5a087eac6d54e8f37ee0a647b0ed22371ecc019f",
      "filename": "JuliaSyntax/src/julia/literal_parsing.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Fliteral_parsing.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Fliteral_parsing.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fliteral_parsing.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "4142a010bb6b92b7525eaf27bc426ebc92db13c5",
      "filename": "JuliaSyntax/src/julia/parser.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Fparser.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Fparser.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fparser.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "a3e2162bc985b7268dc50260f83e5bf0a42c63c5",
      "filename": "JuliaSyntax/src/julia/parser_api.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Fparser_api.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Fparser_api.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fparser_api.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "2bd0f56df1b841ff114ea85b9aaadc716c5c7328",
      "filename": "JuliaSyntax/src/julia/tokenize.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Ftokenize.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fjulia%2Ftokenize.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Ftokenize.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "7838ff733c0bf687e0ecddbad4989e1bea446203",
      "filename": "JuliaSyntax/src/porcelain/green_node.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fporcelain%2Fgreen_node.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fporcelain%2Fgreen_node.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fporcelain%2Fgreen_node.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "ad08b25e6a1dfb5e864cf2070ef90ba4a104f899",
      "filename": "JuliaSyntax/src/porcelain/syntax_tree.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_tree.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_tree.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_tree.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "9fb71c74d7132b8dbe0c2e14b033f7591f552d6f",
      "filename": "JuliaSyntax/src/precompile.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fprecompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Fprecompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fprecompile.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "c21c251eb688a1d771f82c9b36e49a266064e606",
      "filename": "JuliaSyntax/src/utils.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Futils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsrc%2Futils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Futils.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "344cdc510a3715c69e370752cefca01b57ac1d50",
      "filename": "JuliaSyntax/sysimage/.gitignore",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2F.gitignore",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2F.gitignore",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsysimage%2F.gitignore?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "7e31a0dd5bc26c3ed2dd1e2225ff412e252f15ce",
      "filename": "JuliaSyntax/sysimage/JuliaSyntaxCore/Project.toml",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2FJuliaSyntaxCore%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2FJuliaSyntaxCore%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsysimage%2FJuliaSyntaxCore%2FProject.toml?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "d1804b89053b79b7106aa78126bd67b8b3637165",
      "filename": "JuliaSyntax/sysimage/JuliaSyntaxCore/src/JuliaSyntaxCore.jl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2FJuliaSyntaxCore%2Fsrc%2FJuliaSyntaxCore.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2FJuliaSyntaxCore%2Fsrc%2FJuliaSyntaxCore.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsysimage%2FJuliaSyntaxCore%2Fsrc%2FJuliaSyntaxCore.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958"
    },
    {
      "sha": "390901eb56cd101a785380bc10ff1785d5f43ea5",
      "filename": "JuliaSyntax/sysimage/compile.jl",
      "status": "added",
      "additions": 47,
      "deletions": 0,
      "changes": 47,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2Fcompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2Fcompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsysimage%2Fcompile.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,47 @@\n+#!/bin/bash\n+#=\n+[[ $1 == +* ]] && juliaup_arg=$1 && shift # release channel for juliaup\n+exec julia ${juliaup_arg} --startup-file=no -e 'include(popfirst!(ARGS))' \"$0\" \"$@\"\n+=#\n+\n+imgs_base_path = joinpath(first(DEPOT_PATH), \"sysimages\", \"v$VERSION\")\n+mkpath(imgs_base_path)\n+\n+using Libdl\n+\n+cd(@__DIR__)\n+\n+# Create a copy of JuliaSyntax so we can change the project UUID.\n+# This allows us to use an older version of JuliaSyntax for developing\n+# JuliaSyntax itself.\n+rm(\"JuliaSyntax\", force=true, recursive=true)\n+mkdir(\"JuliaSyntax\")\n+cp(\"../src\", \"JuliaSyntax/src\")\n+cp(\"../test\", \"JuliaSyntax/test\")\n+projstr = replace(read(\"../Project.toml\", String),\n+    \"70703baa-626e-46a2-a12c-08ffd08c73b4\"=>\"54354a4c-6cac-4c00-8566-e7c1beb8bfd8\")\n+write(\"JuliaSyntax/Project.toml\", projstr)\n+\n+using Pkg\n+rm(\"Project.toml\", force=true)\n+rm(\"Manifest.toml\", force=true)\n+Pkg.activate(\".\")\n+Pkg.develop(path=\"./JuliaSyntax\")\n+Pkg.develop(path=\"./JuliaSyntaxCore\")\n+Pkg.add(\"PackageCompiler\")\n+\n+image_path = joinpath(imgs_base_path, \"juliasyntax_sysimage.\"*Libdl.dlext)\n+\n+using PackageCompiler\n+PackageCompiler.create_sysimage(\n+    [\"JuliaSyntaxCore\"],\n+    project=\".\",\n+    sysimage_path=image_path,\n+    precompile_execution_file=\"precompile_exec.jl\",\n+    incremental=true,\n+)\n+\n+@info \"\"\"## System image compiled!\n+\n+      Use it with `julia -J \"$image_path\"`\n+      \"\"\""
    },
    {
      "sha": "a1ae9555f33a22e947d1742b36e00b67d67ae3ff",
      "filename": "JuliaSyntax/sysimage/precompile.jl",
      "status": "added",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2Fprecompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2Fprecompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsysimage%2Fprecompile.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,6 @@\n+function precompile_JuliaSyntax(mod, juliasyntax_path)\n+    Base.include(mod, joinpath(juliasyntax_path, \"test\", \"test_utils.jl\"))\n+    Base.include(mod, joinpath(juliasyntax_path, \"test\", \"parser.jl\"))\n+    JuliaSyntax.enable_in_core!()\n+    Meta.parse(\"x+y+z-w .+ [a b c]\")\n+end"
    },
    {
      "sha": "99c80693412752d446873d4999aadedc11219bcc",
      "filename": "JuliaSyntax/sysimage/precompile_exec.jl",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2Fprecompile_exec.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Fsysimage%2Fprecompile_exec.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsysimage%2Fprecompile_exec.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,3 @@\n+import JuliaSyntax\n+include(\"precompile.jl\")\n+precompile_JuliaSyntax(@__MODULE__(), pkgdir(JuliaSyntax))"
    },
    {
      "sha": "0a4e260e485e966990672d961d5a6ffb0cac7c6d",
      "filename": "JuliaSyntax/test/benchmark.jl",
      "status": "added",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fbenchmark.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fbenchmark.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fbenchmark.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,35 @@\n+using BenchmarkTools\n+using JuliaSyntax\n+\n+include(\"test_utils.jl\")\n+\n+function concat_base()\n+    basedir = joinpath(Sys.BINDIR, \"..\", \"share\", \"julia\", \"base\")\n+    io = IOBuffer()\n+    for f in find_source_in_path(basedir)\n+        write(io, read(f, String))\n+        println(io)\n+    end\n+    return String(take!(io))\n+end\n+\n+all_base_code = concat_base()\n+\n+b_ParseStream = @benchmark JuliaSyntax.parse!(JuliaSyntax.ParseStream(all_base_code), rule=:all)\n+b_GreenNode   = @benchmark JuliaSyntax.parseall(JuliaSyntax.GreenNode, all_base_code, ignore_warnings=true)\n+b_SyntaxNode  = @benchmark JuliaSyntax.parseall(JuliaSyntax.SyntaxNode, all_base_code, ignore_warnings=true)\n+b_Expr        = @benchmark JuliaSyntax.parseall(Expr, all_base_code, ignore_warnings=true)\n+b_flisp       = @benchmark JuliaSyntax.fl_parseall(all_base_code)\n+\n+@info \"Benchmarks\" ParseStream=b_ParseStream GreenNode=b_GreenNode SyntaxNode=b_SyntaxNode Expr=b_Expr flisp=b_flisp\n+\n+\n+# Allocation profiling\n+#\n+# using Profile.Allocs\n+# using PProf\n+# Allocs.clear()\n+# stream = JuliaSyntax.ParseStream(text);\n+# JuliaSyntax.peek(stream);\n+# Allocs.@profile sample_rate=1 JuliaSyntax.parsestmt(stream)\n+# PProf.Allocs.pprof()"
    },
    {
      "sha": "151aad919c0ed3b530a0fe74437a8a61a393589c",
      "filename": "JuliaSyntax/test/diagnostics.jl",
      "status": "added",
      "additions": 251,
      "deletions": 0,
      "changes": 251,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fdiagnostics.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fdiagnostics.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fdiagnostics.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,251 @@\n+function diagnostic(str; only_first=false, allow_multiple=false, rule=:all, version=v\"1.6\")\n+    stream = ParseStream(str; version=version)\n+    parse!(stream, rule=rule)\n+    if allow_multiple\n+        stream.diagnostics\n+    else\n+        if !only_first\n+            @test length(stream.diagnostics) == 1\n+        end\n+        return isempty(stream.diagnostics) ? nothing : stream.diagnostics[1]\n+    end\n+end\n+\n+@testset \"token errors\" begin\n+    @test diagnostic(\"a\\xf5b\") == Diagnostic(2, 2, :error, \"invalid UTF-8 sequence \\\"\\\\xf5\\\"\")\n+    @test diagnostic(\"# a\\xf5b\") == Diagnostic(1, 5, :error, \"invalid UTF-8 sequence \\\"# a\\\\xf5b\\\"\")\n+    for c in ['\\u00ad', '\\u200b', '\\u200c', '\\u200d',\n+              '\\u200e', '\\u200f', '\\u2060', '\\u2061']\n+        @test diagnostic(\"a$(c)b\") ==\n+            Diagnostic(2, 1+sizeof(string(c)), :error, \"invisible character $(repr(c))\")\n+    end\n+    @test diagnostic(\"\u2081\") == Diagnostic(1, 3, :error, \"identifier cannot begin with character '\u2081'\")\n+    @test diagnostic(\":\u297b\") == Diagnostic(2, 4, :error, \"unknown unicode character '\u297b'\")\n+\n+    @test diagnostic(\"\\\"X \\u202a X\\\"\") == Diagnostic(2, 8, :error, \"unbalanced bidirectional unicode formatting \\\"X \\\\u202a X\\\"\")\n+    @test diagnostic(\"#= \\u202a =#\") == Diagnostic(1, 9, :error, \"unbalanced bidirectional unicode formatting \\\"#= \\\\u202a =#\\\"\")\n+    @test diagnostic(\"\\\"X \\u202a \\$xx\\u202c\\\"\", allow_multiple=true) == [\n+        Diagnostic(2, 7, :error, \"unbalanced bidirectional unicode formatting \\\"X \\\\u202a \\\"\")\n+        Diagnostic(11, 13, :error, \"unbalanced bidirectional unicode formatting \\\"\\\\u202c\\\"\")\n+    ]\n+\n+    @test diagnostic(\"0x\") == Diagnostic(1, 2, :error, \"invalid numeric constant\")\n+    @test diagnostic(\"0x0.1\") == Diagnostic(1, 5, :error, \"hex float literal must contain `p` or `P`\")\n+end\n+\n+@testset \"parser errors\" begin\n+    @test diagnostic(\"+ #==# (a,b)\") ==\n+        Diagnostic(2, 7, :error, \"whitespace not allowed between prefix function call and argument list\")\n+    @test diagnostic(\"1 -+ (a=1, b=2)\") ==\n+        Diagnostic(5, 5, :error, \"whitespace not allowed between prefix function call and argument list\")\n+    @test diagnostic(\"\\n+ (x, y)\") ==\n+        Diagnostic(3, 3, :error, \"whitespace not allowed between prefix function call and argument list\")\n+\n+    @test diagnostic(\"function (\\$f) body end\") ==\n+        Diagnostic(10, 13, :error, \"Ambiguous signature. Add a trailing comma if this is a 1-argument anonymous function; remove parentheses if this is a macro call acting as function signature.\")\n+\n+    @test diagnostic(\"A.@B.x\", only_first=true) ==\n+        Diagnostic(3, 4, :error, \"`@` must appear on first or last macro name component\")\n+    @test diagnostic(\"@M.(x)\") ==\n+        Diagnostic(1, 3, :error, \"dot call syntax not supported for macros\")\n+\n+    @test diagnostic(\"try x end\") ==\n+        Diagnostic(1, 9, :error, \"try without catch or finally\")\n+    # TODO: better range\n+    @test diagnostic(\"@A.\\$x a\") ==\n+        Diagnostic(4, 5, :error, \"invalid macro name\")\n+\n+    @test diagnostic(\"a, , b\") ==\n+        Diagnostic(4, 4, :error, \"unexpected `,`\")\n+    @test diagnostic(\")\", allow_multiple=true) == [\n+        Diagnostic(1, 1, :error, \"unexpected `)`\")\n+        Diagnostic(1, 1, :error, \"extra tokens after end of expression\")\n+    ]\n+\n+    @test diagnostic(\"if\\nfalse\\nend\") ==\n+        Diagnostic(3, 3, :error, \"missing condition in `if`\")\n+    @test diagnostic(\"if false\\nelseif\\nend\") ==\n+        Diagnostic(16, 16, :error, \"missing condition in `elseif`\")\n+\n+    @test diagnostic(\"f(x::V) where {V) = x\", allow_multiple=true) == [\n+        Diagnostic(17, 16, :error, \"Expected `}` or `,`\")\n+        Diagnostic(17, 21, :error, \"extra tokens after end of expression\")\n+    ]\n+    @test diagnostic(\"[1)\", allow_multiple=true) == [\n+        Diagnostic(3, 2, :error, \"Expected `]` or `,`\")\n+        Diagnostic(3, 3, :error, \"extra tokens after end of expression\")\n+    ]\n+    @test diagnostic(\"f(x, y #=hi=#\\ng(z)\") == Diagnostic(7, 6, :error, \"Expected `)` or `,`\")\n+    @test diagnostic(\"(x, y \\nz\") == Diagnostic(6, 5, :error, \"Expected `)` or `,`\")\n+    @test diagnostic(\"function f(x, y \\nz end\") == Diagnostic(16, 15, :error, \"Expected `)` or `,`\")\n+\n+    @test diagnostic(\"sin. (1)\") ==\n+        Diagnostic(5, 5, :error, \"whitespace is not allowed here\")\n+    @test diagnostic(\"x [i]\") ==\n+        Diagnostic(2, 2, :error, \"whitespace is not allowed here\")\n+    @test diagnostic(\"\\nf() [i]\") ==\n+        Diagnostic(5, 5, :error, \"whitespace is not allowed here\")\n+    @test diagnostic(\"\\nf() (i)\") ==\n+        Diagnostic(5, 5, :error, \"whitespace is not allowed here\")\n+    @test diagnostic(\"\\nf() .i\") ==\n+        Diagnostic(5, 5, :error, \"whitespace is not allowed here\")\n+    @test diagnostic(\"\\nf() {i}\") ==\n+        Diagnostic(5, 5, :error, \"whitespace is not allowed here\")\n+    @test diagnostic(\"\\n@ m\") ==\n+        Diagnostic(3, 3, :error, \"whitespace is not allowed here\")\n+    @test diagnostic(\"\\nusing a .b\") ==\n+        Diagnostic(9, 9, :error, \"whitespace is not allowed here\")\n+\n+    @test diagnostic(\"const x\") ==\n+        Diagnostic(1, 7, :error, \"expected assignment after `const`\")\n+    @test diagnostic(\"global const x\") ==\n+        Diagnostic(1, 14, :error, \"expected assignment after `const`\")\n+\n+    @test diagnostic(\"(for i=1; println())\") ==\n+        Diagnostic(20, 19, :error, \"Expected `end`\")\n+    @test diagnostic(\"(try i=1; println())\", allow_multiple=true) == [\n+        Diagnostic(2, 19, :error, \"try without catch or finally\")\n+        Diagnostic(20, 19, :error, \"Expected `end`\")\n+    ]\n+\n+    @test diagnostic(\"\\\"\\$(x,y)\\\"\") ==\n+        Diagnostic(3, 7, :error, \"invalid interpolation syntax\")\n+\n+    @test diagnostic(\"\", rule=:statement) ==\n+        Diagnostic(1, 0, :error, \"premature end of input\")\n+    @test diagnostic(\"\", rule=:atom) ==\n+        Diagnostic(1, 0, :error, \"premature end of input\")\n+end\n+\n+@testset \"parser warnings\" begin\n+    @test diagnostic(\"@(A)\", only_first=true) ==\n+        Diagnostic(2, 4, :warning, \"parenthesizing macro names is unnecessary\")\n+    @test diagnostic(\"try finally catch a ; b end\") ==\n+        Diagnostic(13, 23, :warning, \"`catch` after `finally` will execute out of order\")\n+    @test diagnostic(\"import .  .A\") ==\n+        Diagnostic(9, 10, :warning, \"space between dots in import path\")\n+    @test diagnostic(\"import A .==\") ==\n+        Diagnostic(9, 9, :warning, \"space between dots in import path\")\n+    @test diagnostic(\"import A.:+\") ==\n+        Diagnostic(10, 10, :warning, \"quoting with `:` is not required here\")\n+    # No warnings for imports of `:` and parenthesized `(..)`\n+    @test diagnostic(\"import A.:, :\", allow_multiple=true) == []\n+    @test diagnostic(\"import A: (..)\", allow_multiple=true) == []\n+    @test diagnostic(\"import A.(:+)\") ==\n+        Diagnostic(10, 13, :warning, \"parentheses are not required here\")\n+    @test diagnostic(\"export (x)\") ==\n+        Diagnostic(8, 10, :warning, \"parentheses are not required here\")\n+    @test diagnostic(\"import :A\") ==\n+        Diagnostic(8, 9, :error, \"expected identifier\")\n+    @test diagnostic(\"export :x\") ==\n+        Diagnostic(8, 9, :error, \"expected identifier\")\n+    @test diagnostic(\"public = 4\", version=v\"1.11\") ==\n+        diagnostic(\"public[7] = 5\", version=v\"1.11\") ==\n+        diagnostic(\"public() = 6\", version=v\"1.11\") ==\n+        Diagnostic(1, 6, :warning, \"using public as an identifier is deprecated\")\n+end\n+\n+@testset \"diagnostics for literal parsing\" begin\n+    # Float overflow/underflow\n+    @test diagnostic(\"x = 10.0e1000;\") ==\n+        Diagnostic(5, 13, :error, \"overflow in floating point literal\")\n+    @test diagnostic(\"x = 10.0f1000;\") ==\n+        Diagnostic(5, 13, :error, \"overflow in floating point literal\")\n+    @test diagnostic(\"x = 10.0e-1000;\") ==\n+        Diagnostic(5, 14, :warning, \"underflow to zero in floating point literal\")\n+    @test diagnostic(\"x = 10.0f-1000;\") ==\n+        Diagnostic(5, 14, :warning, \"underflow to zero in floating point literal\")\n+    # Underflow boundary\n+    @test diagnostic(\"5e-324\", allow_multiple=true) == []\n+    @test diagnostic(\"2e-324\") ==\n+        Diagnostic(1, 6, :warning, \"underflow to zero in floating point literal\")\n+\n+    # Char\n+    @test diagnostic(\"x = ''\") ==\n+        Diagnostic(6, 5, :error, \"empty character literal\")\n+    @test diagnostic(\"x = 'abc'\") ==\n+        Diagnostic(6, 8, :error, \"character literal contains multiple characters\")\n+    @test diagnostic(\"x = '\\\\xq'\") ==\n+        Diagnostic(6, 7, :error, \"invalid hex escape sequence\")\n+    @test diagnostic(\"x = '\\\\uq'\") ==\n+        Diagnostic(6, 7, :error, \"invalid unicode escape sequence\")\n+    @test diagnostic(\"x = '\\\\Uq'\") ==\n+        Diagnostic(6, 7, :error, \"invalid unicode escape sequence\")\n+    @test diagnostic(\"x = '\\\\777'\") ==\n+        Diagnostic(6, 9, :error, \"invalid octal escape sequence\")\n+    @test diagnostic(\"x = '\\\\k'\") ==\n+        Diagnostic(6, 7, :error, \"invalid escape sequence\")\n+    @test diagnostic(\"'\\\\\", allow_multiple=true) == [\n+        Diagnostic(2, 2, :error, \"invalid escape sequence\"),\n+        Diagnostic(3, 2, :error, \"unterminated character literal\")\n+    ]\n+    # Various cases from Base\n+    @test diagnostic(\"'\\\\xff\\\\xff\\\\xff\\\\xff'\") ==\n+        Diagnostic(2, 17, :error, \"character literal contains multiple characters\")\n+    @test diagnostic(\"'\\\\100\\\\42'\") ==\n+        Diagnostic(2, 8, :error, \"character literal contains multiple characters\")\n+    @test diagnostic(\"'\\\\xff\\\\xff\\\\xff\\\\xff\\\\xff'\") ==\n+        Diagnostic(2, 21, :error, \"character literal contains multiple characters\")\n+    @test diagnostic(\"'abcd'\") ==\n+        Diagnostic(2, 5, :error, \"character literal contains multiple characters\")\n+    @test diagnostic(\"'\\\\uff\\\\xff'\") ==\n+        Diagnostic(2, 9, :error, \"character literal contains multiple characters\")\n+    @test diagnostic(\"'\\\\xffa'\") ==\n+        Diagnostic(2, 6, :error, \"character literal contains multiple characters\")\n+    @test diagnostic(\"'\\\\uffffa'\") ==\n+        Diagnostic(2, 8, :error, \"character literal contains multiple characters\")\n+    @test diagnostic(\"'\\\\U00002014a'\") ==\n+        Diagnostic(2, 12, :error, \"character literal contains multiple characters\")\n+    @test diagnostic(\"'\\\\1000'\") ==\n+        Diagnostic(2, 6, :error, \"character literal contains multiple characters\")\n+\n+    # String\n+    @test diagnostic(\"x = \\\"abc\\\\xq\\\"\") ==\n+        Diagnostic(9, 10, :error, \"invalid hex escape sequence\")\n+    @test diagnostic(\"x = \\\"abc\\\\uq\\\"\") ==\n+        Diagnostic(9, 10, :error, \"invalid unicode escape sequence\")\n+    @test diagnostic(\"x = \\\"abc\\\\Uq\\\"\") ==\n+        Diagnostic(9, 10, :error, \"invalid unicode escape sequence\")\n+    @test diagnostic(\"x = \\\"abc\\\\777\\\"\") ==\n+        Diagnostic(9, 12, :error, \"invalid octal escape sequence\")\n+    @test diagnostic(\"x = \\\"abc\\\\k\\\"\") ==\n+        Diagnostic(9, 10, :error, \"invalid escape sequence\")\n+    @test diagnostic(\"x = \\\"abc\\\\k \\\\k\\\"\", allow_multiple=true) == [\n+        Diagnostic(9, 10, :error, \"invalid escape sequence\"),\n+        Diagnostic(12, 13, :error, \"invalid escape sequence\")\n+    ]\n+    @test diagnostic(\"\\\"\\$x\u0df4  \\\"\") ==\n+        Diagnostic(4, 6, :error, \"interpolated variable ends with invalid character; use `\\$(...)` instead\")\n+end\n+\n+@testset \"diagnostic printing\" begin\n+    stream = JuliaSyntax.ParseStream(\"a -- b -- c\")\n+    JuliaSyntax.parse!(stream)\n+    @test sprint(JuliaSyntax.show_diagnostics, stream) == \"\"\"\n+        # Error @ line 1:3\n+        a -- b -- c\n+        # \u2514\u2518 \u2500\u2500 invalid operator\n+        # Error @ line 1:8\n+        a -- b -- c\n+        #      \u2514\u2518 \u2500\u2500 invalid operator\"\"\"\n+\n+    stream = JuliaSyntax.ParseStream(\"a -- b\")\n+    JuliaSyntax.parse!(stream)\n+    fname = \"test.jl\"\n+    sf = SourceFile(stream, filename=fname)\n+    url = JuliaSyntax._file_url(fname)\n+    @test sprint(JuliaSyntax.show_diagnostics, stream.diagnostics, sf,\n+                 context=:color=>true) == \"\"\"\n+        \\e[90m# Error @ \\e[0;0m\\e]8;;$url#1:3\\e\\\\\\e[90mtest.jl:1:3\\e[0;0m\\e]8;;\\e\\\\\n+        a \\e[48;2;120;70;70m--\\e[0;0m b\n+        \\e[90m# \u2514\u2518 \u2500\u2500 \\e[0;0m\\e[91minvalid operator\\e[0;0m\"\"\"\n+\n+    if Sys.isunix()\n+        tempdirname = mktempdir()\n+        cd(tempdirname) do\n+            rm(tempdirname)\n+            # Test _file_url doesn't fail with nonexistent directories\n+            @test isnothing(JuliaSyntax._file_url(joinpath(\"__nonexistent__\", \"test.jl\")))\n+        end\n+    end\n+end"
    },
    {
      "sha": "d7547848bef09f37d401c68bc5b1658cc9e50e08",
      "filename": "JuliaSyntax/test/expr.jl",
      "status": "added",
      "additions": 843,
      "deletions": 0,
      "changes": 843,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fexpr.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fexpr.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fexpr.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,843 @@\n+@testset \"Expr parsing with $method\" for method in [\"build_tree\", \"SyntaxNode conversion\"]\n+    parseatom, parsestmt, parseall =\n+        if method == \"build_tree\"\n+            ((s; kws...) -> JuliaSyntax.parseatom(Expr, s; kws...),\n+             (s; kws...) -> JuliaSyntax.parsestmt(Expr, s; kws...),\n+             (s; kws...) -> JuliaSyntax.parseall(Expr, s; kws...))\n+        else\n+            ((s; kws...) -> Expr(JuliaSyntax.parseatom(SyntaxNode, s; keep_parens=true, kws...)),\n+             (s; kws...) -> Expr(JuliaSyntax.parsestmt(SyntaxNode, s; keep_parens=true, kws...)),\n+             (s; kws...) -> Expr(JuliaSyntax.parseall(SyntaxNode, s; keep_parens=true, kws...)))\n+        end\n+\n+    @testset \"Quote nodes\" begin\n+        @test parseatom(\":(a)\") == QuoteNode(:a)\n+        @test parseatom(\":(:a)\") == Expr(:quote, QuoteNode(:a))\n+        @test parseatom(\":(1+2)\") == Expr(:quote, Expr(:call, :+, 1, 2))\n+        # Compatibility hack for VERSION >= v\"1.4\"\n+        # https://github.com/JuliaLang/julia/pull/34077\n+        @test parseatom(\":true\") == Expr(:quote, true)\n+    end\n+\n+    @testset \"Line numbers\" begin\n+        @testset \"Blocks\" begin\n+            @test parsestmt(\"begin a\\nb\\n\\nc\\nend\") ==\n+                Expr(:block,\n+                     LineNumberNode(1),\n+                     :a,\n+                     LineNumberNode(2),\n+                     :b,\n+                     LineNumberNode(4),\n+                     :c,\n+                )\n+            @test parsestmt(\"(a;b;c)\") ==\n+                Expr(:block,\n+                     :a,\n+                     LineNumberNode(1),\n+                     :b,\n+                     LineNumberNode(1),\n+                     :c,\n+                )\n+            @test parsestmt(\"begin end\") ==\n+                Expr(:block,\n+                     LineNumberNode(1)\n+                )\n+            @test parsestmt(\"(;;)\") ==\n+                Expr(:block)\n+\n+            @test parseall(\"a\\n\\nb\") ==\n+                Expr(:toplevel,\n+                     LineNumberNode(1),\n+                     :a,\n+                     LineNumberNode(3),\n+                     :b,\n+                )\n+            @test parsestmt(\"a;b\") ==\n+                Expr(:toplevel, :a, :b)\n+\n+            @test parsestmt(\"module A\\n\\nbody\\nend\") ==\n+                Expr(:module,\n+                     true,\n+                     :A,\n+                     Expr(:block,\n+                          LineNumberNode(1),\n+                          LineNumberNode(3),\n+                          :body,\n+                     ),\n+                )\n+\n+            @test parseall(\"a\\n\\nx\") ==\n+                Expr(:toplevel,\n+                    LineNumberNode(1),\n+                    :a,\n+                    LineNumberNode(3),\n+                    :x\n+                )\n+            @test parseall(\"a\\n\\nx;y\") ==\n+                Expr(:toplevel,\n+                    LineNumberNode(1),\n+                    :a,\n+                    LineNumberNode(3),\n+                    Expr(:toplevel, :x, :y)\n+                )\n+        end\n+\n+        @testset \"Function definition lines\" begin\n+            @test parsestmt(\"function f()\\na\\n\\nb\\nend\") ==\n+                Expr(:function,\n+                     Expr(:call, :f),\n+                     Expr(:block,\n+                         LineNumberNode(1),\n+                         LineNumberNode(2),\n+                         :a,\n+                         LineNumberNode(4),\n+                         :b,\n+                     )\n+                )\n+            @test parsestmt(\"f() = 1\") ==\n+                Expr(:(=),\n+                     Expr(:call, :f),\n+                     Expr(:block,\n+                          LineNumberNode(1),\n+                          1\n+                     )\n+                )\n+            @test parsestmt(\"macro f()\\na\\nend\") ==\n+                Expr(:macro,\n+                     Expr(:call, :f),\n+                     Expr(:block,\n+                         LineNumberNode(1),\n+                         LineNumberNode(2),\n+                         :a,\n+                     )\n+                )\n+\n+            # function/macro without methods\n+            @test parsestmt(\"function f end\") ==\n+                Expr(:function, :f)\n+            @test parsestmt(\"macro f end\") ==\n+                Expr(:macro, :f)\n+\n+            # weird cases with extra parens\n+            @test parsestmt(\"function (f() where T) end\") ==\n+                Expr(:function, Expr(:where, Expr(:call, :f), :T),\n+                     Expr(:block, LineNumberNode(1), LineNumberNode(1)))\n+            @test parsestmt(\"function (f()::S) end\") ==\n+                Expr(:function, Expr(:(::), Expr(:call, :f), :S),\n+                     Expr(:block, LineNumberNode(1), LineNumberNode(1)))\n+        end\n+\n+        @testset \"->\" begin\n+            @test parsestmt(\"a -> b\") ==\n+                Expr(:->, :a, Expr(:block, LineNumberNode(1), :b))\n+            @test parsestmt(\"(a,) -> b\") ==\n+                Expr(:->, Expr(:tuple, :a), Expr(:block, LineNumberNode(1), :b))\n+            @test parsestmt(\"(a where T) -> b\") ==\n+                Expr(:->, Expr(:where, :a, :T), Expr(:block, LineNumberNode(1), :b))\n+            # @test parsestmt(\"a -> (\\nb;c)\") ==\n+            #     Expr(:->, :a, Expr(:block, LineNumberNode(1), :b))\n+            @test parsestmt(\"a -> begin\\nb\\nc\\nend\") ==\n+                Expr(:->, :a, Expr(:block,\n+                                   LineNumberNode(1),\n+                                   LineNumberNode(2), :b,\n+                                   LineNumberNode(3), :c))\n+            @test parsestmt(\"(a;b=1) -> c\") ==\n+                Expr(:->,\n+                     Expr(:block, :a, LineNumberNode(1), Expr(:(=), :b, 1)),\n+                     Expr(:block, LineNumberNode(1), :c))\n+            @test parsestmt(\"(a...;b...) -> c\") ==\n+                Expr(:->,\n+                     Expr(:tuple, Expr(:parameters, Expr(:(...), :b)), Expr(:(...), :a)),\n+                     Expr(:block, LineNumberNode(1), :c))\n+            @test parsestmt(\"(;) -> c\") ==\n+                Expr(:->,\n+                     Expr(:tuple, Expr(:parameters)),\n+                     Expr(:block, LineNumberNode(1), :c))\n+            @test parsestmt(\"a::T -> b\") ==\n+                Expr(:->, Expr(:(::), :a, :T), Expr(:block, LineNumberNode(1), :b))\n+        end\n+\n+        @testset \"elseif\" begin\n+            @test parsestmt(\"if a\\nb\\nelseif c\\n d\\nend\") ==\n+                Expr(:if,\n+                     :a,\n+                     Expr(:block,\n+                          LineNumberNode(2),\n+                          :b),\n+                     Expr(:elseif,\n+                          Expr(:block,\n+                               LineNumberNode(3),  # Line number for elseif condition\n+                               :c),\n+                          Expr(:block,\n+                               LineNumberNode(4),\n+                               :d),\n+                     )\n+                )\n+        end\n+\n+        @testset \"No line numbers in let bindings\" begin\n+            @test parsestmt(\"let i=is, j=js\\nbody\\nend\") ==\n+                Expr(:let,\n+                     Expr(:block,\n+                         Expr(:(=), :i, :is),\n+                         Expr(:(=), :j, :js),\n+                     ),\n+                     Expr(:block,\n+                         LineNumberNode(2),\n+                         :body\n+                     )\n+                )\n+        end\n+\n+        @testset \"Loops\" begin\n+            @test parsestmt(\"for x=xs\\n\\nend\") ==\n+                Expr(:for,\n+                     Expr(:(=), :x, :xs),\n+                     Expr(:block,\n+                          LineNumberNode(1),\n+                          LineNumberNode(3)\n+                     )\n+                )\n+            @test parsestmt(\"for x=xs\\ny\\nend\") ==\n+                Expr(:for,\n+                     Expr(:(=), :x, :xs),\n+                     Expr(:block,\n+                          LineNumberNode(2),\n+                          :y,\n+                          LineNumberNode(3)\n+                     )\n+                )\n+            @test parsestmt(\"while cond\\n\\nend\") ==\n+                Expr(:while,\n+                     :cond,\n+                     Expr(:block,\n+                          LineNumberNode(1),\n+                          LineNumberNode(3)\n+                     )\n+                )\n+            @test parsestmt(\"while cond\\ny\\nend\") ==\n+                Expr(:while,\n+                     :cond,\n+                     Expr(:block,\n+                          LineNumberNode(2),\n+                          :y,\n+                          LineNumberNode(3)\n+                     )\n+                )\n+        end\n+    end\n+\n+    @testset \"Short form function line numbers\" begin\n+        # A block is added to hold the line number node\n+        @test parsestmt(\"f() = xs\") ==\n+            Expr(:(=),\n+                 Expr(:call, :f),\n+                 Expr(:block,\n+                      LineNumberNode(1),\n+                      :xs))\n+\n+        @test parsestmt(\"f() =\\n(a;b)\") ==\n+            Expr(:(=),\n+                 Expr(:call, :f),\n+                 Expr(:block,\n+                      LineNumberNode(1),\n+                      :a,\n+                      LineNumberNode(2),\n+                      :b))\n+\n+        @test parsestmt(\"f() =\\nbegin\\na\\nb\\nend\") ==\n+            Expr(:(=),\n+                 Expr(:call, :f),\n+                 Expr(:block,\n+                      LineNumberNode(1),\n+                      LineNumberNode(3),\n+                      :a,\n+                      LineNumberNode(4),\n+                      :b))\n+\n+        @test parsestmt(\"let f(x) =\\ng(x)=1\\nend\") ==\n+            Expr(:let,\n+                 Expr(:(=),\n+                      Expr(:call, :f, :x),\n+                      Expr(:block,\n+                           LineNumberNode(1),\n+                           Expr(:(=),\n+                               Expr(:call, :g, :x),\n+                               Expr(:block,\n+                                    LineNumberNode(2),\n+                                    1)))),\n+                 Expr(:block,\n+                      LineNumberNode(3)))\n+\n+        # `.=` doesn't introduce short form functions\n+        @test parsestmt(\"f() .= xs\") ==\n+            Expr(:(.=), Expr(:call, :f), :xs)\n+    end\n+\n+    @testset \"for\" begin\n+        @test parsestmt(\"for i=is body end\") ==\n+            Expr(:for,\n+                 Expr(:(=), :i, :is),\n+                 Expr(:block,\n+                     LineNumberNode(1),\n+                     :body,\n+                     LineNumberNode(1)\n+                 )\n+            )\n+        @test parsestmt(\"for i=is, j=js\\nbody\\nend\") ==\n+            Expr(:for,\n+                 Expr(:block,\n+                     Expr(:(=), :i, :is),\n+                     Expr(:(=), :j, :js),\n+                 ),\n+                 Expr(:block,\n+                     LineNumberNode(2),\n+                     :body,\n+                     LineNumberNode(3),\n+                 )\n+            )\n+    end\n+\n+    @testset \"Long form anonymous functions\" begin\n+        @test parsestmt(\"function (xs...)\\nbody end\") ==\n+            Expr(:function,\n+                 Expr(:..., :xs),\n+                 Expr(:block,\n+                      LineNumberNode(1),\n+                      LineNumberNode(2),\n+                      :body))\n+    end\n+\n+    @testset \"String conversions\" begin\n+        # String unwrapping / wrapping\n+        @test parsestmt(\"\\\"str\\\"\") == \"str\"\n+        @test parsestmt(\"\\\"\\$(\\\"str\\\")\\\"\") ==\n+            Expr(:string, Expr(:string, \"str\"))\n+        # Concatenation of string chunks in triple quoted cases\n+        @test parsestmt(\"```\\n  a\\n  b```\") ==\n+            Expr(:macrocall, GlobalRef(Core, Symbol(\"@cmd\")), LineNumberNode(1),\n+                 \"a\\nb\")\n+        @test parsestmt(\"\\\"\\\"\\\"\\n  a\\n  \\$x\\n  b\\n  c\\\"\\\"\\\"\") ==\n+            Expr(:string, \"a\\n\", :x, \"\\nb\\nc\")\n+        # Incomplete cases\n+        @test parsestmt(\"`x\", ignore_errors=true) ==\n+            Expr(:macrocall, GlobalRef(Core, Symbol(\"@cmd\")), LineNumberNode(1),\n+                 Expr(:string, \"x\", Expr(:error)))\n+        @test parsestmt(\"`\", ignore_errors=true) ==\n+            Expr(:macrocall, GlobalRef(Core, Symbol(\"@cmd\")), LineNumberNode(1),\n+                 Expr(:string, Expr(:error)))\n+    end\n+\n+    @testset \"Char conversions\" begin\n+        @test parsestmt(\"'a'\") == 'a'\n+        @test parsestmt(\"'\u03b1'\") == '\u03b1'\n+        @test parsestmt(\"'\\\\xce\\\\xb1'\") == '\u03b1'\n+    end\n+\n+    @testset \"do block conversion\" begin\n+        @test parsestmt(\"f(x) do y\\n body end\") ==\n+            Expr(:do,\n+                 Expr(:call, :f, :x),\n+                 Expr(:->, Expr(:tuple, :y),\n+                      Expr(:block,\n+                           LineNumberNode(2),\n+                           :body)))\n+\n+        @test parsestmt(\"@f(x) do y body end\") ==\n+            Expr(:do,\n+                 Expr(:macrocall, Symbol(\"@f\"), LineNumberNode(1), :x),\n+                 Expr(:->, Expr(:tuple, :y),\n+                      Expr(:block,\n+                           LineNumberNode(1),\n+                           :body)))\n+\n+        @test parsestmt(\"f(x; a=1) do y body end\") ==\n+            Expr(:do,\n+                 Expr(:call, :f, Expr(:parameters, Expr(:kw, :a, 1)), :x),\n+                 Expr(:->, Expr(:tuple, :y),\n+                      Expr(:block,\n+                           LineNumberNode(1),\n+                           :body)))\n+\n+        # Test calls with do inside them\n+        @test parsestmt(\"g(f(x) do y\\n body end)\") ==\n+            Expr(:call,\n+                 :g,\n+                 Expr(:do,\n+                      Expr(:call, :f, :x),\n+                      Expr(:->, Expr(:tuple, :y),\n+                           Expr(:block,\n+                                LineNumberNode(2),\n+                                :body))))\n+    end\n+\n+    @testset \"= to Expr(:kw) conversion\" begin\n+        # Call\n+        @test parsestmt(\"f(a=1)\") ==\n+            Expr(:call, :f, Expr(:kw, :a, 1))\n+        @test parsestmt(\"f(; b=2)\") ==\n+            Expr(:call, :f, Expr(:parameters, Expr(:kw, :b, 2)))\n+        @test parsestmt(\"f(a=1; b=2)\") ==\n+            Expr(:call, :f, Expr(:parameters, Expr(:kw, :b, 2)), Expr(:kw, :a, 1))\n+        @test parsestmt(\"f(a; b; c)\") ==\n+            Expr(:call, :f, Expr(:parameters, Expr(:parameters, :c), :b), :a)\n+        @test parsestmt(\"+(a=1,)\") ==\n+            Expr(:call, :+, Expr(:kw, :a, 1))\n+        @test parsestmt(\"(a=1)()\") ==\n+            Expr(:call, Expr(:(=), :a, 1))\n+\n+        # Operator calls:  = is not :kw\n+        @test parsestmt(\"(x=1) != 2\") ==\n+            Expr(:call, :!=, Expr(:(=), :x, 1), 2)\n+        @test parsestmt(\"+(a=1)\") ==\n+            Expr(:call, :+, Expr(:(=), :a, 1))\n+        @test parsestmt(\"(a=1)'\") ==\n+            Expr(Symbol(\"'\"), Expr(:(=), :a, 1))\n+        @test parsestmt(\"(a=1)'\u1d40\") ==\n+            Expr(:call, Symbol(\"'\u1d40\"), Expr(:(=), :a, 1))\n+\n+        # Dotcall\n+        @test parsestmt(\"f.(a=1; b=2)\") ==\n+            Expr(:., :f, Expr(:tuple,\n+                              Expr(:parameters, Expr(:kw, :b, 2)),\n+                              Expr(:kw, :a, 1)))\n+\n+        # Named tuples\n+        @test parsestmt(\"(a=1,)\") ==\n+            Expr(:tuple, Expr(:(=), :a, 1))\n+        @test parsestmt(\"(a=1,; b=2)\") ==\n+            Expr(:tuple, Expr(:parameters, Expr(:kw, :b, 2)), Expr(:(=), :a, 1))\n+        @test parsestmt(\"(a=1,; b=2; c=3)\") ==\n+            Expr(:tuple,\n+                 Expr(:parameters,\n+                      Expr(:parameters, Expr(:kw, :c, 3)),\n+                      Expr(:kw, :b, 2)),\n+                 Expr(:(=), :a, 1))\n+\n+        # ref\n+        @test parsestmt(\"x[i=j]\") ==\n+            Expr(:ref, :x, Expr(:kw, :i, :j))\n+        @test parsestmt(\"(i=j)[x]\") ==\n+            Expr(:ref, Expr(:(=), :i, :j), :x)\n+        @test parsestmt(\"x[a, b; i=j]\") ==\n+            Expr(:ref, :x, Expr(:parameters, Expr(:(=), :i, :j)), :a, :b)\n+        # curly\n+        @test parsestmt(\"(i=j){x}\") ==\n+            Expr(:curly, Expr(:(=), :i, :j), :x)\n+        @test parsestmt(\"x{a, b; i=j}\") ==\n+            Expr(:curly, :x, Expr(:parameters, Expr(:(=), :i, :j)), :a, :b)\n+\n+        # vect\n+        @test parsestmt(\"[a=1,; b=2]\") ==\n+            Expr(:vect,\n+                 Expr(:parameters, Expr(:(=), :b, 2)),\n+                 Expr(:(=), :a, 1))\n+        # braces\n+        @test parsestmt(\"{a=1,; b=2}\") ==\n+            Expr(:braces,\n+                 Expr(:parameters, Expr(:(=), :b, 2)),\n+                 Expr(:(=), :a, 1))\n+\n+        # dotted = is not :kw\n+        @test parsestmt(\"f(a .= 1)\") ==\n+            Expr(:call, :f, Expr(:.=, :a, 1))\n+\n+        # = inside parens in calls and tuples\n+        @test parsestmt(\"f(((a = 1)))\") ==\n+            Expr(:call, :f, Expr(:kw, :a, 1))\n+        @test parsestmt(\"(((a = 1)),)\") ==\n+            Expr(:tuple, Expr(:(=), :a, 1))\n+        @test parsestmt(\"(;((a = 1)),)\") ==\n+            Expr(:tuple, Expr(:parameters, Expr(:kw, :a, 1)))\n+    end\n+\n+    @testset \"Field access syntax\" begin\n+        @test parsestmt(\"a.b\") == Expr(:., :a, QuoteNode(:b))\n+        @test parsestmt(\"a.\\$b\") == Expr(:., :a, QuoteNode(Expr(:$, :b)))\n+        @test parsestmt(\"a.:b\") == Expr(:., :a, QuoteNode(:b))\n+        @test parsestmt(\"a.@b x\") == Expr(:macrocall,\n+                                          Expr(:., :a, QuoteNode(Symbol(\"@b\"))),\n+                                          LineNumberNode(1),\n+                                          :x)\n+    end\n+\n+    @testset \"dotcall / dotted operators\" begin\n+        @test parsestmt(\"f.(x,y)\") == Expr(:., :f, Expr(:tuple, :x, :y))\n+        @test parsestmt(\"f.(x=1)\") == Expr(:., :f, Expr(:tuple, Expr(:kw, :x, 1)))\n+        @test parsestmt(\"f.(a=1; b=2)\") ==\n+            Expr(:., :f, Expr(:tuple, Expr(:parameters, Expr(:kw, :b, 2)), Expr(:kw, :a, 1)))\n+        @test parsestmt(\"(a=1).()\") == Expr(:., Expr(:(=), :a, 1), Expr(:tuple))\n+        @test parsestmt(\"x .+ y\")  == Expr(:call, Symbol(\".+\"), :x, :y)\n+        @test parsestmt(\"(x=1) .+ y\") == Expr(:call, Symbol(\".+\"), Expr(:(=), :x, 1), :y)\n+        @test parsestmt(\"a .< b .< c\") == Expr(:comparison, :a, Symbol(\".<\"),\n+                                                     :b, Symbol(\".<\"), :c)\n+        @test parsestmt(\"a .< (.<) .< c\") == Expr(:comparison, :a, Symbol(\".<\"),\n+                                                        Expr(:., :<), Symbol(\".<\"), :c)\n+        @test parsestmt(\".*(x)\")    == Expr(:call, Symbol(\".*\"), :x)\n+        @test parsestmt(\".+(x)\")    == Expr(:call, Symbol(\".+\"), :x)\n+        @test parsestmt(\".+x\")      == Expr(:call, Symbol(\".+\"), :x)\n+        @test parsestmt(\"(.+)(x)\")  == Expr(:call, Expr(:., :+), :x)\n+        @test parsestmt(\"(.+).(x)\") == Expr(:., Expr(:., :+), Expr(:tuple, :x))\n+\n+        @test parsestmt(\".+\")    == Expr(:., :+)\n+        @test parsestmt(\":.+\")   == QuoteNode(Symbol(\".+\"))\n+        @test parsestmt(\":(.+)\") == Expr(:quote, (Expr(:., :+)))\n+        @test parsestmt(\"quote .+ end\")   == Expr(:quote,\n+                                                        Expr(:block,\n+                                                             LineNumberNode(1),\n+                                                             Expr(:., :+)))\n+        @test parsestmt(\".+{x}\") == Expr(:curly, Symbol(\".+\"), :x)\n+\n+        # Quoted syntactic ops act different when in parens\n+        @test parsestmt(\":.=\")   == QuoteNode(Symbol(\".=\"))\n+        @test parsestmt(\":(.=)\") == QuoteNode(Symbol(\".=\"))\n+\n+        # A few other cases of bare dotted ops\n+        @test parsestmt(\"f(.+)\")   == Expr(:call, :f, Expr(:., :+))\n+        @test parsestmt(\"(a, .+)\") == Expr(:tuple, :a, Expr(:., :+))\n+        @test parsestmt(\"A.:.+\")   == Expr(:., :A, QuoteNode(Symbol(\".+\")))\n+\n+        # Issue #341\n+        @test parsestmt(\"./x\", ignore_errors=true) == Expr(:call, Expr(:error, Expr(:., :/)), :x)\n+    end\n+\n+    @testset \"syntactic update-assignment operators\" begin\n+        @test parsestmt(\"x += y\") == Expr(:(+=), :x, :y)\n+        @test parsestmt(\"x .+= y\") == Expr(:(.+=), :x, :y)\n+        @test parsestmt(\":+=\") == QuoteNode(Symbol(\"+=\"))\n+        @test parsestmt(\":(+=)\") == QuoteNode(Symbol(\"+=\"))\n+        @test parsestmt(\":.+=\") == QuoteNode(Symbol(\".+=\"))\n+        @test parsestmt(\":(.+=)\") == QuoteNode(Symbol(\".+=\"))\n+        @test parsestmt(\"x \\u2212= y\") == Expr(:(-=), :x, :y)\n+    end\n+\n+    @testset \"let\" begin\n+        @test parsestmt(\"let x=1\\n end\") ==\n+            Expr(:let, Expr(:(=), :x, 1),  Expr(:block, LineNumberNode(2)))\n+        @test parsestmt(\"let x=1 ; end\") ==\n+            Expr(:let, Expr(:(=), :x, 1),  Expr(:block, LineNumberNode(1)))\n+        @test parsestmt(\"let x ; end\") ==\n+            Expr(:let, :x, Expr(:block, LineNumberNode(1)))\n+        @test parsestmt(\"let x::1 ; end\") ==\n+            Expr(:let, Expr(:(::), :x, 1), Expr(:block, LineNumberNode(1)))\n+        @test parsestmt(\"let x=1,y=2 end\") ==\n+            Expr(:let, Expr(:block, Expr(:(=), :x, 1), Expr(:(=), :y, 2)), Expr(:block, LineNumberNode(1)))\n+        @test parsestmt(\"let x+=1 ; end\") ==\n+            Expr(:let, Expr(:block, Expr(:+=, :x, 1)), Expr(:block, LineNumberNode(1)))\n+        @test parsestmt(\"let ; end\") ==\n+            Expr(:let, Expr(:block), Expr(:block, LineNumberNode(1)))\n+        @test parsestmt(\"let ; body end\") ==\n+            Expr(:let, Expr(:block), Expr(:block, LineNumberNode(1), :body))\n+        @test parsestmt(\"let\\na\\nb\\nend\") ==\n+            Expr(:let, Expr(:block), Expr(:block, LineNumberNode(2), :a, LineNumberNode(3), :b))\n+    end\n+\n+    @testset \"where\" begin\n+        @test parsestmt(\"A where T\") == Expr(:where, :A, :T)\n+        @test parsestmt(\"A where {T}\") == Expr(:where, :A, :T)\n+        @test parsestmt(\"A where {S, T}\") == Expr(:where, :A, :S, :T)\n+        @test parsestmt(\"A where {X, Y; Z}\") == Expr(:where, :A, Expr(:parameters, :Z), :X, :Y)\n+    end\n+\n+    @testset \"macrocall\" begin\n+        # line numbers\n+        @test parsestmt(\"@m\\n\") == Expr(:macrocall, Symbol(\"@m\"), LineNumberNode(1))\n+        @test parsestmt(\"\\n@m\") == Expr(:macrocall, Symbol(\"@m\"), LineNumberNode(2))\n+        # parameters\n+        @test parsestmt(\"@m(x; a)\") == Expr(:macrocall, Symbol(\"@m\"), LineNumberNode(1),\n+                                              Expr(:parameters, :a), :x)\n+        @test parsestmt(\"@m(a=1; b=2)\") == Expr(:macrocall, Symbol(\"@m\"), LineNumberNode(1),\n+                                                  Expr(:parameters, Expr(:kw, :b, 2)), Expr(:(=), :a, 1))\n+        # @__dot__\n+        @test parsestmt(\"@.\") == Expr(:macrocall, Symbol(\"@__dot__\"), LineNumberNode(1))\n+        @test parsestmt(\"using A: @.\") == Expr(:using, Expr(Symbol(\":\"), Expr(:., :A), Expr(:., Symbol(\"@__dot__\"))))\n+\n+        # var\"\"\n+        @test parsestmt(\"@var\\\"#\\\" a\") == Expr(:macrocall, Symbol(\"@#\"), LineNumberNode(1), :a)\n+        @test parsestmt(\"@var\\\"\\\\\\\"\\\" a\") == Expr(:macrocall, Symbol(\"@\\\"\"), LineNumberNode(1), :a)\n+        @test parsestmt(\"A.@var\\\"#\\\" a\") == Expr(:macrocall, Expr(:., :A, QuoteNode(Symbol(\"@#\"))), LineNumberNode(1), :a)\n+\n+        # Square brackets\n+        @test parsestmt(\"@S[a,b]\") ==\n+            Expr(:macrocall, Symbol(\"@S\"), LineNumberNode(1), Expr(:vect, :a, :b))\n+        @test parsestmt(\"@S[a b]\") ==\n+            Expr(:macrocall, Symbol(\"@S\"), LineNumberNode(1), Expr(:hcat, :a, :b))\n+        @test parsestmt(\"@S[a; b]\") ==\n+            Expr(:macrocall, Symbol(\"@S\"), LineNumberNode(1), Expr(:vcat, :a, :b))\n+        @test parsestmt(\"@S[a ;; b]\", version=v\"1.7\") ==\n+            Expr(:macrocall, Symbol(\"@S\"), LineNumberNode(1), Expr(:ncat, 2, :a, :b))\n+    end\n+\n+    @testset \"var\" begin\n+        @test parsestmt(\"var\\\"x\\\"\") == :x\n+        @test parsestmt(\"var\\\"\\\"\")         == Symbol(\"\")\n+        @test parsestmt(\"var\\\"\\\\\\\"\\\"\")     == Symbol(\"\\\"\")\n+        @test parsestmt(\"var\\\"\\\\\\\\\\\\\\\"\\\"\") == Symbol(\"\\\\\\\"\")\n+        @test parsestmt(\"var\\\"\\\\\\\\x\\\"\")    == Symbol(\"\\\\\\\\x\")\n+        @test parsestmt(\"var\\\"x\\\"+y\")      == Expr(:call, :+, :x, :y)\n+    end\n+\n+    @testset \"vect\" begin\n+        @test parsestmt(\"[x,y ; z]\") == Expr(:vect, Expr(:parameters, :z), :x, :y)\n+    end\n+\n+    @testset \"concatenation\" begin\n+        @test parsestmt(\"[a ;;; b ;;;; c]\", version=v\"1.7\") ==\n+            Expr(:ncat, 4, Expr(:nrow, 3, :a, :b), :c)\n+        @test parsestmt(\"[a b ; c d]\") ==\n+            Expr(:vcat, Expr(:row, :a, :b), Expr(:row, :c, :d))\n+        @test parsestmt(\"[a\\nb]\") == Expr(:vcat, :a, :b)\n+        @test parsestmt(\"[a b]\") == Expr(:hcat, :a, :b)\n+        @test parsestmt(\"[a b ; c d]\") ==\n+            Expr(:vcat, Expr(:row, :a, :b), Expr(:row, :c, :d))\n+\n+        @test parsestmt(\"T[a ;;; b ;;;; c]\", version=v\"1.7\") ==\n+            Expr(:typed_ncat, :T, 4, Expr(:nrow, 3, :a, :b), :c)\n+        @test parsestmt(\"T[a b ; c d]\") ==\n+            Expr(:typed_vcat, :T, Expr(:row, :a, :b), Expr(:row, :c, :d))\n+        @test parsestmt(\"T[a\\nb]\") == Expr(:typed_vcat, :T, :a, :b)\n+        @test parsestmt(\"T[a b]\") == Expr(:typed_hcat, :T, :a, :b)\n+        @test parsestmt(\"T[a b ; c d]\") ==\n+            Expr(:typed_vcat, :T, Expr(:row, :a, :b), Expr(:row, :c, :d))\n+    end\n+\n+    @testset \"generators\" begin\n+        @test parsestmt(\"(x for a in as for b in bs)\") ==\n+            Expr(:flatten, Expr(:generator,\n+                                Expr(:generator, :x, Expr(:(=), :b, :bs)),\n+                                Expr(:(=), :a, :as)))\n+        @test parsestmt(\"(x for a in as, b in bs)\") ==\n+            Expr(:generator, :x, Expr(:(=), :a, :as), Expr(:(=), :b, :bs))\n+        @test parsestmt(\"(x for a in as, b in bs if z)\") ==\n+            Expr(:generator, :x,\n+                 Expr(:filter, :z, Expr(:(=), :a, :as), Expr(:(=), :b, :bs)))\n+        @test parsestmt(\"(x for a in as, b in bs for c in cs, d in ds)\") ==\n+            Expr(:flatten,\n+                Expr(:generator,\n+                     Expr(:generator, :x, Expr(:(=), :c, :cs), Expr(:(=), :d, :ds)),\n+                     Expr(:(=), :a, :as), Expr(:(=), :b, :bs)))\n+        @test parsestmt(\"(x for a in as for b in bs if z)\") ==\n+            Expr(:flatten, Expr(:generator,\n+                                Expr(:generator, :x, Expr(:filter, :z, Expr(:(=), :b, :bs))),\n+                                Expr(:(=), :a, :as)))\n+        @test parsestmt(\"(x for a in as if z for b in bs)\") ==\n+            Expr(:flatten, Expr(:generator,\n+                                Expr(:generator, :x, Expr(:(=), :b, :bs)),\n+                                Expr(:filter, :z, Expr(:(=), :a, :as))))\n+        @test parsestmt(\"[x for a = as for b = bs if cond1 for c = cs if cond2]\" ) ==\n+            Expr(:comprehension,\n+                 Expr(:flatten,\n+                      Expr(:generator,\n+                           Expr(:flatten,\n+                                Expr(:generator,\n+                                     Expr(:generator,\n+                                          :x,\n+                                          Expr(:filter,\n+                                               :cond2,\n+                                               Expr(:(=), :c, :cs))),\n+                                     Expr(:filter,\n+                                          :cond1,\n+                                          Expr(:(=), :b, :bs)))),\n+                           Expr(:(=), :a, :as))))\n+        @test parsestmt(\"[x for a = as if begin cond2 end]\" ) ==\n+            Expr(:comprehension, Expr(:generator, :x,\n+                                      Expr(:filter,\n+                                           Expr(:block, LineNumberNode(1), :cond2),\n+                                           Expr(:(=), :a, :as))))\n+        @test parsestmt(\"(x for a in as if z)\") ==\n+            Expr(:generator, :x, Expr(:filter, :z, Expr(:(=), :a, :as)))\n+    end\n+\n+    @testset \"try\" begin\n+        @test parsestmt(\"try x catch e; y end\") ==\n+            Expr(:try,\n+                 Expr(:block, LineNumberNode(1), :x),\n+                 :e,\n+                 Expr(:block, LineNumberNode(1), :y))\n+        @test parsestmt(\"try x finally y end\") ==\n+            Expr(:try,\n+                 Expr(:block, LineNumberNode(1), :x),\n+                 false,\n+                 false,\n+                 Expr(:block, LineNumberNode(1), :y))\n+        @test parsestmt(\"try x catch e; y finally z end\") ==\n+            Expr(:try,\n+                 Expr(:block, LineNumberNode(1), :x),\n+                 :e,\n+                 Expr(:block, LineNumberNode(1), :y),\n+                 Expr(:block, LineNumberNode(1), :z))\n+        @test parsestmt(\"try x catch e; y else z end\", version=v\"1.8\") ==\n+            Expr(:try,\n+                 Expr(:block, LineNumberNode(1), :x),\n+                 :e,\n+                 Expr(:block, LineNumberNode(1), :y),\n+                 false,\n+                 Expr(:block, LineNumberNode(1), :z))\n+        @test parsestmt(\"try x catch e; y else z finally w end\", version=v\"1.8\") ==\n+            Expr(:try,\n+                 Expr(:block, LineNumberNode(1), :x),\n+                 :e,\n+                 Expr(:block, LineNumberNode(1), :y),\n+                 Expr(:block, LineNumberNode(1), :w),\n+                 Expr(:block, LineNumberNode(1), :z))\n+        # finally before catch\n+        @test parsestmt(\"try x finally y catch e z end\", ignore_warnings=true) ==\n+            Expr(:try,\n+                 Expr(:block, LineNumberNode(1), :x),\n+                 :e,\n+                 Expr(:block, LineNumberNode(1), :z),\n+                 Expr(:block, LineNumberNode(1), :y))\n+        # empty recovery\n+        @test parsestmt(\"try x end\", ignore_errors=true) ==\n+            Expr(:try,\n+                 Expr(:block, LineNumberNode(1), :x),\n+                 false, false,\n+                 Expr(:block, Expr(:error)))\n+    end\n+\n+    @testset \"juxtapose\" begin\n+        @test parsestmt(\"2x\") == Expr(:call, :*, 2, :x)\n+        @test parsestmt(\"(2)(3)x\") == Expr(:call, :*, 2, 3, :x)\n+    end\n+\n+    @testset \"Core.@doc\" begin\n+        @test parsestmt(\"\\\"x\\\" f\") ==\n+            Expr(:macrocall, GlobalRef(Core, Symbol(\"@doc\")), LineNumberNode(1), \"x\", :f)\n+        @test parsestmt(\"\\n\\\"x\\\" f\") ==\n+            Expr(:macrocall, GlobalRef(Core, Symbol(\"@doc\")), LineNumberNode(2), \"x\", :f)\n+    end\n+\n+    @testset \"String and cmd macros\" begin\n+        # Custom string macros\n+        @test parsestmt(\"foo\\\"str\\\"\") ==\n+            Expr(:macrocall, Symbol(\"@foo_str\"), LineNumberNode(1), \"str\")\n+        # Bare @cmd\n+        @test parsestmt(\"\\n`str`\") ==\n+            Expr(:macrocall, GlobalRef(Core, Symbol(\"@cmd\")), LineNumberNode(2), \"str\")\n+        # Custom cmd macros\n+        @test parsestmt(\"foo`str`\") ==\n+            Expr(:macrocall, Symbol(\"@foo_cmd\"), LineNumberNode(1), \"str\")\n+        @test parsestmt(\"foo`str`flag\") ==\n+            Expr(:macrocall, Symbol(\"@foo_cmd\"), LineNumberNode(1), \"str\", \"flag\")\n+        @test parsestmt(\"foo```\\n  a\\n  b```\") ==\n+            Expr(:macrocall, Symbol(\"@foo_cmd\"), LineNumberNode(1), \"a\\nb\")\n+        # Expr conversion distinguishes from explicit calls to a macro of the same name\n+        @test parsestmt(\"@foo_cmd `str`\") ==\n+            Expr(:macrocall, Symbol(\"@foo_cmd\"), LineNumberNode(1),\n+                 Expr(:macrocall, GlobalRef(Core, Symbol(\"@cmd\")), LineNumberNode(1), \"str\"))\n+    end\n+\n+    @testset \"return\" begin\n+        @test parsestmt(\"return x\") == Expr(:return, :x)\n+        @test parsestmt(\"return\")  == Expr(:return, nothing)\n+    end\n+\n+    @testset \"Large integer macros\" begin\n+        @test parsestmt(\"0x00000000000000001\") ==\n+            Expr(:macrocall, GlobalRef(Core, Symbol(\"@uint128_str\")),\n+                 nothing, \"0x00000000000000001\")\n+\n+        @test parsestmt(\"(0x00000000000000001)\") ==\n+            Expr(:macrocall, GlobalRef(Core, Symbol(\"@uint128_str\")),\n+                 nothing, \"0x00000000000000001\")\n+    end\n+\n+    @testset \"struct\" begin\n+        @test parsestmt(\"struct A end\") ==\n+            Expr(:struct, false, :A, Expr(:block, LineNumberNode(1)))\n+        @test parsestmt(\"mutable struct A end\") ==\n+            Expr(:struct, true, :A, Expr(:block, LineNumberNode(1)))\n+\n+        @test parsestmt(\"struct A <: B \\n a::X \\n end\") ==\n+            Expr(:struct, false, Expr(:<:, :A, :B),\n+                 Expr(:block, LineNumberNode(2), Expr(:(::), :a, :X)))\n+        @test parsestmt(\"struct A \\n a \\n b \\n end\") ==\n+            Expr(:struct, false, :A,\n+                 Expr(:block, LineNumberNode(2), :a, LineNumberNode(3), :b))\n+        @test parsestmt(\"struct A const a end\", version=v\"1.8\") ==\n+            Expr(:struct, false, :A, Expr(:block, LineNumberNode(1), Expr(:const, :a)))\n+\n+        @test parsestmt(\"struct A \\n \\\"doc\\\" \\n a end\") ==\n+            Expr(:struct, false, :A, Expr(:block, LineNumberNode(2), \"doc\", :a))\n+    end\n+\n+    @testset \"export\" begin\n+        @test parsestmt(\"export a\") == Expr(:export, :a)\n+        @test parsestmt(\"export @a\") == Expr(:export, Symbol(\"@a\"))\n+        @test parsestmt(\"export @var\\\"'\\\"\") == Expr(:export, Symbol(\"@'\"))\n+        @test parsestmt(\"export a, \\n @b\") == Expr(:export, :a, Symbol(\"@b\"))\n+        @test parsestmt(\"export +, ==\") == Expr(:export, :+, :(==))\n+        @test parsestmt(\"export \\n a\") == Expr(:export, :a)\n+    end\n+\n+    @testset \"global/const/local\" begin\n+        @test parsestmt(\"global x\") == Expr(:global, :x)\n+        @test parsestmt(\"local x\") == Expr(:local, :x)\n+        @test parsestmt(\"global x,y\") == Expr(:global, :x, :y)\n+        @test parsestmt(\"global const x = 1\") == Expr(:const, Expr(:global, Expr(:(=), :x, 1)))\n+        @test parsestmt(\"local const x = 1\") == Expr(:const, Expr(:local, Expr(:(=), :x, 1)))\n+        @test parsestmt(\"const global x = 1\") == Expr(:const, Expr(:global, Expr(:(=), :x, 1)))\n+        @test parsestmt(\"const local x = 1\") == Expr(:const, Expr(:local, Expr(:(=), :x, 1)))\n+        @test parsestmt(\"const x,y = 1,2\") == Expr(:const, Expr(:(=), Expr(:tuple, :x, :y), Expr(:tuple, 1, 2)))\n+        @test parsestmt(\"const x = 1\") == Expr(:const, Expr(:(=), :x, 1))\n+        @test parsestmt(\"global x ~ 1\") == Expr(:global, Expr(:call, :~, :x, 1))\n+        @test parsestmt(\"global x += 1\") == Expr(:global, Expr(:+=, :x, 1))\n+\n+        # Parsing of global/local with\n+        @test parsestmt(\"global (x,y)\") == Expr(:global, :x, :y)\n+        @test parsestmt(\"local (x,y)\") == Expr(:local, :x, :y)\n+    end\n+\n+    @testset \"tuples\" begin\n+        @test parsestmt(\"(;)\")       == Expr(:tuple, Expr(:parameters))\n+        @test parsestmt(\"(; a=1)\")   == Expr(:tuple, Expr(:parameters, Expr(:kw, :a, 1)))\n+        @test parsestmt(\"(; a=1; b=2)\") ==\n+            Expr(:tuple, Expr(:parameters, Expr(:parameters, Expr(:kw, :b, 2)), Expr(:kw, :a, 1)))\n+        @test parsestmt(\"(a; b; c,d)\") ==\n+            Expr(:tuple, Expr(:parameters, Expr(:parameters, :c, :d), :b), :a)\n+    end\n+\n+    @testset \"module\" begin\n+        @test parsestmt(\"module A end\") ==\n+            Expr(:module, true,  :A, Expr(:block, LineNumberNode(1), LineNumberNode(1)))\n+        @test parsestmt(\"baremodule A end\") ==\n+            Expr(:module, false, :A, Expr(:block, LineNumberNode(1), LineNumberNode(1)))\n+    end\n+\n+    @testset \"errors\" begin\n+        @test parsestmt(\"--\", ignore_errors=true) ==\n+            Expr(:error, \"invalid operator: `--`\")\n+        @test parseall(\"a b\", ignore_errors=true) ==\n+            Expr(:toplevel, LineNumberNode(1), :a,\n+                 LineNumberNode(1), Expr(:error, :b))\n+        @test parsestmt(\"(x\", ignore_errors=true) ==\n+            Expr(:block, :x, Expr(:error))\n+        @test parsestmt(\"x do\", ignore_errors=true) ==\n+            Expr(:block, :x, Expr(:error, :do))\n+        @test parsestmt(\"x var\\\"y\\\"\", ignore_errors=true) ==\n+            Expr(:block, :x, Expr(:error, :var, ErrorVal(), \"y\", ErrorVal()))\n+        @test parsestmt(\"var\\\"y\", ignore_errors=true) ==\n+            Expr(:var, :y, Expr(:error))\n+    end\n+\n+    @testset \"import\" begin\n+        @test parsestmt(\"import A\") == Expr(:import, Expr(:., :A))\n+        @test parsestmt(\"import A.(:b).:c: x.:z\", ignore_warnings=true) ==\n+            Expr(:import, Expr(Symbol(\":\"), Expr(:., :A, :b, :c), Expr(:., :x, :z)))\n+        # Stupid parens and quotes in import paths\n+        @test parsestmt(\"import A.:+\", ignore_warnings=true) ==\n+            Expr(:import, Expr(:., :A, :+))\n+        @test parsestmt(\"import A.(:+)\", ignore_warnings=true) ==\n+            Expr(:import, Expr(:., :A, :+))\n+        @test parsestmt(\"import A.:(+)\", ignore_warnings=true) ==\n+            Expr(:import, Expr(:., :A, :+))\n+        @test parsestmt(\"import A.:(+) as y\", ignore_warnings=true, version=v\"1.6\") ==\n+            Expr(:import, Expr(:as, Expr(:., :A, :+), :y))\n+    end\n+end\n+\n+@testset \"SyntaxNode->Expr conversion\" begin\n+    src = repeat('a', 1000) * '\\n' * \"@hi\"\n+    @test Expr(parsestmt(SyntaxNode, SubString(src, 1001:lastindex(src)))) ==\n+        Expr(:macrocall, Symbol(\"@hi\"), LineNumberNode(2))\n+end"
    },
    {
      "sha": "71c9ff77b1ab6d80825c09194dede13902b5e675",
      "filename": "JuliaSyntax/test/fuzz_test.jl",
      "status": "added",
      "additions": 1023,
      "deletions": 0,
      "changes": 1023,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Ffuzz_test.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Ffuzz_test.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Ffuzz_test.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,1023 @@\n+using .JuliaSyntax: tokenize\n+import Logging\n+import Test\n+\n+# Parser fuzz testing tools.\n+\n+const all_tokens = [\n+    \"#x\\n\"\n+    \"#==#\"\n+    \" \"\n+    \"\\t\"\n+    \"\\n\"\n+    \"x\"\n+    \"@\"\n+    \",\"\n+    \";\"\n+\n+    \"baremodule\"\n+    \"begin\"\n+    \"break\"\n+    \"const\"\n+    \"continue\"\n+    \"do\"\n+    \"export\"\n+    \"for\"\n+    \"function\"\n+    \"global\"\n+    \"if\"\n+    \"import\"\n+    \"let\"\n+    \"local\"\n+    \"macro\"\n+    \"module\"\n+    \"quote\"\n+    \"return\"\n+    \"struct\"\n+    \"try\"\n+    \"using\"\n+    \"while\"\n+    \"catch\"\n+    \"finally\"\n+    \"else\"\n+    \"elseif\"\n+    \"end\"\n+    \"abstract\"\n+    \"as\"\n+    \"doc\"\n+    \"mutable\"\n+    \"outer\"\n+    \"primitive\"\n+    \"type\"\n+    \"var\"\n+\n+    \"1\"\n+    \"0b1\"\n+    \"0x1\"\n+    \"0o1\"\n+    \"1.0\"\n+    \"1.0f0\"\n+    \"\\\"s\\\"\"\n+    \"'c'\"\n+    \"`s`\"\n+    \"true\"\n+    \"false\"\n+\n+    \"[\"\n+    \"]\"\n+    \"{\"\n+    \"}\"\n+    \"(\"\n+    \")\"\n+    \"\\\"\"\n+    \"\\\"\\\"\\\"\"\n+    \"`\"\n+    \"```\"\n+\n+    \"=\"\n+    \"+=\"\n+    \"-=\"   # Also used for \"\u2212=\"\n+    \"\u2212=\"\n+    \"*=\"\n+    \"/=\"\n+    \"//=\"\n+    \"|=\"\n+    \"^=\"\n+    \"\u00f7=\"\n+    \"%=\"\n+    \"<<=\"\n+    \">>=\"\n+    \">>>=\"\n+    \"\\\\=\"\n+    \"&=\"\n+    \":=\"\n+    \"~\"\n+    \"\\$=\"\n+    \"\u22bb=\"\n+    \"\u2254\"\n+    \"\u2a74\"\n+    \"\u2255\"\n+\n+    \"=>\"\n+\n+    \"?\"\n+\n+    \"-->\"\n+    \"<--\"\n+    \"<-->\"\n+    \"\u2190\"\n+    \"\u2192\"\n+    \"\u2194\"\n+    \"\u219a\"\n+    \"\u219b\"\n+    \"\u219e\"\n+    \"\u21a0\"\n+    \"\u21a2\"\n+    \"\u21a3\"\n+    \"\u21a4\"\n+    \"\u21a6\"\n+    \"\u21ae\"\n+    \"\u21ce\"\n+    \"\u21cd\"\n+    \"\u21cf\"\n+    \"\u21d0\"\n+    \"\u21d2\"\n+    \"\u21d4\"\n+    \"\u21f4\"\n+    \"\u21f6\"\n+    \"\u21f7\"\n+    \"\u21f8\"\n+    \"\u21f9\"\n+    \"\u21fa\"\n+    \"\u21fb\"\n+    \"\u21fc\"\n+    \"\u21fd\"\n+    \"\u21fe\"\n+    \"\u21ff\"\n+    \"\u27f5\"\n+    \"\u27f6\"\n+    \"\u27f7\"\n+    \"\u27f9\"\n+    \"\u27fa\"\n+    \"\u27fb\"\n+    \"\u27fc\"\n+    \"\u27fd\"\n+    \"\u27fe\"\n+    \"\u27ff\"\n+    \"\u2900\"\n+    \"\u2901\"\n+    \"\u2902\"\n+    \"\u2903\"\n+    \"\u2904\"\n+    \"\u2905\"\n+    \"\u2906\"\n+    \"\u2907\"\n+    \"\u290c\"\n+    \"\u290d\"\n+    \"\u290e\"\n+    \"\u290f\"\n+    \"\u2910\"\n+    \"\u2911\"\n+    \"\u2914\"\n+    \"\u2915\"\n+    \"\u2916\"\n+    \"\u2917\"\n+    \"\u2918\"\n+    \"\u291d\"\n+    \"\u291e\"\n+    \"\u291f\"\n+    \"\u2920\"\n+    \"\u2944\"\n+    \"\u2945\"\n+    \"\u2946\"\n+    \"\u2947\"\n+    \"\u2948\"\n+    \"\u294a\"\n+    \"\u294b\"\n+    \"\u294e\"\n+    \"\u2950\"\n+    \"\u2952\"\n+    \"\u2953\"\n+    \"\u2956\"\n+    \"\u2957\"\n+    \"\u295a\"\n+    \"\u295b\"\n+    \"\u295e\"\n+    \"\u295f\"\n+    \"\u2962\"\n+    \"\u2964\"\n+    \"\u2966\"\n+    \"\u2967\"\n+    \"\u2968\"\n+    \"\u2969\"\n+    \"\u296a\"\n+    \"\u296b\"\n+    \"\u296c\"\n+    \"\u296d\"\n+    \"\u2970\"\n+    \"\u29f4\"\n+    \"\u2b31\"\n+    \"\u2b30\"\n+    \"\u2b32\"\n+    \"\u2b33\"\n+    \"\u2b34\"\n+    \"\u2b35\"\n+    \"\u2b36\"\n+    \"\u2b37\"\n+    \"\u2b38\"\n+    \"\u2b39\"\n+    \"\u2b3a\"\n+    \"\u2b3b\"\n+    \"\u2b3c\"\n+    \"\u2b3d\"\n+    \"\u2b3e\"\n+    \"\u2b3f\"\n+    \"\u2b40\"\n+    \"\u2b41\"\n+    \"\u2b42\"\n+    \"\u2b43\"\n+    \"\u2b44\"\n+    \"\u2b47\"\n+    \"\u2b48\"\n+    \"\u2b49\"\n+    \"\u2b4a\"\n+    \"\u2b4b\"\n+    \"\u2b4c\"\n+    \"\uffe9\"\n+    \"\uffeb\"\n+    \"\u21dc\"\n+    \"\u21dd\"\n+    \"\u219c\"\n+    \"\u219d\"\n+    \"\u21a9\"\n+    \"\u21aa\"\n+    \"\u21ab\"\n+    \"\u21ac\"\n+    \"\u21bc\"\n+    \"\u21bd\"\n+    \"\u21c0\"\n+    \"\u21c1\"\n+    \"\u21c4\"\n+    \"\u21c6\"\n+    \"\u21c7\"\n+    \"\u21c9\"\n+    \"\u21cb\"\n+    \"\u21cc\"\n+    \"\u21da\"\n+    \"\u21db\"\n+    \"\u21e0\"\n+    \"\u21e2\"\n+    \"\u21b7\"\n+    \"\u21b6\"\n+    \"\u21ba\"\n+    \"\u21bb\"\n+\n+    \"||\"\n+\n+    \"&&\"\n+\n+    \"<:\"\n+    \">:\"\n+    \">\"\n+    \"<\"\n+    \">=\"\n+    \"\u2265\"\n+    \"<=\"\n+    \"\u2264\"\n+    \"==\"\n+    \"===\"\n+    \"\u2261\"\n+    \"!=\"\n+    \"\u2260\"\n+    \"!==\"\n+    \"\u2262\"\n+    \"\u2208\"\n+    \"in\"\n+    \"isa\"\n+    \"\u2209\"\n+    \"\u220b\"\n+    \"\u220c\"\n+    \"\u2286\"\n+    \"\u2288\"\n+    \"\u2282\"\n+    \"\u2284\"\n+    \"\u228a\"\n+    \"\u221d\"\n+    \"\u220a\"\n+    \"\u220d\"\n+    \"\u2225\"\n+    \"\u2226\"\n+    \"\u2237\"\n+    \"\u223a\"\n+    \"\u223b\"\n+    \"\u223d\"\n+    \"\u223e\"\n+    \"\u2241\"\n+    \"\u2243\"\n+    \"\u2242\"\n+    \"\u2244\"\n+    \"\u2245\"\n+    \"\u2246\"\n+    \"\u2247\"\n+    \"\u2248\"\n+    \"\u2249\"\n+    \"\u224a\"\n+    \"\u224b\"\n+    \"\u224c\"\n+    \"\u224d\"\n+    \"\u224e\"\n+    \"\u2250\"\n+    \"\u2251\"\n+    \"\u2252\"\n+    \"\u2253\"\n+    \"\u2256\"\n+    \"\u2257\"\n+    \"\u2258\"\n+    \"\u2259\"\n+    \"\u225a\"\n+    \"\u225b\"\n+    \"\u225c\"\n+    \"\u225d\"\n+    \"\u225e\"\n+    \"\u225f\"\n+    \"\u2263\"\n+    \"\u2266\"\n+    \"\u2267\"\n+    \"\u2268\"\n+    \"\u2269\"\n+    \"\u226a\"\n+    \"\u226b\"\n+    \"\u226c\"\n+    \"\u226d\"\n+    \"\u226e\"\n+    \"\u226f\"\n+    \"\u2270\"\n+    \"\u2271\"\n+    \"\u2272\"\n+    \"\u2273\"\n+    \"\u2274\"\n+    \"\u2275\"\n+    \"\u2276\"\n+    \"\u2277\"\n+    \"\u2278\"\n+    \"\u2279\"\n+    \"\u227a\"\n+    \"\u227b\"\n+    \"\u227c\"\n+    \"\u227d\"\n+    \"\u227e\"\n+    \"\u227f\"\n+    \"\u2280\"\n+    \"\u2281\"\n+    \"\u2283\"\n+    \"\u2285\"\n+    \"\u2287\"\n+    \"\u2289\"\n+    \"\u228b\"\n+    \"\u228f\"\n+    \"\u2290\"\n+    \"\u2291\"\n+    \"\u2292\"\n+    \"\u229c\"\n+    \"\u22a9\"\n+    \"\u22ac\"\n+    \"\u22ae\"\n+    \"\u22b0\"\n+    \"\u22b1\"\n+    \"\u22b2\"\n+    \"\u22b3\"\n+    \"\u22b4\"\n+    \"\u22b5\"\n+    \"\u22b6\"\n+    \"\u22b7\"\n+    \"\u22cd\"\n+    \"\u22d0\"\n+    \"\u22d1\"\n+    \"\u22d5\"\n+    \"\u22d6\"\n+    \"\u22d7\"\n+    \"\u22d8\"\n+    \"\u22d9\"\n+    \"\u22da\"\n+    \"\u22db\"\n+    \"\u22dc\"\n+    \"\u22dd\"\n+    \"\u22de\"\n+    \"\u22df\"\n+    \"\u22e0\"\n+    \"\u22e1\"\n+    \"\u22e2\"\n+    \"\u22e3\"\n+    \"\u22e4\"\n+    \"\u22e5\"\n+    \"\u22e6\"\n+    \"\u22e7\"\n+    \"\u22e8\"\n+    \"\u22e9\"\n+    \"\u22ea\"\n+    \"\u22eb\"\n+    \"\u22ec\"\n+    \"\u22ed\"\n+    \"\u22f2\"\n+    \"\u22f3\"\n+    \"\u22f4\"\n+    \"\u22f5\"\n+    \"\u22f6\"\n+    \"\u22f7\"\n+    \"\u22f8\"\n+    \"\u22f9\"\n+    \"\u22fa\"\n+    \"\u22fb\"\n+    \"\u22fc\"\n+    \"\u22fd\"\n+    \"\u22fe\"\n+    \"\u22ff\"\n+    \"\u27c8\"\n+    \"\u27c9\"\n+    \"\u27d2\"\n+    \"\u29b7\"\n+    \"\u29c0\"\n+    \"\u29c1\"\n+    \"\u29e1\"\n+    \"\u29e3\"\n+    \"\u29e4\"\n+    \"\u29e5\"\n+    \"\u2a66\"\n+    \"\u2a67\"\n+    \"\u2a6a\"\n+    \"\u2a6b\"\n+    \"\u2a6c\"\n+    \"\u2a6d\"\n+    \"\u2a6e\"\n+    \"\u2a6f\"\n+    \"\u2a70\"\n+    \"\u2a71\"\n+    \"\u2a72\"\n+    \"\u2a73\"\n+    \"\u2a75\"\n+    \"\u2a76\"\n+    \"\u2a77\"\n+    \"\u2a78\"\n+    \"\u2a79\"\n+    \"\u2a7a\"\n+    \"\u2a7b\"\n+    \"\u2a7c\"\n+    \"\u2a7d\"\n+    \"\u2a7e\"\n+    \"\u2a7f\"\n+    \"\u2a80\"\n+    \"\u2a81\"\n+    \"\u2a82\"\n+    \"\u2a83\"\n+    \"\u2a84\"\n+    \"\u2a85\"\n+    \"\u2a86\"\n+    \"\u2a87\"\n+    \"\u2a88\"\n+    \"\u2a89\"\n+    \"\u2a8a\"\n+    \"\u2a8b\"\n+    \"\u2a8c\"\n+    \"\u2a8d\"\n+    \"\u2a8e\"\n+    \"\u2a8f\"\n+    \"\u2a90\"\n+    \"\u2a91\"\n+    \"\u2a92\"\n+    \"\u2a93\"\n+    \"\u2a94\"\n+    \"\u2a95\"\n+    \"\u2a96\"\n+    \"\u2a97\"\n+    \"\u2a98\"\n+    \"\u2a99\"\n+    \"\u2a9a\"\n+    \"\u2a9b\"\n+    \"\u2a9c\"\n+    \"\u2a9d\"\n+    \"\u2a9e\"\n+    \"\u2a9f\"\n+    \"\u2aa0\"\n+    \"\u2aa1\"\n+    \"\u2aa2\"\n+    \"\u2aa3\"\n+    \"\u2aa4\"\n+    \"\u2aa5\"\n+    \"\u2aa6\"\n+    \"\u2aa7\"\n+    \"\u2aa8\"\n+    \"\u2aa9\"\n+    \"\u2aaa\"\n+    \"\u2aab\"\n+    \"\u2aac\"\n+    \"\u2aad\"\n+    \"\u2aae\"\n+    \"\u2aaf\"\n+    \"\u2ab0\"\n+    \"\u2ab1\"\n+    \"\u2ab2\"\n+    \"\u2ab3\"\n+    \"\u2ab4\"\n+    \"\u2ab5\"\n+    \"\u2ab6\"\n+    \"\u2ab7\"\n+    \"\u2ab8\"\n+    \"\u2ab9\"\n+    \"\u2aba\"\n+    \"\u2abb\"\n+    \"\u2abc\"\n+    \"\u2abd\"\n+    \"\u2abe\"\n+    \"\u2abf\"\n+    \"\u2ac0\"\n+    \"\u2ac1\"\n+    \"\u2ac2\"\n+    \"\u2ac3\"\n+    \"\u2ac4\"\n+    \"\u2ac5\"\n+    \"\u2ac6\"\n+    \"\u2ac7\"\n+    \"\u2ac8\"\n+    \"\u2ac9\"\n+    \"\u2aca\"\n+    \"\u2acb\"\n+    \"\u2acc\"\n+    \"\u2acd\"\n+    \"\u2ace\"\n+    \"\u2acf\"\n+    \"\u2ad0\"\n+    \"\u2ad1\"\n+    \"\u2ad2\"\n+    \"\u2ad3\"\n+    \"\u2ad4\"\n+    \"\u2ad5\"\n+    \"\u2ad6\"\n+    \"\u2ad7\"\n+    \"\u2ad8\"\n+    \"\u2ad9\"\n+    \"\u2af7\"\n+    \"\u2af8\"\n+    \"\u2af9\"\n+    \"\u2afa\"\n+    \"\u22a2\"\n+    \"\u22a3\"\n+    \"\u27c2\"\n+    \"\u2aea\"\n+    \"\u2aeb\"\n+\n+    \"<|\"\n+    \"|>\"\n+\n+    \":\"\n+    \"..\"\n+    \"\u2026\"\n+    \"\u205d\"\n+    \"\u22ee\"\n+    \"\u22f1\"\n+    \"\u22f0\"\n+    \"\u22ef\"\n+\n+    \"\\$\"\n+    \"+\"\n+    \"-\" # also used for \"\u2212\"\n+    \"\u2212\"\n+    \"++\"\n+    \"\u2295\"\n+    \"\u2296\"\n+    \"\u229e\"\n+    \"\u229f\"\n+    \"|\"\n+    \"\u222a\"\n+    \"\u2228\"\n+    \"\u2294\"\n+    \"\u00b1\"\n+    \"\u2213\"\n+    \"\u2214\"\n+    \"\u2238\"\n+    \"\u224f\"\n+    \"\u228e\"\n+    \"\u22bb\"\n+    \"\u22bd\"\n+    \"\u22ce\"\n+    \"\u22d3\"\n+    \"\u29fa\"\n+    \"\u29fb\"\n+    \"\u2a08\"\n+    \"\u2a22\"\n+    \"\u2a23\"\n+    \"\u2a24\"\n+    \"\u2a25\"\n+    \"\u2a26\"\n+    \"\u2a27\"\n+    \"\u2a28\"\n+    \"\u2a29\"\n+    \"\u2a2a\"\n+    \"\u2a2b\"\n+    \"\u2a2c\"\n+    \"\u2a2d\"\n+    \"\u2a2e\"\n+    \"\u2a39\"\n+    \"\u2a3a\"\n+    \"\u2a41\"\n+    \"\u2a42\"\n+    \"\u2a45\"\n+    \"\u2a4a\"\n+    \"\u2a4c\"\n+    \"\u2a4f\"\n+    \"\u2a50\"\n+    \"\u2a52\"\n+    \"\u2a54\"\n+    \"\u2a56\"\n+    \"\u2a57\"\n+    \"\u2a5b\"\n+    \"\u2a5d\"\n+    \"\u2a61\"\n+    \"\u2a62\"\n+    \"\u2a63\"\n+    \"\u00a6\"\n+\n+    \"*\"\n+    \"/\"\n+    \"\u00f7\"\n+    \"%\"\n+    \"\u22c5\" # also used for lookalikes \"\u00b7\" and \"\u0387\"\n+    \"\u00b7\"\n+    \"\u0387\"\n+    \"\u2218\"\n+    \"\u00d7\"\n+    \"\\\\\"\n+    \"&\"\n+    \"\u2229\"\n+    \"\u2227\"\n+    \"\u2297\"\n+    \"\u2298\"\n+    \"\u2299\"\n+    \"\u229a\"\n+    \"\u229b\"\n+    \"\u22a0\"\n+    \"\u22a1\"\n+    \"\u2293\"\n+    \"\u2217\"\n+    \"\u2219\"\n+    \"\u2224\"\n+    \"\u214b\"\n+    \"\u2240\"\n+    \"\u22bc\"\n+    \"\u22c4\"\n+    \"\u22c6\"\n+    \"\u22c7\"\n+    \"\u22c9\"\n+    \"\u22ca\"\n+    \"\u22cb\"\n+    \"\u22cc\"\n+    \"\u22cf\"\n+    \"\u22d2\"\n+    \"\u27d1\"\n+    \"\u29b8\"\n+    \"\u29bc\"\n+    \"\u29be\"\n+    \"\u29bf\"\n+    \"\u29f6\"\n+    \"\u29f7\"\n+    \"\u2a07\"\n+    \"\u2a30\"\n+    \"\u2a31\"\n+    \"\u2a32\"\n+    \"\u2a33\"\n+    \"\u2a34\"\n+    \"\u2a35\"\n+    \"\u2a36\"\n+    \"\u2a37\"\n+    \"\u2a38\"\n+    \"\u2a3b\"\n+    \"\u2a3c\"\n+    \"\u2a3d\"\n+    \"\u2a40\"\n+    \"\u2a43\"\n+    \"\u2a44\"\n+    \"\u2a4b\"\n+    \"\u2a4d\"\n+    \"\u2a4e\"\n+    \"\u2a51\"\n+    \"\u2a53\"\n+    \"\u2a55\"\n+    \"\u2a58\"\n+    \"\u2a5a\"\n+    \"\u2a5c\"\n+    \"\u2a5e\"\n+    \"\u2a5f\"\n+    \"\u2a60\"\n+    \"\u2adb\"\n+    \"\u228d\"\n+    \"\u25b7\"\n+    \"\u2a1d\"\n+    \"\u27d5\"\n+    \"\u27d6\"\n+    \"\u27d7\"\n+    \"\u233f\"\n+    \"\u2a1f\"\n+\n+    \"//\"\n+\n+    \"<<\"\n+    \">>\"\n+    \">>>\"\n+\n+    \"^\"\n+    \"\u2191\"\n+    \"\u2193\"\n+    \"\u21f5\"\n+    \"\u27f0\"\n+    \"\u27f1\"\n+    \"\u2908\"\n+    \"\u2909\"\n+    \"\u290a\"\n+    \"\u290b\"\n+    \"\u2912\"\n+    \"\u2913\"\n+    \"\u2949\"\n+    \"\u294c\"\n+    \"\u294d\"\n+    \"\u294f\"\n+    \"\u2951\"\n+    \"\u2954\"\n+    \"\u2955\"\n+    \"\u2958\"\n+    \"\u2959\"\n+    \"\u295c\"\n+    \"\u295d\"\n+    \"\u2960\"\n+    \"\u2961\"\n+    \"\u2963\"\n+    \"\u2965\"\n+    \"\u296e\"\n+    \"\u296f\"\n+    \"\uffea\"\n+    \"\uffec\"\n+\n+    \"::\"\n+\n+    \"where\"\n+\n+    \".\"\n+\n+    \"!\"\n+    \"'\"\n+    \".'\"\n+    \"->\"\n+\n+    \"\u00ac\"\n+    \"\u221a\"\n+    \"\u221b\"\n+    \"\u221c\"\n+]\n+\n+const cutdown_tokens = [\n+    \"#x\\n\"\n+    \"#==#\"\n+    \" \"\n+    \"\\t\"\n+    \"\\n\"\n+    \"x\"\n+    \"\u03b2\"\n+    \"@\"\n+    \",\"\n+    \";\"\n+\n+    \"baremodule\"\n+    \"begin\"\n+    \"break\"\n+    \"const\"\n+    \"continue\"\n+    \"do\"\n+    \"export\"\n+    \"for\"\n+    \"function\"\n+    \"global\"\n+    \"if\"\n+    \"import\"\n+    \"let\"\n+    \"local\"\n+    \"macro\"\n+    \"module\"\n+    \"quote\"\n+    \"return\"\n+    \"struct\"\n+    \"try\"\n+    \"using\"\n+    \"while\"\n+    \"catch\"\n+    \"finally\"\n+    \"else\"\n+    \"elseif\"\n+    \"end\"\n+    \"abstract\"\n+    \"as\"\n+    \"doc\"\n+    \"mutable\"\n+    \"outer\"\n+    \"primitive\"\n+    \"type\"\n+    \"var\"\n+\n+    \"1\"\n+    \"0b1\"\n+    \"0x1\"\n+    \"0o1\"\n+    \"1.0\"\n+    \"1.0f0\"\n+    \"\\\"s\\\"\"\n+    \"'c'\"\n+    \"`s`\"\n+    \"true\"\n+    \"false\"\n+\n+    \"[\"\n+    \"]\"\n+    \"{\"\n+    \"}\"\n+    \"(\"\n+    \")\"\n+    \"\\\"\"\n+    \"\\\"\\\"\\\"\"\n+    \"`\"\n+    \"```\"\n+\n+    \"=\"\n+    \"+=\"\n+    \"~\"\n+\n+    \"=>\"\n+\n+    \"?\"\n+\n+    \"-->\"\n+\n+    \"||\"\n+\n+    \"&&\"\n+\n+    \"<:\"\n+    \">:\"\n+    \">\"\n+    \"<\"\n+    \">=\"\n+    \"<=\"\n+    \"==\"\n+    \"===\"\n+    \"!=\"\n+\n+    \"<|\"\n+    \"|>\"\n+\n+    \":\"\n+    \"..\"\n+    \"\u2026\"\n+\n+    \"\\$\"\n+    \"+\"\n+    \"\u2212\"\n+    \"-\"\n+    \"|\"\n+\n+    \"*\"\n+    \"/\"\n+    \"\u22c5\" # also used for lookalikes \"\u00b7\" and \"\u0387\"\n+    \"\u00b7\"\n+    \"\\\\\"\n+\n+    \"//\"\n+\n+    \"<<\"\n+\n+    \"^\"\n+\n+    \"::\"\n+\n+    \"where\"\n+\n+    \".\"\n+\n+    \"!\"\n+    \"'\"\n+    \"->\"\n+\n+    \"\u221a\"\n+]\n+\n+#-------------------------------------------------------------------------------\n+# Parsing functions for use with fuzz_test\n+\n+function try_parseall_failure(str)\n+    try\n+        JuliaSyntax.parseall(JuliaSyntax.SyntaxNode, str, ignore_errors=true);\n+        return nothing\n+    catch exc\n+        !(exc isa InterruptException) || rethrow()\n+        rstr = reduce_text(str, parser_throws_exception)\n+        @error \"Parser threw exception\" rstr exception=current_exceptions()\n+        return rstr\n+    end\n+end\n+\n+function try_hook_failure(str)\n+    try\n+        test_logger = Test.TestLogger()\n+        Logging.with_logger(test_logger) do\n+            try\n+                Meta_parseall(str)\n+            catch exc\n+                exc isa Meta.ParseError || exc isa JuliaSyntax.ParseError || rethrow()\n+            end\n+        end\n+        if !isempty(test_logger.logs)\n+            return str\n+        end\n+    catch exc\n+        return str\n+    end\n+    return nothing\n+end\n+\n+#-------------------------------------------------------------------------------\n+\"\"\"Delete `nlines` adjacent lines from code, at `niters` randomly chosen positions\"\"\"\n+function delete_lines(lines, nlines, niters)\n+    selection = trues(length(lines))\n+    for j=1:niters\n+        i = rand(1:length(lines)-nlines)\n+        selection[i:i+nlines] .= false\n+    end\n+    join(lines[selection], '\\n')\n+end\n+\n+\"\"\"Delete `ntokens` adjacent tokens from code, at `niters` randomly chosen positions\"\"\"\n+function delete_tokens(code, tokens, ntokens, niters)\n+    # [ aa bbbb cc d eeeeee  ]\n+    #   |  |    |  | |     |\n+    selection = trues(length(tokens))\n+    for j=1:niters\n+        i = rand(1:length(tokens)-ntokens)\n+        selection[i:i+ntokens] .= false\n+    end\n+    io = IOBuffer()\n+    i = 1\n+    while true\n+        while i <= length(selection) && !selection[i]\n+            i += 1\n+        end\n+        if i > length(selection)\n+            break\n+        end\n+        first_ind = first(tokens[i].range)\n+        while selection[i] && i < length(selection)\n+            i += 1\n+        end\n+        last_ind = last(tokens[i].range)\n+        write(io, @view code[first_ind:last_ind])\n+        if i == length(selection)\n+            break\n+        end\n+    end\n+    return String(take!(io))\n+end\n+\n+#-------------------------------------------------------------------------------\n+# Generators for \"potentially bad input\"\n+\n+\"\"\"\n+Fuzz test parser against all tuples of length `N` with elements taken from\n+`tokens`.\n+\"\"\"\n+function product_token_fuzz(tokens, N)\n+    (join(ts) for ts in Iterators.product([tokens for _ in 1:N]...))\n+end\n+\n+function random_token_fuzz(tokens, ntokens, ntries)\n+    (join(rand(tokens, ntokens)) for _ in 1:ntries)\n+end\n+\n+\"\"\"\n+Fuzz test parser against randomly generated binary strings\n+\"\"\"\n+function random_binary_fuzz(nbytes, N)\n+    (String(rand(UInt8, nbytes)) for _ in 1:N)\n+end\n+\n+\"\"\"\n+Fuzz test by deleting random lines of some given source `code`\n+\"\"\"\n+function deleted_line_fuzz(code, N; nlines=10, niters=10)\n+    lines = split(code, '\\n')\n+    (delete_lines(lines, nlines, niters) for _=1:N)\n+end\n+\n+\"\"\"\n+Fuzz test by deleting random tokens from given source `code`\n+\"\"\"\n+function deleted_token_fuzz(code, N; ntokens=10, niters=10)\n+    ts = tokenize(code)\n+    (delete_tokens(code, ts, ntokens, niters) for _=1:N)\n+end\n+\n+\"\"\"\n+Fuzz test a parsing function by trying it with many \"bad\" input strings.\n+\n+`try_parsefail` should return `nothing` when the parser succeeds, and return a\n+string (or reduced string) when parsing succeeds.\n+\"\"\"\n+function fuzz_test(try_parsefail::Function, bad_input_iter)\n+    error_strings = []\n+    for str in bad_input_iter\n+        res = try_parsefail(str)\n+        if !isnothing(res)\n+            push!(error_strings, res)\n+        end\n+    end\n+    return error_strings\n+end\n+\n+\n+# Examples\n+#\n+# fuzz_test(try_hook_failure, product_token_fuzz(cutdown_tokens, 2))\n+# fuzz_test(try_parseall_failure, product_token_fuzz(cutdown_tokens, 2))"
    },
    {
      "sha": "0c3be65873c2e736587baba79f62af8b6afe822c",
      "filename": "JuliaSyntax/test/green_node.jl",
      "status": "added",
      "additions": 68,
      "deletions": 0,
      "changes": 68,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fgreen_node.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fgreen_node.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fgreen_node.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,68 @@\n+@testset \"GreenNode\" begin\n+    t = parsestmt(GreenNode, \"aa + b\")\n+\n+    @test span(t) == 6\n+    @test !is_leaf(t)\n+    @test head(t) == SyntaxHead(K\"call\", 0x0088)\n+    @test span.(children(t)) == [2,1,1,1,1]\n+    @test head.(children(t)) == [\n+         SyntaxHead(K\"Identifier\", 0x0000)\n+         SyntaxHead(K\"Whitespace\", 0x0001)\n+         SyntaxHead(K\"Identifier\", 0x0000)\n+         SyntaxHead(K\"Whitespace\", 0x0001)\n+         SyntaxHead(K\"Identifier\", 0x0000)\n+    ]\n+\n+    @test numchildren(t) == 5\n+    @test !is_leaf(t)\n+    @test is_leaf(t[1])\n+\n+    @test t[1] === children(t)[1]\n+    @test t[2:4] == [t[2],t[3],t[4]]\n+    @test firstindex(t) == 1\n+    @test lastindex(t) == 5\n+\n+    t2 = parsestmt(GreenNode, \"aa + b\")\n+    @test t == t2\n+    @test t !== t2\n+\n+    text = \"f(@x(y), z)\"\n+    @test sprint(show, MIME(\"text/plain\"), parsestmt(GreenNode, text)) ==\n+    \"\"\"\n+         1:11     \u2502[call]\n+         1:1      \u2502  Identifier             \u2714\n+         2:2      \u2502  (\n+         3:7      \u2502  [macrocall]\n+         3:4      \u2502    [macro_name]\n+         3:3      \u2502      @\n+         4:4      \u2502      Identifier         \u2714\n+         5:5      \u2502    (\n+         6:6      \u2502    Identifier           \u2714\n+         7:7      \u2502    )\n+         8:8      \u2502  ,\n+         9:9      \u2502  Whitespace\n+        10:10     \u2502  Identifier             \u2714\n+        11:11     \u2502  )\n+    \"\"\"\n+\n+    @test sprint(show, MIME(\"text/plain\"), parsestmt(GreenNode, text), text) ==\n+    \"\"\"\n+         1:11     \u2502[call]\n+         1:1      \u2502  Identifier             \u2714   \"f\"\n+         2:2      \u2502  (                          \"(\"\n+         3:7      \u2502  [macrocall]\n+         3:4      \u2502    [macro_name]\n+         3:3      \u2502      @                      \"@\"\n+         4:4      \u2502      Identifier         \u2714   \"x\"\n+         5:5      \u2502    (                        \"(\"\n+         6:6      \u2502    Identifier           \u2714   \"y\"\n+         7:7      \u2502    )                        \")\"\n+         8:8      \u2502  ,                          \",\"\n+         9:9      \u2502  Whitespace                 \" \"\n+        10:10     \u2502  Identifier             \u2714   \"z\"\n+        11:11     \u2502  )                          \")\"\n+    \"\"\"\n+\n+    @test sprint(show, parsestmt(GreenNode, \"a + bb - f(ccc)\")) ==\n+        \"(call-i (call-i 1-1::Identifier 2-2::Whitespace-t 3-3::Identifier 4-4::Whitespace-t 5-6::Identifier) 7-7::Whitespace-t 8-8::Identifier 9-9::Whitespace-t (call 10-10::Identifier 11-11::(-t 12-14::Identifier 15-15::)-t))\"\n+end"
    },
    {
      "sha": "333344d7c50a178212da2b557fad2c15f375dfc1",
      "filename": "JuliaSyntax/test/hooks.jl",
      "status": "added",
      "additions": 516,
      "deletions": 0,
      "changes": 516,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fhooks.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fhooks.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fhooks.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,516 @@\n+function _unwrap_parse_error(core_hook_result)\n+    @test Meta.isexpr(core_hook_result[1], :error, 1)\n+    err = core_hook_result[1].args[1]\n+    if JuliaSyntax._has_v1_10_hooks\n+        @test err isa Meta.ParseError\n+        return err.detail\n+    else\n+        @test err isa JuliaSyntax.ParseError\n+        return err\n+    end\n+end\n+\n+@testset \"Hooks for Core integration\" begin\n+    @testset \"whitespace and comment parsing\" begin\n+        @test JuliaSyntax.core_parser_hook(\"\", \"somefile\", 1, 0, :statement) == Core.svec(nothing, 0)\n+        @test JuliaSyntax.core_parser_hook(\"\", \"somefile\", 1, 0, :statement) == Core.svec(nothing, 0)\n+\n+        @test JuliaSyntax.core_parser_hook(\"  \", \"somefile\", 1, 2, :statement) == Core.svec(nothing,2)\n+        @test JuliaSyntax.core_parser_hook(\" #==# \", \"somefile\", 1, 6, :statement) == Core.svec(nothing,6)\n+\n+        @test JuliaSyntax.core_parser_hook(\" x \\n\", \"somefile\", 1, 0, :statement) == Core.svec(:x,4)\n+        @test JuliaSyntax.core_parser_hook(\" x \\n\", \"somefile\", 1, 0, :atom)      == Core.svec(:x,2)\n+\n+        # https://github.com/JuliaLang/JuliaSyntax.jl/issues/316#issuecomment-1870294857\n+        stmtstr =\n+            \"\"\"\n+            plus(a, b) = a + b\n+\n+            # Issue #81\n+            f() = nothing\n+            \"\"\"\n+        @test JuliaSyntax.core_parser_hook(stmtstr, \"somefile\", 1, 0, :statement)[2] == 19\n+    end\n+\n+    @testset \"filename and lineno\" begin\n+        ex = JuliaSyntax.core_parser_hook(\"@a\", \"somefile\", 1, 0, :statement)[1]\n+        @test Meta.isexpr(ex, :macrocall)\n+        @test ex.args[2] == LineNumberNode(1, \"somefile\")\n+\n+        ex = JuliaSyntax.core_parser_hook(\"@a\", \"otherfile\", 2, 0, :statement)[1]\n+        @test ex.args[2] == LineNumberNode(2, \"otherfile\")\n+\n+        # Errors also propagate file & lineno\n+        err = _unwrap_parse_error(\n+            JuliaSyntax.core_parser_hook(\"[x)\", \"f1\", 1, 0, :statement)\n+        )\n+        @test err isa JuliaSyntax.ParseError\n+        @test filename(err) == \"f1\"\n+        @test err.source.first_line == 1\n+        err = _unwrap_parse_error(\n+            JuliaSyntax.core_parser_hook(\"[x)\", \"f2\", 2, 0, :statement)\n+        )\n+        @test err isa JuliaSyntax.ParseError\n+        @test filename(err) == \"f2\"\n+        @test err.source.first_line == 2\n+\n+        # Errors including nontrivial offset indices\n+        err = _unwrap_parse_error(\n+            JuliaSyntax.core_parser_hook(\"a\\nh{x)\\nb\", \"test.jl\", 1, 2, :statement)\n+        )\n+        @test err isa JuliaSyntax.ParseError\n+        @test err.source.first_line == 1\n+        @test err.diagnostics[1].first_byte == 6\n+        @test err.diagnostics[1].last_byte == 5\n+        @test err.diagnostics[1].message == \"Expected `}` or `,`\"\n+    end\n+\n+    @testset \"toplevel errors\" begin\n+        ex = JuliaSyntax.core_parser_hook(\"a\\nb\\n[x,\\ny)\", \"somefile\", 1, 0, :all)[1]\n+        @test ex.head == :toplevel\n+        @test ex.args[1:5] == [\n+            LineNumberNode(1, \"somefile\"),\n+            :a,\n+            LineNumberNode(2, \"somefile\"),\n+            :b,\n+            LineNumberNode(4, \"somefile\"),\n+        ]\n+        @test Meta.isexpr(ex.args[6], :error)\n+\n+        ex = JuliaSyntax.core_parser_hook(\"x.\", \"somefile\", 0, 0, :all)[1]\n+        @test ex.head == :toplevel\n+        @test ex.args[2].head == :incomplete\n+    end\n+\n+    @testset \"enable_in_core!\" begin\n+        JuliaSyntax.enable_in_core!()\n+\n+        @test Meta.parse(\"x + 1\") == :(x + 1)\n+        @test Meta.parse(\"x + 1\", 1) == (:(x + 1), 6)\n+\n+        # Test that parsing statements incrementally works and stops after\n+        # whitespace / comment trivia\n+        @test Meta.parse(\"x + 1\\n(y)\\n\", 1) == (:(x + 1), 7)\n+        @test Meta.parse(\"x + 1\\n(y)\\n\", 7) == (:y, 11)\n+        @test Meta.parse(\" x#==#\", 1) == (:x, 7)\n+        @test Meta.parse(\" #==# \", 1) == (nothing, 7)\n+\n+        # Check the exception type that Meta.parse throws\n+        if JuliaSyntax._has_v1_10_hooks\n+            @test_throws Meta.ParseError Meta.parse(\"[x)\")\n+            @test_throws Meta.ParseError eval(Meta.parse(\"[x)\", raise=false))\n+            @test_throws Meta.ParseError eval(Meta.parse(\"(x\")) # Expr(:incomplete)\n+        else\n+            @test_throws JuliaSyntax.ParseError Meta.parse(\"[x)\")\n+        end\n+\n+        # Check custom string types defined in a world age later than\n+        # enable_in_core!() can be passed to Meta.parse()\n+        mystr = @eval begin\n+            struct MyString <: AbstractString\n+                x::String\n+            end\n+            Base.String(s::MyString) = s.x\n+            Base.ncodeunits(s::MyString) = ncodeunits(s.x)\n+\n+            MyString(\"hi\")\n+        end\n+        @test Meta.parse(mystr) == :hi\n+\n+        err = Meta.parse(\"\\\"\")\n+        @test Meta.isexpr(err, :incomplete)\n+        if JuliaSyntax._has_v1_10_hooks\n+            @test err.args[1] isa Meta.ParseError\n+            exc = err.args[1]\n+            @test exc.msg == \"ParseError:\\n# Error @ none:1:2\\n\\\"\\n#\u2514 \u2500\u2500 unterminated string literal\"\n+            @test exc.detail isa JuliaSyntax.ParseError\n+            @test exc.detail.incomplete_tag === :string\n+        else\n+            @test err.args[1] isa String\n+        end\n+\n+        JuliaSyntax.enable_in_core!(false)\n+    end\n+\n+    @testset \"Expr(:incomplete)\" begin\n+        for (str, tag) in [\n+                \"\\\"\"           => :string\n+                \"\\\"\\$foo\"      => :string\n+                \"#=\"           => :comment\n+                \"'\"            => :char\n+                \"'a\"           => :char\n+                \"`\"            => :cmd\n+                \"(\"            => :other\n+                \"[\"            => :other\n+                \"begin\"        => :block\n+                \"quote\"        => :block\n+                \"let\"          => :block\n+                \"let;\"         => :block\n+                \"for\"          => :other\n+                \"for x=xs\"     => :block\n+                \"function\"     => :other\n+                \"function f()\" => :block\n+                \"macro\"        => :other\n+                \"macro f()\"    => :block\n+                \"f() do\"       => :other\n+                \"f() do x\"     => :block\n+                \"module\"       => :other\n+                \"module X\"     => :block\n+                \"baremodule\"   => :other\n+                \"baremodule X\" => :block\n+                \"mutable struct\"    => :other\n+                \"mutable struct X\"  => :block\n+                \"struct\"       => :other\n+                \"struct X\"     => :block\n+                \"if\"           => :other\n+                \"if x\"         => :block\n+                \"while\"        => :other\n+                \"while x\"      => :block\n+                \"try\"          => :block\n+                # could be `try x catch exc body end` or `try x catch ; body end`\n+                \"try x catch\"  => :block\n+                \"using\"        => :other\n+                \"import\"       => :other\n+                \"local\"        => :other\n+                \"global\"       => :other\n+\n+                \"1 == 2 ?\"     => :other\n+                \"1 == 2 ? 3 :\" => :other\n+                \"1,\"           => :other\n+                \"1, \"          => :other\n+                \"1,\\n\"         => :other\n+                \"1, \\n\"        => :other\n+                \"f(1, \"        => :other\n+                \"[x \"          => :other\n+                \"( \"           => :other\n+\n+                # Reference parser fails to detect incomplete exprs in this case\n+                \"(x for y\"     => :other\n+\n+                # Syntax which may be an error but is not incomplete\n+                \"\"             => :none\n+                \")\"            => :none\n+                \"1))\"          => :none\n+                \"a b\"          => :none\n+                \"()x\"          => :none\n+                \".\"            => :none\n+\n+                # Some error tokens which cannot be made complete by appending more characters\n+                \"1.e1.\"        => :none\n+                \"\\u200b\"       => :none\n+                \"x #=\\xf5b\\n=#\" => :none\n+                \"\u2081\"            => :none\n+                \"0x1.0\\n\"      => :none\n+                \"\\\"\\$x\u0df4\\\"\"     => :none\n+                \"10e1000\"      => :none\n+\n+                # Multiline input with comments (#519)\n+                \"function f()\\nbody #comment\" => :block\n+                \"a = [\\n1,\\n2, #comment\"      => :other\n+\n+                # Extended set of cases extracted from the REPL stdlib tests.\n+                # There is some redundancy here, but we've mostly left these\n+                # here because incomplete-detection is partly heuristic and\n+                # it's good to have a wide variety of incomplete expressions.\n+                #\n+                # The \"desired\" incomplete tag here was generated from the\n+                # flisp parser.\n+                \"Main.CompletionFoo.\" => :other\n+                \"Base.return_types(getin\" => :other\n+                \"test7().\" => :other\n+                \"(3,2).\" => :other\n+                \"Base.print(\\\"lol\" => :string\n+                \"run(`lol\" => :cmd\n+                \"copy(A').\" => :other\n+                \"cd(\\\"path_to_an_empty_folder_should_not_complete_latex\\\\\\\\\\\\alpha\" => :string\n+                \"\\\"C:\\\\\\\\ \\\\alpha\" => :string\n+                \"cd(\\\"C:\\\\U\" => :string\n+                \"max(\" => :other\n+                \"!(\" => :other\n+                \"!isnothing(\" => :other\n+                \"!!isnothing(\" => :other\n+                \"CompletionFoo.test(1, 1, \" => :other\n+                \"CompletionFoo.test(CompletionFoo.array,\" => :other\n+                \"CompletionFoo.test(1,1,1,\" => :other\n+                \"CompletionFoo.test1(Int,\" => :other\n+                \"CompletionFoo.test1(Float64,\" => :other\n+                \"prevind(\\\"\u03b8\\\",1,\" => :other\n+                \"(1, CompletionFoo.test2(\\\")\\\",\" => :other\n+                \"(1, CompletionFoo.test2(')',\" => :other\n+                \"(1, CompletionFoo.test2(`')'`,\" => :other\n+                \"CompletionFoo.test3([1, 2] .+ CompletionFoo.varfloat,\" => :other\n+                \"CompletionFoo.test3([1.,2.], 1.,\" => :other\n+                \"CompletionFoo.test4(\\\"e\\\",r\\\" \\\",\" => :other\n+                \"CompletionFoo.test5(broadcast((x,y)->x==y, push!(Base.split(\\\"\\\",' '),\\\"\\\",\\\"\\\"), \\\"\\\"),\" => :other\n+                \"CompletionFoo.test5(Bool[x==1 for x=1:4],\" => :other\n+                \"CompletionFoo.test4(CompletionFoo.test_y_array[1]()[1], CompletionFoo.test_y_array[1]()[2], \" => :other\n+                \"CompletionFoo.test4(\\\"\\\\\\\"\\\",\" => :other\n+                \"convert(\" => :other\n+                \"convert(\" => :other\n+                \"CompletionFoo.test5(AbstractArray[Bool[]][1],\" => :other\n+                \"CompletionFoo.test3(@time([1, 2] .+ CompletionFoo.varfloat),\" => :other\n+                \"CompletionFoo.kwtest( \" => :other\n+                \"CompletionFoo.kwtest(;\" => :other\n+                \"CompletionFoo.kwtest(; x=1, \" => :other\n+                \"CompletionFoo.kwtest(; kw=1, \" => :other\n+                \"CompletionFoo.kwtest(x=1, \" => :other\n+                \"CompletionFoo.kwtest(x=1; \" => :other\n+                \"CompletionFoo.kwtest(x=kw=1, \" => :other\n+                \"CompletionFoo.kwtest(; x=kw=1, \" => :other\n+                \"CompletionFoo.kwtest2(1, x=1,\" => :other\n+                \"CompletionFoo.kwtest2(1; x=1, \" => :other\n+                \"CompletionFoo.kwtest2(1, x=1; \" => :other\n+                \"CompletionFoo.kwtest2(1, kw=1, \" => :other\n+                \"CompletionFoo.kwtest2(1; kw=1, \" => :other\n+                \"CompletionFoo.kwtest2(1, kw=1; \" => :other\n+                \"CompletionFoo.kwtest2(y=3, 1, \" => :other\n+                \"CompletionFoo.kwtest2(y=3, 1; \" => :other\n+                \"CompletionFoo.kwtest2(kw=3, 1, \" => :other\n+                \"CompletionFoo.kwtest2(kw=3, 1; \" => :other\n+                \"CompletionFoo.kwtest2(1; \" => :other\n+                \"CompletionFoo.kwtest2(1, \" => :other\n+                \"CompletionFoo.kwtest4(x23=18, x; \" => :other\n+                \"CompletionFoo.kwtest4(x23=18, x, \" => :other\n+                \"CompletionFoo.kwtest4(x23=18, \" => :other\n+                \"CompletionFoo.kwtest5(3, somekwarg=6,\" => :other\n+                \"CompletionFoo.kwtest5(3, somekwarg=6, anything, \" => :other\n+                \"CompletionFoo.?([1,2,3], 2.0\" => :other\n+                \"CompletionFoo.?('c'\" => :other\n+                \"CompletionFoo.?(false, \\\"a\\\", 3, \" => :other\n+                \"CompletionFoo.?(false, \\\"a\\\", 3, \" => :other\n+                \"CompletionFoo.?(\\\"a\\\", 3, \" => :other\n+                \"CompletionFoo.?(; \" => :other\n+                \"CompletionFoo.?(\" => :other\n+                \"CompletionFoo.test10(z, Integer[]...,\" => :other\n+                \"CompletionFoo.test10(3, Integer[]...,\" => :other\n+                \"CompletionFoo.test10(3, 4,\" => :other\n+                \"CompletionFoo.test10(3, 4, 5,\" => :other\n+                \"CompletionFoo.test10(z, z, 0, \" => :other\n+                \"CompletionFoo.test10(\\\"a\\\", Union{Signed,Bool,String}[3][1], \" => :other\n+                \"CompletionFoo.test11(Integer[false][1], Integer[14][1], \" => :other\n+                \"CompletionFoo.test11(Integer[-7][1], Integer[0x6][1], 6,\" => :other\n+                \"CompletionFoo.test11(3, 4,\" => :other\n+                \"CompletionFoo.test11(0x8, 5,\" => :other\n+                \"CompletionFoo.test11(0x8, 'c',\" => :other\n+                \"CompletionFoo.test11('d', 3,\" => :other\n+                \"CompletionFoo.test!12(\" => :other\n+                \"CompletionFoo.kwtest(; x=2, y=4; kw=3, \" => :other\n+                \"CompletionFoo.kwtest(x=2; y=4; \" => :other\n+                \"CompletionFoo.kwtest((x=y)=4, \" => :other\n+                \"CompletionFoo.kwtest(; (x=y)=4, \" => :other\n+                \"CompletionFoo.kwtest(; w...=16, \" => :other\n+                \"CompletionFoo.kwtest(; 2, \" => :other\n+                \"CompletionFoo.kwtest(; 2=3, \" => :other\n+                \"CompletionFoo.kwtest3(im; (true ? length : length), \" => :other\n+                \"CompletionFoo.kwtest.(x=2; y=4; \" => :other\n+                \"CompletionFoo.kwtest.(; w...=16, \" => :other\n+                \"(1+2im).\" => :other\n+                \"((1+2im)).\" => :other\n+                \"CompletionFoo.test_y_array[1].\" => :other\n+                \"CompletionFoo.named.\" => :other\n+                \"#=\\n\\\\alpha\" => :comment\n+                \"#=\\nmax\" => :comment\n+                \"using \" => :other\n+                \"(max\" => :other\n+                \"@show \\\"/dev/nul\" => :string\n+                \"@show \\\"/tm\" => :string\n+                \"@show \\\"/dev/nul\" => :string\n+                \"(Iter\" => :other\n+                \"\\\"/tmp/jl_4sjOtz/tmpfoob\" => :string\n+                \"\\\"~\" => :string\n+                \"\\\"~user\" => :string\n+                \"\\\"/tmp/jl_Mn9Rbz/selfsym\" => :string\n+                \"\\\"~/ka8w5rsz\" => :string\n+                \"\\\"foo~bar\" => :string\n+                \"\\\"~/Zx6Wa0GkC\" => :string\n+                \"\\\"~/Zx6Wa0GkC0\" => :string\n+                \"\\\"~/Zx6Wa0GkC0/my_\" => :string\n+                \"\\\"~/Zx6Wa0GkC0/my_file\" => :string\n+                \"cd(\\\"folder_do_not_exist_77/file\" => :string\n+                \"CompletionFoo.tuple.\" => :other\n+                \"CompletionFoo.test_dict[\\\"ab\" => :string\n+                \"CompletionFoo.test_dict[\\\"abcd\" => :string\n+                \"CompletionFoo.test_dict[ \\\"abcd\" => :string\n+                \"CompletionFoo.test_dict[\\\"abcd\" => :string\n+                \"CompletionFoo.test_dict[:b\" => :other\n+                \"CompletionFoo.test_dict[:bar2\" => :other\n+                \"CompletionFoo.test_dict[Ba\" => :other\n+                \"CompletionFoo.test_dict[occ\" => :other\n+                \"CompletionFoo.test_dict[`l\" => :cmd\n+                \"CompletionFoo.test_dict[6\" => :other\n+                \"CompletionFoo.test_dict[66\" => :other\n+                \"CompletionFoo.test_dict[(\" => :other\n+                \"CompletionFoo.test_dict[\\\"\\\\alp\" => :string\n+                \"CompletionFoo.test_dict[\\\"\\\\alpha\" => :string\n+                \"CompletionFoo.test_dict[\\\"\u03b1\" => :string\n+                \"CompletionFoo.test_dict[:\u03b1\" => :other\n+                \"CompletionFoo.test_dict[\" => :other\n+                \"CompletionFoo.test_customdict[\\\"ab\" => :string\n+                \"CompletionFoo.test_customdict[\\\"abcd\" => :string\n+                \"CompletionFoo.test_customdict[ \\\"abcd\" => :string\n+                \"CompletionFoo.test_customdict[\\\"abcd\" => :string\n+                \"CompletionFoo.test_customdict[:b\" => :other\n+                \"CompletionFoo.test_customdict[:bar2\" => :other\n+                \"CompletionFoo.test_customdict[Ba\" => :other\n+                \"CompletionFoo.test_customdict[occ\" => :other\n+                \"CompletionFoo.test_customdict[`l\" => :cmd\n+                \"CompletionFoo.test_customdict[6\" => :other\n+                \"CompletionFoo.test_customdict[66\" => :other\n+                \"CompletionFoo.test_customdict[(\" => :other\n+                \"CompletionFoo.test_customdict[\\\"\\\\alp\" => :string\n+                \"CompletionFoo.test_customdict[\\\"\\\\alpha\" => :string\n+                \"CompletionFoo.test_customdict[\\\"\u03b1\" => :string\n+                \"CompletionFoo.test_customdict[:\u03b1\" => :other\n+                \"CompletionFoo.test_customdict[\" => :other\n+                \"test_repl_comp_dict[\\\"ab\" => :string\n+                \"test_repl_comp_dict[\\\"abcd\" => :string\n+                \"test_repl_comp_dict[ \\\"abcd\" => :string\n+                \"test_repl_comp_dict[\\\"abcd\" => :string\n+                \"test_repl_comp_dict[:b\" => :other\n+                \"test_repl_comp_dict[:bar2\" => :other\n+                \"test_repl_comp_dict[Ba\" => :other\n+                \"test_repl_comp_dict[occ\" => :other\n+                \"test_repl_comp_dict[`l\" => :cmd\n+                \"test_repl_comp_dict[6\" => :other\n+                \"test_repl_comp_dict[66\" => :other\n+                \"test_repl_comp_dict[(\" => :other\n+                \"test_repl_comp_dict[\\\"\\\\alp\" => :string\n+                \"test_repl_comp_dict[\\\"\\\\alpha\" => :string\n+                \"test_repl_comp_dict[\\\"\u03b1\" => :string\n+                \"test_repl_comp_dict[:\u03b1\" => :other\n+                \"test_repl_comp_dict[\" => :other\n+                \"test_repl_comp_customdict[\\\"ab\" => :string\n+                \"test_repl_comp_customdict[\\\"abcd\" => :string\n+                \"test_repl_comp_customdict[ \\\"abcd\" => :string\n+                \"test_repl_comp_customdict[\\\"abcd\" => :string\n+                \"test_repl_comp_customdict[:b\" => :other\n+                \"test_repl_comp_customdict[:bar2\" => :other\n+                \"test_repl_comp_customdict[Ba\" => :other\n+                \"test_repl_comp_customdict[occ\" => :other\n+                \"test_repl_comp_customdict[`l\" => :cmd\n+                \"test_repl_comp_customdict[6\" => :other\n+                \"test_repl_comp_customdict[66\" => :other\n+                \"test_repl_comp_customdict[(\" => :other\n+                \"test_repl_comp_customdict[\\\"\\\\alp\" => :string\n+                \"test_repl_comp_customdict[\\\"\\\\alpha\" => :string\n+                \"test_repl_comp_customdict[\\\"\u03b1\" => :string\n+                \"test_repl_comp_customdict[:\u03b1\" => :other\n+                \"test_repl_comp_customdict[\" => :other\n+                \"CompletionFoo.kwtest3(a;foob\" => :other\n+                \"CompletionFoo.kwtest3(a; le\" => :other\n+                \"CompletionFoo.kwtest3.(a;\\nlength\" => :other\n+                \"CompletionFoo.kwtest3(a, length=4, l\" => :other\n+                \"CompletionFoo.kwtest3(a; kwargs..., fo\" => :other\n+                \"CompletionFoo.kwtest3(a; another!kwarg=0, le\" => :other\n+                \"CompletionFoo.kwtest3(a; another!\" => :other\n+                \"CompletionFoo.kwtest3(a; another!kwarg=0, foob\" => :other\n+                \"CompletionFoo.kwtest3(a; namedarg=0, foob\" => :other\n+                \"kwtest3(blabla; unknown=4, namedar\" => :other\n+                \"kwtest3(blabla; named\" => :other\n+                \"kwtest3(blabla; named.\" => :other\n+                \"kwtest3(blabla; named..., another!\" => :other\n+                \"kwtest3(blabla; named..., len\" => :other\n+                \"kwtest3(1+3im; named\" => :other\n+                \"kwtest3(1+3im; named.\" => :other\n+                \"CompletionFoo.kwtest4(a; x23=0, _\" => :other\n+                \"CompletionFoo.kwtest4(a; x\u03b1\u03b2\u03b3=1, _\" => :other\n+                \"CompletionFoo.kwtest4.(a; x\u03b1\u03b2\u03b3=1, _\" => :other\n+                \"CompletionFoo.kwtest4(a; x23=0, x\" => :other\n+                \"CompletionFoo.kwtest4.(a; x23=0, x\" => :other\n+                \"CompletionFoo.kwtest4(a; _a1b=1, x\" => :other\n+                \"CompletionFoo.kwtest5(3, 5; somek\" => :other\n+                \"CompletionFoo.kwtest5(3, 5, somekwarg=4, somek\" => :other\n+                \"CompletionFoo.kwtest5(3, 5, 7; somekw\" => :other\n+                \"CompletionFoo.kwtest5(3, 5, 7, 9; somekw\" => :other\n+                \"CompletionFoo.kwtest5(3, 5, 7, 9, Any[]...; somek\" => :other\n+                \"CompletionFoo.kwtest5(unknownsplat...; somekw\" => :other\n+                \"CompletionFoo.kwtest5(3, 5, 7, 9, somekwarg=4, somek\" => :other\n+                \"CompletionFoo.kwtest5(String[]..., unknownsplat...; xy\" => :other\n+                \"CompletionFoo.kwtest5('a', unknownsplat...; xy\" => :other\n+                \"CompletionFoo.kwtest5('a', 3, String[]...; xy\" => :other\n+                \"CompletionFoo.kwtest3(\" => :other\n+                \"CompletionFoo.kwtest3(a;\" => :other\n+                \"CompletionFoo.kwtest3(a; len2=\" => :other\n+                \"CompletionFoo.kwtest3(a; len2=le\" => :other\n+                \"CompletionFoo.kwtest3(a; len2=3 \" => :other\n+                \"CompletionFoo.kwtest3(a; [le\" => :other\n+                \"CompletionFoo.kwtest3([length; le\" => :other\n+                \"CompletionFoo.kwtest3(a; (le\" => :other\n+                \"CompletionFoo.kwtest3(a; foo(le\" => :other\n+                \"CompletionFoo.kwtest3(a; (; le\" => :other\n+                \"CompletionFoo.kwtest3(a; length, \" => :other\n+                \"CompletionFoo.kwtest3(a; kwargs..., \" => :other\n+                \":(function foo(::Int) end).args[1].args[2].\" => :other\n+                \"log(log.(varfloat),\" => :other\n+                \"Base.return_types(getin\" => :other\n+                \"test(1,1, \" => :other\n+                \"test.(1,1, \" => :other\n+                \"prevind(\\\"\u03b8\\\",1,\" => :other\n+                \"typeof(+).\" => :other\n+                \"test_dict[\\\"ab\" => :string\n+                \"CompletionFoo.x.\" => :other\n+                \"@noexist.\" => :other\n+                \"Main.@noexist.\" => :none # <- Invalid syntax which adding a suffix can't fix\n+                \"@Main.noexist.\" => :other\n+                \"@show.\" => :other\n+                \"@macroexpand.\" => :other\n+                \"CompletionFoo.@foobar().\" => :other\n+                \"CompletionFoo.@foobar(4).\" => :other\n+                \"foo(#=#==#=##==#).rs[1].\" => :other\n+                \"foo().r.\" => :other\n+                \"foo(#=#=# =#= =#).r.\" => :other\n+                \"test_47594.\" => :other\n+                \"Issue36437(42).\" => :other\n+                \"Some(Issue36437(42)).value.\" => :other\n+                \"some_issue36437.value.\" => :other\n+                \"some_issue36437.value.a, some_issue36437.value.\" => :other\n+                \"@show some_issue36437.value.a; some_issue36437.value.\" => :other\n+                \"().\" => :other\n+                \"Ref(Issue36437(42))[].\" => :other\n+                \"global_dict[:r].\" => :other\n+                \"global_dict_nested[:g][:r].\" => :other\n+                \"global_dict_nested[\" => :other\n+                \"global_dict_nested[:g][\" => :other\n+                \"pop!(global_xs).\" => :other\n+                \"tcd1.\" => :other\n+                \"tcd1.x.\" => :other\n+                \"tcd1.x.v.\" => :other\n+                \"getkeyelem(mutable_const_prop).\" => :other\n+                \"getkeyelem(mutable_const_prop).value.\" => :other\n+                \"var\\\"complicated \" => :string\n+                \"WeirdNames().var\\\"oh \" => :string\n+                \"WeirdNames().var\\\"\" => :string\n+                \"\\\"abc\\\".\" => :other\n+                \"(rand(Bool) ? issue51499_2_1 : issue51499_2_2).\" => :other\n+                \"union_somes(1, 1.0).\" => :other\n+                \"union_some_ref(1, 1.0).\" => :other\n+                \"Issue49892(fal\" => :other\n+                \"-CompletionFoo.Test_y(3).\" => :other\n+                \"99 \u2a37\u207b\u1d68\u2077 CompletionFoo.type_test.\" => :other\n+                \"CompletionFoo.type_test + CompletionFoo.Test_y(2).\" => :other\n+                \"(CompletionFoo.type_test + CompletionFoo.Test_y(2)).\" => :other\n+                \"CompletionFoo.type_test + CompletionFoo.unicode_\u03b1\u03b2\u03b3.\" => :other\n+                \"(CompletionFoo.type_test + CompletionFoo.unicode_\u03b1\u03b2\u03b3).\" => :other\n+                \"using Base.\" => :other\n+                \"@time(using .Iss\" => :other\n+                \"using .Issue52922.Inner1.\" => :other\n+                \"Issue53126().\" => :other\n+                \"using \" => :other\n+                \"global xxx::Number = Base.\" => :other\n+                \"let x = 1 # comment\" => :other\n+            ]\n+            @testset \"$(repr(str))\" begin\n+                # Test :statement parsing\n+                ex = JuliaSyntax.core_parser_hook(str, \"somefile\", 1, 0, :statement)[1]\n+                @test Base.incomplete_tag(ex) == tag\n+                # Test :all parsing - this is what the REPL uses to parse user input.\n+                ex = JuliaSyntax.core_parser_hook(str, \"somefile\", 1, 0, :all)[1]\n+                @test ex.head == :toplevel\n+                @test Base.incomplete_tag(ex.args[end]) == tag\n+            end\n+        end\n+\n+        # Should not throw\n+        @test JuliaSyntax.core_parser_hook(\"+=\", \"somefile\", 1, 0, :statement)[1] isa Expr\n+    end\n+end"
    },
    {
      "sha": "5179544ec15d3b8778cfa99578e0c9e41429c877",
      "filename": "JuliaSyntax/test/kinds.jl",
      "status": "added",
      "additions": 59,
      "deletions": 0,
      "changes": 59,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fkinds.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fkinds.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fkinds.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,59 @@\n+# Only test this once per session, as kind modules must be unique (ugh)\n+if !isdefined(@__MODULE__, :FooKinds)\n+@eval module FooKinds\n+\n+using ..JuliaSyntax\n+\n+function _init_kinds()\n+    JuliaSyntax.register_kinds!(@__MODULE__, 42, [\n+        \"BEGIN_FOO\"\n+        \"foo_1\"\n+        \"foo_2\"\n+        \"BEGIN_FOOBAR\"\n+        \"foobar_1\"\n+        \"foobar_2\"\n+        \"END_FOOBAR\"\n+        \"END_FOO\"\n+    ])\n+end\n+\n+_init_kinds()\n+\n+k_before_init = K\"foo_1\"\n+\n+function __init__()\n+    _init_kinds()\n+end\n+\n+end\n+\n+@eval module BarKinds\n+    # Intentionally empty\n+end\n+\n+end\n+\n+@testset \"Kinds\" begin\n+    @test K\"foo_1\" != K\"foo_2\"\n+\n+    @test FooKinds.k_before_init == K\"foo_1\"\n+\n+    @test K\"BEGIN_FOO\" == K\"foo_1\"\n+    @test K\"foo_2\" < K\"BEGIN_FOOBAR\"\n+    @test K\"BEGIN_FOOBAR\" == K\"foobar_1\"\n+    @test K\"END_FOOBAR\" == K\"foobar_2\"\n+    @test K\"END_FOO\" == K\"foobar_2\"\n+\n+    @test parentmodule(K\"foo_1\") == FooKinds\n+    @test sprint(show, K\"foo_1\") == \"K\\\"foo_1\\\"\"\n+\n+    # Too many kind modules\n+    @test_throws ErrorException JuliaSyntax.register_kinds!(BarKinds, 64, [\"hoo?\"])\n+    # Too many kind names per module\n+    @test_throws ErrorException JuliaSyntax.register_kinds!(BarKinds, 42, string.(1:1024))\n+    # Re-registering or registering new kinds is not supported\n+    @test_throws ErrorException JuliaSyntax.register_kinds!(FooKinds, 42, [\"foo_2\", \"foo_1\"])\n+    @test_throws ErrorException JuliaSyntax.register_kinds!(FooKinds, 42, [\"foo_3\"])\n+    # Module ID already taken by FooKinds\n+    @test_throws ErrorException JuliaSyntax.register_kinds!(BarKinds, 42, [\"hii?\"])\n+end"
    },
    {
      "sha": "bfb8e932458adf59e24427a9bd98df680264b8c8",
      "filename": "JuliaSyntax/test/literal_parsing.jl",
      "status": "added",
      "additions": 256,
      "deletions": 0,
      "changes": 256,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fliteral_parsing.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fliteral_parsing.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fliteral_parsing.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,256 @@\n+using .JuliaSyntax:\n+    parse_int_literal,\n+    parse_uint_literal,\n+    parse_float_literal,\n+    unescape_julia_string\n+\n+@testset \"Float parsing\" begin\n+    # Float64\n+    @test parse_float_literal(Float64, \"123\", 1, 4)   === (123.0, :ok)\n+    @test parse_float_literal(Float64, \"123\", 2, 4)   === (23.0,  :ok)\n+    @test parse_float_literal(Float64, \"123\", 2, 3)   === (2.0,   :ok)\n+    @test parse_float_literal(Float64, \"1.3\", 1, 4)   === (1.3,   :ok)\n+    @test parse_float_literal(Float64, \"1.3e2\", 1, 6) === (1.3e2, :ok)\n+    @test parse_float_literal(Float64, \"1.3E2\", 1, 6) === (1.3e2, :ok)\n+    @test parse_float_literal(Float64, \"1.0e-1000\", 1, 10) === (0.0, :underflow)\n+    @test parse_float_literal(Float64, \"1.0e+1000\", 1, 10) === (Inf, :overflow)\n+    # Slow path (exceeds static buffer size)\n+    @test parse_float_literal(Float64, \"0.000000000000000000000000000000000000000000000000000000000001\", 1, 63) === (1e-60, :ok)\n+    # hexfloat\n+    @test parse_float_literal(Float64, \"0x0ap-0\", 1, 8) === (Float64(10), :ok)\n+    @test parse_float_literal(Float64, \"0xffp-0\", 1, 8) === (Float64(255), :ok)\n+\n+    # Float32\n+    @test parse_float_literal(Float32, \"123\", 1, 4) === (123.0f0, :ok)\n+    @test parse_float_literal(Float32, \"1.3f2\", 1, 6) === (1.3f2, :ok)\n+    if !Sys.iswindows()\n+        @test parse_float_literal(Float32, \"1.0f-50\", 1, 8) === (0.0f0, :underflow)\n+    end\n+    @test parse_float_literal(Float32, \"1.0f+50\", 1, 8) === (Inf32, :overflow)\n+\n+    # Assertions\n+    @test_throws ErrorException parse_float_literal(Float64, \"x\", 1, 2)\n+    @test_throws ErrorException parse_float_literal(Float64, \"1x\", 1, 3)\n+\n+    # Underscore and \\minus allowed\n+    @test parse_float_literal(Float64, \"10_000.0_0\", 1, 9) === (Float64(10000), :ok)\n+    @test parse_float_literal(Float64, \"\u221210.0\", 1, 8)      === (Float64(-10), :ok)\n+    @test parse_float_literal(Float64, \"10e\\u22121\", 1, 8) === (Float64(1), :ok)\n+end\n+\n+hexint(s) = parse_uint_literal(s, K\"HexInt\")\n+binint(s) = parse_uint_literal(s, K\"BinInt\")\n+octint(s) = parse_uint_literal(s, K\"OctInt\")\n+\n+@testset \"Integer parsing\" begin\n+    # Integers\n+    @testset \"Signed Integers\" begin\n+        @test parse_int_literal(\"-1\") isa Int\n+        @test parse_int_literal(\"1\") isa Int\n+        @test parse_int_literal(\"2147483647\") isa Int\n+        @test parse_int_literal(\"9223372036854775807\") isa Int64\n+        @test parse_int_literal(\"9223372036854775808\") isa Int128\n+        @test parse_int_literal(\"170141183460469231731687303715884105727\") isa Int128\n+        @test parse_int_literal(\"170141183460469231731687303715884105728\") isa BigInt\n+    end\n+\n+    # HexInt\n+    @testset \"HexInt numeric limits for different types\" begin\n+        @test hexint(\"0xff\")  === UInt8(0xff)\n+        @test hexint(\"0x100\") === UInt16(0x100)\n+        @test hexint(\"0xffff\") === UInt16(0xffff)\n+        @test hexint(\"0x10000\") === UInt32(0x10000)\n+        @test hexint(\"0xffffffff\") === UInt32(0xffffffff)\n+        @test hexint(\"0x100000000\") === UInt64(0x100000000)\n+        @test hexint(\"0xffffffffffffffff\") === UInt64(0xffffffffffffffff)\n+        @test hexint(\"0x10000000000000000\") === UInt128(0x10000000000000000)\n+        @test hexint(\"0xffffffffffffffffffffffffffffffff\") === UInt128(0xffffffffffffffffffffffffffffffff)\n+        @test (n = hexint(\"0x100000000000000000000000000000000\");\n+               n isa BigInt && n == big\"0x100000000000000000000000000000000\")\n+    end\n+    @testset \"HexInt string length limits for different types\" begin\n+        @test hexint(\"0x00\")  === UInt8(0)\n+        @test hexint(\"0x000\")  === UInt16(0)\n+        @test hexint(\"0x0000\")  === UInt16(0)\n+        @test hexint(\"0x00000\")  === UInt32(0)\n+        @test hexint(\"0x00000000\") === UInt32(0)\n+        @test hexint(\"0x000000000\") === UInt64(0)\n+        @test hexint(\"0x0000000000000000\") === UInt64(0)\n+        @test hexint(\"0x00000000000000000\") === UInt128(0)\n+        @test hexint(\"0x00000000000000000000000000000000\") === UInt128(0)\n+        @test (n = hexint(\"0x000000000000000000000000000000000\");\n+               n isa BigInt && n == 0)\n+    end\n+\n+    # BinInt\n+    @testset \"BinInt numeric limits for different types\" begin\n+        @test binint(\"0b11111111\")  === UInt8(0xff)\n+        @test binint(\"0b100000000\") === UInt16(0x100)\n+        @test binint(\"0b1111111111111111\") === UInt16(0xffff)\n+        @test binint(\"0b10000000000000000\") === UInt32(0x10000)\n+        @test binint(\"0b11111111111111111111111111111111\") === UInt32(0xffffffff)\n+        @test binint(\"0b100000000000000000000000000000000\") === UInt64(0x100000000)\n+        @test binint(\"0b1111111111111111111111111111111111111111111111111111111111111111\") === UInt64(0xffffffffffffffff)\n+        @test binint(\"0b10000000000000000000000000000000000000000000000000000000000000000\") === UInt128(0x10000000000000000)\n+        @test binint(\"0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\") === UInt128(0xffffffffffffffffffffffffffffffff)\n+        @test (n = binint(\"0b100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\");\n+               n isa BigInt && n == big\"0x100000000000000000000000000000000\")\n+    end\n+    @testset \"BinInt string length limits for different types\" begin\n+        @test binint(\"0b00000000\")  === UInt8(0)\n+        @test binint(\"0b000000000\")  === UInt16(0)\n+        @test binint(\"0b0000000000000000\")  === UInt16(0)\n+        @test binint(\"0b00000000000000000\")  === UInt32(0)\n+        @test binint(\"0b00000000000000000000000000000000\") === UInt32(0)\n+        @test binint(\"0b000000000000000000000000000000000\") === UInt64(0)\n+        @test binint(\"0b0000000000000000000000000000000000000000000000000000000000000000\") === UInt64(0)\n+        @test binint(\"0b00000000000000000000000000000000000000000000000000000000000000000\") === UInt128(0)\n+        @test binint(\"0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\") === UInt128(0)\n+        @test (n = binint(\"0b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\");\n+               n isa BigInt && n == 0)\n+    end\n+\n+    # OctInt\n+    @testset \"OctInt numeric limits for different types\" begin\n+        @test octint(\"0o377\")  === UInt8(0xff)\n+        @test octint(\"0o400\") === UInt16(0x100)\n+        @test octint(\"0o177777\") === UInt16(0xffff)\n+        @test octint(\"0o200000\") === UInt32(0x10000)\n+        @test octint(\"0o37777777777\") === UInt32(0xffffffff)\n+        @test octint(\"0o40000000000\") === UInt64(0x100000000)\n+        @test octint(\"0o1777777777777777777777\") === UInt64(0xffffffffffffffff)\n+        @test octint(\"0o2000000000000000000000\") === UInt128(0x10000000000000000)\n+        @test octint(\"0o3777777777777777777777777777777777777777777\") === UInt128(0xffffffffffffffffffffffffffffffff)\n+        @test (n = octint(\"0o4000000000000000000000000000000000000000000\");\n+               n isa BigInt && n == big\"0x100000000000000000000000000000000\")\n+    end\n+    @testset \"OctInt string length limits for different types\" begin\n+        @test octint(\"0o000\")  === UInt8(0)\n+        @test octint(\"0o0000\")  === UInt16(0)\n+        @test octint(\"0o000000\")  === UInt16(0)\n+        @test octint(\"0o0000000\")  === UInt32(0)\n+        @test octint(\"0o00000000000\") === UInt32(0)\n+        @test octint(\"0o000000000000\") === UInt64(0)\n+        @test octint(\"0o0000000000000000000000\") === UInt64(0)\n+        @test octint(\"0o00000000000000000000000\") === UInt128(0)\n+        @test octint(\"0o0000000000000000000000000000000000000000000\") === UInt128(0)\n+        @test (n = octint(\"0o00000000000000000000000000000000000000000000\");\n+               n isa BigInt && n == 0)\n+    end\n+\n+    @testset \"Underscore separators\" begin\n+        @test parse_int_literal(\"10_000\") === 10000\n+        @test parse_uint_literal(\"0xff_ff\",     K\"HexInt\")  === 0xffff\n+        @test parse_uint_literal(\"0b1111_1111\", K\"BinInt\")  === 0xff\n+        @test parse_uint_literal(\"0o177_777\",   K\"OctInt\")  === 0xffff\n+    end\n+\n+    @testset \"\\\\minus ('\\\\u2212' / '\u2212') allowed in numbers\" begin\n+        @test parse_int_literal(\"\u221210\")  === -10\n+    end\n+end\n+\n+function unesc(str, firstind=firstindex(str), endind=lastindex(str)+1; diagnostics=false)\n+    io = IOBuffer()\n+    ds = JuliaSyntax.Diagnostic[]\n+    unescape_julia_string(io, Vector{UInt8}(str), firstind, endind, ds)\n+    if diagnostics\n+        ds\n+    else\n+        @test isempty(ds)\n+        String(take!(io))\n+    end\n+end\n+\n+@testset \"String unescaping\" begin\n+    # offsets\n+    @test unesc(\"abcd\", 1, 3) == \"ab\"\n+    @test unesc(\"abcd\", 2, 4) == \"bc\"\n+    @test unesc(\"abcd\", 3, 5) == \"cd\"\n+\n+    # Allowed escapes of delimiters and dollar sign\n+    @test unesc(\"\\\\\\\\\") == \"\\\\\"\n+    @test unesc(\"\\\\\\\"\") == \"\\\"\"\n+    @test unesc(\"\\\\\\$\") == \"\\$\"\n+    @test unesc(\"\\\\'\")  == \"\\'\"\n+    @test unesc(\"\\\\`\")  == \"`\"\n+\n+    # Newline normalization\n+    @test unesc(\"a\\nb\\rc\\r\\nd\") == \"a\\nb\\nc\\nd\"\n+\n+    # Invalid escapes\n+    @test !isempty(unesc(\"\\\\.\", diagnostics=true))\n+    @test !isempty(unesc(\"\\\\z\", diagnostics=true))\n+\n+    # Standard C escape sequences\n+    @test codeunits(unesc(\"\\\\n\\\\t\\\\r\\\\e\\\\b\\\\f\\\\v\\\\a\")) ==\n+        UInt8[0x0a, 0x09, 0x0d, 0x1b, 0x08, 0x0c, 0x0b, 0x07]\n+\n+    # Hex and unicode escapes; \\x \\u and \\U\n+    @test unesc(\"x\\\\x61x\") == \"xax\"\n+    @test unesc(\"x\\\\u03b1x\") == \"x\u03b1x\"\n+    @test unesc(\"x\\\\U001F604x\") == \"x\ud83d\ude04x\"\n+    # Maximum unicode code point\n+    @test unesc(\"x\\\\U10ffffx\") == \"x\\U10ffffx\"\n+    @test !isempty(unesc(\"x\\\\U110000x\", diagnostics=true))\n+\n+    # variable-length octal\n+    @test unesc(\"x\\\\7x\") == \"x\\ax\"\n+    @test unesc(\"x\\\\77x\") == \"x?x\"\n+    @test unesc(\"x\\\\141x\") == \"xax\"\n+    @test unesc(\"x\\\\377x\") == \"x\\xffx\"\n+    @test !isempty(unesc(\"x\\\\400x\", diagnostics=true))\n+end\n+\n+function unesc_raw(str, is_cmd)\n+    io = IOBuffer()\n+    JuliaSyntax.unescape_raw_string(io, Vector{UInt8}(str),\n+                                    firstindex(str), lastindex(str)+1, is_cmd)\n+    return String(take!(io))\n+end\n+\n+@testset \"Raw string unescaping\" begin\n+    # \" delimited\n+    # x\\\"x ==> x\"x\n+    @test unesc_raw(\"x\\\\\\\"x\",     false) == \"x\\\"x\"\n+    # x\\`x ==> x\\`x\n+    @test unesc_raw(\"x\\\\`x\",      false) == \"x\\\\`x\"\n+    # x\\\\\\\"x ==> x\\\"x\n+    @test unesc_raw(\"x\\\\\\\\\\\\\\\"x\", false) == \"x\\\\\\\"x\"\n+    # x\\\\\\`x ==> x\\\\\\`x\n+    @test unesc_raw(\"x\\\\\\\\\\\\`x\",  false) == \"x\\\\\\\\\\\\`x\"\n+    # '\\\\ ' ==> '\\\\ '\n+    @test unesc_raw(\"\\\\\\\\ \",      false) == \"\\\\\\\\ \"\n+    # '\\\\' ==> '\\'\n+    @test unesc_raw(\"\\\\\\\\\",       false) == \"\\\\\"\n+    # '\\\\\\\\' ==> '\\\\'\n+    @test unesc_raw(\"\\\\\\\\\\\\\\\\\",   false) == \"\\\\\\\\\"\n+\n+    # ` delimited\n+    # x\\\"x ==> x\\\"x\n+    @test unesc_raw(\"x\\\\\\\"x\",     true) == \"x\\\\\\\"x\"\n+    # x\\`x ==> x`x\n+    @test unesc_raw(\"x\\\\`x\",      true)  == \"x`x\"\n+    # x\\\\\\\"x ==> x\\\"x\n+    @test unesc_raw(\"x\\\\\\\\\\\\\\\"x\", true) == \"x\\\\\\\\\\\\\\\"x\"\n+    # x\\\\\\`x ==> x\\`x\n+    @test unesc_raw(\"x\\\\\\\\\\\\`x\",  true) == \"x\\\\`x\"\n+    # '\\\\ ' ==> '\\\\ '\n+    @test unesc_raw(\"\\\\\\\\ \",      true) == \"\\\\\\\\ \"\n+end\n+\n+@testset \"Normalization of identifiers\" begin\n+    # NFC normalization\n+    # https://github.com/JuliaLang/julia/issues/5434\n+    # https://github.com/JuliaLang/julia/pull/19464\n+    @test JuliaSyntax.normalize_identifier(\"\\u0069\\u0302\") == \"\\u00ee\"\n+\n+    # Special Julia normalization\n+    # https://github.com/JuliaLang/julia/pull/42561\n+    @test JuliaSyntax.normalize_identifier(\"julia\\u025B\\u00B5\\u00B7\\u0387\\u2212\") ==\n+        \"julia\\u03B5\\u03BC\\u22C5\\u22C5\\u002D\"\n+\n+    # https://github.com/JuliaLang/julia/issues/48870\n+    # \u210f -> \u0127\n+    @test JuliaSyntax.normalize_identifier(\"\\u210f\") == \"\\u0127\"\n+end"
    },
    {
      "sha": "b5b08f488a918cf6665cb685a51df6aae46925e5",
      "filename": "JuliaSyntax/test/parse_packages.jl",
      "status": "added",
      "additions": 79,
      "deletions": 0,
      "changes": 79,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fparse_packages.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fparse_packages.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fparse_packages.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,79 @@\n+# Full-scale parsing tests of JuliaSyntax itself, Julia Base, etc.\n+\n+juliasyntax_dir = joinpath(@__DIR__, \"..\")\n+@testset \"Parse JuliaSyntax\" begin\n+    test_parse_all_in_path(joinpath(juliasyntax_dir, \"src\"))\n+end\n+@testset \"Parse JuliaSyntax tests\" begin\n+    test_parse_all_in_path(joinpath(juliasyntax_dir, \"test\"))\n+end\n+\n+base_path = let\n+    p = joinpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\", \"base\")\n+    if !isdir(p)\n+        # For julia 1.9 images.\n+        p = joinpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\", \"src\", \"base\")\n+        if !isdir(p)\n+            error(\"source for Julia base not found\")\n+        end\n+    end\n+    p\n+end\n+@testset \"Parse Base at $base_path\" begin\n+    test_parse_all_in_path(base_path) do f\n+        if endswith(f, \"gmp.jl\")\n+            # Loose comparison due to `f(::g(w) = z) = a` syntax\n+            return exprs_roughly_equal\n+        end\n+        return exprs_equal_no_linenum\n+    end\n+end\n+\n+base_tests_path = joinpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\", \"test\")\n+@testset \"Parse Base tests at $base_tests_path\" begin\n+    test_parse_all_in_path(base_tests_path) do f\n+        # In julia-1.6, test/copy.jl had spurious syntax which became the\n+        # multidimensional array syntax in 1.7.\n+        if endswith(f, \"copy.jl\") && v\"1.6\" <= VERSION < v\"1.7\"\n+            return nothing\n+        end\n+\n+        # syntax.jl has some intentionally weird syntax which we parse\n+        # differently than the flisp parser, and some cases which we've\n+        # decided are syntax errors.\n+        if endswith(f, \"syntax.jl\")\n+            return nothing\n+        end\n+\n+        if endswith(f, \"core.jl\")\n+            # The test\n+            # @test Union{Tuple{T}, Tuple{T,Int}} where {T} === widen_diagonal(Union{Tuple{T}, Tuple{T,Int}} where {T})\n+            # depends on a JuliaSyntax bugfix and parses differently (wrong) using\n+            # flisp. This was added in julia#52228 and backported in julia#52045\n+            if v\"1.10.0-rc1.39\" <= VERSION\n+                return nothing\n+            else\n+                # Loose comparison due to `for f() = 1:3` syntax\n+                return exprs_roughly_equal\n+            end\n+        end\n+\n+        # subtype.jl also depends on the where precedence JuliaSyntax bugfix as of julia#53034\n+        if endswith(f, \"subtype.jl\") && v\"1.11.0-DEV.1382\" <= VERSION\n+            return nothing\n+        end\n+\n+        return exprs_equal_no_linenum\n+    end\n+end\n+\n+@testset \"Parse Julia stdlib at $(Sys.STDLIB)\" begin\n+    for stdlib in readdir(Sys.STDLIB)\n+        fulldir = joinpath(Sys.STDLIB, stdlib)\n+        if isdir(fulldir)\n+            @testset \"Parse $stdlib\" begin\n+                test_parse_all_in_path(joinpath(Sys.STDLIB, fulldir))\n+            end\n+        end\n+    end\n+end"
    },
    {
      "sha": "cda8443be113aca055f637b3aee8ace1aa16a6ee",
      "filename": "JuliaSyntax/test/parse_stream.jl",
      "status": "added",
      "additions": 168,
      "deletions": 0,
      "changes": 168,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fparse_stream.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fparse_stream.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fparse_stream.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,168 @@\n+# Prototype ParseStream interface\n+#\n+# Here we test the ParseStream interface, by taking input code and checking\n+# that the correct sequence of emit() and bump() produces a valid parse tree.\n+\n+using .JuliaSyntax: ParseStream,\n+    peek, peek_token,\n+    bump, bump_trivia, bump_invisible,\n+    emit, emit_diagnostic, TRIVIA_FLAG, INFIX_FLAG,\n+    ParseStreamPosition, first_child_position, last_child_position,\n+    parsestmt\n+\n+# Here we manually issue parse events in the order the Julia parser would issue\n+# them\n+@testset \"ParseStream\" begin\n+    code = \"\"\"\n+    for i = 1:10\n+        xx[i] + 2\n+        # hi\n+        yy\n+    end\n+    \"\"\"\n+    st = ParseStream(code)\n+\n+    p1 = position(st)\n+        @test peek(st) == K\"for\"\n+        bump(st, TRIVIA_FLAG)\n+        p2 = position(st)\n+            @test peek(st) == K\"Identifier\"    # 'i'\n+            bump(st)\n+            @test peek(st) == K\"=\"\n+            bump(st, TRIVIA_FLAG)\n+            p3 = position(st)\n+                @test peek(st) == K\"Integer\"   # 1\n+                bump(st)\n+                @test peek(st) == K\":\"\n+                bump(st) # :\n+                @test peek(st) == K\"Integer\"   # 10\n+                bump(st) # 10\n+            emit(st, p3, K\"call\", INFIX_FLAG)\n+        emit(st, p2, K\"=\")\n+        @test peek(st) == K\"NewlineWs\"\n+        bump(st, TRIVIA_FLAG)\n+        p4 = position(st)\n+            p5 = position(st) # [call]\n+                p6 = position(st) # [ref]\n+                    @test peek(st) == K\"Identifier\" # 'xx'\n+                    bump(st)\n+                    @test peek(st) == K\"[\"\n+                    bump(st, TRIVIA_FLAG)\n+                    @test peek(st) == K\"Identifier\" # 'i'\n+                    bump(st)\n+                    @test peek(st) == K\"]\"\n+                    bump(st, TRIVIA_FLAG)\n+                emit(st, p6, K\"ref\")\n+                @test peek(st) == K\"+\"\n+                bump(st)\n+                @test peek(st) == K\"Integer\"        # 2\n+                bump(st)\n+            emit(st, p5, K\"call\", INFIX_FLAG)\n+            @test peek(st) == K\"NewlineWs\"\n+            bump(st, TRIVIA_FLAG)\n+            @test peek(st) == K\"NewlineWs\"\n+            bump(st, TRIVIA_FLAG)\n+            @test peek(st) == K\"Identifier\" # 'yy'\n+            bump(st)\n+        emit(st, p4, K\"block\")\n+        @test peek(st) == K\"NewlineWs\"\n+        bump(st, TRIVIA_FLAG)\n+        bump(st, TRIVIA_FLAG) # end\n+    emit(st, p1, K\"for\")\n+    @test peek(st) == K\"NewlineWs\"\n+    bump(st, TRIVIA_FLAG)\n+    emit(st, p1, K\"toplevel\")\n+end\n+\n+@testset \"ParseStream constructors\" begin\n+    @testset \"Byte buffer inputs\" begin\n+        # Vector{UInt8}\n+        let\n+            st = ParseStream(Vector{UInt8}(\"x+y\"))\n+            bump(st)\n+            @test build_tree(Expr, st) == :x\n+            @test JuliaSyntax.last_byte(st) == 1\n+        end\n+        let\n+            st = ParseStream(Vector{UInt8}(\"x+y\"), 3)\n+            bump(st)\n+            @test build_tree(Expr, st) == :y\n+            @test JuliaSyntax.last_byte(st) == 3\n+        end\n+        # Ptr{UInt8}, len\n+        code = \"x+y\"\n+        GC.@preserve code begin\n+            let\n+                st = ParseStream(pointer(code), 3)\n+                bump(st)\n+                @test build_tree(Expr, st) == :x\n+                @test JuliaSyntax.last_byte(st) == 1\n+            end\n+        end\n+    end\n+end\n+\n+@testset \"ParseStream tree traversal\" begin\n+    # NB: ParseStreamPosition.node_index includes an initial sentinel token so\n+    # indices here are one more than \"might be expected\". Additionally, note that\n+    # the byte index points to the first byte after the token.\n+    st = parse_sexpr(\"((a b) c)\")\n+    child1_pos = first_child_position(st, position(st))\n+    @test child1_pos == ParseStreamPosition(7, 8)\n+    @test first_child_position(st, child1_pos) == ParseStreamPosition(4, 4)\n+    @test last_child_position(st, position(st)) == ParseStreamPosition(9, 10)\n+    @test last_child_position(st, child1_pos) == ParseStreamPosition(6, 6)\n+\n+    st = parse_sexpr(\"( (a b) c)\")\n+    child1_pos = first_child_position(st, position(st))\n+    @test child1_pos == ParseStreamPosition(8, 9)\n+    @test first_child_position(st, child1_pos) == ParseStreamPosition(5, 5)\n+    @test last_child_position(st, position(st)) == ParseStreamPosition(10, 11)\n+    @test last_child_position(st, child1_pos) == ParseStreamPosition(7, 7)\n+\n+    st = parse_sexpr(\"(a (b c))\")\n+    @test first_child_position(st, position(st)) == ParseStreamPosition(3, 3)\n+    child2_pos = last_child_position(st, position(st))\n+    @test child2_pos == ParseStreamPosition(9, 10)\n+    @test first_child_position(st, child2_pos) == ParseStreamPosition(6, 6)\n+    @test last_child_position(st, child2_pos) == ParseStreamPosition(8, 8)\n+\n+    st = parse_sexpr(\"( a (b c))\")\n+    @test first_child_position(st, position(st)) == ParseStreamPosition(4, 4)\n+    child2_pos = last_child_position(st, position(st))\n+    @test child2_pos == ParseStreamPosition(10, 11)\n+    @test first_child_position(st, child2_pos) == ParseStreamPosition(7, 7)\n+    @test last_child_position(st, child2_pos) == ParseStreamPosition(9, 9)\n+\n+    st = parse_sexpr(\"a (b c)\")\n+    @test first_child_position(st, position(st)) == ParseStreamPosition(5, 5)\n+    @test last_child_position(st, position(st)) == ParseStreamPosition(7, 7)\n+\n+    st = parse_sexpr(\"(a) (b c)\")\n+    @test first_child_position(st, position(st)) == ParseStreamPosition(7, 8)\n+    @test last_child_position(st, position(st)) == ParseStreamPosition(9, 10)\n+\n+    st = parse_sexpr(\"(() ())\")\n+    @test first_child_position(st, position(st)) == ParseStreamPosition(4, 5)\n+    @test last_child_position(st, position(st)) == ParseStreamPosition(7, 9)\n+end\n+\n+@testset \"SubString{GenericString} (issue #505)\" begin\n+    x = Test.GenericString(\"1 2\")\n+    @test x == \"1 2\"\n+    y = split(x)[1]\n+    @test y == \"1\"\n+    @test y isa SubString{GenericString}\n+    @test ParseStream(y) isa ParseStream\n+    @test parsestmt(Expr, y) == parsestmt(Expr, \"1\")\n+end\n+\n+@testset \"peek_behind_pos with negative byte index\" begin\n+    # Test that peek_behind_pos doesn't cause InexactError when byte_idx goes negative\n+    # This can happen when parsing certain incomplete keywords like \"do\"\n+    # where trivia skipping walks back past the beginning of the stream\n+    @test_throws JuliaSyntax.ParseError parseall(GreenNode, \"do\")\n+    @test_throws JuliaSyntax.ParseError parseall(GreenNode, \"do \")\n+    @test_throws JuliaSyntax.ParseError parseall(GreenNode, \" do\")\n+    @test_throws JuliaSyntax.ParseError parseall(GreenNode, \"do\\n\")\n+end"
    },
    {
      "sha": "6c66ea40123e0bdc364c53dcae26c80e7216b881",
      "filename": "JuliaSyntax/test/parser.jl",
      "status": "added",
      "additions": 1240,
      "deletions": 0,
      "changes": 1240,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fparser.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fparser.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fparser.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,1240 @@\n+\"\"\"\n+Parse string to SyntaxNode tree and show as an sexpression\n+\"\"\"\n+function parse_to_sexpr_str(production, code::AbstractString; v=v\"1.6\", show_kws...)\n+    stream = ParseStream(code, version=v)\n+    production(ParseState(stream))\n+    JuliaSyntax.validate_tokens(stream)\n+    s = build_tree(SyntaxNode, stream, keep_parens=true)\n+    return sprint(io->show(io, MIME(\"text/x.sexpression\"), s; show_kws...))\n+end\n+\n+function test_parse(production, input, expected)\n+    if !(input isa AbstractString)\n+        opts, input = input\n+    else\n+        opts = NamedTuple()\n+    end\n+    parsed = parse_to_sexpr_str(production, input; opts...)\n+    if expected isa Regex # Could be AbstractPattern, but that type was added in Julia 1.6.\n+        @test match(expected, parsed) !== nothing\n+    else\n+        @test parsed == expected\n+    end\n+end\n+\n+function test_parse(inout::Pair)\n+    test_parse(JuliaSyntax.parse_toplevel, inout...)\n+end\n+\n+PARSE_ERROR = r\"\\(error-t \"\n+\n+with_version(v::VersionNumber, (i,o)::Pair) = ((;v=v), i) => o\n+\n+# TODO:\n+# * Extract the following test cases from the source itself.\n+# * Use only the green tree to generate the S-expressions\n+#   (add flag annotations to heads)\n+tests = [\n+    JuliaSyntax.parse_toplevel => [\n+        \"a \\n b\"     =>  \"(toplevel a b)\"\n+        \"a;b \\n c;d\" =>  \"(toplevel (toplevel-; a b) (toplevel-; c d))\"\n+        \"a \\n \\n\"    =>  \"(toplevel a)\"\n+        \"\"           =>  \"(toplevel)\"\n+    ],\n+    JuliaSyntax.parse_block => [\n+        \"a;b;c\"   => \"(block a b c)\"\n+        \"a;;;b;;\" => \"(block a b)\"\n+        \";a\"      => \"(block a)\"\n+        \"\\n a\"    => \"(block a)\"\n+        \"a\\nb\"    => \"(block a b)\"\n+    ],\n+    JuliaSyntax.parse_stmts => [\n+        \"a;b;c\"   => \"(toplevel-; a b c)\"\n+        \"a;;;b;;\" => \"(toplevel-; a b)\"\n+        \"\"\" \"x\" a ; \"y\" b \"\"\" =>\n+            \"\"\"(toplevel-; (doc (string \"x\") a) (doc (string \"y\") b))\"\"\"\n+        \"x y\"  =>  \"(wrapper x (error-t y))\"\n+    ],\n+    JuliaSyntax.parse_eq => [\n+        # parse_assignment\n+        \"a = b\"       =>  \"(= a b)\"\n+        \"a .= b\"      =>  \"(.= a b)\"\n+        \"a += b\"      =>  \"(op= a + b)\"\n+        \"a .+= b\"     =>  \"(.op= a + b)\"\n+        \"a, b = c, d\" =>  \"(= (tuple a b) (tuple c d))\"\n+        \"x, = xs\"     =>  \"(= (tuple x) xs)\"\n+        \"[a ~b]\"      =>  \"(hcat a (call-pre ~ b))\"\n+        \"a ~ b\"       =>  \"(call-i a ~ b)\"\n+        \"a .~ b\"      =>  \"(dotcall-i a ~ b)\"\n+        \"[a ~ b c]\"   =>  \"(hcat (call-i a ~ b) c)\"\n+        \"[a~b]\"       =>  \"(vect (call-i a ~ b))\"\n+        \"f(x) .= 1\"   =>  \"(.= (call f x) 1)\"\n+        \"::g() = 1\"   =>  \"(= (::-pre (call g)) 1)\"\n+        \"f(x) = 1\"    =>  \"(function-= (call f x) 1)\"\n+        \"f(x)::T = 1\" =>  \"(function-= (::-i (call f x) T) 1)\"\n+        \"f(x) where S where U = 1\" =>  \"(function-= (where (where (call f x) S) U) 1)\"\n+        \"(f(x)::T) where S = 1\" =>  \"(function-= (where (parens (::-i (call f x) T)) S) 1)\"\n+        \"f(x) = 1 = 2\"    =>  \"(function-= (call f x) (= 1 2))\" # Should be a warning!\n+    ],\n+    JuliaSyntax.parse_pair => [\n+        \"a => b\"  =>  \"(call-i a => b)\"\n+        \"a .=> b\" => \"(dotcall-i a => b)\"\n+    ],\n+    JuliaSyntax.parse_cond => [\n+        \"a ? b : c\"   => \"(? a b c)\"\n+        \"a ?\\nb : c\"  => \"(? a b c)\"\n+        \"a ? b :\\nc\"  => \"(? a b c)\"\n+        \"a ? b : c:d\" =>   \"(? a b (call-i c : d))\"\n+        # Following are errors but should recover\n+        \"a? b : c\"    => \"(? a (error-t) b c)\"\n+        \"a ?b : c\"    => \"(? a (error-t) b c)\"\n+        \"a ? b: c\"    => \"(? a b (error-t) c)\"\n+        \"a ? b :c\"    => \"(? a b (error-t) c)\"\n+        \"a ? b c\"     => \"(? a b (error-t) c)\"\n+        \"A[x ? y : end]\" => \"(ref A (? x y end))\"\n+    ],\n+    JuliaSyntax.parse_arrow => [\n+        \"x \u2192 y\"     =>  \"(call-i x \u2192 y)\"\n+        \"x <--> y\"  =>  \"(call-i x <--> y)\"\n+        \"x --> y\"   =>  \"(--> x y)\"\n+        \"x .--> y\"  =>  \"(dotcall-i x --> y)\"\n+        \"x -->\u2081 y\"  =>  \"(call-i x -->\u2081 y)\"\n+    ],\n+    JuliaSyntax.parse_or => [\n+        \"x || y || z\" => \"(|| x (|| y z))\"\n+        ((v=v\"1.6\",), \"x .|| y\") => \"(error (.|| x y))\"\n+        ((v=v\"1.7\",), \"x .|| y\") => \"(.|| x y)\"\n+    ],\n+    JuliaSyntax.parse_and => [\n+        \"x && y && z\" => \"(&& x (&& y z))\"\n+        ((v=v\"1.6\",), \"x .&& y\") => \"(error (.&& x y))\"\n+        ((v=v\"1.7\",), \"x .&& y\") => \"(.&& x y)\"\n+    ],\n+    JuliaSyntax.parse_comparison => [\n+        # Type comparisons are syntactic\n+        \"x <: y\"      => \"(<: x y)\"\n+        \"x >: y\"      => \"(>: x y)\"\n+        # Normal binary comparisons\n+        \"x < y\"       => \"(call-i x < y)\"\n+        \"x .< y\"      => \"(dotcall-i x < y)\"\n+        \"x .<: y\"     => \"(dotcall-i x <: y)\"\n+        \":. == :.\"    => \"(call-i (quote-: .) == (quote-: .))\"\n+        # Comparison chains\n+        \"x < y < z\"   => \"(comparison x < y < z)\"\n+        \"x == y < z\"  => \"(comparison x == y < z)\"\n+        \"x .< y .< z\" => \"(comparison x (. <) y (. <) z)\"\n+        \"x .< y < z\"  => \"(comparison x (. <) y < z)\"\n+    ],\n+    JuliaSyntax.parse_pipe_lt => [\n+        \"x <| y <| z\" => \"(call-i x <| (call-i y <| z))\"\n+    ],\n+    JuliaSyntax.parse_pipe_gt => [\n+        \"x |> y |> z\" => \"(call-i (call-i x |> y) |> z)\"\n+        \"x .|> y\"     => \"(dotcall-i x |> y)\"\n+    ],\n+    JuliaSyntax.parse_range => [\n+        \"1:2\"       => \"(call-i 1 : 2)\"\n+        \"1:2:3\"     => \"(call-i 1 : 2 3)\"\n+        \"a:b:c:d:e\" => \"(call-i (call-i a : b c) : d e)\"\n+        \"a :< b\"    => \"(call-i a (error : <) b)\"\n+        \"1:\\n2\"     => \"(call-i 1 : (error))\"\n+    ],\n+    JuliaSyntax.parse_range => [\n+        \"a..b\"       => \"(call-i a .. b)\"\n+        \"a \u2026 b\"      => \"(call-i a \u2026 b)\"\n+        \"a .\u2026 b\"     => \"(dotcall-i a \u2026 b)\"\n+        \"[1 :a]\"     => \"(hcat 1 (quote-: a))\"\n+        \"[1 2:3 :a]\" =>  \"(hcat 1 (call-i 2 : 3) (quote-: a))\"\n+        \"x...\"     => \"(... x)\"\n+        \"x:y...\"   => \"(... (call-i x : y))\"\n+        \"x..y...\"  => \"(... (call-i x .. y))\"\n+    ],\n+    JuliaSyntax.parse_invalid_ops => [\n+        \"a--b\"  =>  \"(call-i a (ErrorInvalidOperator) b)\"\n+    ],\n+    JuliaSyntax.parse_expr => [\n+        \"a - b - c\"  => \"(call-i (call-i a - b) - c)\"\n+        \"a + b + c\"  => \"(call-i a + b c)\"\n+        \"a + b .+ c\" => \"(dotcall-i (call-i a + b) + c)\"\n+        # parse_with_chains:\n+        # The following is two elements of a hcat\n+        \"[x +y]\"     =>  \"(hcat x (call-pre + y))\"\n+        \"[x+y +z]\"   =>  \"(hcat (call-i x + y) (call-pre + z))\"\n+        # Conversely the following are infix calls\n+        \"[x +\u2081y]\"    =>  \"(vect (call-i x +\u2081 y))\"\n+        \"[x+y+z]\"    =>  \"(vect (call-i x + y z))\"\n+        \"[x+y + z]\"  =>  \"(vect (call-i x + y z))\"\n+        # Dotted and normal operators\n+        \"a +\u2081 b +\u2081 c\" =>  \"(call-i (call-i a +\u2081 b) +\u2081 c)\"\n+        \"a .+ b .+ c\" =>  \"(dotcall-i (dotcall-i a + b) + c)\"\n+    ],\n+    JuliaSyntax.parse_term => [\n+        \"a * b * c\"  => \"(call-i a * b c)\"\n+        \"a .* b\"     => \"(dotcall-i a * b)\"\n+        \"-2*x\"       => \"(call-i -2 * x)\"\n+    ],\n+    JuliaSyntax.parse_rational => [\n+        \"x // y // z\" => \"(call-i (call-i x // y) // z)\"\n+    ],\n+    JuliaSyntax.parse_shift => [\n+        \"x >> y >> z\" => \"(call-i (call-i x >> y) >> z)\"\n+    ],\n+    JuliaSyntax.parse_juxtapose => [\n+        \"2x\"         => \"(juxtapose 2 x)\"\n+        \"2x\"         => \"(juxtapose 2 x)\"\n+        \"2(x)\"       => \"(juxtapose 2 (parens x))\"\n+        \"(2)(3)x\"    => \"(juxtapose (parens 2) (parens 3) x)\"\n+        \"(x-1)y\"     => \"(juxtapose (parens (call-i x - 1)) y)\"\n+        \"x'y\"        => \"(juxtapose (call-post x ') y)\"\n+        \"1\u221ax\"        =>  \"(juxtapose 1 (call-pre \u221a x))\"\n+        # errors\n+        \"\\\"a\\\"\\\"b\\\"\" => \"(juxtapose (string \\\"a\\\") (error-t) (string \\\"b\\\"))\"\n+        \"\\\"a\\\"x\"     => \"(juxtapose (string \\\"a\\\") (error-t) x)\"\n+        \"\\\"\\$y\\\"x\"   => \"(juxtapose (string y) (error-t) x)\"\n+        \"\\\"a\\\"begin end\" => \"(juxtapose (string \\\"a\\\") (error-t) (block))\"\n+        # Not juxtaposition - parse_juxtapose will consume only the first token.\n+        \"x.3\"       =>  \"x\"\n+        \"f(2)2\"     =>  \"(call f 2)\"\n+        \"x' y\"      =>  \"(call-post x ')\"\n+        \"x 'y\"      =>  \"x\"\n+        \"x@y\"       =>  \"x\"\n+        \"(begin end)x\" => \"(parens (block))\"\n+    ],\n+    JuliaSyntax.parse_unary => [\n+        \":T\"       => \"(quote-: T)\"\n+        \"in::T\"    => \"(::-i in T)\"\n+        \"isa::T\"   => \"(::-i isa T)\"\n+        \"-2^x\"     => \"(call-pre - (call-i 2 ^ x))\"\n+        \"-2[1, 3]\" => \"(call-pre - (ref 2 1 3))\"\n+        # signed literals\n+        \"-2\"       => \"-2\"\n+        \"+2.0\"     => \"2.0\"\n+        \"-1.0f0\"   => \"-1.0f0\"\n+        \"-0xf.0p0\" => \"-15.0\"\n+        \"+0b10010\" => \"0x12\"\n+        \"+0o22\"    => \"0x12\"\n+        \"+0x12\"    => \"0x12\"\n+        \"-0b10010\" => \"(call-pre - 0x12)\"\n+        \"-0o22\"    => \"(call-pre - 0x12)\"\n+        \"-0x12\"    => \"(call-pre - 0x12)\"\n+        \"-1::T\"    => \"(::-i -1 T)\"\n+        # Standalone dotted operators are parsed as (|.| op)\n+        \".+\"   =>  \"(. +)\"\n+        \".+\\n\" =>  \"(. +)\"\n+        \".+ =\" =>  \"(. +)\"\n+        \".+)\"  =>  \"(. +)\"\n+        \".&\"   =>  \"(. &)\"\n+        # Standalone non-dotted operators\n+        \"+)\"   =>  \"+\"\n+        # Call with type parameters or non-unary prefix call\n+        \"+{T}(x::T)\"  =>  \"(call (curly + T) (::-i x T))\"\n+        \"*(x)\"        =>  \"(call * x)\"\n+        \".*(x)\"       =>  \"(call (. *) x)\"\n+        # Prefix function calls for operators which are both binary and unary\n+        \"+(a,b)\"   =>  \"(call + a b)\"\n+        \"+(a,)\"    =>  \"(call-, + a)\"\n+        \".+(a,)\"   =>  \"(call-, (. +) a)\"\n+        \"(.+)(a)\"  =>  \"(call (parens (. +)) a)\"\n+        \"(.~(a))\"  =>  \"(parens (dotcall-pre ~ (parens a)))\"\n+        \"+(a=1,)\"  =>  \"(call-, + (= a 1))\"\n+        \"+(a...)\"  =>  \"(call + (... a))\"\n+        \"+(a;b,c)\" =>  \"(call + a (parameters b c))\"\n+        \"+(;a)\"    =>  \"(call + (parameters a))\"\n+        \"+(;;a)\"   =>  \"(call + (parameters) (parameters a))\"\n+        \"+()\"      =>  \"(call +)\"\n+        \"+(\\n;a)\"  =>  \"(call + (parameters a))\"\n+        \"+(;)\"     =>  \"(call + (parameters))\"\n+        \"+(\\n;\\n)\" =>  \"(call + (parameters))\"\n+        \"+(\\n)\"    =>  \"(call +)\"\n+        # Whitespace not allowed before prefix function call bracket\n+        \"+ (a,b)\"  =>  \"(call + (error) a b)\"\n+        # Prefix calls have higher precedence than ^\n+        \"+(a,b)^2\"  =>  \"(call-i (call + a b) ^ 2)\"\n+        \"+(a,b)(x)^2\"  =>  \"(call-i (call (call + a b) x) ^ 2)\"\n+        \"<:(a,)\"  =>  \"(<:-, a)\"\n+        # Unary function calls with brackets as grouping, not an arglist\n+        \".+(a)\"   =>  \"(dotcall-pre + (parens a))\"\n+        \"+(a;b)\"  =>  \"(call-pre + (block-p a b))\"\n+        \"+(;;)\"   =>  \"(call-pre + (block-p))\"\n+        \"+(;;)\"   =>  \"(call-pre + (block-p))\"\n+        \"+(a;)\"   =>  \"(call-pre + (block-p a))\"\n+        \"+(a;;)\"  =>  \"(call-pre + (block-p a))\"\n+        \"+(\\n;\\n;\\n)\" =>  \"(call-pre + (block-p))\"\n+        \"+(a=1)\"  =>  \"(call-pre + (parens (= a 1)))\"\n+        # Unary operators have lower precedence than ^\n+        \"+(a)^2\"  =>  \"(call-pre + (call-i (parens a) ^ 2))\"\n+        \".+(a)^2\" =>  \"(dotcall-pre + (call-i (parens a) ^ 2))\"\n+        \"+(a)(x,y)^2\"  =>  \"(call-pre + (call-i (call (parens a) x y) ^ 2))\"\n+        \"<:(a)\"   =>  \"(<:-pre (parens a))\"\n+        # Normal unary calls\n+        \"+x\" => \"(call-pre + x)\"\n+        \"\u221ax\" => \"(call-pre \u221a x)\"\n+        \".~x\" => \"(dotcall-pre ~ x)\"\n+        # Things which are not quite negative literals\n+        \"-0x1\"=> \"(call-pre - 0x01)\"\n+        \"- 2\" => \"(call-pre - 2)\"\n+        \".-2\" => \"(dotcall-pre - 2)\"\n+        # Not a unary operator\n+        \"/x\"     => \"(call-pre (error /) x)\"\n+        \"+\u2081 x\"   => \"(call-pre (error +\u2081) x)\"\n+        \".<: x\"  => \"(dotcall-pre (error (. <:)) x)\"\n+        \"?\\\"str\\\"\" => \"\"\"(call-pre (error ?) (string \"str\"))\"\"\"\n+    ],\n+    JuliaSyntax.parse_factor => [\n+        \"x^y\"      =>  \"(call-i x ^ y)\"\n+        \"x^y^z\"    =>  \"(call-i x ^ (call-i y ^ z))\"\n+        \"x .^ y\"   =>  \"(dotcall-i x ^ y)\"\n+        \"begin x end::T\"  =>  \"(::-i (block x) T)\"\n+        # parse_decl_with_initial_ex\n+        \"a::b\"     =>  \"(::-i a b)\"\n+        \"a::b::c\"  =>  \"(::-i (::-i a b) c)\"\n+        \"a->b\"     =>  \"(-> (tuple a) b)\"\n+        \"(a,b)->c\" =>  \"(-> (tuple-p a b) c)\"\n+        \"(a;b=1)->c\" =>  \"(-> (tuple-p a (parameters (= b 1))) c)\"\n+        \"x::T->c\"  =>  \"(-> (tuple (::-i x T)) c)\"\n+        \"\\$a->b\"   =>  \"(-> (tuple (\\$ a)) b)\"\n+        \"\\$(a)->b\" =>  \"(-> (tuple (\\$ (parens a))) b)\"\n+        # FIXME \"&(a)->b\"  =>  \"(-> (tuple-p (& (parens a))) b)\"\n+        # FIXME \"::(a)->b\" =>  \"(-> (tuple-p (:: (parens a))) b)\"\n+        # `where` combined with `->` still parses strangely. However:\n+        # * It's extra hard to add a tuple around the `x` in this syntax corner case.\n+        # * The user already needs to add additional, ugly, parens to get this\n+        #   to parse correctly because the precedence of `where` is\n+        #   inconsistent with `::` and `->` in this case.\n+        \"(x where T)->c\" => \"(-> (parens (where x T)) c)\"\n+        \"((x::T) where T)->c\" => \"(-> (parens (where (parens (::-i x T)) T)) c)\"\n+    ],\n+    JuliaSyntax.parse_unary_subtype => [\n+        \"<: )\"    =>  \"<:\"\n+        \"<: \\n\"   =>  \"<:\"\n+        \"<: =\"    =>  \"<:\"\n+        \"<:{T}(x::T)\"   =>  \"(call (curly <: T) (::-i x T))\"\n+        \"<:(x::T)\"      =>  \"(<:-pre (parens (::-i x T)))\"\n+        \"<: x\"          =>  \"(<:-pre x)\"\n+        \"<: <: x\"       =>  \"(<:-pre (<:-pre x))\"\n+        \"<: A where B\"  =>  \"(<:-pre (where A B))\"\n+        # FIXME: The following bizarre precedence seems broken, but is\n+        # compatible with the reference parser (see #248)\n+        \"+ <: A where B\"  =>  \"(where (call-pre + (<:-pre A)) B)\"\n+        # Really for parse_where\n+        \"x where \\n {T}\"  =>  \"(where x (braces T))\"\n+        \"x where {T,S}\"  =>  \"(where x (braces T S))\"\n+        \"x where {T,S,}\" =>  \"(where x (braces-, T S))\"\n+        \"x where {T S}\"  =>  \"(where x (bracescat (row T S)))\"\n+        \"x where {y for y in ys}\"  =>  \"(where x (braces (generator y (iteration (in y ys)))))\"\n+        \"x where T\"  =>  \"(where x T)\"\n+        \"x where \\n T\"  =>  \"(where x T)\"\n+        \"x where T<:S\"  =>  \"(where x (<: T S))\"\n+        # nested unary and unary-syntactic ops\n+        \"<: + <: + A\" => \"(<:-pre (call-pre + (<:-pre (call-pre + A))))\"\n+        \"* <: A\"      => \"(call-pre (error *) (<:-pre A))\"\n+    ],\n+    JuliaSyntax.parse_unary_prefix => [\n+        \"&)\"   => \"&\"\n+        \"\\$\\n\" => \"\\$\"\n+        \"&a\"   => \"(& a)\"\n+        \"::a\"  => \"(::-pre a)\"\n+        \"\\$a\"  => \"(\\$ a)\"\n+        \"\\$\\$a\"  => \"(\\$ (\\$ a))\"\n+    ],\n+    JuliaSyntax.parse_call => [\n+        # parse_call\n+        \"f(x)\"    =>  \"(call f x)\"\n+        \"\\$f(x)\"  =>  \"(call (\\$ f) x)\"\n+        \".&(x,y)\" =>  \"(call (. &) x y)\"\n+        # parse_call_chain\n+        \"f(a).g(b)\" => \"(call (. (call f a) g) b)\"\n+        \"\\$A.@x\"    =>  \"(macrocall (. (\\$ A) (macro_name x)))\"\n+\n+        # non-errors in space sensitive contexts\n+        \"[f (x)]\"    =>  \"(hcat f (parens x))\"\n+        \"[f x]\"      =>  \"(hcat f x)\"\n+        # space separated macro calls\n+        \"@foo a b\"     =>  \"(macrocall (macro_name foo) a b)\"\n+        \"@foo (x)\"     =>  \"(macrocall (macro_name foo) (parens x))\"\n+        \"@foo (x,y)\"   =>  \"(macrocall (macro_name foo) (tuple-p x y))\"\n+        \"A.@foo a b\"   =>  \"(macrocall (. A (macro_name foo)) a b)\"\n+        \"@A.foo a b\"   =>  \"(macrocall (macro_name (. A foo)) a b)\"\n+        \"[@foo x]\"     =>  \"(vect (macrocall (macro_name foo) x))\"\n+        \"[@foo]\"       =>  \"(vect (macrocall (macro_name foo)))\"\n+        \"@var\\\"#\\\" a\"  =>  \"(macrocall (macro_name (var #)) a)\"\n+        \"@(A) x\"       =>  \"(macrocall (macro_name (parens A)) x)\"\n+        \"A.@x y\"       =>  \"(macrocall (. A (macro_name x)) y)\"\n+        \"A.@var\\\"#\\\" a\"=>  \"(macrocall (. A (macro_name (var #))) a)\"\n+        \"@+x y\"        =>  \"(macrocall (macro_name +) x y)\"\n+        \"A.@.x\"        =>  \"(macrocall (. A (macro_name .)) x)\"\n+        # Macro names\n+        \"@! x\"  => \"(macrocall (macro_name !) x)\"\n+        \"@.. x\" => \"(macrocall (macro_name ..) x)\"\n+        \"@\\$ y\"  => \"(macrocall (macro_name \\$) y)\"\n+        \"@[x] y z\" => \"(macrocall (macro_name (error (vect x))) y z)\"\n+        # Special @doc parsing rules\n+        \"@doc x\\ny\"    =>  \"(macrocall (macro_name doc) x y)\"\n+        \"A.@doc x\\ny\"  =>  \"(macrocall (. A (macro_name doc)) x y)\"\n+        \"@A.doc x\\ny\"  =>  \"(macrocall (macro_name (. A doc)) x y)\"\n+        \"@doc x y\\nz\"  =>  \"(macrocall (macro_name doc) x y)\"\n+        \"@doc x\\n\\ny\"  =>  \"(macrocall (macro_name doc) x)\"\n+        \"@doc x\\nend\"  =>  \"(macrocall (macro_name doc) x)\"\n+\n+        # calls with brackets\n+        \"f(a,b)\"  => \"(call f a b)\"\n+        \"f(a,)\"   => \"(call-, f a)\"\n+        \"f(a=1; b=2)\" => \"(call f (= a 1) (parameters (= b 2)))\"\n+        \"f(a; b; c)\" => \"(call f a (parameters b) (parameters c))\"\n+        \"(a=1)()\" =>  \"(call (parens (= a 1)))\"\n+        \"f (a)\" => \"(call f (error-t) a)\"\n+        \"@x(a, b)\"   =>  \"(macrocall-p (macro_name x) a b)\"\n+        \"@x(a, b,)\"  =>  \"(macrocall-p-, (macro_name x) a b)\"\n+        \"A.@x(y)\"    =>  \"(macrocall-p (. A (macro_name x)) y)\"\n+        \"A.@x(y).z\"  =>  \"(. (macrocall-p (. A (macro_name x)) y) z)\"\n+        \"f(y for x = xs; a)\" => \"(call f (generator y (iteration (in x xs))) (parameters a))\"\n+        # do\n+        \"f() do\\nend\"         =>  \"(call f (do (tuple) (block)))\"\n+        \"f() do ; body end\"   =>  \"(call f (do (tuple) (block body)))\"\n+        \"f() do x, y\\n body end\"  =>  \"(call f (do (tuple x y) (block body)))\"\n+        \"f(x) do y body end\"  =>  \"(call f x (do (tuple y) (block body)))\"\n+        \"@f(x) do y body end\" =>  \"(macrocall-p (macro_name f) x (do (tuple y) (block body)))\"\n+\n+        # square brackets\n+        \"@S[a,b]\"  => \"(macrocall (macro_name S) (vect a b))\"\n+        \"@S[a b]\"  => \"(macrocall (macro_name S) (hcat a b))\"\n+        \"@S[a; b]\" => \"(macrocall (macro_name S) (vcat a b))\"\n+        \"A.@S[a]\"  =>  \"(macrocall (. A (macro_name S)) (vect a))\"\n+        \"@S[a].b\"  =>  \"(. (macrocall (macro_name S) (vect a)) b)\"\n+        ((v=v\"1.7\",), \"@S[a ;; b]\")  =>  \"(macrocall (macro_name S) (ncat-2 a b))\"\n+        ((v=v\"1.6\",), \"@S[a ;; b]\")  =>  \"(macrocall (macro_name S) (error (ncat-2 a b)))\"\n+        \"a[i]\"  =>  \"(ref a i)\"\n+        \"a [i]\"  =>  \"(ref a (error-t) i)\"\n+        \"a[i,j]\"  =>  \"(ref a i j)\"\n+        \"(a=1)[]\" =>  \"(ref (parens (= a 1)))\"\n+        \"a[end]\"  =>  \"(ref a end)\"\n+        \"a[begin]\"  =>  \"(ref a begin)\"\n+        \"a[:(end)]\" => \"(typed_hcat a (quote-: (parens (error-t))) (error-t))\"\n+        \"T[x   y]\"  =>  \"(typed_hcat T x y)\"\n+        \"T[x ; y]\"  =>  \"(typed_vcat T x y)\"\n+        \"T[a b; c d]\"  =>  \"(typed_vcat T (row a b) (row c d))\"\n+        \"T[x for x in xs]\"  =>  \"(typed_comprehension T (generator x (iteration (in x xs))))\"\n+        ((v=v\"1.8\",), \"T[a ; b ;; c ; d]\") => \"(typed_ncat-2 T (nrow-1 a b) (nrow-1 c d))\"\n+\n+        # Dotted forms\n+        # Allow `@` in macrocall only in first and last position\n+        \"A.B.@x\"    =>  \"(macrocall (. (. A B) (macro_name x)))\"\n+        \"@A.B.x\"    =>  \"(macrocall (macro_name (. (. A B) x)))\"\n+        \"A.@B.x\"    =>  \"(macrocall (. (. A (error-t) B) (macro_name (error-t) x)))\"\n+        \"@M.(x)\"    =>  \"(macrocall (dotcall (macro_name M) (error-t) x))\"\n+        \"f.(a,b)\"   =>  \"(dotcall f a b)\"\n+        \"f.(a,b,)\"  =>  \"(dotcall-, f a b)\"\n+        \"f.(a=1; b=2)\" => \"(dotcall f (= a 1) (parameters (= b 2)))\"\n+        \"(a=1).()\" =>  \"(dotcall (parens (= a 1)))\"\n+        \"f. (x)\"    =>  \"(dotcall f (error-t) x)\"\n+        # Other dotted syntax\n+        \"A.:+\"      =>  \"(. A (quote-: +))\"\n+        \"A.:.+\"     =>  \"(. A (quote-: (. +)))\"\n+        \"A.: +\"     =>  \"(. A (quote-: (error-t) +))\"\n+        \"f.\\$x\"     =>  \"(. f (\\$ x))\"\n+        \"f.\\$(x+y)\" =>  \"(. f (\\$ (parens (call-i x + y))))\"\n+        \"A.\\$B.@x\"  =>  \"(macrocall (. (. A (\\$ B)) (macro_name x)))\"\n+        \"@A.\\$x a\"  =>  \"(macrocall (macro_name (. A (error x))) a)\"\n+        \"A.@x\"      =>  \"(macrocall (. A (macro_name x)))\"\n+        \"A.@x a\"    =>  \"(macrocall (. A (macro_name x)) a)\"\n+        \"@A.B.@x a\" =>  \"(macrocall (macro_name (. (. A B) (error-t) x)) a)\"\n+        # .' discontinued\n+        \"f.'\"    =>  \"(dotcall-post f (error '))\"\n+        # Field/property syntax\n+        \"f.x.y\"  =>  \"(. (. f x) y)\"\n+        \"x .y\"   =>  \"(. x (error-t) y)\"\n+        \"x.?\"    =>  \"(. x ?)\"\n+        \"x.in\"   =>  \"(. x in)\"\n+        # Adjoint\n+        \"f'\"  => \"(call-post f ')\"\n+        \"f'\u1d40\" => \"(call-post f '\u1d40)\"\n+        # Curly calls\n+        \"S {a}\"   => \"(curly S (error-t) a)\"\n+        \"A.@S{a}\" => \"(macrocall (. A (macro_name S)) (braces a))\"\n+        \"@S{a,b}\" => \"(macrocall (macro_name S) (braces a b))\"\n+        \"A.@S{a}\" => \"(macrocall (. A (macro_name S)) (braces a))\"\n+        \"@S{a}.b\" => \"(. (macrocall (macro_name S) (braces a)) b)\"\n+        # Macro calls with chained operations\n+        \"@a[b][c]\" => \"(ref (macrocall (macro_name a) (vect b)) c)\"\n+        \"@a{b}{c}\" => \"(curly (macrocall (macro_name a) (braces b)) c)\"\n+        \"@a[b]{c}\" => \"(curly (macrocall (macro_name a) (vect b)) c)\"\n+        \"@a{b}[c]\" => \"(ref (macrocall (macro_name a) (braces b)) c)\"\n+        \"S{a,b}\"  => \"(curly S a b)\"\n+        \"T{y for x = xs; a}\" => \"(curly T (generator y (iteration (in x xs))) (parameters a))\"\n+        # String macros\n+        \"x\\\"str\\\"\"   => \"\"\"(macrocall @x_str (string-r \"str\"))\"\"\"\n+        \"x`str`\"     => \"\"\"(macrocall @x_cmd (cmdstring-r \"str\"))\"\"\"\n+        \"x\\\"\\\"\"      => \"\"\"(macrocall @x_str (string-r \"\"))\"\"\"\n+        \"x``\"        => \"\"\"(macrocall @x_cmd (cmdstring-r \"\"))\"\"\"\n+        \"in\\\"str\\\"\"  => \"\"\"(macrocall @in_str (string-r \"str\"))\"\"\"\n+        \"outer\\\"str\\\"\" => \"\"\"(macrocall @outer_str (string-r \"str\"))\"\"\"\n+        \"A.x\\\"str\\\"\" => \"\"\"(macrocall (. A @x_str) (string-r \"str\"))\"\"\"\n+        \"A.x`str`\" => \"\"\"(macrocall (. A @x_cmd) (cmdstring-r \"str\"))\"\"\"\n+        # Triple quoted processing for custom strings\n+        \"r\\\"\\\"\\\"\\nx\\\"\\\"\\\"\"        => raw\"\"\"(macrocall @r_str (string-s-r \"x\"))\"\"\"\n+        \"r\\\"\\\"\\\"\\n x\\n y\\\"\\\"\\\"\"   => raw\"\"\"(macrocall @r_str (string-s-r \"x\\n\" \"y\"))\"\"\"\n+        \"r\\\"\\\"\\\"\\n x\\\\\\n y\\\"\\\"\\\"\" => raw\"\"\"(macrocall @r_str (string-s-r \"x\\\\\\n\" \"y\"))\"\"\"\n+        # Macro suffixes can include keywords and numbers\n+        \"x\\\"s\\\"y\"    => \"\"\"(macrocall @x_str (string-r \"s\") \"y\")\"\"\"\n+        \"x\\\"s\\\"end\"  => \"\"\"(macrocall @x_str (string-r \"s\") \"end\")\"\"\"\n+        \"x\\\"s\\\"in\"   => \"\"\"(macrocall @x_str (string-r \"s\") \"in\")\"\"\"\n+        \"x\\\"s\\\"2\"    => \"\"\"(macrocall @x_str (string-r \"s\") 2)\"\"\"\n+        \"x\\\"s\\\"10.0\" => \"\"\"(macrocall @x_str (string-r \"s\") 10.0)\"\"\"\n+        # Cmd macro suffixes\n+        \"x`s`y\"    => \"\"\"(macrocall @x_cmd (cmdstring-r \"s\") \"y\")\"\"\"\n+        \"x`s`end\"  => \"\"\"(macrocall @x_cmd (cmdstring-r \"s\") \"end\")\"\"\"\n+        \"x`s`in\"   => \"\"\"(macrocall @x_cmd (cmdstring-r \"s\") \"in\")\"\"\"\n+        \"x`s`2\"    => \"\"\"(macrocall @x_cmd (cmdstring-r \"s\") 2)\"\"\"\n+        \"x`s`10.0\" => \"\"\"(macrocall @x_cmd (cmdstring-r \"s\") 10.0)\"\"\"\n+    ],\n+    JuliaSyntax.parse_resword => [\n+        # In normal_context\n+        \"begin f() where T = x end\" => \"(block (function-= (where (call f) T) x))\"\n+        # block\n+        \"begin end\"         =>  \"(block)\"\n+        \"begin a ; b end\"   =>  \"(block a b)\"\n+        \"begin\\na\\nb\\nend\"  =>  \"(block a b)\"\n+        # quote\n+        \"quote end\"         =>  \"(quote (block))\"\n+        \"quote body end\"    =>  \"(quote (block body))\"\n+        # while\n+        \"while cond body end\"  =>  \"(while cond (block body))\"\n+        \"while x < y \\n a \\n b \\n end\"  =>  \"(while (call-i x < y) (block a b))\"\n+        # for\n+        \"for x in xs end\" => \"(for (iteration (in x xs)) (block))\"\n+        \"for x in xs, y in ys \\n a \\n end\" => \"(for (iteration (in x xs) (in y ys)) (block a))\"\n+        # let\n+        \"let x=1\\n end\"    =>  \"(let (block (= x 1)) (block))\"\n+        \"let x=1 ; end\"    =>  \"(let (block (= x 1)) (block))\"\n+        \"let x ; end\"      =>  \"(let (block x) (block))\"\n+        \"let x::1 ; end\"   =>  \"(let (block (::-i x 1)) (block))\"\n+        \"let x=1,y=2 end\"  =>  \"(let (block (= x 1) (= y 2)) (block))\"\n+        \"let x+=1 ; end\"   =>  \"(let (block (op= x + 1)) (block))\"\n+        \"let ; end\"        =>  \"(let (block) (block))\"\n+        \"let ; body end\"   =>  \"(let (block) (block body))\"\n+        \"let\\na\\nb\\nend\"   =>  \"(let (block) (block a b))\"\n+        # abstract type\n+        \"abstract type A end\"            =>  \"(abstract A)\"\n+        \"abstract type A ; end\"          =>  \"(abstract A)\"\n+        \"abstract type \\n\\n A \\n\\n end\"  =>  \"(abstract A)\"\n+        \"abstract type A <: B end\"       =>  \"(abstract (<: A B))\"\n+        \"abstract type A <: B{T,S} end\"  =>  \"(abstract (<: A (curly B T S)))\"\n+        \"abstract type A < B end\"        =>  \"(abstract (call-i A < B))\"\n+        # primitive type\n+        \"primitive type A 32 end\"   =>  \"(primitive A 32)\"\n+        \"primitive type A 32 ; end\" =>  \"(primitive A 32)\"\n+        \"primitive type A \\$N end\"  =>  \"(primitive A (\\$ N))\"\n+        \"primitive type A <: B \\n 8 \\n end\"  =>  \"(primitive (<: A B) 8)\"\n+        # struct\n+        \"struct A <: B \\n a::X \\n end\" =>  \"(struct (<: A B) (block (::-i a X)))\"\n+        \"struct A \\n a \\n b \\n end\"    =>  \"(struct A (block a b))\"\n+        \"struct A \\n \\\"doca\\\" \\n a \\n \\\"docb\\\" \\n b \\n end\"    =>  \"(struct A (block (doc (string \\\"doca\\\") a) (doc (string \\\"docb\\\") b)))\"\n+        \"mutable struct A end\"         =>  \"(struct-mut A (block))\"\n+        ((v=v\"1.8\",), \"struct A const a end\") => \"(struct A (block (const a)))\"\n+        ((v=v\"1.7\",), \"struct A const a end\") => \"(struct A (block (error (const a))))\"\n+        \"struct A end\"    =>  \"(struct A (block))\"\n+        \"struct try end\"  =>  \"(struct (error try) (block))\"\n+        # return\n+        \"return\\nx\"   =>  \"(return)\"\n+        \"return)\"     =>  \"(return)\"\n+        \"return x\"    =>  \"(return x)\"\n+        \"return x,y\"  =>  \"(return (tuple x y))\"\n+        # break/continue\n+        \"break\"    => \"(break)\"\n+        \"continue\" => \"(continue)\"\n+        # module/baremodule\n+        \"module A end\"      =>  \"(module A (block))\"\n+        \"baremodule A end\"  =>  \"(module-bare A (block))\"\n+        \"module do \\n end\"  =>  \"(module (error do) (block))\"\n+        \"module \\$A end\"    =>  \"(module (\\$ A) (block))\"\n+        \"module A \\n a \\n b \\n end\"  =>  \"(module A (block a b))\"\n+        \"\"\"module A \\n \"x\"\\na\\n end\"\"\" => \"\"\"(module A (block (doc (string \"x\") a)))\"\"\"\n+        # export\n+        \"export a\"   =>  \"(export a)\"\n+        \"export @a\"  =>  \"(export (macro_name a))\"\n+        \"export @var\\\"'\\\"\" =>  \"(export (macro_name (var ')))\"\n+        \"export a, \\n @b\"  =>  \"(export a (macro_name b))\"\n+        \"export +, ==\"     =>  \"(export + ==)\"\n+        \"export \\n a\"      =>  \"(export a)\"\n+        \"export \\$a, \\$(a*b)\"  =>  \"(export (\\$ a) (\\$ (parens (call-i a * b))))\"\n+        \"export (x::T)\"  =>  \"(export (error (parens (::-i x T))))\"\n+        \"export outer\"  =>  \"(export outer)\"\n+        \"export (\\$f)\"  =>  \"(export (parens (\\$ f)))\"\n+    ],\n+    JuliaSyntax.parse_if_elseif => [\n+        \"if a xx elseif b yy else zz end\" => \"(if a (block xx) (elseif b (block yy) (block zz)))\"\n+        \"if end\"        =>  \"(if (error) (block))\"\n+        \"if \\n end\"     =>  \"(if (error) (block))\"\n+        \"if a end\"      =>  \"(if a (block))\"\n+        \"if a xx end\"   =>  \"(if a (block xx))\"\n+        \"if a \\n\\n xx \\n\\n end\"   =>  \"(if a (block xx))\"\n+        \"if a xx elseif b yy end\"   =>  \"(if a (block xx) (elseif b (block yy)))\"\n+        \"if a xx else if b yy end\"  =>  \"(if a (block xx) (error-t) (elseif b (block yy)))\"\n+        \"if a xx else yy end\"   =>  \"(if a (block xx) (block yy))\"\n+        \"if true; x ? true elseif true end\"  => \"(if true (block (if x true (error-t) (error-t))) (elseif true (block)))\"\n+        \"if true; x ? true end\"  => \"(if true (block (if x true (error-t) (error-t))))\"\n+        \"if true; x ? true\\nend\"  => \"(if true (block (if x true (error-t) (error-t))))\"\n+        \"if true; x ? true : elseif true end\"  => \"(if true (block (if x true (error-t))) (elseif true (block)))\"\n+    ],\n+    JuliaSyntax.parse_resword => [\n+        \"global x\"    =>  \"(global x)\"\n+        \"local x\"     =>  \"(local x)\"\n+        \"global x,y\"  =>  \"(global x y)\"\n+        \"global const x = 1\" => \"(global (const (= x 1)))\"\n+        \"local const x = 1\"  => \"(local (const (= x 1)))\"\n+        \"const global x = 1\" => \"(const (global (= x 1)))\"\n+        \"const local x = 1\"  => \"(const (local (= x 1)))\"\n+        \"const x,y = 1,2\"    => \"(const (= (tuple x y) (tuple 1 2)))\"\n+        \"const x = 1\"    =>  \"(const (= x 1))\"\n+        \"const x .= 1\"   => \"(error (const (.= x 1)))\"\n+        \"global x ~ 1\"   =>  \"(global (call-i x ~ 1))\"\n+        \"global x += 1\"  => \"(global (op= x + 1))\"\n+        \"const x\"        => \"(error (const x))\"\n+        \"global const x\" => \"(global (error (const x)))\"\n+        \"const global x\" => \"(error (const (global x)))\"\n+    ],\n+    JuliaSyntax.parse_resword => [\n+        # Macros and functions\n+        \"macro while(ex) end\"  =>  \"(macro (call (error while) ex) (block))\"\n+        \"macro f()     end\"    =>  \"(macro (call f) (block))\"\n+        \"macro (:)(ex) end\"    =>  \"(macro (call (parens :) ex) (block))\"\n+        \"macro (type)(ex) end\" =>  \"(macro (call (parens type) ex) (block))\"\n+        \"macro \\$f()    end\"   =>  \"(macro (call (\\$ f)) (block))\"\n+        \"macro (\\$f)()  end\"   =>  \"(macro (call (parens (\\$ f))) (block))\"\n+        \"function (x) body end\"=>  \"(function (tuple-p x) (block body))\"\n+        \"function (x,y) end\"   =>  \"(function (tuple-p x y) (block))\"\n+        \"function (x,y,) end\"  =>  \"(function (tuple-p-, x y) (block))\"\n+        \"function (x=1) end\"   =>  \"(function (tuple-p (= x 1)) (block))\"\n+        \"function (;x=1) end\"  =>  \"(function (tuple-p (parameters (= x 1))) (block))\"\n+        \"function (f(x),) end\" =>  \"(function (tuple-p-, (call f x)) (block))\"\n+        \"function (@f(x);) end\" => \"(function (tuple-p (macrocall-p (macro_name f) x) (parameters)) (block))\"\n+        \"function (@f(x)...) end\" =>  \"(function (tuple-p (... (macrocall-p (macro_name f) x))) (block))\"\n+        \"function (@f(x)) end\" =>  \"(function (error (tuple-p (macrocall-p (macro_name f) x))) (block))\"\n+        \"function (\\$f) end\"   =>  \"(function (error (tuple-p (\\$ f))) (block))\"\n+        \"function ()(x) end\"   =>  \"(function (call (tuple-p) x) (block))\"\n+        \"function (A).f() end\" =>  \"(function (call (. (parens A) f)) (block))\"\n+        \"function (:)() end\"   =>  \"(function (call (parens :)) (block))\"\n+        \"function (x::T)() end\"=>  \"(function (call (parens (::-i x T))) (block))\"\n+        \"function (::g(x))() end\" => \"(function (call (parens (::-pre (call g x)))) (block))\"\n+        \"function (f::T{g(i)})() end\" => \"(function (call (parens (::-i f (curly T (call g i))))) (block))\"\n+        \"function (::T)() end\" =>  \"(function (call (parens (::-pre T))) (block))\"\n+        \"function (\\n        ::T\\n        )() end\" =>  \"(function (call (parens (::-pre T))) (block))\"\n+        \"function (\\n        x::T\\n        )() end\" =>  \"(function (call (parens (::-i x T))) (block))\"\n+        \"function (\\n        f\\n        )() end\" =>  \"(function (call (parens f)) (block))\"\n+        \"function (\\n        A\\n        ).f() end\" =>  \"(function (call (. (parens A) f)) (block))\"\n+        \"function (\\n        ::T\\n        )(x, y) end\" =>  \"(function (call (parens (::-pre T)) x y) (block))\"\n+        \"function (\\n        f::T{g(i)}\\n        )() end\" => \"(function (call (parens (::-i f (curly T (call g i))))) (block))\"\n+        \"function (\\n        x, y\\n        ) x + y end\" => \"(function (tuple-p x y) (block (call-i x + y)))\"\n+        \"function (:*=(f))() end\" => \"(function (call (parens (call (quote-: *=) f))) (block))\"\n+        \"function begin() end\" =>  \"(function (call (error begin)) (block))\"\n+        \"function f() end\"     =>  \"(function (call f) (block))\"\n+        \"function type() end\"  =>  \"(function (call type) (block))\"\n+        \"function \\n f() end\"  =>  \"(function (call f) (block))\"\n+        \"function \\$f() end\"   =>  \"(function (call (\\$ f)) (block))\"\n+        \"function (::Type{T})(x) end\"  =>  \"(function (call (parens (::-pre (curly Type T))) x) (block))\"\n+        # Function/macro definition with no methods\n+        \"function f end\"      =>  \"(function f)\"\n+        \"function f \\n\\n end\" =>  \"(function f)\"\n+        \"function \\$f end\"    =>  \"(function (\\$ f))\"\n+        \"function var\\\".\\\" end\" => \"(function (var .))\"\n+        \"macro f end\"         =>  \"(macro f)\"\n+        # Function argument list\n+        \"function f(x,y) end\"    =>  \"(function (call f x y) (block))\"\n+        \"function f{T}() end\"    =>  \"(function (call (curly f T)) (block))\"\n+        \"function A.f()   end\"   =>  \"(function (call (. A f)) (block))\"\n+        \"function f body end\"    =>  \"(function (error f) (block body))\"\n+        \"function f()::T    end\" =>  \"(function (::-i (call f) T) (block))\"\n+        \"function f()::g(T) end\" =>  \"(function (::-i (call f) (call g T)) (block))\"\n+        \"function f() where {T} end\"  => \"(function (where (call f) (braces T)) (block))\"\n+        \"function f() where T   end\"  => \"(function (where (call f) T) (block))\"\n+        \"function f()::S where T end\" => \"(function (where (::-i (call f) S) T) (block))\"\n+        # Ugly cases for compat where extra parentheses existed and we've\n+        # already parsed at least the call part of the signature\n+        \"function (f() where T) end\" => \"(function (parens (where (call f) T)) (block))\"\n+        \"function (f()) where T end\" => \"(function (where (parens (call f)) T) (block))\"\n+        \"function (f() where T) where U end\" => \"(function (where (parens (where (call f) T)) U) (block))\"\n+        \"function (f()::S) end\"=>  \"(function (parens (::-i (call f) S)) (block))\"\n+        \"function ((f()::S) where T) end\" => \"(function (parens (where (parens (::-i (call f) S)) T)) (block))\"\n+        \"function (x*y ) end\" => \"(function (parens (call-i x * y)) (block))\"\n+        # body\n+        \"function f() \\n a \\n b end\"  =>  \"(function (call f) (block a b))\"\n+        \"function f() end\"       =>  \"(function (call f) (block))\"\n+        # Macrocall as sig\n+        ((v=v\"1.12\",), \"function @callmemacro(a::Int) \\n 1 \\n end\") => \"(function (macrocall-p (macro_name callmemacro) (::-i a Int)) (block 1))\"\n+        ((v=v\"1.12\",), \"function @callmemacro(a::T, b::T) where T <: Int64\\n3\\nend\") => \"(function (where (macrocall-p (macro_name callmemacro) (::-i a T) (::-i b T)) (<: T Int64)) (block 3))\"\n+        ((v=v\"1.12\",), \"function @callmemacro(a::Int, b::Int, c::Int)::Float64\\n4\\nend\") => \"(function (::-i (macrocall-p (macro_name callmemacro) (::-i a Int) (::-i b Int) (::-i c Int)) Float64) (block 4))\"\n+        ((v=v\"1.12\",), \"function @f()() end\") => \"(function (call (macrocall-p (macro_name f))) (block))\"\n+        # Errors\n+        \"function\"            => \"(function (error (error)) (block (error)) (error-t))\"\n+    ],\n+    JuliaSyntax.parse_try => [\n+        \"try \\n x \\n catch e \\n y \\n finally \\n z end\" =>\n+            \"(try (block x) (catch e (block y)) (finally (block z)))\"\n+        ((v=v\"1.8\",), \"try \\n x \\n catch e \\n y \\n else z finally \\n w end\") =>\n+            \"(try (block x) (catch e (block y)) (else (block z)) (finally (block w)))\"\n+        \"try x catch end\"       =>  \"(try (block x) (catch \u25a1 (block)))\"\n+        \"try x catch ; y end\"   =>  \"(try (block x) (catch \u25a1 (block y)))\"\n+        \"try x catch \\n y end\"  =>  \"(try (block x) (catch \u25a1 (block y)))\"\n+        \"try x catch e y end\"   =>  \"(try (block x) (catch e (block y)))\"\n+        \"try x catch \\$e y end\" =>  \"(try (block x) (catch (\\$ e) (block y)))\"\n+        \"try x catch var\\\"#\\\" y end\" => \"(try (block x) (catch (var #) (block y)))\"\n+        \"try x catch e+3 y end\" =>  \"(try (block x) (catch (error (call-i e + 3)) (block y)))\"\n+        \"try x finally y end\"   =>  \"(try (block x) (finally (block y)))\"\n+        # v1.8 only\n+        ((v=v\"1.8\",), \"try catch ; else end\") => \"(try (block) (catch \u25a1 (block)) (else (block)))\"\n+        ((v=v\"1.8\",), \"try else x finally y end\") => \"(try (block) (else (error (block x))) (finally (block y)))\"\n+        ((v=v\"1.7\",), \"try catch ; else end\")  =>  \"(try (block) (catch \u25a1 (block)) (else (error (block))))\"\n+        # finally before catch :-(\n+        \"try x finally y catch e z end\"  =>  \"(try (block x) (finally (block y)) (catch e (block z)))\"\n+        \"try x end\" => \"(try (block x) (error-t))\"\n+    ],\n+    JuliaSyntax.parse_imports => [\n+        \"import A as B: x\" => \"(import (: (error (as (importpath A) B)) (importpath x)))\"\n+        \"import A, y\"      => \"(import (importpath A) (importpath y))\"\n+        \"import A: +, ==\"  => \"(import (: (importpath A) (importpath +) (importpath ==)))\"\n+        \"import A: x, y\"   => \"(import (: (importpath A) (importpath x) (importpath y)))\"\n+        \"import A: x, B: y\" => \"(import (: (importpath A) (importpath x) (importpath B) (error-t (importpath y))))\"\n+        \"import A: x\"      => \"(import (: (importpath A) (importpath x)))\"\n+        \"using  A\"         => \"(using (importpath A))\"\n+        \"import A\"         => \"(import (importpath A))\"\n+        # parse_import\n+        \"import A: x, y\"   =>  \"(import (: (importpath A) (importpath x) (importpath y)))\"\n+        \"import A as B\"    =>  \"(import (as (importpath A) B))\"\n+        \"import A: x as y\" =>  \"(import (: (importpath A) (as (importpath x) y)))\"\n+        \"using  A: x as y\" =>  \"(using (: (importpath A) (as (importpath x) y)))\"\n+        ((v=v\"1.5\",), \"import A as B\") =>  \"(import (error (as (importpath A) B)))\"\n+        \"using A as B\"     =>  \"(using (error (as (importpath A) B)))\"\n+        \"using A, B as C\"  =>  \"(using (importpath A) (error (as (importpath B) C)))\"\n+        # parse_import_path\n+        # When parsing import we must split initial dots into nontrivial\n+        # leading dots for relative paths\n+        \"import .A\"     =>  \"(import (importpath . A))\"\n+        \"import ..A\"    =>  \"(import (importpath . . A))\"\n+        \"import ...A\"   =>  \"(import (importpath . . . A))\"\n+        \"import ....A\"  =>  \"(import (importpath . . . . A))\"\n+        # Dots with spaces are allowed (a misfeature?)\n+        \"import . .A\"   =>  \"(import (importpath . . A))\"\n+        # Modules with operator symbol names\n+        \"import .\u22c6\"     =>  \"(import (importpath . \u22c6))\"\n+        # Expressions allowed in import paths\n+        \"import @x\"     =>  \"(import (importpath (macro_name x)))\"\n+        \"import \\$A\"    =>  \"(import (importpath (\\$ A)))\"\n+        \"import \\$A.@x\" =>  \"(import (importpath (\\$ A) (macro_name x)))\"\n+        \"import A.B\"    =>  \"(import (importpath A B))\"\n+        \"import A.B.C\"  =>  \"(import (importpath A B C))\"\n+        \"import A.:+\"   =>  \"(import (importpath A (quote-: +)))\"\n+        \"import A.(:+)\" =>  \"(import (importpath A (parens (quote-: +))))\"\n+        \"import A.:(+)\" =>  \"(import (importpath A (quote-: (parens +))))\"\n+        \"import A.==\"   =>  \"(import (importpath A ==))\"\n+        \"import A.\u22c6.f\"  =>  \"(import (importpath A \u22c6 f))\"\n+        \"import A...\"   =>  \"(import (importpath A ..))\"\n+        \"import A; B\"   =>  \"(import (importpath A))\"\n+        # Colons not allowed first in import paths\n+        # but are allowed in trailing components (#473)\n+        \"using :A\"         =>  \"(using (importpath (error (quote-: A))))\"\n+        \"using A: :b\"      =>  \"(using (: (importpath A) (importpath (error (quote-: b)))))\"\n+        \"using A: b.:c\"    =>  \"(using (: (importpath A) (importpath b (quote-: c))))\"\n+        # Syntactic operators not allowed in import\n+    ],\n+    JuliaSyntax.parse_iteration_specs => [\n+        \"i = rhs\"        =>  \"(iteration (in i rhs))\"\n+        \"i in rhs\"       =>  \"(iteration (in i rhs))\"\n+        \"i \u2208 rhs\"        =>  \"(iteration (in i rhs))\"\n+        \"i = 1:10\"       =>  \"(iteration (in i (call-i 1 : 10)))\"\n+        \"(i,j) in iter\"  =>  \"(iteration (in (tuple-p i j) iter))\"\n+        \"outer = rhs\"       =>  \"(iteration (in outer rhs))\"\n+        \"outer <| x = rhs\"  =>  \"(iteration (in (call-i outer <| x) rhs))\"\n+        \"outer i = rhs\"     =>  \"(iteration (in (outer i) rhs))\"\n+        \"outer (x,y) = rhs\" =>  \"(iteration (in (outer (tuple-p x y)) rhs))\"\n+    ],\n+    JuliaSyntax.parse_paren => [\n+        # Tuple syntax with commas\n+        \"()\"          =>  \"(tuple-p)\"\n+        \"(x,)\"        =>  \"(tuple-p-, x)\"\n+        \"(x,y)\"       =>  \"(tuple-p x y)\"\n+        \"(x=1, y=2)\"  =>  \"(tuple-p (= x 1) (= y 2))\"\n+        # Named tuples with initial semicolon\n+        \"(;)\"         =>  \"(tuple-p (parameters))\"\n+        \"(; a=1)\"     =>  \"(tuple-p (parameters (= a 1)))\"\n+        # Extra credit: nested parameters and frankentuples\n+        \"(x...; y)\"       => \"(tuple-p (... x) (parameters y))\"\n+        \"(x...;)\"         => \"(tuple-p (... x) (parameters))\"\n+        \"(; a=1; b=2)\"    => \"(tuple-p (parameters (= a 1)) (parameters (= b 2)))\"\n+        \"(a; b; c,d)\"     => \"(tuple-p a (parameters b) (parameters c d))\"\n+        \"(a=1, b=2; c=3)\" => \"(tuple-p (= a 1) (= b 2) (parameters (= c 3)))\"\n+        # Block syntax\n+        \"(;;)\"        =>  \"(block-p)\"\n+        \"(a=1;)\"      =>  \"(block-p (= a 1))\"\n+        \"(a;b;;c)\"    =>  \"(block-p a b c)\"\n+        \"(a=1; b=2)\"  =>  \"(block-p (= a 1) (= b 2))\"\n+        # Following is an error for flisp compatibility. But it could be\n+        # allowed as valid block syntax in the future?\n+        \"(y for x = xs; a)\" => \"(parens (generator y (iteration (in x xs))) (error-t \u2718 a))\"\n+        # Parentheses used for grouping\n+        \"(a * b)\"     =>  \"(parens (call-i a * b))\"\n+        \"(a=1)\"       =>  \"(parens (= a 1))\"\n+        \"(x)\"         =>  \"(parens x)\"\n+        \"(a...)\"      =>  \"(parens (... a))\"\n+        # Generators\n+        \"(x for a in as)\"       =>  \"(parens (generator x (iteration (in a as))))\"\n+        \"(x \\n\\n for a in as)\"  =>  \"(parens (generator x (iteration (in a as))))\"\n+        # Range parsing in parens\n+        \"(1:\\n2)\" => \"(parens (call-i 1 : 2))\"\n+        \"(1:2)\" => \"(parens (call-i 1 : 2))\"\n+    ],\n+    JuliaSyntax.parse_atom => [\n+        # char literal\n+        \"'a'\"           =>  \"(char 'a')\"\n+        \"'\u03b1'\"           =>  \"(char '\u03b1')\"\n+        \"'\\\\xce\\\\xb1'\"  =>  \"(char '\u03b1')\"\n+        \"'\\\\u03b1'\"     =>  \"(char '\u03b1')\"\n+        \"'\\\\U1D7DA'\"    =>  \"(char '\ud835\udfda')\"\n+        \"'a\"            =>  \"(char 'a' (error-t))\"\n+        \"''\"            =>  \"(char (error))\"\n+        \"'\"             =>  \"(char (error))\"\n+        # symbol/expression quote\n+        \":foo\"   => \"(quote-: foo)\"\n+        # Literal colons\n+        \":)\"     => \":\"\n+        \": end\"  => \":\"\n+        # Whitespace after quoting colon\n+        \": foo\"  => \"(quote-: (error-t) foo)\"\n+        \":\\nfoo\" => \"(quote-: (error-t) foo)\"\n+        # plain equals\n+        \"=\"      => \"(error =)\"\n+        # Identifiers\n+        \"xx\"     => \"xx\"\n+        \"x\u2081\"     => \"x\u2081\"\n+        # var syntax\n+        \"\"\"var\"x\" \"\"\"   =>  \"(var x)\"\n+        # var syntax raw string unescaping\n+        \"var\\\"\\\"\"          =>  \"(var )\"\n+        \"var\\\"\\\\\\\"\\\"\"      =>  \"(var \\\")\"\n+        \"var\\\"\\\\\\\\\\\\\\\"\\\"\"  =>  \"(var \\\\\\\")\"\n+        \"var\\\"\\\\\\\\x\\\"\"     =>  \"(var \\\\\\\\x)\"\n+        # trailing syntax after var\n+        \"\"\"var\"x\"+\"\"\"   =>  \"(var x)\"\n+        \"\"\"var\"x\")\"\"\"   =>  \"(var x)\"\n+        \"\"\"var\"x\"(\"\"\"   =>  \"(var x)\"\n+        \"\"\"var\"x\"end\"\"\" =>  \"(var x (error-t))\"\n+        \"\"\"var\"x\"1\"\"\"   =>  \"(var x (error-t))\"\n+        \"\"\"var\"x\"y\"\"\"   =>  \"(var x (error-t))\"\n+        # Standalone syntactic operators are errors\n+        \"?\"   =>  \"(error ?)\"\n+        \"&&\"  =>  \"(error &&)\"\n+        \"||\"  =>  \"(error ||)\"\n+        \".\"   =>  \"(error .)\"\n+        \"...\" =>  \"(error ...)\"\n+        \"+=\"  =>  \"(error +=)\"\n+        \"-=\"  =>  \"(error -=)\"\n+        \"*=\"  =>  \"(error *=)\"\n+        \"/=\"  =>  \"(error /=)\"\n+        \"//=\" =>  \"(error //=)\"\n+        \"|=\"  =>  \"(error |=)\"\n+        \"^=\"  =>  \"(error ^=)\"\n+        \"\u00f7=\"  =>  \"(error \u00f7=)\"\n+        \"%=\"  =>  \"(error %=)\"\n+        \"<<=\" =>  \"(error <<=)\"\n+        \">>=\" =>  \"(error >>=)\"\n+        \">>>=\"=>  \"(error >>>=)\"\n+        \"\\\\=\" =>  \"(error \\\\=)\"\n+        \"&=\"  =>  \"(error &=)\"\n+        \":=\"  =>  \"(error :=)\"\n+        \"\\$=\" =>  \"(error \\$=)\"\n+        \"\u22bb=\"  =>  \"(error \u22bb=)\"\n+        \".+=\" =>  \"(error (. +=))\"\n+        # Normal operators\n+        \"+\"  =>  \"+\"\n+        # Assignment-precedence operators which can be used as identifiers\n+        \"~\"  =>  \"~\"\n+        \"\u2254\"  =>  \"\u2254\"\n+        \"\u2a74\"  =>  \"\u2a74\"\n+        \"\u2255\"  =>  \"\u2255\"\n+        # Quoted syntactic operators allowed\n+        \":+=\"  =>  \"(quote-: +=)\"\n+        \":.+=\" =>  \"(quote-: (. +=))\"\n+        \":.=\"  =>  \"(quote-: (. =))\"\n+        \":.&&\" =>  \"(quote-: (. &&))\"\n+        # Special symbols quoted\n+        \":end\" => \"(quote-: end)\"\n+        \":(end)\" => \"(quote-: (parens (error-t)))\"\n+        \":<:\"  => \"(quote-: <:)\"\n+        # unexpected =\n+        \"=\"    => \"(error =)\"\n+        # parse_cat\n+        \"[]\"        =>  \"(vect)\"\n+        \"[x,]\"      =>  \"(vect-, x)\"\n+        \"[x,y,]\"    =>  \"(vect-, x y)\"\n+        \"[x\\n,,]\"   =>  \"(vect-, x (error-t \u2718))\"\n+        \"[x]\"       =>  \"(vect x)\"\n+        \"[x \\n ]\"   =>  \"(vect x)\"\n+        \"[x \\n, ]\"  =>  \"(vect-, x)\"\n+        \"[x\"        =>  \"(vect x (error-t))\"\n+        \"[x \\n\\n ]\" =>  \"(vect x)\"\n+        \"[x for a in as]\"  =>  \"(comprehension (generator x (iteration (in a as))))\"\n+        \"[x \\n\\n for a in as]\"  =>  \"(comprehension (generator x (iteration (in a as))))\"\n+        # parse_generator\n+        \"(x for a in as for b in bs)\" => \"(parens (generator x (iteration (in a as)) (iteration (in b bs))))\"\n+        \"(x for a in as, b in bs)\" => \"(parens (generator x (iteration (in a as) (in b bs))))\"\n+        \"(x for a in as, b in bs if z)\" => \"(parens (generator x (filter (iteration (in a as) (in b bs)) z)))\"\n+        \"(x for a in as, b in bs for c in cs, d in ds)\" => \"(parens (generator x (iteration (in a as) (in b bs)) (iteration (in c cs) (in d ds))))\"\n+        \"(x for a in as for b in bs if z)\" => \"(parens (generator x (iteration (in a as)) (filter (iteration (in b bs)) z)))\"\n+        \"(x for a in as if z for b in bs)\" => \"(parens (generator x (filter (iteration (in a as)) z) (iteration (in b bs))))\"\n+        \"[x for a = as for b = bs if cond1 for c = cs if cond2]\"  =>  \"(comprehension (generator x (iteration (in a as)) (filter (iteration (in b bs)) cond1) (filter (iteration (in c cs)) cond2)))\"\n+        \"[x for a = as if begin cond2 end]\"  =>  \"(comprehension (generator x (filter (iteration (in a as)) (block cond2))))\"\n+        \"[(x)for x in xs]\"  =>  \"(comprehension (generator (parens x) (error-t) (iteration (in x xs))))\"\n+        \"(x for a in as if z)\" => \"(parens (generator x (filter (iteration (in a as)) z)))\"\n+        # parse_vect\n+        \"[x, y]\"        =>  \"(vect x y)\"\n+        \"[x, y,]\"       =>  \"(vect-, x y)\"\n+        \"[x,\\n y]\"      =>  \"(vect x y)\"\n+        \"[x\\n, y]\"      =>  \"(vect x y)\"\n+        \"[x\\n,, y]\"     =>  \"(vect-, x (error-t \u2718 y))\"\n+        \"[x,y ; z]\"     =>  \"(vect x y (parameters z))\"\n+        \"[x=1, y=2]\"    =>  \"(vect (= x 1) (= y 2))\"\n+        \"[x=1, ; y=2]\"  =>  \"(vect (= x 1) (parameters (= y 2)))\"\n+        # parse_paren\n+        \":(=)\"  =>  \"(quote-: (parens =))\"\n+        \":(::)\"  =>  \"(quote-: (parens ::))\"\n+        \":(::\\n)\" => \"(quote-: (parens ::))\"\n+        \"(function f \\n end)\" => \"(parens (function f))\"\n+        # braces\n+        \"{x,y}\"      =>  \"(braces x y)\"\n+        \"{x,y,}\"     =>  \"(braces-, x y)\"\n+        \"{x y}\"      =>  \"(bracescat (row x y))\"\n+        ((v=v\"1.7\",), \"{x ;;; y}\") =>  \"(bracescat (nrow-3 x y))\"\n+        ((v=v\"1.7\",), \"{a ;; b}\") =>  \"(bracescat (nrow-2 a b))\"\n+        ((v=v\"1.7\",), \"{a ;;;; b}\") =>  \"(bracescat (nrow-4 a b))\"\n+        # Macro names can be keywords\n+        \"@end x\" => \"(macrocall (macro_name end) x)\"\n+        # __dot__ macro\n+        \"@. x\" => \"(macrocall (macro_name .) x)\"\n+        # cmd strings\n+        \"``\"         =>  \"(cmdstring-r \\\"\\\")\"\n+        \"`cmd`\"      =>  \"(cmdstring-r \\\"cmd\\\")\"\n+        \"```cmd```\"  =>  \"(cmdstring-s-r \\\"cmd\\\")\"\n+        # literals\n+        \"true\" => \"true\"\n+        \"42\"   => \"42\"\n+        \"1.0e-1000\"   => \"0.0\"\n+        \"0x123456789abcdefp+0\" => \"8.19855292164869e16\"\n+        # closing tokens\n+        \")\"    => \"(error)\"\n+    ],\n+    JuliaSyntax.parse_atom => [\n+        # Actually parse_array\n+        # Normal matrix construction syntax\n+        \"[x y ; z w]\"  =>  \"(vcat (row x y) (row z w))\"\n+        \"[x y ; z w ; a b]\"  =>  \"(vcat (row x y) (row z w) (row a b))\"\n+        \"[x ; y ; z]\"  =>  \"(vcat x y z)\"\n+        \"[x;]\"  =>  \"(vcat x)\"\n+        \"[x y]\"  =>  \"(hcat x y)\"\n+        # Early abort in array parsing\n+        \"[x@y\"   =>  \"(hcat x (error-t \u2718 y))\"\n+        \"[x@y]\"  =>  \"(hcat x (error-t \u2718 y))\"\n+        # Mismatched rows\n+        \"[x y ; z]\"  =>  \"(vcat (row x y) z)\"\n+        # Single elements in rows\n+        ((v=v\"1.7\",), \"[x ; y ;; z ]\")  =>  \"(ncat-2 (nrow-1 x y) z)\"\n+        ((v=v\"1.7\",), \"[x  y ;;; z ]\")  =>  \"(ncat-3 (row x y) z)\"\n+        # Higher dimensional ncat\n+        # Row major\n+        ((v=v\"1.7\",), \"[x y ; z w ;;; a b ; c d]\")  =>\n+            \"(ncat-3 (nrow-1 (row x y) (row z w)) (nrow-1 (row a b) (row c d)))\"\n+        # Column major\n+        ((v=v\"1.7\",), \"[x ; y ;; z ; w ;;; a ; b ;; c ; d]\")  =>\n+            \"(ncat-3 (nrow-2 (nrow-1 x y) (nrow-1 z w)) (nrow-2 (nrow-1 a b) (nrow-1 c d)))\"\n+        # Dimension 4 ncat\n+        ((v=v\"1.7\",), \"[x ;;;; y]\")  =>  \"(ncat-4 x y)\"\n+        ((v=v\"1.7\",), \"[a ; b ;;;; c ; d]\")  =>  \"(ncat-4 (nrow-1 a b) (nrow-1 c d))\"\n+        ((v=v\"1.7\",), \"[a b ; c d ;;;; e f ; g h]\")  =>\n+            \"(ncat-4 (nrow-1 (row a b) (row c d)) (nrow-1 (row e f) (row g h)))\"\n+        # Array separators\n+        # Newlines before semicolons are not significant\n+        \"[a \\n ;]\"  =>  \"(vcat a)\"\n+        # Newlines after semicolons are not significant\n+        \"[a ; \\n]\"  =>  \"(vcat a)\"\n+        \"[a ; \\n\\n b]\"  =>  \"(vcat a b)\"\n+        ((v=v\"1.7\",), \"[a ;; \\n b]\")  =>  \"(ncat-2 a b)\"\n+        # In hcat with spaces as separators, `;;` is a line\n+        # continuation character\n+        ((v=v\"1.7\",), \"[a b ;; \\n c]\")  =>  \"(hcat a b c)\"\n+        ((v=v\"1.7\",), \"[a b \\n ;; c]\")  =>  \"(ncat-2 (row a b (error-t)) c)\"\n+        # Can't mix spaces and multiple ;'s\n+        ((v=v\"1.7\",), \"[a b ;; c]\")  =>  \"(ncat-2 (row a b (error-t)) c)\"\n+        # Linebreaks not significant before closing `]`\n+        \"[a b\\n\\n]\" =>  \"(hcat a b)\"\n+        # Treat a linebreak prior to a value as a semicolon (ie, separator for\n+        # the first dimension) if no previous semicolons observed\n+        \"[a \\n b]\"  =>  \"(vcat a b)\"\n+        # Can't mix multiple ;'s and spaces\n+        ((v=v\"1.7\",), \"[a ;; b c]\")  =>  \"(ncat-2 a (row b (error-t) c))\"\n+        # Empty N-dimensional arrays\n+        ((v=v\"1.8\",), \"[;]\")   =>  \"(ncat-1)\"\n+        ((v=v\"1.8\",), \"[;;]\")  =>  \"(ncat-2)\"\n+        ((v=v\"1.8\",), \"[\\n  ;; \\n ]\")  =>  \"(ncat-2)\"\n+        ((v=v\"1.7\",), \"[;;]\")  =>  \"(ncat-2 (error))\"\n+        # parse_string\n+        \"\\\"\\\"\\\"\\n\\$x\\n a\\\"\\\"\\\"\" => \"(string-s x \\\"\\\\n\\\" \\\" a\\\")\"\n+        \"\\\"a \\$(x + y) b\\\"\"  =>  \"(string \\\"a \\\" (parens (call-i x + y)) \\\" b\\\")\"\n+        \"\\\"hi\\$(\\\"ho\\\")\\\"\"   =>  \"(string \\\"hi\\\" (parens (string \\\"ho\\\")))\"\n+        \"\\\"\\$(x,y)\\\"\"        =>  \"(string (parens (error x y)))\"\n+        \"\\\"\\$(x;y)\\\"\"        =>  \"(string (parens (error x y)))\"\n+        \"\\\"\\$(x for y in z)\\\"\" => \"(string (parens (error (generator x (iteration (in y z))))))\"\n+        \"\\\"\\$((x for y in z))\\\"\" => \"(string (parens (parens (generator x (iteration (in y z))))))\"\n+        \"\\\"\\$(xs...)\\\"\"  =>  \"(string (parens (... xs)))\"\n+        \"\\\"a \\$foo b\\\"\"  =>  \"(string \\\"a \\\" foo \\\" b\\\")\"\n+        \"\\\"\\$var\\\"\"      =>  \"(string var)\"\n+        \"\\\"\\$outer\\\"\"    =>  \"(string outer)\"\n+        \"\\\"\\$in\\\"\"       =>  \"(string in)\"\n+        # Triple-quoted dedenting:\n+        \"\\\"\\\"\\\"\\nx\\\"\\\"\\\"\"   =>  raw\"\"\"(string-s \"x\")\"\"\"\n+        \"\\\"\\\"\\\"\\n\\nx\\\"\\\"\\\"\" =>  raw\"\"\"(string-s \"\\n\" \"x\")\"\"\"\n+        \"```\\n x\\n y```\"    =>  raw\"\"\"(cmdstring-s-r \"x\\n\" \"y\")\"\"\"\n+        # Various newlines (\\n \\r \\r\\n) and whitespace (' ' \\t)\n+        \"\\\"\\\"\\\"\\n x\\n y\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \"x\\n\" \"y\")\"\"\"\n+        \"\\\"\\\"\\\"\\r x\\r y\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \"x\\n\" \"y\")\"\"\"\n+        \"\\\"\\\"\\\"\\r\\n x\\r\\n y\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \"x\\n\" \"y\")\"\"\"\n+        # Spaces or tabs or mixtures acceptable\n+        \"\\\"\\\"\\\"\\n\\tx\\n\\ty\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \"x\\n\" \"y\")\"\"\"\n+        \"\\\"\\\"\\\"\\n \\tx\\n \\ty\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \"x\\n\" \"y\")\"\"\"\n+        # Mismatched tab vs space not deindented\n+        # Find minimum common prefix in mismatched whitespace\n+        \"\\\"\\\"\\\"\\n\\tx\\n y\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \"\\tx\\n\" \" y\")\"\"\"\n+        \"\\\"\\\"\\\"\\n x\\n  y\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \"x\\n\" \" y\")\"\"\"\n+        \"\\\"\\\"\\\"\\n  x\\n y\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \" x\\n\" \"y\")\"\"\"\n+        \"\\\"\\\"\\\"\\n \\tx\\n  y\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \"\\tx\\n\" \" y\")\"\"\"\n+        \"\\\"\\\"\\\"\\n  x\\n \\ty\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \" x\\n\" \"\\ty\")\"\"\"\n+        # Empty lines don't affect dedenting\n+        \"\\\"\\\"\\\"\\n x\\n\\n y\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \"x\\n\" \"\\n\" \"y\")\"\"\"\n+        # Non-empty first line doesn't participate in deindentation\n+        \"\\\"\\\"\\\" x\\n y\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \" x\\n\" \"y\")\"\"\"\n+        # Dedenting and interpolations\n+        \"\\\"\\\"\\\"\\n  \\$a\\n  \\$b\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s a \"\\n\" b)\"\"\"\n+        \"\\\"\\\"\\\"\\n  \\$a \\n  \\$b\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s a \" \\n\" b)\"\"\"\n+        \"\\\"\\\"\\\"\\n  \\$a\\n  \\$b\\n\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \"  \" a \"\\n\" \"  \" b \"\\n\")\"\"\"\n+        # Empty chunks after dedent are removed\n+        \"\\\"\\\"\\\"\\n \\n \\\"\\\"\\\"\"  =>  \"(string-s \\\"\\\\n\\\")\"\n+        # Newline at end of string\n+        \"\\\"\\\"\\\"\\n x\\n y\\n\\\"\\\"\\\"\"  =>  raw\"\"\"(string-s \" x\\n\" \" y\\n\")\"\"\"\n+        # Empty strings, or empty after triple quoted processing\n+        \"\\\"\\\"\"              =>  \"(string \\\"\\\")\"\n+        \"\\\"\\\"\\\"\\n  \\\"\\\"\\\"\"  =>  \"(string-s \\\"\\\")\"\n+        # Missing delimiter\n+        \"\\\"str\"  =>  \"(string \\\"str\\\" (error-t))\"\n+        # String interpolations\n+        \"\\\"\\$x\\$y\\$z\\\"\"  =>  \"(string x y z)\"\n+        \"\\\"\\$(x)\\\"\"  =>  \"(string (parens x))\"\n+        \"\\\"\\$x\\\"\"  =>  \"(string x)\"\n+        # Strings with embedded whitespace trivia\n+        \"\\\"a\\\\\\nb\\\"\"     =>  raw\"\"\"(string \"a\" \"b\")\"\"\"\n+        \"\\\"a\\\\\\rb\\\"\"     =>  raw\"\"\"(string \"a\" \"b\")\"\"\"\n+        \"\\\"a\\\\\\r\\nb\\\"\"   =>  raw\"\"\"(string \"a\" \"b\")\"\"\"\n+        \"\\\"a\\\\\\n \\tb\\\"\"  =>  raw\"\"\"(string \"a\" \"b\")\"\"\"\n+        # Strings with only a single valid string chunk\n+        \"\\\"str\\\"\"     => \"(string \\\"str\\\")\"\n+        \"\\\"a\\\\\\n\\\"\"   => \"(string \\\"a\\\")\"\n+        \"\\\"a\\\\\\r\\\"\"   => \"(string \\\"a\\\")\"\n+        \"\\\"a\\\\\\r\\n\\\"\" => \"(string \\\"a\\\")\"\n+    ],\n+    JuliaSyntax.parse_atom => [\n+        # errors in literals\n+        \"\\\"\\\\xqqq\\\"\"  =>  \"(string (ErrorInvalidEscapeSequence))\"\n+        \"'\\\\xq'\"      =>  \"(char (ErrorInvalidEscapeSequence))\"\n+        \"'ab'\"        =>  \"(char (ErrorOverLongCharacter))\"\n+        \"\\\"\\xf5\\\"\"    =>  \"(string (ErrorInvalidUTF8))\"\n+        \"'\\xf5'\"      =>  \"(char (ErrorInvalidUTF8))\"\n+        \"`\\xf5`\"      =>  \"(cmdstring-r (ErrorInvalidUTF8))\"\n+        \"10.0e1000'\"  =>  \"(ErrorNumericOverflow)\"\n+        \"10.0f100'\"   =>  \"(ErrorNumericOverflow)\"\n+    ],\n+    JuliaSyntax.parse_stmts => with_version.(v\"1.11\", [\n+        \"function f(public)\\n    public + 3\\nend\"       => \"(function (call f public) (block (call-i public + 3)))\"\n+        \"public A, B\"                                   => \"(public A B)\"\n+        \"if true \\n public *= 4 \\n end\"                 => \"(if true (block (op= public * 4)))\"\n+        \"module Mod\\n public A, B \\n end\"               => \"(module Mod (block (public A B)))\"\n+        \"module Mod2\\n a = 3; b = 6; public a, b\\n end\" => \"(module Mod2 (block (= a 3) (= b 6) (public a b)))\"\n+        \"a = 3; b = 6; public a, b\"                     => \"(toplevel-; (= a 3) (= b 6) (public a b))\"\n+        \"begin \\n public A, B \\n end\"                   => PARSE_ERROR\n+        \"if true \\n public A, B \\n end\"                 => PARSE_ERROR\n+        \"public export=true foo, bar\"                   => PARSE_ERROR # but these may be\n+        \"public experimental=true foo, bar\"             => PARSE_ERROR # supported soon ;)\n+        \"public(x::String) = false\"                     => \"(function-= (call public (::-i x String)) false)\"\n+        \"module M; export @a; end\"                      => \"(module M (block (export (macro_name a))))\"\n+        \"module M; public @a; end\"                      => \"(module M (block (public (macro_name a))))\"\n+        \"module M; export \u2908; end\"                       => \"(module M (block (export \u2908)))\"\n+        \"module M; public \u2908; end\"                       => \"(module M (block (public \u2908)))\"\n+        \"public = 4\"                                    => \"(= public 4)\"\n+        \"public[7] = 5\"                                 => \"(= (ref public 7) 5)\"\n+        \"public() = 6\"                                  => \"(function-= (call public) 6)\"\n+    ]),\n+    JuliaSyntax.parse_stmts => [\n+        ((v = v\"1.12\",), \"@callmemacro(b::Float64) = 2\") => \"(= (macrocall-p (macro_name callmemacro) (::-i b Float64)) 2)\"\n+    ],\n+    JuliaSyntax.parse_docstring => [\n+        \"\"\" \"notdoc\" ]        \"\"\" => \"(string \\\"notdoc\\\")\"\n+        \"\"\" \"notdoc\" \\n]      \"\"\" => \"(string \\\"notdoc\\\")\"\n+        \"\"\" \"notdoc\" \\n\\n foo \"\"\" => \"(string \\\"notdoc\\\")\"\n+        \"\"\" \"doc\" \\n foo      \"\"\" => \"\"\"(doc (string \"doc\") foo)\"\"\"\n+        \"\"\" \"doc\" foo         \"\"\" => \"\"\"(doc (string \"doc\") foo)\"\"\"\n+        \"\"\" \"doc \\$x\" foo     \"\"\" => \"\"\"(doc (string \"doc \" x) foo)\"\"\"\n+        # Allow docstrings with embedded trailing whitespace trivia\n+        \"\\\"\\\"\\\"\\n doc\\n \\\"\\\"\\\" foo\"  => \"\"\"(doc (string-s \"doc\\\\n\") foo)\"\"\"\n+    ],\n+]\n+\n+@testset \"Inline test cases\" begin\n+    @testset \"$production\" for (production, test_specs) in tests\n+        @testset \"$(repr(input))\" for (input, output) in test_specs\n+            test_parse(production, input, output)\n+        end\n+    end\n+end\n+\n+parsestmt_test_specs = [\n+    # whitespace before keywords in space-insensitive mode\n+    \"(y::\\nif x z end)\" => \"(parens (::-i y (if x (block z))))\"\n+    # Contextual keyword pairs inside parentheses\n+    \"(abstract type X end)\" => \"(parens (abstract X))\"\n+    \"(mutable struct X end)\" => \"(parens (struct-mut X (block)))\"\n+    # parsing of tricky primes\n+    \"x in'c'\"   => \"(call-i x in (char 'c'))\"\n+    \"1where'c'\" => \"(where 1 (char 'c'))\"\n+    \":+'y'\"     => \"(juxtapose (call-post (quote-: +) ') (call-post y '))\"\n+    # unary subtype ops and newlines\n+    \"a +\\n\\n<:\" => \"(call-i a + <:)\"\n+    \"for\\n\\n<:\" => \"(for (iteration (in <: (error (error-t)))) (block (error)) (error-t))\"\n+    # Empty character consumes trailing ' delimiter (ideally this could be\n+    # tested above but we don't require the input stream to be consumed in the\n+    # unit tests there.\n+    \"''\" => \"(char (error))\"\n+\n+    # The following may not be ideal error recovery! But at least the parser\n+    # shouldn't crash\n+    \"@(x y)\" => \"(macrocall (macro_name (parens x (error-t y))))\"\n+    \"|(&\\nfunction\" => \"(call | (& (function (error (error)) (block (error)) (error-t))) (error-t))\"\n+    \"@(\" => \"(macrocall (macro_name (parens (error-t))))\"\n+    \"x = @(\" => \"(= x (macrocall (macro_name (parens (error-t)))))\"\n+    \"function(where\" => \"(function (tuple-p where (error-t)) (block (error)) (error-t))\"\n+    # Contextual keyword pairs must not be separated by newlines even within parens\n+    \"(abstract\\ntype X end)\" => \"(wrapper (parens abstract (error-t type X)) (error-t end \u2718))\"\n+    \"(mutable\\nstruct X end)\" => \"(wrapper (parens mutable (error-t struct X)) (error-t end \u2718))\"\n+\n+    # Lexer vs parser: issues detecting which tokens are string delimiters and\n+    # detecting raw vs non-raw strings. The old parser was tightly coupled to\n+    # the lexer and the parser state was used to disambiguate these cases.\n+    \"x in' '\" => \"(call-i x in (char (error)))\"\n+    \"x in'``\\$\" => \"(call-i x in (call-i (juxtapose (char '`' (error-t)) (cmdstring-r (error-t))) \\$ (error)))\"\n+    \"var\\\"#\\\"`str`\" => \"(juxtapose (var # (error-t)) (cmdstring-r \\\"str\\\"))\"\n+    \"var\\\"#\\\"\\\"str\\\"\" => \"(juxtapose (var # (error-t)) (error-t) (string \\\"str\\\"))\"\n+\n+    # trailing junk in generators (issue #407)\n+    \"(x for x = xs a)\"      =>  \"(parens (generator x (iteration (in x xs))) (error-t a))\"\n+    \"(x for x = xs a, b)\"   =>  \"(parens (generator x (iteration (in x xs))) (error-t a \u2718 b))\"\n+    \"f(x for x = xs a)\"     =>  \"(call f (generator x (iteration (in x xs))) (error-t a))\"\n+]\n+\n+@testset \"Parser does not crash on broken code\" begin\n+    @testset \"$(repr(input))\" for (input, output) in parsestmt_test_specs\n+        test_parse(JuliaSyntax.parse_stmts, input, output)\n+    end\n+end\n+\n+parsestmt_with_kind_tests = [\n+    # Most operators are semantically just normal identifiers after parsing so\n+    # get the Kind K\"Identifier\"\n+    \"+\"      => \"+::Identifier\"\n+    \"a + b\"  => \"(call-i a::Identifier +::Identifier b::Identifier)\"\n+    \"a .+ b\" => \"(dotcall-i a::Identifier +::Identifier b::Identifier)\"\n+    \"a |> b\" => \"(call-i a::Identifier |>::Identifier b::Identifier)\"\n+    \"a => b\" => \"(call-i a::Identifier =>::Identifier b::Identifier)\"\n+    \"a \u2192  b\" => \"(call-i a::Identifier \u2192::Identifier b::Identifier)\"\n+    \"a < b < c\" => \"(comparison a::Identifier <::Identifier b::Identifier <::Identifier c::Identifier)\"\n+    \"a .<: b\"=> \"(dotcall-i a::Identifier <:::Identifier b::Identifier)\"\n+    \"a .. b\" => \"(call-i a::Identifier ..::Identifier b::Identifier)\"\n+    \"a : b\"  => \"(call-i a::Identifier :::Identifier b::Identifier)\"\n+    \"-2^x\"   => \"(call-pre -::Identifier (call-i 2::Integer ^::Identifier x::Identifier))\"\n+    \"-(2)\"   => \"(call-pre -::Identifier (parens 2::Integer))\"\n+    \"<:(a,)\" => \"(<:-, a::Identifier)\"\n+    \"- 2\"    => \"(call-pre -::Identifier 2::Integer)\"\n+    \"/x\"     => \"(call-pre (error /::Identifier) x::Identifier)\"\n+    \"a^b\"    => \"(call-i a::Identifier ^::Identifier b::Identifier)\"\n+    \"f.'\"    => \"(dotcall-post f::Identifier (error '::Identifier))\"\n+    \"f'\"     => \"(call-post f::Identifier '::Identifier)\"\n+    # Standalone syntactic ops which keep their kind - they can't really be\n+    # used in a sane way as identifiers or interpolated into expressions\n+    # because they have their own syntactic forms.\n+    \":(::)\"  => \"(quote-: (parens ::::::))\"\n+    \":(\\$)\"  => \"(quote-: (parens \\$::\\$))\"\n+    \":(<:)\"  => \"(quote-: (parens <:::<:))\"\n+    \":(&&)\"  => \"(quote-: (parens &&::&&))\"\n+    \":(=)\"   => \"(quote-: (parens =::=))\"\n+    \"a := b\" => \"(:= a::Identifier b::Identifier)\"\n+    \"a += b\" => \"(op= a::Identifier +::Identifier b::Identifier)\"\n+    \"a .+= b\" => \"(.op= a::Identifier +::Identifier b::Identifier)\"\n+    \"a >>= b\" => \"(op= a::Identifier >>::Identifier b::Identifier)\"\n+    \":+=\"    => \"(quote-: +=::op=)\"\n+    \":.+=\"   => \"(quote-: (. +=::op=))\"\n+    # str/cmd macro name kinds\n+    \"x\\\"str\\\"\"   => \"\"\"(macrocall x::StrMacroName (string-r \"str\"::String))\"\"\"\n+    \"x`str`\"     => \"\"\"(macrocall x::CmdMacroName (cmdstring-r \"str\"::CmdString))\"\"\"\n+]\n+\n+@testset \"parser `Kind` remapping\" begin\n+    @testset \"$(repr(input))\" for (input, output) in parsestmt_with_kind_tests\n+        input = ((show_kind=true,), input)\n+        test_parse(JuliaSyntax.parse_stmts, input, output)\n+    end\n+end\n+\n+@testset \"Trivia attachment\" begin\n+    # TODO: Need to expand this greatly to cover as many forms as possible!\n+    @test show_green_tree(\"f(a;b)\") == \"\"\"\n+         1:6      \u2502[toplevel]\n+         1:6      \u2502  [call]\n+         1:1      \u2502    Identifier           \u2714   \"f\"\n+         2:2      \u2502    (                        \"(\"\n+         3:3      \u2502    Identifier           \u2714   \"a\"\n+         4:5      \u2502    [parameters]\n+         4:4      \u2502      ;                      \";\"\n+         5:5      \u2502      Identifier         \u2714   \"b\"\n+         6:6      \u2502    )                        \")\"\n+    \"\"\"\n+end\n+\n+@testset \"Unicode normalization in tree conversion\" begin\n+    # \u025b\u00b5 normalizes to \u03b5\u03bc\n+    @test parse_to_sexpr_str(JuliaSyntax.parse_eq, \"\\u025B\\u00B5()\") == \"(call \\u03B5\\u03BC)\"\n+    @test parse_to_sexpr_str(JuliaSyntax.parse_eq, \"@\\u025B\\u00B5\") == \"(macrocall (macro_name \\u03B5\\u03BC))\"\n+    @test parse_to_sexpr_str(JuliaSyntax.parse_eq, \"\\u025B\\u00B5\\\"\\\"\") == \"(macrocall @\\u03B5\\u03BC_str (string-r \\\"\\\"))\"\n+    @test parse_to_sexpr_str(JuliaSyntax.parse_eq, \"\\u025B\\u00B5``\") == \"(macrocall @\\u03B5\\u03BC_cmd (cmdstring-r \\\"\\\"))\"\n+    # \u0387 and \u00b7 normalize to \u22c5\n+    @test parse_to_sexpr_str(JuliaSyntax.parse_eq, \"a \\u00B7 b\") == \"(call-i a \\u22C5 b)\"\n+    @test parse_to_sexpr_str(JuliaSyntax.parse_eq, \"a \\u0387 b\") == \"(call-i a \\u22C5 b)\"\n+    # \u2212 ('\\u2212') normalizes to - ('\\u002d')\n+    @test parse_to_sexpr_str(JuliaSyntax.parse_expr, \"a \\u2212 b\")  == \"(call-i a - b)\"\n+    @test parse_to_sexpr_str(JuliaSyntax.parse_eq, \"a \\u2212= b\") == \"(op= a - b)\"\n+    @test parse_to_sexpr_str(JuliaSyntax.parse_eq, \"a .\\u2212= b\") == \"(.op= a - b)\"\n+end\n+\n+@testset \"Unbalanced bidirectional unicode\" begin\n+    # https://trojansource.codes\n+    @test_throws JuliaSyntax.ParseError parsestmt(GreenNode, \"\"\"\n+    function checkUserAccess(u::User)\n+        if u.accessLevel != \"user\\u202e \\u2066# users are not allowed\\u2069\\u2066\"\n+            return true\n+        end\n+        return false\n+    end\n+    \"\"\")\n+\n+    @test_throws JuliaSyntax.ParseError parsestmt(GreenNode, \"\"\"\n+    function checkUserAccess(u::User)\n+        #=\\u202e \\u2066if (u.isAdmin)\\u2069 \\u2066 begin admins only =#\n+            return true\n+        #= end admin only \\u202e \\u2066end\\u2069 \\u2066=#\n+        return false\n+    end\n+    \"\"\")\n+end"
    },
    {
      "sha": "10a09d3ace58599cfc8707ea4632e41f58251f1d",
      "filename": "JuliaSyntax/test/parser_api.jl",
      "status": "added",
      "additions": 237,
      "deletions": 0,
      "changes": 237,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fparser_api.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fparser_api.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fparser_api.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,237 @@\n+@testset \"parser API\" begin\n+    @testset \"parse with String input\" begin\n+        @test parsestmt(Expr, \" x \") == :x\n+        @test JuliaSyntax.remove_linenums!(parseall(Expr, \" x \")) == Expr(:toplevel, :x)\n+        @test parseatom(Expr, \" x \") == :x\n+        @test parseatom(Expr, \"(x)\") == :x\n+\n+        # SubString\n+        @test parsestmt(Expr, SubString(\"x+y\")) == :(x+y)\n+        @test parsestmt(Expr, SubString(\"\u03b1+x\")) == :(\u03b1+x)\n+        @test parseatom(Expr, SubString(\"x+y\",3,3)) == :y\n+\n+        # Exceptions due to extra trailing syntax\n+        @test_throws JuliaSyntax.ParseError parseatom(Expr, \"x+y\")\n+        @test_throws JuliaSyntax.ParseError parsestmt(Expr, \"x+y\\nz\")\n+\n+        # ignore_warnings flag\n+        @test_throws JuliaSyntax.ParseError parsestmt(Expr, \"import . .A\")\n+        @test parsestmt(Expr, \"import . .A\", ignore_warnings=true) == :(import ..A)\n+\n+        # version selection\n+        @test_throws JuliaSyntax.ParseError parsestmt(Expr, \"[a ;; b]\", version=v\"1.6\")\n+        @test parsestmt(Expr, \"[a ;; b]\", version=v\"1.7\") == Expr(:ncat, 2, :a, :b)\n+\n+        # filename\n+        @test parsestmt(Expr, \"begin\\na\\nend\", filename=\"foo.jl\", first_line=55) ==\n+            Expr(:block, LineNumberNode(56, Symbol(\"foo.jl\")), :a)\n+\n+        # ignore_trivia\n+        @test parseatom(Expr, \" x \", ignore_trivia=true) == :x\n+        @test_throws JuliaSyntax.ParseError parseatom(Expr, \" x \", ignore_trivia=false)\n+\n+        # Top level parsing\n+        @test parseall(Expr, \"a\\nb\") ==\n+            Expr(:toplevel, LineNumberNode(1), :a, LineNumberNode(2), :b)\n+        @test parseall(Expr, \"a\\nb #==#\") ==\n+            Expr(:toplevel, LineNumberNode(1), :a, LineNumberNode(2), :b)\n+        @test parseall(Expr, \"#==#\\na\\nb\") ==\n+            Expr(:toplevel, LineNumberNode(2), :a, LineNumberNode(3), :b)\n+        @test parseall(Expr, \"a\\nb\\n#==#\") ==\n+            Expr(:toplevel, LineNumberNode(1), :a, LineNumberNode(2), :b)\n+    end\n+\n+    @testset \"IO input\" begin\n+        # IOBuffer\n+        io = IOBuffer(\"x+y\")\n+        @test parse!(Expr, io, rule=:statement) == (:(x+y), [])\n+        @test position(io) == 3\n+        io = IOBuffer(\"x+y\")\n+        seek(io, 2)\n+        @test parse!(Expr, io, rule=:atom) == (:y, [])\n+        @test position(io) == 3\n+        # A GenericIOBuffer, not actually IOBuffer\n+        io = IOBuffer(SubString(\"x+y\"))\n+        @test parse!(Expr, io, rule=:statement) == (:(x+y), [])\n+        @test position(io) == 3\n+        # Another type of GenericIOBuffer\n+        io = IOBuffer(codeunits(\"x+y\"))\n+        @test parse!(Expr, io, rule=:statement) == (:(x+y), [])\n+        @test position(io) == 3\n+        # IOStream\n+        mktemp() do path, io\n+            write(io, \"x+y\")\n+            close(io)\n+\n+            open(path, \"r\") do io\n+                @test parse!(Expr, io, rule=:statement) == (:(x+y), [])\n+                @test position(io) == 3\n+            end\n+        end\n+    end\n+\n+    @testset \"parse with String and index input\" begin\n+        # String\n+        let\n+            ex,pos = parseall(Expr, \"x+y\\nz\", 1)\n+            @test JuliaSyntax.remove_linenums!(ex) == Expr(:toplevel, :(x+y), :z)\n+            @test pos == 6\n+        end\n+        @test parsestmt(Expr, \"x+y\\nz\", 1)     == (:(x+y), 4)\n+        @test parseatom(Expr, \"x+y\\nz\", 1) == (:x, 2)\n+        @test parseatom(Expr, \"x+y\\nz\", 5) == (:z, 6)\n+\n+        # SubString\n+        @test parsestmt(Expr, SubString(\"\u03b1+x\\ny\"), 1)  == (:(\u03b1+x), 5)\n+        @test parseatom(Expr, SubString(\"x+y\"), 1) == (:x, 2)\n+        @test parseatom(Expr, SubString(\"x+y\"), 3) == (:y, 4)\n+\n+        @test parseatom(Expr, SubString(\"x+1.0\"), 3) == (1.0, 6)\n+        @test parseatom(Expr, SubString(\"x+\\\"\\n\\\"\"), 3) == (\"\\n\", 6)\n+\n+        # Line numbers are relative to the start of the string we're currently\n+        # parsing\n+        @test JuliaSyntax.parsestmt(Expr, \"begin\\na\\nend\\nbegin\\nb\\nend\", 1) ==\n+            (Expr(:block, LineNumberNode(2), :a), 12)\n+        @test JuliaSyntax.parsestmt(Expr, \"begin\\na\\nend\\nbegin\\nb\\nend\", 12) ==\n+            (Expr(:block, LineNumberNode(3), :b), 24)\n+    end\n+\n+    @testset \"error/warning handling\" begin\n+        parseshow(s;kws...) = sprint(show, MIME(\"text/x.sexpression\"), parsestmt(SyntaxNode, s; kws...))\n+        @test_throws JuliaSyntax.ParseError parseshow(\"try finally catch ex end\")\n+        @test parseshow(\"try finally catch ex end\", ignore_warnings=true) ==\n+            \"(try (block) (finally (block)) (catch ex (block)))\"\n+        # ignore_errors\n+        @test_throws JuliaSyntax.ParseError parseshow(\"[a; b, c]\")\n+        @test_throws JuliaSyntax.ParseError parseshow(\"[a; b, c]\", ignore_warnings=true)\n+        @test parseshow(\"[a; b, c]\", ignore_errors=true) == \"(vcat a b (error-t) c)\"\n+        # errors in literals\n+        @test parseshow(\"\\\"\\\\z\\\"\", ignore_errors=true) == \"(string (ErrorInvalidEscapeSequence))\"\n+        @test parseshow(\"'\\\\z'\", ignore_errors=true) == \"(char (ErrorInvalidEscapeSequence))\"\n+        @test parseshow(\"'abc'\", ignore_errors=true) == \"(char (ErrorOverLongCharacter))\"\n+        @test parseshow(\"1e1000\", ignore_errors=true) == \"(ErrorNumericOverflow)\"\n+        @test parseshow(\"1f1000\", ignore_errors=true) == \"(ErrorNumericOverflow)\"\n+    end\n+end\n+\n+@testset \"ParseError printing\" begin\n+    try\n+        parsestmt(SyntaxNode, \"a -- b -- c\", filename=\"somefile.jl\")\n+        @assert false \"error should be thrown\"\n+    catch exc\n+        @test exc isa JuliaSyntax.ParseError\n+        @test sprint(showerror, exc) == \"\"\"\n+            ParseError:\n+            # Error @ somefile.jl:1:3\n+            a -- b -- c\n+            # \u2514\u2518 \u2500\u2500 invalid operator\"\"\"\n+        @test occursin(\"Stacktrace:\\n\", sprint(showerror, exc, catch_backtrace()))\n+        file_url = JuliaSyntax._file_url(\"somefile.jl\")\n+        @test sprint(showerror, exc, context=:color=>true) == \"\"\"\n+            ParseError:\n+            \\e[90m# Error @ \\e[0;0m\\e]8;;$file_url#1:3\\e\\\\\\e[90msomefile.jl:1:3\\e[0;0m\\e]8;;\\e\\\\\n+            a \\e[48;2;120;70;70m--\\e[0;0m b -- c\n+            \\e[90m# \u2514\u2518 \u2500\u2500 \\e[0;0m\\e[91minvalid operator\\e[0;0m\"\"\"\n+    end\n+\n+    try\n+        # Test that warnings are printed first followed by only the first error\n+        parsestmt(SyntaxNode, \"\"\"\n+           @(a)\n+           x -- y\n+           z -- y\"\"\", filename=\"somefile.jl\")\n+        @assert false \"error should be thrown\"\n+    catch exc\n+        @test exc isa JuliaSyntax.ParseError\n+        @test sprint(showerror, exc) == \"\"\"\n+            ParseError:\n+            # Warning @ somefile.jl:1:2\n+            @(a)\n+            #\u2514\u2500\u2518 \u2500\u2500 parenthesizing macro names is unnecessary\n+            # Error @ somefile.jl:2:1\n+            @(a)\n+            x\n+            \u2559 \u2500\u2500 unexpected text after parsing statement\"\"\"\n+    end\n+\n+    try\n+        # Test that initial warnings are always printed\n+        parsestmt(SyntaxNode, \"\"\"\n+           @(a)\"\"\", filename=\"somefile.jl\")\n+        @assert false \"error should be thrown\"\n+    catch exc\n+        @test exc isa JuliaSyntax.ParseError\n+        @test sprint(showerror, exc) == \"\"\"\n+            ParseError: some warnings detected:\n+            # Warning @ somefile.jl:1:2\n+            @(a)\n+            #\u2514\u2500\u2518 \u2500\u2500 parenthesizing macro names is unnecessary\"\"\"\n+    end\n+end\n+\n+tokensplit(str; kws...) = [kind(tok) => untokenize(tok, str) for tok in tokenize(str; kws...)]\n+\n+@testset \"tokenize() API\" begin\n+    # tokenize() is eager\n+    @test tokenize(\"aba\") isa Vector{JuliaSyntax.Token}\n+\n+    # . is a separate token from + in `.+`\n+    @test tokensplit(\"a .+ \u03b2\") == [\n+        K\"Identifier\" => \"a\",\n+        K\"Whitespace\" => \" \",\n+        K\".\" => \".\",\n+        K\"Identifier\" => \"+\",\n+        K\"Whitespace\" => \" \",\n+        K\"Identifier\" => \"\u03b2\",\n+    ]\n+\n+    # + is kind K\"+\" when operators in identifier position are emitted as\n+    # operator kinds.\n+    @test tokensplit(\"a .+ \u03b2\"; operators_as_identifiers=false) == [\n+        K\"Identifier\" => \"a\",\n+        K\"Whitespace\" => \" \",\n+        K\".\" => \".\",\n+        K\"+\" => \"+\",\n+        K\"Whitespace\" => \" \",\n+        K\"Identifier\" => \"\u03b2\",\n+    ]\n+\n+    # Contextual keywords become identifiers where necessary\n+    @test tokensplit(\"outer = 1\") == [\n+        K\"Identifier\" => \"outer\",\n+        K\"Whitespace\" => \" \",\n+        K\"=\" => \"=\",\n+        K\"Whitespace\" => \" \",\n+        K\"Integer\" => \"1\",\n+    ]\n+    # Including word operators\n+    @test tokensplit(\"where = 1\"; operators_as_identifiers=false) == [\n+        K\"Identifier\" => \"where\",\n+        K\"Whitespace\" => \" \",\n+        K\"=\" => \"=\",\n+        K\"Whitespace\" => \" \",\n+        K\"Integer\" => \"1\",\n+    ]\n+\n+    # A predicate based on flags()\n+    @test JuliaSyntax.is_suffixed(tokenize(\"+\u2081\")[1])\n+\n+    # Buffer interface\n+    @test tokenize(Vector{UInt8}(\"a + b\")) == tokenize(\"a + b\")\n+\n+    buf = Vector{UInt8}(\"a-\u03b2\")\n+    @test untokenize.(tokenize(buf), Ref(buf,)) == [\n+        Vector{UInt8}(\"a\"),\n+        Vector{UInt8}(\"-\"),\n+        Vector{UInt8}(\"\u03b2\")\n+    ]\n+\n+    @test kind(JuliaSyntax.Token()) == K\"None\"\n+\n+    @test tokensplit(\"'\\\\\") == [\n+        K\"'\" => \"'\",\n+        K\"ErrorInvalidEscapeSequence\" => \"\\\\\",\n+        K\"error\" => \"\"\n+    ]\n+end"
    },
    {
      "sha": "644f07312498277175da4c2ffba328e8ab6314ed",
      "filename": "JuliaSyntax/test/runtests.jl",
      "status": "added",
      "additions": 38,
      "deletions": 0,
      "changes": 38,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fruntests.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,38 @@\n+if !(@isdefined JuliaSyntax)\n+    using JuliaSyntax\n+end\n+\n+using Test\n+\n+include(\"test_utils.jl\")\n+include(\"test_utils_tests.jl\")\n+include(\"fuzz_test.jl\")\n+\n+include(\"utils.jl\")\n+include(\"kinds.jl\")\n+\n+@testset \"Tokenize\" begin\n+    include(\"tokenize.jl\")\n+end\n+\n+include(\"parse_stream.jl\")\n+include(\"parser.jl\")\n+include(\"green_node.jl\")\n+include(\"syntax_tree.jl\")\n+include(\"diagnostics.jl\")\n+include(\"parser_api.jl\")\n+include(\"expr.jl\")\n+@testset \"Parsing literals from strings\" begin\n+    include(\"literal_parsing.jl\")\n+end\n+include(\"source_files.jl\")\n+\n+if VERSION >= v\"1.6\"\n+    # Tests restricted to 1.6+ due to\n+    # * Core._parse hook doesn't exist on v1.5 and lower\n+    # * Reference parser bugs which would need workarounds for package parse comparisons\n+    include(\"hooks.jl\")\n+    include(\"parse_packages.jl\")\n+end\n+\n+include(\"serialization.jl\")"
    },
    {
      "sha": "52980e4917dcfddcbae1b3a22de8862d6d840f61",
      "filename": "JuliaSyntax/test/runtests_vendored.jl",
      "status": "added",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fruntests_vendored.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fruntests_vendored.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fruntests_vendored.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,4 @@\n+# Test copy of JuliaSyntax vendored into Base\n+using Base.JuliaSyntax: JuliaSyntax\n+\n+include(\"runtests.jl\")"
    },
    {
      "sha": "abdc5fa61e72fe2ebc266ec1f6f43f16cf061cc3",
      "filename": "JuliaSyntax/test/serialization.jl",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fserialization.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fserialization.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fserialization.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,29 @@\n+using Serialization\n+\n+@testset \"Equality $T\" for T in [Expr, SyntaxNode, JuliaSyntax.GreenNode]\n+    x = JuliaSyntax.parsestmt(T, \"f(x) = x + 2\")\n+    y = JuliaSyntax.parsestmt(T, \"f(x) = x + 2\")\n+    z = JuliaSyntax.parsestmt(T, \"f(x) = 2 + x\")\n+    @test x == y\n+    @test x != z\n+    @test y != z\n+end\n+\n+@testset \"Hashing $T\" for T in [Expr, SyntaxNode, JuliaSyntax.GreenNode]\n+    x = hash(JuliaSyntax.parsestmt(T, \"f(x) = x + 2\"))::UInt\n+    y = hash(JuliaSyntax.parsestmt(T, \"f(x) = x + 2\"))::UInt\n+    z = hash(JuliaSyntax.parsestmt(T, \"f(x) = 2 + x\"))::UInt\n+    @test x == y # Correctness\n+    @test x != z # Collision\n+    @test y != z # Collision\n+end\n+\n+@testset \"Serialization $T\" for T in [Expr, SyntaxNode, JuliaSyntax.GreenNode]\n+    x = JuliaSyntax.parsestmt(T, \"f(x) = x \u22c5 2\")\n+    f = tempname()\n+    open(f, \"w\") do io\n+        serialize(io, x)\n+    end\n+    y = open(deserialize, f, \"r\")\n+    @test x == y\n+end"
    },
    {
      "sha": "d518124f1e6e115066d8dd823ad5bbb22b19bc85",
      "filename": "JuliaSyntax/test/source_files.jl",
      "status": "added",
      "additions": 230,
      "deletions": 0,
      "changes": 230,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fsource_files.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fsource_files.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fsource_files.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,230 @@\n+@testset \"SourceFile lines and column indexing\" begin\n+    @test source_location(SourceFile(\"a\"), 1) == (1,1)\n+    @test source_location(SourceFile(\"a\"), 2) == (1,2)\n+\n+    @test source_location(SourceFile(\"a\\n\"), 2) == (1,2)\n+    @test source_location(SourceFile(\"a\\n\"), 3) == (2,1)\n+\n+    @test source_location(SourceFile(\"a\\nb\\n\"), 2) == (1,2)\n+    @test source_location(SourceFile(\"a\\nb\\n\"), 3) == (2,1)\n+    @test source_location(SourceFile(\"a\\nb\\n\"), 4) == (2,2)\n+    @test source_location(SourceFile(\"a\\nb\\n\"), 5) == (3,1)\n+\n+    @test source_location(SourceFile(\"\\n\\n\"), 1) == (1,1)\n+    @test source_location(SourceFile(\"\\n\\n\"), 2) == (2,1)\n+    @test source_location(SourceFile(\"\\n\\n\"), 3) == (3,1)\n+\n+    @test source_location(SourceFile(\"a\"; first_line=7), 1) == (7,1)\n+    @test source_location(SourceFile(\"a\"; first_line=7), 2) == (7,2)\n+\n+    @test source_location(SourceFile(\"a\\n\"; first_line=7), 2) == (7,2)\n+    @test source_location(SourceFile(\"a\\n\"; first_line=7), 3) == (8,1)\n+\n+    @test source_location(SourceFile(\"a\\nb\\n\"; first_line=7), 2) == (7,2)\n+    @test source_location(SourceFile(\"a\\nb\\n\"; first_line=7), 3) == (8,1)\n+    @test source_location(SourceFile(\"a\\nb\\n\"; first_line=7), 4) == (8,2)\n+    @test source_location(SourceFile(\"a\\nb\\n\"; first_line=7), 5) == (9,1)\n+\n+\n+    mktemp() do path, io\n+        write(io, \"a\\n\")\n+        @test source_location(SourceFile(; filename=path), 1) == (1,1)\n+        @test source_location(SourceFile(; filename=path, first_line=7), 1) == (7,1)\n+    end\n+\n+    # byte offset\n+    sf = SourceFile(\"a\\nbb\\nccc\\ndddd\", first_index=10)\n+    @test source_location(sf, 13) == (2,2)\n+    @test source_line(sf, 15) == 3\n+    @test source_line_range(sf, 10) == (10,11)\n+    @test source_line_range(sf, 11) == (10,11)\n+    @test source_line_range(sf, 12) == (12,14)\n+    @test source_line_range(sf, 14) == (12,14)\n+    @test source_line_range(sf, 15) == (15,18)\n+\n+    # source_line convenience function\n+    @test source_line(SourceFile(\"a\\nb\\n\"), 2) == 1\n+    @test source_line(SourceFile(\"a\\nb\\n\"), 3) == 2\n+end\n+\n+@testset \"SourceFile position indexing\" begin\n+    @test SourceFile(\"a\\nb\\n\")[1:2] == \"a\\n\"\n+    @test SourceFile(\"a\\nb\\n\")[3:end] == \"b\\n\"\n+\n+    # unicode\n+    @test SourceFile(\"\u03b1\u03b2\")[1:2] == \"\u03b1\"\n+    @test SourceFile(\"\u03b1\u03b2\")[3] == '\u03b2'\n+\n+    # offsets\n+    sf = SourceFile(\"abcd\", first_index=10)\n+    @test firstindex(sf) == 10\n+    @test lastindex(sf) == 13\n+    @test sf[10] == 'a'\n+    @test sf[10:11] == \"ab\"\n+    @test view(sf, 10:11) == \"ab\"\n+\n+    @test thisind(SourceFile(\"x\u03b1x\", first_index=10), 10) == 10\n+    @test thisind(SourceFile(\"x\u03b1x\", first_index=10), 11) == 11\n+    @test thisind(SourceFile(\"x\u03b1x\", first_index=10), 12) == 11\n+    @test thisind(SourceFile(\"x\u03b1x\", first_index=10), 13) == 13\n+\n+    if Base.VERSION >= v\"1.4\"\n+        # Protect the `[begin` from being viewed by the parser on older Julia versions\n+        @test eval(Meta.parse(\"SourceFile(\\\"a\\nb\\n\\\")[begin:end]\")) == \"a\\nb\\n\"\n+        @test eval(Meta.parse(\"SourceFile(\\\"abcd\\\", first_index=10)[begin+1:end-1]\")) == \"bc\"\n+    end\n+end\n+\n+@testset \"SourceFile printing and text extraction\" begin\n+    srcf = SourceFile(\"module Foo\\nend\")\n+    @test sprint(show, MIME(\"text/plain\"), srcf) == \"\"\"\n+    ## SourceFile ##\n+    module Foo\n+    end\"\"\"\n+    @test sourcetext(srcf) == \"module Foo\\nend\"\n+end\n+\n+\n+@testset \"highlight()\" begin\n+    src = SourceFile(\"\"\"\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        +-*/\"\"\")\n+\n+    # Empty ranges\n+    @test sprint(highlight, src, 1:0) == \"abcd\\n\u2514\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\"\n+    @test sprint(highlight, src, 2:1) == \"abcd\\n#\u2514\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\"\n+    @test sprint(highlight, src, 3:2) == \"abcd\\n# \u2514\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\"\n+    @test sprint(highlight, src, 4:3) == \"abcd\\n#  \u2514\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\"\n+    @test sprint(highlight, src, 5:4) == \"abcd\\n#   \u2514\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\"\n+    @test sprint(highlight, src, 6:5) == \"abcd\\n\u03b1\u03b2\u03b3\u03b4\\n\u2514\\n+-*/\"\n+    @test sprint(highlight, src, 19:18) == \"abcd\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\\n#   \u2514\"\n+    @test sprint(io->highlight(io, src, 1:0, context_lines_after=0, note=\"hi\")) ==\n+        \"abcd\\n\u2514 \u2500\u2500 hi\"\n+\n+    # Single line ranges\n+    @test sprint(highlight, src, 1:4) == \"abcd\\n\u2514\u2500\u2500\u2518\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\"\n+    @test sprint(highlight, src, 2:4) == \"abcd\\n#\u2514\u2500\u2518\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\"\n+    @test sprint(highlight, src, 3:4) == \"abcd\\n# \u2514\u2518\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\"\n+    @test sprint(highlight, src, 4:4) == \"abcd\\n#  \u2559\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\"\n+    @test sprint(highlight, src, 5:5) == \"abcd\\n#   \u2514\\n\u03b1\u03b2\u03b3\u03b4\\n+-*/\"\n+    @test sprint(highlight, src, 6:6) == \"abcd\\n\u03b1\u03b2\u03b3\u03b4\\n\u2559\\n+-*/\"\n+    @test sprint(highlight, src, 6:9) == \"abcd\\n\u03b1\u03b2\u03b3\u03b4\\n\u2514\u2518\\n+-*/\"\n+    @test sprint(highlight, src, 8:8) == \"abcd\\n\u03b1\u03b2\u03b3\u03b4\\n#\u2559\\n+-*/\"\n+\n+    # multi-byte chars\n+    @test sprint(highlight, src, 8:13) == \"\"\"\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        #\u2514\u2500\u2518\n+        +-*/\"\"\"\n+    # multi-byte char at eof\n+    @test sprint(highlight, SourceFile(\"a \u03b1\"), 3:4) == \"a \u03b1\\n# \u2559\"\n+    @test sprint(highlight, SourceFile(\"a\\n\u03b1\"), 1:4) == \"\u250c\\na\\n\u03b1\\n\u2518\"\n+    @test sprint(highlight, SourceFile(\"a\\nb\\n\u03b1\"), 3:3) == \"a\\nb\\n\u2559\\n\u03b1\"\n+\n+    # empty files\n+    @test sprint(highlight, SourceFile(\"\"), 1:0) == \"\u2514\"\n+\n+    # Multi-line ranges\n+    @test sprint(highlight, src, 1:7) == \"\"\"\n+        \u250c\u2500\u2500\u2500\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        \u2518\n+        +-*/\"\"\"\n+    @test sprint(highlight, src, 2:7) == \"\"\"\n+        #\u250c\u2500\u2500\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        \u2518\n+        +-*/\"\"\"\n+    @test sprint(highlight, src, 2:9) == \"\"\"\n+        #\u250c\u2500\u2500\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        #\u2518\n+        +-*/\"\"\"\n+    @test sprint(highlight, src, 4:9) == \"\"\"\n+        #  \u250c\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        #\u2518\n+        +-*/\"\"\"\n+    @test sprint(highlight, src, 5:9) == \"\"\"\n+        #   \u250c\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        #\u2518\n+        +-*/\"\"\"\n+    @test sprint(highlight, src, 6:15) == \"\"\"\n+        abcd\n+        \u250c\u2500\u2500\u2500\n+        \u03b1\u03b2\u03b3\u03b4\n+        +-*/\n+        \u2518\"\"\"\n+    @test sprint(highlight, src, 8:15) == \"\"\"\n+        abcd\n+        #\u250c\u2500\u2500\n+        \u03b1\u03b2\u03b3\u03b4\n+        +-*/\n+        \u2518\"\"\"\n+    @test sprint(highlight, src, 1:18) == \"\"\"\n+        \u250c\u2500\u2500\u2500\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        +-*/\n+        #\u2500\u2500\u2518\"\"\"\n+\n+    # context lines\n+    @test sprint(io->highlight(io, src, 8:13;\n+                               context_lines_before=0,\n+                               context_lines_after=0)) == \"\"\"\n+        \u03b1\u03b2\u03b3\u03b4\n+        #\u2514\u2500\u2518\"\"\"\n+    @test sprint(io->highlight(io, src, 8:13; context_lines_after=0)) == \"\"\"\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        #\u2514\u2500\u2518\"\"\"\n+    @test sprint(io->highlight(io, src, 8:13; context_lines_before=0)) == \"\"\"\n+        \u03b1\u03b2\u03b3\u03b4\n+        #\u2514\u2500\u2518\n+        +-*/\"\"\"\n+    @test sprint(io->highlight(io, src, 1:18; context_lines_inner=0)) == \"\"\"\n+        \u250c\u2500\u2500\u2500\n+        abcd\n+        \u22ee\n+        +-*/\n+        #\u2500\u2500\u2518\"\"\"\n+\n+    # annotations\n+    @test sprint(io->highlight(io, src, 8:13; note=\"hello\")) == \"\"\"\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        #\u2514\u2500\u2518 \u2500\u2500 hello\n+        +-*/\"\"\"\n+    @test sprint(io->highlight(io, src, 1:13; note=\"hello\")) == \"\"\"\n+        \u250c\u2500\u2500\u2500\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        #\u2500\u2500\u2518 \u2500\u2500 hello\n+        +-*/\"\"\"\n+    @test sprint(io->highlight(io, src, 8:13;\n+                               note=(io,indent,w)->print(io, \"\\n$indent$('!'^w) hello\"))) == \"\"\"\n+        abcd\n+        \u03b1\u03b2\u03b3\u03b4\n+        #\u2514\u2500\u2518\n+        #!!! hello\n+        +-*/\"\"\"\n+\n+    # colored output\n+    @test sprint(io->highlight(io, src, 8:13; context_lines_after=0, note=\"hello\", notecolor=:light_red),\n+                 context=:color=>true) ==\n+        \"abcd\\n\u03b1\\e[48;2;120;70;70m\u03b2\u03b3\u03b4\\e[0;0m\\n\\e[90m#\u2514\u2500\u2518 \u2500\u2500 \\e[0;0m\\e[91mhello\\e[0;0m\"\n+    @test sprint(io->highlight(io, src, 1:13; context_lines_after=0, note=\"hello\", notecolor=(255,0,0)),\n+                 context=:color=>true) ==\n+        \"\\e[90m\u250c\u2500\u2500\u2500\\e[0;0m\\n\\e[48;2;120;70;70mabcd\\e[0;0m\\n\\e[48;2;120;70;70m\u03b1\u03b2\u03b3\u03b4\\e[0;0m\\n\\e[90m#\u2500\u2500\u2518 \u2500\u2500 \\e[0;0m\\e[38;2;255;0;0mhello\\e[0;0m\"\n+    @test sprint(io->highlight(io, src, 1:18, context_lines_inner=0),\n+                 context=:color=>true) ==\n+        \"\\e[90m\u250c\u2500\u2500\u2500\\e[0;0m\\n\\e[48;2;120;70;70mabcd\\e[0;0m\\n\\e[48;2;120;70;70m\\e[0;0m\u22ee\\n\\e[48;2;120;70;70m+-*/\\e[0;0m\\n\\e[90m#\u2500\u2500\u2518\\e[0;0m\"\n+end"
    },
    {
      "sha": "3e2361ca56b2fa67f170fd907a0068ec9549e3e1",
      "filename": "JuliaSyntax/test/syntax_tree.jl",
      "status": "added",
      "additions": 117,
      "deletions": 0,
      "changes": 117,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fsyntax_tree.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Fsyntax_tree.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fsyntax_tree.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,117 @@\n+@testset \"SyntaxNode\" begin\n+    # Child access\n+    tt = \"a*b + c\"\n+    t = parsestmt(SyntaxNode, tt)\n+\n+    @test sourcetext(t[1])    == \"a*b\"\n+    @test sourcetext(t[1][1]) == \"a\"\n+    @test sourcetext(t[1][2]) == \"*\"\n+    @test sourcetext(t[1][3]) == \"b\"\n+    @test sourcetext(t[2])    == \"+\"\n+    @test sourcetext(t[3])    == \"c\"\n+\n+    @test JuliaSyntax.first_byte(t[2]) == findfirst(==('+'), tt)\n+    @test JuliaSyntax.source_line(t[3]) == 1\n+    @test source_location(t[3]) == (1, 7)\n+\n+    # Child indexing\n+    @test t[end] === t[3]\n+    @test sourcetext.(t[2:3]) == [\"+\", \"c\"]\n+    @test sourcetext.(t[2:end]) == [\"+\", \"c\"]\n+    @test firstindex(t) == 1\n+    @test lastindex(t) == 3\n+    @test !is_leaf(t)\n+    @test is_leaf(t[3])\n+\n+    @test sprint(show, t) == \"(call-i (call-i a * b) + c)\"\n+    @test sprint(io->show(io, MIME(\"text/x.sexpression\"), t, show_kind=true)) ==\n+        \"(call-i (call-i a::Identifier *::Identifier b::Identifier) +::Identifier c::Identifier)\"\n+\n+    @test sprint(highlight, t[1][3]) == \"a*b + c\\n# \u2559\"\n+\n+    # Pass-through field access\n+    node = t[1][1]\n+    @test node.val === :a\n+    # The specific error text has evolved over Julia versions. Check that it involves `SyntaxData` and immutability\n+    e = try node.val = :q catch e e end\n+    @test occursin(\"immutable\", e.msg) && occursin(\"SyntaxData\", e.msg)\n+\n+    # Newline-terminated source\n+    t = parsestmt(SyntaxNode, \"a*b + c\\n\")\n+    @test sprint(highlight, t[1][3]) == \"a*b + c\\n# \u2559\"\n+\n+    # copy\n+    t = parsestmt(SyntaxNode, \"a*b + c\")\n+    ct = copy(t)\n+    ct.data = nothing\n+    @test ct.data === nothing && t.data !== nothing\n+    @test ct[1].parent === ct\n+    @test ct[1] !== t[1]\n+\n+    node = parsestmt(SyntaxNode, \"f()\")\n+    push!(node, parsestmt(SyntaxNode, \"x\"))\n+    @test length(children(node)) == 2\n+    node[2] = parsestmt(SyntaxNode, \"y\")\n+    @test sourcetext(node[2]) == \"y\"\n+\n+    # SyntaxNode with offsets\n+    t,_ = parsestmt(SyntaxNode, \"begin a end\\nbegin b end\", 13)\n+    @test first(byte_range(t)) == 13\n+    @test first(byte_range(t[1])) == 19\n+    @test t[1].val == :b\n+\n+    # Unicode character ranges\n+    src = \"ab + \u03b1\u03b2\"\n+    t = parsestmt(SyntaxNode, src)\n+    @test char_range(t[1]) == 1:2\n+    @test char_range(t[2]) == 4:4\n+    @test char_range(t[3]) == 6:8\n+    # conversely, \u03b2 takes two bytes so char_range(t[3]) != byte_range(t[3])\n+    @test byte_range(t[3]) == 6:9\n+end\n+\n+@testset \"SyntaxNode pretty printing\" begin\n+    t = parsestmt(SyntaxNode, \"f(a*b,\\n  c)\", filename=\"foo.jl\")\n+    @test sprint(show, MIME(\"text/plain\"), t) == \"\"\"\n+    SyntaxNode:\n+    [call]\n+      f                                      :: Identifier\n+      [call-i]\n+        a                                    :: Identifier\n+        *                                    :: Identifier\n+        b                                    :: Identifier\n+      c                                      :: Identifier\n+    \"\"\"\n+\n+    @test sprint(io->show(io, MIME(\"text/plain\"), t, show_location=true)) == \"\"\"\n+    SyntaxNode:\n+    line:col\u2502 byte_range  \u2502 tree\n+     -file- \u2502 \"foo.jl\"\n+       1:1  \u2502     1:11    \u2502[call]\n+       1:1  \u2502     1:1     \u2502  f                                      :: Identifier\n+       1:3  \u2502     3:5     \u2502  [call-i]\n+       1:3  \u2502     3:3     \u2502    a                                    :: Identifier\n+       1:4  \u2502     4:4     \u2502    *                                    :: Identifier\n+       1:5  \u2502     5:5     \u2502    b                                    :: Identifier\n+       2:3  \u2502    10:10    \u2502  c                                      :: Identifier\n+    \"\"\"\n+\n+    @test sprint(io->show(io, MIME(\"text/plain\"), t, show_kind=false)) == \"\"\"\n+    SyntaxNode:\n+    [call]\n+      f\n+      [call-i]\n+        a\n+        *\n+        b\n+      c\n+    \"\"\"\n+\n+    t,_ = parsestmt(SyntaxNode, \"begin a end\\nbegin b end\", 13, first_line=100)\n+    @test sprint(io->show(io, MIME(\"text/plain\"), t, show_location=true)) == \"\"\"\n+    SyntaxNode:\n+    line:col\u2502 byte_range  \u2502 tree\n+     100:1  \u2502    13:23    \u2502[block]\n+     100:7  \u2502    19:19    \u2502  b                                      :: Identifier\n+    \"\"\"\n+end"
    },
    {
      "sha": "ed3d11e2f966f76ea119003004521dc164c58068",
      "filename": "JuliaSyntax/test/test_utils.jl",
      "status": "added",
      "additions": 484,
      "deletions": 0,
      "changes": 484,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Ftest_utils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Ftest_utils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Ftest_utils.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,484 @@\n+using Test\n+\n+# We need a relative include here as JuliaSyntax may come from Base.\n+using .JuliaSyntax:\n+    # Parsing\n+    ParseStream,\n+    ParseState,\n+    Diagnostic,\n+    SourceFile,\n+    source_location,\n+    source_line,\n+    source_line_range,\n+    parse!,\n+    parsestmt,\n+    parseall,\n+    parseatom,\n+    build_tree,\n+    @K_str,\n+    # Nodes\n+    GreenNode,\n+    RedTreeCursor,\n+    SyntaxNode,\n+    ErrorVal,\n+    # Node inspection\n+    kind,\n+    flags,\n+    EMPTY_FLAGS, TRIVIA_FLAG, INFIX_FLAG,\n+    head,\n+    span,\n+    SyntaxHead,\n+    is_trivia,\n+    sourcetext,\n+    is_leaf,\n+    numchildren,\n+    children,\n+    fl_parseall,\n+    fl_parse,\n+    highlight,\n+    tokenize,\n+    untokenize,\n+    filename,\n+    byte_range,\n+    char_range\n+\n+if VERSION < v\"1.6\"\n+    # Compat stuff which might not be in Base for older versions\n+    using JuliaSyntax: isnothing, only, peek\n+end\n+\n+function toks(str)\n+    ts = [JuliaSyntax.Tokenize.untokenize(t, str)=>kind(t)\n+          for t in JuliaSyntax.Tokenize.tokenize(str)]\n+    @test ts[end] == (\"\"=>K\"EndMarker\")\n+    pop!(ts)\n+    ts\n+end\n+\n+function remove_macro_linenums!(ex)\n+    if Meta.isexpr(ex, :macrocall)\n+        ex.args[2] = nothing\n+    end\n+    if ex isa Expr\n+        map!(remove_macro_linenums!, ex.args, ex.args)\n+    end\n+    return ex\n+end\n+\n+function remove_all_linenums!(ex)\n+    JuliaSyntax.remove_linenums!(ex)\n+    remove_macro_linenums!(ex)\n+end\n+\n+function kw_to_eq(ex)\n+    return Meta.isexpr(ex, :kw) ? Expr(:(=), ex.args...) : ex\n+end\n+\n+function triple_string_roughly_equal(fl_str, str)\n+    # Allow some leeway for a bug in the reference parser with\n+    # triple quoted strings\n+    lines = split(str, '\\n')\n+    fl_lines = split(fl_str, '\\n')\n+    if length(lines) != length(fl_lines)\n+        return false\n+    end\n+    has_whitespace_only_line =\n+        any(!isempty(fl_line) && all(c in \" \\t\" for c in fl_line)\n+            for fl_line in fl_lines)\n+    if !has_whitespace_only_line\n+        return str == fl_str\n+    end\n+    for (line, fl_line) in zip(lines, fl_lines)\n+        if !all(c in \" \\t\" for c in fl_line) && !endswith(line, fl_line)\n+            return false\n+        end\n+    end\n+    return true\n+end\n+\n+function exprs_equal_no_linenum(fl_ex, ex)\n+    remove_all_linenums!(deepcopy(ex)) == remove_all_linenums!(deepcopy(fl_ex))\n+end\n+\n+function is_eventually_call(ex)\n+    return ex isa Expr && (ex.head === :call ||\n+        (ex.head === :where || ex.head === :(::)) && is_eventually_call(ex.args[1]))\n+end\n+\n+# Compare Expr from reference parser expression to JuliaSyntax parser, ignoring\n+# differences due to bugs in the reference parser.\n+function exprs_roughly_equal(fl_ex, ex)\n+    if fl_ex isa Float64 && Meta.isexpr(ex, :call, 3) &&\n+                            ex.args[1] == :* &&\n+                            ex.args[2] == fl_ex &&\n+                            (ex.args[3] == :f || ex.args[3] == :f0)\n+        # 0x1p0f\n+        return true\n+    elseif !(fl_ex isa Expr) || !(ex isa Expr)\n+        if fl_ex isa String && ex isa String\n+            if fl_ex == ex\n+                return true\n+            else\n+                return triple_string_roughly_equal(fl_ex, ex)\n+            end\n+        else\n+            return fl_ex == ex\n+        end\n+    end\n+    # Ignore differences in line number nodes within block-like constructs\n+    fl_args = fl_ex.head in (:block, :quote, :toplevel) ?\n+              filter(x->!(x isa LineNumberNode), fl_ex.args) :\n+              fl_ex.args\n+    args = ex.head in (:block, :quote, :toplevel) ?\n+           filter(x->!(x isa LineNumberNode), ex.args) :\n+           ex.args\n+    if (fl_ex.head == :block && ex.head == :tuple &&\n+        length(fl_args) == 2 && length(args) == 2 &&\n+        Meta.isexpr(args[1], :parameters, 1) &&\n+        exprs_roughly_equal(fl_args[2], args[1].args[1]) &&\n+        exprs_roughly_equal(fl_args[1], args[2]))\n+        # Allow `(a; b,)`:\n+        # * Reference parser produces a block\n+        # * New parser produces a frankentuple\n+        return true\n+    end\n+    if fl_ex.head != ex.head\n+        return false\n+    end\n+    h = ex.head\n+    if h == :function && Meta.isexpr(fl_args[1], :block)\n+        blockargs = filter(x->!(x isa LineNumberNode), fl_args[1].args)\n+        posargs = blockargs[1:max(0, length(blockargs))]\n+        kwargs = blockargs[2:end]\n+        for i = 1:length(kwargs)\n+            if Meta.isexpr(kwargs[i], :(=))\n+                kwargs[i] = Expr(:kw, kwargs[i].args...)\n+            end\n+        end\n+        fl_args[1] = Expr(:tuple, Expr(:parameters, kwargs...), posargs...)\n+    elseif h == :for\n+        iterspec = args[1]\n+        if is_eventually_call(iterspec.args[1]) &&\n+                Meta.isexpr(iterspec.args[2], :block)\n+            blk = iterspec.args[2]\n+            if length(blk.args) == 2 && blk.args[1] isa LineNumberNode\n+                # Ignore short form function location differences in\n+                # `for f() = 1:3 end`\n+                iterspec.args[2] = blk.args[2]\n+            end\n+        end\n+    elseif (h == :(=) || h == :kw) && Meta.isexpr(fl_args[1], :(::), 1) &&\n+             Meta.isexpr(fl_args[2], :block, 2) && fl_args[2].args[1] isa LineNumberNode\n+        # The flisp parser adds an extra block around `w` in the following case\n+        # f(::g(z) = w) = 1\n+        fl_args[2] = fl_args[2].args[2]\n+    end\n+    if length(fl_args) != length(args)\n+        return false\n+    end\n+    if h == :do && length(args) >= 1 && Meta.isexpr(fl_args[1], :macrocall)\n+        # Macrocalls with do, as in `@f(a=1) do\\nend` use :kw in the\n+        # reference parser for the `a=1`, but we regard this as a bug.\n+        fl_args = copy(fl_args)\n+        fl_args[1] = Expr(:macrocall, map(kw_to_eq, args[1].args)...)\n+    end\n+    for i = 1:length(args)\n+        if !exprs_roughly_equal(fl_args[i], args[i])\n+            return false\n+        end\n+    end\n+    return true\n+end\n+\n+function parsers_agree_on_file(filename; kws...)\n+    text = try\n+        read(filename, String)\n+    catch\n+        # Something went wrong reading the file. This isn't a parser failure so\n+        # ignore this case.\n+        return true\n+    end\n+    parsers_agree_on_file(text, filename; kws...)\n+end\n+\n+function parsers_agree_on_file(text, filename; exprs_equal=exprs_equal_no_linenum)\n+    fl_ex = fl_parseall(text, filename=filename)\n+    if Meta.isexpr(fl_ex, :toplevel) && !isempty(fl_ex.args) &&\n+            Meta.isexpr(fl_ex.args[end], (:error, :incomplete))\n+        # Reference parser failed. This generally indicates a broken file not a\n+        # parser problem, so ignore this case.\n+        return true\n+    end\n+    try\n+        stream = ParseStream(text)\n+        parse!(stream)\n+        ex = build_tree(Expr, stream, filename=filename)\n+        return !JuliaSyntax.any_error(stream) && exprs_equal(fl_ex, ex)\n+    catch exc\n+        @error \"Parsing failed\" filename exception=current_exceptions()\n+        return false\n+    end\n+end\n+\n+function find_source_in_path(basedir)\n+    src_list = String[]\n+    for (root, dirs, files) in walkdir(basedir)\n+        append!(src_list, (joinpath(root, f) for f in files\n+                           if endswith(f, \".jl\") && (p = joinpath(root,f); !islink(p) && isfile(p))))\n+    end\n+    src_list\n+end\n+\n+test_parse_all_in_path(basedir) =\n+    test_parse_all_in_path(path->exprs_equal_no_linenum, basedir)\n+\n+function test_parse_all_in_path(compare_for_path::Function, basedir)\n+    for filepath in find_source_in_path(basedir)\n+        cmp = compare_for_path(filepath)\n+        if isnothing(cmp)\n+            continue\n+        end\n+        @testset \"Parse $(relpath(filepath, basedir))\" begin\n+            text = try\n+                read(filepath, String)\n+            catch\n+                # Something went wrong reading the file. This isn't a parser failure so\n+                # ignore this case.\n+                continue\n+            end\n+            parsers_agree = parsers_agree_on_file(text, filepath, exprs_equal=cmp)\n+            @test parsers_agree\n+            if !parsers_agree\n+                reduced_failures = reduce_text.(reduce_tree(text),\n+                                                parsers_fuzzy_disagree)\n+                @test reduced_failures == []\n+            end\n+        end\n+    end\n+end\n+\n+#-------------------------------------------------------------------------------\n+# Test case reduction\n+\n+# Check whether a given SyntaxNode converts to the same Expr as the flisp\n+# parser produces from the source text of the node.\n+function equals_flisp_parse(exprs_equal, tree)\n+    node_text = sourcetext(tree)\n+    # Reparse with JuliaSyntax. This is a crude way to ensure we're not missing\n+    # some context from the parent node.\n+    fl_ex = fl_parseall(node_text, filename=\"none\")\n+    if Meta.isexpr(fl_ex, :error) || (Meta.isexpr(fl_ex, :toplevel) &&\n+                                      length(fl_ex.args) >= 1 &&\n+                                      Meta.isexpr(fl_ex.args[end], :error))\n+        return true # Something went wrong in reduction; ignore these cases \ud83d\ude2c\n+    end\n+    ex = parseall(Expr, node_text, filename=\"none\", ignore_errors=true)\n+    exprs_equal(fl_ex, ex)\n+end\n+\n+function _reduce_tree(failing_subtrees, tree; exprs_equal=exprs_equal_no_linenum)\n+    if equals_flisp_parse(exprs_equal, tree)\n+        return false\n+    end\n+    if is_leaf(tree)\n+        push!(failing_subtrees, tree)\n+        return true\n+    end\n+    had_failing_subtrees = false\n+    if !is_leaf(tree)\n+        for child in children(tree)\n+            if is_trivia(child) || is_leaf(child)\n+                continue\n+            end\n+            had_failing_subtrees |= _reduce_tree(failing_subtrees, child; exprs_equal=exprs_equal)\n+        end\n+    end\n+    if !had_failing_subtrees\n+        push!(failing_subtrees, tree)\n+    end\n+    return true\n+end\n+\n+\"\"\"\n+    reduce_tree(tree::SyntaxNode; exprs_equal=exprs_equal_no_linenum)\n+\n+Select minimal subtrees of `tree` which are inconsistent between flisp and\n+JuliaSyntax parsers.\n+\"\"\"\n+function reduce_tree(tree::SyntaxNode; kws...)\n+    subtrees = Vector{typeof(tree)}()\n+    _reduce_tree(subtrees, tree; kws...)\n+    subtrees\n+end\n+\n+\"\"\"\n+    reduce_tree(text::AbstractString; exprs_equal=exprs_equal_no_linenum)\n+\n+Find the minimal subtrees of the parsed form of `text` which are inconsistent\n+between flisp and JuliaSyntax parsers and return the source text of those\n+subtrees.\n+\"\"\"\n+function reduce_tree(text::AbstractString; kws...)\n+    tree = parseall(SyntaxNode, text, ignore_warnings=true)\n+    sourcetext.(reduce_tree(tree; kws...))\n+end\n+\n+\n+#-------------------------------------------------------------------------------\n+# Text-based test case reduction\n+function parser_throws_exception(text)\n+    try\n+        JuliaSyntax.parseall(JuliaSyntax.SyntaxNode, text, ignore_errors=true)\n+        false\n+    catch\n+        true\n+    end\n+end\n+\n+function parsers_fuzzy_disagree(text::AbstractString)\n+    fl_ex = fl_parseall(text, filename=\"none\")\n+    if Meta.isexpr(fl_ex, (:error,:incomplete)) ||\n+            (Meta.isexpr(fl_ex, :toplevel) && length(fl_ex.args) >= 1 &&\n+             Meta.isexpr(fl_ex.args[end], (:error,:incomplete)))\n+        return false\n+    end\n+    try\n+        ex = parseall(Expr, text, filename=\"none\", ignore_errors=true)\n+        return !exprs_roughly_equal(fl_ex, ex)\n+    catch\n+        @error \"Reduction failed\" text\n+        return false\n+    end\n+end\n+\n+\n+\"\"\"\n+Reduce text of a test case via combination of bisection and random deletion.\n+\n+This is suited to randomly generated strings, but it's surprisingly effective\n+for code-like strings as well.\n+\"\"\"\n+function reduce_text(str, parse_differs)\n+    while true\n+        if length(str) <= 1\n+            return str\n+        end\n+        m1 = thisind(str, length(str)\u00f72)\n+        m2 = nextind(str, m1)\n+        if parse_differs(str[1:m1])\n+            str = str[1:m1]\n+        elseif parse_differs(str[m2:end])\n+            str = str[m2:end]\n+        else\n+            chunklen = clamp(length(str)\u00f710, 1, 10)\n+            reduced = false\n+            for i = 1:100\n+                m = thisind(str, rand(1:length(str)-chunklen))\n+                m3 = nextind(str, m+chunklen)\n+                if m3 == nextind(str, m)\n+                    continue\n+                end\n+                s = str[1:m]*str[m3:end]\n+                if parse_differs(s)\n+                    str = s\n+                    reduced = true\n+                    break\n+                end\n+            end\n+            if !reduced\n+                return str\n+            end\n+        end\n+    end\n+end\n+\n+function show_green_tree(code; version::VersionNumber=v\"1.6\")\n+    t = JuliaSyntax.parseall(GreenNode, code, version=version)\n+    sprint(show, MIME\"text/plain\"(), t, code)\n+end\n+\n+#-------------------------------------------------------------------------------\n+# Parse s-expressions\n+function parse_sexpr(code)\n+    st = ParseStream(code)\n+    pos_stack = ParseStreamPosition[]\n+    while true\n+        k = peek(st)\n+        if k == K\"(\"\n+            push!(pos_stack, position(st))\n+            bump(st, TRIVIA_FLAG)\n+        elseif k == K\")\"\n+            if isempty(pos_stack)\n+                bump(st, error=\"Mismatched `)` with no opening `(`\")\n+                break\n+            else\n+                bump(st, TRIVIA_FLAG)\n+            end\n+            emit(st, pop!(pos_stack), K\"parens\")\n+        elseif k == K\"Identifier\" || k == K\"Integer\"\n+            bump(st)\n+        elseif k == K\"NewlineWs\"\n+            bump(st, TRIVIA_FLAG)\n+        elseif k == K\"EndMarker\"\n+            if !isempty(pos_stack)\n+                bump_invisible(st, K\"error\", error=\"Mismatched `)`\")\n+            end\n+            break\n+        else\n+            bump(st, error=\"Unexpected token\")\n+        end\n+    end\n+    if JuliaSyntax.any_error(st)\n+        throw(JuliaSyntax.ParseError(st))\n+    end\n+    st\n+end\n+\n+\n+#-------------------------------------------------------------------------------\n+# Tools copied from Base.Meta which call core_parser_hook as if called by\n+# Meta.parse(), but without installing the global hook.\n+\n+function _Meta_parse_string(text::AbstractString, filename::AbstractString,\n+                            lineno::Integer, index::Integer, options)\n+    if index < 1 || index > ncodeunits(text) + 1\n+        throw(BoundsError(text, index))\n+    end\n+    ex, offset::Int = JuliaSyntax.core_parser_hook(text, filename, lineno, index-1, options)\n+    ex, offset+1\n+end\n+\n+function Meta_parse(str::AbstractString, pos::Integer;\n+               filename=\"none\", greedy::Bool=true, raise::Bool=true, depwarn::Bool=true)\n+    ex, pos = _Meta_parse_string(str, String(filename), 1, pos, greedy ? :statement : :atom)\n+    if raise && Meta.isexpr(ex, :error)\n+        err = ex.args[1]\n+        if err isa String\n+            err = Meta.ParseError(err) # For flisp parser\n+        end\n+        throw(err)\n+    end\n+    return ex, pos\n+end\n+\n+function Meta_parse(str::AbstractString;\n+                    filename=\"none\", raise::Bool=true, depwarn::Bool=true)\n+    ex, pos = Meta_parse(str, 1; filename=filename, greedy=true, raise=raise, depwarn=depwarn)\n+    if Meta.isexpr(ex, :error)\n+        return ex\n+    end\n+    if pos <= ncodeunits(str)\n+        raise && throw(Meta.ParseError(\"extra token after end of expression\"))\n+        return Expr(:error, \"extra token after end of expression\")\n+    end\n+    return ex\n+end\n+\n+function Meta_parseatom(text::AbstractString, pos::Integer; filename=\"none\", lineno=1)\n+    return _Meta_parse_string(text, String(filename), lineno, pos, :atom)\n+end\n+\n+function Meta_parseall(text::AbstractString; filename=\"none\", lineno=1)\n+    ex,_ = _Meta_parse_string(text, String(filename), lineno, 1, :all)\n+    return ex\n+end"
    },
    {
      "sha": "51515515a83f55397779687241811678ac475825",
      "filename": "JuliaSyntax/test/test_utils_tests.jl",
      "status": "added",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Ftest_utils_tests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Ftest_utils_tests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Ftest_utils_tests.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,37 @@\n+# Tests for the test_utils go here to allow the utils to be included on their\n+# own without invoking the tests.\n+@testset \"Reference parser bugs\" begin\n+    # `0x1.8p0f`\n+    @test exprs_roughly_equal(1.5,\n+                              Expr(:call, :*, 1.5, :f))\n+    @test exprs_roughly_equal(1.5,\n+                              Expr(:call, :*, 1.5, :f0))\n+    # `@f(a=1) do \\n end`\n+    @test exprs_roughly_equal(Expr(:do, Expr(:macrocall, Symbol(\"@f\"), LineNumberNode(1), Expr(:kw, :a, 1)),\n+                                   Expr(:->, Expr(:tuple), Expr(:block, LineNumberNode(1)))),\n+                              Expr(:do, Expr(:macrocall, Symbol(\"@f\"), LineNumberNode(1), Expr(:(=), :a, 1)),\n+                                   Expr(:->, Expr(:tuple), Expr(:block, LineNumberNode(1)))))\n+    # `\"\"\"\\n  a\\n \\n  b\"\"\"`\n+    @test exprs_roughly_equal(\"a\\n \\nb\", \" a\\n\\n b\")\n+    @test !exprs_roughly_equal(\"a\\n x\\nb\", \" a\\n x\\n b\")\n+    @test exprs_roughly_equal(\"a\\n x\\nb\", \"a\\n x\\nb\")\n+    # `(a; b,)`\n+    @test exprs_roughly_equal(Expr(:block, :a, LineNumberNode(1), :b),\n+                              Expr(:tuple, Expr(:parameters, :b), :a))\n+    @test !exprs_roughly_equal(Expr(:block, :a, LineNumberNode(1), :b),\n+                               Expr(:tuple, Expr(:parameters, :c), :a))\n+    @test !exprs_roughly_equal(Expr(:block, :a, LineNumberNode(1), :b),\n+                               Expr(:tuple, Expr(:parameters, :b), :c))\n+    @test !exprs_roughly_equal(Expr(:block, :a, LineNumberNode(1), :b, :c),\n+                               Expr(:tuple, Expr(:parameters, :b), :a))\n+\n+    # Line numbers for short form function defs in `for` :-(\n+    @test exprs_roughly_equal(Expr(:for, Expr(:(=),\n+                                              Expr(:call, :f),\n+                                              1),\n+                                   Expr(:block, LineNumberNode(1))),\n+                              Expr(:for, Expr(:(=),\n+                                              Expr(:call, :f),\n+                                              Expr(:block, LineNumberNode(1), 1)),\n+                                   Expr(:block, LineNumberNode(1))))\n+end"
    },
    {
      "sha": "fe5bba6ac073e196156449502272289838269004",
      "filename": "JuliaSyntax/test/tokenize.jl",
      "status": "added",
      "additions": 1190,
      "deletions": 0,
      "changes": 1190,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Ftokenize.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Ftokenize.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Ftokenize.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,1190 @@\n+# Hack: Introduce a module here to isolate some Tokenize internals from JuliaSyntax\n+module TokenizeTests\n+\n+using Test\n+\n+using ..JuliaSyntax:\n+    JuliaSyntax,\n+    @K_str,\n+    Kind,\n+    kind,\n+    is_error,\n+    is_operator\n+\n+using ..JuliaSyntax.Tokenize:\n+    Tokenize,\n+    tokenize,\n+    untokenize,\n+    RawToken\n+\n+import ..toks\n+\n+tok(str, i = 1) = collect(tokenize(str))[i]\n+\n+strtok(str) = untokenize.(collect(tokenize(str)), str)\n+\n+function onlytok(str)\n+    ts = collect(tokenize(str))\n+    (length(ts) == 2 && ts[2].kind == K\"EndMarker\") ||\n+        error(\"Expected one token got $(length(ts)-1)\")\n+    return ts[1].kind\n+end\n+\n+@testset \"tokens\" begin\n+    for s in [\"a\", IOBuffer(\"a\")]\n+        l = tokenize(s)\n+        @test Tokenize.readchar(l) == 'a'\n+\n+        l_old = l\n+        @test l == l_old\n+        @test Tokenize.eof(l)\n+        @test Tokenize.readchar(l) == Tokenize.EOF_CHAR\n+\n+    end\n+end # testset\n+\n+@testset \"tokenize unicode\" begin\n+    # FIXME: rm VERSION check once we implement our own is_identifier_char\n+    emoji = VERSION < v\"1.5\" ? \"\ud83d\ude04\" : \"\\U1F3F3\\UFE0F\\U200D\\U1F308\" # \ud83c\udff3\ufe0f\u200d\ud83c\udf08 requires newer Unicode\n+    str = \"\ud835\ude0b =2\"*emoji\n+    for s in [str, IOBuffer(str)]\n+        l = tokenize(s)\n+        kinds = [K\"Identifier\", K\"Whitespace\", K\"=\",\n+                 K\"Integer\", K\"Identifier\", K\"EndMarker\"]\n+        token_strs = [\"\ud835\ude0b\", \" \", \"=\", \"2\", emoji, \"\"]\n+        for (i, n) in enumerate(l)\n+            @test kind(n) == kinds[i]\n+            @test untokenize(n, str)  == token_strs[i]\n+        end\n+    end\n+end # testset\n+\n+@testset \"tokenize complex piece of code\" begin\n+\n+    str = \"\"\"\n+    function foo!{T<:Bar}(x::{T}=12)\n+        @time (x+x, x+x);\n+    end\n+    try\n+        foo\n+    catch\n+        bar\n+    end\n+    @time x+x\n+    y[[1 2 3]]\n+    [1*2,2;3,4]\n+    \"string\"; 'c'\n+    (a&&b)||(a||b)\n+    # comment\n+    #= comment\n+    is done here =#\n+    2%5\n+    a'/b'\n+    a.'\\\\b.'\n+    `command`\n+    12_sin(12)\n+    {}\n+    '\n+    \"\"\"\n+\n+    # Generate the following with\n+    # ```\n+    # for t in kind.(collect(tokenize(str)))\n+    #    print(kind(t), \",\")\n+    # end\n+    # ```\n+    # and *check* it afterwards.\n+\n+    kinds = [K\"function\",K\"Whitespace\",K\"Identifier\",K\"{\",K\"Identifier\",\n+            K\"<:\",K\"Identifier\",K\"}\",K\"(\",K\"Identifier\",K\"::\",\n+            K\"{\",K\"Identifier\",K\"}\",K\"=\",K\"Integer\",K\")\",\n+\n+            K\"NewlineWs\",K\"@\",K\"Identifier\",K\"Whitespace\",K\"(\",\n+            K\"Identifier\",K\"+\",K\"Identifier\",K\",\",K\"Whitespace\",\n+            K\"Identifier\",K\"+\",K\"Identifier\",K\")\",K\";\",\n+\n+            K\"NewlineWs\",K\"end\",\n+\n+            K\"NewlineWs\",K\"try\",\n+            K\"NewlineWs\",K\"Identifier\",\n+            K\"NewlineWs\",K\"catch\",\n+            K\"NewlineWs\",K\"Identifier\",\n+            K\"NewlineWs\",K\"end\",\n+\n+            K\"NewlineWs\",K\"@\",K\"Identifier\",K\"Whitespace\",K\"Identifier\",\n+            K\"+\",K\"Identifier\",\n+\n+            K\"NewlineWs\",K\"Identifier\",K\"[\",K\"[\",K\"Integer\",K\"Whitespace\",\n+            K\"Integer\",K\"Whitespace\",K\"Integer\",K\"]\",K\"]\",\n+\n+            K\"NewlineWs\",K\"[\",K\"Integer\",K\"*\",K\"Integer\",K\",\",K\"Integer\",\n+            K\";\",K\"Integer\",K\",\",K\"Integer\",K\"]\",\n+\n+            K\"NewlineWs\",K\"\\\"\",K\"String\",K\"\\\"\",K\";\",K\"Whitespace\",K\"'\",K\"Char\",K\"'\",\n+\n+            K\"NewlineWs\",K\"(\",K\"Identifier\",K\"&&\",K\"Identifier\",K\")\",K\"||\",\n+            K\"(\",K\"Identifier\",K\"||\",K\"Identifier\",K\")\",\n+\n+            K\"NewlineWs\",K\"Comment\",\n+\n+            K\"NewlineWs\",K\"Comment\",\n+\n+            K\"NewlineWs\",K\"Integer\",K\"%\",K\"Integer\",\n+\n+            K\"NewlineWs\",K\"Identifier\",K\"'\",K\"/\",K\"Identifier\",K\"'\",\n+\n+            K\"NewlineWs\",K\"Identifier\",K\".\",K\"'\",K\"\\\\\",K\"Identifier\",K\".\",K\"'\",\n+\n+            K\"NewlineWs\",K\"`\",K\"CmdString\",K\"`\",\n+\n+            K\"NewlineWs\",K\"Integer\",K\"Identifier\",K\"(\",K\"Integer\",K\")\",\n+\n+            K\"NewlineWs\",K\"{\",K\"}\",\n+\n+            K\"NewlineWs\",K\"'\",K\"Char\",K\"EndMarker\"]\n+\n+    for (i, n) in enumerate(tokenize(str))\n+        @test kind(n) == kinds[i]\n+    end\n+\n+    @testset \"roundtrippability\" begin\n+        @test join(untokenize.(collect(tokenize(str)), str)) == str\n+    end\n+\n+    @test all((t.endbyte - t.startbyte + 1)==sizeof(untokenize(t, str)) for t in tokenize(str))\n+end # testset\n+\n+@testset \"issue 5, '..'\" begin\n+    @test kind.(collect(tokenize(\"1.23..3.21\"))) == [K\"Float\",K\"..\",K\"Float\",K\"EndMarker\"]\n+end\n+\n+@testset \"issue 17, >>\" begin\n+    str = \">> \"\n+    @test untokenize(tok(str), str)==\">>\"\n+end\n+\n+@testset \"tokenize newlines\" begin\n+    n = \"\\n\"\n+    rn = \"\\r\\n\"\n+    nl = K\"NewlineWs\"\n+    for i in 0:5\n+        j = 5 - i\n+        @test toks(n^i * rn^j) == vcat(fill(n  => nl, i), fill(rn => nl, j))\n+        @test toks(rn^i * n^j) == vcat(fill(rn => nl, i), fill(n  => nl, j))\n+    end\n+end\n+\n+@testset \"test added operators\" begin\n+    @test tok(\"1+=2\",  2).kind == K\"op=\"\n+    @test tok(\"1-=2\",  2).kind == K\"op=\"\n+    @test tok(\"1*=2\",  2).kind == K\"op=\"\n+    @test tok(\"1^=2\",  2).kind == K\"op=\"\n+    @test tok(\"1\u00f7=2\",  2).kind == K\"op=\"\n+    @test tok(\"1\\\\=2\", 2).kind == K\"op=\"\n+    @test tok(\"1\\$=2\", 2).kind == K\"op=\"\n+    @test tok(\"1\u22bb=2\",  2).kind == K\"op=\"\n+    @test tok(\"1:=2\",  2).kind == K\":=\"\n+    @test tok(\"1-->2\", 2).kind == K\"-->\"\n+    @test tok(\"1<--2\", 2).kind == K\"<--\"\n+    @test tok(\"1<-->2\", 2).kind == K\"<-->\"\n+    @test tok(\"1>:2\",  2).kind == K\">:\"\n+end\n+\n+@testset \"infix\" begin\n+    @test tok(\"1 in 2\",  3).kind == K\"in\"\n+    @test tok(\"1 in[1]\", 3).kind == K\"in\"\n+\n+    @test tok(\"1 isa 2\",  3).kind == K\"isa\"\n+    @test tok(\"1 isa[2]\", 3).kind == K\"isa\"\n+end\n+\n+@testset \"tokenizing true/false literals\" begin\n+    @test tok(\"somtext true\", 3).kind == K\"Bool\"\n+    @test tok(\"somtext false\", 3).kind == K\"Bool\"\n+    @test tok(\"somtext tr\", 3).kind == K\"Identifier\"\n+    @test tok(\"somtext truething\", 3).kind == K\"Identifier\"\n+    @test tok(\"somtext falsething\", 3).kind == K\"Identifier\"\n+end\n+\n+\n+roundtrip(str) = join(untokenize.(collect(tokenize(str)), str))\n+\n+@testset \"lexing anon functions '->' \" begin\n+    @test tok(\"a->b\", 2).kind==K\"->\"\n+end\n+\n+@testset \"comments\" begin\n+    ts = collect(tokenize(\"\"\"\n+       #\n+       \\\"\\\"\\\"\n+       f\n+       \\\"\\\"\\\"\n+       1\n+       \"\"\"))\n+\n+    kinds = [K\"Comment\", K\"NewlineWs\",\n+             K\"\\\"\\\"\\\"\", K\"String\", K\"String\", K\"\\\"\\\"\\\"\", K\"NewlineWs\",\n+             K\"Integer\", K\"NewlineWs\",\n+             K\"EndMarker\"]\n+    @test kind.(ts) == kinds\n+\n+    @test toks(\"#=# text=#\") == [\"#=# text=#\"=>K\"Comment\"]\n+\n+    @test toks(\"#=   #=   =#\") == [\"#=   #=   =#\"=>K\"ErrorEofMultiComment\"]\n+    @test toks(\"#=#==#=#\") == [\"#=#==#=#\"=>K\"Comment\"]\n+    @test toks(\"#=#==#=\")  == [\"#=#==#=\"=>K\"ErrorEofMultiComment\"]\n+    # comment terminated by \\r\\n\n+    @test toks(\"#\\r\\n\") == [\"#\" => K\"Comment\", \"\\r\\n\" => K\"NewlineWs\"]\n+end\n+\n+\n+@testset \"invalid UTF-8\" begin\n+    @test toks(\"#=\\xf5b\\n=#\") == [\n+        \"#=\\xf5b\\n=#\" => K\"ErrorInvalidUTF8\",\n+    ]\n+    @test toks(\"#\\xf5b\\n\") == [\n+        \"#\\xf5b\" => K\"ErrorInvalidUTF8\",\n+        \"\\n\" => K\"NewlineWs\"\n+    ]\n+    @test toks(\"\\\"\\xf5\\\"\") == [\n+        \"\\\"\"   => K\"\\\"\"\n+        \"\\xf5\" => K\"ErrorInvalidUTF8\"\n+        \"\\\"\"   => K\"\\\"\"\n+    ]\n+    @test toks(\"'\\xf5'\") == [\n+        \"'\"    => K\"'\"\n+        \"\\xf5\" => K\"ErrorInvalidUTF8\"\n+        \"'\"    => K\"'\"\n+    ]\n+    @test toks(\"`\\xf5`\") == [\n+        \"`\"    => K\"`\"\n+        \"\\xf5\" => K\"ErrorInvalidUTF8\"\n+        \"`\"    => K\"`\"\n+    ]\n+end\n+\n+@testset \"primes\" begin\n+    str = \"\"\"\n+    ImageMagick.save(fn, reinterpret(ARGB32, [0xf0884422]''))\n+    D = ImageMagick.load(fn)\n+    \"\"\"\n+    tokens = collect(tokenize(str))\n+    @test string(untokenize(tokens[16], str)) == string(untokenize(tokens[17], str))==\"'\"\n+\n+    @test roundtrip(\"'a'\") == \"'a'\"\n+    @test kind.(collect(tokenize(\"'a'\"))) == [K\"'\", K\"Char\", K\"'\", K\"EndMarker\"]\n+\n+    # ' is not an operator here, so doesn't consume the suffix \u1d40\n+    @test roundtrip(\"'\u1d40'\") == \"'\u1d40'\"\n+    @test kind.(collect(tokenize(\"'\u2081'\"))) == [K\"'\", K\"Char\", K\"'\", K\"EndMarker\"]\n+\n+    @test roundtrip(\"''\") == \"''\"\n+    @test kind.(collect(tokenize(\"''\"))) == [K\"'\", K\"'\", K\"EndMarker\"]\n+\n+    @test roundtrip(\"'''\") == \"'''\"\n+    @test kind.(collect(tokenize(\"'''\"))) == [K\"'\", K\"Char\", K\"'\", K\"EndMarker\"]\n+\n+    @test roundtrip(\"''''\") == \"''''\"\n+    @test kind.(collect(tokenize(\"''''\"))) == [K\"'\", K\"Char\", K\"'\", K\"'\", K\"EndMarker\"]\n+\n+    @test tok(\"()'\", 3).kind == K\"'\"\n+    @test tok(\"{}'\", 3).kind == K\"'\"\n+    @test tok(\"[]'\", 3).kind == K\"'\"\n+    @test tok(\"outer'\", 2).kind == K\"'\"\n+    @test tok(\"mutable'\", 2).kind == K\"'\"\n+    @test tok(\"as'\", 2).kind == K\"'\"\n+    @test tok(\"isa'\", 2).kind == K\"'\"\n+    @test untokenize.(collect(tokenize(\"a'\u1d40\")), \"a'\u1d40\") == [\"a\", \"'\u1d40\", \"\"]\n+end\n+\n+@testset \"keywords\" begin\n+      for kw in    [\"baremodule\",\n+                    \"begin\",\n+                    \"break\",\n+                    \"catch\",\n+                    \"const\",\n+                    \"continue\",\n+                    \"do\",\n+                    \"else\",\n+                    \"elseif\",\n+                    \"end\",\n+                    \"export\",\n+                    \"finally\",\n+                    \"for\",\n+                    \"function\",\n+                    \"global\",\n+                    \"if\",\n+                    \"import\",\n+                    \"let\",\n+                    \"local\",\n+                    \"macro\",\n+                    \"module\",\n+                    \"quote\",\n+                    \"return\",\n+                    \"struct\",\n+                    \"try\",\n+                    \"using\",\n+                    \"while\",\n+\n+                    \"abstract\",\n+                    \"as\",\n+                    \"doc\",\n+                    \"mutable\",\n+                    \"outer\",\n+                    \"primitive\",\n+                    \"type\",\n+                    \"var\"]\n+\n+        @test kind(tok(kw)) == Kind(kw)\n+    end\n+end\n+\n+@testset \"issue in PR #45\" begin\n+    @test length(collect(tokenize(\"x)\"))) == 3\n+end\n+\n+@testset \"lex binary\" begin\n+    @test tok(\"0b0101\").kind==K\"BinInt\"\n+end\n+\n+@testset \"show\" begin\n+    io = IOBuffer()\n+    show(io, collect(tokenize(\"\\\"abc\\nd\\\"ef\"))[2])\n+    @test String(take!(io)) == \"1-5        String         \"\n+end\n+\n+~(tok::RawToken, t::Tuple) = tok.kind == t[1] && untokenize(tok, t[3]) == t[2]\n+\n+@testset \"raw strings\" begin\n+    str = raw\"\"\" str\"x $ \\ y\" \"\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[1] ~ (K\"Whitespace\" , \" \"        , str)\n+    @test ts[2] ~ (K\"Identifier\" , \"str\"      , str)\n+    @test ts[3] ~ (K\"\\\"\"         , \"\\\"\"       , str)\n+    @test ts[4] ~ (K\"String\"     , \"x \\$ \\\\ y\", str)\n+    @test ts[5] ~ (K\"\\\"\"         , \"\\\"\"       , str)\n+    @test ts[6] ~ (K\"Whitespace\" , \" \"        , str)\n+    @test ts[7] ~ (K\"EndMarker\"  , \"\"         , str)\n+\n+    str = raw\"\"\"`x $ \\ y`\"\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[1] ~ (K\"`\"         , \"`\"         , str)\n+    @test ts[2] ~ (K\"CmdString\" , \"x \\$ \\\\ y\" , str)\n+    @test ts[3] ~ (K\"`\"         , \"`\"         , str)\n+    @test ts[4] ~ (K\"EndMarker\" , \"\"          , str)\n+\n+    # str\"\\\\\"\n+    str = \"str\\\"\\\\\\\\\\\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[1] ~ (K\"Identifier\" , \"str\"  , str)\n+    @test ts[2] ~ (K\"\\\"\"         , \"\\\"\"   , str)\n+    @test ts[3] ~ (K\"String\"     , \"\\\\\\\\\" , str)\n+    @test ts[4] ~ (K\"\\\"\"         , \"\\\"\"   , str)\n+    @test ts[5] ~ (K\"EndMarker\"  , \"\"     , str)\n+\n+    # str\"\\\\\\\"\"\n+    str = \"str\\\"\\\\\\\\\\\\\\\"\\\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[1] ~ (K\"Identifier\" , \"str\"      , str)\n+    @test ts[2] ~ (K\"\\\"\"         , \"\\\"\"       , str)\n+    @test ts[3] ~ (K\"String\"     , \"\\\\\\\\\\\\\\\"\" , str)\n+    @test ts[4] ~ (K\"\\\"\"         , \"\\\"\"       , str)\n+    @test ts[5] ~ (K\"EndMarker\"  , \"\"         , str)\n+\n+    # Contextual keywords and operators allowed as raw string prefixes\n+    str = raw\"\"\" var\"x $ \\ y\" \"\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[2] ~ (K\"var\"        , \"var\", str)\n+    @test ts[4] ~ (K\"String\"     , \"x \\$ \\\\ y\", str)\n+\n+    str = raw\"\"\" outer\"x $ \\ y\" \"\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[2] ~ (K\"outer\"      , \"outer\", str)\n+    @test ts[4] ~ (K\"String\"     , \"x \\$ \\\\ y\", str)\n+\n+    str = raw\"\"\" isa\"x $ \\ y\" \"\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[2] ~ (K\"isa\"        , \"isa\", str)\n+    @test ts[4] ~ (K\"String\"     , \"x \\$ \\\\ y\", str)\n+end\n+\n+@testset \"string escaped newline whitespace\" begin\n+    str = \"\\\"x\\\\\\n \\ty\\\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[1] ~ (K\"\\\"\", \"\\\"\", str)\n+    @test ts[2] ~ (K\"String\", \"x\", str)\n+    @test ts[3] ~ (K\"Whitespace\", \"\\\\\\n \\t\", str)\n+    @test ts[4] ~ (K\"String\", \"y\", str)\n+    @test ts[5] ~ (K\"\\\"\", \"\\\"\", str)\n+\n+    # No newline escape for raw strings\n+    str = \"r\\\"x\\\\\\ny\\\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[1] ~ (K\"Identifier\", \"r\", str)\n+    @test ts[2] ~ (K\"\\\"\", \"\\\"\", str)\n+    @test ts[3] ~ (K\"String\", \"x\\\\\\ny\", str)\n+    @test ts[4] ~ (K\"\\\"\", \"\\\"\", str)\n+end\n+\n+@testset \"triple quoted string line splitting\" begin\n+    str = \"\\\"\\\"\\\"\\nx\\r\\ny\\rz\\n\\r\\\"\\\"\\\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[1] ~ (K\"\\\"\\\"\\\"\" , \"\\\"\\\"\\\"\", str)\n+    @test ts[2] ~ (K\"String\" , \"\\n\", str)\n+    @test ts[3] ~ (K\"String\" , \"x\\r\\n\", str)\n+    @test ts[4] ~ (K\"String\" , \"y\\r\", str)\n+    @test ts[5] ~ (K\"String\" , \"z\\n\", str)\n+    @test ts[6] ~ (K\"String\" , \"\\r\", str)\n+    @test ts[7] ~ (K\"\\\"\\\"\\\"\" , \"\\\"\\\"\\\"\", str)\n+\n+    # Also for raw strings\n+    str = \"r\\\"\\\"\\\"\\nx\\ny\\\"\\\"\\\"\"\n+    ts = collect(tokenize(str))\n+    @test ts[1] ~ (K\"Identifier\" , \"r\", str)\n+    @test ts[2] ~ (K\"\\\"\\\"\\\"\"     , \"\\\"\\\"\\\"\", str)\n+    @test ts[3] ~ (K\"String\"     , \"\\n\", str)\n+    @test ts[4] ~ (K\"String\"     , \"x\\n\", str)\n+    @test ts[5] ~ (K\"String\"     , \"y\", str)\n+    @test ts[6] ~ (K\"\\\"\\\"\\\"\"     , \"\\\"\\\"\\\"\", str)\n+end\n+\n+@testset \"interpolation\" begin\n+    @testset \"basic\" begin\n+        str = \"\\\"\\$x \\$y\\\"\"\n+        ts = collect(tokenize(str))\n+        @test ts[1]  ~ (K\"\\\"\"         , \"\\\"\", str)\n+        @test ts[2]  ~ (K\"$\"          , \"\\$\", str)\n+        @test ts[3]  ~ (K\"Identifier\" , \"x\" , str)\n+        @test ts[4]  ~ (K\"String\"     , \" \" , str)\n+        @test ts[5]  ~ (K\"$\"          , \"\\$\", str)\n+        @test ts[6]  ~ (K\"Identifier\" , \"y\" , str)\n+        @test ts[7]  ~ (K\"\\\"\"         , \"\\\"\", str)\n+        @test ts[8]  ~ (K\"EndMarker\"  , \"\"  , str)\n+    end\n+\n+    @testset \"nested\" begin\n+        str = \"\"\"\"str: \\$(g(\"str: \\$(h(\"str\"))\"))\" \"\"\"\n+        ts = collect(tokenize(str))\n+        @test length(ts) == 23\n+        @test ts[1]  ~ (K\"\\\"\"        , \"\\\"\"   , str)\n+        @test ts[2]  ~ (K\"String\"    , \"str: \", str)\n+        @test ts[3]  ~ (K\"$\"         , \"\\$\"   , str)\n+        @test ts[4]  ~ (K\"(\"         , \"(\"    , str)\n+        @test ts[5]  ~ (K\"Identifier\", \"g\"    , str)\n+        @test ts[6]  ~ (K\"(\"         , \"(\"    , str)\n+        @test ts[7]  ~ (K\"\\\"\"        , \"\\\"\"   , str)\n+        @test ts[8]  ~ (K\"String\"    , \"str: \", str)\n+        @test ts[9]  ~ (K\"$\"         , \"\\$\"   , str)\n+        @test ts[10] ~ (K\"(\"         , \"(\"    , str)\n+        @test ts[11] ~ (K\"Identifier\", \"h\"    , str)\n+        @test ts[12] ~ (K\"(\"         , \"(\"    , str)\n+        @test ts[13] ~ (K\"\\\"\"        , \"\\\"\"   , str)\n+        @test ts[14] ~ (K\"String\"    , \"str\"  , str)\n+        @test ts[15] ~ (K\"\\\"\"        , \"\\\"\"   , str)\n+        @test ts[16] ~ (K\")\"         , \")\"    , str)\n+        @test ts[17] ~ (K\")\"         , \")\"    , str)\n+        @test ts[18] ~ (K\"\\\"\"        , \"\\\"\"   , str)\n+        @test ts[19] ~ (K\")\"         , \")\"    , str)\n+        @test ts[20] ~ (K\")\"         , \")\"    , str)\n+        @test ts[21] ~ (K\"\\\"\"        , \"\\\"\"   , str)\n+        @test ts[22] ~ (K\"Whitespace\", \" \"    , str)\n+        @test ts[23] ~ (K\"EndMarker\" , \"\"     , str)\n+    end\n+\n+    @testset \"duplicate \\$\" begin\n+        str = \"\\\"\\$\\$\\\"\"\n+        ts = collect(tokenize(str))\n+        @test ts[1]  ~ (K\"\\\"\"        , \"\\\"\", str)\n+        @test ts[2]  ~ (K\"$\"         , \"\\$\", str)\n+        @test ts[3]  ~ (K\"$\"         , \"\\$\", str)\n+        @test ts[4]  ~ (K\"\\\"\"        , \"\\\"\", str)\n+        @test ts[5]  ~ (K\"EndMarker\" , \"\"  , str)\n+    end\n+\n+    @testset \"Unmatched parens\" begin\n+        # issue 73: https://github.com/JuliaLang/Tokenize.jl/issues/73\n+        str = \"\\\"\\$(fdsf\\\"\"\n+        ts = collect(tokenize(str))\n+        @test ts[1] ~ (K\"\\\"\"         , \"\\\"\"   , str)\n+        @test ts[2] ~ (K\"$\"          , \"\\$\"   , str)\n+        @test ts[3] ~ (K\"(\"          , \"(\"    , str)\n+        @test ts[4] ~ (K\"Identifier\" , \"fdsf\" , str)\n+        @test ts[5] ~ (K\"\\\"\"         , \"\\\"\"   , str)\n+        @test ts[6] ~ (K\"EndMarker\"  , \"\"     , str)\n+    end\n+\n+    @testset \"Unicode\" begin\n+        # issue 178: https://github.com/JuliaLang/Tokenize.jl/issues/178\n+        str = \"\"\" \"\\$u\u2095x \\$(u\u2095x - ux)\" \"\"\"\n+        ts = collect(tokenize(str))\n+        @test ts[ 1] ~ (K\"Whitespace\" , \" \"   , str)\n+        @test ts[ 2] ~ (K\"\\\"\"         , \"\\\"\"  , str)\n+        @test ts[ 3] ~ (K\"$\"          , \"\\$\"  , str)\n+        @test ts[ 4] ~ (K\"Identifier\" , \"u\u2095x\" , str)\n+        @test ts[ 5] ~ (K\"String\"     , \" \"   , str)\n+        @test ts[ 6] ~ (K\"$\"          , \"\\$\"  , str)\n+        @test ts[ 7] ~ (K\"(\"          , \"(\"   , str)\n+        @test ts[ 8] ~ (K\"Identifier\" , \"u\u2095x\" , str)\n+        @test ts[ 9] ~ (K\"Whitespace\" , \" \"   , str)\n+        @test ts[10] ~ (K\"-\"          , \"-\"   , str)\n+        @test ts[11] ~ (K\"Whitespace\" , \" \"   , str)\n+        @test ts[12] ~ (K\"Identifier\" , \"ux\"  , str)\n+        @test ts[13] ~ (K\")\"          , \")\"   , str)\n+        @test ts[14] ~ (K\"\\\"\"         , \"\\\"\"  , str)\n+        @test ts[15] ~ (K\"Whitespace\" , \" \"   , str)\n+        @test ts[16] ~ (K\"EndMarker\"  , \"\"    , str)\n+    end\n+\n+    @testset \"var\\\"...\\\" disabled in interpolations\" begin\n+        str = \"\"\" \"\\$var\"x\" \" \"\"\"\n+        ts = collect(tokenize(str))\n+        @test ts[ 1] ~ (K\"Whitespace\" , \" \"   , str)\n+        @test ts[ 2] ~ (K\"\\\"\"         , \"\\\"\"  , str)\n+        @test ts[ 3] ~ (K\"$\"          , \"\\$\"  , str)\n+        @test ts[ 4] ~ (K\"var\"        , \"var\" , str)\n+        @test ts[ 5] ~ (K\"\\\"\"         , \"\\\"\"  , str)\n+        @test ts[ 6] ~ (K\"Identifier\" , \"x\"   , str)\n+        @test ts[ 7] ~ (K\"\\\"\"         , \"\\\"\"  , str)\n+        @test ts[ 8] ~ (K\"String\"     , \" \"   , str)\n+        @test ts[ 9] ~ (K\"\\\"\"         , \"\\\"\"  , str)\n+        @test ts[10] ~ (K\"Whitespace\" , \" \"   , str)\n+        @test ts[11] ~ (K\"EndMarker\"  , \"\"    , str)\n+    end\n+\n+    @testset \"chars after interpolation identifier\" begin\n+        # Operators allowed\n+        @test toks(\"\\\"\\$x?\\\"\") == [\n+            \"\\\"\"=>K\"\\\"\"\n+            \"\\$\"=>K\"$\"\n+            \"x\"=>K\"Identifier\"\n+            \"?\"=>K\"String\"\n+            \"\\\"\"=>K\"\\\"\"\n+        ]\n+        @test toks(\"\\\"\\$x\u2aea\\\"\") == [\n+            \"\\\"\"=>K\"\\\"\"\n+            \"\\$\"=>K\"$\"\n+            \"x\"=>K\"Identifier\"\n+            \"\u2aea\"=>K\"String\"\n+            \"\\\"\"=>K\"\\\"\"\n+        ]\n+        # Some chars disallowed (eg, U+0DF4)\n+        @test toks(\"\\\"\\$x\u0df4\\\"\") == [\n+            \"\\\"\"=>K\"\\\"\"\n+            \"\\$\"=>K\"$\"\n+            \"x\"=>K\"Identifier\"\n+            \"\u0df4\"=>K\"ErrorInvalidInterpolationTerminator\"\n+            \"\\\"\"=>K\"\\\"\"\n+        ]\n+    end\n+end\n+\n+@testset \"inferred\" begin\n+    l = tokenize(\"abc\")\n+    @inferred Tokenize.next_token(l)\n+end\n+\n+@testset \"modifying function names (!) followed by operator\" begin\n+    @test toks(\"a!=b\") == [\"a\"=>K\"Identifier\", \"!=\"=>K\"!=\", \"b\"=>K\"Identifier\"]\n+    @test toks(\"a!!=b\") == [\"a!\"=>K\"Identifier\", \"!=\"=>K\"!=\", \"b\"=>K\"Identifier\"]\n+    @test toks(\"!=b\") == [\"!=\"=>K\"!=\", \"b\"=>K\"Identifier\"]\n+end\n+\n+@testset \"integer literals\" begin\n+    @test onlytok(\"1234\")  == K\"Integer\"\n+    @test onlytok(\"12_34\") == K\"Integer\"\n+\n+    @test toks(\"1234_\") == [\"1234\"=>K\"Integer\", \"_\"=>K\"Identifier\"]\n+    @test toks(\"1234x\") == [\"1234\"=>K\"Integer\", \"x\"=>K\"Identifier\"]\n+\n+    @test onlytok(\"_1234\") == K\"Identifier\"\n+\n+    @test toks(\"1__2\") == [\"1\"=>K\"Integer\", \"__2\"=>K\"Identifier\"]\n+end\n+\n+@testset \"hex integer literals\" begin\n+    @test onlytok(\"0x0167_032\") == K\"HexInt\"\n+    @test onlytok(\"0x2_0_2\")    == K\"HexInt\"\n+    # trailing junk\n+    # https://github.com/JuliaLang/julia/issues/16356\n+    @test onlytok(\"0xenomorph\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"0xa\u03b1\")    == K\"ErrorInvalidNumericConstant\"\n+    @test toks(\"0x \") == [\"0x\"=>K\"ErrorInvalidNumericConstant\", \" \"=>K\"Whitespace\"]\n+    @test onlytok(\"0x\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"0xg\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"0x_\") == K\"ErrorInvalidNumericConstant\"\n+    @test toks(\"0x-\") == [\"0x\"=>K\"ErrorInvalidNumericConstant\", \"-\"=>K\"-\"]\n+end\n+\n+@testset \"hexfloat literals\" begin\n+    @test onlytok(\"0x.1p1\")    == K\"Float\"\n+    @test onlytok(\"0x00p2\")    == K\"Float\"\n+    @test onlytok(\"0x00P2\")    == K\"Float\"\n+    @test onlytok(\"0x0.00p23\") == K\"Float\"\n+    @test onlytok(\"0x0.0ap23\") == K\"Float\"\n+    @test onlytok(\"0x0.0_0p2\") == K\"Float\"\n+    @test onlytok(\"0x0_0_0.0_0p2\") == K\"Float\"\n+    @test onlytok(\"0x0p+2\")    == K\"Float\"\n+    @test onlytok(\"0x0p-2\")    == K\"Float\"\n+    # errors\n+    @test onlytok(\"0x\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"0x2__2\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"0x1p\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"0x.p0\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"0x.\")   == K\"ErrorHexFloatMustContainP\"\n+    @test onlytok(\"0x1.0\") == K\"ErrorHexFloatMustContainP\"\n+end\n+\n+@testset \"binary literals\" begin\n+    @test onlytok(\"0b0101001_0100_0101\")  == K\"BinInt\"\n+\n+    @test onlytok(\"0b\") == K\"ErrorInvalidNumericConstant\"\n+    @test toks(\"0b \") == [\"0b\"=>K\"ErrorInvalidNumericConstant\", \" \"=>K\"Whitespace\"]\n+    @test onlytok(\"0b101__101\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"0b123\") == K\"ErrorInvalidNumericConstant\"\n+end\n+\n+@testset \"octal literals\" begin\n+    @test onlytok(\"0o0167\") == K\"OctInt\"\n+    @test onlytok(\"0o01054001_0100_0101\") == K\"OctInt\"\n+\n+    @test onlytok(\"0o\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"0o78p\") == K\"ErrorInvalidNumericConstant\"\n+    @test toks(\"0o \") == [\"0o\"=>K\"ErrorInvalidNumericConstant\", \" \"=>K\"Whitespace\"]\n+end\n+\n+@testset \"float literals\" begin\n+    @test onlytok(\"1.0\") == K\"Float\"\n+\n+    @test onlytok(\"1.0e0\")  == K\"Float\"\n+    @test onlytok(\"1.0e-0\") == K\"Float\"\n+    @test onlytok(\"1.0E0\")  == K\"Float\"\n+    @test onlytok(\"1.0E-0\") == K\"Float\"\n+    @test onlytok(\"1.0f0\")  == K\"Float32\"\n+    @test onlytok(\"1.0f-0\") == K\"Float32\"\n+    @test onlytok(\"1.e0\")  == K\"Float\"\n+    @test onlytok(\"1.f0\")  == K\"Float32\"\n+\n+    @test onlytok(\"0e0\")    == K\"Float\"\n+    @test onlytok(\"0e+0\")   == K\"Float\"\n+    @test onlytok(\"0E0\")    == K\"Float\"\n+    @test onlytok(\"201E+0\") == K\"Float\"\n+    @test onlytok(\"2f+0\")   == K\"Float32\"\n+    @test onlytok(\"2048f0\") == K\"Float32\"\n+\n+    # underscores\n+    @test onlytok(\"1_1.11\")  == K\"Float\"\n+    @test onlytok(\"11.1_1\")  == K\"Float\"\n+    @test onlytok(\"1_1.1_1\") == K\"Float\"\n+    @test onlytok(\"1.2_3\")   == K\"Float\"\n+    @test onlytok(\"3_2.5_2\") == K\"Float\"\n+    @test toks(\"_1.1_1\") == [\"_1\"=>K\"Identifier\", \".1_1\"=>K\"Float\"]\n+\n+    # juxtapositions with identifiers\n+    @test toks(\"3e2_2\") == [\"3e2\"=>K\"Float\", \"_2\"=>K\"Identifier\"]\n+    @test toks(\"1e\") == [\"1\"=>K\"Integer\", \"e\"=>K\"Identifier\"]\n+\n+    # Floating point with \\minus rather than -\n+    @test onlytok(\"1.0e\u22120\") == K\"Float\"\n+    @test onlytok(\"1.0f\u22120\") == K\"Float32\"\n+    @test onlytok(\"0x0p\u22122\") == K\"Float\"\n+\n+    # Errors\n+    @test onlytok(\"1._\")   == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"1.1.\")  == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"1e+\")   == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"1.0e+\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"1.e1.\") == K\"ErrorInvalidNumericConstant\"\n+    @test onlytok(\"1e1.\")  == K\"ErrorInvalidNumericConstant\"\n+    @test toks(\"1.e\")   == [\"1.\"=>K\"ErrorAmbiguousNumericDotMultiply\", \"e\"=>K\"Identifier\"]\n+    @test toks(\"3.2e2.2\") == [\"3.2e2.\"=>K\"ErrorInvalidNumericConstant\", \"2\"=>K\"Integer\"]\n+    @test toks(\"3e2.2\") == [\"3e2.\"=>K\"ErrorInvalidNumericConstant\", \"2\"=>K\"Integer\"]\n+    @test toks(\"1.2.f\") == [\"1.2.\"=>K\"ErrorInvalidNumericConstant\", \"f\"=>K\"Identifier\"]\n+end\n+\n+@testset \"numbers with trailing `.` \" begin\n+    @test toks(\"1.\")  == [\"1.\"=>K\"Float\"]\n+\n+    @test toks(\"1.)\") == [\"1.\"=>K\"Float\", \")\"=>K\")\"]\n+    @test toks(\"1.]\") == [\"1.\"=>K\"Float\", \"]\"=>K\"]\"]\n+    @test toks(\"1.}\") == [\"1.\"=>K\"Float\", \"}\"=>K\"}\"]\n+    @test toks(\"1.,\") == [\"1.\"=>K\"Float\", \",\"=>K\",\"]\n+    @test toks(\"1.;\") == [\"1.\"=>K\"Float\", \";\"=>K\";\"]\n+    @test toks(\"1.#\") == [\"1.\"=>K\"Float\", \"#\"=>K\"Comment\"]\n+\n+    # ellipses\n+    @test toks(\"1..\")    == [\"1\"=>K\"Integer\",   \"..\"=>K\"..\"]\n+    @test toks(\"1...\")   == [\"1\"=>K\"Integer\",  \"...\"=>K\"...\"]\n+    @test toks(\".1..\")   == [\".1\"=>K\"Float\",    \"..\"=>K\"..\"]\n+    @test toks(\"0x01..\") == [\"0x01\"=>K\"HexInt\", \"..\"=>K\"..\"]\n+\n+    # Dotted operators and other dotted suffixes\n+    @test toks(\"1234 .+1\") == [\"1234\"=>K\"Integer\", \" \"=>K\"Whitespace\", \".\"=>K\".\", \"+\"=>K\"+\", \"1\"=>K\"Integer\"]\n+    @test toks(\"1234.0+1\") == [\"1234.0\"=>K\"Float\", \"+\"=>K\"+\", \"1\"=>K\"Integer\"]\n+    @test toks(\"1234.0 .+1\") == [\"1234.0\"=>K\"Float\", \" \"=>K\"Whitespace\", \".\"=>K\".\", \"+\"=>K\"+\", \"1\"=>K\"Integer\"]\n+    @test toks(\"1234 .f(a)\") == [\"1234\"=>K\"Integer\", \" \"=>K\"Whitespace\", \".\"=>K\".\",\n+                                 \"f\"=>K\"Identifier\", \"(\"=>K\"(\", \"a\"=>K\"Identifier\", \")\"=>K\")\"]\n+    @test toks(\"1234.0 .f(a)\") == [\"1234.0\"=>K\"Float\", \" \"=>K\"Whitespace\", \".\"=>K\".\",\n+                                   \"f\"=>K\"Identifier\", \"(\"=>K\"(\", \"a\"=>K\"Identifier\", \")\"=>K\")\"]\n+    @test toks(\"1f0./1\") == [\"1f0\"=>K\"Float32\", \".\"=>K\".\", \"/\"=>K\"/\", \"1\"=>K\"Integer\"]\n+\n+    # Dotted operators after numeric constants are ok\n+    @test toks(\"1e1.\u2aea\")  == [\"1e1\"=>K\"Float\", \".\"=>K\".\", \"\u2aea\"=>K\"\u2aea\"]\n+    @test toks(\"1.1.\u2aea\")  == [\"1.1\"=>K\"Float\", \".\"=>K\".\", \"\u2aea\"=>K\"\u2aea\"]\n+    @test toks(\"1e1.\u2212\")  == [\"1e1\"=>K\"Float\", \".\"=>K\".\", \"\u2212\"=>K\"-\"]\n+    @test toks(\"1.1.\u2212\")  == [\"1.1\"=>K\"Float\", \".\"=>K\".\", \"\u2212\"=>K\"-\"]\n+    # Non-dottable operators are not ok\n+    @test toks(\"1e1.\\$\")  == [\"1e1.\"=>K\"ErrorInvalidNumericConstant\", \"\\$\"=>K\"$\"]\n+    @test toks(\"1.1.\\$\")  == [\"1.1.\"=>K\"ErrorInvalidNumericConstant\", \"\\$\"=>K\"$\"]\n+\n+    # Ambiguous dotted operators\n+    @test toks(\"1.+\") == [\"1.\"=>K\"ErrorAmbiguousNumericConstant\", \"+\"=>K\"+\"]\n+    @test toks(\"1.+ \") == [\"1.\"=>K\"ErrorAmbiguousNumericConstant\", \"+\"=>K\"+\", \" \"=>K\"Whitespace\"]\n+    @test toks(\"1.\u290b\")  == [\"1.\"=>K\"ErrorAmbiguousNumericConstant\", \"\u290b\"=>K\"\u290b\"]\n+    @test toks(\"1.\u2aea\")  == [\"1.\"=>K\"ErrorAmbiguousNumericConstant\", \"\u2aea\"=>K\"\u2aea\"]\n+    # non-dottable ops are the exception\n+    @test toks(\"1.:\")  == [\"1.\"=>K\"Float\", \":\"=>K\":\"]\n+    @test toks(\"1.\\$\") == [\"1.\"=>K\"Float\", \"\\$\"=>K\"$\"]\n+\n+    # Ambiguous - literal vs multiply by juxtaposition\n+    @test toks(\"1.x\")  == [\"1.\"=>K\"ErrorAmbiguousNumericDotMultiply\", \"x\"=>K\"Identifier\"]\n+    @test toks(\"1.(\")  == [\"1.\"=>K\"ErrorAmbiguousNumericDotMultiply\", \"(\"=>K\"(\"]\n+    @test toks(\"1.[\")  == [\"1.\"=>K\"ErrorAmbiguousNumericDotMultiply\", \"[\"=>K\"[\"]\n+    @test toks(\"1.{\")  == [\"1.\"=>K\"ErrorAmbiguousNumericDotMultiply\", \"{\"=>K\"{\"]\n+    @test toks(\"1.@\")  == [\"1.\"=>K\"ErrorAmbiguousNumericDotMultiply\", \"@\"=>K\"@\"]\n+    @test toks(\"1.\\\"\") == [\"1.\"=>K\"ErrorAmbiguousNumericDotMultiply\", \"\\\"\"=>K\"\\\"\"]\n+end\n+\n+@testset \"julia 0.6 types\" begin\n+    @test onlytok(\"mutable\")   == K\"mutable\"\n+    @test onlytok(\"primitive\") == K\"primitive\"\n+    @test onlytok(\"struct\")    == K\"struct\"\n+    @test onlytok(\"where\")     == K\"where\"\n+\n+    @test tok(\"mutable struct s{T} where T\",  1).kind == K\"mutable\"\n+    @test tok(\"mutable struct s{T} where T\",  3).kind == K\"struct\"\n+    @test tok(\"mutable struct s{T} where T\", 10).kind == K\"where\"\n+end\n+\n+@testset \"CMDs\" begin\n+    @test tok(\"`cmd`\",1).kind == K\"`\"\n+    @test tok(\"`cmd`\",2).kind == K\"CmdString\"\n+    @test tok(\"`cmd`\",3).kind == K\"`\"\n+    @test tok(\"`cmd`\",4).kind == K\"EndMarker\"\n+    @test tok(\"```cmd```\", 1).kind == K\"```\"\n+    @test tok(\"```cmd```\", 2).kind == K\"CmdString\"\n+    @test tok(\"```cmd```\", 3).kind == K\"```\"\n+    @test tok(\"```cmd```\", 4).kind == K\"EndMarker\"\n+    @test tok(\"```cmd````cmd`\", 1).kind == K\"```\"\n+    @test tok(\"```cmd````cmd`\", 2).kind == K\"CmdString\"\n+    @test tok(\"```cmd````cmd`\", 3).kind == K\"```\"\n+    @test tok(\"```cmd````cmd`\", 4).kind == K\"`\"\n+    @test tok(\"```cmd````cmd`\", 5).kind == K\"CmdString\"\n+    @test tok(\"```cmd````cmd`\", 6).kind == K\"`\"\n+    @test tok(\"```cmd````cmd`\", 7).kind == K\"EndMarker\"\n+end\n+\n+@testset \"where\" begin\n+    @test tok(\"a where b\", 3).kind == K\"where\"\n+end\n+\n+@testset \"IO position\" begin\n+    io = IOBuffer(\"#1+1\")\n+    skip(io, 1)\n+    @test length(collect(tokenize(io))) == 4\n+end\n+\n+@testset \"dotted and suffixed operators\" begin\n+\n+for opkind in Tokenize._nondot_symbolic_operator_kinds()\n+    op = string(opkind)\n+    strs = [\n+        1 => [ # unary\n+            \"$(op)b\",\n+            \".$(op)b\",\n+        ],\n+        2 => [ # binary\n+            \"a $op b\",\n+            \"a .$op b\",\n+            \"a $(op)\u2081 b\",\n+            \"a $(op)\\U0304 b\",\n+            \"a .$(op)\u2081 b\"\n+        ]\n+    ]\n+\n+    for (arity, container) in strs\n+        for str in container\n+            expr = JuliaSyntax.fl_parse(str, raise = false)\n+            if VERSION < v\"1.7\" && str == \"a .&& b\"\n+                expr = Expr(Symbol(\".&&\"), :a, :b)\n+            end\n+            if expr isa Expr && (expr.head != :error && expr.head != :incomplete)\n+                tokens = collect(tokenize(str))\n+                exop = expr.head == :call ? expr.args[1] : expr.head\n+                #println(str)\n+                # For dotted operators, we need to reconstruct the operator from separate tokens\n+                # Note: .. and ... are not dotted operators, they're regular operators\n+                exop_str = string(exop)\n+                is_dotted = occursin(\".\", exop_str) && exop != :.. && exop != :...\n+                if is_dotted\n+                    # Dotted operators are now two tokens: . and the operator\n+                    dot_pos = arity == 1 ? 1 : 3\n+                    op_pos = arity == 1 ? 2 : 4\n+                    reconstructed_op = Symbol(Tokenize.untokenize(tokens[dot_pos], str) *\n+                                            Tokenize.untokenize(tokens[op_pos], str))\n+                    if reconstructed_op != exop\n+                        @info \"\" arity str exop reconstructed_op\n+                    end\n+                    @test reconstructed_op == exop\n+                else\n+                    # Regular operators and suffixed operators\n+                    op_pos = arity == 1 ? 1 : 3\n+                    if Symbol(Tokenize.untokenize(tokens[op_pos], str)) != exop\n+                        @info \"\" arity str exop op_pos\n+                    end\n+                    @test Symbol(Tokenize.untokenize(tokens[op_pos], str)) == exop\n+                end\n+            else\n+                break\n+            end\n+        end\n+    end\n+end\n+end\n+\n+@testset \"Normalization of Unicode symbols\" begin\n+    # https://github.com/JuliaLang/julia/pull/25157\n+    @test tok(\"\\u00b7\").kind == K\"\u22c5\"\n+    @test tok(\"\\u0387\").kind == K\"\u22c5\"\n+    @test toks(\".\\u00b7\") == [\".\"=>K\".\", \"\\u00b7\"=>K\"\u22c5\"]\n+    @test toks(\".\\u0387\") == [\".\"=>K\".\", \"\\u0387\"=>K\"\u22c5\"]\n+\n+    # https://github.com/JuliaLang/julia/pull/40948\n+    @test tok(\"\u2212\").kind == K\"-\"\n+    @test tok(\"\u2212=\").kind == K\"op=\"\n+    @test toks(\".\u2212\") == [\".\"=>K\".\", \"\u2212\"=>K\"-\"]\n+end\n+\n+@testset \"perp\" begin\n+    @test tok(\"1 \u27c2 2\", 3).kind==K\"\u27c2\"\n+end\n+\n+@testset \"outer\" begin\n+    @test tok(\"outer\", 1).kind==K\"outer\"\n+end\n+\n+@testset \"invalid operator errors\" begin\n+    @test toks(\"--\")      == [\"--\"=>K\"ErrorInvalidOperator\"]\n+    @test toks(\"1**2\") == [\"1\"=>K\"Integer\", \"**\"=>K\"Error**\", \"2\"=>K\"Integer\"]\n+    @test toks(\"a<---b\") == [\"a\"=>K\"Identifier\", \"<---\"=>K\"ErrorInvalidOperator\", \"b\"=>K\"Identifier\"]\n+    @test toks(\"a..+b\") == [\"a\"=>K\"Identifier\", \"..+\"=>K\"ErrorInvalidOperator\", \"b\"=>K\"Identifier\"]\n+    @test toks(\"a..\u2212b\") == [\"a\"=>K\"Identifier\", \"..\u2212\"=>K\"ErrorInvalidOperator\", \"b\"=>K\"Identifier\"]\n+end\n+\n+@testset \"hat suffix\" begin\n+    @test tok(\"s\u0302\", 1).kind==K\"Identifier\"\n+    @test untokenize(collect(tokenize(\"s\u0302\"))[1], \"s\u0302\") == \"s\u0302\"\n+end\n+\n+@testset \"suffixed op\" begin\n+    s = \"+\u00b9\"\n+    @test is_operator(tok(s, 1).kind)\n+    @test untokenize(collect(tokenize(s))[1], s) == s\n+end\n+\n+@testset \"circ arrow right op\" begin\n+    s = \"\u21bb\"\n+    @test collect(tokenize(s))[1].kind == K\"\u21bb\"\n+end\n+\n+@testset \"invalid float\" begin\n+    s = \".0.\"\n+    @test collect(tokenize(s))[1].kind == K\"ErrorInvalidNumericConstant\"\n+end\n+\n+@testset \"allow prime after end\" begin\n+    @test tok(\"begin end'\", 4).kind === K\"'\"\n+end\n+\n+@testset \"new ops\" begin\n+    ops = [\n+        raw\"= += -= *= /= //= \\= ^= \u00f7= %= <<= >>= >>>= |= &= \u22bb= \u2254 \u2a74 \u2255 ~ := $=\"\n+        raw\"=>\"\n+        raw\"?\"\n+        raw\"\u2190 \u2192 \u2194 \u219a \u219b \u219e \u21a0 \u21a2 \u21a3 \u21a6 \u21a4 \u21ae \u21ce \u21cd \u21cf \u21d0 \u21d2 \u21d4 \u21f4 \u21f6 \u21f7 \u21f8 \u21f9 \u21fa \u21fb \u21fc \u21fd \u21fe \u21ff \u27f5 \u27f6 \u27f7 \u27f9 \u27fa \u27fb \u27fc \u27fd \u27fe \u27ff \u2900 \u2901 \u2902 \u2903 \u2904 \u2905 \u2906 \u2907 \u290c \u290d \u290e \u290f \u2910 \u2911 \u2914 \u2915 \u2916 \u2917 \u2918 \u291d \u291e \u291f \u2920 \u2944 \u2945 \u2946 \u2947 \u2948 \u294a \u294b \u294e \u2950 \u2952 \u2953 \u2956 \u2957 \u295a \u295b \u295e \u295f \u2962 \u2964 \u2966 \u2967 \u2968 \u2969 \u296a \u296b \u296c \u296d \u2970 \u29f4 \u2b31 \u2b30 \u2b32 \u2b33 \u2b34 \u2b35 \u2b36 \u2b37 \u2b38 \u2b39 \u2b3a \u2b3b \u2b3c \u2b3d \u2b3e \u2b3f \u2b40 \u2b41 \u2b42 \u2b43 \u2b44 \u2b47 \u2b48 \u2b49 \u2b4a \u2b4b \u2b4c \uffe9 \uffeb \u21dc \u21dd \u219c \u219d \u21a9 \u21aa \u21ab \u21ac \u21bc \u21bd \u21c0 \u21c1 \u21c4 \u21c6 \u21c7 \u21c9 \u21cb \u21cc \u21da \u21db \u21e0 \u21e2 \u21b7 \u21b6 \u21ba \u21bb -->\"\n+        raw\"||\"\n+        raw\"&&\"\n+        raw\"> < >= \u2265 <= \u2264 == === \u2261 != \u2260 !== \u2262 \u2208 \u2209 \u220b \u220c \u2286 \u2288 \u2282 \u2284 \u228a \u221d \u220a \u220d \u2225 \u2226 \u2237 \u223a \u223b \u223d \u223e \u2241 \u2243 \u2242 \u2244 \u2245 \u2246 \u2247 \u2248 \u2249 \u224a \u224b \u224c \u224d \u224e \u2250 \u2251 \u2252 \u2253 \u2256 \u2257 \u2258 \u2259 \u225a \u225b \u225c \u225d \u225e \u225f \u2263 \u2266 \u2267 \u2268 \u2269 \u226a \u226b \u226c \u226d \u226e \u226f \u2270 \u2271 \u2272 \u2273 \u2274 \u2275 \u2276 \u2277 \u2278 \u2279 \u227a \u227b \u227c \u227d \u227e \u227f \u2280 \u2281 \u2283 \u2285 \u2287 \u2289 \u228b \u228f \u2290 \u2291 \u2292 \u229c \u22a9 \u22ac \u22ae \u22b0 \u22b1 \u22b2 \u22b3 \u22b4 \u22b5 \u22b6 \u22b7 \u22cd \u22d0 \u22d1 \u22d5 \u22d6 \u22d7 \u22d8 \u22d9 \u22da \u22db \u22dc \u22dd \u22de \u22df \u22e0 \u22e1 \u22e2 \u22e3 \u22e4 \u22e5 \u22e6 \u22e7 \u22e8 \u22e9 \u22ea \u22eb \u22ec \u22ed \u22f2 \u22f3 \u22f4 \u22f5 \u22f6 \u22f7 \u22f8 \u22f9 \u22fa \u22fb \u22fc \u22fd \u22fe \u22ff \u27c8 \u27c9 \u27d2 \u29b7 \u29c0 \u29c1 \u29e1 \u29e3 \u29e4 \u29e5 \u2a66 \u2a67 \u2a6a \u2a6b \u2a6c \u2a6d \u2a6e \u2a6f \u2a70 \u2a71 \u2a72 \u2a73 \u2a75 \u2a76 \u2a77 \u2a78 \u2a79 \u2a7a \u2a7b \u2a7c \u2a7d \u2a7e \u2a7f \u2a80 \u2a81 \u2a82 \u2a83 \u2a84 \u2a85 \u2a86 \u2a87 \u2a88 \u2a89 \u2a8a \u2a8b \u2a8c \u2a8d \u2a8e \u2a8f \u2a90 \u2a91 \u2a92 \u2a93 \u2a94 \u2a95 \u2a96 \u2a97 \u2a98 \u2a99 \u2a9a \u2a9b \u2a9c \u2a9d \u2a9e \u2a9f \u2aa0 \u2aa1 \u2aa2 \u2aa3 \u2aa4 \u2aa5 \u2aa6 \u2aa7 \u2aa8 \u2aa9 \u2aaa \u2aab \u2aac \u2aad \u2aae \u2aaf \u2ab0 \u2ab1 \u2ab2 \u2ab3 \u2ab4 \u2ab5 \u2ab6 \u2ab7 \u2ab8 \u2ab9 \u2aba \u2abb \u2abc \u2abd \u2abe \u2abf \u2ac0 \u2ac1 \u2ac2 \u2ac3 \u2ac4 \u2ac5 \u2ac6 \u2ac7 \u2ac8 \u2ac9 \u2aca \u2acb \u2acc \u2acd \u2ace \u2acf \u2ad0 \u2ad1 \u2ad2 \u2ad3 \u2ad4 \u2ad5 \u2ad6 \u2ad7 \u2ad8 \u2ad9 \u2af7 \u2af8 \u2af9 \u2afa \u22a2 \u22a3 \u27c2 <: >:\"\n+        raw\"<|\"\n+        raw\"|>\"\n+        raw\": .. \u2026 \u205d \u22ee \u22f1 \u22f0 \u22ef\"\n+        raw\"$ + - \u00a6 | \u2295 \u2296 \u229e \u229f ++ \u222a \u2228 \u2294 \u00b1 \u2213 \u2214 \u2238 \u224f \u228e \u22bb \u22bd \u22ce \u22d3 \u29fa \u29fb \u2a08 \u2a22 \u2a23 \u2a24 \u2a25 \u2a26 \u2a27 \u2a28 \u2a29 \u2a2a \u2a2b \u2a2c \u2a2d \u2a2e \u2a39 \u2a3a \u2a41 \u2a42 \u2a45 \u2a4a \u2a4c \u2a4f \u2a50 \u2a52 \u2a54 \u2a56 \u2a57 \u2a5b \u2a5d \u2a61 \u2a62 \u2a63\"\n+        raw\"* / \u233f \u00f7 % & \u22c5 \u2218 \u00d7 \\ \u2229 \u2227 \u2297 \u2298 \u2299 \u229a \u229b \u22a0 \u22a1 \u2293 \u2217 \u2219 \u2224 \u214b \u2240 \u22bc \u22c4 \u22c6 \u22c7 \u22c9 \u22ca \u22cb \u22cc \u22cf \u22d2 \u27d1 \u29b8 \u29bc \u29be \u29bf \u29f6 \u29f7 \u2a07 \u2a30 \u2a31 \u2a32 \u2a33 \u2a34 \u2a35 \u2a36 \u2a37 \u2a38 \u2a3b \u2a3c \u2a3d \u2a40 \u2a43 \u2a44 \u2a4b \u2a4d \u2a4e \u2a51 \u2a53 \u2a55 \u2a58 \u2a5a \u2a5c \u2a5e \u2a5f \u2a60 \u2adb \u228d \u25b7 \u2a1d \u27d5 \u27d6 \u27d7\"\n+        raw\"//\"\n+        raw\"<< >> >>>\"\n+        raw\"^ \u2191 \u2193 \u21f5 \u27f0 \u27f1 \u2908 \u2909 \u290a \u290b \u2912 \u2913 \u2949 \u294c \u294d \u294f \u2951 \u2954 \u2955 \u2958 \u2959 \u295c \u295d \u2960 \u2961 \u2963 \u2965 \u296e \u296f \uffea \uffec\"\n+        raw\"::\"\n+        raw\".\"\n+    ]\n+    if VERSION >= v\"1.6.0\"\n+        push!(ops, raw\"<-- <-->\")\n+    end\n+    if VERSION >= v\"1.7.0\"\n+        append!(ops, [\n+            \"\u2212\"\n+            \"\\u00b7 \\u0387\"\n+            \"\u2aea \u2aeb\"\n+        ])\n+    end\n+    if VERSION >= v\"1.10-DEV\"\n+        push!(ops, \"\u2977 \u297a \u27c7\")\n+    end\n+    allops = split(join(ops, \" \"), \" \")\n+    @test all(s->Base.isoperator(Symbol(s)) == is_operator(first(collect(tokenize(s))).kind), allops)\n+\n+    # \"\\U1f8b2\" added in Julia 1.12\n+    @test is_operator(first(collect(tokenize(\"\ud83e\udcb2\"))))\n+end\n+\n+const all_kws = Set([\n+    # Keywords\n+    \"baremodule\",\n+    \"begin\",\n+    \"break\",\n+    \"catch\",\n+    \"const\",\n+    \"continue\",\n+    \"do\",\n+    \"else\",\n+    \"elseif\",\n+    \"end\",\n+    \"export\",\n+    \"finally\",\n+    \"for\",\n+    \"function\",\n+    \"global\",\n+    \"if\",\n+    \"import\",\n+    \"let\",\n+    \"local\",\n+    \"macro\",\n+    \"module\",\n+    \"public\",\n+    \"quote\",\n+    \"return\",\n+    \"struct\",\n+    \"try\",\n+    \"using\",\n+    \"while\",\n+    # Contextual keywords\n+    \"abstract\",\n+    \"as\",\n+    \"doc\",\n+    \"mutable\",\n+    \"outer\",\n+    \"primitive\",\n+    \"type\",\n+    \"var\",\n+    # Word-like operators\n+    \"in\",\n+    \"isa\",\n+    \"where\",\n+])\n+\n+function check_kw_hashes(iter)\n+    for cs in iter\n+        str = String([cs...])\n+        if Tokenize.simple_hash(str) in keys(Tokenize._kw_hash)\n+            @test str in all_kws\n+        end\n+    end\n+end\n+\n+@testset \"simple_hash\" begin\n+    @test length(all_kws) == length(Tokenize._kw_hash)\n+\n+    @testset \"Length $len keywords\" for len in 1:5\n+        check_kw_hashes(String([cs...]) for cs in Iterators.product(['a':'z' for _ in 1:len]...))\n+    end\n+end\n+\n+\n+@testset \"UTF-8 BOM\" begin\n+    @test kind.(collect(tokenize(\"\\ufeff[1\\ufeff2]\"))) == [\n+        K\"Whitespace\",\n+        K\"[\",\n+        K\"Integer\",\n+        K\"Whitespace\",\n+        K\"Integer\",\n+        K\"]\",\n+        K\"EndMarker\"\n+    ]\n+end\n+\n+@testset \"lexer initialization\" begin\n+    # Ranges of EndMarker\n+    @test (t = last(collect(tokenize(\"+\"))); (t.startbyte, t.endbyte)) == (1,0)\n+    @test (t = last(collect(tokenize(\"+*\"))); (t.startbyte, t.endbyte)) == (2,1)\n+end\n+\n+@testset \"invalid UTF-8 characters\" begin\n+    @test onlytok(\"\\x00\") == K\"ErrorUnknownCharacter\"\n+    @test onlytok(\"\u2081\") == K\"ErrorIdentifierStart\"\n+\n+    bad_chars = [\n+        first(\"\\xe2\")              # malformed\n+        first(\"\\xc0\\x9b\")          # overlong\n+        first(\"\\xf0\\x83\\x99\\xae\")  # overlong\n+    ]\n+\n+    @testset \"bad char $(repr(c))\" for c in bad_chars\n+        @test Tokenize.is_identifier_char(c) == false\n+        @test Tokenize.is_identifier_start_char(c) == false\n+        @test Tokenize.is_never_id_char(c) == true\n+        @test Tokenize.is_dottable_operator_start_char(c) == false\n+        @test Tokenize.isopsuffix(c) == false\n+        @test Tokenize.is_operator_start_char(c) == false\n+        @test Tokenize.iswhitespace(c) == false\n+        @test Tokenize.ishex(c) == false\n+    end\n+end\n+\n+@testset \"unbalanced bidirectional unicode\" begin\n+    open_embedding = ['\\U202A', '\\U202B', '\\U202D', '\\U202E']\n+    close_embedding = '\\U202C'\n+    open_isolate = ['\\U2066', '\\U2067', '\\U2068']\n+    close_isolate = '\\U2069'\n+    close_all = '\\n'\n+\n+    all_bidi_codes = [open_embedding; close_embedding; open_isolate; close_isolate]\n+\n+    bidi_pairs = [Iterators.product(open_embedding, [close_embedding, close_all])...,\n+                  Iterators.product(open_isolate,   [close_isolate, close_all])...]\n+\n+    @testset \"delimiter $kd\" for (kd, chunk_kind) in [\n+            (K\"\\\"\",      K\"String\"),\n+            (K\"\\\"\\\"\\\"\",  K\"String\"),\n+            (K\"`\",       K\"CmdString\"),\n+            (K\"```\",     K\"CmdString\")\n+        ]\n+        d = string(kd)\n+        @testset \"Single unbalanced codes\" begin\n+            for c in all_bidi_codes\n+                @test toks(\"$d$c$d\") ==\n+                    [d=>kd, \"$c\"=>K\"ErrorBidiFormatting\", d=>kd]\n+                @test toks(\"pfx$d$c$d\") ==\n+                    [\"pfx\"=>K\"Identifier\", d=>kd, \"$c\"=>K\"ErrorBidiFormatting\", d=>kd]\n+            end\n+        end\n+        @testset \"Balanced pairs\" begin\n+            for (openc, closec) in bidi_pairs\n+                str = \"$(openc)##$(closec)\"\n+                @test toks(\"$d$str$d\") ==\n+                    [d=>kd, str=>chunk_kind, d=>kd]\n+                @test toks(\"pfx$d$str$d\") ==\n+                    [\"pfx\"=>K\"Identifier\", d=>kd, str=>chunk_kind, d=>kd]\n+            end\n+        end\n+    end\n+\n+    @testset \"multi line comments\" begin\n+        @testset \"Single unbalanced codes\" begin\n+            for c in all_bidi_codes\n+                comment = \"#=$c=#\"\n+                @test toks(comment) == [comment=>K\"ErrorBidiFormatting\"]\n+            end\n+        end\n+        @testset \"Balanced pairs\" begin\n+            for (openc, closec) in bidi_pairs\n+                str = \"#=$(openc)zz$(closec)=#\"\n+                @test toks(str) == [str=>K\"Comment\"]\n+            end\n+        end\n+    end\n+\n+    @testset \"extended balanced/unbalanced bidi state\" begin\n+        @testset \"delimiter $kd\" for (kd, chunk_kind) in [\n+                (K\"\\\"\",      K\"String\"),\n+                (K\"\\\"\\\"\\\"\",  K\"String\"),\n+                (K\"`\",       K\"CmdString\"),\n+                (K\"```\",     K\"CmdString\")\n+            ]\n+            d = string(kd)\n+            for balanced in [# Balanced pairs\n+                             \"\\u202a\\u202bzz\\u202c\\u202c\"\n+                             \"\\u2066\\u2067zz\\u2069\\u2069\"\n+                             # Newline is complete bidi state reset\n+                             \"\\u202a\\u2067zz\\n\"\n+                             \"\\u202a\\u202azz\\n\"\n+                             # \\r\\n and \\n terminate a line\n+                             \"\\u202azz\\r\\n\"\n+                             ]\n+                @test toks(\"$d$balanced$d\") == [\n+                    d=>kd\n+                    balanced=>chunk_kind\n+                    d=>kd\n+                ]\n+            end\n+            for unbalanced in [\"\\u202azz\\u202c\\u202c\"\n+                               \"\\u202a\\u202bzz\\u202c\"\n+                               # \\r does not terminate a bidi line\n+                               \"\\u202azz\\r\"\n+                              ]\n+                @test toks(\"$d$unbalanced$d\") == [\n+                    d=>kd\n+                    unbalanced=>K\"ErrorBidiFormatting\"\n+                    d=>kd\n+                ]\n+            end\n+        end\n+    end\n+\n+    # Interpolations reset bidi state\n+    @test toks(\"\\\"\\u202a\\$zz\\n\\\"\") == [\n+        \"\\\"\"=>K\"\\\"\"\n+        \"\\u202a\"=>K\"ErrorBidiFormatting\"\n+        \"\\$\"=>K\"$\"\n+        \"zz\"=>K\"Identifier\"\n+        \"\\n\"=>K\"String\"\n+        \"\\\"\"=>K\"\\\"\"\n+    ]\n+    @testset \"newline escaping\" begin\n+        @test toks(\"\\\"a\\u202a\\\\\\n\\\"\") == [\n+             \"\\\"\"=>K\"\\\"\"\n+             \"a\\u202a\"=>K\"String\"\n+             \"\\\\\\n\"=>K\"Whitespace\"\n+             \"\\\"\"=>K\"\\\"\"\n+        ]\n+        @test toks(\"\\\"a\\u202a\\\\\\r\\n\\\"\") == [\n+             \"\\\"\"=>K\"\\\"\"\n+             \"a\\u202a\"=>K\"String\"\n+             \"\\\\\\r\\n\"=>K\"Whitespace\"\n+             \"\\\"\"=>K\"\\\"\"\n+        ]\n+        @test toks(\"\\\"a\\u202a\\\\\\r\\\"\") == [\n+             \"\\\"\"=>K\"\\\"\"\n+             \"a\\u202a\"=>K\"ErrorBidiFormatting\"\n+             \"\\\\\\r\"=>K\"Whitespace\"\n+             \"\\\"\"=>K\"\\\"\"\n+        ]\n+    end\n+\n+    @testset \"delimiter '\" begin\n+        for c in all_bidi_codes\n+            @test toks(\"'$c'\") == [\"'\"=>K\"'\", \"$c\"=>K\"Char\", \"'\"=>K\"'\"]\n+        end\n+    end\n+end\n+\n+@testset \"dotop miscellanea\" begin\n+    @test strtok(\"a .-> b\")  ==  [\"a\", \" \", \".\", \"-\", \">\", \" \", \"b\", \"\"]\n+    @test strtok(\".>: b\")    ==  [\".\", \">:\", \" \", \"b\", \"\"]\n+    @test strtok(\".<: b\")    ==  [\".\", \"<:\", \" \", \"b\", \"\"]\n+    @test strtok(\"a ||\u2081 b\")  ==  [\"a\", \" \", \"||\", \"\u2081\", \" \", \"b\", \"\"]\n+    @test strtok(\"a ||\u0304 b\")   ==  [\"a\", \" \", \"||\", \"\u0304\", \" \", \"b\", \"\"]\n+    @test strtok(\"a .||\u2081 b\") ==  [\"a\", \" \", \".\", \"||\", \"\u2081\", \" \", \"b\", \"\"]\n+    @test strtok(\"a &&\u2081 b\")  ==  [\"a\", \" \", \"&&\", \"\u2081\", \" \", \"b\", \"\"]\n+    @test strtok(\"a &&\u0304 b\")   ==  [\"a\", \" \", \"&&\", \"\u0304\", \" \", \"b\", \"\"]\n+    @test strtok(\"a .&&\u2081 b\") ==  [\"a\", \" \", \".\", \"&&\", \"\u2081\", \" \", \"b\", \"\"]\n+end\n+\n+end"
    },
    {
      "sha": "371da98c9e174972c85a686ce03776e49622fc74",
      "filename": "JuliaSyntax/test/utils.jl",
      "status": "added",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Futils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftest%2Futils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Futils.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,24 @@\n+@testset \"_printstyled\" begin\n+    ps(str; kws...) = sprint(io->JuliaSyntax._printstyled(IOContext(io, :color=>true), str; kws...))\n+\n+    @test ps(\"XX\"; fgcolor=:red) == \"\\e[31mXX\\e[0;0m\"\n+    @test ps(\"XX\"; fgcolor=42)   == \"\\e[38;5;42mXX\\e[0;0m\"\n+    @test ps(\"XX\"; fgcolor=(10,100,200)) == \"\\e[38;2;10;100;200mXX\\e[0;0m\"\n+\n+    ps(\"XX\"; bgcolor=:red) == \"\\e[41mXX\\e[0;0m\"\n+    @test ps(\"XX\"; bgcolor=42) == \"\\e[48;5;42mXX\\e[0;0m\"\n+    @test ps(\"XX\"; bgcolor=(10,100,200)) == \"\\e[48;2;10;100;200mXX\\e[0;0m\"\n+\n+    @test ps(\"XX\"; href=\"https://www.example.com\") ==\n+        \"\\e]8;;https://www.example.com\\e\\\\XX\\e[0;0m\\e]8;;\\e\\\\\"\n+\n+    @test ps(\"XX\", fgcolor=:red, bgcolor=:green, href=\"https://www.example.com\") ==\n+        \"\\e]8;;https://www.example.com\\e\\\\\\e[31m\\e[42mXX\\e[0;0m\\e]8;;\\e\\\\\"\n+end\n+\n+@testset \"ambiguities\" begin\n+    if VERSION >= v\"1.8\"\n+        @test detect_ambiguities(JuliaSyntax) == []\n+        @test detect_unbound_args(JuliaSyntax) == []\n+    end\n+end"
    },
    {
      "sha": "aec2876deb645b672e61ce37ec1cc504089878e6",
      "filename": "JuliaSyntax/tools/bump_in_Base.jl",
      "status": "added",
      "additions": 74,
      "deletions": 0,
      "changes": 74,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftools%2Fbump_in_Base.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftools%2Fbump_in_Base.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftools%2Fbump_in_Base.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,74 @@\n+function find_checksum_files(checksum_dir)\n+    filter(readdir(checksum_dir, join=true)) do path\n+        occursin(r\"^JuliaSyntax-\", basename(path))\n+    end\n+end\n+\n+function bump_in_Base(julia_dir, juliasyntax_dir, juliasyntax_branch_or_commit)\n+    julia_git_dir = joinpath(julia_dir, \".git\")\n+    JuliaSyntax_git_dir = joinpath(juliasyntax_dir, \".git\")\n+    if !isdir(julia_git_dir)\n+        @error \"Julia .git directory not found\" julia_git_dir\n+        return 1\n+    end\n+    if !isdir(JuliaSyntax_git_dir)\n+        @error \"JuliaSyntax .git directory not found\" JuliaSyntax_git_dir\n+        return 1\n+    end\n+\n+    @info \"Vendoring JuliaSyntax into Base\" julia_dir juliasyntax_branch_or_commit\n+\n+    remote_containing_branches = filter(b->occursin(r\"^origin/(main|release-.*)$\", b),\n+        strip.(split(\n+            read(`git --git-dir=$JuliaSyntax_git_dir branch -r --contains $juliasyntax_branch_or_commit`, String),\n+            '\\n', keepempty=false)))\n+    if isempty(remote_containing_branches)\n+        @warn \"No remote main or release branches contain the given commit. This is ok for testing, but is otherwise an error.\" juliasyntax_branch_or_commit\n+    else\n+        @info \"Given commit is accessible on remote branch\" remote_containing_branches\n+    end\n+\n+    commit_sha = strip(String(read(`git --git-dir=$JuliaSyntax_git_dir show -s --pretty=tformat:%H $juliasyntax_branch_or_commit`)))\n+\n+    cd(julia_dir) do\n+        status = read(`git status --porcelain --untracked-files=no`, String)\n+        if status != \"\"\n+            @error \"Julia git directory contains uncommitted changes\" status=Text(status)\n+            return 1\n+        end\n+\n+        verfile_path = joinpath(\"deps\", \"JuliaSyntax.version\")\n+        @info \"Updating JuliaSyntax.version\" verfile_path\n+        write(verfile_path, replace(read(verfile_path, String), r\"JULIASYNTAX_SHA1.*\"=>\"JULIASYNTAX_SHA1 = \"*commit_sha))\n+        run(`git add $verfile_path`)\n+\n+        @info \"Updating JuliaSyntax checksums\"\n+        deps_dir = \"deps\"\n+        checksum_dir = joinpath(deps_dir, \"checksums\")\n+        old_checksum_paths = find_checksum_files(checksum_dir)\n+        if !isempty(old_checksum_paths)\n+            run(`git rm -rf $old_checksum_paths`)\n+        end\n+        run(`make -C $deps_dir`)\n+        run(`git add $(find_checksum_files(checksum_dir))`)\n+\n+        # Force rebuild of Base to include the newly vendored JuliaSyntax next time Julia is built.\n+        # (TODO: fix the Makefile instead?)\n+        touch(\"base/Base.jl\")\n+\n+        @info \"JuliaSyntax version updated. You can now test or commit the following changes\"\n+        run(`git diff --cached`)\n+    end\n+\n+    return 0\n+end\n+\n+if !isinteractive()\n+    if length(ARGS) != 2\n+        println(\"Usage: bump_in_Base.jl \\$julia_dir \\$juliasyntax_branch_or_commit\")\n+        exit(1)\n+    else\n+        juliasyntax_dir = dirname(@__DIR__)\n+        exit(bump_in_Base(ARGS[1], juliasyntax_dir, ARGS[2]))\n+    end\n+end"
    },
    {
      "sha": "32f255e0cb6ea9381274deb2f8efee5844f77e06",
      "filename": "JuliaSyntax/tools/check_all_packages.jl",
      "status": "added",
      "additions": 99,
      "deletions": 0,
      "changes": 99,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftools%2Fcheck_all_packages.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftools%2Fcheck_all_packages.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftools%2Fcheck_all_packages.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,99 @@\n+# hacky script to parse all Julia files in all packages in General\n+# to Exprs and report errors\n+#\n+# Run this after registry_download.jl (so the pkgs directory is populated).\n+\n+using JuliaSyntax, Logging, TerminalLoggers, ProgressLogging, Serialization\n+\n+include(\"../test/test_utils.jl\")\n+include(\"../test/fuzz_test.jl\")\n+\n+srcpaths = isempty(ARGS) ? [joinpath(@__DIR__, \"pkgs\")] : abspath.(ARGS)\n+source_paths = vcat(find_source_in_path.(srcpaths)...)\n+\n+file_count = length(source_paths)\n+\n+exception_count = 0\n+mismatch_count = 0\n+t0 = time()\n+exceptions = []\n+\n+all_reduced_failures = String[]\n+\n+Logging.with_logger(TerminalLogger()) do\n+    global exception_count, mismatch_count, t0\n+    @withprogress for (ifile, fpath) in enumerate(source_paths)\n+        @logprogress ifile/file_count time_ms=round((time() - t0)/ifile*1000, digits = 2)\n+        text = read(fpath, String)\n+        expr_cache = fpath*\".Expr\"\n+        e2 = if isfile(expr_cache)\n+            open(deserialize, fpath*\".Expr\")\n+        else\n+            @warn \"Expr cache not found, parsing using reference parser\" expr_cache maxlog=1\n+            JuliaSyntax.fl_parseall(text, filename=fpath)\n+        end\n+        @assert Meta.isexpr(e2, :toplevel)\n+        try\n+            e1 = JuliaSyntax.parseall(Expr, text, filename=fpath, ignore_warnings=true)\n+            if !exprs_roughly_equal(e2, e1)\n+                mismatch_count += 1\n+                failing_source = sprint(context=:color=>true) do io\n+                    for c in reduce_tree(parseall(SyntaxNode, text))\n+                        JuliaSyntax.highlight(io, c.source, JuliaSyntax.byte_range(c), context_lines_inner=5)\n+                        println(io, \"\\n\")\n+                    end\n+                end\n+                reduced_failures = reduce_text.(reduce_tree(text),\n+                                                parsers_fuzzy_disagree)\n+                append!(all_reduced_failures, reduced_failures)\n+                @error(\"Parsers succeed but disagree\",\n+                       fpath,\n+                       failing_source=Text(failing_source),\n+                       reduced_failures,\n+                       )\n+            end\n+        catch err\n+            err isa InterruptException && rethrow()\n+            ex = (err, catch_backtrace())\n+            push!(exceptions, ex)\n+            ref_parse = \"success\"\n+            if length(e2.args) >= 1 && Meta.isexpr(last(e2.args), (:error, :incomplete))\n+                ref_parse = \"fail\"\n+                if err isa JuliaSyntax.ParseError\n+                    # Both parsers agree that there's an error, and\n+                    # JuliaSyntax didn't have an internal error.\n+                    continue\n+                end\n+            end\n+\n+            exception_count += 1\n+            parse_to_syntax = \"success\"\n+            try\n+                JuliaSyntax.parseall(JuliaSyntax.SyntaxNode, code)\n+            catch err2\n+                parse_to_syntax = \"fail\"\n+            end\n+            @error \"Parse failed\" fpath exception=ex parse_to_syntax\n+        end\n+    end\n+end\n+\n+t_avg = round((time() - t0)/file_count*1000, digits = 2)\n+\n+println()\n+@info \"\"\"\n+    Finished parsing $file_count files.\n+        $(exception_count) failures compared to reference parser\n+        $(mismatch_count) Expr mismatches\n+        $(t_avg)ms per file\"\"\"\n+\n+open(joinpath(@__DIR__, \"reduced_failures.jl\"), write=true) do io\n+    for str in all_reduced_failures\n+        println(io, repr(str))\n+    end\n+    for str in all_reduced_failures\n+        println(io, \"#------------------------------\")\n+        println(io, str)\n+        println(io)\n+    end\n+end"
    },
    {
      "sha": "e866a6ee72a948d4efdd8e2387522d9585f1e4f5",
      "filename": "JuliaSyntax/tools/registry_download.jl",
      "status": "added",
      "additions": 46,
      "deletions": 0,
      "changes": 46,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftools%2Fregistry_download.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftools%2Fregistry_download.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftools%2Fregistry_download.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,46 @@\n+# Hacky script to download the latest version of all packages registered in the\n+# General registry for testing the parser.\n+#\n+# This uses internal Pkg APIs and seems to work on Julia 1.7\n+\n+using Pkg\n+using Downloads\n+\n+registry = only(filter(r->r.name == \"General\", Pkg.Registry.reachable_registries()))\n+\n+packages = []\n+\n+for (uuid,pkg) in registry\n+    versions = collect(Pkg.Registry.registry_info(pkg).version_info)\n+    latest_ver, ver_info = last(sort(versions, by=first))\n+    if ver_info.yanked\n+        continue\n+    end\n+\n+    push!(packages, (; uuid, pkg.name, version=latest_ver, ver_info.git_tree_sha1))\n+\n+end\n+\n+server = Pkg.pkg_server()\n+output_dir = \"pkgs\"\n+mkpath(output_dir)\n+\n+asyncmap(packages, ntasks=5) do pkg\n+    url = \"$server/package/$(pkg.uuid)/$(pkg.git_tree_sha1)\"\n+    outfile_path = joinpath(output_dir, \"$(pkg.name)_$(pkg.version).tgz\")\n+    if isfile(outfile_path)\n+        @info \"Skipping package\" pkg\n+        return outfile_path\n+    else\n+        @info \"Download package\" url outfile_path\n+        for i=1:5\n+            try\n+                Downloads.download(url, outfile_path)\n+                break\n+            catch\n+                @error \"Error downloading\" pkg exception=current_exceptions()\n+            end\n+            sleep(i)\n+        end\n+    end\n+end"
    },
    {
      "sha": "2c6986890bb63aeda4c5f8ae7e27c93478dc2c84",
      "filename": "JuliaSyntax/tools/untar_packages.jl",
      "status": "added",
      "additions": 68,
      "deletions": 0,
      "changes": 68,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftools%2Funtar_packages.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/JuliaSyntax%2Ftools%2Funtar_packages.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftools%2Funtar_packages.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -0,0 +1,68 @@\n+using Serialization\n+using JuliaSyntax\n+\n+pkgspath = joinpath(@__DIR__, \"pkgs\")\n+tarspath = joinpath(@__DIR__, \"pkg_tars\")\n+\n+mkpath(pkgspath)\n+mkpath(tarspath)\n+\n+tar_info = [(m = match(r\"(.*)_(\\d+\\.\\d+\\.\\d+.*)\\.tgz$\", f); (f, m[1], VersionNumber(m[2])))\n+            for f in readdir(tarspath) if endswith(f, \".tgz\")]\n+\n+tar_maxver = Dict{String,VersionNumber}()\n+for (_,name,ver) in tar_info\n+    v = get(tar_maxver, name, v\"0.0.0\")\n+    if v < ver\n+        tar_maxver[name] = ver\n+    end\n+end\n+\n+@info \"# Untarring packages\"\n+\n+for tinfos in Iterators.partition(tar_info, 50)\n+    @sync for (tarname, pkgname, pkgver) in tinfos\n+        @async begin\n+            dir = joinpath(pkgspath, \"$(pkgname)_$(pkgver)\")\n+            if pkgver != tar_maxver[pkgname]\n+                if isdir(dir)\n+                    # Clean up old packages\n+                    rm(dir; recursive=true, force=true)\n+                end\n+            elseif !isdir(dir) || !isdir(joinpath(dir, \"src\"))\n+                rm(dir; recursive=true, force=true)\n+                mkpath(dir)\n+                tar_path = joinpath(tarspath, tarname)\n+                try\n+                    run(`tar -xf $tar_path -C $dir`)\n+                catch err\n+                    @error \"could not untar $tar_path\"\n+                end\n+            end\n+        end\n+    end\n+end\n+\n+@info \"# Parsing files with reference parser\"\n+\n+let i = 0, tot_files = 0\n+    for (r, _, files) in walkdir(pkgspath)\n+        for f in files\n+            tot_files += 1\n+            endswith(f, \".jl\") || continue\n+            fpath = joinpath(r, f)\n+            outpath = joinpath(r, f*\".Expr\")\n+            if !islink(fpath) && isfile(fpath) && !isfile(outpath)\n+                code = read(fpath, String)\n+                fl_ex = JuliaSyntax.fl_parseall(code, filename=fpath)\n+                i += 1\n+                if i % 100 == 0\n+                    @info \"$i/$tot_files files parsed\"\n+                end\n+                open(outpath, \"w\") do io\n+                    serialize(io, fl_ex)\n+                end\n+            end\n+        end\n+    end\n+end"
    },
    {
      "sha": "7dfd165237aa83071c79abd35ad8c7223b7a37a5",
      "filename": "Makefile",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/Makefile",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/Makefile",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Makefile?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -79,7 +79,7 @@ ifndef JULIA_VAGRANT_BUILD\n endif\n endif\n \n-TOP_LEVEL_PKGS := Compiler\n+TOP_LEVEL_PKGS := Compiler JuliaSyntax JuliaLowering\n \n TOP_LEVEL_PKG_LINK_TARGETS := $(addprefix $(build_datarootdir)/julia/,$(TOP_LEVEL_PKGS))\n "
    },
    {
      "sha": "c5513b0af0ce36ef71579b7fbcaaa550d0539a56",
      "filename": "base/Base.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/base%2FBase.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/base%2FBase.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2FBase.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -315,9 +315,9 @@ a_method_to_overwrite_in_test() = inferencebarrier(1)\n @eval Core const Compiler = $Base.Compiler\n @eval Compiler const fl_parse = $Base.fl_parse\n \n-# External libraries vendored into Base\n+# Compiler frontend\n Core.println(\"JuliaSyntax/src/JuliaSyntax.jl\")\n-include(@__MODULE__, string(BUILDROOT, \"JuliaSyntax/src/JuliaSyntax.jl\")) # include($BUILDROOT/base/JuliaSyntax/JuliaSyntax.jl)\n+include(@__MODULE__, string(DATAROOT, \"julia/JuliaSyntax/src/JuliaSyntax.jl\"))\n \n end_base_include = time_ns()\n "
    },
    {
      "sha": "4a8afa8fbd53c445a4d4a531335c3f78ad7f953f",
      "filename": "deps/JuliaSyntax.mk",
      "status": "removed",
      "additions": 0,
      "deletions": 16,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f5f4c0174ed51de3811da861c0bf01b4e9f10972/deps%2FJuliaSyntax.mk",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f5f4c0174ed51de3811da861c0bf01b4e9f10972/deps%2FJuliaSyntax.mk",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2FJuliaSyntax.mk?ref=f5f4c0174ed51de3811da861c0bf01b4e9f10972",
      "patch": "@@ -1,16 +0,0 @@\n-$(eval $(call git-external,JuliaSyntax,JULIASYNTAX,,,$(BUILDDIR)))\n-\n-$(BUILDDIR)/$(JULIASYNTAX_SRC_DIR)/build-compiled: $(BUILDDIR)/$(JULIASYNTAX_SRC_DIR)/source-extracted\n-\t@# no build steps\n-\techo 1 > $@\n-\n-$(eval $(call symlink_install,JuliaSyntax,$$(JULIASYNTAX_SRC_DIR),$$(BUILDROOT)/base))\n-\n-clean-JuliaSyntax:\n-\t-rm -f $(BUILDDIR)/$(JULIASYNTAX_SRC_DIR)/build-compiled\n-get-JuliaSyntax: $(JULIASYNTAX_SRC_FILE)\n-extract-JuliaSyntax: $(BUILDDIR)/$(JULIASYNTAX_SRC_DIR)/source-extracted\n-configure-JuliaSyntax: extract-JuliaSyntax\n-compile-JuliaSyntax: $(BUILDDIR)/$(JULIASYNTAX_SRC_DIR)/build-compiled\n-fastcheck-JuliaSyntax: check-JuliaSyntax\n-check-JuliaSyntax: compile-JuliaSyntax"
    },
    {
      "sha": "94f480c65dcf77a6df0b0c01d9dec73479528b0d",
      "filename": "deps/JuliaSyntax.version",
      "status": "removed",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f5f4c0174ed51de3811da861c0bf01b4e9f10972/deps%2FJuliaSyntax.version",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f5f4c0174ed51de3811da861c0bf01b4e9f10972/deps%2FJuliaSyntax.version",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2FJuliaSyntax.version?ref=f5f4c0174ed51de3811da861c0bf01b4e9f10972",
      "patch": "@@ -1,4 +0,0 @@\n-JULIASYNTAX_BRANCH = main\n-JULIASYNTAX_SHA1 = 99e975a726a82994de3f8e961e6fa8d39aed0d37\n-JULIASYNTAX_GIT_URL := https://github.com/JuliaLang/JuliaSyntax.jl.git\n-JULIASYNTAX_TAR_URL = https://api.github.com/repos/JuliaLang/JuliaSyntax.jl/tarball/$1"
    },
    {
      "sha": "cea1e52c55156ef8ce17e20c6e24728462c859d9",
      "filename": "deps/Makefile",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/deps%2FMakefile",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/deps%2FMakefile",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/deps%2FMakefile?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -36,8 +36,6 @@ BUILDDIR := $(BUILDDIR)$(MAYBE_HOST)\n # prevent installing libs into usr/lib64 on opensuse\n unexport CONFIG_SITE\n \n-DEP_LIBS := JuliaSyntax\n-\n ifeq ($(USE_SYSTEM_LIBBLASTRAMPOLINE), 0)\n DEP_LIBS += blastrampoline\n endif\n@@ -212,7 +210,7 @@ DEP_LIBS_STAGED := $(DEP_LIBS)\n DEP_LIBS_STAGED_ALL := llvm llvm-tools clang llvmunwind unwind libuv pcre \\\n \topenlibm dsfmt blastrampoline openblas lapack gmp mpfr patchelf utf8proc \\\n \tobjconv openssl libssh2 nghttp2 curl libgit2 libwhich zlib zstd p7zip csl \\\n-\tsanitizers libsuitesparse lld libtracyclient ittapi nvtx JuliaSyntax \\\n+\tsanitizers libsuitesparse lld libtracyclient ittapi nvtx \\\n \tterminfo mmtk_julia\n DEP_LIBS_ALL := $(DEP_LIBS_STAGED_ALL)\n \n@@ -297,7 +295,4 @@ include $(SRCDIR)/terminfo.mk\n # MMTk\n include $(SRCDIR)/mmtk_julia.mk\n \n-# vendored Julia libs\n-include $(SRCDIR)/JuliaSyntax.mk\n-\n include $(SRCDIR)/tools/uninstallers.mk"
    },
    {
      "sha": "e7917875e0ef2bf13b569d6868ea98fe35c1cb0c",
      "filename": "sysimage.mk",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/sysimage.mk",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/sysimage.mk",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/sysimage.mk?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -76,9 +76,12 @@ COMPILER_SRCS := $(addprefix $(JULIAHOME)/, \\\n \t\tbase/traits.jl \\\n \t\tbase/tuple.jl)\n COMPILER_SRCS += $(shell find $(JULIAHOME)/Compiler/src -name \\*.jl -and -not -name verifytrim.jl -and -not -name show.jl)\n+# Julia-based compiler frontend is bootstrapped into Base for now\n+COMPILER_FRONTEND_SRCS = $(shell find $(JULIAHOME)/JuliaSyntax/src -name \\*.jl)\n # sort these to remove duplicates\n BASE_SRCS := $(sort $(shell find $(JULIAHOME)/base -name \\*.jl -and -not -name sysimg.jl) \\\n                     $(shell find $(BUILDROOT)/base -name \\*.jl  -and -not -name sysimg.jl)) \\\n+\t\t\t $(COMPILER_FRONTEND_SRCS) \\\n              $(JULIAHOME)/Compiler/src/ssair/show.jl \\\n              $(JULIAHOME)/Compiler/src/verifytrim.jl\n STDLIB_SRCS := $(JULIAHOME)/base/sysimg.jl $(SYSIMG_STDLIBS_SRCS)"
    },
    {
      "sha": "33b74eaf93d3be31385251a67fae2ef745f915c6",
      "filename": "test/Makefile",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/test%2FMakefile",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/test%2FMakefile",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2FMakefile?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -11,7 +11,7 @@ export JULIA_LOAD_PATH := @$(PATHSEP)@stdlib\n unexport JULIA_PROJECT :=\n unexport JULIA_BINDIR :=\n \n-TESTGROUPS = unicode strings compiler Compiler\n+TESTGROUPS = unicode strings compiler Compiler JuliaSyntax JuliaLowering\n TESTS = all default stdlib $(TESTGROUPS) \\\n \t\t$(patsubst $(STDLIBDIR)/%/,%,$(dir $(wildcard $(STDLIBDIR)/*/.))) \\\n \t\t$(filter-out runtests testdefs relocatedepot, \\"
    },
    {
      "sha": "3e315523a40a1407b009141eea265439018a5c8e",
      "filename": "test/choosetests.jl",
      "status": "modified",
      "additions": 18,
      "deletions": 3,
      "changes": 21,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/test%2Fchoosetests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d0f24f24e9b5ce2265b6a58f72142aab2cb5a958/test%2Fchoosetests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fchoosetests.jl?ref=d0f24f24e9b5ce2265b6a58f72142aab2cb5a958",
      "patch": "@@ -30,7 +30,8 @@ const TESTNAMES = [\n         \"reinterpretarray\", \"syntax\", \"corelogging\", \"missing\", \"asyncmap\",\n         \"smallarrayshrink\", \"opaque_closure\", \"filesystem\", \"download\",\n         \"scopedvalues\", \"compileall\", \"rebinding\",\n-        \"faulty_constructor_method_should_not_cause_stack_overflows\"\n+        \"faulty_constructor_method_should_not_cause_stack_overflows\",\n+        \"JuliaSyntax\", \"JuliaLowering\",\n ]\n \n const INTERNET_REQUIRED_LIST = [\n@@ -46,6 +47,12 @@ const INTERNET_REQUIRED_LIST = [\n \n const NETWORK_REQUIRED_LIST = vcat(INTERNET_REQUIRED_LIST, [\"Sockets\"])\n \n+const TOP_LEVEL_PKGS = [\n+    \"Compiler\",\n+    \"JuliaSyntax\",\n+    \"JuliaLowering\",\n+]\n+\n function test_path(test)\n     t = split(test, '/')\n     if t[1] in STDLIBS\n@@ -61,6 +68,12 @@ function test_path(test)\n     elseif t[1] == \"Compiler\"\n         testpath = length(t) >= 2 ? t[2:end] : (\"runtests\",)\n         return joinpath(@__DIR__, \"..\", t[1], \"test\", testpath...)\n+    elseif t[1] == \"JuliaSyntax\"\n+        testpath = length(t) >= 2 ? t[2:end] : (\"runtests_vendored\",)\n+        return joinpath(@__DIR__, \"..\", t[1], \"test\", testpath...)\n+    elseif t[1] == \"JuliaLowering\"\n+        testpath = length(t) >= 2 ? t[2:end] : (\"runtests_vendored\",)\n+        return joinpath(@__DIR__, \"..\", t[1], \"test\", testpath...)\n     else\n         return joinpath(@__DIR__, test)\n     end\n@@ -225,9 +238,11 @@ function choosetests(choices = [])\n     filter!(!in(tests), unhandled)\n     filter!(!in(skip_tests), tests)\n \n+    is_package_test(testname) = testname in STDLIBS || testname in TOP_LEVEL_PKGS\n+\n     new_tests = String[]\n     for test in tests\n-        if test in STDLIBS || test == \"Compiler\"\n+        if is_package_test(test)\n             testfile = test_path(\"$test/testgroups\")\n             if isfile(testfile)\n                 testgroups = readlines(testfile)\n@@ -238,7 +253,7 @@ function choosetests(choices = [])\n             end\n         end\n     end\n-    filter!(x -> (x != \"stdlib\" && !(x in STDLIBS) && x != \"Compiler\") , tests)\n+    filter!(x -> (x != \"stdlib\" && !is_package_test(x)) , tests)\n     append!(tests, new_tests)\n \n     requested_all || explicit_pkg            || filter!(x -> x != \"Pkg\",            tests)"
    }
  ]
}