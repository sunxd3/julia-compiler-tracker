{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59863",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59863/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59863/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59863/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59863",
  "id": 3521020880,
  "node_id": "PR_kwDOABkWpM6uCoBC",
  "number": 59863,
  "title": "loading: Try to clean up extension loading a bit",
  "user": {
    "login": "Keno",
    "id": 1291671,
    "node_id": "MDQ6VXNlcjEyOTE2NzE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1291671?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Keno",
    "html_url": "https://github.com/Keno",
    "followers_url": "https://api.github.com/users/Keno/followers",
    "following_url": "https://api.github.com/users/Keno/following{/other_user}",
    "gists_url": "https://api.github.com/users/Keno/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Keno/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Keno/subscriptions",
    "organizations_url": "https://api.github.com/users/Keno/orgs",
    "repos_url": "https://api.github.com/users/Keno/repos",
    "events_url": "https://api.github.com/users/Keno/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Keno/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 24139877,
      "node_id": "MDU6TGFiZWwyNDEzOTg3Nw==",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/packages",
      "name": "packages",
      "color": "D180FB",
      "default": false,
      "description": "Package management and loading"
    },
    {
      "id": 5811602268,
      "node_id": "LA_kwDOABkWpM8AAAABWmYDXA",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/package%20extensions",
      "name": "package extensions",
      "color": "c5def5",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 1,
  "created_at": "2025-10-16T09:16:23Z",
  "updated_at": "2025-10-23T17:06:50Z",
  "closed_at": "2025-10-23T17:06:48Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59863",
    "html_url": "https://github.com/JuliaLang/julia/pull/59863",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59863.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59863.patch",
    "merged_at": "2025-10-23T17:06:48Z"
  },
  "body": "The loading code is overall a bit messy. I'd like to add some new features to it, but I think before I can sensibly do that, some cleanup is required. This attempts to de-deduplicate the several places where extensions deal with weakdeps. The logic for extension loading weakdeps is present multiple times because we support loading extension:\r\n\r\n1. By looking at the [extensions] section of the currently active Project.toml (for loading extensions of the currently active top level project)\r\n\r\n2. By looking at the [extensions] sub-section of the top-level Manifest.toml (for any extension of a non-toplevel package); and\r\n\r\n3. Like 1, except that rather than the env specifying a toplevel Project.toml, it specifies a directory and we search the second level for a Project.toml.\r\n\r\nThis separation is a sensible resolution to the tradeoff of not wanting to scan all package's `Project.toml`s at load time while also not forcing a `resolve` for changes to the top-level Project.toml.\r\n\r\nUnfortunately, the loading behavior in case 1 currently differs from the loading behavior of case 2 and 3. In case 1, an extension is allowed to load any weakdep, in cases 2/3, it's only allowed to load weakdeps that are also extension triggers. I believe that the missing extra check for this restriction in case 1 is an oversight.\r\n\r\nSo, this refactors all that by adding the check to case 1 and mostly deleting the code for case 3, by just putting the project-file-lookup code inline at the start of case 1.\r\n\r\nAdditionally, I've factored out common queries into utility functions, even when the code itself is simple. The idea is to signal that these are the same data structure even if they appear in different places (Project vs Manifest).\r\n\r\nLastly, this makes the following additional behavior changes that I don't expect to be observable:\r\n\r\nIn case 2, when loading a non-extension-trigger, don't restart the search from scratch. The only case in which I could see this causing an observable behavior difference is if there are multiple versions of the package in the load path and for some reason the highest priority one doesn't have the extension (but then how did you load it in the first place??). However, even in that case, I think the new behavior is better, because it would get the dep of the version that *did* declare the extension.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59863/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59863/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "a3284c5dcc80e1c2958e35608250add1309cdac8",
      "filename": "base/loading.jl",
      "status": "modified",
      "additions": 128,
      "deletions": 123,
      "changes": 251,
      "blob_url": "https://github.com/JuliaLang/julia/blob/34e6520f6a668297948658e28cc05f70ca6d4016/base%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/34e6520f6a668297948658e28cc05f70ca6d4016/base%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Floading.jl?ref=34e6520f6a668297948658e28cc05f70ca6d4016",
      "patch": "@@ -348,11 +348,14 @@ function identify_package_env(where::PkgId, name::String)\n     else\n         for env in load_path()\n             pkgid = manifest_deps_get(env, where, name)\n-            pkgid === nothing && continue # not found--keep looking\n+            # If we didn't find `where` at all, keep looking through the environment stack\n+            pkgid === nothing && continue\n             if pkgid.uuid !== nothing\n-                pkg_env = pkgid, env # found in explicit environment--use it\n+                pkg_env = pkgid, env\n             end\n-            break # found in implicit environment--return \"not found\"\n+            # If we don't have pkgid.uuid, still break here - this is a sentinel that indicates\n+            # that we've found `where` but it did not have the required dependency. We terminate the search.\n+            break\n         end\n         if pkg_env === nothing && is_stdlib(where)\n             # if not found it could be that manifests are from a different julia version/commit\n@@ -698,51 +701,77 @@ function project_deps_get(env::String, name::String)::Union{Nothing,PkgId}\n     return nothing\n end\n \n+function package_get_here(project_file, name::String)\n+    # if `where` matches the project, use [deps] section as manifest, and stop searching\n+    pkg_uuid = explicit_project_deps_get(project_file, name)\n+    pkg_uuid === nothing && return PkgId(name)\n+    return PkgId(pkg_uuid, name)\n+end\n+\n function package_get(project_file, where::PkgId, name::String)\n     proj = project_file_name_uuid(project_file, where.name)\n-    if proj == where\n-        # if `where` matches the project, use [deps] section as manifest, and stop searching\n-        pkg_uuid = explicit_project_deps_get(project_file, name)\n-        return PkgId(pkg_uuid, name)\n-    end\n-    return nothing\n+    proj != where && return nothing\n+    return package_get_here(project_file, name)\n end\n \n-function manifest_deps_get(env::String, where::PkgId, name::String)::Union{Nothing,PkgId}\n-    uuid = where.uuid\n-    @assert uuid !== nothing\n-    project_file = env_project_file(env)\n-    if project_file isa String\n-        pkg = package_get(project_file, where, name)\n-        pkg === nothing || return pkg\n-        d = parsed_toml(project_file)\n-        exts = get(d, \"extensions\", nothing)::Union{Dict{String, Any}, Nothing}\n-        if exts !== nothing\n-            proj = project_file_name_uuid(project_file, where.name)\n-            # Check if `where` is an extension of the project\n-            if where.name in keys(exts) && where.uuid == uuid5(proj.uuid::UUID, where.name)\n-                # Extensions can load weak deps...\n+ext_may_load_weakdep(exts::String, name::String) = exts == name\n+ext_may_load_weakdep(exts::Vector{String}, name::String) = name in exts\n+\n+function package_extension_get(project_file, where::PkgId, name::String)\n+    d = parsed_toml(project_file)\n+    exts = get(d, \"extensions\", nothing)::Union{Dict{String, Any}, Nothing}\n+    if exts !== nothing\n+        proj = project_file_name_uuid(project_file, where.name)\n+        # Check if `where` is an extension of the project\n+        if where.name in keys(exts) && where.uuid == uuid5(proj.uuid::UUID, where.name)\n+            # Extensions can load weak deps if they are an extension trigger\n+            if ext_may_load_weakdep(exts[where.name]::Union{String, Vector{String}}, name)\n                 weakdeps = get(d, \"weakdeps\", nothing)::Union{Dict{String, Any}, Nothing}\n                 if weakdeps !== nothing\n                     wuuid = get(weakdeps, name, nothing)::Union{String, Nothing}\n                     if wuuid !== nothing\n                         return PkgId(UUID(wuuid), name)\n                     end\n                 end\n-                # ... and they can load same deps as the project itself\n-                mby_uuid = explicit_project_deps_get(project_file, name)\n-                mby_uuid === nothing || return PkgId(mby_uuid, name)\n             end\n+            # ... and they can load same deps as the project itself\n+            return package_get_here(project_file, name)\n         end\n-        # look for manifest file and `where` stanza\n-        return explicit_manifest_deps_get(project_file, where, name)\n-    elseif project_file\n-        # if env names a directory, search it\n-        return implicit_manifest_deps_get(env, where, name)\n     end\n     return nothing\n end\n \n+function manifest_deps_get(env::String, where::PkgId, name::String)::Union{Nothing,PkgId}\n+    @assert where.uuid !== nothing\n+    project_file = env_project_file(env)\n+    implicit_manifest = !(project_file isa String)\n+    if implicit_manifest\n+        project_file || return nothing\n+        project_file = implicit_manifest_project(env, where)\n+        project_file === nothing && return nothing\n+    end\n+\n+    # 1. Are we loading into the top-level project itself? dependencies come from [deps]\n+    #    N.B.: Here \"top-level\" includes package loaded from an implicit manifest, which\n+    #          uses the same code path.\n+    pkg = package_get(project_file, where, name)\n+    pkg === nothing || return pkg\n+\n+    # 2. Are we an extension of the top-level project? dependencies come from [weakdeps] and [deps]\n+    pkg = package_extension_get(project_file, where, name)\n+    pkg === nothing || return pkg\n+\n+    if implicit_manifest\n+        # With an implicit manifest, getting here means that our (implicit) environment\n+        # *has* the package `where`. If we don't find it, it just means that `where` doesn't\n+        # have `name` as a dependency - c.f. the analogous case in `explicit_manifest_deps_get`.\n+        return PkgId(name)\n+    end\n+\n+    # All other cases, dependencies come from the (top-level) manifest\n+    return explicit_manifest_deps_get(project_file, where, name)\n+end\n+\n function manifest_uuid_path(env::String, pkg::PkgId)::Union{Nothing,String,Missing}\n     project_file = env_project_file(env)\n     if project_file isa String\n@@ -913,7 +942,7 @@ end\n # find project file root or deps `name => uuid` mapping\n # `ext` is the name of the extension if `name` is loaded from one\n # return `nothing` if `name` is not found\n-function explicit_project_deps_get(project_file::String, name::String, ext::Union{String,Nothing}=nothing)::Union{Nothing,UUID}\n+function explicit_project_deps_get(project_file::String, name::String)::Union{Nothing,UUID}\n     d = parsed_toml(project_file)\n     if get(d, \"name\", nothing)::Union{String, Nothing} === name\n         root_uuid = dummy_uuid(project_file)\n@@ -925,19 +954,6 @@ function explicit_project_deps_get(project_file::String, name::String, ext::Unio\n         uuid = get(deps, name, nothing)::Union{String, Nothing}\n         uuid === nothing || return UUID(uuid)\n     end\n-    if ext !== nothing\n-        extensions = get(d, \"extensions\", nothing)\n-        extensions === nothing && return nothing\n-        ext_data = get(extensions, ext, nothing)\n-        ext_data === nothing && return nothing\n-        if (ext_data isa String && name == ext_data) || (ext_data isa Vector{String} && name in ext_data)\n-            weakdeps = get(d, \"weakdeps\", nothing)::Union{Dict{String, Any}, Nothing}\n-            weakdeps === nothing && return nothing\n-            wuuid = get(weakdeps, name, nothing)::Union{String, Nothing}\n-            wuuid === nothing && return nothing\n-            return UUID(wuuid)\n-        end\n-    end\n     return nothing\n end\n \n@@ -964,14 +980,27 @@ function get_deps(raw_manifest::Dict)\n     end\n end\n \n-# find `where` stanza and return the PkgId for `name`\n-# return `nothing` if it did not find `where` (indicating caller should continue searching)\n+function dep_stanza_get(stanza::Dict{String, Any}, name::String)::Union{Nothing, PkgId}\n+    for (dep, uuid) in stanza\n+        uuid::String\n+        if dep === name\n+            return PkgId(UUID(uuid), name)\n+        end\n+    end\n+    return nothing\n+end\n+\n+function dep_stanza_get(stanza::Vector{String}, name::String)::Union{Nothing, PkgId}\n+    name in stanza && return PkgId(name)\n+    return nothing\n+end\n+\n+dep_stanza_get(stanza::Nothing, name::String) = nothing\n+\n function explicit_manifest_deps_get(project_file::String, where::PkgId, name::String)::Union{Nothing,PkgId}\n     manifest_file = project_file_manifest_path(project_file)\n     manifest_file === nothing && return nothing # manifest not found--keep searching LOAD_PATH\n     d = get_deps(parsed_toml(manifest_file))\n-    found_where = false\n-    found_name = false\n     for (dep_name, entries) in d\n         entries::Vector{Any}\n         for entry in entries\n@@ -981,67 +1010,62 @@ function explicit_manifest_deps_get(project_file::String, where::PkgId, name::St\n             # deps is either a list of names (deps = [\"DepA\", \"DepB\"]) or\n             # a table of entries (deps = {\"DepA\" = \"6ea...\", \"DepB\" = \"55d...\"}\n             deps = get(entry, \"deps\", nothing)::Union{Vector{String}, Dict{String, Any}, Nothing}\n+            local dep::Union{Nothing, PkgId}\n             if UUID(uuid) === where.uuid\n-                found_where = true\n-                if deps isa Vector{String}\n-                    found_name = name in deps\n-                    found_name && @goto done\n-                elseif deps isa Dict{String, Any}\n-                    deps = deps::Dict{String, Any}\n-                    for (dep, uuid) in deps\n-                        uuid::String\n-                        if dep === name\n-                            return PkgId(UUID(uuid), name)\n-                        end\n-                    end\n-                end\n-            else # Check for extensions\n+                dep = dep_stanza_get(deps, name)\n+\n+                # We found `where` in this environment, but it did not have a deps entry for\n+                # `name`. This is likely because the dependency was modified without a corresponding\n+                # change to dependency's Project or our Manifest. Return a sentinel here indicating\n+                # that we know the package, but do not know its UUID. The caller will terminate the\n+                # search and provide an appropriate error to the user.\n+                dep === nothing && return PkgId(name)\n+            else\n+                # Check if we're trying to load into an extension of this package\n                 extensions = get(entry, \"extensions\", nothing)\n                 if extensions !== nothing\n                     if haskey(extensions, where.name) && where.uuid == uuid5(UUID(uuid), where.name)\n-                        found_where = true\n                         if name == dep_name\n+                            # Extension loads its base package\n                             return PkgId(UUID(uuid), name)\n                         end\n                         exts = extensions[where.name]::Union{String, Vector{String}}\n-                        weakdeps = get(entry, \"weakdeps\", nothing)::Union{Vector{String}, Dict{String, Any}, Nothing}\n-                        if (exts isa String && name == exts) || (exts isa Vector{String} && name in exts)\n-                            for deps\u2032 in [weakdeps, deps]\n-                                    if deps\u2032 !== nothing\n-                                        if deps\u2032 isa Vector{String}\n-                                            found_name = name in deps\u2032\n-                                            found_name && @goto done\n-                                        elseif deps\u2032 isa Dict{String, Any}\n-                                            deps\u2032 = deps\u2032::Dict{String, Any}\n-                                            for (dep, uuid) in deps\u2032\n-                                                uuid::String\n-                                                if dep === name\n-                                                    return PkgId(UUID(uuid), name)\n-                                                end\n-                                            end\n-                                        end\n-                                    end\n-                                end\n-                            end\n-                        # `name` is not an ext, do standard lookup as if this was the parent\n-                        return identify_package(PkgId(UUID(uuid), dep_name), name)\n+                        # Extensions are allowed to load:\n+                        # 1. Any ordinary dep of the parent package\n+                        # 2. Any weakdep of the parent package declared as an extension trigger\n+                        for deps\u2032 in (ext_may_load_weakdep(exts, name) ?\n+                                (get(entry, \"weakdeps\", nothing)::Union{Vector{String}, Dict{String, Any}, Nothing}, deps) :\n+                                (deps,))\n+                            dep = dep_stanza_get(deps\u2032, name)\n+                            dep === nothing && continue\n+                            @goto have_dep\n+                        end\n+                        return PkgId(name)\n                     end\n                 end\n+                continue\n             end\n+\n+            @label have_dep\n+            dep.uuid !== nothing && return dep\n+\n+            # We have the dep, but it did not specify a UUID. In this case,\n+            # it must be that the name is unique in the manifest - so lookup\n+            # the UUID at the lop level by name\n+            name_deps = get(d, name, nothing)::Union{Nothing, Vector{Any}}\n+            if name_deps === nothing || length(name_deps) != 1\n+                error(\"expected a single entry for $(repr(name)) in $(repr(project_file))\")\n+            end\n+            entry = first(name_deps::Vector{Any})::Dict{String, Any}\n+            uuid = get(entry, \"uuid\", nothing)::Union{String, Nothing}\n+            uuid === nothing && return PkgId(name)\n+            return PkgId(UUID(uuid), name)\n         end\n     end\n-    @label done\n-    found_where || return nothing\n-    found_name || return PkgId(name)\n-    # Only reach here if deps was not a dict which mean we have a unique name for the dep\n-    name_deps = get(d, name, nothing)::Union{Nothing, Vector{Any}}\n-    if name_deps === nothing || length(name_deps) != 1\n-        error(\"expected a single entry for $(repr(name)) in $(repr(project_file))\")\n-    end\n-    entry = first(name_deps::Vector{Any})::Dict{String, Any}\n-    uuid = get(entry, \"uuid\", nothing)::Union{String, Nothing}\n-    uuid === nothing && return nothing\n-    return PkgId(UUID(uuid), name)\n+\n+    # We did not find `where` in this environment, either as a package or as an extension.\n+    # The caller should continue searching the environment stack.\n+    return nothing\n end\n \n # find `uuid` stanza, return the corresponding path\n@@ -1124,35 +1148,16 @@ function implicit_project_deps_get(dir::String, name::String)::Union{Nothing,Pkg\n     return proj\n end\n \n-# look for an entry-point for `name`, check that UUID matches\n-# if there's a project file, look up `name` in its deps and return that\n-# otherwise return `nothing` to indicate the caller should keep searching\n-function implicit_manifest_deps_get(dir::String, where::PkgId, name::String)::Union{Nothing,PkgId}\n-    @assert where.uuid !== nothing\n-    project_file = entry_point_and_project_file(dir, where.name)[2]\n+function implicit_manifest_project(dir, pkg::PkgId)::Union{Nothing, String}\n+    @assert pkg.uuid !== nothing\n+    project_file = entry_point_and_project_file(dir, pkg.name)[2]\n     if project_file === nothing\n         # `where` could be an extension\n-        project_file = implicit_env_project_file_extension(dir, where)[2]\n-        project_file === nothing && return nothing\n-    end\n-    proj = project_file_name_uuid(project_file, where.name)\n-    ext = nothing\n-    if proj !== where\n-        # `where` could be an extension in `proj`\n-        d = parsed_toml(project_file)\n-        exts = get(d, \"extensions\", nothing)::Union{Dict{String, Any}, Nothing}\n-        if exts !== nothing && where.name in keys(exts)\n-            if where.uuid !== uuid5(proj.uuid, where.name)\n-                return nothing\n-            end\n-            ext = where.name\n-        else\n-            return nothing\n-        end\n+        return implicit_env_project_file_extension(dir, pkg)[2]\n     end\n-    # this is the correct project, so stop searching here\n-    pkg_uuid = explicit_project_deps_get(project_file, name, ext)\n-    return PkgId(pkg_uuid, name)\n+    proj = project_file_name_uuid(project_file, pkg.name)\n+    proj == pkg || return nothing\n+    return project_file\n end\n \n # look for an entry-point for `pkg` and return its path if UUID matches"
    },
    {
      "sha": "7828d664a31864168af4efee8fce37c2b4f8e658",
      "filename": "test/loading.jl",
      "status": "modified",
      "additions": 21,
      "deletions": 16,
      "changes": 37,
      "blob_url": "https://github.com/JuliaLang/julia/blob/34e6520f6a668297948658e28cc05f70ca6d4016/test%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/34e6520f6a668297948658e28cc05f70ca6d4016/test%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Floading.jl?ref=34e6520f6a668297948658e28cc05f70ca6d4016",
      "patch": "@@ -463,7 +463,7 @@ function make_env(flat, root, roots, graph, paths, dummies)\n end\n \n const depots = [mkdepottempdir() for _ = 1:3]\n-const envs = Dict{String,Any}()\n+const envs = Pair{String, Any}[]\n \n append!(empty!(DEPOT_PATH), depots)\n \n@@ -557,7 +557,7 @@ for (flat, root, roots, graph) in graphs\n         end\n     end\n \n-    envs[dir] = make_env(flat, root, roots, graph, paths, dummies)\n+    push!(envs, dir => make_env(flat, root, roots, graph, paths, dummies))\n end\n \n # materialize dependency graphs as implicit environments (if possible)\n@@ -590,7 +590,7 @@ for (flat, root, roots, graph) in graphs\n         end\n     end\n \n-    envs[dir] = make_env(flat, root, roots, graph, paths, dummies)\n+    push!(envs, dir => make_env(flat, root, roots, graph, paths, dummies))\n end\n \n ## use generated environments to test package loading ##\n@@ -612,10 +612,12 @@ function test_find(\n         where.uuid === nothing && continue\n         deps = get(graph, where, Dict(where.name => where))\n         for name in NAMES\n-            id = identify_package(where, name)\n-            @test id == get(deps, name, nothing)\n-            path = id === nothing ? nothing : locate_package(id)\n-            @test path == get(paths, id, nothing)\n+            @testset let where=where, name=name\n+                id = identify_package(where, name)\n+                @test id == get(deps, name, nothing)\n+                path = id === nothing ? nothing : locate_package(id)\n+                @test path == get(paths, id, nothing)\n+            end\n         end\n     end\n end\n@@ -628,14 +630,17 @@ end\n end\n \n @testset \"find_package with two envs in load path\" begin\n-    for x = false:true,\n-        (env1, (_, _, roots1, graph1, paths1)) in (x ? envs : rand(envs, 10)),\n-        (env2, (_, _, roots2, graph2, paths2)) in (x ? rand(envs, 10) : envs)\n-        push!(empty!(LOAD_PATH), env1, env2)\n-        roots = merge(roots2, roots1)\n-        graph = merge(graph2, graph1)\n-        paths = merge(paths2, paths1)\n-        test_find(roots, graph, paths)\n+    for x = false:true, env1idx in (x ? (1:length(envs)) : rand(1:length(envs), 10)),\n+                        env2idx in (x ? rand(1:length(envs), 10) : (1:length(envs)))\n+        @testset let env1idx=env1idx, env2idx=env2idx\n+            (env1, (_, _, roots1, graph1, paths1)) = envs[env1idx]\n+            (env2, (_, _, roots2, graph2, paths2)) = envs[env2idx]\n+            push!(empty!(LOAD_PATH), env1, env2)\n+            roots = merge(roots2, roots1)\n+            graph = merge(graph2, graph1)\n+            paths = merge(paths2, paths1)\n+            test_find(roots, graph, paths)\n+        end\n     end\n end\n \n@@ -753,7 +758,7 @@ end\n \n ## cleanup after tests ##\n \n-for env in keys(envs)\n+for (env, _) in envs\n     rm(env, force=true, recursive=true)\n end\n "
    }
  ]
}