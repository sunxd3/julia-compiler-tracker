{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60230",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60230/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60230/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60230/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60230",
  "id": 3660727943,
  "node_id": "PR_kwDOABkWpM61S-WB",
  "number": 60230,
  "title": "Fix aarch64 macOS crash when SIP disabled (re-land JLJITLinkMemoryManager/#60105)",
  "user": {
    "login": "xal-0",
    "id": 33556084,
    "node_id": "MDQ6VXNlcjMzNTU2MDg0",
    "avatar_url": "https://avatars.githubusercontent.com/u/33556084?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/xal-0",
    "html_url": "https://github.com/xal-0",
    "followers_url": "https://api.github.com/users/xal-0/followers",
    "following_url": "https://api.github.com/users/xal-0/following{/other_user}",
    "gists_url": "https://api.github.com/users/xal-0/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/xal-0/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/xal-0/subscriptions",
    "organizations_url": "https://api.github.com/users/xal-0/orgs",
    "repos_url": "https://api.github.com/users/xal-0/repos",
    "events_url": "https://api.github.com/users/xal-0/events{/privacy}",
    "received_events_url": "https://api.github.com/users/xal-0/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4447356586,
      "node_id": "LA_kwDOABkWpM8AAAABCRVGqg",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/re-land",
      "name": "re-land",
      "color": "00CCE0",
      "default": false,
      "description": "This relands a PR that was previously merged but was later reverted."
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 5,
  "created_at": "2025-11-24T22:20:01Z",
  "updated_at": "2025-11-25T17:49:31Z",
  "closed_at": "2025-11-25T04:21:54Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60230",
    "html_url": "https://github.com/JuliaLang/julia/pull/60230",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60230.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60230.patch",
    "merged_at": "2025-11-25T04:21:54Z"
  },
  "body": "Apple ARM CPUs treat the `ic ivau` as a memory read, which causes a confusing crash in DualMapAllocator if we try using it on a `wr_addr` that has been mprotected to `Prot::NO`, since we are still holding the allocator lock.\r\n\r\nFor Apple aarch64 systems with SIP disabled, this will result in some memory savings, since DualMapAllocator will now work there.  Like before, other JITLink platforms, namely Linux aarch64 and RISC-V, will benefit too.\r\n\r\nThis re-lands #60105, after it was reverted in #60196.  Thanks @giordano!",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60230/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 1,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60230/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "d3f0be0ec4cbfbc6409a7e04417ea799a773dba7",
      "filename": "src/cgmemmgr.cpp",
      "status": "modified",
      "additions": 193,
      "deletions": 53,
      "changes": 246,
      "blob_url": "https://github.com/JuliaLang/julia/blob/068186c191fc3d0ba7a1cf54ee36ae4ff55c1c08/src%2Fcgmemmgr.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/068186c191fc3d0ba7a1cf54ee36ae4ff55c1c08/src%2Fcgmemmgr.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcgmemmgr.cpp?ref=068186c191fc3d0ba7a1cf54ee36ae4ff55c1c08",
      "patch": "@@ -3,7 +3,11 @@\n #include \"llvm-version.h\"\n #include \"platform.h\"\n \n+#include <llvm/ExecutionEngine/JITLink/JITLink.h>\n+#include <llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h>\n+#include <llvm/ExecutionEngine/Orc/MapperJITLinkMemoryManager.h>\n #include <llvm/ExecutionEngine/SectionMemoryManager.h>\n+\n #include \"julia.h\"\n #include \"julia_internal.h\"\n \n@@ -460,26 +464,36 @@ struct Block {\n     }\n };\n \n+struct Allocation {\n+    // Address to write to (the one returned by the allocation function)\n+    void *wr_addr;\n+    // Runtime address\n+    void *rt_addr;\n+    size_t sz;\n+    bool relocated;\n+};\n+\n class RWAllocator {\n     static constexpr int nblocks = 8;\n     Block blocks[nblocks]{};\n public:\n     RWAllocator() JL_NOTSAFEPOINT = default;\n-    void *alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n+    Allocation alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n     {\n         size_t min_size = (size_t)-1;\n         int min_id = 0;\n         for (int i = 0;i < nblocks && blocks[i].ptr;i++) {\n             if (void *ptr = blocks[i].alloc(size, align))\n-                return ptr;\n+                return {ptr, ptr, size, false};\n             if (blocks[i].avail < min_size) {\n                 min_size = blocks[i].avail;\n                 min_id = i;\n             }\n         }\n         size_t block_size = get_block_size(size);\n         blocks[min_id].reset(map_anon_page(block_size), block_size);\n-        return blocks[min_id].alloc(size, align);\n+        void *ptr = blocks[min_id].alloc(size, align);\n+        return {ptr, ptr, size, false};\n     }\n };\n \n@@ -519,16 +533,6 @@ struct SplitPtrBlock : public Block {\n     }\n };\n \n-struct Allocation {\n-    // Address to write to (the one returned by the allocation function)\n-    void *wr_addr;\n-    // Runtime address\n-    void *rt_addr;\n-    size_t sz;\n-    bool relocated;\n-};\n-\n-template<bool exec>\n class ROAllocator {\n protected:\n     static constexpr int nblocks = 8;\n@@ -544,19 +548,18 @@ class ROAllocator {\n     virtual ~ROAllocator() JL_NOTSAFEPOINT {}\n     virtual void finalize() JL_NOTSAFEPOINT\n     {\n-        for (auto &alloc: allocations) {\n-            // ensure the mapped pages are consistent\n-            sys::Memory::InvalidateInstructionCache(alloc.wr_addr,\n-                                                    alloc.sz);\n-            sys::Memory::InvalidateInstructionCache(alloc.rt_addr,\n-                                                    alloc.sz);\n-        }\n+        // Note: on some aarch64 platforms, like Apple CPUs, we need read\n+        // permission in order to invalidate instruction cache lines.  We are\n+        // not guaranteed to have read permission on the wr_addr when using\n+        // DualMapAllocator.\n+        for (auto &alloc : allocations)\n+            sys::Memory::InvalidateInstructionCache(alloc.rt_addr, alloc.sz);\n         completed.clear();\n         allocations.clear();\n     }\n     // Allocations that have not been finalized yet.\n     SmallVector<Allocation, 16> allocations;\n-    void *alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n+    Allocation alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n     {\n         size_t min_size = (size_t)-1;\n         int min_id = 0;\n@@ -572,8 +575,9 @@ class ROAllocator {\n                     wr_ptr = get_wr_ptr(block, ptr, size, align);\n                 }\n                 block.state |= SplitPtrBlock::Alloc;\n-                allocations.push_back(Allocation{wr_ptr, ptr, size, false});\n-                return wr_ptr;\n+                Allocation a{wr_ptr, ptr, size, false};\n+                allocations.push_back(a);\n+                return a;\n             }\n             if (block.avail < min_size) {\n                 min_size = block.avail;\n@@ -594,18 +598,21 @@ class ROAllocator {\n #ifdef _OS_WINDOWS_\n         block.state = SplitPtrBlock::Alloc;\n         void *wr_ptr = get_wr_ptr(block, ptr, size, align);\n-        allocations.push_back(Allocation{wr_ptr, ptr, size, false});\n+        Allocation a{wr_ptr, ptr, size, false};\n+        allocations.push_back(a);\n         ptr = wr_ptr;\n #else\n         block.state = SplitPtrBlock::Alloc | SplitPtrBlock::InitAlloc;\n-        allocations.push_back(Allocation{ptr, ptr, size, false});\n+        Allocation a{ptr, ptr, size, false};\n+        allocations.push_back(a);\n #endif\n-        return ptr;\n+        return a;\n     }\n };\n \n-template<bool exec>\n-class DualMapAllocator : public ROAllocator<exec> {\n+class DualMapAllocator : public ROAllocator {\n+    bool exec;\n+\n protected:\n     void *get_wr_ptr(SplitPtrBlock &block, void *rt_ptr, size_t, size_t) override JL_NOTSAFEPOINT\n     {\n@@ -666,7 +673,7 @@ class DualMapAllocator : public ROAllocator<exec> {\n         }\n     }\n public:\n-    DualMapAllocator() JL_NOTSAFEPOINT\n+    DualMapAllocator(bool exec) JL_NOTSAFEPOINT : exec(exec)\n     {\n         assert(anon_hdl != -1);\n     }\n@@ -679,13 +686,13 @@ class DualMapAllocator : public ROAllocator<exec> {\n             finalize_block(block, true);\n             block.reset(nullptr, 0);\n         }\n-        ROAllocator<exec>::finalize();\n+        ROAllocator::finalize();\n     }\n };\n \n #ifdef _OS_LINUX_\n-template<bool exec>\n-class SelfMemAllocator : public ROAllocator<exec> {\n+class SelfMemAllocator : public ROAllocator {\n+    bool exec;\n     SmallVector<Block, 16> temp_buff;\n protected:\n     void *get_wr_ptr(SplitPtrBlock &block, void *rt_ptr,\n@@ -722,9 +729,7 @@ class SelfMemAllocator : public ROAllocator<exec> {\n         }\n     }\n public:\n-    SelfMemAllocator() JL_NOTSAFEPOINT\n-        : ROAllocator<exec>(),\n-          temp_buff()\n+    SelfMemAllocator(bool exec) JL_NOTSAFEPOINT : exec(exec), temp_buff()\n     {\n         assert(get_self_mem_fd() != -1);\n     }\n@@ -758,11 +763,25 @@ class SelfMemAllocator : public ROAllocator<exec> {\n         }\n         if (cached)\n             temp_buff.resize(1);\n-        ROAllocator<exec>::finalize();\n+        ROAllocator::finalize();\n     }\n };\n #endif // _OS_LINUX_\n \n+std::pair<std::unique_ptr<ROAllocator>, std::unique_ptr<ROAllocator>>\n+get_preferred_allocators() JL_NOTSAFEPOINT\n+{\n+#ifdef _OS_LINUX_\n+    if (get_self_mem_fd() != -1)\n+        return {std::make_unique<SelfMemAllocator>(false),\n+                std::make_unique<SelfMemAllocator>(true)};\n+#endif\n+    if (init_shared_map() != -1)\n+        return {std::make_unique<DualMapAllocator>(false),\n+                std::make_unique<DualMapAllocator>(true)};\n+    return {};\n+}\n+\n class RTDyldMemoryManagerJL : public SectionMemoryManager {\n     struct EHFrame {\n         uint8_t *addr;\n@@ -772,29 +791,18 @@ class RTDyldMemoryManagerJL : public SectionMemoryManager {\n     void operator=(const RTDyldMemoryManagerJL&) = delete;\n     SmallVector<EHFrame, 16> pending_eh;\n     RWAllocator rw_alloc;\n-    std::unique_ptr<ROAllocator<false>> ro_alloc;\n-    std::unique_ptr<ROAllocator<true>> exe_alloc;\n+    std::unique_ptr<ROAllocator> ro_alloc;\n+    std::unique_ptr<ROAllocator> exe_alloc;\n     size_t total_allocated;\n \n public:\n     RTDyldMemoryManagerJL() JL_NOTSAFEPOINT\n         : SectionMemoryManager(),\n           pending_eh(),\n           rw_alloc(),\n-          ro_alloc(),\n-          exe_alloc(),\n           total_allocated(0)\n     {\n-#ifdef _OS_LINUX_\n-        if (!ro_alloc && get_self_mem_fd() != -1) {\n-            ro_alloc.reset(new SelfMemAllocator<false>());\n-            exe_alloc.reset(new SelfMemAllocator<true>());\n-        }\n-#endif\n-        if (!ro_alloc && init_shared_map() != -1) {\n-            ro_alloc.reset(new DualMapAllocator<false>());\n-            exe_alloc.reset(new DualMapAllocator<true>());\n-        }\n+        std::tie(ro_alloc, exe_alloc) = get_preferred_allocators();\n     }\n     ~RTDyldMemoryManagerJL() override JL_NOTSAFEPOINT\n     {\n@@ -847,7 +855,7 @@ uint8_t *RTDyldMemoryManagerJL::allocateCodeSection(uintptr_t Size,\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITSize, Size);\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITCodeSize, Size);\n     if (exe_alloc)\n-        return (uint8_t*)exe_alloc->alloc(Size, Alignment);\n+        return (uint8_t*)exe_alloc->alloc(Size, Alignment).wr_addr;\n     return SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID,\n                                                      SectionName);\n }\n@@ -862,9 +870,9 @@ uint8_t *RTDyldMemoryManagerJL::allocateDataSection(uintptr_t Size,\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITSize, Size);\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITDataSize, Size);\n     if (!isReadOnly)\n-        return (uint8_t*)rw_alloc.alloc(Size, Alignment);\n+        return (uint8_t*)rw_alloc.alloc(Size, Alignment).wr_addr;\n     if (ro_alloc)\n-        return (uint8_t*)ro_alloc->alloc(Size, Alignment);\n+        return (uint8_t*)ro_alloc->alloc(Size, Alignment).wr_addr;\n     return SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID,\n                                                      SectionName, isReadOnly);\n }\n@@ -919,6 +927,133 @@ void RTDyldMemoryManagerJL::deregisterEHFrames(uint8_t *Addr,\n }\n #endif\n \n+class JLJITLinkMemoryManager : public jitlink::JITLinkMemoryManager {\n+    using OnFinalizedFunction =\n+        jitlink::JITLinkMemoryManager::InFlightAlloc::OnFinalizedFunction;\n+\n+    std::mutex Mutex;\n+    RWAllocator RWAlloc;\n+    std::unique_ptr<ROAllocator> ROAlloc;\n+    std::unique_ptr<ROAllocator> ExeAlloc;\n+    SmallVector<OnFinalizedFunction> FinalizedCallbacks;\n+    uint32_t InFlight{0};\n+\n+public:\n+    class InFlightAlloc;\n+\n+    static std::unique_ptr<JITLinkMemoryManager> Create()\n+    {\n+        auto [ROAlloc, ExeAlloc] = get_preferred_allocators();\n+        if (ROAlloc && ExeAlloc)\n+            return std::unique_ptr<JLJITLinkMemoryManager>(\n+                new JLJITLinkMemoryManager(std::move(ROAlloc), std::move(ExeAlloc)));\n+\n+        return cantFail(\n+            orc::MapperJITLinkMemoryManager::CreateWithMapper<orc::InProcessMemoryMapper>(\n+                /*Reservation Granularity*/ 16 * 1024 * 1024));\n+    }\n+\n+    void allocate(const jitlink::JITLinkDylib *JD, jitlink::LinkGraph &G,\n+                  OnAllocatedFunction OnAllocated) override;\n+\n+    void deallocate(std::vector<FinalizedAlloc> Allocs,\n+                    OnDeallocatedFunction OnDeallocated) override\n+    {\n+        jl_unreachable();\n+    }\n+\n+protected:\n+    JLJITLinkMemoryManager(std::unique_ptr<ROAllocator> ROAlloc,\n+                           std::unique_ptr<ROAllocator> ExeAlloc)\n+      : ROAlloc(std::move(ROAlloc)), ExeAlloc(std::move(ExeAlloc))\n+    {\n+    }\n+\n+    void finalize(OnFinalizedFunction OnFinalized)\n+    {\n+        SmallVector<OnFinalizedFunction> Callbacks;\n+        {\n+            std::unique_lock Lock{Mutex};\n+            FinalizedCallbacks.push_back(std::move(OnFinalized));\n+\n+            if (--InFlight > 0)\n+                return;\n+\n+            ROAlloc->finalize();\n+            ExeAlloc->finalize();\n+            Callbacks = std::move(FinalizedCallbacks);\n+        }\n+\n+        for (auto &CB : Callbacks)\n+            std::move(CB)(FinalizedAlloc{});\n+    }\n+};\n+\n+class JLJITLinkMemoryManager::InFlightAlloc\n+  : public jitlink::JITLinkMemoryManager::InFlightAlloc {\n+    JLJITLinkMemoryManager &MM;\n+    jitlink::LinkGraph &G;\n+\n+public:\n+    InFlightAlloc(JLJITLinkMemoryManager &MM, jitlink::LinkGraph &G) : MM(MM), G(G) {}\n+\n+    void abandon(OnAbandonedFunction OnAbandoned) override { jl_unreachable(); }\n+\n+    void finalize(OnFinalizedFunction OnFinalized) override\n+    {\n+        auto *GP = &G;\n+        MM.finalize([GP, OnFinalized =\n+                             std::move(OnFinalized)](Expected<FinalizedAlloc> FA) mutable {\n+            if (!FA)\n+                return OnFinalized(FA.takeError());\n+            // Need to handle dealloc actions when we GC code\n+            auto E = orc::shared::runFinalizeActions(GP->allocActions());\n+            if (!E)\n+                return OnFinalized(E.takeError());\n+            OnFinalized(std::move(FA));\n+        });\n+    }\n+};\n+\n+using orc::MemProt;\n+\n+void JLJITLinkMemoryManager::allocate(const jitlink::JITLinkDylib *JD,\n+                                      jitlink::LinkGraph &G,\n+                                      OnAllocatedFunction OnAllocated)\n+{\n+    jitlink::BasicLayout BL{G};\n+\n+    {\n+        std::unique_lock Lock{Mutex};\n+        for (auto &[AG, Seg] : BL.segments()) {\n+            if (AG.getMemLifetime() == orc::MemLifetime::NoAlloc)\n+                continue;\n+            assert(AG.getMemLifetime() == orc::MemLifetime::Standard);\n+\n+            auto Prot = AG.getMemProt();\n+            uint64_t Alignment = Seg.Alignment.value();\n+            uint64_t Size = Seg.ContentSize + Seg.ZeroFillSize;\n+            Allocation Alloc;\n+            if (Prot == (MemProt::Read | MemProt::Write))\n+                Alloc = RWAlloc.alloc(Size, Alignment);\n+            else if (Prot == MemProt::Read)\n+                Alloc = ROAlloc->alloc(Size, Alignment);\n+            else if (Prot == (MemProt::Read | MemProt::Exec))\n+                Alloc = ExeAlloc->alloc(Size, Alignment);\n+            else\n+                abort();\n+\n+            Seg.Addr = orc::ExecutorAddr::fromPtr(Alloc.rt_addr);\n+            Seg.WorkingMem = (char *)Alloc.wr_addr;\n+        }\n+    }\n+\n+    if (auto Err = BL.apply())\n+        return OnAllocated(std::move(Err));\n+\n+    ++InFlight;\n+    OnAllocated(std::make_unique<InFlightAlloc>(*this, G));\n+}\n }\n \n RTDyldMemoryManager* createRTDyldMemoryManager() JL_NOTSAFEPOINT\n@@ -930,3 +1065,8 @@ size_t getRTDyldMemoryManagerTotalBytes(RTDyldMemoryManager *mm) JL_NOTSAFEPOINT\n {\n     return ((RTDyldMemoryManagerJL*)mm)->getTotalBytes();\n }\n+\n+std::unique_ptr<jitlink::JITLinkMemoryManager> createJITLinkMemoryManager()\n+{\n+    return JLJITLinkMemoryManager::Create();\n+}"
    },
    {
      "sha": "90091cc1f38dbbbb2f30cef8e709fdf5e74a68d8",
      "filename": "src/jitlayers.cpp",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/068186c191fc3d0ba7a1cf54ee36ae4ff55c1c08/src%2Fjitlayers.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/068186c191fc3d0ba7a1cf54ee36ae4ff55c1c08/src%2Fjitlayers.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjitlayers.cpp?ref=068186c191fc3d0ba7a1cf54ee36ae4ff55c1c08",
      "patch": "@@ -1208,12 +1208,6 @@ class JLMemoryUsagePlugin : public ObjectLinkingLayer::Plugin {\n #pragma clang diagnostic ignored \"-Wunused-function\"\n #endif\n \n-// TODO: Port our memory management optimisations to JITLink instead of using the\n-// default InProcessMemoryManager.\n-std::unique_ptr<jitlink::JITLinkMemoryManager> createJITLinkMemoryManager() JL_NOTSAFEPOINT {\n-    return cantFail(orc::MapperJITLinkMemoryManager::CreateWithMapper<orc::InProcessMemoryMapper>(/*Reservation Granularity*/ 16 * 1024 * 1024));\n-}\n-\n #ifdef _COMPILER_CLANG_\n #pragma clang diagnostic pop\n #endif\n@@ -1237,6 +1231,7 @@ class JLEHFrameRegistrar final : public jitlink::EHFrameRegistrar {\n };\n \n RTDyldMemoryManager *createRTDyldMemoryManager(void) JL_NOTSAFEPOINT;\n+std::unique_ptr<jitlink::JITLinkMemoryManager> createJITLinkMemoryManager() JL_NOTSAFEPOINT;\n \n // A simple forwarding class, since OrcJIT v2 needs a unique_ptr, while we have a shared_ptr\n class ForwardingMemoryManager : public RuntimeDyld::MemoryManager {"
    }
  ]
}