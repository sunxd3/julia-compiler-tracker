{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59840",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59840/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59840/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59840/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59840",
  "id": 3514635561,
  "node_id": "PR_kwDOABkWpM6ttKiR",
  "number": 59840,
  "title": "signals: acquire loader lock during stackwalk on Win32",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 5669611,
      "node_id": "MDU6TGFiZWw1NjY5NjEx",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/system:windows",
      "name": "system:windows",
      "color": "0b02e1",
      "default": false,
      "description": "Affects only Windows"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 4,
  "created_at": "2025-10-14T16:19:21Z",
  "updated_at": "2025-10-15T14:03:42Z",
  "closed_at": "2025-10-15T14:03:39Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59840",
    "html_url": "https://github.com/JuliaLang/julia/pull/59840",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59840.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59840.patch",
    "merged_at": "2025-10-15T14:03:39Z"
  },
  "body": "Lock the Windows loader lock in jl_with_stackwalk_lock to prevent certain deadlocks when unwinding the stack, similar to how macOS acquires the keymgr lock in jl_lock_profile_mach.\r\n\r\nThe loader lock prevents the loader from modifying internal data structures while we're walking the stack, which could otherwise cause crashes or hangs during backtrace collection.\r\n\r\nFixes some of #59650\r\n\r\n\ud83e\udd16 Generated with Claude Code",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59840/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59840/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "43403e070bc49b8e975a55f18485d77644e7b1eb",
      "filename": "src/julia_internal.h",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd/src%2Fjulia_internal.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd/src%2Fjulia_internal.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia_internal.h?ref=7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd",
      "patch": "@@ -240,7 +240,6 @@ JL_DLLEXPORT int jl_lock_profile(void) JL_NOTSAFEPOINT JL_NOTSAFEPOINT_ENTER;\n JL_DLLEXPORT void jl_unlock_profile(void) JL_NOTSAFEPOINT JL_NOTSAFEPOINT_LEAVE;\n JL_DLLEXPORT int jl_lock_profile_wr(void) JL_NOTSAFEPOINT JL_NOTSAFEPOINT_ENTER;\n JL_DLLEXPORT void jl_unlock_profile_wr(void) JL_NOTSAFEPOINT JL_NOTSAFEPOINT_LEAVE;\n-void jl_with_stackwalk_lock(void (*f)(void*) JL_NOTSAFEPOINT, void *ctx) JL_NOTSAFEPOINT;\n \n arraylist_t *jl_get_all_tasks_arraylist(void) JL_NOTSAFEPOINT;\n typedef struct {\n@@ -1533,8 +1532,8 @@ void jl_fprint_bt_entry_codeloc(ios_t *s, jl_bt_element_t *bt_data) JL_NOTSAFEPO\n #ifdef _OS_WINDOWS_\n JL_DLLEXPORT void jl_refresh_dbg_module_list(void);\n #endif\n-int jl_thread_suspend_and_get_state(int tid, int timeout, bt_context_t *ctx) JL_NOTSAFEPOINT;\n void jl_thread_resume(int tid) JL_NOTSAFEPOINT;\n+int jl_thread_suspend(int16_t tid, bt_context_t *ctx) JL_NOTSAFEPOINT;\n \n // *to is NULL or malloc'd pointer, from is allowed to be NULL\n STATIC_INLINE char *jl_copy_str(char **to, const char *from) JL_NOTSAFEPOINT"
    },
    {
      "sha": "1ef3e9d23094a97d126651351963706d757c11b1",
      "filename": "src/signals-mach.c",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd/src%2Fsignals-mach.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd/src%2Fsignals-mach.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-mach.c?ref=7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd",
      "patch": "@@ -527,7 +527,7 @@ static int jl_thread_suspend_and_get_state2(int tid, host_thread_state_t *ctx) J\n     return 1;\n }\n \n-int jl_thread_suspend_and_get_state(int tid, int timeout, bt_context_t *ctx)\n+static int jl_thread_suspend_and_get_state(int tid, int timeout, bt_context_t *ctx)\n {\n     (void)timeout;\n     host_thread_state_t state;\n@@ -712,6 +712,14 @@ static void jl_unlock_profile_mach(int dlsymlock, int keymgr_locked)\n     jl_unlock_profile();\n }\n \n+int jl_thread_suspend(int16_t tid, bt_context_t *ctx)\n+{\n+    int lockret = jl_lock_profile_mach(1);\n+    int success = jl_thread_suspend_and_get_state(tid, 1, ctx);\n+    jl_unlock_profile_mach(1, lockret);\n+    return success;\n+}\n+\n void jl_with_stackwalk_lock(void (*f)(void*), void *ctx)\n {\n     int lockret = jl_lock_profile_mach(1);"
    },
    {
      "sha": "16e70ef0f764e44b2a59546a41c7a1c50e928194",
      "filename": "src/signals-unix.c",
      "status": "modified",
      "additions": 19,
      "deletions": 26,
      "changes": 45,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd/src%2Fsignals-unix.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd/src%2Fsignals-unix.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-unix.c?ref=7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd",
      "patch": "@@ -303,41 +303,34 @@ int exc_reg_is_write_fault(uintptr_t esr) {\n }\n #endif\n \n+static int jl_thread_suspend_and_get_state(int tid, int timeout, bt_context_t *ctx);\n+\n #if defined(HAVE_MACH)\n #include \"signals-mach.c\"\n #else\n #include <poll.h>\n #include <sys/eventfd.h>\n #include <link.h>\n \n-#ifndef _OS_FREEBSD_\n typedef struct {\n-    void (*f)(void*) JL_NOTSAFEPOINT;\n-    void *ctx;\n-} callback_t;\n+    int16_t tid;\n+    bt_context_t *ctx;\n+    int success;\n+} callback_data_t;\n static int with_dl_iterate_phdr_lock(struct dl_phdr_info *info, size_t size, void *data)\n {\n     jl_lock_profile();\n-    callback_t *callback = (callback_t*)data;\n-    callback->f(callback->ctx);\n+    callback_data_t *cb_data = (callback_data_t*)data;\n+    cb_data->success = jl_thread_suspend_and_get_state(cb_data->tid, 1, cb_data->ctx);\n     jl_unlock_profile();\n     return 1; // only call this once\n }\n-#endif\n \n-void jl_with_stackwalk_lock(void (*f)(void*), void *ctx)\n+int jl_thread_suspend(int16_t tid, bt_context_t *ctx)\n {\n-#ifndef _OS_FREEBSD_\n-    callback_t callback = {f, ctx};\n-    dl_iterate_phdr(with_dl_iterate_phdr_lock, &callback);\n-#else\n-    // FreeBSD makes the questionable decisions to use a terrible implementation of a spin\n-    // lock and to block all signals while a lock is held. However, that also means it is\n-    // not currently vulnerable to this libunwind bug that other platforms can encounter.\n-    jl_lock_profile();\n-    f(ctx);\n-    jl_unlock_profile();\n-#endif\n+    callback_data_t cb_data = {tid, ctx, 0};\n+    dl_iterate_phdr(with_dl_iterate_phdr_lock, &cb_data);\n+    return cb_data.success;\n }\n \n #if defined(_OS_LINUX_) && (defined(_CPU_X86_64_) || defined(_CPU_X86_))\n@@ -458,7 +451,7 @@ static int exit_signal_cond = -1;\n static int signal_caught_cond = -1;\n static int signals_inflight = 0;\n \n-int jl_thread_suspend_and_get_state(int tid, int timeout, bt_context_t *ctx)\n+static int jl_thread_suspend_and_get_state(int tid, int timeout, bt_context_t *ctx)\n {\n     int err;\n     pthread_mutex_lock(&in_signal_lock);\n@@ -845,15 +838,15 @@ void trigger_profile_peek(void)\n \n static jl_bt_element_t signal_bt_data[JL_MAX_BT_SIZE + 1];\n static size_t signal_bt_size = 0;\n-static void do_critical_profile(void *ctx)\n+static void do_critical_profile(void)\n {\n     bt_context_t signal_context;\n     // sample each thread, round-robin style in reverse order\n     // (so that thread zero gets notified last)\n     int nthreads = jl_atomic_load_acquire(&jl_n_threads);\n     for (int i = nthreads; i-- > 0; ) {\n         // notify thread to stop\n-        if (!jl_thread_suspend_and_get_state(i, 1, &signal_context))\n+        if (!jl_thread_suspend(i, &signal_context))\n             continue;\n \n         // do backtrace on thread contexts for critical signals\n@@ -866,7 +859,7 @@ static void do_critical_profile(void *ctx)\n     }\n }\n \n-static void do_profile(void *ctx)\n+static void do_profile(void)\n {\n     bt_context_t signal_context;\n     int nthreads = jl_atomic_load_acquire(&jl_n_threads);\n@@ -883,7 +876,7 @@ static void do_profile(void *ctx)\n             return;\n         }\n         // notify thread to stop\n-        if (!jl_thread_suspend_and_get_state(tid, 1, &signal_context))\n+        if (!jl_thread_suspend(tid, &signal_context))\n             return;\n         // unwinding can fail, so keep track of the current state\n         // and restore from the SEGV handler if anything happens.\n@@ -1062,15 +1055,15 @@ static void *signal_listener(void *arg)\n         signal_bt_size = 0;\n #if !defined(JL_DISABLE_LIBUNWIND)\n         if (critical) {\n-            jl_with_stackwalk_lock(do_critical_profile, NULL);\n+            do_critical_profile();\n         }\n         else if (profile) {\n             if (profile_all_tasks) {\n                 // Don't take the stackwalk lock here since it's already taken in `jl_rec_backtrace`\n                 jl_profile_task();\n             }\n             else {\n-                jl_with_stackwalk_lock(do_profile, NULL);\n+                do_profile();\n             }\n         }\n #ifndef HAVE_MACH"
    },
    {
      "sha": "d5770ae7080dab97c64181507de8ed903582c075",
      "filename": "src/signals-win.c",
      "status": "modified",
      "additions": 14,
      "deletions": 19,
      "changes": 33,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd/src%2Fsignals-win.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd/src%2Fsignals-win.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-win.c?ref=7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd",
      "patch": "@@ -4,6 +4,11 @@\n // Note that this file is `#include`d by \"signal-handling.c\"\n #include <mmsystem.h> // hidden by LEAN_AND_MEAN\n \n+// Loader lock functions from ntdll\n+// See https://devblogs.microsoft.com/oldnewthing/20140808-00/?p=293\n+extern NTSTATUS NTAPI LdrLockLoaderLock(ULONG Flags, ULONG *State, ULONG_PTR *Cookie);\n+extern NTSTATUS NTAPI LdrUnlockLoaderLock(ULONG Flags, ULONG_PTR Cookie);\n+\n static const size_t sig_stack_size = 131072; // 128k reserved for backtrace_fiber for stack overflow handling\n \n // Copied from MINGW_FLOAT_H which may not be found due to a collision with the builtin gcc float.h\n@@ -439,26 +444,19 @@ void jl_thread_resume(int tid)\n     }\n }\n \n-void jl_lock_stackwalk(void)\n+int jl_thread_suspend(int16_t tid, bt_context_t *ctx)\n {\n     uv_mutex_lock(&jl_in_stackwalk);\n     jl_lock_profile();\n-}\n-\n-void jl_unlock_stackwalk(void)\n-{\n+    ULONG_PTR lock_cookie = 0;\n+    LdrLockLoaderLock(0x1, NULL, &lock_cookie);\n+    int success = jl_thread_suspend_and_get_state(tid, 0, ctx);\n+    LdrUnlockLoaderLock(0x1, lock_cookie);\n     jl_unlock_profile();\n     uv_mutex_unlock(&jl_in_stackwalk);\n+    return success;\n }\n \n-void jl_with_stackwalk_lock(void (*f)(void*), void *ctx)\n-{\n-    jl_lock_stackwalk();\n-    f(ctx);\n-    jl_unlock_stackwalk();\n-}\n-\n-\n static DWORD WINAPI profile_bt( LPVOID lparam )\n {\n     // Note: illegal to use jl_* functions from this thread except for profiling-specific functions\n@@ -477,17 +475,15 @@ static DWORD WINAPI profile_bt( LPVOID lparam )\n             }\n             else {\n                 // TODO: bring this up to parity with other OS by adding loop over tid here\n-                jl_lock_stackwalk();\n-                CONTEXT ctxThread;\n-                if (!jl_thread_suspend_and_get_state(0, 0, &ctxThread)) {\n-                    jl_unlock_stackwalk();\n+                bt_context_t c;\n+                if (!jl_thread_suspend(0, &c)) {\n                     fputs(\"failed to suspend main thread. aborting profiling.\", stderr);\n                     jl_profile_stop_timer();\n                     break;\n                 }\n                 // Get backtrace data\n                 profile_bt_size_cur += rec_backtrace_ctx((jl_bt_element_t*)profile_bt_data_prof + profile_bt_size_cur,\n-                        profile_bt_size_max - profile_bt_size_cur - 1, &ctxThread, NULL);\n+                        profile_bt_size_max - profile_bt_size_cur - 1, &c, NULL);\n \n                 jl_ptls_t ptls = jl_atomic_load_relaxed(&jl_all_tls_states)[0]; // given only profiling hMainThread\n \n@@ -507,7 +503,6 @@ static DWORD WINAPI profile_bt( LPVOID lparam )\n                 // Mark the end of this block with two 0's\n                 profile_bt_data_prof[profile_bt_size_cur++].uintptr = 0;\n                 profile_bt_data_prof[profile_bt_size_cur++].uintptr = 0;\n-                jl_unlock_stackwalk();\n                 jl_thread_resume(0);\n                 jl_check_profile_autostop();\n             }"
    },
    {
      "sha": "4853e1ec7f4f2b1488b0c0e4f4192d2f0fe0add4",
      "filename": "src/stackwalk.c",
      "status": "modified",
      "additions": 2,
      "deletions": 17,
      "changes": 19,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd/src%2Fstackwalk.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd/src%2Fstackwalk.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fstackwalk.c?ref=7ca7bcd59011bc77e3b5276b59e8ea319d5ef7dd",
      "patch": "@@ -1257,26 +1257,13 @@ return 0;\n #endif\n }\n \n-typedef struct {\n-    int16_t old;\n-    bt_context_t *c;\n-    int success;\n-} suspend_t;\n-static void suspend(void *ctx)\n-{\n-    suspend_t *suspenddata = (suspend_t*)ctx;\n-    suspenddata->success = jl_thread_suspend_and_get_state(suspenddata->old, 1, suspenddata->c);\n-}\n-\n JL_DLLEXPORT size_t jl_try_record_thread_backtrace(jl_ptls_t ptls2, jl_bt_element_t *bt_data, size_t max_bt_size) JL_NOTSAFEPOINT\n {\n     int16_t tid = ptls2->tid;\n     jl_task_t *t = NULL;\n     bt_context_t *context = NULL;\n     bt_context_t c;\n-    suspend_t suspenddata = {tid, &c};\n-    jl_with_stackwalk_lock(suspend, &suspenddata);\n-    if (!suspenddata.success) {\n+    if (!jl_thread_suspend(tid, &c)) {\n         return 0;\n     }\n     // thread is stopped, safe to read the task it was running before we stopped it\n@@ -1309,9 +1296,7 @@ JL_DLLEXPORT jl_record_backtrace_result_t jl_record_backtrace(jl_task_t *t, jl_b\n     int16_t old;\n     for (old = -1; !jl_atomic_cmpswap(&t->tid, &old, tid) && old != tid; old = -1) {\n         // if this task is already running somewhere, we need to stop the thread it is running on and query its state\n-        suspend_t suspenddata = {old, &c};\n-        jl_with_stackwalk_lock(suspend, &suspenddata);\n-        if (!suspenddata.success) {\n+        if (!jl_thread_suspend(old, &c)) {\n             if (jl_atomic_load_relaxed(&t->tid) != old)\n                 continue;\n             return result;"
    }
  ]
}