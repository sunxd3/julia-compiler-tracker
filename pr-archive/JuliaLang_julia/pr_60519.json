{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60519",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60519/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60519/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60519/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60519",
  "id": 3771376406,
  "node_id": "PR_kwDOABkWpM67CFzt",
  "number": 60519,
  "title": "Improve rendering Markdown lists in a terminal",
  "user": {
    "login": "fingolfin",
    "id": 241512,
    "node_id": "MDQ6VXNlcjI0MTUxMg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/241512?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fingolfin",
    "html_url": "https://github.com/fingolfin",
    "followers_url": "https://api.github.com/users/fingolfin/followers",
    "following_url": "https://api.github.com/users/fingolfin/following{/other_user}",
    "gists_url": "https://api.github.com/users/fingolfin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fingolfin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fingolfin/subscriptions",
    "organizations_url": "https://api.github.com/users/fingolfin/orgs",
    "repos_url": "https://api.github.com/users/fingolfin/repos",
    "events_url": "https://api.github.com/users/fingolfin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fingolfin/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2317339600,
      "node_id": "MDU6TGFiZWwyMzE3MzM5NjAw",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/markdown",
      "name": "markdown",
      "color": "D914CD",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 10,
  "created_at": "2025-12-30T21:54:37Z",
  "updated_at": "2026-01-05T10:16:59Z",
  "closed_at": "2026-01-05T10:16:58Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60519",
    "html_url": "https://github.com/JuliaLang/julia/pull/60519",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60519.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60519.patch",
    "merged_at": "2026-01-05T10:16:58Z"
  },
  "body": "This changes how Markdown lists are rendered in the Terminal:\r\n- the list is no longer indented by two spaces\r\n- the bullet points are now followed by a single space, not two\r\n- extra lines in an entry are indented correctly across all levels\r\n- fix printing / indentation for ordered lists starting at an index other than 1: the padding for the labels was being computed incorrectly\r\n- fix word wrap with a given column limit\r\n\r\nConsider this Markdown input:\r\n```md\r\nBefore the list:\r\n- top level\\\r\n  with an extra line\r\n  - second level\\\r\n    again with an extra line\r\n    - third level\\\r\n      yet again with an extra line\r\n      - fourth level\\\r\n        and another extra line\r\n        - fifth level\\\r\n          final extra line\r\n- back to top level\r\n```\r\n\r\nThen with Julia master it renders in the terminal like this:\r\n```\r\n  Before the list:\r\n\r\n    \u2022  top level\r\n       with an extra line\r\n       \u2013  second level\r\n        again with an extra line\r\n          \u25aa  third level\r\n         yet again with an extra line\r\n             \u2013  fourth level\r\n          and another extra line\r\n                \u25aa  fifth level\r\n           final extra line\r\n    \u2022  back to top level\r\n```\r\n\r\nWith this PR:\r\n```\r\n  Before the list:\r\n\r\n  \u2022 top level\r\n    with an extra line\r\n    \u2013 second level\r\n      again with an extra line\r\n      \u25aa third level\r\n        yet again with an extra line\r\n        \u2013 fourth level\r\n          and another extra line\r\n          \u25aa fifth level\r\n            final extra line\r\n  \u2022 back to top level\r\n```\r\n\r\nResolves #40508, resolves #58514",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60519/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60519/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "111a2b425879bced639d322bbcc2647419b9d9d1",
      "filename": "stdlib/Markdown/src/render/terminal/render.jl",
      "status": "modified",
      "additions": 18,
      "deletions": 8,
      "changes": 26,
      "blob_url": "https://github.com/JuliaLang/julia/blob/a99ce4bb54a7b9a334b35be9b46775b18999753f/stdlib%2FMarkdown%2Fsrc%2Frender%2Fterminal%2Frender.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/a99ce4bb54a7b9a334b35be9b46775b18999753f/stdlib%2FMarkdown%2Fsrc%2Frender%2Fterminal%2Frender.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FMarkdown%2Fsrc%2Frender%2Fterminal%2Frender.jl?ref=a99ce4bb54a7b9a334b35be9b46775b18999753f",
      "patch": "@@ -70,30 +70,40 @@ function term(io::IO, f::Footnote, columns)\n     end\n end\n \n-const _list_bullets = (\"\u2022  \", \"\u2013  \", \"\u25aa  \")\n+const _list_bullets = (\"\u2022 \", \"\u2013 \", \"\u25aa \")\n \n function term(io::IO, md::List, columns, depth::Int = 1)\n     dterm(io, md, columns, _depth)      = term(io, md, columns)\n     dterm(io, md::List, columns, depth) = term(io, md, columns, depth)\n-    for (i, point) in enumerate(md.items)\n+\n+    function make_bullet(i::Int)\n         bullet = if isordered(md)\n-            string(lpad(i + md.ordered - 1, ndigits(length(md.items))), \". \")\n+            string(lpad(i + md.ordered - 1, ndigits(length(md.items) + md.ordered - 1)), \". \")\n         elseif depth == 1\n             first(_list_bullets)\n         else\n             _list_bullets[2 + mod(depth, length(_list_bullets) - 1)]\n         end\n-        print(io, ' '^ifelse(depth == 1, 2margin, 2*(depth-1)), styled\"{markdown_list:$bullet}\")\n+    end\n+\n+    # adjust column count to ensure word wrap works correctly; the last\n+    # label will be the widest (for ordered lists; for unordered lists they\n+    # are all the same anyway)\n+    columns -= length(make_bullet(length(md.items)))\n+\n+    for (i, point) in enumerate(md.items)\n+        bullet = make_bullet(i)\n+        print(io, ' '^margin, styled\"{markdown_list:$bullet}\")\n         buf = AnnotatedIOBuffer()\n         if point isa Vector && !isempty(point)\n             for (i, elt) in enumerate(point[1:end-1])\n-                dterm(buf, elt, columns - 10, depth + 1)\n+                dterm(buf, elt, columns, depth + 1)\n                 println(buf)\n                 (!(point[i+1] isa List) || point[i+1].loose) && println(buf)\n             end\n-            dterm(buf, point[end], columns - 10, depth + 1)\n+            dterm(buf, point[end], columns, depth + 1)\n         else\n-            dterm(buf, point, columns - 10, depth + 1)\n+            dterm(buf, point, columns, depth + 1)\n         end\n         content = read(seekstart(buf), AnnotatedString)\n         lines = split(rstrip(content), '\\n')\n@@ -102,7 +112,7 @@ function term(io::IO, md::List, columns, depth::Int = 1)\n              for line in Iterators.filter(!isempty, lines)),\n             init=if isempty(lines) 0 else length(first(lines)) end)\n         for (l, line) in enumerate(lines)\n-            l > 1 && print(io, ' '^ifelse(depth == 1, 2margin + 3, 3))\n+            l > 1 && print(io, ' '^(margin + length(bullet)))\n             !isempty(line) && print(io, line[common_indent+1:end])\n             l < length(lines) && println(io)\n         end"
    },
    {
      "sha": "50fe6b664e911f1471cb57324bfe1e0b45c2a007",
      "filename": "stdlib/Markdown/test/runtests.jl",
      "status": "modified",
      "additions": 130,
      "deletions": 8,
      "changes": 138,
      "blob_url": "https://github.com/JuliaLang/julia/blob/a99ce4bb54a7b9a334b35be9b46775b18999753f/stdlib%2FMarkdown%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/a99ce4bb54a7b9a334b35be9b46775b18999753f/stdlib%2FMarkdown%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FMarkdown%2Ftest%2Fruntests.jl?ref=a99ce4bb54a7b9a334b35be9b46775b18999753f",
      "patch": "@@ -274,7 +274,7 @@ end\n \n # Issue #38275\n function test_list_wrap(str, lenmin, lenmax)\n-    strs = split(str, '\\n')\n+    strs = rstrip.(split(str, '\\n'))\n     l = length.(strs)\n     for i = 1:length(l)-1\n         if l[i] != 0 && l[i+1] != 0    # the next line isn't blank, so this line should be \"full\"\n@@ -283,14 +283,29 @@ function test_list_wrap(str, lenmin, lenmax)\n             l[i] <= lenmax || return false   # this line isn't too long (but there is no min)\n         end\n     end\n+\n     # Check consistent indentation\n-    rngs = findfirst.((\". \",), strs)\n-    k = last(rngs[1])\n+    # First, locate the list labels ends (position of bullet, or the \".\" at\n+    # the end of a numeric label\n+    labelends = findfirst.((r\"[.\u2022\u2013\u25aa] \",), strs)\n+    # sanity checks: label end locations must be either equal or separated by at least one char\n+    sorted_labels = unique(sort(filter(!isnothing, labelends)))\n+    for i in 1:length(sorted_labels)-1\n+        first(sorted_labels[i]) + 1 < first(sorted_labels[i+1]) || return false\n+    end\n+\n+    # next check that after each label / bullet the following lines have the right indent\n+    k = first(labelends[1])+1\n     rex = Regex('^' * \" \"^k * \"\\\\w\")\n-    for (i, rng) in enumerate(rngs)\n-        isa(rng, AbstractRange) && last(rng) == k && continue  # every numbered line starts the text at the same position\n-        rng === nothing && (isempty(strs[i]) || match(rex, strs[i]) !== nothing) && continue  # every unnumbered line is indented to text in numbered lines\n-        return false\n+    for (i, le) in enumerate(labelends)\n+        if le === nothing\n+            # every unlabeled line is indented to text in labeled lines\n+            (isempty(strs[i]) || match(rex, strs[i]) !== nothing) || return false\n+        else\n+            # determine indent for following lines\n+            k = first(le)+1\n+            rex = Regex('^' * \" \"^k * \"\\\\w\")\n+        end\n     end\n     return true\n end\n@@ -299,6 +314,16 @@ let doc =\n     md\"\"\"\n     1. a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij\n \n+       - a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij\n+\n+         - a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij\n+\n+           999. a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij\n+\n+           1000. a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij\n+\n+       - a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij\n+\n     2. a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij a bc def ghij\n     \"\"\"\n     str = sprint(term, doc, 50)\n@@ -377,7 +402,22 @@ table = md\"\"\"\n # mime output\n let out =\n     @test sprint(show, \"text/plain\", book) ==\n-        \"  Title\\n  \u2261\u2261\u2261\u2261\u2261\\n\\n  Some discussion\\n\\n  \u2502  A quote\\n\\n  Section important\\n  =================\\n\\n  Some bolded\\n\\n    \u2022  list1\\n    \u2022  list2\"\n+        \"\"\"\n+          Title\n+          \u2261\u2261\u2261\u2261\u2261\n+\n+          Some discussion\n+\n+          \u2502  A quote\n+\n+          Section important\n+          =================\n+\n+          Some bolded\n+\n+          \u2022 list1\n+          \u2022 list2\n+        \"\"\" |> chomp\n     @test sprint(show, \"text/plain\", md\"#\") == \"\" # edge case of empty header\n     @test sprint(show, \"text/markdown\", book) ==\n         \"\"\"\n@@ -1406,3 +1446,85 @@ end\n @testset \"Lazy Strings\" begin\n     @test Markdown.parse(lazy\"foo\") == Markdown.parse(\"foo\")\n end\n+\n+@testset \"#40508: terminal rendering of nested lists, with hard breaks\" begin\n+    #\n+    # Test an unordered list.\n+    #\n+    m = md\"\"\"\n+    An unordered list:\n+    - top level\\\n+      with an extra line\n+      - second level\\\n+        again with an extra line\n+        - third level\\\n+          yet again with an extra line\n+          - fourth level\\\n+            and another extra line\n+            - fifth level\\\n+              final extra line\n+    - back to top level\n+    \"\"\"\n+\n+    expected = \"\"\"\n+      An unordered list:\n+\n+      \u2022 top level\n+        with an extra line\n+        \u2013 second level\n+          again with an extra line\n+          \u25aa third level\n+            yet again with an extra line\n+            \u2013 fourth level\n+              and another extra line\n+              \u25aa fifth level\n+                final extra line\n+      \u2022 back to top level\n+    \"\"\" |> chomp\n+\n+    actual = sprint(show, MIME(\"text/plain\"), m)\n+    @test expected == actual\n+\n+    #\n+    # Test an ordered list. These behave differently if the number of list\n+    # entries increases to another power of ten. For example, when going from\n+    # 9 to 10 list entries. We test this here.\n+    #\n+    m = md\"\"\"\n+    An unordered list:\n+    1. top level\\\n+       with an extra line\n+       1. second level\\\n+          again with an extra line\n+           999. third level\\\n+                yet again with an extra line\n+                1. fourth level\\\n+                   and another extra line\n+                   1. fifth level\\\n+                      final extra line\n+          1000. more third level\\\n+                with an extra line\n+    1. back to top level\n+    \"\"\"\n+\n+    expected = \"\"\"\n+      An unordered list:\n+\n+      1. top level\n+         with an extra line\n+         1. second level\n+            again with an extra line\n+             999. third level\n+                  yet again with an extra line\n+                  1. fourth level\n+                     and another extra line\n+                     1. fifth level\n+                        final extra line\n+            1000. more third level\n+                  with an extra line\n+      2. back to top level\n+    \"\"\" |> chomp\n+\n+    actual = sprint(show, MIME(\"text/plain\"), m)\n+    @test expected == actual\n+end"
    }
  ]
}