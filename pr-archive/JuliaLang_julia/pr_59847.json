{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59847",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59847/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59847/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59847/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59847",
  "id": 3517582942,
  "node_id": "PR_kwDOABkWpM6t3IS9",
  "number": 59847,
  "title": "add support for automatic bracket completion in REPL input",
  "user": {
    "login": "KristofferC",
    "id": 1282691,
    "node_id": "MDQ6VXNlcjEyODI2OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1282691?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KristofferC",
    "html_url": "https://github.com/KristofferC",
    "followers_url": "https://api.github.com/users/KristofferC/followers",
    "following_url": "https://api.github.com/users/KristofferC/following{/other_user}",
    "gists_url": "https://api.github.com/users/KristofferC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KristofferC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KristofferC/subscriptions",
    "organizations_url": "https://api.github.com/users/KristofferC/orgs",
    "repos_url": "https://api.github.com/users/KristofferC/repos",
    "events_url": "https://api.github.com/users/KristofferC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KristofferC/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 42281298,
      "node_id": "MDU6TGFiZWw0MjI4MTI5OA==",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/REPL",
      "name": "REPL",
      "color": "c7def8",
      "default": false,
      "description": "Julia's REPL (Read Eval Print Loop)"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 7,
  "created_at": "2025-10-15T11:24:11Z",
  "updated_at": "2025-10-17T20:21:42Z",
  "closed_at": "2025-10-17T20:21:40Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59847",
    "html_url": "https://github.com/JuliaLang/julia/pull/59847",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59847.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59847.patch",
    "merged_at": "2025-10-17T20:21:40Z"
  },
  "body": "This ports the bracket completion feature from OhMyREPL (https://kristofferc.github.io/OhMyREPL.jl/latest/features/bracket_complete/) to the Julia REPL. It is disabled by default because I am not sure if this is an obvious feature that everyone wants to have.\r\n\r\nThis feature looks in practice like:\r\n\r\nhttps://github.com/user-attachments/assets/a318905b-ecdc-41e7-9858-ed5a0cd85b6b\r\n\r\nWith this and https://github.com/JuliaLang/julia/pull/59819 all features (excpet perhaps a good API for https://kristofferc.github.io/OhMyREPL.jl/latest/features/prompt/) have been ported to the Julia REPL and OhMyREPL can be deprecated.\r\n\r\n\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59847/reactions",
    "total_count": 10,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 9,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59847/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "9092a452785489bd8f6b1f02a8b0e4e390202b62",
      "filename": "NEWS.md",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5557a8757ddb56513226abc99859a9114fc3ce69/NEWS.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5557a8757ddb56513226abc99859a9114fc3ce69/NEWS.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/NEWS.md?ref=5557a8757ddb56513226abc99859a9114fc3ce69",
      "patch": "@@ -98,6 +98,7 @@ Standard library changes\n \n * The Julia REPL now support bracketed paste on Windows which should significantly speed up pasting large code blocks into the REPL ([#59825])\n * The REPL now provides syntax highlighting for input as you type. See the REPL docs for more info about customization.\n+* The REPL now supports automatic insertion of closing brackets, parentheses, and quotes. See the REPL docs for more info about customization.\n * The display of `AbstractChar`s in the main REPL mode now includes LaTeX input information like what is shown in help mode ([#58181]).\n * Display of repeated frames and cycles in stack traces has been improved by bracketing them in the trace and treating them consistently ([#55841]).\n "
    },
    {
      "sha": "7115c6fd0124216a743f03a520ef14a3ee6d701b",
      "filename": "stdlib/REPL/docs/src/index.md",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Fdocs%2Fsrc%2Findex.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Fdocs%2Fsrc%2Findex.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fdocs%2Fsrc%2Findex.md?ref=5557a8757ddb56513226abc99859a9114fc3ce69",
      "patch": "@@ -317,6 +317,28 @@ atreplinit(customize_keys)\n \n Users should refer to `LineEdit.jl` to discover the available actions on key input.\n \n+### Automatic bracket insertion\n+\n+The Julia REPL supports automatically inserting closing brackets, parentheses, braces, and quotes\n+when you type the opening character.\n+\n+When enabled, typing an opening bracket `(`, `{`, or `[` will automatically insert the matching\n+closing bracket `)`, `}`, or `]` and position the cursor between them. The same behavior applies\n+to quotes (`\"`, `'`, and `` ` ``). If you then type the closing character, the REPL will skip over\n+the auto-inserted character instead of inserting a duplicate. Additionally, pressing backspace\n+immediately after auto-insertion will remove both the opening and closing characters.\n+\n+To disable this feature, add the following to your `~/.julia/config/startup.jl` file:\n+\n+```julia\n+atreplinit() do repl\n+    # Robust against older julia versions\n+    if hasfield(typeof(repl.options), :auto_insert_closing_bracket)\n+        repl.options.auto_insert_closing_bracket = false\n+    end\n+end\n+```\n+\n ## Tab completion\n \n In the Julian, pkg and help modes of the REPL, one can enter the first few characters of a function"
    },
    {
      "sha": "e701cddad6feb716cdf1b90e145fe4afc1d7cb38",
      "filename": "stdlib/REPL/src/LineEdit.jl",
      "status": "modified",
      "additions": 136,
      "deletions": 0,
      "changes": 136,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FLineEdit.jl?ref=5557a8757ddb56513226abc99859a9114fc3ce69",
      "patch": "@@ -2101,6 +2101,142 @@ const escape_defaults = merge!(\n     AnyDict(\"\\e[$(c)l\" => nothing for c in 1:20)\n     )\n \n+\n+# Keymap for automatic bracket/quote insertion and completion\n+const bracket_insert_keymap = AnyDict()\n+let\n+    # Determine when we should not close a bracket/quote\n+    function should_skip_closing_bracket(left_peek, v)\n+        # Don't close if we already have an open quote immediately before (triple quote case)\n+        # For quotes, also check for transpose expressions: issue JuliaLang/OhMyREPL.jl#200\n+        left_peek == v && return true\n+        if v == '\\''\n+            tr_expr = isletter(left_peek) || isnumeric(left_peek) || left_peek == '_' || left_peek == ']'\n+            return tr_expr\n+        end\n+        return false\n+    end\n+\n+    function peek_char_left(b::IOBuffer)\n+        p = position(b)\n+        c = char_move_left(b)\n+        seek(b, p)\n+        return c\n+    end\n+\n+    # Check if there's an unmatched opening quote before the cursor\n+    function has_unmatched_quote(buf::IOBuffer, quote_char::Char)\n+        pos = position(buf)\n+        content = String(buf.data[1:pos])\n+        isempty(content) && return false\n+\n+        # Count unescaped quotes before cursor position\n+        count = 0\n+        i = 1\n+        while i <= length(content)\n+            if content[i] == quote_char\n+                # Check if escaped by counting preceding backslashes\n+                num_backslashes = 0\n+                j = i - 1\n+                while j >= 1 && content[j] == '\\\\'\n+                    num_backslashes += 1\n+                    j -= 1\n+                end\n+                # If even number of backslashes (including zero), the quote is not escaped\n+                if num_backslashes % 2 == 0\n+                    count += 1\n+                end\n+            end\n+            i = nextind(content, i)\n+        end\n+        return isodd(count)\n+    end\n+\n+    # Left/right bracket pairs\n+    bracket_pairs = (('(', ')'), ('{', '}'), ('[', ']'))\n+    right_brackets_ws = (')', '}', ']', ' ', '\\t', '\\n')\n+\n+    for (left, right) in bracket_pairs\n+        # Left bracket: insert both and move cursor between them\n+        bracket_insert_keymap[left] = (s::MIState, o...) -> begin\n+            buf = buffer(s)\n+            edit_insert(buf, left)\n+            if eof(buf) || peek(buf, Char) in right_brackets_ws\n+                edit_insert(buf, right)\n+                edit_move_left(buf)\n+            end\n+            refresh_line(s)\n+        end\n+\n+        # Right bracket: skip over if next char matches, otherwise insert\n+        bracket_insert_keymap[right] = (s::MIState, o...) -> begin\n+            buf = buffer(s)\n+            if !eof(buf) && peek(buf, Char) == right\n+                edit_move_right(buf)\n+            else\n+                edit_insert(buf, right)\n+            end\n+            refresh_line(s)\n+        end\n+    end\n+\n+    # Quote characters (need special handling for transpose detection)\n+    for quote_char in ('\"', '\\'', '`')\n+        bracket_insert_keymap[quote_char] = (s::MIState, o...) -> begin\n+            buf = buffer(s)\n+            if !eof(buf) && peek(buf, Char) == quote_char\n+                # Skip over closing quote\n+                edit_move_right(buf)\n+            elseif position(buf) > 0 && should_skip_closing_bracket(peek_char_left(buf), quote_char)\n+                # Don't auto-close (e.g., for transpose or triple quotes)\n+                edit_insert(buf, quote_char)\n+            elseif quote_char in ('\"', '\\'', '`') && has_unmatched_quote(buf, quote_char)\n+                # For quotes, check if we're closing an existing string\n+                edit_insert(buf, quote_char)\n+            else\n+                # Insert both quotes\n+                edit_insert(buf, quote_char)\n+                edit_insert(buf, quote_char)\n+                edit_move_left(buf)\n+            end\n+            refresh_line(s)\n+        end\n+    end\n+\n+    # Backspace - also remove matching closing bracket/quote\n+    bracket_insert_keymap['\\b'] = (s::MIState, o...) -> begin\n+        if is_region_active(s)\n+            return edit_kill_region(s)\n+        elseif isempty(s) || position(buffer(s)) == 0\n+            # Handle transitioning to main mode\n+            repl = Base.active_repl\n+            mirepl = isdefined(repl, :mi) ? repl.mi : repl\n+            main_mode = mirepl.interface.modes[1]\n+            buf = copy(buffer(s))\n+            transition(s, main_mode) do\n+                state(s, main_mode).input_buffer = buf\n+            end\n+            return\n+        end\n+\n+        buf = buffer(s)\n+        left_brackets = ('(', '{', '[', '\"', '\\'', '`')\n+        right_brackets = (')', '}', ']', '\"', '\\'', '`')\n+\n+        if !eof(buf) && position(buf) > 0\n+            left_char = peek_char_left(buf)\n+            i = findfirst(isequal(left_char), left_brackets)\n+            if i !== nothing && peek(buf, Char) == right_brackets[i]\n+                # Remove both the left and right bracket/quote\n+                edit_delete(buf)\n+                edit_backspace(buf)\n+                return refresh_line(s)\n+            end\n+        end\n+        return edit_backspace(s)\n+    end\n+end\n+\n mutable struct HistoryPrompt <: TextInterface\n     hp::HistoryProvider\n     complete::CompletionProvider"
    },
    {
      "sha": "8752ec654ecec788120356404fc1a35d830e060b",
      "filename": "stdlib/REPL/src/REPL.jl",
      "status": "modified",
      "additions": 28,
      "deletions": 3,
      "changes": 31,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPL.jl?ref=5557a8757ddb56513226abc99859a9114fc3ce69",
      "patch": "@@ -1499,7 +1499,18 @@ function setup_interface(\n                 end\n                 Base.errormonitor(t_replswitch)\n             else\n-                edit_insert(s, ']')\n+                # Use bracket insertion if enabled, otherwise just insert\n+                if repl.options.auto_insert_closing_bracket\n+                    buf = LineEdit.buffer(s)\n+                    if !eof(buf) && LineEdit.peek(buf, Char) == ']'\n+                        LineEdit.edit_move_right(buf)\n+                    else\n+                        edit_insert(buf, ']')\n+                    end\n+                    LineEdit.refresh_line(s)\n+                else\n+                    edit_insert(s, ']')\n+                end\n                 LineEdit.check_show_hint(s)\n             end\n         end,\n@@ -1671,14 +1682,28 @@ function setup_interface(\n \n     prefix_prompt, prefix_keymap = LineEdit.setup_prefix_keymap(hp, julia_prompt)\n \n-    a = Dict{Any,Any}[skeymap, repl_keymap, prefix_keymap, LineEdit.history_keymap, LineEdit.default_keymap, LineEdit.escape_defaults]\n+    # Build keymap list - add bracket insertion if enabled\n+    base_keymaps = Dict{Any,Any}[skeymap, repl_keymap, prefix_keymap, LineEdit.history_keymap]\n+    if repl.options.auto_insert_closing_bracket\n+        push!(base_keymaps, LineEdit.bracket_insert_keymap)\n+    end\n+    push!(base_keymaps, LineEdit.default_keymap, LineEdit.escape_defaults)\n+\n+    a = base_keymaps\n     prepend!(a, extra_repl_keymap)\n \n     julia_prompt.keymap_dict = LineEdit.keymap(a)\n \n     mk = mode_keymap(julia_prompt)\n \n-    b = Dict{Any,Any}[skeymap, mk, prefix_keymap, LineEdit.history_keymap, LineEdit.default_keymap, LineEdit.escape_defaults]\n+    # Build keymap list for other modes\n+    mode_base_keymaps = Dict{Any,Any}[skeymap, mk, prefix_keymap, LineEdit.history_keymap]\n+    if repl.options.auto_insert_closing_bracket\n+        push!(mode_base_keymaps, LineEdit.bracket_insert_keymap)\n+    end\n+    push!(mode_base_keymaps, LineEdit.default_keymap, LineEdit.escape_defaults)\n+\n+    b = mode_base_keymaps\n     prepend!(b, extra_repl_keymap)\n \n     shell_mode.keymap_dict = help_mode.keymap_dict = dummy_pkg_mode.keymap_dict = LineEdit.keymap(b)"
    },
    {
      "sha": "bd881edd23382a0b56e96471363355434079d840",
      "filename": "stdlib/REPL/src/options.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Fsrc%2Foptions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Fsrc%2Foptions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2Foptions.jl?ref=5557a8757ddb56513226abc99859a9114fc3ce69",
      "patch": "@@ -28,6 +28,7 @@ mutable struct Options\n     # refresh after time delay\n     auto_refresh_time_delay::Float64\n     hint_tab_completes::Bool\n+    auto_insert_closing_bracket::Bool # automatically insert closing brackets, quotes, etc.\n     style_input::Bool # enable syntax highlighting for input\n     # default IOContext settings at the REPL\n     iocontext::Dict{Symbol,Any}\n@@ -50,6 +51,7 @@ Options(;\n         auto_indent_time_threshold = 0.005,\n         auto_refresh_time_delay = 0.0, # this no longer seems beneficial\n         hint_tab_completes = true,\n+        auto_insert_closing_bracket = true,\n         style_input = true,\n         iocontext = Dict{Symbol,Any}()) =\n             Options(hascolor, extra_keymap, tabwidth,\n@@ -59,7 +61,7 @@ Options(;\n                     backspace_align, backspace_adjust, confirm_exit,\n                     auto_indent, auto_indent_tmp_off, auto_indent_bracketed_paste,\n                     auto_indent_time_threshold, auto_refresh_time_delay,\n-                    hint_tab_completes, style_input,\n+                    hint_tab_completes, auto_insert_closing_bracket, style_input,\n                     iocontext)\n \n # for use by REPLs not having an options field"
    },
    {
      "sha": "7befa31a518e519e8a70fa445b0da2a0c258b68e",
      "filename": "stdlib/REPL/test/lineedit.jl",
      "status": "modified",
      "additions": 184,
      "deletions": 0,
      "changes": 184,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Ftest%2Flineedit.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Ftest%2Flineedit.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Flineedit.jl?ref=5557a8757ddb56513226abc99859a9114fc3ce69",
      "patch": "@@ -940,3 +940,187 @@ end\n     strings3 = [\"abcdef\", \"123456\\nijklmn\"]\n     @test getcompletion(strings3) == \"\\033[0B\\nabcdef\\n123456\\nijklmn\\n\"\n end\n+\n+# Test bracket insertion functionality\n+@testset \"Bracket insertion\" begin\n+    # Test bracket insertion with a fake REPL that has bracket completion enabled\n+    term = FakeTerminal(IOBuffer(), IOBuffer(), IOBuffer())\n+    prompt = LineEdit.Prompt(\"test> \")\n+\n+    # Build keymap with bracket insertion enabled (as it would be in practice)\n+    base_keymaps = Dict{Any,Any}[LineEdit.bracket_insert_keymap, LineEdit.default_keymap, LineEdit.escape_defaults]\n+    prompt.keymap_dict = LineEdit.keymap(base_keymaps)\n+\n+    interface = LineEdit.ModalInterface([prompt])\n+    s = LineEdit.init_state(term, interface)\n+\n+    # Helper to write characters as stdin input\n+    write_input(s, str) = for c in str\n+        buf = IOBuffer(string(c))\n+        LineEdit.match_input(prompt.keymap_dict, s, buf)(s, buf)\n+    end\n+\n+    # Test left bracket at EOF triggers auto-complete\n+    write_input(s, \"(\")\n+    @test content(s) == \"()\"\n+    @test position(buffer(s)) == 1\n+\n+    # Test right bracket skips over matching bracket\n+    write_input(s, \")\")\n+    @test content(s) == \"()\"\n+    @test position(buffer(s)) == 2\n+\n+    # Test backspace removes both brackets\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"(\")\n+    write_input(s, \"\\b\")\n+    @test content(s) == \"\"\n+    @test position(buffer(s)) == 0\n+\n+    # Test quote insertion at EOF\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"\\\"\\\"\"\n+    @test position(buffer(s)) == 1\n+\n+    # Test quote skip over\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"\\\"\\\"\"\n+    @test position(buffer(s)) == 2\n+\n+    # Test transpose detection - single quote after letter shouldn't auto-complete\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"A\")\n+    write_input(s, \"'\")\n+    @test content(s) == \"A'\"\n+    @test position(buffer(s)) == 2\n+\n+    # Test single quote after space should auto-complete\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \" \")\n+    write_input(s, \"'\")\n+    @test content(s) == \" ''\"\n+    @test position(buffer(s)) == 2\n+\n+    # Test bracket not inserted when next char is not whitespace\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"x\")\n+    charseek(buffer(s), 0)\n+    write_input(s, \"(\")\n+    @test content(s) == \"(x\"\n+    @test position(buffer(s)) == 1\n+\n+    # Test all bracket types\n+    for (left, right) in (('[', ']'), ('{', '}'))\n+        s = LineEdit.init_state(term, interface)\n+        write_input(s, string(left))\n+        @test content(s) == string(left, right)\n+        @test position(buffer(s)) == 1\n+        write_input(s, string(right))\n+        @test position(buffer(s)) == 2\n+        write_input(s, \"\\b\")\n+        @test content(s) == string(left)\n+        @test position(buffer(s)) == 1\n+        write_input(s, \"\\b\")\n+        @test content(s) == \"\"\n+        @test position(buffer(s)) == 0\n+    end\n+\n+    # Test all quote types\n+    for quote_char in ('`', '\"', '\\'')\n+        s = LineEdit.init_state(term, interface)\n+        write_input(s, string(quote_char))\n+        @test content(s) == string(quote_char, quote_char)\n+        @test position(buffer(s)) == 1\n+    end\n+\n+    # Test nested brackets\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"(\")\n+    write_input(s, \"[\")\n+    @test content(s) == \"([])\"\n+    @test position(buffer(s)) == 2\n+    write_input(s, \"]\")\n+    @test position(buffer(s)) == 3\n+    write_input(s, \")\")\n+    @test position(buffer(s)) == 4\n+\n+    # Test backspace in middle of nested brackets\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"(\")\n+    write_input(s, \"{\")\n+    @test content(s) == \"({})\"\n+    @test position(buffer(s)) == 2\n+    write_input(s, \"\\b\")\n+    @test content(s) == \"()\"\n+    @test position(buffer(s)) == 1\n+\n+    # Test triple quotes don't auto-complete\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"\\\"\\\"\"\n+    @test position(buffer(s)) == 1\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"\\\"\\\"\"\n+    @test position(buffer(s)) == 2\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"\\\"\\\"\\\"\"\n+    @test position(buffer(s)) == 3\n+\n+    # Test transpose detection for various cases\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"x123\")\n+    write_input(s, \"'\")\n+    @test content(s) == \"x123'\"\n+    @test position(buffer(s)) == 5\n+\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"arr]\")\n+    write_input(s, \"'\")\n+    @test content(s) == \"arr]'\"\n+    @test position(buffer(s)) == 5\n+\n+    # Test right bracket insert when not matching\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \")\")\n+    @test content(s) == \")\"\n+    @test position(buffer(s)) == 1\n+\n+    # Test backspace doesn't remove mismatched brackets\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"(\")\n+    write_input(s, \"]\")\n+    charseek(buffer(s), 1)\n+    write_input(s, \"\\b\")\n+    @test content(s) == \"])\"\n+    @test position(buffer(s)) == 0\n+\n+    # Test bracket insertion followed by whitespace\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \" \")\n+    charseek(buffer(s), 0)\n+    write_input(s, \"(\")\n+    @test content(s) == \"() \"\n+    @test position(buffer(s)) == 1\n+\n+    # Test context-aware quote closing: typing \" inside include(\"myfile.jl should close the string\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"include(\\\"myfile.jl\")\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"include(\\\"myfile.jl\\\")\"\n+    @test position(buffer(s)) == 19\n+\n+    # Test context-aware quote closing for single quotes\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"include('fsfds \")\n+    write_input(s, \"'\")\n+    @test content(s) == \"include('fsfds ')\"\n+    @test position(buffer(s)) == 16\n+\n+    # Test that auto-close for quotes still works when there's no unmatched quote\n+    s = LineEdit.init_state(term, interface)\n+    write_input(s, \"foo()\")\n+    write_input(s, \"\\\"\")\n+    @test content(s) == \"foo()\\\"\\\"\"\n+    @test position(buffer(s)) == 6\n+end"
    },
    {
      "sha": "5b8a159fb9b796c7f0f181e29f32f09060e6a539",
      "filename": "stdlib/REPL/test/repl.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Ftest%2Frepl.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/5557a8757ddb56513226abc99859a9114fc3ce69/stdlib%2FREPL%2Ftest%2Frepl.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Frepl.jl?ref=5557a8757ddb56513226abc99859a9114fc3ce69",
      "patch": "@@ -67,7 +67,7 @@ end\n #end\n \n # REPL tests\n-function fake_repl(@nospecialize(f); options::REPL.Options=REPL.Options(confirm_exit=false,style_input=false))\n+function fake_repl(@nospecialize(f); options::REPL.Options=REPL.Options(confirm_exit=false,style_input=false,auto_insert_closing_bracket=false))\n     # Use pipes so we can easily do blocking reads\n     # In the future if we want we can add a test that the right object\n     # gets displayed by intercepting the display\n@@ -121,7 +121,7 @@ end\n # in the mix. If verification needs to be done, keep it to the bare minimum. Basically\n # this should make sure nothing crashes without depending on how exactly the control\n # characters are being used.\n-fake_repl(options = REPL.Options(confirm_exit=false,hascolor=true,style_input=false)) do stdin_write, stdout_read, repl\n+fake_repl(options = REPL.Options(confirm_exit=false,hascolor=true,style_input=false,auto_insert_closing_bracket=false)) do stdin_write, stdout_read, repl\n     repl.specialdisplay = REPL.REPLDisplay(repl)\n     repl.history_file = false\n \n@@ -1893,7 +1893,7 @@ fake_repl() do stdin_write, stdout_read, repl\n     Base.wait(repltask)\n end\n ## hints disabled\n-fake_repl(options=REPL.Options(confirm_exit=false,hascolor=true,hint_tab_completes=false,style_input=false)) do stdin_write, stdout_read, repl\n+fake_repl(options=REPL.Options(confirm_exit=false,hascolor=true,hint_tab_completes=false,style_input=false,auto_insert_closing_bracket=false)) do stdin_write, stdout_read, repl\n     repltask = @async begin\n         REPL.run_repl(repl)\n     end\n@@ -2040,7 +2040,7 @@ end\n                             :julia_number => StyledStrings.Face(foreground=:blue)) do\n \n         # Test that julia_prompt has syntax highlighting passes\n-        fake_repl(options = REPL.Options(confirm_exit=false, style_input=true)) do stdin_write, stdout_read, repl\n+        fake_repl(options = REPL.Options(confirm_exit=false, style_input=true, auto_insert_closing_bracket=false)) do stdin_write, stdout_read, repl\n             repl.interface = REPL.setup_interface(repl)\n             julia_prompt = repl.interface.modes[1]\n             shell_mode = repl.interface.modes[3]\n@@ -2128,7 +2128,7 @@ end\n         end\n \n         # Test that syntax highlighting can be disabled\n-        fake_repl(options = REPL.Options(confirm_exit=false, style_input=false)) do stdin_write, stdout_read, repl\n+        fake_repl(options = REPL.Options(confirm_exit=false, style_input=false, auto_insert_closing_bracket=false)) do stdin_write, stdout_read, repl\n             repl.interface = REPL.setup_interface(repl)\n \n             repltask = @async begin"
    }
  ]
}