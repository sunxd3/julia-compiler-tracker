{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/55601",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/55601/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/55601/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/55601/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/55601",
  "id": 2489847798,
  "node_id": "PR_kwDOABkWpM55mX8r",
  "number": 55601,
  "title": "inference: track reaching defs for slots",
  "user": {
    "login": "topolarity",
    "id": 84105208,
    "node_id": "MDQ6VXNlcjg0MTA1MjA4",
    "avatar_url": "https://avatars.githubusercontent.com/u/84105208?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/topolarity",
    "html_url": "https://github.com/topolarity",
    "followers_url": "https://api.github.com/users/topolarity/followers",
    "following_url": "https://api.github.com/users/topolarity/following{/other_user}",
    "gists_url": "https://api.github.com/users/topolarity/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/topolarity/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/topolarity/subscriptions",
    "organizations_url": "https://api.github.com/users/topolarity/orgs",
    "repos_url": "https://api.github.com/users/topolarity/repos",
    "events_url": "https://api.github.com/users/topolarity/events{/privacy}",
    "received_events_url": "https://api.github.com/users/topolarity/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 414648058,
      "node_id": "MDU6TGFiZWw0MTQ2NDgwNTg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/bugfix",
      "name": "bugfix",
      "color": "15ff91",
      "default": false,
      "description": "This change fixes an existing bug"
    },
    {
      "id": 421532175,
      "node_id": "MDU6TGFiZWw0MjE1MzIxNzU=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:inference",
      "name": "compiler:inference",
      "color": "bfdadc",
      "default": false,
      "description": "Type inference"
    },
    {
      "id": 4232017300,
      "node_id": "LA_kwDOABkWpM78P3WU",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/don't%20squash",
      "name": "don't squash",
      "color": "ff4500",
      "default": false,
      "description": "Don't squash merge"
    },
    {
      "id": 7980098453,
      "node_id": "LA_kwDOABkWpM8AAAAB26ajlQ",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/backport%201.12",
      "name": "backport 1.12",
      "color": "5CAAA4",
      "default": false,
      "description": "Change should be backported to release-1.12"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 20,
  "created_at": "2024-08-27T16:24:56Z",
  "updated_at": "2025-12-30T15:55:39Z",
  "closed_at": "2025-12-30T15:55:39Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/55601",
    "html_url": "https://github.com/JuliaLang/julia/pull/55601",
    "diff_url": "https://github.com/JuliaLang/julia/pull/55601.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/55601.patch",
    "merged_at": "2025-12-30T15:55:38Z"
  },
  "body": "This PR implements the \"Path-Convergence Criterion\" for SSA / \u03d5-nodes as part of type-inference.\r\n\r\nThe `VarState.ssadef` field corresponds to the \"reaching definition\" of the slot in SSA form, which allows us to conveniently reason about the identity of a `slot` across multiple program points. If the reaching def is equal at two program points, then the slot contents are guaranteed to be egal (i.e. `x\u2080 === x\u2081`)\r\n\r\nTasks:\r\n - [x] Split `StateRefinement` change to separate PR\r\n - [x] Split `VarTable` plumbing to separate PR\r\n - [x] Remove old `Conditional` invalidation logic\r\n - [x] Add tests\r\n \r\n Fixes #55548 (alternative to https://github.com/JuliaLang/julia/pull/55551), by having `Conditional` remember the reaching definition that it narrows.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/55601/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/55601/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "96d03102a82a6a9aea9b1c493cbad9f5ec7ea994",
      "filename": "Compiler/src/abstractinterpretation.jl",
      "status": "modified",
      "additions": 159,
      "deletions": 93,
      "changes": 252,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fabstractinterpretation.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -30,12 +30,12 @@ function propagate_conditional(rt::InterConditional, cond::Conditional)\n     new_elsetype = rt.elsetype === Const(true) ? cond.thentype : cond.elsetype\n     if rt.thentype == Bottom\n         @assert rt.elsetype != Bottom\n-        return Conditional(cond.slot, Bottom, new_elsetype)\n+        return Conditional(cond.slot, cond.ssadef, Bottom, new_elsetype)\n     elseif rt.elsetype == Bottom\n         @assert rt.thentype != Bottom\n-        return Conditional(cond.slot, new_thentype, Bottom)\n+        return Conditional(cond.slot, cond.ssadef, new_thentype, Bottom)\n     end\n-    return Conditional(cond.slot, new_thentype, new_elsetype)\n+    return Conditional(cond.slot, cond.ssadef, new_thentype, new_elsetype)\n end\n \n mutable struct SafeBox{T}\n@@ -108,7 +108,7 @@ end\n \n function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(func),\n                                   arginfo::ArgInfo, si::StmtInfo, @nospecialize(atype),\n-                                  sv::AbsIntState, max_methods::Int)\n+                                  vtypes::Union{VarTable,Nothing}, sv::AbsIntState, max_methods::Int)\n     \ud835\udd43\u209a, \ud835\udd43\u1d62 = ipo_lattice(interp), typeinf_lattice(interp)\n     \u2291\u209a, \u2294\u209a, \u2294\u1d62  = partialorder(\ud835\udd43\u209a), join(\ud835\udd43\u209a), join(\ud835\udd43\u1d62)\n     argtypes = arginfo.argtypes\n@@ -264,7 +264,7 @@ function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(fun\n             if sv isa InferenceState && fargs !== nothing\n                 state.slotrefinements = collect_slot_refinements(\ud835\udd43\u1d62, applicable, argtypes, fargs, sv)\n             end\n-            state.rettype = from_interprocedural!(interp, state.rettype, sv, arginfo, state.conditionals)\n+            state.rettype = from_interprocedural!(interp, state.rettype, sv, arginfo, state.conditionals, vtypes)\n             if call_result_unused(si) && !(state.rettype === Bottom)\n                 add_remark!(interp, sv, \"Call result type was widened because the return value is unused\")\n                 # We're mainly only here because the optimizer might want this code,\n@@ -408,15 +408,15 @@ When we deal with multiple `MethodMatch`es, it's better to precompute `maybecond\n `tmerge`ing argument signature type of each method call.\n \"\"\"\n function from_interprocedural!(interp::AbstractInterpreter, @nospecialize(rt), sv::AbsIntState,\n-                               arginfo::ArgInfo, @nospecialize(maybecondinfo))\n+                               arginfo::ArgInfo, @nospecialize(maybecondinfo), vtypes::Union{VarTable,Nothing})\n     rt = collect_limitations!(rt, sv)\n     if isa(rt, InterMustAlias)\n-        rt = from_intermustalias(typeinf_lattice(interp), rt, arginfo, sv)\n+        rt = from_intermustalias(typeinf_lattice(interp), rt, arginfo, vtypes, sv)\n     elseif is_lattice_bool(ipo_lattice(interp), rt)\n         if maybecondinfo === nothing\n             rt = widenconditional(rt)\n         else\n-            rt = from_interconditional(typeinf_lattice(interp), rt, sv, arginfo, maybecondinfo)\n+            rt = from_interconditional(typeinf_lattice(interp), rt, sv, arginfo, maybecondinfo, vtypes)\n         end\n     end\n     @assert !(rt isa InterConditional || rt isa InterMustAlias) \"invalid lattice element returned from inter-procedural context\"\n@@ -431,15 +431,17 @@ function collect_limitations!(@nospecialize(typ), sv::InferenceState)\n     return typ\n end\n \n-function from_intermustalias(\ud835\udd43\u1d62::AbstractLattice, rt::InterMustAlias, arginfo::ArgInfo, sv::AbsIntState)\n+function from_intermustalias(\ud835\udd43\u1d62::AbstractLattice, rt::InterMustAlias, arginfo::ArgInfo, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)\n     fargs = arginfo.fargs\n     if fargs !== nothing && 1 \u2264 rt.slot \u2264 length(fargs)\n         arg = ssa_def_slot(fargs[rt.slot], sv)\n         if isa(arg, SlotNumber)\n+            @assert vtypes !== nothing\n             argtyp = widenslotwrapper(arginfo.argtypes[rt.slot])\n             \u2291 = partialorder(\ud835\udd43\u1d62)\n             if rt.vartyp \u2291 argtyp\n-                return MustAlias(arg, rt.vartyp, rt.fldidx, rt.fldtyp)\n+                vtyp = vtypes[slot_id(arg)]\n+                return MustAlias(arg, vtyp.ssadef, rt.vartyp, rt.fldidx, rt.fldtyp)\n             else\n                 # TODO optimize this case?\n             end\n@@ -449,7 +451,7 @@ function from_intermustalias(\ud835\udd43\u1d62::AbstractLattice, rt::InterMustAlias, argin\n end\n \n function from_interconditional(\ud835\udd43\u1d62::AbstractLattice, @nospecialize(rt), sv::AbsIntState,\n-                               arginfo::ArgInfo, @nospecialize(maybecondinfo))\n+                               arginfo::ArgInfo, @nospecialize(maybecondinfo), vtypes::Union{VarTable,Nothing})\n     has_conditional(\ud835\udd43\u1d62, sv) || return widenconditional(rt)\n     (; fargs, argtypes) = arginfo\n     fargs === nothing && return widenconditional(rt)\n@@ -531,7 +533,8 @@ function from_interconditional(\ud835\udd43\u1d62::AbstractLattice, @nospecialize(rt), sv::\n         if alias !== nothing\n             return form_mustalias_conditional(alias, thentype, elsetype)\n         end\n-        return Conditional(slot, thentype, elsetype) # record a Conditional improvement to this slot\n+        @assert vtypes !== nothing\n+        return Conditional(slot, vtypes[slot].ssadef, thentype, elsetype) # record a Conditional improvement to this slot\n     end\n     return widenconditional(rt)\n end\n@@ -1397,7 +1400,7 @@ function matching_cache_argtypes(\ud835\udd43::AbstractLattice, mi::MethodInstance,\n                     # TODO bail out here immediately rather than just propagating Bottom ?\n                     given_argtypes[i] = Bottom\n                 else\n-                    given_argtypes[i] = Conditional(slotid, thentype, elsetype)\n+                    given_argtypes[i] = Conditional(slotid, #= ssadef =# 0, thentype, elsetype)\n                 end\n                 continue\n             end\n@@ -1475,7 +1478,7 @@ AbstractIterationResult(cti::Vector{Any}, info::MaybeAbstractIterationInfo) =\n # Union of Tuples of the same length is converted to Tuple of Unions.\n # returns an array of types\n function precise_container_type(interp::AbstractInterpreter, @nospecialize(itft), @nospecialize(typ),\n-                                sv::AbsIntState)\n+                                vtypes::Union{VarTable,Nothing}, sv::AbsIntState)\n     if isa(typ, PartialStruct)\n         widet = typ.typ\n         if isa(widet, DataType)\n@@ -1561,12 +1564,13 @@ function precise_container_type(interp::AbstractInterpreter, @nospecialize(itft)\n         end\n         return Future(AbstractIterationResult(Any[Vararg{eltype(tti0)}], nothing))\n     else\n-        return abstract_iteration(interp, itft, typ, sv)\n+        return abstract_iteration(interp, itft, typ, vtypes, sv)\n     end\n end\n \n # simulate iteration protocol on container type up to fixpoint\n-function abstract_iteration(interp::AbstractInterpreter, @nospecialize(itft), @nospecialize(itertype), sv::AbsIntState)\n+function abstract_iteration(interp::AbstractInterpreter, @nospecialize(itft), @nospecialize(itertype),\n+                            vtypes::Union{VarTable,Nothing}, sv::AbsIntState)\n     if isa(itft, Const)\n         iteratef = itft.val\n     else\n@@ -1575,7 +1579,7 @@ function abstract_iteration(interp::AbstractInterpreter, @nospecialize(itft), @n\n     @assert !isvarargtype(itertype)\n \n     iterateresult = Future{AbstractIterationResult}()\n-    call1future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[itft, itertype]), StmtInfo(true, false), sv)::Future\n+    call1future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[itft, itertype]), StmtInfo(true, false), vtypes, sv)::Future\n     function inferiterate(interp, sv)\n         call1 = call1future[]\n         stateordonet = call1.rt\n@@ -1631,7 +1635,7 @@ function abstract_iteration(interp::AbstractInterpreter, @nospecialize(itft), @n\n                 valtype = getfield_tfunc(\ud835\udd43\u1d62, stateordonet, Const(1))\n                 push!(ret, valtype)\n                 statetype = nstatetype\n-                call2future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[Const(iteratef), itertype, statetype]), StmtInfo(true, false), sv)::Future\n+                call2future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[Const(iteratef), itertype, statetype]), StmtInfo(true, false), vtypes, sv)::Future\n                 if !isready(call2future)\n                     nextstate = 0x1\n                     return false\n@@ -1673,7 +1677,7 @@ function abstract_iteration(interp::AbstractInterpreter, @nospecialize(itft), @n\n                 end\n                 valtype = tmerge(valtype, nounion.parameters[1])\n                 statetype = tmerge(statetype, nounion.parameters[2])\n-                call2future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[Const(iteratef), itertype, statetype]), StmtInfo(true, false), sv)::Future\n+                call2future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[Const(iteratef), itertype, statetype]), StmtInfo(true, false), vtypes, sv)::Future\n                 if !isready(call2future)\n                     nextstate = 0x2\n                     return false\n@@ -1704,7 +1708,8 @@ end\n \n # do apply(af, fargs...), where af is a function value\n function abstract_apply(interp::AbstractInterpreter, argtypes::Vector{Any}, si::StmtInfo,\n-                        sv::AbsIntState, max_methods::Int=get_max_methods(interp, sv))\n+                        vtypes::Union{VarTable,Nothing}, sv::AbsIntState,\n+                        max_methods::Int=get_max_methods(interp, sv))\n     itft = Core.Box(argtype_by_index(argtypes, 2))\n     aft = argtype_by_index(argtypes, 3)\n     (itft.contents === Bottom || aft === Bottom) && return Future(CallMeta(Bottom, Any, EFFECTS_THROWS, NoCallInfo()))\n@@ -1763,15 +1768,15 @@ function abstract_apply(interp::AbstractInterpreter, argtypes::Vector{Any}, si::\n                 ti = argtypesi[j]\n                 j += 1\n                 if !isvarargtype(ti)\n-                    ctfuture = precise_container_type(interp, itft.contents, ti, sv)::Future\n+                    ctfuture = precise_container_type(interp, itft.contents, ti, vtypes, sv)::Future\n                     if !isready(ctfuture)\n                         nextstate = 0x1\n                         return false\n                         @label state1\n                     end\n                     (;cti, info, ai_effects) = ctfuture[]\n                 else\n-                    ctfuture = precise_container_type(interp, itft.contents, unwrapva(ti), sv)::Future\n+                    ctfuture = precise_container_type(interp, itft.contents, unwrapva(ti), vtypes, sv)::Future\n                     if !isready(ctfuture)\n                         nextstate = 0x2\n                         return false\n@@ -1842,7 +1847,7 @@ function abstract_apply(interp::AbstractInterpreter, argtypes::Vector{Any}, si::\n                     break\n                 end\n             end\n-            callfuture = abstract_call(interp, ArgInfo(nothing, ct), si, sv, max_methods)::Future\n+            callfuture = abstract_call(interp, ArgInfo(nothing, ct), si, vtypes, sv, max_methods)::Future\n             if !isready(callfuture)\n                 nextstate = 0x3\n                 return false\n@@ -1944,7 +1949,7 @@ end\n end\n \n function abstract_call_builtin(interp::AbstractInterpreter, f::Builtin, (; fargs, argtypes)::ArgInfo,\n-                               sv::AbsIntState)\n+                               vtypes::Union{VarTable,Nothing}, sv::AbsIntState)\n     @nospecialize f\n     la = length(argtypes)\n     \ud835\udd43\u1d62 = typeinf_lattice(interp)\n@@ -1985,7 +1990,9 @@ function abstract_call_builtin(interp::AbstractInterpreter, f::Builtin, (; fargs\n                     fldidx = maybe_const_fldidx(vartyp, a3.val)\n                     if fldidx !== nothing\n                         # wrap this aliasable field into `MustAlias` for possible constraint propagations\n-                        return MustAlias(var, vartyp, fldidx, rt)\n+                        @assert vtypes !== nothing\n+                        vtyp = vtypes[slot_id(var)]\n+                        return MustAlias(var, vtyp.ssadef, vartyp, fldidx, rt)\n                     end\n                 end\n             end\n@@ -2000,7 +2007,9 @@ function abstract_call_builtin(interp::AbstractInterpreter, f::Builtin, (; fargs\n             if isa(a, SlotNumber)\n                 cndt = isa_condition(a2, a3, InferenceParams(interp).max_union_splitting, rt)\n                 if cndt !== nothing\n-                    return Conditional(a, cndt.thentype, cndt.elsetype)\n+                    @assert vtypes !== nothing\n+                    vtyp = vtypes[slot_id(a)]\n+                    return Conditional(a, vtyp.ssadef, cndt.thentype, cndt.elsetype)\n                 end\n             end\n             if isa(a2, MustAlias)\n@@ -2018,7 +2027,9 @@ function abstract_call_builtin(interp::AbstractInterpreter, f::Builtin, (; fargs\n                     # !(x isa T) implies !(Type{a2} <: T)\n                     # TODO: complete splitting, based on which portions of the Union a3 for which isa_tfunc returns Const(true) or Const(false) instead of Bool\n                     elsetype = typesubtract(a3, Type{widenconst(a2)}, InferenceParams(interp).max_union_splitting)\n-                    return Conditional(b, a3, elsetype)\n+                    @assert vtypes !== nothing\n+                    vtyp = vtypes[slot_id(b)]\n+                    return Conditional(b, vtyp.ssadef, a3, elsetype)\n                 end\n             end\n         elseif f === (===)\n@@ -2029,16 +2040,20 @@ function abstract_call_builtin(interp::AbstractInterpreter, f::Builtin, (; fargs\n             # if doing a comparison to a singleton, consider returning a `Conditional` instead\n             if isa(aty, Const)\n                 if isa(b, SlotNumber)\n+                    @assert vtypes !== nothing\n+                    vtyp = vtypes[slot_id(b)]\n                     cndt = egal_condition(aty, bty, InferenceParams(interp).max_union_splitting, rt)\n-                    return Conditional(b, cndt.thentype, cndt.elsetype)\n+                    return Conditional(b, vtyp.ssadef, cndt.thentype, cndt.elsetype)\n                 elseif isa(bty, MustAlias) && !isa(rt, Const) # skip refinement when the field is known precisely (just optimization)\n                     cndt = egal_condition(aty, bty.fldtyp, InferenceParams(interp).max_union_splitting)\n                     return form_mustalias_conditional(bty, cndt.thentype, cndt.elsetype)\n                 end\n             elseif isa(bty, Const)\n                 if isa(a, SlotNumber)\n+                    @assert vtypes !== nothing\n+                    vtyp = vtypes[slot_id(a)]\n                     cndt = egal_condition(bty, aty, InferenceParams(interp).max_union_splitting, rt)\n-                    return Conditional(a, cndt.thentype, cndt.elsetype)\n+                    return Conditional(a, vtyp.ssadef, cndt.thentype, cndt.elsetype)\n                 elseif isa(aty, MustAlias) && !isa(rt, Const) # skip refinement when the field is known precisely (just optimization)\n                     cndt = egal_condition(bty, aty.fldtyp, InferenceParams(interp).max_union_splitting)\n                     return form_mustalias_conditional(aty, cndt.thentype, cndt.elsetype)\n@@ -2069,18 +2084,24 @@ function abstract_call_builtin(interp::AbstractInterpreter, f::Builtin, (; fargs\n             if isa(b, SlotNumber)\n                 thentype = rt === Const(false) ? Bottom : widenslotwrapper(bty)\n                 elsetype = rt === Const(true)  ? Bottom : widenslotwrapper(bty)\n-                return Conditional(b, thentype, elsetype)\n+                @assert vtypes !== nothing\n+                vtyp = vtypes[slot_id(b)]\n+                return Conditional(b, vtyp.ssadef, thentype, elsetype)\n             elseif isa(a, SlotNumber)\n                 thentype = rt === Const(false) ? Bottom : widenslotwrapper(aty)\n                 elsetype = rt === Const(true)  ? Bottom : widenslotwrapper(aty)\n-                return Conditional(a, thentype, elsetype)\n+                @assert vtypes !== nothing\n+                vtyp = vtypes[slot_id(a)]\n+                return Conditional(a, vtyp.ssadef, thentype, elsetype)\n             end\n         elseif f === Core.Intrinsics.not_int\n             aty = argtypes[2]\n             if isa(aty, Conditional)\n                 thentype = rt === Const(false) ? Bottom : aty.elsetype\n                 elsetype = rt === Const(true)  ? Bottom : aty.thentype\n-                return Conditional(aty.slot, thentype, elsetype)\n+                @assert vtypes !== nothing\n+                vtyp = vtypes[aty.slot]\n+                return Conditional(aty.slot, vtyp.ssadef, thentype, elsetype)\n             end\n         elseif f === isdefined\n             a = ssa_def_slot(fargs[2], sv)\n@@ -2103,7 +2124,9 @@ function abstract_call_builtin(interp::AbstractInterpreter, f::Builtin, (; fargs\n                             elsetype = elsetype \u2294 ty\n                         end\n                     end\n-                    return Conditional(a, thentype, elsetype)\n+                    @assert vtypes !== nothing\n+                    vtyp = vtypes[slot_id(a)]\n+                    return Conditional(a, vtyp.ssadef, thentype, elsetype)\n                 else\n                     thentype = form_partially_defined_struct(\ud835\udd43\u1d62, argtype2, argtypes[3])\n                     if thentype !== nothing\n@@ -2113,7 +2136,9 @@ function abstract_call_builtin(interp::AbstractInterpreter, f::Builtin, (; fargs\n                         elseif rt === Const(true)\n                             elsetype = Bottom\n                         end\n-                        return Conditional(a, thentype, elsetype)\n+                        @assert vtypes !== nothing\n+                        vtyp = vtypes[slot_id(a)]\n+                        return Conditional(a, vtyp.ssadef, thentype, elsetype)\n                     end\n                 end\n             end\n@@ -2208,7 +2233,7 @@ function get_ci_abi(ci::CodeInstance)\n     (def::MethodInstance).specTypes\n end\n \n-function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::StmtInfo, sv::AbsIntState)\n+function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::StmtInfo, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)\n     argtypes = arginfo.argtypes\n     ft\u2032 = argtype_by_index(argtypes, 2)\n     ft = widenconst(ft\u2032)\n@@ -2318,7 +2343,7 @@ function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::Stmt\n                 call_result = const_result\n             end\n         end\n-        rt = from_interprocedural!(interp, rt, sv, arginfo\u2032, sig)\n+        rt = from_interprocedural!(interp, rt, sv, arginfo\u2032, sig, vtypes)\n         info = InvokeCallInfo(edge, match, call_result, lookupsig_box.contents)\n         if !match.fully_covers\n             effects = Effects(effects; nothrow=false)\n@@ -2335,10 +2360,10 @@ function invoke_rewrite(xs::Vector{Any})\n     return newxs\n end\n \n-function abstract_finalizer(interp::AbstractInterpreter, argtypes::Vector{Any}, sv::AbsIntState)\n+function abstract_finalizer(interp::AbstractInterpreter, argtypes::Vector{Any}, vtypes, sv::AbsIntState)\n     if length(argtypes) == 3\n         finalizer_argvec = Any[argtypes[2], argtypes[3]]\n-        call = abstract_call(interp, ArgInfo(nothing, finalizer_argvec), StmtInfo(false, false), sv, #=max_methods=#1)::Future\n+        call = abstract_call(interp, ArgInfo(nothing, finalizer_argvec), StmtInfo(false, false), vtypes, sv, #=max_methods=#1)::Future\n         return Future{CallMeta}(call, interp, sv) do call, _, _\n             return CallMeta(Nothing, Any, Effects(), FinalizerInfo(call.info, call.effects))\n         end\n@@ -2636,23 +2661,23 @@ end\n \n # call where the function is known exactly\n function abstract_call_known(interp::AbstractInterpreter, @nospecialize(f),\n-        arginfo::ArgInfo, si::StmtInfo, sv::AbsIntState,\n-        max_methods::Int = get_max_methods(interp, f, sv))\n+        arginfo::ArgInfo, si::StmtInfo, vtypes::Union{VarTable,Nothing},\n+        sv::AbsIntState, max_methods::Int = get_max_methods(interp, f, sv))\n     (; fargs, argtypes) = arginfo\n     argtypes::Vector{Any} = arginfo.argtypes  # declare type because the closure below captures `argtypes`\n     fargs = arginfo.fargs\n     la = length(argtypes)\n     \ud835\udd43\u1d62 = typeinf_lattice(interp)\n     if isa(f, Builtin)\n         if f === _apply_iterate\n-            return abstract_apply(interp, argtypes, si, sv, max_methods)\n+            return abstract_apply(interp, argtypes, si, vtypes, sv, max_methods)\n         elseif f === invoke\n-            return abstract_invoke(interp, arginfo, si, sv)\n+            return abstract_invoke(interp, arginfo, si, vtypes, sv)\n         elseif f === modifyfield! || f === Core.modifyglobal! ||\n                f === Core.memoryrefmodify! || f === atomic_pointermodify\n-            return abstract_modifyop!(interp, f, argtypes, si, sv)\n+            return abstract_modifyop!(interp, f, argtypes, si, vtypes, sv)\n         elseif f === Core.finalizer\n-            return abstract_finalizer(interp, argtypes, sv)\n+            return abstract_finalizer(interp, argtypes, vtypes, sv)\n         elseif f === applicable\n             return abstract_applicable(interp, argtypes, sv, max_methods)\n         elseif f === throw\n@@ -2680,7 +2705,7 @@ function abstract_call_known(interp::AbstractInterpreter, @nospecialize(f),\n         elseif f === Core.get_binding_type\n             return Future(abstract_eval_get_binding_type(interp, sv, argtypes))\n         end\n-        rt = abstract_call_builtin(interp, f, arginfo, sv)\n+        rt = abstract_call_builtin(interp, f, arginfo, vtypes, sv)\n         ft = popfirst!(argtypes)\n         effects = builtin_effects(\ud835\udd43\u1d62, f, argtypes, rt)\n         if effects.nothrow\n@@ -2726,7 +2751,7 @@ function abstract_call_known(interp::AbstractInterpreter, @nospecialize(f),\n             resize!(T, la)\n             atype = Tuple{T...}\n             T[1] = Const(TypeVar)\n-            let call = abstract_call_gf_by_type(interp, f, ArgInfo(nothing, T), si, atype, sv, max_methods)::Future\n+            let call = abstract_call_gf_by_type(interp, f, ArgInfo(nothing, T), si, atype, vtypes, sv, max_methods)::Future\n                 return Future{CallMeta}(call, interp, sv) do call, interp, sv\n                     n = argtypes[2]\n                     ub_var = Const(Any)\n@@ -2750,7 +2775,7 @@ function abstract_call_known(interp::AbstractInterpreter, @nospecialize(f),\n             end\n         end\n     elseif f === UnionAll\n-        let call = abstract_call_gf_by_type(interp, f, ArgInfo(nothing, Any[Const(UnionAll), Any, Any]), si, Tuple{Type{UnionAll}, Any, Any}, sv, max_methods)::Future\n+        let call = abstract_call_gf_by_type(interp, f, ArgInfo(nothing, Any[Const(UnionAll), Any, Any]), si, Tuple{Type{UnionAll}, Any, Any}, vtypes, sv, max_methods)::Future\n             return Future{CallMeta}(call, interp, sv) do call, interp, sv\n                 return abstract_call_unionall(interp, argtypes, call)\n             end\n@@ -2765,12 +2790,12 @@ function abstract_call_known(interp::AbstractInterpreter, @nospecialize(f),\n         return return_type_tfunc(interp, argtypes, si, sv)\n     elseif la == 3 && f === Core.:(!==)\n         # mark !== as exactly a negated call to ===\n-        let callfuture = abstract_call_gf_by_type(interp, f, ArgInfo(fargs, Any[Const(f), Any, Any]), si, Tuple{typeof(f), Any, Any}, sv, max_methods)::Future,\n-            rtfuture = abstract_call_known(interp, (===), arginfo, si, sv, max_methods)::Future\n+        let callfuture = abstract_call_gf_by_type(interp, f, ArgInfo(fargs, Any[Const(f), Any, Any]), si, Tuple{typeof(f), Any, Any}, vtypes, sv, max_methods)::Future,\n+            rtfuture = abstract_call_known(interp, (===), arginfo, si, vtypes, sv, max_methods)::Future\n             return Future{CallMeta}(isready(callfuture) && isready(rtfuture), interp, sv) do interp, sv\n                 local rty = rtfuture[].rt\n                 if isa(rty, Conditional)\n-                    return CallMeta(Conditional(rty.slot, rty.elsetype, rty.thentype), Bottom, EFFECTS_TOTAL, NoCallInfo()) # swap if-else\n+                    return CallMeta(Conditional(rty.slot, rty.ssadef, rty.elsetype, rty.thentype), Bottom, EFFECTS_TOTAL, NoCallInfo()) # swap if-else\n                 elseif isa(rty, Const)\n                     return CallMeta(Const(rty.val === false), Bottom, EFFECTS_TOTAL, MethodResultPure())\n                 end\n@@ -2786,18 +2811,18 @@ function abstract_call_known(interp::AbstractInterpreter, @nospecialize(f),\n             fargs = nothing\n         end\n         argtypes = Any[typeof(<:), argtypes[3], argtypes[2]]\n-        return abstract_call_known(interp, <:, ArgInfo(fargs, argtypes), si, sv, max_methods)\n+        return abstract_call_known(interp, <:, ArgInfo(fargs, argtypes), si, vtypes, sv, max_methods)\n     elseif la == 2 && f === Core.typename\n         return Future(CallMeta(typename_static(argtypes[2]), Bottom, EFFECTS_TOTAL, MethodResultPure()))\n     elseif f === Core._hasmethod\n         return Future(_hasmethod_tfunc(interp, argtypes, sv))\n     end\n     atype = argtypes_to_type(argtypes)\n-    return abstract_call_gf_by_type(interp, f, arginfo, si, atype, sv, max_methods)::Future\n+    return abstract_call_gf_by_type(interp, f, arginfo, si, atype, vtypes, sv, max_methods)::Future\n end\n \n-function abstract_call_opaque_closure(interp::AbstractInterpreter,\n-    closure::PartialOpaque, arginfo::ArgInfo, si::StmtInfo, sv::AbsIntState, check::Bool=true)\n+function abstract_call_opaque_closure(interp::AbstractInterpreter, closure::PartialOpaque,\n+    arginfo::ArgInfo, si::StmtInfo, vtypes::Union{VarTable,Nothing}, sv::AbsIntState, check::Bool=true)\n     sig = argtypes_to_type(arginfo.argtypes)\n     tt = closure.typ\n     ocargsig = rewrap_unionall((unwrap_unionall(tt)::DataType).parameters[1], tt)\n@@ -2850,7 +2875,7 @@ function abstract_call_opaque_closure(interp::AbstractInterpreter,\n                 exct = exct \u2294 TypeError\n             end\n         end\n-        rt = from_interprocedural!(interp, rt, sv, arginfo, match.spec_types)\n+        rt = from_interprocedural!(interp, rt, sv, arginfo, match.spec_types, vtypes)\n         info = OpaqueClosureCallInfo(edge, match, call_result)\n         return CallMeta(rt, exct, effects, info)\n     end\n@@ -2866,13 +2891,13 @@ function most_general_argtypes(closure::PartialOpaque)\n end\n \n function abstract_call_unknown(interp::AbstractInterpreter, @nospecialize(ft),\n-                               arginfo::ArgInfo, si::StmtInfo, sv::AbsIntState,\n-                               max_methods::Int)\n+                               arginfo::ArgInfo, si::StmtInfo, vtypes::Union{VarTable,Nothing},\n+                               sv::AbsIntState, max_methods::Int)\n     if isa(ft, PartialOpaque)\n         newargtypes = copy(arginfo.argtypes)\n         newargtypes[1] = ft.env\n         return abstract_call_opaque_closure(interp,\n-            ft, ArgInfo(arginfo.fargs, newargtypes), si, sv, #=check=#true)\n+            ft, ArgInfo(arginfo.fargs, newargtypes), si, vtypes, sv, #=check=#true)\n     end\n     wft = widenconst(ft)\n     if hasintersect(wft, Builtin)\n@@ -2888,20 +2913,22 @@ function abstract_call_unknown(interp::AbstractInterpreter, @nospecialize(ft),\n     # non-constant function, but the number of arguments is known and the `f` is not a builtin or intrinsic\n     atype = argtypes_to_type(arginfo.argtypes)\n     atype === Bottom && return Future(CallMeta(Union{}, Union{}, EFFECTS_THROWS, NoCallInfo())) # accidentally unreachable\n-    return abstract_call_gf_by_type(interp, nothing, arginfo, si, atype, sv, max_methods)::Future\n+    return abstract_call_gf_by_type(interp, nothing, arginfo, si, atype, vtypes, sv, max_methods)::Future\n end\n \n+# TODO: abstract\n+\n # call where the function is any lattice element\n function abstract_call(interp::AbstractInterpreter, arginfo::ArgInfo, si::StmtInfo,\n-                       sv::AbsIntState, max_methods::Int=typemin(Int))\n+                       vtypes::Union{VarTable,Nothing}, sv::AbsIntState, max_methods::Int=typemin(Int))\n     ft = widenslotwrapper(arginfo.argtypes[1])\n     f = singleton_type(ft)\n     if f === nothing\n         max_methods = max_methods == typemin(Int) ? get_max_methods(interp, sv) : max_methods\n-        return abstract_call_unknown(interp, ft, arginfo, si, sv, max_methods)\n+        return abstract_call_unknown(interp, ft, arginfo, si, vtypes, sv, max_methods)\n     end\n     max_methods = max_methods == typemin(Int) ? get_max_methods(interp, f, sv) : max_methods\n-    return abstract_call_known(interp, f, arginfo, si, sv, max_methods)\n+    return abstract_call_known(interp, f, arginfo, si, vtypes, sv, max_methods)\n end\n \n function sp_type_rewrap(@nospecialize(T), mi::MethodInstance, isreturn::Bool)\n@@ -2960,7 +2987,7 @@ function abstract_eval_cfunction(interp::AbstractInterpreter, e::Expr, sstate::S\n     # this may be the wrong world for the call,\n     # but some of the result is likely to be valid anyways\n     # and that may help generate better codegen\n-    abstract_call(interp, ArgInfo(nothing, at), StmtInfo(false, false), sv)::Future\n+    abstract_call(interp, ArgInfo(nothing, at), StmtInfo(false, false), sstate.vtypes, sv)::Future\n     rt = e.args[1]\n     isconcretetype(rt) || (rt = Any)\n     return RTEffects(rt, Any, EFFECTS_UNKNOWN)\n@@ -3054,7 +3081,7 @@ function abstract_call(interp::AbstractInterpreter, arginfo::ArgInfo, sstate::St\n         add_curr_ssaflag!(sv, IR_FLAG_UNUSED)\n     end\n     si = StmtInfo(!unused, sstate.saw_latestworld)\n-    call = abstract_call(interp, arginfo, si, sv)::Future\n+    call = abstract_call(interp, arginfo, si, sstate.vtypes, sv)::Future\n     Future{Any}(call, interp, sv) do call, _, sv\n         # this only is needed for the side-effect, sequenced before any task tries to consume the return value,\n         # which this will do even without returning this Future\n@@ -3240,7 +3267,7 @@ function abstract_eval_new_opaque_closure(interp::AbstractInterpreter, e::Expr,\n                 argtypes = most_general_argtypes(rt)\n                 pushfirst!(argtypes, rt.env)\n                 callinfo = abstract_call_opaque_closure(interp, rt,\n-                    ArgInfo(nothing, argtypes), StmtInfo(true, false), sv, #=check=#false)::Future\n+                    ArgInfo(nothing, argtypes), StmtInfo(true, false), sstate.vtypes, sv, #=check=#false)::Future\n                 Future{Any}(callinfo, interp, sv) do callinfo, _, sv\n                     sv.stmt_info[sv.currpc] = OpaqueClosureCreateInfo(callinfo)\n                     nothing\n@@ -3272,7 +3299,7 @@ function abstract_eval_isdefined_expr(::AbstractInterpreter, e::Expr, sstate::St\n         elseif !vtyp.undef\n             rt = Const(true) # definitely assigned previously\n         else # form `Conditional` to refine `vtyp.undef` in the then branch\n-            rt = Conditional(sym, widenslotwrapper(vtyp.typ), widenslotwrapper(vtyp.typ); isdefined=true)\n+            rt = Conditional(sym, vtyp.ssadef, widenslotwrapper(vtyp.typ), widenslotwrapper(vtyp.typ); isdefined=true)\n         end\n         return RTEffects(rt, Union{}, EFFECTS_TOTAL)\n     end\n@@ -3802,7 +3829,7 @@ end\n         @goto injectresult\n     end\n     if isa(stmt, NewvarNode)\n-        changes = StateUpdate(stmt.slot, VarState(Bottom, true))\n+        changes = StateUpdate(stmt.slot, VarState(Bottom, frame.currpc, #= undef =# true))\n     elseif isa(stmt, PhiNode)\n         add_curr_ssaflag!(frame, IR_FLAGS_REMOVABLE)\n         # Implement convergence for PhiNodes. In particular, PhiNodes need to tmerge over\n@@ -3825,7 +3852,7 @@ end\n             if hd === :method\n                 fname = stmt.args[1]\n                 if isa(fname, SlotNumber)\n-                    changes = StateUpdate(fname, VarState(Any, false))\n+                    changes = StateUpdate(fname, VarState(Any, frame.currpc, #= undef =# false))\n                 end\n             elseif (hd === :code_coverage_effect ||\n                     # :boundscheck can be narrowed to Bool\n@@ -3871,7 +3898,7 @@ end\n             end\n         end\n         if lhs !== nothing && rt !== Bottom\n-            changes = StateUpdate(lhs::SlotNumber, VarState(rt, false))\n+            changes = StateUpdate(lhs::SlotNumber, VarState(rt, frame.currpc, #= undef =# false))\n         end\n     end\n     return AbstractEvalBasicStatementResult(rt, exct, effects, changes, refinements, currsaw_latestworld)\n@@ -3902,7 +3929,7 @@ end\n \n @nospecializeinfer function widenreturn(\ud835\udd43\u1d62::MustAliasesLattice, @nospecialize(rt), info::BestguessInfo)\n     if isa(rt, MustAlias)\n-        if 1 \u2264 rt.slot \u2264 info.nargs\n+        if 1 \u2264 rt.slot \u2264 info.nargs && rt.ssadef == 0\n             rt = InterMustAlias(rt)\n         else\n             rt = widenmustalias(rt)\n@@ -3937,13 +3964,13 @@ end\n                 rt = widenconditional(rt)\n             end\n         end\n-        if isa(rt, Conditional)\n+        if isa(rt, Conditional) && rt.ssadef == 0\n             rt = InterConditional(rt.slot, rt.thentype, rt.elsetype)\n         elseif is_lattice_bool(\ud835\udd43\u1d62, rt)\n             rt = bool_rt_to_conditional(rt, info)\n         end\n     end\n-    if isa(rt, Conditional)\n+    if isa(rt, Conditional) && rt.ssadef == 0\n         rt = InterConditional(rt)\n     end\n     isa(rt, InterConditional) && return rt\n@@ -4056,14 +4083,17 @@ function update_bbstate!(\ud835\udd43\u1d62::AbstractLattice, frame::InferenceState, bb::In\n         frame.bb_vartables[bb] = copy(vartable)\n         return true\n     else\n-        return stupdate!(\ud835\udd43\u1d62, bbtable, vartable)\n+        pc = first(frame.cfg.blocks[bb].stmts)\n+        # Minus sign marks this as a \"virtual\" PC so that it is\n+        # not confused with a real assignment at this PC.\n+        return stupdate!(\ud835\udd43\u1d62, bbtable, vartable, -pc)\n     end\n end\n \n function init_vartable!(vartable::VarTable, frame::InferenceState)\n     nargtypes = length(frame.result.argtypes)\n     for i = 1:length(vartable)\n-        vartable[i] = VarState(Bottom, i > nargtypes)\n+        vartable[i] = VarState(Bottom, #= ssadef =# typemin(Int), i > nargtypes)\n     end\n     return vartable\n end\n@@ -4227,9 +4257,10 @@ function typeinf_local(interp::AbstractInterpreter, frame::InferenceState, nextr\n                     end\n                     orig_condt = condt\n                     if !(isa(condt, Const) || isa(condt, Conditional)) && isa(condslot, SlotNumber)\n+                        vtyp = currstate[slot_id(condslot)]\n                         # if this non-`Conditional` object is a slot, we form and propagate\n                         # the conditional constraint on it\n-                        condt = Conditional(condslot, Const(true), Const(false))\n+                        condt = Conditional(condslot, vtyp.ssadef, Const(true), Const(false))\n                     end\n                     condval = maybe_extract_const_bool(condt)\n                     nothrow = (condval !== nothing) || \u2291(\ud835\udd43\u1d62, orig_condt, Bool)\n@@ -4274,27 +4305,27 @@ function typeinf_local(interp::AbstractInterpreter, frame::InferenceState, nextr\n \n                         # We continue with the true branch, but process the false\n                         # branch here.\n-                        if isa(condt, Conditional)\n-                            else_change = conditional_change(\ud835\udd43\u1d62, currstate, condt, #=then_or_else=#false)\n+                        if isa(condt, Conditional) && conditional_valid(condt, currstate)\n+                            else_change = conditional_change(\ud835\udd43\u1d62, currstate, condt, :else)\n                             if else_change !== nothing\n                                 elsestate = copy(currstate)\n-                                stoverwrite1!(elsestate, else_change)\n+                                strefine1!(elsestate, else_change)\n                             elseif condslot isa SlotNumber\n                                 elsestate = copy(currstate)\n                             else\n                                 elsestate = currstate\n                             end\n                             if condslot isa SlotNumber # refine the type of this conditional object itself for this else branch\n-                                stoverwrite1!(elsestate, condition_object_change(currstate, condt, condslot, #=then_or_else=#false))\n+                                strefine1!(elsestate, condition_object_change(currstate, condt, condslot, :else))\n                             end\n                             else_changed = update_bbstate!(\ud835\udd43\u1d62, frame, falsebb, elsestate, currsaw_latestworld)\n-                            then_change = conditional_change(\ud835\udd43\u1d62, currstate, condt, #=then_or_else=#true)\n+                            then_change = conditional_change(\ud835\udd43\u1d62, currstate, condt, :then)\n                             thenstate = currstate\n                             if then_change !== nothing\n-                                stoverwrite1!(thenstate, then_change)\n+                                strefine1!(thenstate, then_change)\n                             end\n                             if condslot isa SlotNumber # refine the type of this conditional object itself for this then branch\n-                                stoverwrite1!(thenstate, condition_object_change(currstate, condt, condslot, #=then_or_else=#true))\n+                                strefine1!(thenstate, condition_object_change(currstate, condt, condslot, :then))\n                             end\n                         else\n                             else_changed = update_bbstate!(\ud835\udd43\u1d62, frame, falsebb, currstate, currsaw_latestworld)\n@@ -4423,15 +4454,45 @@ function apply_refinement!(\ud835\udd43\u1d62::AbstractLattice, slot::SlotNumber, @nospecia\n     oldtyp = vtype.typ\n     \u228f = strictpartialorder(\ud835\udd43\u1d62)\n     if newtyp \u228f oldtyp\n-        stmtupdate = StateUpdate(slot, VarState(newtyp, vtype.undef))\n-        stoverwrite1!(currstate, stmtupdate)\n+        refinement = StateRefinement(slot_id(slot), newtyp, vtype.undef)\n+        strefine1!(currstate, refinement)\n     end\n end\n \n-function conditional_change(\ud835\udd43\u1d62::AbstractLattice, currstate::VarTable, condt::Conditional, then_or_else::Bool)\n+\"\"\"\n+    conditional_valid(condt::Conditional, currstate::VarTable) -> Bool\n+\n+Check whether a `Conditional` is still valid for refining the type of its slot.\n+\n+A `Conditional` becomes invalid when the slot it references has been reassigned\n+since the conditional was created. This is detected by comparing the `ssadef`\n+(reaching definition) stored in the `Conditional` with the current `ssadef` of\n+the slot in `currstate`. If they differ, the slot now holds a different object\n+and the conditional's type constraints no longer apply.\n+\n+For example:\n+```julia\n+x = foo()        # ssadef=1\n+cond = x isa Int # creates Conditional(slot=x, ssadef=1, ...)\n+x = bar()        # ssadef=2, x is now a different object\n+if cond          # conditional_valid returns false here\n+    # Cannot assume x::Int because x was reassigned\n+end\n+```\n+\"\"\"\n+function conditional_valid(condt::Conditional, currstate::VarTable)\n+    @assert condt.ssadef != typemin(Int)\n+    return currstate[condt.slot].ssadef == condt.ssadef\n+end\n+\n+function conditional_change(\ud835\udd43\u1d62::AbstractLattice, currstate::VarTable, condt::Conditional, then_or_else::Symbol)\n     vtype = currstate[condt.slot]\n     oldtyp = vtype.typ\n-    newtyp = then_or_else ? condt.thentype : condt.elsetype\n+    newtyp = if then_or_else === :then\n+        condt.thentype\n+    elseif then_or_else === :else\n+        condt.elsetype\n+    else @assert false end\n     if iskindtype(newtyp)\n         # this code path corresponds to the special handling for `isa(x, iskindtype)` check\n         # implemented within `abstract_call_builtin`\n@@ -4448,17 +4509,22 @@ function conditional_change(\ud835\udd43\u1d62::AbstractLattice, currstate::VarTable, condt\n         newtyp = tmerge(\ud835\udd43\u1d62, newtyp, LimitedAccuracy(Bottom, oldtyp.causes))\n     end\n     # if this `Conditional` is from `@isdefined condt.slot`, refine its `undef` information\n-    newundef = condt.isdefined ? !then_or_else : vtype.undef\n-    return StateUpdate(SlotNumber(condt.slot), VarState(newtyp, newundef), #=conditional=#true)\n+    newundef = condt.isdefined ? (then_or_else === :else) : vtype.undef\n+    return StateRefinement(condt.slot, newtyp, newundef)\n end\n \n function condition_object_change(currstate::VarTable, condt::Conditional,\n-                                 condslot::SlotNumber, then_or_else::Bool)\n+                                 condslot::SlotNumber, then_or_else::Symbol)\n     vtype = currstate[slot_id(condslot)]\n-    newcondt = Conditional(condt.slot,\n-        then_or_else ? condt.thentype : Union{},\n-        then_or_else ? Union{} : condt.elsetype)\n-    return StateUpdate(condslot, VarState(newcondt, vtype.undef))\n+    if then_or_else === :then\n+        thentype = condt.thentype\n+        elsetype = Union{}\n+    elseif then_or_else === :else\n+        thentype = Union{}\n+        elsetype = condt.elsetype\n+    else @assert false end\n+    newcondt = Conditional(condt.slot, condt.ssadef, thentype, elsetype)\n+    return StateRefinement(slot_id(condslot), newcondt, vtype.undef)\n end\n \n # make as much progress on `frame` as possible (by handling cycles)"
    },
    {
      "sha": "deb3195b03255ccf19dfb3921beae42964b890e3",
      "filename": "Compiler/src/inferencestate.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Finferencestate.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Finferencestate.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Finferencestate.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -354,10 +354,10 @@ mutable struct InferenceState\n         for i = 1:nslots\n             argtyp = (i > nargtypes) ? Bottom : argtypes[i]\n             if argtyp === Bool && has_conditional(typeinf_lattice(interp))\n-                argtyp = Conditional(i, Const(true), Const(false))\n+                argtyp = Conditional(i, #= ssadef =# 0, Const(true), Const(false))\n             end\n             slottypes[i] = argtyp\n-            bb_vartable1[i] = VarState(argtyp, i > nargtypes)\n+            bb_vartable1[i] = VarState(argtyp, #= ssadef =# 0, i > nargtypes)\n         end\n         src.ssavaluetypes = ssavaluetypes = Any[ NOT_FOUND for _ = 1:nssavalues ]\n         ssaflags = copy(src.ssaflags)\n@@ -759,7 +759,7 @@ function sptypes_from_meth_instance(mi::MethodInstance)\n             ty = Const(v)\n             undef = false\n         end\n-        sptypes[i] = VarState(ty, undef)\n+        sptypes[i] = VarState(ty, typemin(Int), undef)\n     end\n     return sptypes\n end"
    },
    {
      "sha": "d7b3c493e797af2de1f281c1d05205db5879a275",
      "filename": "Compiler/src/optimize.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Foptimize.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Foptimize.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Foptimize.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -246,7 +246,7 @@ function OptimizationState(mi::MethodInstance, src::CodeInfo, interp::AbstractIn\n     bb_vartables = Union{VarTable,Nothing}[]\n     for _ = 1:length(cfg.blocks)\n         push!(bb_vartables, VarState[\n-            VarState(slottypes[slot], src.slotflags[slot] & SLOT_USEDUNDEF != 0)\n+            VarState(slottypes[slot], typemin(Int), src.slotflags[slot] & SLOT_USEDUNDEF != 0)\n             for slot = 1:nslots\n         ])\n     end"
    },
    {
      "sha": "6cd21355918c20bb00bd68fcfe6bbbbe867c2118",
      "filename": "Compiler/src/reflection_interface.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Freflection_interface.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Freflection_interface.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Freflection_interface.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -42,7 +42,7 @@ end\n \n function statement_costs!(interp::AbstractInterpreter, cost::Vector{Int}, body::Vector{Any}, src::Union{CodeInfo, IRCode}, match::Core.MethodMatch)\n     params = OptimizationParams(interp)\n-    sptypes = VarState[VarState(sp, false) for sp in match.sparams]\n+    sptypes = VarState[VarState(sp, #= ssadef =# typemin(Int), false) for sp in match.sparams]\n     return statement_costs!(cost, body, src, sptypes, params)\n end\n "
    },
    {
      "sha": "d81bd94bcf0afcbdbd08789c9e225153d384c257",
      "filename": "Compiler/src/ssair/irinterp.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Fssair%2Firinterp.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Fssair%2Firinterp.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2Firinterp.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -56,7 +56,7 @@ end\n \n function abstract_call(interp::AbstractInterpreter, arginfo::ArgInfo, sstate::StatementState, irsv::IRInterpretationState)\n     si = StmtInfo(true, sstate.saw_latestworld) # TODO better job here?\n-    call = abstract_call(interp, arginfo, si, irsv)::Future\n+    call = abstract_call(interp, arginfo, si, sstate.vtypes, irsv)::Future\n     Future{Any}(call, interp, irsv) do call, interp, irsv\n         irsv.ir.stmts[irsv.curridx][:info] = call.info\n         nothing"
    },
    {
      "sha": "3a39b7040f27bb9473ad1cfde6c4967f83ba7904",
      "filename": "Compiler/src/tfuncs.jl",
      "status": "modified",
      "additions": 10,
      "deletions": 6,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Ftfuncs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Ftfuncs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftfuncs.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -233,7 +233,7 @@ end\n \n function not_tfunc(\ud835\udd43::AbstractLattice, @nospecialize(b))\n     if isa(b, Conditional)\n-        return Conditional(b.slot, b.elsetype, b.thentype)\n+        return Conditional(b.slot, b.ssadef, b.elsetype, b.thentype)\n     elseif isa(b, Const)\n         return Const(not_int(b.val))\n     end\n@@ -354,14 +354,14 @@ end\n     if isa(x, Conditional)\n         y = widenconditional(y)\n         if isa(y, Const)\n-            y.val === false && return Conditional(x.slot, x.elsetype, x.thentype)\n+            y.val === false && return Conditional(x.slot, x.ssadef, x.elsetype, x.thentype)\n             y.val === true && return x\n             return Const(false)\n         end\n     elseif isa(y, Conditional)\n         x = widenconditional(x)\n         if isa(x, Const)\n-            x.val === false && return Conditional(y.slot, y.elsetype, y.thentype)\n+            x.val === false && return Conditional(y.slot, y.ssadef, y.elsetype, y.thentype)\n             x.val === true && return y\n             return Const(false)\n         end\n@@ -1364,7 +1364,7 @@ end\n     return Bool\n end\n \n-@nospecs function abstract_modifyop!(interp::AbstractInterpreter, ff, argtypes::Vector{Any}, si::StmtInfo, sv::AbsIntState)\n+@nospecs function abstract_modifyop!(interp::AbstractInterpreter, ff, argtypes::Vector{Any}, si::StmtInfo, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)\n     if ff === modifyfield!\n         minargs = 5\n         maxargs = 6\n@@ -1425,7 +1425,7 @@ end\n         # as well as compute the info for the method matches\n         op = unwrapva(argtypes[op_argi])\n         v = unwrapva(argtypes[v_argi])\n-        callinfo = abstract_call(interp, ArgInfo(nothing, Any[op, TF, v]), StmtInfo(true, si.saw_latestworld), sv, #=max_methods=#1)\n+        callinfo = abstract_call(interp, ArgInfo(nothing, Any[op, TF, v]), StmtInfo(true, si.saw_latestworld), vtypes, sv, #=max_methods=#1)\n         TF = Core.Box(TF)\n         RT = Core.Box(RT)\n         return Future{CallMeta}(callinfo, interp, sv) do callinfo, interp, sv\n@@ -3125,7 +3125,11 @@ function return_type_tfunc(interp::AbstractInterpreter, argtypes::Vector{Any}, s\n         old_restrict = sv.restrict_abstract_call_sites\n         sv.restrict_abstract_call_sites = false\n     end\n-    call = abstract_call(interp, ArgInfo(nothing, argtypes_vec), si, sv, #=max_methods=#-1)\n+    # TODO: Could pass vtypes here to enable Conditional/MustAlias refinements\n+    # in return_type inference. Currently passing `nothing` which means any\n+    # slot-dependent refinements will be widened. This is conservative but\n+    # may miss some precision opportunities.\n+    call = abstract_call(interp, ArgInfo(nothing, argtypes_vec), si, nothing, sv, #=max_methods=#-1)\n     tt = Core.Box(tt)\n     return Future{CallMeta}(call, interp, sv) do call, _, sv\n         if isa(sv, InferenceState)"
    },
    {
      "sha": "ea0eebb5ab9372cfdf3e4f11f4b9bffde65e3076",
      "filename": "Compiler/src/typeinfer.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Ftypeinfer.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Ftypeinfer.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftypeinfer.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -930,7 +930,7 @@ function type_annotate!(::AbstractInterpreter, sv::InferenceState)\n             for slot in 1:nslots\n                 vt = varstate[slot]\n                 widened_type = widenslotwrapper(ignorelimited(vt.typ))\n-                varstate[slot] = VarState(widened_type, vt.undef)\n+                varstate[slot] = VarState(widened_type, vt.ssadef, vt.undef)\n             end\n         end\n     end"
    },
    {
      "sha": "510b02e10eb514d3d914b86b1fc90273c2183b93",
      "filename": "Compiler/src/typelattice.jl",
      "status": "modified",
      "additions": 60,
      "deletions": 53,
      "changes": 113,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Ftypelattice.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Ftypelattice.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftypelattice.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -32,7 +32,7 @@ the type of `SlotNumber(cnd.slot)` will be limited by `cnd.thentype`\n and in the false branch, it will be limited by `cnd.elsetype`.\n Example:\n ```julia\n-let cond = isa(x::Union{Int, Float}, Int)::Conditional(x, Int, Float)\n+let cond = isa(x::Union{Int, Float}, Int)::Conditional(x, _, Int, Float)\n     if cond\n        # May assume x is `Int` now\n     else\n@@ -43,27 +43,30 @@ end\n \"\"\"\n struct Conditional\n     slot::Int\n+    ssadef::Int\n     thentype\n     elsetype\n     # `isdefined` indicates this `Conditional` is from `@isdefined slot`, implying that\n     # the `undef` information of `slot` can be improved in the then branch.\n     # Since this is only beneficial for local inference, it is not translated into `InterConditional`.\n     isdefined::Bool\n-    function Conditional(slot::Int, @nospecialize(thentype), @nospecialize(elsetype);\n+    function Conditional(slot::Int, ssadef::Int, @nospecialize(thentype), @nospecialize(elsetype);\n                          isdefined::Bool=false)\n         assert_nested_slotwrapper(thentype)\n         assert_nested_slotwrapper(elsetype)\n         limited = may_form_limited_typ(thentype, elsetype, Bool)\n         limited !== nothing && return limited\n-        return new(slot, thentype, elsetype, isdefined)\n+        return new(slot, ssadef, thentype, elsetype, isdefined)\n     end\n end\n-Conditional(var::SlotNumber, @nospecialize(thentype), @nospecialize(elsetype); isdefined::Bool=false) =\n-    Conditional(slot_id(var), thentype, elsetype; isdefined)\n+Conditional(var::SlotNumber, ssadef::Int, @nospecialize(thentype), @nospecialize(elsetype); isdefined::Bool=false) =\n+    Conditional(slot_id(var), ssadef, thentype, elsetype; isdefined)\n \n const AnyConditional = Union{Conditional,InterConditional}\n-Conditional(cnd::InterConditional) = Conditional(cnd.slot, cnd.thentype, cnd.elsetype)\n-InterConditional(cnd::Conditional) = InterConditional(cnd.slot, cnd.thentype, cnd.elsetype)\n+function InterConditional(cnd::Conditional)\n+    @assert cnd.ssadef == 0\n+    InterConditional(cnd.slot, cnd.thentype, cnd.elsetype)\n+end\n \n \"\"\"\n     alias::MustAlias\n@@ -90,21 +93,22 @@ N.B. currently this lattice element is only used in abstractinterpret, not in op\n \"\"\"\n struct MustAlias\n     slot::Int\n+    ssadef::Int\n     vartyp::Any\n     fldidx::Int\n     fldtyp::Any\n-    function MustAlias(slot::Int, @nospecialize(vartyp), fldidx::Int, @nospecialize(fldtyp))\n+    function MustAlias(slot::Int, ssadef::Int, @nospecialize(vartyp), fldidx::Int, @nospecialize(fldtyp))\n         assert_nested_slotwrapper(vartyp)\n         assert_nested_slotwrapper(fldtyp)\n         # @assert !isalreadyconst(vartyp) \"vartyp is already const\"\n         # @assert !isalreadyconst(fldtyp) \"fldtyp is already const\"\n         limited = may_form_limited_typ(vartyp, fldtyp, fldtyp)\n         limited !== nothing && return limited\n-        return new(slot, vartyp, fldidx, fldtyp)\n+        return new(slot, ssadef, vartyp, fldidx, fldtyp)\n     end\n end\n-MustAlias(var::SlotNumber, @nospecialize(vartyp), fldidx::Int, @nospecialize(fldtyp)) =\n-    MustAlias(slot_id(var), vartyp, fldidx, fldtyp)\n+MustAlias(var::SlotNumber, ssadef::Int, @nospecialize(vartyp), fldidx::Int, @nospecialize(fldtyp)) =\n+    MustAlias(slot_id(var), ssadef, vartyp, fldidx, fldtyp)\n \n \"\"\"\n     alias::InterMustAlias\n@@ -130,8 +134,10 @@ InterMustAlias(var::SlotNumber, @nospecialize(vartyp), fldidx::Int, @nospecializ\n     InterMustAlias(slot_id(var), vartyp, fldidx, fldtyp)\n \n const AnyMustAlias = Union{MustAlias,InterMustAlias}\n-MustAlias(alias::InterMustAlias) = MustAlias(alias.slot, alias.vartyp, alias.fldidx, alias.fldtyp)\n-InterMustAlias(alias::MustAlias) = InterMustAlias(alias.slot, alias.vartyp, alias.fldidx, alias.fldtyp)\n+function InterMustAlias(alias::MustAlias)\n+    @assert alias.ssadef == 0\n+    InterMustAlias(alias.slot, alias.vartyp, alias.fldidx, alias.fldtyp)\n+end\n \n struct PartialTypeVar\n     tv::TypeVar\n@@ -145,8 +151,20 @@ end\n struct StateUpdate\n     var::SlotNumber\n     vtype::VarState\n-    conditional::Bool\n-    StateUpdate(var::SlotNumber, vtype::VarState, conditional::Bool=false) = new(var, vtype, conditional)\n+end\n+\n+\"\"\"\n+Similar to `StateUpdate`, except with the additional guarantee that object identity\n+is preserved by the update (i.e. `x (before) === x (after)`).\n+\"\"\"\n+struct StateRefinement\n+    slot::Int\n+    # XXX: This should be an intersection of the old type with the new\n+    #      (i.e. newtyp \u2291 oldtyp)\n+    newtyp\n+    undef::Bool\n+\n+    StateRefinement(slot::Int, @nospecialize(newtyp), undef::Bool) = new(slot, newtyp, undef)\n end\n \n \"\"\"\n@@ -234,13 +252,6 @@ end\n     return typ\n end\n \n-@nospecializeinfer function widenwrappedslotwrapper(@nospecialize typ)\n-    if isa(typ, LimitedAccuracy)\n-        return LimitedAccuracy(widenslotwrapper(typ.typ), typ.causes)\n-    end\n-    return widenslotwrapper(typ)\n-end\n-\n # Conditional\n # ===========\n \n@@ -284,6 +295,7 @@ end\n     return false\n end\n \n+is_same_conditionals(a::Conditional, b::Conditional) = a.slot == b.slot && a.ssadef == b.ssadef\n is_same_conditionals(a::C, b::C) where C<:AnyConditional = a.slot == b.slot\n \n @nospecializeinfer is_lattice_bool(lattice::AbstractLattice, @nospecialize(typ)) = typ !== Bottom && \u2291(lattice, typ, Bool)\n@@ -332,7 +344,7 @@ end\n end\n \n @nospecializeinfer function form_mustalias_conditional(alias::MustAlias, @nospecialize(thentype), @nospecialize(elsetype))\n-    (; slot, vartyp, fldidx) = alias\n+    (; slot, ssadef, vartyp, fldidx) = alias\n     if isa(vartyp, PartialStruct)\n         fields = vartyp.fields\n         thenfields = thentype === Bottom ? nothing : copy(fields)\n@@ -343,7 +355,7 @@ end\n             elsefields === nothing || (elsefields[fldidx] = elsetype)\n             undefs[fldidx] = false\n         end\n-        return Conditional(slot,\n+        return Conditional(slot, ssadef,\n             thenfields === nothing ? Bottom : PartialStruct(fallback_lattice, vartyp.typ, undefs, thenfields),\n             elsefields === nothing ? Bottom : PartialStruct(fallback_lattice, vartyp.typ, undefs, elsefields))\n     else\n@@ -360,7 +372,7 @@ end\n                 elsefields === nothing || push!(elsefields, t)\n             end\n         end\n-        return Conditional(slot,\n+        return Conditional(slot, ssadef,\n             thenfields === nothing ? Bottom : PartialStruct(fallback_lattice, vartyp_widened, thenfields),\n             elsefields === nothing ? Bottom : PartialStruct(fallback_lattice, vartyp_widened, elsefields))\n     end\n@@ -713,34 +725,28 @@ widenconst(::LimitedAccuracy) = error(\"unhandled LimitedAccuracy\")\n # state management #\n ####################\n \n-function smerge(lattice::AbstractLattice, sa::Union{NotFound,VarState}, sb::Union{NotFound,VarState})\n+function smerge(lattice::AbstractLattice, sa::Union{NotFound,VarState}, sb::Union{NotFound,VarState}, join_pc::Int)\n     sa === sb && return sa\n     sa === NOT_FOUND && return sb\n     sb === NOT_FOUND && return sa\n-    return VarState(tmerge(lattice, sa.typ, sb.typ), sa.undef | sb.undef)\n+    return VarState(tmerge(lattice, sa.typ, sb.typ), sa.ssadef == sb.ssadef ? sa.ssadef : join_pc, sa.undef | sb.undef)\n end\n \n-@nospecializeinfer @inline schanged(lattice::AbstractLattice, @nospecialize(n), @nospecialize(o)) =\n-    (n !== o) && (o === NOT_FOUND || (n !== NOT_FOUND && !(n.undef <= o.undef && \u2291(lattice, n.typ, o.typ))))\n-\n-# remove any lattice elements that wrap the reassigned slot object from the vartable\n-function invalidate_slotwrapper(vt::VarState, changeid::Int, ignore_conditional::Bool)\n-    newtyp = ignorelimited(vt.typ)\n-    if (!ignore_conditional && isa(newtyp, Conditional) && newtyp.slot == changeid) ||\n-       (isa(newtyp, MustAlias) && newtyp.slot == changeid)\n-        newtyp = @noinline widenwrappedslotwrapper(vt.typ)\n-        return VarState(newtyp, vt.undef)\n-    end\n-    return nothing\n-end\n+@nospecializeinfer @inline schanged(lattice::AbstractLattice, @nospecialize(n), @nospecialize(o), join_pc::Int) =\n+    (n !== o) && (o === NOT_FOUND || (n !== NOT_FOUND && !(n.undef <= o.undef && (n.ssadef === o.ssadef || o.ssadef === join_pc) && \u2291(lattice, n.typ, o.typ))))\n \n-function stupdate!(lattice::AbstractLattice, state::VarTable, changes::VarTable)\n+function stupdate!(lattice::AbstractLattice, state::VarTable, changes::VarTable, join_pc::Int)\n     changed = false\n     for i = 1:length(state)\n         newtype = changes[i]\n         oldtype = state[i]\n-        if schanged(lattice, newtype, oldtype)\n-            state[i] = smerge(lattice, oldtype, newtype)\n+        # In addition to computing the type, the merge here computes the \"reaching definition\"\n+        # for a slot. The provided `join_pc` is a \"virtual\" PC, which corresponds to the \u03d5-block\n+        # that would exist at the beginning of the BasicBlock.\n+        #\n+        # This effectively applies the \"path-convergence criterion\" for SSA construction.\n+        if schanged(lattice, newtype, oldtype, join_pc)\n+            state[i] = smerge(lattice, oldtype, newtype, join_pc)\n             changed = true\n         end\n     end\n@@ -755,16 +761,17 @@ function stoverwrite!(state::VarTable, newstate::VarTable)\n end\n \n function stoverwrite1!(state::VarTable, change::StateUpdate)\n-    changeid = slot_id(change.var)\n-    for i = 1:length(state)\n-        invalidated = invalidate_slotwrapper(state[i], changeid, change.conditional)\n-        if invalidated !== nothing\n-            state[i] = invalidated\n-        end\n-    end\n-    # and update the type of it\n-    newtype = change.vtype\n-    state[changeid] = newtype\n+    # Note: We no longer need to invalidate Conditional/MustAlias in other slots\n+    # that reference this slot. The ssadef tracking handles this: when a slot is\n+    # reassigned, its ssadef changes, and any Conditional/MustAlias referencing\n+    # the old ssadef will be detected as stale by conditional_valid().\n+    state[slot_id(change.var)] = change.vtype\n+    return state\n+end\n+\n+function strefine1!(state::VarTable, refinement::StateRefinement)\n+    (; newtyp, undef, slot) = refinement\n+    state[slot] = VarState(newtyp, state[slot].ssadef, undef)\n     return state\n end\n "
    },
    {
      "sha": "99f5c4185067ff9a7cf94b463b18da96c26df2d9",
      "filename": "Compiler/src/typelimits.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Ftypelimits.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Ftypelimits.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftypelimits.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -500,24 +500,24 @@ end\n     # type-lattice for Conditional wrapper (NOTE never be merged with InterConditional)\n     if isa(typea, Conditional) && isa(typeb, Const)\n         if typeb.val === true\n-            typeb = Conditional(typea.slot, Any, Union{})\n+            typeb = Conditional(typea.slot, typea.ssadef, Any, Union{})\n         elseif typeb.val === false\n-            typeb = Conditional(typea.slot, Union{}, Any)\n+            typeb = Conditional(typea.slot, typea.ssadef, Union{}, Any)\n         end\n     end\n     if isa(typeb, Conditional) && isa(typea, Const)\n         if typea.val === true\n-            typea = Conditional(typeb.slot, Any, Union{})\n+            typea = Conditional(typeb.slot, typeb.ssadef, Any, Union{})\n         elseif typea.val === false\n-            typea = Conditional(typeb.slot, Union{}, Any)\n+            typea = Conditional(typeb.slot, typeb.ssadef, Union{}, Any)\n         end\n     end\n     if isa(typea, Conditional) && isa(typeb, Conditional)\n         if is_same_conditionals(typea, typeb)\n             thentype = tmerge(widenlattice(lattice), typea.thentype, typeb.thentype)\n             elsetype = tmerge(widenlattice(lattice), typea.elsetype, typeb.elsetype)\n             if thentype !== elsetype\n-                return Conditional(typea.slot, thentype, elsetype)\n+                return Conditional(typea.slot, typea.ssadef, thentype, elsetype)\n             end\n         end\n         val = maybe_extract_const_bool(typea)"
    },
    {
      "sha": "cdfeb547d3a4bef83cfa116e87e22759f8c787b1",
      "filename": "Compiler/src/types.jl",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Ftypes.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Fsrc%2Ftypes.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftypes.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -70,14 +70,23 @@ SpecInfo(src::CodeInfo) = SpecInfo(\n A special wrapper that represents a local variable of a method being analyzed.\n This does not participate in the native type system nor the inference lattice, and it thus\n should be always unwrapped to `v.typ` when performing any type or lattice operations on it.\n+\n `v.undef` represents undefined-ness of this static parameter. If `true`, it means that the\n variable _may_ be undefined at runtime, otherwise it is guaranteed to be defined.\n If `v.typ === Bottom` it means that the variable is strictly undefined.\n+\n+`v.ssadef` represents the \"reaching definition\" for the variable.\n+If zero, then the value comes from an argument.\n+If negative, this refers to a \"virtual \u03d5-block\" preceding the given index,\n+that would have been inserted as the value of this slot in a truly SSA-form IR.\n+If a slot has the same `ssadef` at two different points of execution,\n+the slot contents are guaranteed to share identity (`x\u2080 === x\u2081`).\n \"\"\"\n struct VarState\n     typ\n+    ssadef::Int\n     undef::Bool\n-    VarState(@nospecialize(typ), undef::Bool) = new(typ, undef)\n+    VarState(@nospecialize(typ), ssadef::Int, undef::Bool) = new(typ, ssadef, undef)\n end\n \n struct AnalysisResults"
    },
    {
      "sha": "b33f7cc7bd93b08622a760e4bdb5903ee6a0ea67",
      "filename": "Compiler/test/AbstractInterpreter.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Ftest%2FAbstractInterpreter.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Ftest%2FAbstractInterpreter.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2FAbstractInterpreter.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -408,10 +408,10 @@ Compiler.nsplit_impl(info::NoinlineCallInfo) = Compiler.nsplit(info.info)\n Compiler.getsplit_impl(info::NoinlineCallInfo, idx::Int) = Compiler.getsplit(info.info, idx)\n Compiler.getresult_impl(info::NoinlineCallInfo, idx::Int) = Compiler.getresult(info.info, idx)\n \n-function Compiler.abstract_call(interp::NoinlineInterpreter,\n-    arginfo::Compiler.ArgInfo, si::Compiler.StmtInfo, sv::Compiler.InferenceState, max_methods::Int)\n+function Compiler.abstract_call(interp::NoinlineInterpreter, arginfo::Compiler.ArgInfo, si::Compiler.StmtInfo,\n+    vtypes::Union{Compiler.VarTable,Nothing}, sv::Compiler.InferenceState, max_methods::Int)\n     ret = @invoke Compiler.abstract_call(interp::Compiler.AbstractInterpreter,\n-        arginfo::Compiler.ArgInfo, si::Compiler.StmtInfo, sv::Compiler.InferenceState, max_methods::Int)\n+        arginfo::Compiler.ArgInfo, si::Compiler.StmtInfo, vtypes::Union{Compiler.VarTable,Nothing}, sv::Compiler.InferenceState, max_methods::Int)\n     return Compiler.Future{Compiler.CallMeta}(ret, interp, sv) do ret, interp, sv\n         if sv.mod in noinline_modules(interp)\n             (;rt, exct, effects, info) = ret"
    },
    {
      "sha": "70cd940a658a385f24af6d8edce286af0e6a3dfd",
      "filename": "Compiler/test/inference.jl",
      "status": "modified",
      "additions": 36,
      "deletions": 24,
      "changes": 60,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Ftest%2Finference.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Ftest%2Finference.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Finference.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -1381,7 +1381,7 @@ let isa_tfunc(@nospecialize xs...) =\n     @test isa_tfunc(typeof(Union{}), Union{}) === Union{} # any result is ok\n     @test isa_tfunc(typeof(Union{}), Type{typeof(Union{})}) === Const(true)\n     @test isa_tfunc(typeof(Union{}), Const(typeof(Union{}))) === Const(true)\n-    let c = Conditional(0, Const(Union{}), Const(Union{}))\n+    let c = Conditional(#= slot =# 0, #= ssadef =# 0, Const(Union{}), Const(Union{}))\n         @test isa_tfunc(c, Const(Bool)) === Const(true)\n         @test isa_tfunc(c, Type{Bool}) === Const(true)\n         @test isa_tfunc(c, Const(Real)) === Const(true)\n@@ -1433,7 +1433,7 @@ let subtype_tfunc(@nospecialize xs...) =\n     @test subtype_tfunc(Type{Union{}}, Any) === Const(true) # Union{} <: Any\n     @test subtype_tfunc(Type{Union{}}, Union{Type{Int64}, Type{Float64}}) === Const(true)\n     @test subtype_tfunc(Type{Union{}}, Union{Type{T}, Type{Float64}} where T) === Const(true)\n-    let c = Conditional(0, Const(Union{}), Const(Union{}))\n+    let c = Conditional(#= slot =# 0, #= ssadef =# 0, Const(Union{}), Const(Union{}))\n         @test subtype_tfunc(c, Const(Bool)) === Const(true) # any result is ok\n     end\n     @test subtype_tfunc(Type{Val{1}}, Type{Val{T}} where T) === Bool\n@@ -1477,7 +1477,7 @@ let egal_tfunc\n     @test egal_tfunc(Type{Union{Float32, Float64}}, Type{Union{Float32, Float64}}) === Bool\n     @test egal_tfunc(typeof(Union{}), typeof(Union{})) === Bool # could be improved\n     @test egal_tfunc(Const(typeof(Union{})), Const(typeof(Union{}))) === Const(true)\n-    let c = Conditional(0, Const(Union{}), Const(Union{}))\n+    let c = Conditional(#= slot =# 0, #= ssadef =# 0, Const(Union{}), Const(Union{}))\n         @test egal_tfunc(c, Const(Bool)) === Const(false)\n         @test egal_tfunc(c, Type{Bool}) === Const(false)\n         @test egal_tfunc(c, Const(Real)) === Const(false)\n@@ -1488,17 +1488,17 @@ let egal_tfunc\n         @test egal_tfunc(c, Bool) === Bool\n         @test egal_tfunc(c, Any) === Bool\n     end\n-    let c = Conditional(0, Union{}, Const(Union{})) # === Const(false)\n-        @test egal_tfunc(c, Const(false)) === Conditional(c.slot, c.elsetype, Union{})\n-        @test egal_tfunc(c, Const(true)) === Conditional(c.slot, Union{}, c.elsetype)\n+    let c = Conditional(#= slot =# 0, #= ssadef =# 0, Union{}, Const(Union{})) # === Const(false)\n+        @test egal_tfunc(c, Const(false)) === Conditional(c.slot, c.ssadef, c.elsetype, Union{})\n+        @test egal_tfunc(c, Const(true)) === Conditional(c.slot, c.ssadef, Union{}, c.elsetype)\n         @test egal_tfunc(c, Const(nothing)) === Const(false)\n         @test egal_tfunc(c, Int) === Const(false)\n         @test egal_tfunc(c, Bool) === Bool\n         @test egal_tfunc(c, Any) === Bool\n     end\n-    let c = Conditional(0, Const(Union{}), Union{}) # === Const(true)\n-        @test egal_tfunc(c, Const(false)) === Conditional(c.slot, Union{}, c.thentype)\n-        @test egal_tfunc(c, Const(true)) === Conditional(c.slot, c.thentype, Union{})\n+    let c = Conditional(#= slot =# 0, #= ssadef =# 0, Const(Union{}), Union{}) # === Const(true)\n+        @test egal_tfunc(c, Const(false)) === Conditional(c.slot, c.ssadef, Union{}, c.thentype)\n+        @test egal_tfunc(c, Const(true)) === Conditional(c.slot, c.ssadef, c.thentype, Union{})\n         @test egal_tfunc(c, Const(nothing)) === Const(false)\n         @test egal_tfunc(c, Int) === Const(false)\n         @test egal_tfunc(c, Bool) === Bool\n@@ -2299,21 +2299,21 @@ let \ud835\udd43\u1d62 = InferenceLattice(MustAliasesLattice(BaseInferenceLattice.instance)\n     isa_tfunc(@nospecialize xs...) = Compiler.isa_tfunc(\ud835\udd43\u1d62, xs...)\n     ifelse_tfunc(@nospecialize xs...) = Compiler.ifelse_tfunc(\ud835\udd43\u1d62, xs...)\n \n-    @test (MustAlias(2, AliasableField{Any}, 1, Int) \u2291 Int)\n-    @test !(Int \u2291 MustAlias(2, AliasableField{Any}, 1, Int))\n-    @test (Int \u2291 MustAlias(2, AliasableField{Any}, 1, Any))\n-    @test (Const(42) \u2291 MustAlias(2, AliasableField{Any}, 1, Int))\n-    @test !(MustAlias(2, AliasableField{Any}, 1, Any) \u2291 Int)\n-    @test tmerge(MustAlias(2, AliasableField{Any}, 1, Any), Const(nothing)) === Any\n-    @test tmerge(MustAlias(2, AliasableField{Any}, 1, Int), Const(nothing)) === Union{Int,Nothing}\n-    @test tmerge(Const(nothing), MustAlias(2, AliasableField{Any}, 1, Any)) === Any\n-    @test tmerge(Const(nothing), MustAlias(2, AliasableField{Any}, 1, Int)) === Union{Int,Nothing}\n+    @test (MustAlias(2, 0, AliasableField{Any}, 1, Int) \u2291 Int)\n+    @test !(Int \u2291 MustAlias(2, 0, AliasableField{Any}, 1, Int))\n+    @test (Int \u2291 MustAlias(2, 0, AliasableField{Any}, 1, Any))\n+    @test (Const(42) \u2291 MustAlias(2, 0, AliasableField{Any}, 1, Int))\n+    @test !(MustAlias(2, 0, AliasableField{Any}, 1, Any) \u2291 Int)\n+    @test tmerge(MustAlias(2, 0, AliasableField{Any}, 1, Any), Const(nothing)) === Any\n+    @test tmerge(MustAlias(2, 0, AliasableField{Any}, 1, Int), Const(nothing)) === Union{Int,Nothing}\n+    @test tmerge(Const(nothing), MustAlias(2, 0, AliasableField{Any}, 1, Any)) === Any\n+    @test tmerge(Const(nothing), MustAlias(2, 0, AliasableField{Any}, 1, Int)) === Union{Int,Nothing}\n     tmerge(Const(AbstractVector{<:Any}), Const(AbstractVector{T} where {T}))  # issue #56913\n-    @test isa_tfunc(MustAlias(2, AliasableField{Any}, 1, Bool), Const(Bool)) === Const(true)\n-    @test isa_tfunc(MustAlias(2, AliasableField{Any}, 1, Bool), Type{Bool}) === Const(true)\n-    @test isa_tfunc(MustAlias(2, AliasableField{Any}, 1, Int), Type{Bool}) === Const(false)\n-    @test ifelse_tfunc(MustAlias(2, AliasableField{Any}, 1, Bool), Int, Int) === Int\n-    @test ifelse_tfunc(MustAlias(2, AliasableField{Any}, 1, Int), Int, Int) === Union{}\n+    @test isa_tfunc(MustAlias(2, 0, AliasableField{Any}, 1, Bool), Const(Bool)) === Const(true)\n+    @test isa_tfunc(MustAlias(2, 0, AliasableField{Any}, 1, Bool), Type{Bool}) === Const(true)\n+    @test isa_tfunc(MustAlias(2, 0, AliasableField{Any}, 1, Int), Type{Bool}) === Const(false)\n+    @test ifelse_tfunc(MustAlias(2, 0, AliasableField{Any}, 1, Bool), Int, Int) === Int\n+    @test ifelse_tfunc(MustAlias(2, 0, AliasableField{Any}, 1, Int), Int, Int) === Union{}\n end\n \n maybeget_mustalias_tmerge(x::AliasableField) = x.f\n@@ -2472,7 +2472,7 @@ end |> only === Int\n # appropriate lattice order\n @test Base.return_types((AliasableField{Any},); interp=MustAliasInterpreter()) do x\n     v = x.f        # ::MustAlias(2, AliasableField{Any}, 1, Any)\n-    if isa(v, Int) # ::Conditional(3, Int, Any)\n+    if isa(v, Int) # ::Conditional(3, _, Int, Any)\n         v = v      # ::Int (\u2235 Int \u2291 MustAlias(2, AliasableField{Any}, 1, Any))\n     else\n         v = 42\n@@ -6523,4 +6523,16 @@ function haskey_inference_test()\n end\n @inferred haskey_inference_test()\n \n+# JuliaLang/julia#55548: invalidate stale slot wrapper types in `ssavaluetypes`\n+_issue55548_proj1(a, b) = a\n+function issue55548(a)\n+    a = Base.inferencebarrier(a)::Union{Int64,Float64}\n+    if _issue55548_proj1(isa(a, Int64), (a = Base.inferencebarrier(1.0)::Union{Int64,Float64}; true))\n+        return a\n+    end\n+    return 2\n+end\n+@test Float64 <: Base.infer_return_type(issue55548, (Int,))\n+@test issue55548(Int64(0)) === 1.0\n+\n end # module inference"
    },
    {
      "sha": "98c7915d0043cfcb0e4ffb8e83e7903eac7d7cba",
      "filename": "Compiler/test/irpasses.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Ftest%2Firpasses.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/749bc618c555b0d481a434dd30614ad0a36a07a8/Compiler%2Ftest%2Firpasses.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Firpasses.jl?ref=749bc618c555b0d481a434dd30614ad0a36a07a8",
      "patch": "@@ -1499,11 +1499,10 @@ let code = Any[\n     # Simulate the important results from inference\n     interp = Compiler.NativeInterpreter()\n     sv = Compiler.OptimizationState(mi, src, interp)\n-    slot_id = 4\n-    for block_id = 3:5\n-        # (_4 !== nothing) conditional narrows the type, triggering PiNodes\n-        sv.bb_vartables[block_id][slot_id] = VarState(Bool, #= maybe_undef =# false)\n-    end\n+    # (_4 !== nothing) conditional narrows the type, triggering PiNodes\n+    sv.bb_vartables[#= block_id =# 3][#= slot_id =# 4] = VarState(Bool, #= def =# 5, #= maybe_undef =# false)\n+    sv.bb_vartables[#= block_id =# 4][#= slot_id =# 4] = VarState(Bool, #= def =# 7, #= maybe_undef =# false)\n+    sv.bb_vartables[#= block_id =# 5][#= slot_id =# 4] = VarState(Bool, #= def =# 7, #= maybe_undef =# false)\n \n     ir = Compiler.convert_to_ircode(src, sv)\n     ir = Compiler.slot2reg(ir, src, sv)"
    }
  ]
}