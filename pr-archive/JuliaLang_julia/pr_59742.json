{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59742",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59742/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59742/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59742/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59742",
  "id": 3482977216,
  "node_id": "PR_kwDOABkWpM6sDepl",
  "number": 59742,
  "title": "docs: fix crashes on searching documentation of various expressions",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 229907793,
      "node_id": "MDU6TGFiZWwyMjk5MDc3OTM=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/docsystem",
      "name": "docsystem",
      "color": "d4c5f9",
      "default": false,
      "description": "The documentation building system"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 4,
  "created_at": "2025-10-04T00:41:07Z",
  "updated_at": "2025-10-21T19:32:35Z",
  "closed_at": "2025-10-21T19:32:32Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59742",
    "html_url": "https://github.com/JuliaLang/julia/pull/59742",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59742.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59742.patch",
    "merged_at": "2025-10-21T19:32:32Z"
  },
  "body": "Fix a crash when calling `@doc` on non-document-able expressions so that docs (or lack thereof) can be successfully printed. For example, looking up docs on sad faces, doesn't crash and cause sad faces after this change:\r\n\r\n```\r\nhelp?> :()\r\n  Expr(head::Symbol, args...)\r\n```\r\n\r\nDetails: expands `astname` to handle valid expression types explicitly, removes the unused, undocumented `@var` export from Base.Docs, and updates the error message to be clearer.\r\n\r\n\ud83e\udd16 Generated with some assistance from Claude Code.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59742/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59742/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "1026c70617ea1d6b4f6137319e9181909eb367a9",
      "filename": "base/docs/Docs.jl",
      "status": "modified",
      "additions": 25,
      "deletions": 6,
      "changes": 31,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729/base%2Fdocs%2FDocs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729/base%2Fdocs%2FDocs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fdocs%2FDocs.jl?ref=4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729",
      "patch": "@@ -295,16 +295,29 @@ catdoc(xs...) = vcat(xs...)\n \n const keywords = Dict{Symbol, DocStr}()\n \n-namify(@nospecialize x) = astname(x, isexpr(x, :macro))::Union{Symbol,Expr,GlobalRef}\n+namify(@nospecialize x) = astname(x, isexpr(x, :macro))\n \n function astname(x::Expr, ismacro::Bool)\n     head = x.head\n     if head === :.\n         ismacro ? macroname(x) : x\n-    elseif head === :call && isexpr(x.args[1], :(::))\n-        return astname((x.args[1]::Expr).args[end], ismacro)\n+elseif head === :call && length(x.args) >= 1 && isexpr(x.args[1], :(::))\n+        # for documenting (x::y)(args...), extract the name from y\n+        # otherwise, for documenting `x::y`, it will be extracted from x\n+        astname((x.args[1]::Expr).args[end], ismacro)\n     else\n-        n = isexpr(x, (:module, :struct)) ? 2 : 1\n+        n = if isexpr(x, (:module, :struct))\n+            2\n+        elseif isexpr(x, (:call, :macrocall, :function, :(=), :macro, :where, :curly,\n+                          :(::), :(<:), :(>:), :local, :global, :const, :atomic,\n+                          :copyast, :quote, :inert, :primitive, :abstract,\n+                          :escape, :var\"hygienic-scope\"))\n+            # similar to is_function_def, but without -> and with various assignments, quoted statements, and miscellaneous that might be encountered in struct definitions also\n+            1\n+        else\n+            return x # nothing to see here--bindingexpr will convert this to an error if defining a doc\n+        end\n+        length(x.args) < n && return x\n         astname(x.args[n], ismacro)\n     end\n end\n@@ -356,7 +369,7 @@ function metadata(__source__, __module__, expr, ismodule)\n             if isa(eachex, Symbol) || isexpr(eachex, :(::))\n                 # a field declaration\n                 if last_docstr !== nothing\n-                    push!(fields, P(namify(eachex::Union{Symbol,Expr}), last_docstr))\n+                    push!(fields, P(namify(eachex), last_docstr))\n                     last_docstr = nothing\n                 end\n             elseif isexpr(eachex, :function) || isexpr(eachex, :(=))\n@@ -610,7 +623,13 @@ function simple_lookup_doc(ex)\n     elseif !isa(ex, Expr) && !isa(ex, Symbol)\n         return :($(_doc)($(typeof)($(esc(ex)))))\n     end\n-    binding = esc(bindingexpr(namify(ex)))\n+    name = namify(ex)\n+    # If namify couldn't extract a meaningful name and returned an Expr\n+    # that can't be converted to a binding, treat it like a value\n+    if isa(name, Expr) && !isexpr(name, :(.))\n+        return :($(_doc)($(typeof)($(esc(ex)))))\n+    end\n+    binding = esc(bindingexpr(name))\n     if isexpr(ex, :call) || isexpr(ex, :macrocall) || isexpr(ex, :where)\n         sig = esc(signature(ex))\n         :($(_doc)($binding, $sig))"
    },
    {
      "sha": "fc72375e8cebefdb0051aa330300aae4cf24ce32",
      "filename": "base/docs/bindings.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 11,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729/base%2Fdocs%2Fbindings.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729/base%2Fdocs%2Fbindings.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fdocs%2Fbindings.jl?ref=4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729",
      "patch": "@@ -1,7 +1,5 @@\n # This file is a part of Julia. License is MIT: https://julialang.org/license\n \n-export @var\n-\n struct Binding\n     mod::Module\n     var::Symbol\n@@ -20,17 +18,11 @@ defined(b::Binding) = invokelatest(isdefinedglobal, b.mod, b.var)\n resolve(b::Binding) = invokelatest(getglobal, b.mod, b.var)\n \n function splitexpr(x::Expr)\n-    isexpr(x, :macrocall) ? splitexpr(x.args[1]) :\n-    isexpr(x, :.)         ? (x.args[1], x.args[2]) :\n-    error(\"Invalid @var syntax `$x`.\")\n+    isexpr(x, :.) ? (x.args[1], x.args[2]) : error(\"Could not find something to document in `$x`.\")\n end\n-splitexpr(s::Symbol) = Expr(:macrocall, getfield(Base, Symbol(\"@__MODULE__\")), nothing), quot(s)\n+splitexpr(s::Symbol) = :($Base.@__MODULE__), quot(s) # this somewhat complex form allows deferring resolving the Module for module docstring until after the module is created\n splitexpr(r::GlobalRef) = r.mod, quot(r.name)\n-splitexpr(other)     = error(\"Invalid @var syntax `$other`.\")\n-\n-macro var(x)\n-    esc(bindingexpr(x))\n-end\n+splitexpr(other)     = error(\"Could not find something to document in `$other`.\")\n \n function Base.show(io::IO, b::Binding)\n     if b.mod === Base.active_module()"
    },
    {
      "sha": "e05b3075d9f7c59a7190a2caf9eeafdc56c6590e",
      "filename": "stdlib/REPL/src/docview.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 3,
      "changes": 11,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729/stdlib%2FREPL%2Fsrc%2Fdocview.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729/stdlib%2FREPL%2Fsrc%2Fdocview.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2Fdocview.jl?ref=4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729",
      "patch": "@@ -256,7 +256,7 @@ doc(obj::UnionAll) = doc(Base.unwrap_unionall(obj))\n doc(object, sig::Type = Union{}) = doc(aliasof(object, typeof(object)), sig)\n doc(object, sig...)              = doc(object, Tuple{sig...})\n \n-function lookup_doc(ex)\n+function lookup_doc(@nospecialize(ex))\n     if isa(ex, Expr) && ex.head !== :(.) && Base.isoperator(ex.head)\n         # handle syntactic operators, e.g. +=, ::, .=\n         ex = ex.head\n@@ -284,7 +284,13 @@ function lookup_doc(ex)\n             end\n         end\n     end\n-    binding = esc(bindingexpr(namify(ex)))\n+    name = namify(ex)\n+    # If namify couldn't extract a meaningful name and returned an Expr\n+    # that can't be converted to a binding, treat it like a value\n+    if isa(name, Expr) && !isexpr(name, :(.))\n+        return :($(doc)($(typeof)($(esc(ex)))))\n+    end\n+    binding = esc(bindingexpr(name))\n     if isexpr(ex, :call) || isexpr(ex, :macrocall) || isexpr(ex, :where)\n         sig = esc(signature(ex))\n         :($(doc)($binding, $sig))\n@@ -579,7 +585,6 @@ isregex(x) = isexpr(x, :macrocall, 3) && x.args[1] === Symbol(\"@r_str\") && !isem\n repl(io::IO, ex::Expr; brief::Bool=true, mod::Module=Main, internal_accesses::Union{Nothing, Set{Pair{Module,Symbol}}}=nothing) = isregex(ex) ? :(apropos($io, $ex)) : _repl(ex, brief, mod, internal_accesses)\n repl(io::IO, str::AbstractString; brief::Bool=true, mod::Module=Main, internal_accesses::Union{Nothing, Set{Pair{Module,Symbol}}}=nothing) = :(apropos($io, $str))\n repl(io::IO, other; brief::Bool=true, mod::Module=Main, internal_accesses::Union{Nothing, Set{Pair{Module,Symbol}}}=nothing) = esc(:(@doc $other)) # TODO: track internal_accesses\n-#repl(io::IO, other) = lookup_doc(other) # TODO\n \n repl(x; brief::Bool=true, mod::Module=Main) = repl(stdout, x; brief, mod)\n "
    },
    {
      "sha": "e1b212944016c1ae63144685e6c90c27a653be13",
      "filename": "test/docs.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 4,
      "changes": 13,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729/test%2Fdocs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729/test%2Fdocs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fdocs.jl?ref=4ca97dc26d38fc6d7f9b2eb7bb2d654fd781a729",
      "patch": "@@ -1,6 +1,10 @@\n # This file is a part of Julia. License is MIT: https://julialang.org/license\n \n-import Base.Docs: meta, @var, DocStr, parsedoc\n+import Base.Docs: meta, DocStr, parsedoc, bindingexpr, namify\n+\n+macro var(x) # just for testing bindingexpr/nameify more conveniently\n+    esc(bindingexpr(namify(x)))\n+end\n \n # check that @doc can work before REPL is loaded\n @test !startswith(read(`$(Base.julia_cmd()) -E '@doc sin'`, String), \"nothing\")\n@@ -58,6 +62,8 @@ macro macro_doctest() end\n @test (@eval @doc $(Meta.parse(\"``\"))) == (@doc @cmd)\n @test (@eval @doc $(Meta.parse(\"123456789012345678901234567890\"))) == (@doc @int128_str)\n @test (@eval @doc $(Meta.parse(\"1234567890123456789012345678901234567890\"))) == (@doc @big_str)\n+# Test that @doc doesn't crash on empty tuple expression (issue #XXXXX)\n+@test (@doc :()) == (@doc Expr)\n \n # test that random stuff interpolated into docstrings doesn't break search or other methods here\n @doc doc\"\"\"\n@@ -1239,7 +1245,7 @@ end\n \n # Bindings.\n \n-import Base.Docs: @var, Binding, defined\n+import Base.Docs: Binding, defined\n \n let x = Binding(Base, Symbol(\"@inline\"))\n     @test defined(x) == true\n@@ -1565,8 +1571,7 @@ Base.@ccallable c51586_long()::Int = 3\n \n @testset \"Docs docstrings\" begin\n     undoc = Docs.undocumented_names(Docs)\n-    @test_broken isempty(undoc)\n-    @test undoc == [Symbol(\"@var\")]\n+    @test isempty(undoc)\n end\n \n # Docing the macroception macro"
    }
  ]
}