{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60311",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60311/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60311/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60311/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60311",
  "id": 3692789136,
  "node_id": "PR_kwDOABkWpM629-pe",
  "number": 60311,
  "title": "threads: Implement asymmetric atomic fences",
  "user": {
    "login": "Keno",
    "id": 1291671,
    "node_id": "MDQ6VXNlcjEyOTE2NzE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1291671?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Keno",
    "html_url": "https://github.com/Keno",
    "followers_url": "https://api.github.com/users/Keno/followers",
    "following_url": "https://api.github.com/users/Keno/following{/other_user}",
    "gists_url": "https://api.github.com/users/Keno/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Keno/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Keno/subscriptions",
    "organizations_url": "https://api.github.com/users/Keno/orgs",
    "repos_url": "https://api.github.com/users/Keno/repos",
    "events_url": "https://api.github.com/users/Keno/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Keno/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 6,
  "created_at": "2025-12-04T04:09:15Z",
  "updated_at": "2025-12-15T12:11:52Z",
  "closed_at": "2025-12-15T12:11:49Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60311",
    "html_url": "https://github.com/JuliaLang/julia/pull/60311",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60311.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60311.patch",
    "merged_at": "2025-12-15T12:11:49Z"
  },
  "body": "Asymmetric atomic fences are a performance optimization of regular atomic fences (the seq_cst version of which we expose as `Base.Threads.atomic_fence`). The problem with these regular fences is that they require a CPU fence instruction, which can be very expensive and is thus unsuitable for code in the hot path. Asymmetric fences on the other hand split an ordinary fence into two: A `light` side where the fence is extremely cheap (only a compiler reordering barrier) and a `heavy` side where the fence is very expensive.\r\n\r\nBasically the way it works is that the heavy side does a system call that issues an inter-processor-interrupt (IPI) which then issues the appropriate barrier instruction on the other CPU (i.e. both CPUs will have issues a barrier instruction, one of them just does it asynchronously due to interrupt).\r\n\r\nThe `light` and `heavy` naming here is taken from C++ PR1202R5 [1], which is the proposal for the same feature in the C++ standard library (to appear in the next iteration of the C++ concurrency spec).\r\n\r\nOn the julia side, these functions are exposed as\r\n`Threads.atomic_fence_light` and `Threads.atomic_fence_heavy`. The light side lowers to `fence singlethread` in llvm IR (the Core.Intrinsic atomic_fence is adjusted appropriately to faciliate this). The heavy side has OS-specifc implementations, where:\r\n\r\n1. Linux/FreeBSD try to use the `membarrier` syscall or a fallback to `mprotect` for systems that don't have it.\r\n2. Windows uses the `FlushProcessWriteBuffers` syscall.\r\n3. macOS uses an implementation from the dotnet runtime (https://github.com/dotnet/runtime/pull/44670), which the dotnet folks have checked with Apple does the right thing by happenstance (i.e. an IPI/memory barrier is needed to execute the syscall), but looks a little nonsensical by itself. However, since it's what Apple recommended to dotnet, I don't see much risk here, though I wouldn't be surprised if Apple added a proper syscall for this in the future (since freebsd has it now).\r\n\r\nNote that unlike the C++ spec, I have specified that `atomic_fence_heavy` does synchronize with `atomic_fence`. This matches the underlying system call. I suspect C++ chose to omit this for a hypothetical future architecture that has instruction support for doing this from userspace that would then not synchronize with ordinary barriers, but I think I would rather cross that bridge when we get there.\r\n\r\nI intend to use this in #60281, but it's an independently useful feature.\r\n\r\n[1] https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1202r5.pdf",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60311/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60311/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0
}