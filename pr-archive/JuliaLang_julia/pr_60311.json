{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60311",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60311/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60311/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60311/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60311",
  "id": 3692789136,
  "node_id": "PR_kwDOABkWpM629-pe",
  "number": 60311,
  "title": "threads: Implement asymmetric atomic fences",
  "user": {
    "login": "Keno",
    "id": 1291671,
    "node_id": "MDQ6VXNlcjEyOTE2NzE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1291671?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Keno",
    "html_url": "https://github.com/Keno",
    "followers_url": "https://api.github.com/users/Keno/followers",
    "following_url": "https://api.github.com/users/Keno/following{/other_user}",
    "gists_url": "https://api.github.com/users/Keno/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Keno/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Keno/subscriptions",
    "organizations_url": "https://api.github.com/users/Keno/orgs",
    "repos_url": "https://api.github.com/users/Keno/repos",
    "events_url": "https://api.github.com/users/Keno/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Keno/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 6,
  "created_at": "2025-12-04T04:09:15Z",
  "updated_at": "2025-12-15T12:11:52Z",
  "closed_at": "2025-12-15T12:11:49Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60311",
    "html_url": "https://github.com/JuliaLang/julia/pull/60311",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60311.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60311.patch",
    "merged_at": "2025-12-15T12:11:49Z"
  },
  "body": "Asymmetric atomic fences are a performance optimization of regular atomic fences (the seq_cst version of which we expose as `Base.Threads.atomic_fence`). The problem with these regular fences is that they require a CPU fence instruction, which can be very expensive and is thus unsuitable for code in the hot path. Asymmetric fences on the other hand split an ordinary fence into two: A `light` side where the fence is extremely cheap (only a compiler reordering barrier) and a `heavy` side where the fence is very expensive.\r\n\r\nBasically the way it works is that the heavy side does a system call that issues an inter-processor-interrupt (IPI) which then issues the appropriate barrier instruction on the other CPU (i.e. both CPUs will have issues a barrier instruction, one of them just does it asynchronously due to interrupt).\r\n\r\nThe `light` and `heavy` naming here is taken from C++ PR1202R5 [1], which is the proposal for the same feature in the C++ standard library (to appear in the next iteration of the C++ concurrency spec).\r\n\r\nOn the julia side, these functions are exposed as\r\n`Threads.atomic_fence_light` and `Threads.atomic_fence_heavy`. The light side lowers to `fence singlethread` in llvm IR (the Core.Intrinsic atomic_fence is adjusted appropriately to faciliate this). The heavy side has OS-specifc implementations, where:\r\n\r\n1. Linux/FreeBSD try to use the `membarrier` syscall or a fallback to `mprotect` for systems that don't have it.\r\n2. Windows uses the `FlushProcessWriteBuffers` syscall.\r\n3. macOS uses an implementation from the dotnet runtime (https://github.com/dotnet/runtime/pull/44670), which the dotnet folks have checked with Apple does the right thing by happenstance (i.e. an IPI/memory barrier is needed to execute the syscall), but looks a little nonsensical by itself. However, since it's what Apple recommended to dotnet, I don't see much risk here, though I wouldn't be surprised if Apple added a proper syscall for this in the future (since freebsd has it now).\r\n\r\nNote that unlike the C++ spec, I have specified that `atomic_fence_heavy` does synchronize with `atomic_fence`. This matches the underlying system call. I suspect C++ chose to omit this for a hypothetical future architecture that has instruction support for doing this from userspace that would then not synchronize with ordinary barriers, but I think I would rather cross that bridge when we get there.\r\n\r\nI intend to use this in #60281, but it's an independently useful feature.\r\n\r\n[1] https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1202r5.pdf",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60311/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60311/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "2656c7bb1ee1ace5d2b43505df95c54ecdc8491a",
      "filename": "Compiler/src/tfuncs.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/Compiler%2Fsrc%2Ftfuncs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/Compiler%2Fsrc%2Ftfuncs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftfuncs.jl?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -716,7 +716,7 @@ end\n @nospecs function pointerset_tfunc(\ud835\udd43::AbstractLattice, a, v, i, align)\n     return a\n end\n-@nospecs function atomic_fence_tfunc(\ud835\udd43::AbstractLattice, order)\n+@nospecs function atomic_fence_tfunc(\ud835\udd43::AbstractLattice, order, syncscope)\n     return Nothing\n end\n @nospecs function atomic_pointerref_tfunc(\ud835\udd43::AbstractLattice, a, order)\n@@ -757,7 +757,7 @@ add_tfunc(add_ptr, 2, 2, pointerarith_tfunc, 1)\n add_tfunc(sub_ptr, 2, 2, pointerarith_tfunc, 1)\n add_tfunc(pointerref, 3, 3, pointerref_tfunc, 4)\n add_tfunc(pointerset, 4, 4, pointerset_tfunc, 5)\n-add_tfunc(atomic_fence, 1, 1, atomic_fence_tfunc, 4)\n+add_tfunc(atomic_fence, 2, 2, atomic_fence_tfunc, 4)\n add_tfunc(atomic_pointerref, 2, 2, atomic_pointerref_tfunc, 4)\n add_tfunc(atomic_pointerset, 3, 3, atomic_pointerset_tfunc, 5)\n add_tfunc(atomic_pointerswap, 3, 3, atomic_pointerswap_tfunc, 5)"
    },
    {
      "sha": "5a57f178177f38a16a4d0c051ae77f6d3116f792",
      "filename": "NEWS.md",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/NEWS.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/NEWS.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/NEWS.md?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -21,6 +21,10 @@ Command-line option changes\n Multi-threading changes\n -----------------------\n \n+  - New functions `Threads.atomic_fence_heavy` and `Threads.atomic_fence_light` provide support for\n+    asymmetric atomic fences, speeding up atomic synchronization where one side of the synchronization\n+    runs significantly less often than the other ([#60311]).\n+\n Build system changes\n --------------------\n "
    },
    {
      "sha": "68ae27049adc01d90bbd834d90ab2f2618dd6560",
      "filename": "base/asyncevent.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/base%2Fasyncevent.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/base%2Fasyncevent.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fasyncevent.jl?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -165,7 +165,7 @@ function _trywait(t::Union{Timer, AsyncCondition})\n     set = t.set\n     if set\n         # full barrier now for AsyncCondition\n-        t isa Timer || Core.Intrinsics.atomic_fence(:acquire_release)\n+        t isa Timer || Core.Intrinsics.atomic_fence(:acquire_release, :system)\n     else\n         if !isopen(t)\n             set = t.set"
    },
    {
      "sha": "21689e06ba1a11b07682288e79fa2b5fec590adb",
      "filename": "base/atomics.jl",
      "status": "modified",
      "additions": 26,
      "deletions": 2,
      "changes": 28,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/base%2Fatomics.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/base%2Fatomics.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fatomics.jl?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -10,7 +10,7 @@ export\n     atomic_add!, atomic_sub!,\n     atomic_and!, atomic_nand!, atomic_or!, atomic_xor!,\n     atomic_max!, atomic_min!,\n-    atomic_fence\n+    atomic_fence, atomic_fence_light, atomic_fence_heavy\n \n \"\"\"\n     Threads.Atomic{T}\n@@ -329,4 +329,28 @@ fences should not be necessary in most cases.\n \n For further details, see LLVM's `fence` instruction.\n \"\"\"\n-atomic_fence() = Core.Intrinsics.atomic_fence(:sequentially_consistent)\n+atomic_fence() = Core.Intrinsics.atomic_fence(:sequentially_consistent, :system)\n+\n+\"\"\"\n+    Threads.atomic_fence_light()\n+\n+Insert the light side of an asymmetric sequential-consistency memory fence.\n+Asymmetric memory fences are useful in scenarios where one side of the\n+synchronization runs significantly less often than the other side. Use this\n+function on the side that runs often and [`atomic_fence_heavy`](@ref) on the\n+side that runs rarely.\n+\n+On supported operating systems and architectures this fence is cheaper than\n+`Threads.atomic_fence()`, but synchronizes only with [`atomic_fence_heavy`](@ref)\n+calls from other threads.\n+\"\"\"\n+atomic_fence_light() = Core.Intrinsics.atomic_fence(:sequentially_consistent, :singlethread)\n+\n+\"\"\"\n+    Threads.atomic_fence_heavy()\n+\n+Insert the heavy side of an asymmetric sequential-consistency memory fence.\n+Use this function on the side that runs rarely.\n+See [`atomic_fence_light`](@ref) for more details.\n+\"\"\"\n+atomic_fence_heavy() = ccall(:jl_membarrier, Cvoid, ())"
    },
    {
      "sha": "0b7d545e54d0883dbd1173a6cc64afe7003c068e",
      "filename": "doc/src/base/multi-threading.md",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/doc%2Fsrc%2Fbase%2Fmulti-threading.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/doc%2Fsrc%2Fbase%2Fmulti-threading.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fbase%2Fmulti-threading.md?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -50,6 +50,8 @@ Base.Threads.atomic_xor!\n Base.Threads.atomic_max!\n Base.Threads.atomic_min!\n Base.Threads.atomic_fence\n+Base.Threads.atomic_fence_heavy\n+Base.Threads.atomic_fence_light\n ```\n \n ## ccall using a libuv threadpool (Experimental)"
    },
    {
      "sha": "f513ef34b01ebdc5b365dfb8673d470fa94ef87e",
      "filename": "src/ast.c",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fast.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fast.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fast.c?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -319,6 +319,8 @@ void jl_init_common_symbols(void)\n     jl_atomic_sym = jl_symbol(\"atomic\");\n     jl_not_atomic_sym = jl_symbol(\"not_atomic\");\n     jl_unordered_sym = jl_symbol(\"unordered\");\n+    jl_singlethread_sym = jl_symbol(\"singlethread\");\n+    jl_system_sym = jl_symbol(\"system\");\n     jl_monotonic_sym = jl_symbol(\"monotonic\");\n     jl_acquire_sym = jl_symbol(\"acquire\");\n     jl_release_sym = jl_symbol(\"release\");"
    },
    {
      "sha": "4791d439e2ad0830f59b45d60b51e3ddf7a59204",
      "filename": "src/intrinsics.cpp",
      "status": "modified",
      "additions": 12,
      "deletions": 3,
      "changes": 15,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fintrinsics.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fintrinsics.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fintrinsics.cpp?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -915,17 +915,26 @@ static jl_cgval_t emit_pointerarith(jl_codectx_t &ctx, intrinsic f,\n static jl_cgval_t emit_atomicfence(jl_codectx_t &ctx, ArrayRef<jl_cgval_t> argv)\n {\n     const jl_cgval_t &ord = argv[0];\n+    const jl_cgval_t &ssid_arg = argv[1];\n+    llvm::SyncScope::ID ssid = llvm::SyncScope::System;\n+    if (!ssid_arg.constant || !jl_is_symbol(ssid_arg.constant) ||\n+        ((jl_sym_t*)ssid_arg.constant != jl_singlethread_sym &&\n+            (jl_sym_t*)ssid_arg.constant != jl_system_sym)) {\n+        return emit_runtime_call(ctx, atomic_fence, argv, 2);\n+    }\n+    if ((jl_sym_t*)ssid_arg.constant == jl_singlethread_sym)\n+        ssid = llvm::SyncScope::SingleThread;\n     if (ord.constant && jl_is_symbol(ord.constant)) {\n         enum jl_memory_order order = jl_get_atomic_order((jl_sym_t*)ord.constant, true, true);\n         if (order == jl_memory_order_invalid) {\n             emit_atomic_error(ctx, \"invalid atomic ordering\");\n             return jl_cgval_t(); // unreachable\n         }\n         if (order > jl_memory_order_monotonic)\n-            ctx.builder.CreateFence(get_llvm_atomic_order(order));\n+            ctx.builder.CreateFence(get_llvm_atomic_order(order), ssid);\n         return ghostValue(ctx, jl_nothing_type);\n     }\n-    return emit_runtime_call(ctx, atomic_fence, argv, 1);\n+    return emit_runtime_call(ctx, atomic_fence, argv, 2);\n }\n \n static jl_cgval_t emit_atomic_pointerref(jl_codectx_t &ctx, ArrayRef<jl_cgval_t> argv)\n@@ -1339,7 +1348,7 @@ static jl_cgval_t emit_intrinsic(jl_codectx_t &ctx, intrinsic f, jl_value_t **ar\n \n     case atomic_fence:\n         ++Emitted_atomic_fence;\n-        assert(nargs == 1);\n+        assert(nargs == 2);\n         return emit_atomicfence(ctx, argv);\n     case atomic_pointerref:\n         ++Emitted_atomic_pointerref;"
    },
    {
      "sha": "4fd5630afa38f3ae23ce9856a15abe92a843fba1",
      "filename": "src/intrinsics.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fintrinsics.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fintrinsics.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fintrinsics.h?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -95,7 +95,7 @@\n     ADD_I(pointerref, 3) \\\n     ADD_I(pointerset, 4) \\\n     /*  pointer atomics */ \\\n-    ADD_I(atomic_fence, 1) \\\n+    ADD_I(atomic_fence, 2) \\\n     ADD_I(atomic_pointerref, 2) \\\n     ADD_I(atomic_pointerset, 3) \\\n     ADD_I(atomic_pointerswap, 3) \\"
    },
    {
      "sha": "1a0ff14a82b55393eb9bf9e7aa820a59fab92434",
      "filename": "src/jl_exported_funcs.inc",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fjl_exported_funcs.inc",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fjl_exported_funcs.inc",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjl_exported_funcs.inc?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -506,6 +506,7 @@\n     XX(jl_vprintf) \\\n     XX(jl_wakeup_thread) \\\n     XX(jl_write_compiler_output) \\\n+    XX(jl_membarrier) \\\n \n #define JL_RUNTIME_EXPORTED_FUNCS_WIN(XX) \\\n     XX(jl_setjmp) \\"
    },
    {
      "sha": "9a85d1086d694cd07b5c1c5630b7ac14acd6fe41",
      "filename": "src/julia_internal.h",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fjulia_internal.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fjulia_internal.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia_internal.h?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -1689,7 +1689,7 @@ STATIC_INLINE int is_valid_intrinsic_elptr(jl_value_t *ety)\n JL_DLLEXPORT jl_value_t *jl_bitcast(jl_value_t *ty, jl_value_t *v);\n JL_DLLEXPORT jl_value_t *jl_pointerref(jl_value_t *p, jl_value_t *i, jl_value_t *align);\n JL_DLLEXPORT jl_value_t *jl_pointerset(jl_value_t *p, jl_value_t *x, jl_value_t *align, jl_value_t *i);\n-JL_DLLEXPORT jl_value_t *jl_atomic_fence(jl_value_t *order);\n+JL_DLLEXPORT jl_value_t *jl_atomic_fence(jl_value_t *order, jl_value_t *syncscope);\n JL_DLLEXPORT jl_value_t *jl_atomic_pointerref(jl_value_t *p, jl_value_t *order);\n JL_DLLEXPORT jl_value_t *jl_atomic_pointerset(jl_value_t *p, jl_value_t *x, jl_value_t *order);\n JL_DLLEXPORT jl_value_t *jl_atomic_pointerswap(jl_value_t *p, jl_value_t *x, jl_value_t *order);\n@@ -2010,6 +2010,8 @@ JL_DLLEXPORT int jl_isabspath(const char *in) JL_NOTSAFEPOINT;\n     XX(uninferred_sym) \\\n     XX(unordered_sym) \\\n     XX(unused_sym) \\\n+    XX(singlethread_sym) \\\n+    XX(system_sym)\n \n #define XX(name) extern JL_DLLEXPORT jl_sym_t *jl_##name;\n JL_COMMON_SYMBOLS(XX)"
    },
    {
      "sha": "c2abb705fd7c6f26f80fca9247bd35ed48281eaf",
      "filename": "src/runtime_intrinsics.c",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fruntime_intrinsics.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fruntime_intrinsics.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fruntime_intrinsics.c?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -622,10 +622,17 @@ JL_DLLEXPORT jl_value_t *jl_atomic_pointerreplace(jl_value_t *p, jl_value_t *exp\n     return result;\n }\n \n-JL_DLLEXPORT jl_value_t *jl_atomic_fence(jl_value_t *order_sym)\n+JL_DLLEXPORT jl_value_t *jl_atomic_fence(jl_value_t *order_sym, jl_value_t *syncscope_sym)\n {\n     JL_TYPECHK(fence, symbol, order_sym);\n+    JL_TYPECHK(fence, symbol, syncscope_sym);\n     enum jl_memory_order order = jl_get_atomic_order_checked((jl_sym_t*)order_sym, 1, 1);\n+    if ((jl_sym_t*)syncscope_sym == jl_singlethread_sym) {\n+        asm volatile (\"\" : : : \"memory\");\n+        return jl_nothing;\n+    } else if ((jl_sym_t*)syncscope_sym != jl_system_sym) {\n+        jl_error(\"atomic_fence: invalid syncscope\");\n+    }\n     if (order > jl_memory_order_monotonic)\n         jl_fence();\n     return jl_nothing;"
    },
    {
      "sha": "55a430425dce51ad99ceed00a8ccb2b975eb752d",
      "filename": "src/signals-mach.c",
      "status": "modified",
      "additions": 44,
      "deletions": 0,
      "changes": 44,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fsignals-mach.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fsignals-mach.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-mach.c?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -5,6 +5,7 @@\n #include <mach/clock.h>\n #include <mach/clock_types.h>\n #include <mach/clock_reply.h>\n+#include <mach/thread_state.h>\n #include <mach/mach_traps.h>\n #include <mach/task.h>\n #include <mach/mig_errors.h>\n@@ -891,3 +892,46 @@ JL_DLLEXPORT void jl_profile_stop_timer(void)\n     profile_all_tasks = 0;\n     uv_mutex_unlock(&bt_data_prof_lock);\n }\n+\n+// The mprotect implementation in signals-unix.c does not work on macOS/aarch64, as mentioned.\n+// This implementation comes from dotnet, but is similarly dependent on undocumented behavior of the OS.\n+// Copyright (c) .NET Foundation and Contributors\n+// MIT LICENSE\n+JL_DLLEXPORT void jl_membarrier(void) {\n+    uintptr_t sp;\n+    uintptr_t registerValues[128];\n+    kern_return_t machret;\n+\n+    // Iterate through each of the threads in the list.\n+    int nthreads = jl_atomic_load_acquire(&jl_n_threads);\n+    for (int tid = 0; tid < nthreads; tid++) {\n+        jl_ptls_t ptls2 = jl_atomic_load_relaxed(&jl_all_tls_states)[tid];\n+        thread_act_t thread = pthread_mach_thread_np(ptls2->system_id);\n+        if (__builtin_available (macOS 10.14, iOS 12, tvOS 9, *))\n+        {\n+            // Request the threads pointer values to force the thread to emit a memory barrier\n+            size_t registers = 128;\n+            machret = thread_get_register_pointer_values(thread, &sp, &registers, registerValues);\n+        }\n+        else\n+        {\n+            // fallback implementation for older OS versions\n+#if defined(_CPU_X86_64_)\n+            x86_thread_state64_t threadState;\n+            mach_msg_type_number_t count = x86_THREAD_STATE64_COUNT;\n+            machret = thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&threadState, &count);\n+#elif defined(_CPU_AARCH64_)\n+            arm_thread_state64_t threadState;\n+            mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;\n+            machret = thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&threadState, &count);\n+#else\n+            #error Unexpected architecture\n+#endif\n+        }\n+\n+        if (machret == KERN_INSUFFICIENT_BUFFER_SIZE)\n+        {\n+            HANDLE_MACH_ERROR(\"thread_get_register_pointer_values()\", machret);\n+        }\n+    }\n+}"
    },
    {
      "sha": "3868d16a60e56b80471e1e8150f48c2f54d42252",
      "filename": "src/signals-unix.c",
      "status": "modified",
      "additions": 174,
      "deletions": 0,
      "changes": 174,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fsignals-unix.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fsignals-unix.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-unix.c?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -1274,3 +1274,177 @@ JL_DLLEXPORT int jl_repl_raise_sigtstp(void)\n {\n     return raise(SIGTSTP);\n }\n+\n+#if !defined(_OS_DARWIN_)\n+// Thread suspension based membarrier fallback.\n+// This is a sound but slow implementation that suspends and resumes each thread\n+// to force them to execute memory barriers via the signal handling mechanism.\n+// This is used as a fallback when neither the membarrier syscall nor the mprotect\n+// hack are available or working.\n+static void jl_thread_suspend_membarrier(void)\n+{\n+    bt_context_t ctx;\n+    // Suspend each thread and immediately resume it.\n+    // The act of suspending/resuming forces a memory barrier via\n+    // the signal handler mechanism.\n+    // jl_thread_suspend tries to interrupt the thread for up to 1 second,\n+    // so we retry in a loop until it succeeds or we determine the thread\n+    // is no longer alive.\n+    for (int tid = 0; tid < jl_atomic_load_acquire(&jl_n_threads); tid++) {\n+        while (!jl_thread_suspend(tid, &ctx)) {\n+            jl_ptls_t ptls2 = jl_atomic_load_relaxed(&jl_all_tls_states)[tid];\n+            jl_task_t *ct2 = ptls2 ? jl_atomic_load_relaxed(&ptls2->current_task) : NULL;\n+            if (ct2 == NULL) {\n+                // this thread is not alive or already dead, move to next\n+                goto next_thread;\n+            }\n+            // thread is alive but suspend failed, retry\n+        }\n+        jl_thread_resume(tid);\n+next_thread:;\n+    }\n+}\n+\n+// Implementation of the `mprotect` based membarrier fallback.\n+// This is a common fallback based on the observation that `mprotect` happens to\n+// issue the necessary memory barriers. However, there is no spec that\n+// guarantees this behavior. On AArch64, it is known not to work on either\n+// Linux or FreeBSD, so we don't use it there. However, we use it as a fallback\n+// here for older versions of Linux and FreeBSD on x86 where we know that it\n+// happens to work.\n+#if !defined(_CPU_AARCH64_) && !defined(_CPU_ARM_)\n+static pthread_mutex_t mprotect_barrier_lock = PTHREAD_MUTEX_INITIALIZER;\n+static _Atomic(uint64_t) *mprotect_barrier_page = NULL;\n+// Returns 1 on success, 0 on failure (e.g. mlock fails)\n+static int jl_init_mprotect_membarrier(void)\n+{\n+    int result = pthread_mutex_lock(&mprotect_barrier_lock);\n+    assert(result == 0);\n+    if (mprotect_barrier_page == NULL) {\n+        size_t pagesize = jl_getpagesize();\n+\n+        mprotect_barrier_page = (_Atomic(uint64_t) *)\n+                                     mmap(NULL, pagesize, PROT_READ | PROT_WRITE,\n+                                     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+        if (mprotect_barrier_page == MAP_FAILED) {\n+            mprotect_barrier_page = NULL;\n+            result = pthread_mutex_unlock(&mprotect_barrier_lock);\n+            assert(result == 0);\n+            return 0;\n+        }\n+        result = mlock(mprotect_barrier_page, pagesize);\n+        if (result != 0) {\n+            // mlock failed (e.g. RLIMIT_MEMLOCK too low), fall back to thread suspension\n+            munmap(mprotect_barrier_page, pagesize);\n+            mprotect_barrier_page = NULL;\n+            result = pthread_mutex_unlock(&mprotect_barrier_lock);\n+            assert(result == 0);\n+            return 0;\n+        }\n+    }\n+    result = pthread_mutex_unlock(&mprotect_barrier_lock);\n+    assert(result == 0);\n+    (void)result;\n+    return 1;\n+}\n+\n+static void jl_mprotect_membarrier(void)\n+{\n+    int result = pthread_mutex_lock(&mprotect_barrier_lock);\n+    assert(result == 0);\n+    size_t pagesize = jl_getpagesize();\n+    result = mprotect(mprotect_barrier_page, pagesize, PROT_READ | PROT_WRITE);\n+    jl_atomic_fetch_add_relaxed(mprotect_barrier_page, 1);\n+    assert(result == 0);\n+    result = mprotect(mprotect_barrier_page, pagesize, PROT_NONE);\n+    assert(result == 0);\n+    result = pthread_mutex_unlock(&mprotect_barrier_lock);\n+    assert(result == 0);\n+    (void)result;\n+}\n+#endif // !_CPU_AARCH64_ && !_CPU_ARM_\n+\n+// Membarrier implementation selection\n+enum membarrier_implementation {\n+    MEMBARRIER_IMPLEMENTATION_UNKNOWN        = 0,\n+    MEMBARRIER_IMPLEMENTATION_SYS_MEMBARRIER = 1,\n+    MEMBARRIER_IMPLEMENTATION_MPROTECT       = 2,\n+    MEMBARRIER_IMPLEMENTATION_THREAD_SUSPEND = 3\n+};\n+\n+static _Atomic(enum membarrier_implementation) membarrier_impl = MEMBARRIER_IMPLEMENTATION_UNKNOWN;\n+\n+// Linux and FreeBSD have compatible membarrier syscall support\n+#if defined(_OS_LINUX_)\n+#   include <sys/syscall.h>\n+#   if defined(__NR_membarrier)\n+enum membarrier_cmd {\n+    MEMBARRIER_CMD_QUERY                        = 0,\n+    MEMBARRIER_CMD_PRIVATE_EXPEDITED            = (1 << 3),\n+    MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED   = (1 << 4),\n+};\n+#    define membarrier(...) syscall(__NR_membarrier, __VA_ARGS__)\n+#    define HAVE_MEMBARRIER_SYSCALL\n+#  else\n+#    warning \"Missing linux kernel headers for membarrier syscall, support disabled\"\n+#  endif\n+#elif defined(_OS_FREEBSD_)\n+#  include <sys/param.h>\n+#  if __FreeBSD_version >= 1401500\n+#    include <sys/membarrier.h>\n+#    define HAVE_MEMBARRIER_SYSCALL\n+#  endif\n+#endif\n+\n+static enum membarrier_implementation jl_init_membarrier(void) {\n+#ifdef HAVE_MEMBARRIER_SYSCALL\n+    int ret = membarrier(MEMBARRIER_CMD_QUERY, 0);\n+    int needed = MEMBARRIER_CMD_PRIVATE_EXPEDITED | MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED;\n+    if (ret > 0 && ((ret & needed) == needed)) {\n+        // supported\n+        if (membarrier(MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED, 0) == 0) {\n+            // working\n+            jl_atomic_store_relaxed(&membarrier_impl, MEMBARRIER_IMPLEMENTATION_SYS_MEMBARRIER);\n+            return MEMBARRIER_IMPLEMENTATION_SYS_MEMBARRIER;\n+        }\n+    }\n+#endif\n+    // The mprotect fallback is known not to work on AArch64, so skip it there\n+#if !defined(_CPU_AARCH64_) && !defined(_CPU_ARM_)\n+    if (jl_init_mprotect_membarrier()) {\n+        jl_atomic_store_relaxed(&membarrier_impl, MEMBARRIER_IMPLEMENTATION_MPROTECT);\n+        return MEMBARRIER_IMPLEMENTATION_MPROTECT;\n+    }\n+#endif\n+    // Fall back to thread suspension (sound but slow)\n+    jl_atomic_store_relaxed(&membarrier_impl, MEMBARRIER_IMPLEMENTATION_THREAD_SUSPEND);\n+    return MEMBARRIER_IMPLEMENTATION_THREAD_SUSPEND;\n+}\n+\n+JL_DLLEXPORT void jl_membarrier(void) {\n+    enum membarrier_implementation impl = jl_atomic_load_relaxed(&membarrier_impl);\n+    if (impl == MEMBARRIER_IMPLEMENTATION_UNKNOWN) {\n+        impl = jl_init_membarrier();\n+    }\n+    switch (impl) {\n+#ifdef HAVE_MEMBARRIER_SYSCALL\n+    case MEMBARRIER_IMPLEMENTATION_SYS_MEMBARRIER: {\n+        int ret = membarrier(MEMBARRIER_CMD_PRIVATE_EXPEDITED, 0);\n+        assert(ret == 0);\n+        (void)ret;\n+        break;\n+    }\n+#endif\n+#if !defined(_CPU_AARCH64_) && !defined(_CPU_ARM_)\n+    case MEMBARRIER_IMPLEMENTATION_MPROTECT:\n+        jl_mprotect_membarrier();\n+        break;\n+#endif\n+    case MEMBARRIER_IMPLEMENTATION_THREAD_SUSPEND:\n+        jl_thread_suspend_membarrier();\n+        break;\n+    default:\n+        abort();\n+    }\n+}\n+#endif // !_OS_DARWIN_"
    },
    {
      "sha": "e0968b35e8555032da674afa0928c6a0e39f667f",
      "filename": "src/signals-win.c",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fsignals-win.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/src%2Fsignals-win.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-win.c?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -664,3 +664,7 @@ void jl_install_thread_signal_handler(jl_ptls_t ptls)\n         have_backtrace_fiber = 1;\n     }\n }\n+\n+JL_DLLEXPORT void jl_membarrier(void) {\n+    FlushProcessWriteBuffers();\n+}"
    },
    {
      "sha": "03ba86f85676e826c36e1c8528c9f26cdb61c575",
      "filename": "test/intrinsics.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/test%2Fintrinsics.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/test%2Fintrinsics.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fintrinsics.jl?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -395,13 +395,13 @@ end\n end\n \n using Base.Experimental: @force_compile\n-@test_throws ConcurrencyViolationError(\"invalid atomic ordering\") (@force_compile; Core.Intrinsics.atomic_fence(:u)) === nothing\n-@test_throws ConcurrencyViolationError(\"invalid atomic ordering\") (@force_compile; Core.Intrinsics.atomic_fence(Symbol(\"u\", \"x\"))) === nothing\n-@test_throws ConcurrencyViolationError(\"invalid atomic ordering\") Core.Intrinsics.atomic_fence(Symbol(\"u\", \"x\")) === nothing\n+@test_throws ConcurrencyViolationError(\"invalid atomic ordering\") (@force_compile; Core.Intrinsics.atomic_fence(:u, :system)) === nothing\n+@test_throws ConcurrencyViolationError(\"invalid atomic ordering\") (@force_compile; Core.Intrinsics.atomic_fence(Symbol(\"u\", \"x\"), :system)) === nothing\n+@test_throws ConcurrencyViolationError(\"invalid atomic ordering\") Core.Intrinsics.atomic_fence(Symbol(\"u\", \"x\"), :system) === nothing\n for order in (:not_atomic, :monotonic, :acquire, :release, :acquire_release, :sequentially_consistent)\n-    @test Core.Intrinsics.atomic_fence(order) === nothing\n-    @test (order -> Core.Intrinsics.atomic_fence(order))(order) === nothing\n-    @test Base.invokelatest(@eval () -> Core.Intrinsics.atomic_fence($(QuoteNode(order)))) === nothing\n+    @test Core.Intrinsics.atomic_fence(order, :system) === nothing\n+    @test (order -> Core.Intrinsics.atomic_fence(order, :system))(order) === nothing\n+    @test Base.invokelatest(@eval () -> Core.Intrinsics.atomic_fence($(QuoteNode(order)), :system)) === nothing\n end\n @test Core.Intrinsics.atomic_pointerref(C_NULL, :sequentially_consistent) === nothing\n @test (@force_compile; Core.Intrinsics.atomic_pointerref(C_NULL, :sequentially_consistent)) === nothing"
    },
    {
      "sha": "6fb4a9f2b7b89007e7ba1582f8b8c8b5bc64dc78",
      "filename": "test/threads_exec.jl",
      "status": "modified",
      "additions": 50,
      "deletions": 0,
      "changes": 50,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b399d93b9eaf5bd1f223fefbb667e111a824c151/test%2Fthreads_exec.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b399d93b9eaf5bd1f223fefbb667e111a824c151/test%2Fthreads_exec.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fthreads_exec.jl?ref=b399d93b9eaf5bd1f223fefbb667e111a824c151",
      "patch": "@@ -464,6 +464,56 @@ function test_fence()\n end\n test_fence()\n \n+# Test asymmetric thread fences\n+struct AsymmetricFenceTestData\n+    n::Int\n+    x::AtomicMemory{Int}\n+    y::AtomicMemory{Int}\n+    read_x::AtomicMemory{Int}\n+    read_y::AtomicMemory{Int}\n+end\n+function test_asymmetric_fence(data::AsymmetricFenceTestData, cond1, cond2, threadid, it)\n+    if (threadid % 2) == 0\n+        @atomic :monotonic data.x[it] = 1\n+        Threads.atomic_fence_heavy()\n+        @atomic :monotonic data.read_y[it] = @atomic :monotonic data.y[it]\n+        wait(cond1)\n+        notify(cond2)\n+    else\n+        @atomic :monotonic data.y[it] = 1\n+        Threads.atomic_fence_light()\n+        @atomic :monotonic data.read_x[it] = @atomic :monotonic data.x[it]\n+        notify(cond1)\n+        wait(cond2)\n+    end\n+end\n+function test_asymmetric_fence(data::AsymmetricFenceTestData, cond1, cond2, threadid)\n+    for i = 1:data.n\n+        test_asymmetric_fence(data, cond1, cond2, threadid, i)\n+    end\n+end\n+function test_asymmetric_fence()\n+    asymmetric_test_count = 200_000\n+    cond1 = Threads.Event(true)\n+    cond2 = Threads.Event(true)\n+    data = AsymmetricFenceTestData(asymmetric_test_count,\n+                                   AtomicMemory{Int}(undef, asymmetric_test_count),\n+                                   AtomicMemory{Int}(undef, asymmetric_test_count),\n+                                   AtomicMemory{Int}(undef, asymmetric_test_count),\n+                                   AtomicMemory{Int}(undef, asymmetric_test_count))\n+    for i = 1:asymmetric_test_count\n+        @atomic :monotonic data.x[i] = 0\n+        @atomic :monotonic data.y[i] = 0\n+        @atomic :monotonic data.read_x[i] = typemax(Int)\n+        @atomic :monotonic data.read_y[i] = typemax(Int)\n+    end\n+    t1 = @Threads.spawn test_asymmetric_fence(data, cond1, cond2, 1)\n+    t2 = @Threads.spawn test_asymmetric_fence(data, cond1, cond2, 2)\n+    wait(t1); wait(t2)\n+    @test !any((data.read_x .== 0) .& (data.read_y .== 0))\n+end\n+test_asymmetric_fence()\n+\n # Test load / store with various types\n let atomictypes = (Int8, Int16, Int32, Int64, Int128,\n                    UInt8, UInt16, UInt32, UInt64, UInt128,"
    }
  ]
}