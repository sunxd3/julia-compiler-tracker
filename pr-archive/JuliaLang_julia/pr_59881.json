{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59881",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59881/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59881/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59881/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59881",
  "id": 3527855658,
  "node_id": "PR_kwDOABkWpM6uZvT_",
  "number": 59881,
  "title": "loading: More simplification",
  "user": {
    "login": "Keno",
    "id": 1291671,
    "node_id": "MDQ6VXNlcjEyOTE2NzE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1291671?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Keno",
    "html_url": "https://github.com/Keno",
    "followers_url": "https://api.github.com/users/Keno/followers",
    "following_url": "https://api.github.com/users/Keno/following{/other_user}",
    "gists_url": "https://api.github.com/users/Keno/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Keno/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Keno/subscriptions",
    "organizations_url": "https://api.github.com/users/Keno/orgs",
    "repos_url": "https://api.github.com/users/Keno/repos",
    "events_url": "https://api.github.com/users/Keno/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Keno/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 1,
  "created_at": "2025-10-18T00:15:16Z",
  "updated_at": "2025-10-30T02:19:09Z",
  "closed_at": "2025-10-30T02:19:07Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59881",
    "html_url": "https://github.com/JuliaLang/julia/pull/59881",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59881.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59881.patch",
    "merged_at": "2025-10-30T02:19:07Z"
  },
  "body": "Mostly unswitches the distinction between a top-level load and a load into another project. The hope is that by keeping the code load flow more linear, it becomes easier to follow. No behavioral changes intended.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59881/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59881/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "1721969cfbf0164e94e4a10cc886de66367fe8e3",
      "filename": "base/loading.jl",
      "status": "modified",
      "additions": 87,
      "deletions": 78,
      "changes": 165,
      "blob_url": "https://github.com/JuliaLang/julia/blob/79f503bcf3d154d81b1370312eff9204fb2af685/base%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/79f503bcf3d154d81b1370312eff9204fb2af685/base%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Floading.jl?ref=79f503bcf3d154d81b1370312eff9204fb2af685",
      "patch": "@@ -333,62 +333,56 @@ Same as [`Base.identify_package`](@ref) except that the path to the environment\n is also returned, except when the identity is not identified.\n \"\"\"\n identify_package_env(where::Module, name::String) = identify_package_env(PkgId(where), name)\n-function identify_package_env(where::PkgId, name::String)\n-    assert_havelock(require_lock)\n-    cache = LOADING_CACHE[]\n-    if cache !== nothing\n-        pkg_env = get(cache.identified_where, (where, name), missing)\n-        pkg_env === missing || return pkg_env\n-    end\n-    pkg_env = nothing\n-    if where.name === name\n-        return (where, nothing)\n-    elseif where.uuid === nothing\n-        pkg_env = identify_package_env(name) # ignore `where`\n-    else\n-        for env in load_path()\n-            pkgid = manifest_deps_get(env, where, name)\n-            # If we didn't find `where` at all, keep looking through the environment stack\n-            pkgid === nothing && continue\n-            if pkgid.uuid !== nothing\n-                pkg_env = pkgid, env\n-            end\n-            # If we don't have pkgid.uuid, still break here - this is a sentinel that indicates\n-            # that we've found `where` but it did not have the required dependency. We terminate the search.\n-            break\n+function identify_package_env(where::Union{PkgId, Nothing}, name::String)\n+    # Special cases\n+    if where !== nothing\n+        if where.name === name\n+            # Project tries to load itself\n+            return (where, nothing)\n+        elseif where.uuid === nothing\n+            # Project without Project.toml - treat as toplevel load\n+            where = nothing\n         end\n-        if pkg_env === nothing && is_stdlib(where)\n-            # if not found it could be that manifests are from a different julia version/commit\n-            # where stdlib dependencies have changed, so look up deps based on the stdlib Project.toml\n-            # as a fallback\n-            pkg_env = identify_stdlib_project_dep(where, name)\n-        end\n-    end\n-    if cache !== nothing\n-        cache.identified_where[(where, name)] = pkg_env\n     end\n-    return pkg_env\n-end\n-function identify_package_env(name::String)\n+\n+    # Check if we have a cached answer for this\n     assert_havelock(require_lock)\n     cache = LOADING_CACHE[]\n+    cache_key = where === nothing ? name : (where, name)\n     if cache !== nothing\n-        pkg_env = get(cache.identified, name, missing)\n+        env_cache = where === nothing ? cache.identified : cache.identified_where\n+        pkg_env = get(env_cache, cache_key, missing)\n         pkg_env === missing || return pkg_env\n     end\n+\n+    # Main part: Search through all environments in the load path to see if we have\n+    # a matching entry.\n     pkg_env = nothing\n     for env in load_path()\n-        pkg = project_deps_get(env, name)\n-        if pkg !== nothing\n-            pkg_env = pkg, env # found--return it\n-            break\n+        pkgid = environment_deps_get(env, where, name)\n+        # If we didn't find `where` at all, keep looking through the environment stack\n+        pkgid === nothing && continue\n+        if pkgid.uuid !== nothing || where === nothing\n+            pkg_env = pkgid, env\n         end\n+        # If we don't have pkgid.uuid, still break here - this is a sentinel that indicates\n+        # that we've found `where` but it did not have the required dependency. We terminate the search.\n+        break\n     end\n+    if pkg_env === nothing && where !== nothing && is_stdlib(where)\n+        # if not found it could be that manifests are from a different julia version/commit\n+        # where stdlib dependencies have changed, so look up deps based on the stdlib Project.toml\n+        # as a fallback\n+        pkg_env = identify_stdlib_project_dep(where, name)\n+    end\n+\n+    # Cache the result\n     if cache !== nothing\n-        cache.identified[name] = pkg_env\n+        env_cache[cache_key] = pkg_env\n     end\n     return pkg_env\n end\n+identify_package_env(name::String) = identify_package_env(nothing, name)\n \n function identify_stdlib_project_dep(stdlib::PkgId, depname::String)\n     @debug \"\"\"\n@@ -447,19 +441,18 @@ function locate_package_env(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)\n     path = nothing\n     env\u2032 = nothing\n     if pkg.uuid === nothing\n+        # The project we're looking for does not have a Project.toml (n.b. - present\n+        # `Project.toml` without UUID gets a path-based dummy UUID). It must have\n+        # come from an implicit manifest environment, so go through those only.\n         for env in load_path()\n-            # look for the toplevel pkg `pkg.name` in this entry\n-            found = project_deps_get(env, pkg.name)\n-            if found !== nothing\n+            project_file = env_project_file(env)\n+            (project_file isa Bool && project_file) || continue\n+            found = implicit_manifest_pkgid(env, pkg.name)\n+            if found !== nothing && found.uuid === nothing\n                 @assert found.name == pkg.name\n-                if found.uuid === nothing\n-                    # pkg.name is present in this directory or project file,\n-                    # return the path the entry point for the code, if it could be found\n-                    # otherwise, signal failure\n-                    path = implicit_manifest_uuid_path(env, pkg)\n-                    env\u2032 = env\n-                    @goto done\n-                end\n+                path = implicit_manifest_uuid_path(env, pkg)\n+                env\u2032 = env\n+                @goto done\n             end\n             if !(loading_extension || precompiling_extension)\n                 stopenv == env && @goto done\n@@ -715,27 +708,18 @@ function base_project(project_file)\n     end\n end\n \n-function project_deps_get(env::String, name::String)::Union{Nothing,PkgId}\n-    project_file = env_project_file(env)\n-    if project_file isa String\n-        pkg_uuid = explicit_project_deps_get(project_file, name)\n-        pkg_uuid === nothing || return PkgId(pkg_uuid, name)\n-    elseif project_file\n-        return implicit_project_deps_get(env, name)\n-    end\n-    return nothing\n-end\n-\n function package_get_here(project_file, name::String)\n     # if `where` matches the project, use [deps] section as manifest, and stop searching\n     pkg_uuid = explicit_project_deps_get(project_file, name)\n     pkg_uuid === nothing && return PkgId(name)\n     return PkgId(pkg_uuid, name)\n end\n \n-function package_get(project_file, where::PkgId, name::String)\n-    proj = project_file_name_uuid(project_file, where.name)\n-    proj != where && return nothing\n+function package_get(project_file, where::Union{Nothing, PkgId}, name::String)\n+    if where !== nothing\n+        proj = project_file_name_uuid(project_file, where.name)\n+        proj != where && return nothing\n+    end\n     return package_get_here(project_file, name)\n end\n \n@@ -766,23 +750,51 @@ function package_extension_get(project_file, where::PkgId, name::String)\n     return nothing\n end\n \n-function manifest_deps_get(env::String, where::PkgId, name::String)::Union{Nothing,PkgId}\n-    @assert where.uuid !== nothing\n+function environment_deps_get(env::String, where::Union{Nothing,PkgId}, name::String)::Union{Nothing,PkgId}\n+    @assert where === nothing || where.uuid !== nothing\n     project_file = env_project_file(env)\n     implicit_manifest = !(project_file isa String)\n     if implicit_manifest\n         project_file || return nothing\n+        if where === nothing\n+            # Toplevel load with a directory (implicit manifest) - all we look for is the\n+            # existence of the package name in the directory.\n+            pkg = implicit_manifest_pkgid(env, name)\n+            return pkg\n+        end\n         project_file = implicit_manifest_project(env, where)\n         project_file === nothing && return nothing\n     end\n \n-    # 1. Are we loading into the top-level project itself? dependencies come from [deps]\n-    #    N.B.: Here \"top-level\" includes package loaded from an implicit manifest, which\n-    #          uses the same code path.\n+    # Are we\n+    #    a) loading into a top-level project itself\n+    #    b) loading into a non-top-level project that was part of an implicit\n+    #       manifest environment (and for which we found the project file above)\n+    #    c) performing a top-level load (where === nothing) - i.e. we're looking\n+    #       at an environment's project file.\n+    #\n+    # If so, we may load either:\n+    #   I: the project itself (if name matches where)\n+    #   II: a dependency from [deps] section of the project file\n+    #\n+    # N.B.: Here \"top-level\" includes package loaded from an implicit manifest, which\n+    #       uses the same code path. Otherwise this is the active project.\n     pkg = package_get(project_file, where, name)\n-    pkg === nothing || return pkg\n+    if pkg !== nothing\n+        if where === nothing && pkg.uuid === nothing\n+            # This is a top-level load - even though we didn't find the dependency\n+            # here, we still want to keep looking through the top-level environment stack.\n+            return nothing\n+        end\n+        return pkg\n+    end\n \n-    # 2. Are we an extension of the top-level project? dependencies come from [weakdeps] and [deps]\n+    @assert where !== nothing\n+\n+    # Are we an extension of a project from cases a), b) above\n+    # If so, in addition to I, II above, we get:\n+    #   III: A dependency from [weakdeps] section of the project file as long\n+    #        as it is an extension trigger for `where` in the `extensions` section.\n     pkg = package_extension_get(project_file, where, name)\n     pkg === nothing || return pkg\n \n@@ -1160,10 +1172,7 @@ function explicit_manifest_entry_path(manifest_file::String, pkg::PkgId, entry::\n end\n \n ## implicit project & manifest API ##\n-\n-# look for an entry point for `name` from a top-level package (no environment)\n-# otherwise return `nothing` to indicate the caller should keep searching\n-function implicit_project_deps_get(dir::String, name::String)::Union{Nothing,PkgId}\n+function implicit_manifest_pkgid(dir::String, name::String)::Union{Nothing,PkgId}\n     path, project_file = entry_point_and_project_file(dir, name)\n     if project_file === nothing\n         path === nothing && return nothing\n@@ -1174,7 +1183,7 @@ function implicit_project_deps_get(dir::String, name::String)::Union{Nothing,Pkg\n     return proj\n end\n \n-function implicit_manifest_project(dir, pkg::PkgId)::Union{Nothing, String}\n+function implicit_manifest_project(dir::String, pkg::PkgId)::Union{Nothing, String}\n     @assert pkg.uuid !== nothing\n     project_file = entry_point_and_project_file(dir, pkg.name)[2]\n     if project_file === nothing"
    },
    {
      "sha": "ad5eab3768760e42cf67056410a07fee690bc4f4",
      "filename": "test/loading.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/79f503bcf3d154d81b1370312eff9204fb2af685/test%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/79f503bcf3d154d81b1370312eff9204fb2af685/test%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Floading.jl?ref=79f503bcf3d154d81b1370312eff9204fb2af685",
      "patch": "@@ -623,9 +623,12 @@ function test_find(\n end\n \n @testset \"find_package with one env in load path\" begin\n-    for (env, (_, _, roots, graph, paths)) in envs\n-        push!(empty!(LOAD_PATH), env)\n-        test_find(roots, graph, paths)\n+    for idx in eachindex(envs)\n+        @testset let idx=idx\n+            (env, (_, _, roots, graph, paths)) = envs[idx]\n+            push!(empty!(LOAD_PATH), env)\n+            test_find(roots, graph, paths)\n+        end\n     end\n end\n "
    }
  ]
}