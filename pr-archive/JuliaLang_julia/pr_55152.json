{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/55152",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/55152/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/55152/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/55152/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/55152",
  "id": 2413909147,
  "node_id": "PR_kwDOABkWpM51qI0-",
  "number": 55152,
  "title": "make codepoint(c) work for overlong chars",
  "user": {
    "login": "stevengj",
    "id": 2913679,
    "node_id": "MDQ6VXNlcjI5MTM2Nzk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2913679?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/stevengj",
    "html_url": "https://github.com/stevengj",
    "followers_url": "https://api.github.com/users/stevengj/followers",
    "following_url": "https://api.github.com/users/stevengj/following{/other_user}",
    "gists_url": "https://api.github.com/users/stevengj/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/stevengj/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/stevengj/subscriptions",
    "organizations_url": "https://api.github.com/users/stevengj/orgs",
    "repos_url": "https://api.github.com/users/stevengj/repos",
    "events_url": "https://api.github.com/users/stevengj/events{/privacy}",
    "received_events_url": "https://api.github.com/users/stevengj/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 82096350,
      "node_id": "MDU6TGFiZWw4MjA5NjM1MA==",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/unicode",
      "name": "unicode",
      "color": "5f4a60",
      "default": false,
      "description": "Related to unicode characters and encodings"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": {
    "login": "StefanKarpinski",
    "id": 153596,
    "node_id": "MDQ6VXNlcjE1MzU5Ng==",
    "avatar_url": "https://avatars.githubusercontent.com/u/153596?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/StefanKarpinski",
    "html_url": "https://github.com/StefanKarpinski",
    "followers_url": "https://api.github.com/users/StefanKarpinski/followers",
    "following_url": "https://api.github.com/users/StefanKarpinski/following{/other_user}",
    "gists_url": "https://api.github.com/users/StefanKarpinski/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/StefanKarpinski/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/StefanKarpinski/subscriptions",
    "organizations_url": "https://api.github.com/users/StefanKarpinski/orgs",
    "repos_url": "https://api.github.com/users/StefanKarpinski/repos",
    "events_url": "https://api.github.com/users/StefanKarpinski/events{/privacy}",
    "received_events_url": "https://api.github.com/users/StefanKarpinski/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "StefanKarpinski",
      "id": 153596,
      "node_id": "MDQ6VXNlcjE1MzU5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/153596?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/StefanKarpinski",
      "html_url": "https://github.com/StefanKarpinski",
      "followers_url": "https://api.github.com/users/StefanKarpinski/followers",
      "following_url": "https://api.github.com/users/StefanKarpinski/following{/other_user}",
      "gists_url": "https://api.github.com/users/StefanKarpinski/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/StefanKarpinski/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/StefanKarpinski/subscriptions",
      "organizations_url": "https://api.github.com/users/StefanKarpinski/orgs",
      "repos_url": "https://api.github.com/users/StefanKarpinski/repos",
      "events_url": "https://api.github.com/users/StefanKarpinski/events{/privacy}",
      "received_events_url": "https://api.github.com/users/StefanKarpinski/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 15,
  "created_at": "2024-07-17T15:20:38Z",
  "updated_at": "2025-11-23T16:30:52Z",
  "closed_at": "2025-11-23T16:30:50Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/55152",
    "html_url": "https://github.com/JuliaLang/julia/pull/55152",
    "diff_url": "https://github.com/JuliaLang/julia/pull/55152.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/55152.patch",
    "merged_at": "2025-11-23T16:30:50Z"
  },
  "body": "As discussed in #54393, `codepoint(c)` should succeed for overlong encodings, and whenever `ismalformed(c)` returns `false`.   This should be backwards compatible since it simply removes an error, and should be strictly faster than before since it merely removes a call to `Base.is_overlong_enc`.\r\n\r\nAlso, `Base.ismalformed` and `Base.isoverlong` are declared `public` (but not yet exported) and are included in the manual, since they are referenced in the docstring of `codepoint` etcetera.   I also made `Base.show_invalid` \r\na `public` and documented function, since it is referenced from the `ismalformed` docs and is required by new implementations of `AbstractChar` types that support malformed data.\r\n\r\nFixes #54343, closes #54393.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/55152/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/55152/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "8790950f080ff3ae47a7cc32a1f1f8071a62f5a3",
      "filename": "NEWS.md",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351/NEWS.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351/NEWS.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/NEWS.md?ref=7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351",
      "patch": "@@ -84,6 +84,9 @@ New library features\n Standard library changes\n ------------------------\n \n+* `codepoint(c)` now succeeds for overlong encodings.  `Base.ismalformed`, `Base.isoverlong`, and\n+  `Base.show_invalid` are now `public` and documented (but not exported) ([#55152]).\n+\n #### JuliaSyntaxHighlighting\n \n #### LinearAlgebra"
    },
    {
      "sha": "a75019bf429f5297c693c6648ebe3dc862f4511f",
      "filename": "base/char.jl",
      "status": "modified",
      "additions": 45,
      "deletions": 25,
      "changes": 70,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351/base%2Fchar.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351/base%2Fchar.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fchar.jl?ref=7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351",
      "patch": "@@ -4,18 +4,22 @@ import Core: AbstractChar, Char\n \n \"\"\"\n The `AbstractChar` type is the supertype of all character implementations\n-in Julia. A character represents a Unicode code point, and can be converted\n-to an integer via the [`codepoint`](@ref) function in order to obtain the\n-numerical value of the code point, or constructed from the same integer.\n-These numerical values determine how characters are compared with `<` and `==`,\n-for example.  New `T <: AbstractChar` types should define a `codepoint(::T)`\n+in Julia. A character normally represents a Unicode codepoint (and can\n+also encapsulate other information from an encoded byte sequence as described below),\n+and characters can be converted to integer codepoint values via the [`codepoint`](@ref)\n+function, or can be constructed from the same integer.  At least for valid,\n+properly encoded Unicode characters, these numerical codepoint values\n+determine how characters are compared with `<` and `==`, for example.\n+New `T <: AbstractChar` types should define a `codepoint(::T)`\n method and a `T(::UInt32)` constructor, at minimum.\n \n A given `AbstractChar` subtype may be capable of representing only a subset\n of Unicode, in which case conversion from an unsupported `UInt32` value\n may throw an error. Conversely, the built-in [`Char`](@ref) type represents\n a *superset* of Unicode (in order to losslessly encode invalid byte streams),\n-in which case conversion of a non-Unicode value *to* `UInt32` throws an error.\n+in which case conversion of a non-Unicode value *to* `UInt32` throws an error\n+(see [`Base.ismalformed`](@ref)), and on the other hand a `Char` can also represent\n+a nonstandard \"overlong\" encoding ([`Base.isoverlong`](@ref)) of a codepoint.\n The [`isvalid`](@ref) function can be used to check which codepoints are\n representable in a given `AbstractChar` type.\n \n@@ -77,10 +81,19 @@ end\n     codepoint(c::AbstractChar)::Integer\n \n Return the Unicode codepoint (an unsigned integer) corresponding\n-to the character `c` (or throw an exception if `c` does not represent\n-a valid character). For `Char`, this is a `UInt32` value, but\n+to the character `c` (or throw an exception if `c` represents\n+a malformed character). For `Char`, this is a `UInt32` value, but\n `AbstractChar` types that represent only a subset of Unicode may\n return a different-sized integer (e.g. `UInt8`).\n+\n+Should succeed for any non-malformed character, i.e. when\n+[`Base.ismalformed(c)`](@ref) returns `false`.   This includes\n+invalid Unicode characters (such as unpaired surrogates)\n+and overlong encodings.\n+\n+!!! compat \"Julia 1.12\"\n+    Prior to Julia 1.12, `codepoint(c)` fails for overlong encodings (when\n+    [`Base.isoverlong(c)`](@ref) is `true`), and `Base.decode_overlong(c)` was needed.\n \"\"\"\n function codepoint end\n \n@@ -116,10 +129,19 @@ end\n \"\"\"\n     ismalformed(c::AbstractChar)::Bool\n \n-Return `true` if `c` represents malformed (non-Unicode) data according to the\n+Return `true` if `c` represents malformed (non-codepoint / mis-encoded) data according to the\n encoding used by `c`. Defaults to `false` for non-`Char` types.\n \n-See also [`show_invalid`](@ref).\n+Any *non*-malformed `c` can be mapped to an integer codepoint\n+by [`codepoint(c)`](@ref); this includes codepoints that are\n+not valid Unicode characters ([`isvalid(c)`](@ref) is `false`).\n+For example, well-formed characters can include invalid Unicode\n+codepoints like `'\\\\U110000'`, unpaired surrogates such as `'\\\\ud800'`,\n+and can also include overlong encodings ([`Base.isoverlong`](@ref)).\n+Malformed data, in contrast, cannot be decoded to a codepoint\n+(`codepoint` will throw an exception).\n+\n+See also [`Base.show_invalid`](@ref).\n \"\"\"\n ismalformed(c::AbstractChar) = false\n \n@@ -129,7 +151,7 @@ ismalformed(c::AbstractChar) = false\n Return `true` if `c` represents an overlong UTF-8 sequence. Defaults\n to `false` for non-`Char` types.\n \n-See also [`decode_overlong`](@ref) and [`show_invalid`](@ref).\n+See also [`Base.show_invalid`](@ref).\n \"\"\"\n isoverlong(c::AbstractChar) = false\n \n@@ -140,7 +162,7 @@ isoverlong(c::AbstractChar) = false\n     l1 = leading_ones(u)\n     t0 = trailing_zeros(u) & 56\n     (l1 == 1) | (8l1 + t0 > 32) |\n-    ((((u & 0x00c0c0c0) \u22bb 0x00808080) >> t0 != 0) | is_overlong_enc(u)) &&\n+    (((u & 0x00c0c0c0) \u22bb 0x00808080) >> t0 != 0) &&\n         throw_invalid_char(c)\n     u &= 0xffffffff >> l1\n     u >>= t0\n@@ -152,20 +174,18 @@ end\n     decode_overlong(c::AbstractChar)::Integer\n \n When [`isoverlong(c)`](@ref) is `true`, `decode_overlong(c)` returns\n-the Unicode codepoint value of `c`. `AbstractChar` implementations\n-that support overlong encodings should implement `Base.decode_overlong`.\n+the Unicode codepoint value of `c`.   Deprecated in favor of\n+`codepoint(c)`.\n+\n+!!! compat \"Julia 1.12\"\n+    In Julia 1.12 or later, `decode_overlong(c)` simply calls\n+    `codepoint(c)`, which should now work for overlong encodings.\n+    `AbstractChar` implementations that support overlong encodings\n+    should implement `Base.decode_overlong` on older releases.\n \"\"\"\n function decode_overlong end\n \n-@constprop :aggressive function decode_overlong(c::Char)\n-    u = bitcast(UInt32, c)\n-    l1 = leading_ones(u)\n-    t0 = trailing_zeros(u) & 56\n-    u &= 0xffffffff >> l1\n-    u >>= t0\n-    ((u & 0x0000007f) >> 0) | ((u & 0x00007f00) >> 2) |\n-    ((u & 0x007f0000) >> 4) | ((u & 0x7f000000) >> 6)\n-end\n+@constprop :aggressive decode_overlong(c::AbstractChar) = codepoint(c)\n \n @constprop :aggressive function Char(u::UInt32)\n     u < 0x80 && return bitcast(Char, u << 24)\n@@ -277,7 +297,7 @@ function show_invalid(io::IO, c::Char)\n end\n \n \"\"\"\n-    show_invalid(io::IO, c::AbstractChar)\n+    Base.show_invalid(io::IO, c::AbstractChar)\n \n Called by `show(io, c)` when [`isoverlong(c)`](@ref) or\n [`ismalformed(c)`](@ref) return `true`.   Subclasses\n@@ -330,7 +350,7 @@ function show(io::IO, ::MIME\"text/plain\", c::T) where {T<:AbstractChar}\n         print(io, \": \")\n         if isoverlong(c)\n             print(io, \"[overlong] \")\n-            u = decode_overlong(c)\n+            u = decode_overlong(c) # backwards compat Julia < 1.12\n             c = T(u)\n         else\n             u = codepoint(c)"
    },
    {
      "sha": "afbb77c382659eb6a48c9d730b7ff3b766396b09",
      "filename": "base/public.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351/base%2Fpublic.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351/base%2Fpublic.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fpublic.jl?ref=7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351",
      "patch": "@@ -112,6 +112,11 @@ public\n # Strings\n     escape_raw_string,\n \n+# Chars\n+    ismalformed,\n+    isoverlong,\n+    show_invalid,\n+\n # IO\n     # types\n     BufferStream,"
    },
    {
      "sha": "3b415202559f4f758d71721aafdacdb01d645efe",
      "filename": "doc/src/base/strings.md",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351/doc%2Fsrc%2Fbase%2Fstrings.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351/doc%2Fsrc%2Fbase%2Fstrings.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fbase%2Fstrings.md?ref=7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351",
      "patch": "@@ -35,6 +35,9 @@ Base.Docs.@text_str\n Base.isvalid(::Any)\n Base.isvalid(::Any, ::Any)\n Base.isvalid(::AbstractString, ::Integer)\n+Base.ismalformed\n+Base.isoverlong\n+Base.show_invalid\n Base.match\n Base.eachmatch\n Base.RegexMatch"
    },
    {
      "sha": "a576ad072b1d863fe1437afa2793e187e887df49",
      "filename": "test/char.jl",
      "status": "modified",
      "additions": 11,
      "deletions": 2,
      "changes": 13,
      "blob_url": "https://github.com/JuliaLang/julia/blob/7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351/test%2Fchar.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351/test%2Fchar.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fchar.jl?ref=7a8cbd4b7cfd0b7c3d62c2a4c58b07d177582351",
      "patch": "@@ -244,8 +244,8 @@ end\n \n @testset \"overlong codes\" begin\n     function test_overlong(c::Char, n::Integer, rep::String)\n-        if isvalid(c)\n-            @test Int(c) == n\n+        if !Base.ismalformed(c)\n+            @test Int(c) == n == codepoint(c)\n         else\n             @test_throws Base.InvalidCharError UInt32(c)\n         end\n@@ -357,6 +357,15 @@ end\n         \"'\\\\xc0': Malformed UTF-8 (category Ma: Malformed, bad data)\"\n end\n \n+@testset \"overlong, non-malformed chars\" begin\n+    c = ['\\xc0\\xa0', '\\xf0\\x8e\\x80\\x80']\n+    @test all(Base.isoverlong, c)\n+    @test !any(Base.ismalformed, c)\n+    @test repr(\"text/plain\", c[1]) == \"'\\\\xc0\\\\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)\"\n+    @test codepoint.(c) == [0x20, 0xE000]\n+    @test isuppercase(c[1]) == isuppercase(c[2]) == false # issue #54343\n+end\n+\n @testset \"More fallback tests\" begin\n     @test length(ASCIIChar('x')) == 1\n     @test firstindex(ASCIIChar('x')) == 1"
    }
  ]
}