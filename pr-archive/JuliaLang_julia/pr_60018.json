{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60018",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60018/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60018/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60018/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60018",
  "id": 3578529271,
  "node_id": "PR_kwDOABkWpM6xA0WS",
  "number": 60018,
  "title": "Provide mechanism for Julia syntax evolution",
  "user": {
    "login": "Keno",
    "id": 1291671,
    "node_id": "MDQ6VXNlcjEyOTE2NzE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1291671?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Keno",
    "html_url": "https://github.com/Keno",
    "followers_url": "https://api.github.com/users/Keno/followers",
    "following_url": "https://api.github.com/users/Keno/following{/other_user}",
    "gists_url": "https://api.github.com/users/Keno/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Keno/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Keno/subscriptions",
    "organizations_url": "https://api.github.com/users/Keno/orgs",
    "repos_url": "https://api.github.com/users/Keno/repos",
    "events_url": "https://api.github.com/users/Keno/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Keno/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": {
    "login": "JeffBezanson",
    "id": 744556,
    "node_id": "MDQ6VXNlcjc0NDU1Ng==",
    "avatar_url": "https://avatars.githubusercontent.com/u/744556?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JeffBezanson",
    "html_url": "https://github.com/JeffBezanson",
    "followers_url": "https://api.github.com/users/JeffBezanson/followers",
    "following_url": "https://api.github.com/users/JeffBezanson/following{/other_user}",
    "gists_url": "https://api.github.com/users/JeffBezanson/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JeffBezanson/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JeffBezanson/subscriptions",
    "organizations_url": "https://api.github.com/users/JeffBezanson/orgs",
    "repos_url": "https://api.github.com/users/JeffBezanson/repos",
    "events_url": "https://api.github.com/users/JeffBezanson/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JeffBezanson/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "JeffBezanson",
      "id": 744556,
      "node_id": "MDQ6VXNlcjc0NDU1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/744556?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeffBezanson",
      "html_url": "https://github.com/JeffBezanson",
      "followers_url": "https://api.github.com/users/JeffBezanson/followers",
      "following_url": "https://api.github.com/users/JeffBezanson/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeffBezanson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeffBezanson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeffBezanson/subscriptions",
      "organizations_url": "https://api.github.com/users/JeffBezanson/orgs",
      "repos_url": "https://api.github.com/users/JeffBezanson/repos",
      "events_url": "https://api.github.com/users/JeffBezanson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeffBezanson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 21,
  "created_at": "2025-11-01T22:05:58Z",
  "updated_at": "2025-12-12T07:25:49Z",
  "closed_at": "2025-11-25T23:14:24Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60018",
    "html_url": "https://github.com/JuliaLang/julia/pull/60018",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60018.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60018.patch",
    "merged_at": "2025-11-25T23:14:24Z"
  },
  "body": "# Motivation\r\nThere are several corner cases in the Julia syntax that are essentially bugs or mistakes that we'd like to possibly remove, but can't due to backwards compatibility concerns.\r\n\r\nSimilarly, when adding new syntax features, there are often cases that overlap with valid (but often nonsensical) existing syntax. In the past, we've mostly done judegement calls of these being \"minor changes\", but as the package ecosystem grows, so does the chance of someone accidentally using these anyway and our \"minor changes\" have (subjectively) resulted in more breakages recently.\r\n\r\nFortunately, all the recent work on making the parser replacable, combined with the fact that JuliaSyntax already supports parsing multiple revisions of Julia syntax provides a solution here: Just let packages declare what version of the Julia syntax they are using. That way, packages would not break if we make changes to the syntax and they can be upgraded at their own pace the next time the author of that particular package upgrades to a new julia version.\r\n\r\n# Core mechanism\r\nThe way this works is simple. Right now, the parser function is always looked up in `Core._parse`. With this PR, it is instead looked up as `mod._internal_julia_parse` (slightly longer name to avoid conflicting with existing bindings of the name in downstream packages), or `Core._parse` if no such binding exists. Similar for `_lower`.\r\n\r\nThere is a macro `@Base.Experimental.set_syntax_version v\"1.xx\"` that will set the `_internal_julia_parse` (and inte the future the _lower version) to one that propagates the version to the parser, so users are not expected to manipulate the binding directly.\r\n\r\n# Versioned package loading\r\nThe loading system is extended to look at a new `syntax.julia_version` key in Project.toml (and Manifest for explicit environments). If no such key exists, it defaults to the minimum allowed version of the Julia compat. If no compat is defined, it defaults to the current Julia version. This is technically slightly less backwards compatible than defaulting this to Julia 1.13, but I think it will be less suprising in the future for the default syntax to match what is in the REPL. Most julia packages do already define a julia compat.\r\n\r\nNote that as a result of this, the code for parse compat ranges moves from Pkg to Base.\r\n\r\n# Syntax changes\r\nThis introduces two parser changes:\r\n1. `@VERSION` (and similar macrocall forms of a macro named `VERSION`) are now special and trigger the parser to push its version information into the source location field of the macrocall. Note that because this is in the parser, this affects all macros with the name. However, there is also logic on the macrocall side that discards this again if the macro cannot accept it. This special mechanism is used by the `Base.Experimental.@VERSION` macro to let users detect the parse version.\r\n\r\n2. The `module` syntax form gains a syntax version argument that is automatically populated with the parser's current version. This is the mechanism to propagate syntax information from the parser to the core mechanism above.\r\n\r\nNote that these are only active if a module has opted into 1.14 syntax, so macros that process `:module` exprs will not see these changes unless and until the calling module opts into 1.14 syntax via the above mentioned mechanisms (which is the primary advantage of this scheme).\r\n\r\n# Final words\r\n\r\nI should emphasize that I'm not proposing using this for any big syntax revolutions or anything. I would just like to start cleaning up a few corners of the syntax that I think are universally agreed to be bad but that we've kept for backwards compatibility. This way, by the time we get around to making a breaking revision, our entire ecosystem will have already upgraded to the new syntax.\r\n\r\n# Remaining TODO\r\n- [x] Standalone tests for the parser changes\r\n- [x] JuliaLowering update\r\n- [x] Pkg.jl side changes (https://github.com/JuliaLang/Pkg.jl/pull/4520)\r\n- [x] NEWS entry\r\n\r\n# Open questions\r\n\r\n- [x] What should be the version of the flisp parser?\r\n\r\nSome doc and test edits by Claude but mostly manual.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60018/reactions",
    "total_count": 22,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 12,
    "rocket": 7,
    "eyes": 3
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60018/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "941f9d66052068a6a444e998bcb533b4e89c65ea",
      "filename": "Compiler/test/inference.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/Compiler%2Ftest%2Finference.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/Compiler%2Ftest%2Finference.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Finference.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -6463,6 +6463,7 @@ end == TypeError\n # Issue #58257 - Hang in inference during BindingPartition resolution\n module A58257\n     module B58257\n+        const age = Base.get_world_counter()\n         using ..A58257\n         # World age here is N\n     end\n@@ -6474,7 +6475,7 @@ end\n ## The sequence of events is critical here.\n A58257.get!      # Creates binding partition in A, N+1:\u221e\n A58257.B58257.get!    # Creates binding partition in A.B, N+1:\u221e\n-Base.invoke_in_world(UInt(38678), getglobal, A58257, :get!) # Expands binding partition in A through <N\n+Base.invoke_in_world(A58257.B58257.age, getglobal, A58257, :get!) # Expands binding partition in A through <N\n @test Base.infer_return_type(A58257.f) == typeof(Base.get!) # Attempt to lookup A.B in world age N hangs\n \n function tt57873(a::Vector{String}, pref)"
    },
    {
      "sha": "3f5533f8b773aee7701c0221ebe5b2d2dec3f1b6",
      "filename": "JuliaLowering/src/ast.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaLowering%2Fsrc%2Fast.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaLowering%2Fsrc%2Fast.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fast.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -175,6 +175,7 @@ function makeleaf(ctx, srcref, k::Kind, value; kws...)\n               k == K\"Char\"    ? convert(Char,    value) :\n               k == K\"Value\"   ? value                   :\n               k == K\"Bool\"    ? value                   :\n+              k == K\"VERSION\" ? value                   :\n               error(\"Unexpected leaf kind `$k`\")\n         makeleaf(graph, srcref, k; value=val, kws...)\n     end"
    },
    {
      "sha": "391c99a624d938c4285f6c13f33eed82f71cddd3",
      "filename": "JuliaLowering/src/compat.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 3,
      "changes": 12,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaLowering%2Fsrc%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaLowering%2Fsrc%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fcompat.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -211,6 +211,9 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n         id_inner = _insert_tree_node(graph, K\"String\", src; value=e)\n         setchildren!(graph, st_id, [id_inner])\n         return st_id, src\n+    elseif e isa VersionNumber\n+        st_id = _insert_tree_node(graph, K\"VERSION\", src, JS.set_numeric_flags(e.minor*10); value=e)\n+        return st_id, src\n     elseif !(e isa Expr)\n         # There are other kinds we could potentially back-convert (e.g. Float),\n         # but Value should work fine.\n@@ -398,11 +401,14 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n             child_exprs[2] = maybe_unwrap_arg(e.args[2])\n         end\n     elseif e.head === :module\n-        @assert nargs === 3\n-        if !e.args[1]\n+        @assert nargs in (3, 4)\n+        has_version = !isa(e.args[1], Bool)\n+        if !e.args[1+has_version]\n             st_flags |= JS.BARE_MODULE_FLAG\n         end\n-        child_exprs = Any[e.args[2], e.args[3]]\n+        child_exprs = has_version ?\n+            Any[e.args[1], e.args[2+has_version], e.args[3+has_version]] :\n+            Any[e.args[2+has_version], e.args[3+has_version]]\n     elseif e.head === :do\n         # Expr:\n         # (do (call f args...) (-> (tuple lam_args...) (block ...)))"
    },
    {
      "sha": "933f4c31f385fd7f8675e77526e1300174dcbfdd",
      "filename": "JuliaLowering/src/eval.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 6,
      "changes": 19,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaLowering%2Fsrc%2Feval.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaLowering%2Fsrc%2Feval.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Feval.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -70,19 +70,26 @@ function lower_step(iter, mod, world=Base.get_world_counter())\n         push!(iter.todo, (ex, false, 1))\n         return lower_step(iter, mod)\n     elseif k == K\"module\"\n-        name = ex[1]\n+        name_or_version = ex[1]\n+        version = nothing\n+        if kind(name_or_version) == K\"VERSION\"\n+            version = name_or_version.value\n+            name = ex[2]\n+        else\n+            name = name_or_version\n+        end\n         if kind(name) != K\"Identifier\"\n             throw(LoweringError(name, \"Expected module name\"))\n         end\n         newmod_name = Symbol(name.name_val)\n-        body = ex[2]\n+        body = ex[end]\n         if kind(body) != K\"block\"\n             throw(LoweringError(body, \"Expected block in module body\"))\n         end\n         std_defs = !has_flags(ex, JuliaSyntax.BARE_MODULE_FLAG)\n         loc = source_location(LineNumberNode, ex)\n         push!(iter.todo, (body, true, 1))\n-        return Core.svec(:begin_module, newmod_name, std_defs, loc)\n+        return Core.svec(:begin_module, version, newmod_name, std_defs, loc)\n     else\n         # Non macro expansion parts of lowering\n         ctx2, ex2 = expand_forms_2(ctx1, ex)\n@@ -467,10 +474,10 @@ function _eval(mod, iter)\n         if type == :done\n             break\n         elseif type == :begin_module\n-            filename = something(thunk[4].file, :none)\n+            filename = something(thunk[5].file, :none)\n             mod = @ccall jl_begin_new_module(\n-                modules[end]::Any, thunk[2]::Symbol, thunk[3]::Cint,\n-                filename::Cstring, thunk[4].line::Cint)::Module\n+                modules[end]::Any, thunk[3]::Symbol, thunk[2]::Any, thunk[4]::Cint,\n+                filename::Cstring, thunk[5].line::Cint)::Module\n             push!(modules, mod)\n         elseif type == :end_module\n             @ccall jl_end_new_module(modules[end]::Module)::Cvoid"
    },
    {
      "sha": "84c80499722f74588d439e273bf4303082a188fc",
      "filename": "JuliaLowering/test/macros.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaLowering%2Ftest%2Fmacros.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaLowering%2Ftest%2Fmacros.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmacros.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -431,6 +431,7 @@ end\n         )\n     end\n     \"\"\") \u2248 @ast_ [K\"module\"\n+        v\"1.14.0\"::K\"VERSION\"\n         \"AA\"::K\"Identifier\"\n         [K\"block\"\n         ]"
    },
    {
      "sha": "6db1757d3b03e5ef7f96983f6456f425722f6d3e",
      "filename": "JuliaSyntax/src/integration/expr.jl",
      "status": "modified",
      "additions": 17,
      "deletions": 7,
      "changes": 24,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -199,7 +199,7 @@ end\n \n function parseargs!(retexpr::Expr, loc::LineNumberNode, cursor, source, txtbuf::Vector{UInt8}, txtbuf_offset::UInt32)\n     args = retexpr.args\n-    firstchildhead = head(cursor)\n+    firstchildhead = secondchildhead = head(cursor)\n     firstchildrange::UnitRange{UInt32} = byte_range(cursor)\n     itr = reverse_nontrivia_children(cursor)\n     r = iterate(itr)\n@@ -208,11 +208,12 @@ function parseargs!(retexpr::Expr, loc::LineNumberNode, cursor, source, txtbuf::\n         r = iterate(itr, state)\n         expr = node_to_expr(child, source, txtbuf, txtbuf_offset)\n         @assert expr !== nothing\n+        secondchildhead = firstchildhead\n         firstchildhead = head(child)\n         firstchildrange = byte_range(child)\n         pushfirst!(args, fixup_Expr_child(head(cursor), expr, r === nothing))\n     end\n-    return (firstchildhead, firstchildrange)\n+    return (firstchildhead, secondchildhead, firstchildrange)\n end\n \n _expr_leaf_val(node::SyntaxNode, _...) = node.val\n@@ -235,6 +236,9 @@ function node_to_expr(cursor, source, txtbuf::Vector{UInt8}, txtbuf_offset::UInt\n             return k == K\"error\" ?\n                 Expr(:error) :\n                 Expr(:error, \"$(_token_error_descriptions[k]): `$(source[srcrange])`\")\n+        elseif k == K\"VERSION\"\n+            nv = numeric_flags(flags(nodehead))\n+            return VersionNumber(1, nv \u00f7 10, nv % 10)\n         else\n             scoped_val = _expr_leaf_val(cursor, txtbuf, txtbuf_offset)\n             val = @isexpr(scoped_val, :scope_layer) ? scoped_val.args[1] : scoped_val\n@@ -292,10 +296,11 @@ function node_to_expr(cursor, source, txtbuf::Vector{UInt8}, txtbuf_offset::UInt\n     end\n \n     # Now recurse to parse all arguments\n-    (firstchildhead, firstchildrange) = parseargs!(retexpr, loc, cursor, source, txtbuf, txtbuf_offset)\n+    (firstchildhead, secondchildhead, firstchildrange) =\n+        parseargs!(retexpr, loc, cursor, source, txtbuf, txtbuf_offset)\n \n     return _node_to_expr(retexpr, loc, srcrange,\n-                         firstchildhead, firstchildrange,\n+                         firstchildhead, secondchildhead, firstchildrange,\n                          nodehead, source)\n end\n \n@@ -318,7 +323,7 @@ end\n # tree types.\n @noinline function _node_to_expr(retexpr::Expr, loc::LineNumberNode,\n                                  srcrange::UnitRange{UInt32},\n-                                 firstchildhead::SyntaxHead,\n+                                 firstchildhead::SyntaxHead, secondchildhead::SyntaxHead,\n                                  firstchildrange::UnitRange{UInt32},\n                                  nodehead::SyntaxHead,\n                                  source)\n@@ -355,6 +360,11 @@ end\n                 # Fix up for custom cmd macros like foo`x`\n                 args[2] = a2.args[3]\n             end\n+            if kind(secondchildhead) == K\"VERSION\"\n+                # Encode the syntax version into `loc` so that the argument order\n+                # matches what ordinary macros expect.\n+                loc = Core.MacroSource(loc, popat!(args, 2))\n+            end\n         end\n         do_lambda = _extract_do_lambda!(args)\n         _reorder_parameters!(args, 2)\n@@ -554,8 +564,8 @@ end\n             pushfirst!((args[2]::Expr).args, loc)\n         end\n     elseif k == K\"module\"\n-        pushfirst!(args, !has_flags(nodehead, BARE_MODULE_FLAG))\n-        pushfirst!((args[3]::Expr).args, loc)\n+        insert!(args, kind(firstchildhead) == K\"VERSION\" ? 2 : 1, !has_flags(nodehead, BARE_MODULE_FLAG))\n+        pushfirst!((args[end]::Expr).args, loc)\n     elseif k == K\"quote\"\n         if length(args) == 1\n             a1 = only(args)"
    },
    {
      "sha": "7d5f1781af87719621d6ed95ea02a0a615291a62",
      "filename": "JuliaSyntax/src/integration/hooks.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fintegration%2Fhooks.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fintegration%2Fhooks.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fintegration%2Fhooks.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -162,7 +162,7 @@ end\n # Debug log file for dumping parsed code\n const _debug_log = Ref{Union{Nothing,IO}}(nothing)\n \n-function core_parser_hook(code, filename::String, lineno::Int, offset::Int, options::Symbol)\n+function core_parser_hook(code, filename::String, lineno::Int, offset::Int, options::Symbol; syntax_version = v\"1.13\")\n     try\n         # TODO: Check that we do all this input wrangling without copying the\n         # code buffer\n@@ -184,7 +184,7 @@ function core_parser_hook(code, filename::String, lineno::Int, offset::Int, opti\n             write(_debug_log[], code)\n         end\n \n-        stream = ParseStream(code, offset+1)\n+        stream = ParseStream(code, offset+1; version = syntax_version)\n         if options === :statement || options === :atom\n             # To copy the flisp parser driver:\n             # * Parsing atoms      consumes leading trivia"
    },
    {
      "sha": "7bd9bdb9f0c0164f45aaffc3150d062d82a8c3d8",
      "filename": "JuliaSyntax/src/julia/kinds.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -247,6 +247,7 @@ register_kinds!(JuliaSyntax, 0, [\n             \"public\"\n             \"type\"\n             \"var\"\n+            \"VERSION\"\n         \"END_CONTEXTUAL_KEYWORDS\"\n     \"END_KEYWORDS\"\n "
    },
    {
      "sha": "f0713b513cbcbac160909b2f0aa00662097daaa4",
      "filename": "JuliaSyntax/src/julia/literal_parsing.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fjulia%2Fliteral_parsing.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fjulia%2Fliteral_parsing.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fliteral_parsing.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -408,6 +408,9 @@ function parse_julia_literal(txtbuf::Vector{UInt8}, head::SyntaxHead, srcrange)\n         return had_error ? ErrorVal() : String(take!(io))\n     elseif k == K\"Bool\"\n         return txtbuf[first(srcrange)] == u8\"t\"\n+    elseif k == K\"VERSION\"\n+        nv = numeric_flags(head)\n+        return VersionNumber(1, nv \u00f7 10, nv % 10)\n     end\n \n     # TODO: Avoid allocating temporary String here"
    },
    {
      "sha": "75c806caaa60a1e9f088b7ee7bb4626ffbfc4863",
      "filename": "JuliaSyntax/src/julia/parser.jl",
      "status": "modified",
      "additions": 24,
      "deletions": 6,
      "changes": 30,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fjulia%2Fparser.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fjulia%2Fparser.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fparser.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -1488,13 +1488,23 @@ function parse_unary_prefix(ps::ParseState, has_unary_prefix=false)\n     end\n end\n \n-function maybe_parsed_macro_name(ps, processing_macro_name, mark)\n+function maybe_parsed_macro_name(ps, processing_macro_name, last_identifier_orig_kind, mark)\n     if processing_macro_name\n         emit(ps, mark, K\"macro_name\")\n+        maybe_parsed_special_macro(ps, last_identifier_orig_kind)\n     end\n     return false\n end\n \n+function maybe_parsed_special_macro(ps, last_identifier_orig_kind)\n+    is_syntax_version_macro = last_identifier_orig_kind == K\"VERSION\"\n+    if is_syntax_version_macro && ps.stream.version >= (1, 14)\n+        # Encode the current parser version into an invisible token\n+        bump_invisible(ps, K\"VERSION\",\n+            set_numeric_flags(ps.stream.version[2] * 10))\n+    end\n+end\n+\n # Parses a chain of suffixes at function call precedence, leftmost binding\n # tightest. This handles\n #  * Bracketed calls like a() b[] c{}\n@@ -1543,7 +1553,7 @@ function parse_call_chain(ps::ParseState, mark, is_macrocall=false)\n             # @+x y       ==> (macrocall (macro_name +) x y)\n             # A.@.x       ==> (macrocall (. A (macro_name .)) x)\n             processing_macro_name = maybe_parsed_macro_name(\n-                ps, processing_macro_name, mark)\n+                ps, processing_macro_name, last_identifier_orig_kind, mark)\n             let ps = with_space_sensitive(ps)\n                 # Space separated macro arguments\n                 # A.@foo a b    ==> (macrocall (. A (macro_name foo)) a b)\n@@ -1577,7 +1587,7 @@ function parse_call_chain(ps::ParseState, mark, is_macrocall=false)\n             # (a=1)()  ==>  (call (parens (= a 1)))\n             # f (a)    ==>  (call f (error-t) a)\n             processing_macro_name = maybe_parsed_macro_name(\n-                ps, processing_macro_name, mark)\n+                ps, processing_macro_name, last_identifier_orig_kind, mark)\n             bump_disallowed_space(ps)\n             bump(ps, TRIVIA_FLAG)\n             opts = parse_call_arglist(ps, K\")\")\n@@ -1598,7 +1608,7 @@ function parse_call_chain(ps::ParseState, mark, is_macrocall=false)\n             end\n         elseif k == K\"[\"\n             processing_macro_name = maybe_parsed_macro_name(\n-                ps, processing_macro_name, mark)\n+                ps, processing_macro_name, last_identifier_orig_kind, mark)\n             m = position(ps)\n             # a [i]  ==>  (ref a (error-t) i)\n             bump_disallowed_space(ps)\n@@ -1666,7 +1676,7 @@ function parse_call_chain(ps::ParseState, mark, is_macrocall=false)\n                 if is_macrocall\n                     # Recover by pretending we do have the syntax\n                     processing_macro_name = maybe_parsed_macro_name(\n-                        ps, processing_macro_name, mark)\n+                        ps, processing_macro_name, last_identifier_orig_kind, mark)\n                     # @M.(x)  ==> (macrocall (dotcall (macro_name M) (error-t) x))\n                     bump_invisible(ps, K\"error\", TRIVIA_FLAG)\n                     emit_diagnostic(ps, mark,\n@@ -1720,6 +1730,7 @@ function parse_call_chain(ps::ParseState, mark, is_macrocall=false)\n                 macro_atname_range = (m, position(ps))\n                 is_macrocall = true\n                 emit(ps, mark, K\".\")\n+                maybe_parsed_special_macro(ps, last_identifier_orig_kind)\n             elseif k == K\"'\"\n                 # f.'  =>  (dotcall-post f (error '))\n                 bump(ps, remap_kind=K\"Identifier\")  # bump '\n@@ -1760,7 +1771,7 @@ function parse_call_chain(ps::ParseState, mark, is_macrocall=false)\n             emit(ps, mark, K\"call\", POSTFIX_OP_FLAG)\n         elseif k == K\"{\"\n             processing_macro_name = maybe_parsed_macro_name(\n-                ps, processing_macro_name, mark)\n+                ps, processing_macro_name, last_identifier_orig_kind, mark)\n             # Type parameter curlies and macro calls\n             m = position(ps)\n             # S {a} ==> (curly S (error-t) a)\n@@ -2065,6 +2076,13 @@ function parse_resword(ps::ParseState)\n             # module do \\n end  ==>  (module (error do) (block))\n             bump(ps, error=\"Invalid module name\")\n         else\n+            if ps.stream.version >= (1, 14)\n+                # Encode the parser version that parsed this module - the runtime\n+                # will use this to set the same parser version for runtime `include`\n+                # etc into this module.\n+                bump_invisible(ps, K\"VERSION\",\n+                    set_numeric_flags(ps.stream.version[2] * 10))\n+            end\n             # module $A end  ==>  (module ($ A) (block))\n             parse_unary_prefix(ps)\n         end"
    },
    {
      "sha": "1f279af7c4921126bf40a460289da3e673147a4f",
      "filename": "JuliaSyntax/src/julia/tokenize.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fjulia%2Ftokenize.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Fsrc%2Fjulia%2Ftokenize.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Ftokenize.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -1253,12 +1253,12 @@ function lex_identifier(l::Lexer, c)\n     end\n end\n \n-# This creates a hash for chars in [a-z] using 5 bit per char.\n+# This creates a hash for chars in [A-z] using 6 bit per char.\n # Requires an additional input-length check somewhere, because\n-# this only works up to ~12 chars.\n+# this only works up to ~10 chars.\n @inline function simple_hash(c::Char, h::UInt64)\n-    bytehash = (clamp(c - 'a' + 1, -1, 30) % UInt8) & 0x1f\n-    h << 5 + bytehash\n+    bytehash = (clamp(c - 'A' + 1, -1, 60) % UInt8) & 0x3f\n+    h << 6 + bytehash\n end\n \n function simple_hash(str)\n@@ -1313,10 +1313,11 @@ K\"outer\",\n K\"primitive\",\n K\"type\",\n K\"var\",\n+K\"VERSION\"\n ]\n \n const _true_hash = simple_hash(\"true\")\n const _false_hash = simple_hash(\"false\")\n-const _kw_hash = Dict(simple_hash(lowercase(string(kw))) => kw for kw in kws)\n+const _kw_hash = Dict(simple_hash(string(kw)) => kw for kw in kws)\n \n end # module"
    },
    {
      "sha": "a8ec8c68652c362e1e0164e96cdd1d164ce98346",
      "filename": "JuliaSyntax/test/expr.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Ftest%2Fexpr.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Ftest%2Fexpr.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fexpr.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -55,7 +55,7 @@\n             @test parsestmt(\"a;b\") ==\n                 Expr(:toplevel, :a, :b)\n \n-            @test parsestmt(\"module A\\n\\nbody\\nend\") ==\n+            @test parsestmt(\"module A\\n\\nbody\\nend\"; version=v\"1.13\") ==\n                 Expr(:module,\n                      true,\n                      :A,\n@@ -798,9 +798,11 @@\n     end\n \n     @testset \"module\" begin\n-        @test parsestmt(\"module A end\") ==\n+        @test parsestmt(\"module A end\"; version=v\"1.13\") ==\n             Expr(:module, true,  :A, Expr(:block, LineNumberNode(1), LineNumberNode(1)))\n-        @test parsestmt(\"baremodule A end\") ==\n+        @test parsestmt(\"module A end\"; version=v\"1.14\") ==\n+            Expr(:module, v\"1.14\", true,  :A, Expr(:block, LineNumberNode(1), LineNumberNode(1)))\n+        @test parsestmt(\"baremodule A end\"; version=v\"1.13\") ==\n             Expr(:module, false, :A, Expr(:block, LineNumberNode(1), LineNumberNode(1)))\n     end\n "
    },
    {
      "sha": "2b3e106e1dae400175fa3a88daaf3a5da2a6aa65",
      "filename": "JuliaSyntax/test/parser.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Ftest%2Fparser.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Ftest%2Fparser.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fparser.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -377,6 +377,14 @@ tests = [\n         \"@doc x\\n\\ny\"  =>  \"(macrocall (macro_name doc) x)\"\n         \"@doc x\\nend\"  =>  \"(macrocall (macro_name doc) x)\"\n \n+        # Special 1.14 @VERSION parsing rules\n+        ((v=v\"1.13\",), \"@VERSION\")        =>  \"(macrocall (macro_name VERSION))\"\n+        ((v=v\"1.13\",), \"@A.B.VERSION\")    =>  \"(macrocall (macro_name (. (. A B) VERSION)))\"\n+        ((v=v\"1.13\",), \"A.B.@VERSION\")     =>  \"(macrocall (. (. A B) (macro_name VERSION)))\"\n+        ((v=v\"1.14\",), \"@VERSION\")        =>  \"(macrocall (macro_name VERSION) v\\\"1.14.0\\\")\"\n+        ((v=v\"1.14\",), \"@A.B.VERSION\")    =>  \"(macrocall (macro_name (. (. A B) VERSION)) v\\\"1.14.0\\\")\"\n+        ((v=v\"1.14\",), \"A.B.@VERSION\")     =>  \"(macrocall (. (. A B) (macro_name VERSION)) v\\\"1.14.0\\\")\"\n+\n         # calls with brackets\n         \"f(a,b)\"  => \"(call f a b)\"\n         \"f(a,)\"   => \"(call-, f a)\""
    },
    {
      "sha": "2ad1ecef7a53cd9f48177851e91b47e139fce34a",
      "filename": "JuliaSyntax/test/test_utils.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Ftest%2Ftest_utils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Ftest%2Ftest_utils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Ftest_utils.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -210,7 +210,7 @@ function parsers_agree_on_file(text, filename; exprs_equal=exprs_equal_no_linenu\n         return true\n     end\n     try\n-        stream = ParseStream(text)\n+        stream = ParseStream(text; version=v\"1.13\")\n         parse!(stream)\n         ex = build_tree(Expr, stream, filename=filename)\n         return !JuliaSyntax.any_error(stream) && exprs_equal(fl_ex, ex)"
    },
    {
      "sha": "2c75cbd20c587395bfb6fe939a2a877d59aca6e0",
      "filename": "JuliaSyntax/test/tokenize.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Ftest%2Ftokenize.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/JuliaSyntax%2Ftest%2Ftokenize.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Ftokenize.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -988,6 +988,7 @@ const all_kws = Set([\n     \"primitive\",\n     \"type\",\n     \"var\",\n+    \"VERSION\",\n     # Word-like operators\n     \"in\",\n     \"isa\","
    },
    {
      "sha": "1bb83f409beeebf7a948ad36bb1f9fdf4f0a6b89",
      "filename": "NEWS.md",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/NEWS.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/NEWS.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/NEWS.md?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -11,6 +11,10 @@ New language features\n     is now a valid operator with arrow precedence, accessible as `\\hookunderrightarrow` at the REPL.\n     ([JuliaLang/JuliaSyntax.jl#525], [#57143])\n   - Support for Unicode 17 ([#59534]).\n+  - It is now possible to control which version of the Julia syntax will be used to parse a package by setting the\n+    `compat.julia` or `syntax.julia_version` key in Project.toml. This feature is similar to the notion of \"editions\"\n+    in other language ecosystems and will allow non-breaking evolution of Julia syntax in future versions.\n+    See the \"Syntax Versioning\" section in the code loading documentation ([#60018]).\n \n Language changes\n ----------------"
    },
    {
      "sha": "781ad5c69d512ab0c83e64e1ddd533f2cb955361",
      "filename": "base/Base_compiler.jl",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2FBase_compiler.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2FBase_compiler.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2FBase_compiler.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -141,6 +141,20 @@ import Core: @doc, @__doc__, WrappedException, @int128_str, @uint128_str, @big_s\n # Export list\n include(\"exports.jl\")\n \n+function set_syntax_version end\n+_topmod(m::Module) = ccall(:jl_base_relative_to, Any, (Any,), m)::Module\n+function _setup_module!(mod::Module, Core.@nospecialize syntax_ver)\n+    # using Base\n+    Core._using(mod, _topmod(mod), UInt8(0))\n+    Core.declare_const(mod, :include, IncludeInto(mod))\n+    Core.declare_const(mod, :eval, Core.EvalInto(mod))\n+    if syntax_ver === nothing\n+        return nothing\n+    end\n+    set_syntax_version(mod, syntax_ver)\n+    return nothing\n+end\n+\n # core docsystem\n include(\"docs/core.jl\")\n Core.atdoc!(CoreDocs.docm)"
    },
    {
      "sha": "66e9a57e7aef5e3ec09615ca404c40d61fa80a7b",
      "filename": "base/boot.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fboot.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fboot.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fboot.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -1141,4 +1141,10 @@ typename(union::UnionAll) = typename(union.body)\n \n include(Core, \"optimized_generics.jl\")\n \n+# Used only be the magic @VERSION macro\n+struct MacroSource\n+    lno::Any # ::LineNumberNode, but needs to be a pointer\n+    syntax_ver::Any # ::VersionNumber =#\n+end\n+\n ccall(:jl_set_istopmod, Cvoid, (Any, Bool), Core, true)"
    },
    {
      "sha": "97c0232493c3c77fc58cdfa69b980e93bf1044e1",
      "filename": "base/client.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fclient.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fclient.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fclient.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -173,8 +173,8 @@ function eval_user_input(errio, @nospecialize(ast), show_value::Bool)\n     nothing\n end\n \n-function _parse_input_line_core(s::String, filename::String)\n-    ex = Meta.parseall(s, filename=filename)\n+function _parse_input_line_core(s::String, filename::String, mod::Union{Module, Nothing})\n+    ex = Meta.parseall(s; filename, mod)\n     if ex isa Expr && ex.head === :toplevel\n         if isempty(ex.args)\n             return nothing\n@@ -189,18 +189,18 @@ function _parse_input_line_core(s::String, filename::String)\n     return ex\n end\n \n-function parse_input_line(s::String; filename::String=\"none\", depwarn=true)\n+function parse_input_line(s::String; filename::String=\"none\", depwarn=true, mod::Union{Module, Nothing}=nothing)\n     # For now, assume all parser warnings are depwarns\n     ex = if depwarn\n-        _parse_input_line_core(s, filename)\n+        _parse_input_line_core(s, filename, mod)\n     else\n         with_logger(NullLogger()) do\n-            _parse_input_line_core(s, filename)\n+            _parse_input_line_core(s, filename, mod)\n         end\n     end\n     return ex\n end\n-parse_input_line(s::AbstractString) = parse_input_line(String(s))\n+parse_input_line(s::AbstractString; kwargs...) = parse_input_line(String(s); kwargs...)\n \n # detect the reason which caused an :incomplete expression\n # from the error message\n@@ -443,7 +443,7 @@ function run_fallback_repl(interactive::Bool)\n     let input = stdin\n         if isa(input, File) || isa(input, IOStream)\n             # for files, we can slurp in the whole thing at once\n-            ex = parse_input_line(read(input, String))\n+            ex = parse_input_line(read(input, String); mod=Main)\n             if Meta.isexpr(ex, :toplevel)\n                 # if we get back a list of statements, eval them sequentially\n                 # as if we had parsed them sequentially\n@@ -466,7 +466,7 @@ function run_fallback_repl(interactive::Bool)\n                     ex = nothing\n                     while !eof(input)\n                         line *= readline(input, keep=true)\n-                        ex = parse_input_line(line)\n+                        ex = parse_input_line(line; mod=Main)\n                         if !(isa(ex, Expr) && ex.head === :incomplete)\n                             break\n                         end"
    },
    {
      "sha": "7045a52aba98ed607519b59d746e6eac552a9468",
      "filename": "base/deprecated.jl",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fdeprecated.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fdeprecated.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fdeprecated.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -572,3 +572,14 @@ to_power_type(x) = oftype(x*x, x)\n @deprecate merge(combine::Callable, d::AbstractDict, others::AbstractDict...) mergewith(combine, d, others...)\n \n # end 1.13 deprecations\n+\n+# BEGIN 1.14 deprecations\n+\n+# Revise calls this\n+function explicit_manifest_entry_path(args...)\n+    spec = explicit_manifest_entry_load_spec(args...)\n+    spec === nothing && return nothing\n+    return spec.path\n+end\n+\n+# END 1.14 deprecations"
    },
    {
      "sha": "5d1662551ea6203a2a6f34e320627671aa99b904",
      "filename": "base/docs/Docs.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fdocs%2FDocs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fdocs%2FDocs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fdocs%2FDocs.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -306,7 +306,9 @@ elseif head === :call && length(x.args) >= 1 && isexpr(x.args[1], :(::))\n         # otherwise, for documenting `x::y`, it will be extracted from x\n         astname((x.args[1]::Expr).args[end], ismacro)\n     else\n-        n = if isexpr(x, (:module, :struct))\n+        n = if isexpr(x, :module)\n+            isa(x.args[1], Bool) ? 2 : 3\n+        elseif isexpr(x, :struct)\n             2\n         elseif isexpr(x, (:call, :macrocall, :function, :(=), :macro, :where, :curly,\n                           :(::), :(<:), :(>:), :local, :global, :const, :atomic,\n@@ -439,9 +441,10 @@ function moduledoc(__source__, __module__, meta, def, def\u2032::Expr)\n     if def === nothing\n         esc(:(Core.eval($name, $(quot(docex)))))\n     else\n+        has_version = !isa(def.args[1], Bool)\n         def = unblock(def)\n-        block = def.args[3].args\n-        if !def.args[1]\n+        block = def.args[3 + has_version].args\n+        if !def.args[1 + has_version]\n             pushfirst!(block, :(import Base: @doc))\n         end\n         push!(block, docex)"
    },
    {
      "sha": "2deb3bc76af6cfd65958a2d9e4cfc119ae99b2ac",
      "filename": "base/experimental.jl",
      "status": "modified",
      "additions": 95,
      "deletions": 0,
      "changes": 95,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fexperimental.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fexperimental.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fexperimental.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -746,4 +746,99 @@ macro reexport(ex)\n     return esc(calls)\n end\n \n+struct VersionedParse\n+    ver::VersionNumber\n+end\n+\n+function (vp::VersionedParse)(code, filename::String, lineno::Int, offset::Int, options::Symbol)\n+    if !isdefined(Base, :JuliaSyntax)\n+        if vp.ver === VERSION\n+            return Core._parse\n+        end\n+        error(\"JuliaSyntax module is required for syntax version $(vp.ver), but it is not loaded.\")\n+    end\n+    Base.JuliaSyntax.core_parser_hook(code, filename, lineno, offset, options; syntax_version=vp.ver)\n+end\n+\n+struct VersionedLower\n+    ver::VersionNumber\n+end\n+\n+function (vp::VersionedLower)(@nospecialize(code), mod::Module,\n+                              file=\"none\", line=0, world=typemax(Csize_t), warn=false)\n+    if !isdefined(Base, :JuliaLowering)\n+        if vp.ver === VERSION\n+            return Core._parse\n+        end\n+        error(\"JuliaLowering module is required for syntax version $(vp.ver), but it is not loaded.\")\n+    end\n+    Base.JuliaLowering.core_lowering_hook(code, filename, lineno, offset, options; syntax_version=vp.ver)\n+end\n+\n+function Base.set_syntax_version(m::Module, ver::VersionNumber)\n+    parser = VersionedParse(ver)\n+    Core.declare_const(m, :_internal_julia_parse, parser)\n+    #lowerer = VersionedLower(ver)\n+    #Core.declare_const(m, :_internal_julia_lower, lowerer)\n+    nothing\n+end\n+\n+\"\"\"\n+    Base.Experimental.@set_syntax_version ver\n+\n+Sets the syntax version to the current module to `ver`. This overrides settings of `syntax.julia_version` or\n+`compat.julia` from Project.toml.\n+\n+!!! compat \"Julia 1.14\"\n+    This macro was added in Julia 1.14.\n+\n+!!! warning\n+    The new syntax version will take effect only for code parsed after the *invocation* of the result of the macro\n+    expansion. This may be unintuitive if the macro is used inside a module body, as the entire module will be parsed\n+    before any statements therein are executed, e.g. consider.\n+\n+    ```\n+    @set_syntax_version v\"1.13\"\n+    module ChangeSyntax\n+        @set_syntax_version v\"1.14\"\n+        expr1 # Parsed with syntax version 1.13\n+     # The call itself is parsed with syntax version 1.13, but the included code is parsed with syntax version 1.14\n+        include_string(ChangeSyntax, \"expr2\")\n+        expr3 # Parsed with syntax version 1.13\n+    end\n+    ```\n+\n+    For this reason, the Project.toml mechanism is strongly preferred for packages.\n+    However, this macro may be useful for scripts or the REPL.\n+\n+!!! warning\n+    This interface is experimental and subject to change or removal without notice.\n+\"\"\"\n+macro set_syntax_version(ver)\n+    Expr(:call, Base.set_syntax_version, __module__, esc(ver))\n+end\n+\n+\"\"\"\n+    Base.Experimental.@VERSION ver\n+\n+This macro provides access to parser (and possibly in the future other frontend component) language version\n+information. In particular, `(@VERSION).syntax` provides the syntax version used to parse the location where the macro is invoked.\n+\n+!!! compat \"Julia 1.14\"\n+    This macro was added in Julia 1.14.\n+\n+!!! note\n+    Calls to this macro have special handling in the parser and the name `@VERSION` is mandatory. At this time, other macros do not\n+    have access to source syntax version information.\n+\"\"\"\n+function var\"@VERSION\"(__source__::Union{LineNumberNode, Core.MacroSource}, __module__::Module)\n+    # This macro has special handling in the parser, which puts the current syntax\n+    # version into __source__.\n+    if isa(__source__, LineNumberNode)\n+        return :((; syntax = v\"1.13\", runtime = VERSION))\n+    else\n+        return :((; syntax = $(__source__.syntax_ver), runtime = VERSION))\n+    end\n+end\n+\n end # module"
    },
    {
      "sha": "28f3c510e920edfbb241f7358f59b9389bac3555",
      "filename": "base/loading.jl",
      "status": "modified",
      "additions": 209,
      "deletions": 107,
      "changes": 316,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Floading.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -249,6 +249,17 @@ function get_updated_dict(p::TOML.Parser, f::CachedTOMLDict)\n     return f.d\n end\n \n+\"\"\"\n+    struct PkgLoadSpec\n+\n+A PkgLoadSpec is the result of a `locate_package` operation and specifies how\n+and wherefrom to load a julia package.\n+\"\"\"\n+struct PkgLoadSpec\n+    path::String\n+    julia_syntax_version::VersionNumber\n+end\n+\n struct LoadingCache\n     load_path::Vector{String}\n     dummy_uuid::Dict{String, UUID}\n@@ -257,7 +268,7 @@ struct LoadingCache\n     require_parsed::Set{String}\n     identified_where::Dict{Tuple{PkgId, String}, Union{Nothing, Tuple{PkgId, String}}}\n     identified::Dict{String, Union{Nothing, Tuple{PkgId, String}}}\n-    located::Dict{Tuple{PkgId, Union{String, Nothing}}, Union{Tuple{String, String}, Nothing}}\n+    located::Dict{Tuple{PkgId, Union{String, Nothing}}, Union{Tuple{PkgLoadSpec, String}, Nothing}}\n end\n const LOADING_CACHE = Ref{Union{LoadingCache, Nothing}}(nothing) # n.b.: all access to and through this are protected by require_lock\n LoadingCache() = LoadingCache(load_path(), Dict(), Dict(), Dict(), Set(), Dict(), Dict(), Dict())\n@@ -430,26 +441,28 @@ identify_package(where::Module, name::String) = @lock require_lock _nothing_or_f\n identify_package(where::PkgId, name::String)  = @lock require_lock _nothing_or_first(identify_package_env(where, name))\n identify_package(name::String)                = @lock require_lock _nothing_or_first(identify_package_env(name))\n \n-function locate_package_env(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)::Union{Nothing,Tuple{String,String}}\n+function locate_package_env(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)::Union{Nothing,Tuple{PkgLoadSpec, String}}\n     assert_havelock(require_lock)\n     cache = LOADING_CACHE[]\n     if cache !== nothing\n-        pathenv = get(cache.located, (pkg, stopenv), missing)\n-        pathenv === missing || return pathenv\n+        specenv = get(cache.located, (pkg, stopenv), missing)\n+        specenv === missing || return specenv\n     end\n-    path = nothing\n+    spec = nothing\n     env\u2032 = nothing\n+    syntax_version = VERSION\n     if pkg.uuid === nothing\n         # The project we're looking for does not have a Project.toml (n.b. - present\n         # `Project.toml` without UUID gets a path-based dummy UUID). It must have\n         # come from an implicit manifest environment, so go through those only.\n+        # N.B.: Implicitly loaded packages do not participate in syntax versioning.\n         for env in load_path()\n             project_file = env_project_file(env)\n             (project_file isa Bool && project_file) || continue\n             found = implicit_manifest_pkgid(env, pkg.name)\n             if found !== nothing && found.uuid === nothing\n                 @assert found.name == pkg.name\n-                path = implicit_manifest_uuid_path(env, pkg)\n+                spec = implicit_manifest_uuid_load_spec(env, pkg)\n                 env\u2032 = env\n                 @goto done\n             end\n@@ -459,15 +472,14 @@ function locate_package_env(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)\n         end\n     else\n         for env in load_path()\n-            path = manifest_uuid_path(env, pkg)\n+            spec = manifest_uuid_load_spec(env, pkg)\n             # missing is used as a sentinel to stop looking further down in envs\n-            if path === missing\n-                # Before stopping, try stdlib fallback\n+            if spec === missing\n                 is_stdlib(pkg) && @goto stdlib_fallback\n-                path = nothing\n+                spec = nothing\n                 @goto done\n             end\n-            if path !== nothing\n+            if spec !== nothing\n                 env\u2032 = env\n                 @goto done\n             end\n@@ -478,22 +490,22 @@ function locate_package_env(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)\n         @label stdlib_fallback\n         # Allow loading of stdlibs if the name/uuid are given\n         # e.g. if they have been explicitly added to the project/manifest\n-        mbypath = manifest_uuid_path(Sys.STDLIB, pkg)\n-        if mbypath isa String\n-            path = mbypath\n+        mbyspec = manifest_uuid_load_spec(Sys.STDLIB, pkg)\n+        if mbyspec isa PkgLoadSpec\n+            spec = mbyspec\n             env\u2032 = Sys.STDLIB\n             @goto done\n         end\n     end\n     @label done\n-    if path !== nothing && !isfile_casesensitive(path)\n-        path = nothing\n+    if spec !== nothing && !isfile_casesensitive(spec.path)\n+        spec = nothing\n     end\n     if cache !== nothing\n-        cache.located[(pkg, stopenv)] = path === nothing ? nothing : (path, something(env\u2032))\n+        cache.located[(pkg, stopenv)] = spec === nothing ? nothing : (spec, something(env\u2032))\n     end\n-    path === nothing && return nothing\n-    return path, something(env\u2032)\n+    spec === nothing && return nothing\n+    return spec, something(env\u2032)\n end\n \n \"\"\"\n@@ -511,7 +523,19 @@ julia> Base.locate_package(pkg)\n ```\n \"\"\"\n function locate_package(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)::Union{Nothing,String}\n-    @lock require_lock _nothing_or_first(locate_package_env(pkg, stopenv))\n+    @lock require_lock begin\n+        specenv = locate_package_env(pkg, stopenv)\n+        specenv === nothing && return nothing\n+        specenv[1].path\n+    end\n+end\n+\n+function locate_package_load_spec(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)::Union{Nothing,PkgLoadSpec}\n+    @lock require_lock begin\n+        specenv = locate_package_env(pkg, stopenv)\n+        specenv === nothing && return nothing\n+        specenv[1]\n+    end\n end\n \n \"\"\"\n@@ -811,21 +835,22 @@ function environment_deps_get(env::String, where::Union{Nothing,PkgId}, name::St\n     return explicit_manifest_deps_get(project_file, where, name)\n end\n \n-function manifest_uuid_path(env::String, pkg::PkgId)::Union{Nothing,String,Missing}\n+function manifest_uuid_load_spec(env::String, pkg::PkgId)::Union{Nothing,PkgLoadSpec,Missing}\n     project_file = env_project_file(env)\n     if project_file isa String\n         proj = project_file_name_uuid(project_file, pkg.name)\n         if proj == pkg\n             # if `pkg` matches the project, return the project itself\n-            return project_file_path(project_file, pkg.name)\n+            return project_file_load_spec(project_file, pkg.name)\n         end\n-        mby_ext = project_file_ext_path(project_file, pkg)\n+        mby_ext = project_file_ext_load_spec(project_file, pkg)\n         mby_ext === nothing || return mby_ext\n         # look for manifest file and `where` stanza\n-        return explicit_manifest_uuid_path(project_file, pkg)\n+        return explicit_manifest_uuid_load_spec(project_file, pkg)\n     elseif project_file\n         # if env names a directory, search it\n-        proj = implicit_manifest_uuid_path(env, pkg)\n+        # Implicit environments do not participate in syntax versioning\n+        proj = implicit_manifest_uuid_load_spec(env, pkg)\n         proj === nothing || return proj\n         # if not found, this might be an extension - first we fast path needing\n         # to scan the whole directory for a matching extension by peeking at\n@@ -838,14 +863,14 @@ function manifest_uuid_path(env::String, pkg::PkgId)::Union{Nothing,String,Missi\n             if parent_project_file !== nothing\n                 parentproj = project_file_name_uuid(parent_project_file, parentid.name)\n                 if parentproj == parentid\n-                    mby_ext = project_file_ext_path(parent_project_file, pkg)\n+                    mby_ext = project_file_ext_load_spec(parent_project_file, pkg)\n                     mby_ext === nothing || return mby_ext\n                 end\n             end\n         else\n             # We still need to scan the whole directory for extensions.\n-            ext_path, ext_proj = implicit_env_project_file_extension(env, pkg)\n-            ext_path === nothing || return ext_path\n+            ext_ls, ext_proj = implicit_env_project_file_extension(env, pkg)\n+            ext_ls === nothing || return ext_ls\n         end\n     end\n     return nothing\n@@ -858,13 +883,14 @@ function find_ext_path(project_path::String, extname::String)\n     return joinpath(project_path, \"ext\", extname * \".jl\")\n end\n \n-function project_file_ext_path(project_file::String, ext::PkgId)\n+function project_file_ext_load_spec(project_file::String, ext::PkgId)\n     d = parsed_toml(project_file)\n     p = dirname(project_file)\n     exts = get(d, \"extensions\", nothing)::Union{Dict{String, Any}, Nothing}\n     if exts !== nothing\n         if ext.name in keys(exts) && ext.uuid == uuid5(UUID(d[\"uuid\"]::String), ext.name)\n-            return find_ext_path(p, ext.name)\n+            # Syntax version of the main package applies to its extensions\n+            return PkgLoadSpec(find_ext_path(p, ext.name), project_get_syntax_version(d))\n         end\n     end\n     return nothing\n@@ -879,14 +905,47 @@ function project_file_name_uuid(project_file::String, name::String)::PkgId\n     return PkgId(uuid, name)\n end\n \n-function project_file_path(project_file::String, name::String)\n+const NON_VERSIONED_SYNTAX = v\"1.13\"\n+\n+function project_get_syntax_version(d::Dict)\n+    # Syntax Evolution. First check syntax.julia_version entry\n+    sv = nothing\n+    ds = get(d, \"syntax\", nothing)\n+    if ds !== nothing\n+        sv = VersionNumber(get(ds, \"julia_version\", nothing))\n+    end\n+    # If not found, default to minimum(compat[\"julia\"])\n+    if sv === nothing\n+        cs = get(d, \"compat\", nothing)\n+        if cs !== nothing\n+            jv = get(cs, \"julia\", nothing)\n+            if jv !== nothing\n+                sv = VersionNumber(minimum(semver_spec(jv)).t...)\n+            end\n+        end\n+    end\n+    # Finally, if neither of those are set, default to the current Julia version.\n+    # N.B.: This choice is less \"compatible\" than defaulting to a fixed older version.\n+    # However, it avoids surprises from moving over scripts and REPL code to packages\n+    if sv === nothing\n+        sv = VERSION\n+    elseif sv <= NON_VERSIONED_SYNTAX\n+        # Syntax versioning was first introduced in Julia 1.14 - we do not support\n+        # going back to versions before syntax version 1.13.\n+        sv = NON_VERSIONED_SYNTAX\n+    end\n+    return sv\n+end\n+\n+function project_file_load_spec(project_file::String, name::String)\n     d = parsed_toml(project_file)\n     entryfile = get(d, \"path\", nothing)::Union{String, Nothing}\n     # \"path\" entry in project file is soft deprecated\n     if entryfile === nothing\n         entryfile = get(d, \"entryfile\", nothing)::Union{String, Nothing}\n     end\n-    return entry_path(dirname(project_file), name, entryfile)\n+    sv = project_get_syntax_version(d)\n+    return PkgLoadSpec(entry_path(dirname(project_file), name, entryfile), sv)\n end\n \n function workspace_manifest(project_file)\n@@ -969,9 +1028,9 @@ function implicit_env_project_file_extension(dir::String, ext::PkgId)\n     for pkg in readdir(dir; join=true)\n         project_file = env_project_file(pkg)\n         project_file isa String || continue\n-        path = project_file_ext_path(project_file, ext)\n-        if path !== nothing\n-            return path, project_file\n+        ls = project_file_ext_load_spec(project_file, ext)\n+        if ls !== nothing\n+            return ls, project_file\n         end\n     end\n     return nothing, nothing\n@@ -1116,7 +1175,7 @@ function explicit_manifest_deps_get(project_file::String, where::PkgId, name::St\n end\n \n # find `uuid` stanza, return the corresponding path\n-function explicit_manifest_uuid_path(project_file::String, pkg::PkgId)::Union{Nothing,String,Missing}\n+function explicit_manifest_uuid_load_spec(project_file::String, pkg::PkgId)::Union{Nothing,PkgLoadSpec,Missing}\n     manifest_file = project_file_manifest_path(project_file)\n     manifest_file === nothing && return nothing # no manifest, skip env\n \n@@ -1128,7 +1187,7 @@ function explicit_manifest_uuid_path(project_file::String, pkg::PkgId)::Union{No\n             uuid = get(entry, \"uuid\", nothing)::Union{Nothing, String}\n             uuid === nothing && continue\n             if UUID(uuid) === pkg.uuid\n-                return explicit_manifest_entry_path(manifest_file, pkg, entry)\n+                return explicit_manifest_entry_load_spec(manifest_file, pkg, entry)\n             end\n         end\n     end\n@@ -1140,30 +1199,46 @@ function explicit_manifest_uuid_path(project_file::String, pkg::PkgId)::Union{No\n             uuid = get(entry, \"uuid\", nothing)::Union{Nothing, String}\n             extensions = get(entry, \"extensions\", nothing)::Union{Nothing, Dict{String, Any}}\n             if extensions !== nothing && haskey(extensions, pkg.name) && uuid !== nothing && uuid5(UUID(uuid), pkg.name) == pkg.uuid\n-                parent_path = explicit_manifest_entry_path(manifest_file, PkgId(UUID(uuid), name), entry)\n-                if parent_path === nothing || parent_path === missing\n+                parent_load_spec = explicit_manifest_entry_load_spec(manifest_file, PkgId(UUID(uuid), name), entry)\n+                if parent_load_spec === nothing || parent_load_spec === missing\n                     error(\"failed to find source of parent package: \\\"$name\\\"\")\n                 end\n+                parent_path = parent_load_spec.path\n                 p = normpath(dirname(parent_path), \"..\")\n-                return find_ext_path(p, pkg.name)\n+                return PkgLoadSpec(find_ext_path(p, pkg.name), parent_load_spec.julia_syntax_version)\n             end\n         end\n     end\n     return nothing\n end\n \n-function explicit_manifest_entry_path(manifest_file::String, pkg::PkgId, entry::Dict{String,Any})\n+function explicit_manifest_entry_load_spec(manifest_file::String, pkg::PkgId, entry::Dict{String,Any})::Union{Nothing, Missing, PkgLoadSpec}\n+    # Resolve syntax version. N.B.: Unlike in project files, an absent syntax.julia_version\n+    # entry in manifest files means defaulting to 1.13. This is because we assume the\n+    # manifest was created by an older version of julia that did not support syntax versioning.\n+    # Newer versions of Pkg will provide syntax version information in the manifest,\n+    # even if absent from the project file.\n+    syntax_version = NON_VERSIONED_SYNTAX\n+    syntax_table = get(entry, \"syntax\", nothing)\n+    if syntax_table !== nothing\n+        syntax_version = VersionNumber(get(syntax_table, \"julia_version\", nothing))\n+    end\n+\n+    # Resolve path\n     path = get(entry, \"path\", nothing)::Union{Nothing, String}\n     entryfile = get(entry, \"entryfile\", nothing)::Union{Nothing, String}\n     if path !== nothing\n         path = entry_path(normpath(abspath(dirname(manifest_file), path)), pkg.name, entryfile)\n-        return path\n+        return PkgLoadSpec(path, syntax_version)\n     end\n     hash = get(entry, \"git-tree-sha1\", nothing)::Union{Nothing, String}\n     if hash === nothing\n-        mbypath = manifest_uuid_path(Sys.STDLIB, pkg)\n-        if mbypath isa String && isfile(mbypath)\n-            return mbypath\n+        # stdlibs do not have a git-hash so cannot be loaded from depots. As\n+        # a special case, we allow loading these directly from the stdlib location\n+        # (treated as an implicit environment).\n+        mbyspec = manifest_uuid_load_spec(Sys.STDLIB, pkg)\n+        if mbyspec isa PkgLoadSpec && isfile(mbyspec.path)\n+            return mbyspec\n         end\n         return nothing\n     end\n@@ -1173,7 +1248,7 @@ function explicit_manifest_entry_path(manifest_file::String, pkg::PkgId, entry::\n     for slug in (version_slug(uuid, hash), version_slug(uuid, hash, 4))\n         for depot in DEPOT_PATH\n             path = joinpath(depot, \"packages\", pkg.name, slug)\n-            ispath(path) && return entry_path(abspath(path), pkg.name, entryfile)\n+            ispath(path) && return PkgLoadSpec(entry_path(abspath(path), pkg.name, entryfile), syntax_version)\n         end\n     end\n     # no depot contains the package, return missing to stop looking\n@@ -1205,15 +1280,16 @@ function implicit_manifest_project(dir::String, pkg::PkgId)::Union{Nothing, Stri\n end\n \n # look for an entry-point for `pkg` and return its path if UUID matches\n-function implicit_manifest_uuid_path(dir::String, pkg::PkgId)::Union{Nothing,String}\n+function implicit_manifest_uuid_load_spec(dir::String, pkg::PkgId)::Union{Nothing, PkgLoadSpec}\n     path, project_file = entry_point_and_project_file(dir, pkg.name)\n     if project_file === nothing\n         pkg.uuid === nothing || return nothing\n-        return path\n+        # Without a project file, treat as empty - which defaults to VERSION\n+        return PkgLoadSpec(path, VERSION)\n     end\n     proj = project_file_name_uuid(project_file, pkg.name)\n     proj == pkg || return nothing\n-    return path\n+    return PkgLoadSpec(path, project_get_syntax_version(parsed_toml(project_file)))\n end\n \n ## other code loading functionality ##\n@@ -1310,7 +1386,7 @@ function _include_from_serialized(pkg::PkgId, path::String, ocachepath::Union{No\n         for i in eachindex(depmods)\n             dep = depmods[i]\n             dep isa Module && continue\n-            _, depkey, depbuild_id = dep::Tuple{String, PkgId, UInt128}\n+            _, depkey, depbuild_id = dep::Tuple{PkgLoadSpec, PkgId, UInt128}\n             dep = something(maybe_loaded_precompile(depkey, depbuild_id))\n             @assert PkgId(dep) == depkey && module_build_id(dep) === depbuild_id\n             depmods[i] = dep\n@@ -1518,7 +1594,7 @@ function insert_extension_triggers(pkg::PkgId)\n     pkg.uuid === nothing && return\n     path_env_loc = locate_package_env(pkg)\n     path_env_loc === nothing && return\n-    path, env_loc = path_env_loc\n+    _, env_loc = path_env_loc\n     insert_extension_triggers(env_loc, pkg)\n end\n \n@@ -1878,16 +1954,16 @@ function show(io::IO, it::ImageTarget)\n end\n \n # should sync with the types of arguments of `stale_cachefile`\n-const StaleCacheKey = Tuple{PkgId, UInt128, String, String, Bool, CacheFlags}\n+const StaleCacheKey = Tuple{PkgId, UInt128, PkgLoadSpec, String, Bool, CacheFlags}\n \n function compilecache_freshest_path(pkg::PkgId;\n         ignore_loaded::Bool=false,\n         stale_cache::Dict{StaleCacheKey,Bool}=Dict{StaleCacheKey, Bool}(),\n         cachepath_cache::Dict{PkgId, Vector{String}}=Dict{PkgId, Vector{String}}(),\n         cachepaths::Vector{String}=get(() -> find_all_in_cache_path(pkg), cachepath_cache, pkg),\n-        sourcepath::Union{String,Nothing}=Base.locate_package(pkg),\n+        sourcespec::Union{PkgLoadSpec,Nothing}=Base.locate_package_load_spec(pkg),\n         flags::CacheFlags=CacheFlags())\n-    isnothing(sourcepath) && error(\"Cannot locate source for $(repr(\"text/plain\", pkg))\")\n+    isnothing(sourcespec) && error(\"Cannot locate source for $(repr(\"text/plain\", pkg))\")\n     try_build_ids = UInt128[UInt128(0)]\n     if !ignore_loaded\n         let loaded = get(loaded_precompiles, pkg, nothing)\n@@ -1900,19 +1976,19 @@ function compilecache_freshest_path(pkg::PkgId;\n     end\n     for build_id in try_build_ids\n         for path_to_try in cachepaths\n-            staledeps = stale_cachefile(pkg, build_id, sourcepath, path_to_try; ignore_loaded, requested_flags=flags)\n+            staledeps = stale_cachefile(pkg, build_id, sourcespec, path_to_try; ignore_loaded, requested_flags=flags)\n             if staledeps === true\n                 continue\n             end\n             staledeps, _, _ = staledeps::Tuple{Vector{Any}, Union{Nothing, String}, UInt128}\n             # finish checking staledeps module graph\n             for dep in staledeps\n                 dep isa Module && continue\n-                modpath, modkey, modbuild_id = dep::Tuple{String, PkgId, UInt128}\n+                modspec, modkey, modbuild_id = dep::Tuple{PkgLoadSpec, PkgId, UInt128}\n                 modpaths = get(() -> find_all_in_cache_path(modkey), cachepath_cache, modkey)\n                 for modpath_to_try in modpaths::Vector{String}\n-                    stale_cache_key = (modkey, modbuild_id, modpath, modpath_to_try, ignore_loaded, flags)::StaleCacheKey\n-                    if get!(() -> stale_cachefile(modkey, modbuild_id, modpath, modpath_to_try; ignore_loaded, requested_flags=flags) === true,\n+                    stale_cache_key = (modkey, modbuild_id, modspec, modpath_to_try, ignore_loaded, flags)::StaleCacheKey\n+                    if get!(() -> stale_cachefile(modkey, modbuild_id, modspec, modpath_to_try; ignore_loaded, requested_flags=flags) === true,\n                             stale_cache, stale_cache_key)\n                         continue\n                     end\n@@ -1988,6 +2064,7 @@ function parse_cache_buildid(cachepath::String)\n         checksum = isvalid_cache_header(f)\n         iszero(checksum) && throw(ArgumentError(\"Incompatible header in cache file $cachefile.\"))\n         flags = read(f, UInt8)\n+        syntax_version = read(f, UInt8)\n         n = read(f, Int32)\n         n == 0 && error(\"no module defined in $cachefile\")\n         skip(f, n) # module name\n@@ -2005,11 +2082,10 @@ function _tryrequire_from_serialized(modkey::PkgId, build_id::UInt128)\n     loaded = start_loading(modkey, build_id, false)\n     if loaded === nothing\n         try\n-            modpath = locate_package(modkey)\n-            isnothing(modpath) && error(\"Cannot locate source for $(repr(\"text/plain\", modkey))\")\n-            modpath = String(modpath)::String\n-            set_pkgorigin_version_path(modkey, modpath)\n-            loaded = _require_search_from_serialized(modkey, modpath, build_id, true)\n+            modspec = locate_package_load_spec(modkey)\n+            isnothing(modspec) && error(\"Cannot locate source for $(repr(\"text/plain\", modkey))\")\n+            set_pkgorigin_version_path(modkey, modspec.path)\n+            loaded = _require_search_from_serialized(modkey, modspec, build_id, true)\n         finally\n             end_loading(modkey, loaded)\n         end\n@@ -2066,7 +2142,7 @@ end\n \n # returns `nothing` if require found a precompile cache for this sourcepath, but couldn't load it or it was stale\n # returns the set of modules restored if the cache load succeeded\n-@constprop :none function _require_search_from_serialized(pkg::PkgId, sourcepath::String, build_id::UInt128, stalecheck::Bool; reasons=nothing, DEPOT_PATH::typeof(DEPOT_PATH)=DEPOT_PATH)\n+@constprop :none function _require_search_from_serialized(pkg::PkgId, sourcespec::PkgLoadSpec, build_id::UInt128, stalecheck::Bool; reasons=nothing, DEPOT_PATH::typeof(DEPOT_PATH)=DEPOT_PATH)\n     assert_havelock(require_lock)\n     paths = find_all_in_cache_path(pkg, DEPOT_PATH)\n     newdeps = PkgId[]\n@@ -2082,7 +2158,7 @@ end\n     end\n     for build_id in try_build_ids\n         for path_to_try in paths::Vector{String}\n-            staledeps = stale_cachefile(pkg, build_id, sourcepath, path_to_try; reasons, stalecheck)\n+            staledeps = stale_cachefile(pkg, build_id, sourcespec, path_to_try; reasons, stalecheck)\n             if staledeps === true\n                 continue\n             end\n@@ -2100,7 +2176,7 @@ end\n                         i += 1\n                         dep = staledeps[i]\n                         dep isa Module && continue\n-                        _, modkey, modbuild_id = dep::Tuple{String, PkgId, UInt128}\n+                        _, modkey, modbuild_id = dep::Tuple{PkgLoadSpec, PkgId, UInt128}\n                         dep = canstart_loading(modkey, modbuild_id, stalecheck)\n                         if dep isa Module\n                             if PkgId(dep) == modkey && module_build_id(dep) === modbuild_id\n@@ -2121,19 +2197,19 @@ end\n                 for i in reverse(eachindex(staledeps))\n                     dep = staledeps[i]\n                     dep isa Module && continue\n-                    modpath, modkey, modbuild_id = dep::Tuple{String, PkgId, UInt128}\n+                    modspec, modkey, modbuild_id = dep::Tuple{PkgLoadSpec, PkgId, UInt128}\n                     # inline a call to start_loading here\n                     @assert canstart_loading(modkey, modbuild_id, stalecheck) === nothing\n                     package_locks[modkey] = (current_task(), Threads.Condition(require_lock), modbuild_id)\n                     startedloading = i\n                     modpaths = find_all_in_cache_path(modkey, DEPOT_PATH)\n                     for modpath_to_try in modpaths\n-                        modstaledeps = stale_cachefile(modkey, modbuild_id, modpath, modpath_to_try; stalecheck)\n+                        modstaledeps = stale_cachefile(modkey, modbuild_id, modspec, modpath_to_try; stalecheck)\n                         if modstaledeps === true\n                             continue\n                         end\n                         modstaledeps, modocachepath, _ = modstaledeps::Tuple{Vector{Any}, Union{Nothing, String}, UInt128}\n-                        staledeps[i] = (modpath, modkey, modbuild_id, modpath_to_try, modstaledeps, modocachepath)\n+                        staledeps[i] = (modspec, modkey, modbuild_id, modpath_to_try, modstaledeps, modocachepath)\n                         @goto check_next_dep\n                     end\n                     @debug \"Rejecting cache file $path_to_try because required dependency $modkey with build ID $(UUID(modbuild_id)) is missing from the cache.\"\n@@ -2157,8 +2233,8 @@ end\n                 for i in eachindex(staledeps)\n                     dep = staledeps[i]\n                     dep isa Module && continue\n-                    modpath, modkey, modbuild_id, modcachepath, modstaledeps, modocachepath = dep::Tuple{String, PkgId, UInt128, String, Vector{Any}, Union{Nothing, String}}\n-                    set_pkgorigin_version_path(modkey, modpath)\n+                    modspec, modkey, modbuild_id, modcachepath, modstaledeps, modocachepath = dep::Tuple{PkgLoadSpec, PkgId, UInt128, String, Vector{Any}, Union{Nothing, String}}\n+                    set_pkgorigin_version_path(modkey, modspec.path)\n                     dep = _include_from_serialized(modkey, modcachepath, modocachepath, modstaledeps; register = stalecheck)\n                     if !isa(dep, Module)\n                         @debug \"Rejecting cache file $path_to_try because required dependency $modkey failed to load from cache file for $modcachepath.\" exception=dep\n@@ -2182,10 +2258,10 @@ end\n                 for i in startedloading:length(staledeps)\n                     dep = staledeps[i]\n                     dep isa Module && continue\n-                    if dep isa Tuple{String, PkgId, UInt128}\n+                    if dep isa Tuple{PkgLoadSpec, PkgId, UInt128}\n                         _, modkey, _ = dep\n                     else\n-                        _, modkey, _ = dep::Tuple{String, PkgId, UInt128, String, Vector{Any}, Union{Nothing, String}}\n+                        _, modkey, _ = dep::Tuple{PkgLoadSpec, PkgId, UInt128, String, Vector{Any}, Union{Nothing, String}}\n                     end\n                     end_loading(modkey, nothing)\n                 end\n@@ -2654,6 +2730,11 @@ register_root_module(Main)\n # to the loaded_modules table instead of getting bindings.\n baremodule __toplevel__\n using Base\n+global _internal_julia_parse = Core._parse\n+global _internal_julia_lower = Core._lower\n+\n+# Used for version checking of precompiled cache files only\n+global _internal_syntax_version::UInt8 = 0\n end\n \n # get a top-level Module from the given key\n@@ -2702,21 +2783,23 @@ function __require_prelocked(pkg::PkgId, env)\n     assert_havelock(require_lock)\n \n     # perform the search operation to select the module file require intends to load\n-    path = locate_package(pkg, env)\n-    if path === nothing\n+    specenv = locate_package_env(pkg, env)\n+    if specenv === nothing\n         throw(ArgumentError(\"\"\"\n             Package $(repr(\"text/plain\", pkg)) is required but does not seem to be installed:\n              - Run `Pkg.instantiate()` to install all recorded dependencies.\n             \"\"\"))\n     end\n+    spec = specenv[1]\n+    path = spec.path\n     set_pkgorigin_version_path(pkg, path)\n \n     parallel_precompile_attempted = false # being safe to avoid getting stuck in a precompilepkgs loop\n     reasons = Dict{String,Int}()\n     # attempt to load the module file via the precompile cache locations\n     if JLOptions().use_compiled_modules != 0\n         @label load_from_cache\n-        loaded = _require_search_from_serialized(pkg, path, UInt128(0), true; reasons)\n+        loaded = _require_search_from_serialized(pkg, spec, UInt128(0), true; reasons)\n         if loaded isa Module\n             return loaded\n         end\n@@ -2743,10 +2826,10 @@ function __require_prelocked(pkg::PkgId, env)\n         if !generating_output(#=incremental=#false)\n             project = active_project()\n             # spawn off a new incremental pre-compile task for recursive `require` calls\n-            loaded = let path = path, reasons = reasons\n-                maybe_cachefile_lock(pkg, path) do\n+            loaded = let spec = spec, reasons = reasons\n+                maybe_cachefile_lock(pkg, spec.path) do\n                     # double-check the search now that we have lock\n-                    m = _require_search_from_serialized(pkg, path, UInt128(0), true)\n+                    m = _require_search_from_serialized(pkg, spec, UInt128(0), true)\n                     m isa Module && return m\n \n                     verbosity = isinteractive() ? CoreLogging.Info : CoreLogging.Debug\n@@ -2780,7 +2863,7 @@ function __require_prelocked(pkg::PkgId, env)\n                                 end\n                             end\n                         end\n-                        return compilecache(pkg, path; loadable_exts)\n+                        return compilecache(pkg, spec; loadable_exts)\n                     finally\n                         lock(require_lock)\n                     end\n@@ -2821,11 +2904,13 @@ function __require_prelocked(pkg::PkgId, env)\n     if uuid !== old_uuid\n         ccall(:jl_set_module_uuid, Cvoid, (Any, NTuple{2, UInt64}), __toplevel__, uuid)\n     end\n+    __toplevel__._internal_julia_parse = Experimental.VersionedParse(spec.julia_syntax_version)\n     unlock(require_lock)\n     try\n         include(__toplevel__, path)\n         loaded = maybe_root_module(pkg)\n     finally\n+        __toplevel__._internal_julia_parse = Core._parse\n         lock(require_lock)\n         if uuid !== old_uuid\n             ccall(:jl_set_module_uuid, Cvoid, (Any, NTuple{2, UInt64}), __toplevel__, old_uuid)\n@@ -2923,7 +3008,7 @@ function require_stdlib(package_uuidkey::PkgId, ext::Union{Nothing, String}, fro\n                 sourcepath = find_ext_path(normpath(joinpath(env, package_uuidkey.name)), ext)\n             end\n             set_pkgorigin_version_path(this_uuidkey, sourcepath)\n-            newm = _require_search_from_serialized(this_uuidkey, sourcepath, UInt128(0), false; DEPOT_PATH=depot_path)\n+            newm = _require_search_from_serialized(this_uuidkey, PkgLoadSpec(sourcepath, VERSION), UInt128(0), false; DEPOT_PATH=depot_path)\n         end\n     finally\n         end_loading(this_uuidkey, newm)\n@@ -2960,7 +3045,7 @@ function include_string(mapexpr::Function, mod::Module, code::AbstractString,\n                         filename::AbstractString=\"string\")\n     loc = LineNumberNode(1, Symbol(filename))\n     try\n-        ast = Meta.parseall(code, filename=filename)\n+        ast = Meta.parseall(code; filename, mod)\n         if !Meta.isexpr(ast, :toplevel)\n             @assert Core._lower != fl_lower\n             # Only reached when JuliaLowering and alternate parse functions are activated\n@@ -3129,7 +3214,7 @@ end\n const newly_inferred = CodeInstance[]\n \n # this is called in the external process that generates precompiled package files\n-function include_package_for_output(pkg::PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String},\n+function include_package_for_output(pkg::PkgId, input::String, syntax_version::VersionNumber, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String},\n                                     concrete_deps::typeof(_concrete_dependencies), source::Union{Nothing,String})\n \n     @lock require_lock begin\n@@ -3153,6 +3238,10 @@ function include_package_for_output(pkg::PkgId, input::String, depot_path::Vecto\n     end\n \n     ccall(:jl_set_newly_inferred, Cvoid, (Any,), newly_inferred)\n+    # This one changes the parser behavior\n+    __toplevel__._internal_julia_parse = Experimental.VersionedParse(syntax_version)\n+    # This one is the compatibility marker for cache loading\n+    __toplevel__._internal_syntax_version = cache_syntax_version(syntax_version)\n     try\n         Base.include(Base.__toplevel__, input)\n     catch ex\n@@ -3188,7 +3277,7 @@ _pkg_str(_pkg::Pair{PkgId}) = _pkg_str(_pkg.first) * \" => \" * repr(_pkg.second)\n _pkg_str(_pkg::Nothing) = \"nothing\"\n \n const PRECOMPILE_TRACE_COMPILE = Ref{String}()\n-function create_expr_cache(pkg::PkgId, input::String, output::String, output_o::Union{Nothing, String},\n+function create_expr_cache(pkg::PkgId, input::PkgLoadSpec, output::String, output_o::Union{Nothing, String},\n                            concrete_deps::typeof(_concrete_dependencies), flags::Cmd=``, cacheflags::CacheFlags=CacheFlags(),\n                            internal_stderr::IO = stderr, internal_stdout::IO = stdout, loadable_exts::Union{Vector{PkgId},Nothing}=nothing)\n     @nospecialize internal_stderr internal_stdout\n@@ -3254,7 +3343,7 @@ function create_expr_cache(pkg::PkgId, input::String, output::String, output_o::\n         Base.track_nested_precomp($(_pkg_str(vcat(Base.precompilation_stack, pkg))))\n         Base.loadable_extensions = $(_pkg_str(loadable_exts))\n         Base.precompiling_extension = $(loading_extension)\n-        Base.include_package_for_output($(_pkg_str(pkg)), $(repr(abspath(input))), $(repr(depot_path)), $(repr(dl_load_path)),\n+        Base.include_package_for_output($(_pkg_str(pkg)), $(repr(abspath(input.path))), $(repr(input.julia_syntax_version)), $(repr(depot_path)), $(repr(dl_load_path)),\n             $(repr(load_path)), $(_pkg_str(concrete_deps)), $(repr(source_path(nothing))))\n         \"\"\")\n     close(io.in)\n@@ -3312,14 +3401,14 @@ for important notes.\n \"\"\"\n function compilecache(pkg::PkgId, internal_stderr::IO = stderr, internal_stdout::IO = stdout; flags::Cmd=``, cacheflags::CacheFlags=CacheFlags(), loadable_exts::Union{Vector{PkgId},Nothing}=nothing)\n     @nospecialize internal_stderr internal_stdout\n-    path = locate_package(pkg)\n-    path === nothing && throw(ArgumentError(\"$(repr(\"text/plain\", pkg)) not found during precompilation\"))\n-    return compilecache(pkg, path, internal_stderr, internal_stdout; flags, cacheflags, loadable_exts)\n+    spec = locate_package_load_spec(pkg)\n+    spec === nothing && throw(ArgumentError(\"$(repr(\"text/plain\", pkg)) not found during precompilation\"))\n+    return compilecache(pkg, spec, internal_stderr, internal_stdout; flags, cacheflags, loadable_exts)\n end\n \n const MAX_NUM_PRECOMPILE_FILES = Ref(10)\n \n-function compilecache(pkg::PkgId, path::String, internal_stderr::IO = stderr, internal_stdout::IO = stdout,\n+function compilecache(pkg::PkgId, spec::PkgLoadSpec, internal_stderr::IO = stderr, internal_stdout::IO = stdout,\n                       keep_loaded_modules::Bool = true; flags::Cmd=``, cacheflags::CacheFlags=CacheFlags(),\n                       loadable_exts::Union{Vector{PkgId},Nothing}=nothing)\n \n@@ -3359,7 +3448,7 @@ function compilecache(pkg::PkgId, path::String, internal_stderr::IO = stderr, in\n             close(tmpio_o)\n             close(tmpio_so)\n         end\n-        p = create_expr_cache(pkg, path, tmppath, tmppath_o, concrete_deps, flags, cacheflags, internal_stderr, internal_stdout, loadable_exts)\n+        p = create_expr_cache(pkg, spec, tmppath, tmppath_o, concrete_deps, flags, cacheflags, internal_stderr, internal_stdout, loadable_exts)\n \n         if success(p)\n             if cache_objects\n@@ -3391,7 +3480,7 @@ function compilecache(pkg::PkgId, path::String, internal_stderr::IO = stderr, in\n             end\n \n             # inherit permission from the source file (and make them writable)\n-            chmod(tmppath, filemode(path) & 0o777 | 0o200)\n+            chmod(tmppath, filemode(spec.path) & 0o777 | 0o200)\n \n             # prune the directory with cache files\n             if pkg.uuid !== nothing\n@@ -3556,6 +3645,7 @@ end\n \n function _parse_cache_header(f::IO, cachefile::AbstractString)\n     flags = read(f, UInt8)\n+    syntax_version = read(f, UInt8)\n     modules = read_module_list(f, false)\n     totbytes = Int64(read(f, UInt64)) # total bytes for file dependencies + preferences\n     # read the list of requirements\n@@ -3621,12 +3711,12 @@ function _parse_cache_header(f::IO, cachefile::AbstractString)\n \n     srcfiles = srctext_files(f, srctextpos, includes)\n \n-    return modules, (includes, srcfiles, requires), required_modules, srctextpos, prefs, prefs_hash, clone_targets, flags\n+    return modules, (includes, srcfiles, requires), required_modules, srctextpos, prefs, prefs_hash, clone_targets, flags, syntax_version\n end\n \n function parse_cache_header(f::IO, cachefile::AbstractString)\n     modules, (includes, srcfiles, requires), required_modules,\n-        srctextpos, prefs, prefs_hash, clone_targets, flags = _parse_cache_header(f, cachefile)\n+        srctextpos, prefs, prefs_hash, clone_targets, flags, syntax_version = _parse_cache_header(f, cachefile)\n \n     includes_srcfiles = CacheHeaderIncludes[]\n     includes_depfiles = CacheHeaderIncludes[]\n@@ -3700,7 +3790,7 @@ function parse_cache_header(f::IO, cachefile::AbstractString)\n         end\n     end\n \n-    return modules, (includes, includes_srcfiles, requires), required_modules, srctextpos, prefs, prefs_hash, clone_targets, flags\n+    return modules, (includes, includes_srcfiles, requires), required_modules, srctextpos, prefs, prefs_hash, clone_targets, flags, syntax_version\n end\n \n function parse_cache_header(cachefile::String)\n@@ -4090,12 +4180,19 @@ function any_includes_stale(includes::Vector{CacheHeaderIncludes}, cachefile::St\n     return false\n end\n \n+function cache_syntax_version(ver::VersionNumber)\n+    UInt8(clamp(ver.minor - 13, 0, 255))\n+end\n+\n # returns true if it \"cachefile.ji\" is stale relative to \"modpath.jl\" and build_id for modkey\n # otherwise returns the list of dependencies to also check\n-@constprop :none function stale_cachefile(modpath::String, cachefile::String; ignore_loaded::Bool = false, requested_flags::CacheFlags=CacheFlags(), reasons=nothing)\n-    return stale_cachefile(PkgId(\"\"), UInt128(0), modpath, cachefile; ignore_loaded, requested_flags, reasons)\n+@constprop :none function stale_cachefile(modpath::String, cachefile::String; kwargs...)\n+    return stale_cachefile(PkgLoadSpec(modpath, VERSION), cachefile; kwargs...)\n end\n-@constprop :none function stale_cachefile(modkey::PkgId, build_id::UInt128, modpath::String, cachefile::String;\n+@constprop :none function stale_cachefile(modspec::PkgLoadSpec, cachefile::String; ignore_loaded::Bool = false, requested_flags::CacheFlags=CacheFlags(), reasons=nothing)\n+    return stale_cachefile(PkgId(\"\"), UInt128(0), modspec, cachefile; ignore_loaded, requested_flags, reasons)\n+end\n+@constprop :none function stale_cachefile(modkey::PkgId, build_id::UInt128, modspec::PkgLoadSpec, cachefile::String;\n                                           ignore_loaded::Bool=false, requested_flags::CacheFlags=CacheFlags(),\n                                           reasons::Union{Dict{String,Int},Nothing}=nothing, stalecheck::Bool=true)\n     # n.b.: this function does nearly all of the file validation, not just those checks related to stale, so the name is potentially unclear\n@@ -4113,7 +4210,7 @@ end\n             record_reason(reasons, \"different Julia build configuration\")\n             return true # incompatible cache file\n         end\n-        modules, (includes, _, requires), required_modules, srctextpos, prefs, prefs_hash, clone_targets, actual_flags = parse_cache_header(io, cachefile)\n+        modules, (includes, _, requires), required_modules, srctextpos, prefs, prefs_hash, clone_targets, actual_flags, syntax_version = parse_cache_header(io, cachefile)\n         if isempty(modules)\n             return true # ignore empty file\n         end\n@@ -4126,6 +4223,11 @@ end\n             record_reason(reasons, \"different compilation options\")\n             return true\n         end\n+        if syntax_version != cache_syntax_version(modspec.julia_syntax_version)\n+            @debug \"Rejecting cache file $cachefile for $modkey since it was parsed for a different Julia syntax version\"\n+            record_reason(reasons, \"different Julia syntax version\")\n+            return true\n+        end\n         pkgimage = !isempty(clone_targets)\n         if pkgimage\n             ocachefile = ocachefile_from_cachefile(cachefile)\n@@ -4199,13 +4301,13 @@ end\n                     return true # Won't be able to fulfill dependency\n                 end\n             end\n-            path = locate_package(req_key) # TODO: add env and/or skip this when stalecheck is false\n-            if path === nothing\n+            spec = locate_package_load_spec(req_key) # TODO: add env and/or skip this when stalecheck is false\n+            if spec === nothing\n                 @debug \"Rejecting cache file $cachefile because dependency $req_key not found.\"\n                 record_reason(reasons, \"dependency source file not found\")\n                 return true # Won't be able to fulfill dependency\n             end\n-            depmods[i] = (path, req_key, req_build_id)\n+            depmods[i] = (spec, req_key, req_build_id)\n         end\n \n         # check if this file is going to provide one of our concrete dependencies\n@@ -4229,12 +4331,12 @@ end\n \n         # now check if this file's content hash has changed relative to its source files\n         if stalecheck\n-            if !samefile(includes[1].filename, modpath)\n+            if !samefile(includes[1].filename, modspec.path)\n                 # In certain cases the path rewritten by `fixup_stdlib_path` may\n                 # point to an unreadable directory, make sure we can `stat` the\n                 # file before comparing it with `modpath`.\n                 stdlib_path = fixup_stdlib_path(includes[1].filename)\n-                if !(isreadable(stdlib_path) && samefile(stdlib_path, modpath))\n+                if !(isreadable(stdlib_path) && samefile(stdlib_path, modspec.path))\n                     @debug \"Rejecting cache file $cachefile because it is for file $(includes[1].filename) not file $modpath\"\n                     record_reason(reasons, \"different source file path\")\n                     return true # cache file was compiled from a different path\n@@ -4394,7 +4496,7 @@ function precompile(@nospecialize(argt::Type), m::Method)\n     return precompile(mi)\n end\n \n-precompile(include_package_for_output, (PkgId, String, Vector{String}, Vector{String}, Vector{String}, typeof(_concrete_dependencies), Nothing)) || @assert false\n-precompile(include_package_for_output, (PkgId, String, Vector{String}, Vector{String}, Vector{String}, typeof(_concrete_dependencies), String)) || @assert false\n-precompile(create_expr_cache, (PkgId, String, String, String, typeof(_concrete_dependencies), Cmd, CacheFlags, IO, IO)) || @assert false\n-precompile(create_expr_cache, (PkgId, String, String, Nothing, typeof(_concrete_dependencies), Cmd, CacheFlags, IO, IO)) || @assert false\n+precompile(include_package_for_output, (PkgId, String, VersionNumber, Vector{String}, Vector{String}, Vector{String}, typeof(_concrete_dependencies), Nothing)) || @assert false\n+precompile(include_package_for_output, (PkgId, String, VersionNumber, Vector{String}, Vector{String}, Vector{String}, typeof(_concrete_dependencies), String)) || @assert false\n+precompile(create_expr_cache, (PkgId, PkgLoadSpec, String, String, typeof(_concrete_dependencies), Cmd, CacheFlags, IO, IO)) || @assert false\n+precompile(create_expr_cache, (PkgId, PkgLoadSpec, String, Nothing, typeof(_concrete_dependencies), Cmd, CacheFlags, IO, IO)) || @assert false"
    },
    {
      "sha": "1f5f49b72575f581ae95bcde54f059d9ca0724e7",
      "filename": "base/meta.jl",
      "status": "modified",
      "additions": 19,
      "deletions": 10,
      "changes": 29,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fmeta.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fmeta.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fmeta.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -304,12 +304,21 @@ end\n \n ParseError(msg::AbstractString) = ParseError(msg, nothing)\n \n+# N.B.: Should match definition in src/ast.c:jl_parse\n+function parser_for_module(mod::Union{Module, Nothing})\n+    mod === nothing && return Core._parse\n+    isdefined(mod, :_internal_julia_parse) ?\n+        getglobal(mod, :_internal_julia_parse) :\n+        Core._parse\n+end\n+\n function _parse_string(text::AbstractString, filename::AbstractString,\n-                       lineno::Integer, index::Integer, options)\n+                       lineno::Integer, index::Integer, options,\n+                       _parse=parser_for_module(nothing))\n     if index < 1 || index > ncodeunits(text) + 1\n         throw(BoundsError(text, index))\n     end\n-    ex, offset::Int = Core._parse(text, filename, lineno, index-1, options)\n+    ex, offset::Int = _parse(text, filename, lineno, index-1, options)\n     ex, offset+1\n end\n \n@@ -346,8 +355,8 @@ julia> Meta.parse(\"(\u03b1, \u03b2) = 3, 5\", 11, greedy=false)\n ```\n \"\"\"\n function parse(str::AbstractString, pos::Integer;\n-               filename=\"none\", greedy::Bool=true, raise::Bool=true, depwarn::Bool=true)\n-    ex, pos = _parse_string(str, String(filename), 1, pos, greedy ? :statement : :atom)\n+               filename=\"none\", greedy::Bool=true, raise::Bool=true, depwarn::Bool=true, mod = nothing)\n+    ex, pos = _parse_string(str, String(filename), 1, pos, greedy ? :statement : :atom, parser_for_module(mod))\n     if raise && isexpr(ex, :error)\n         err = ex.args[1]\n         if err isa String\n@@ -386,8 +395,8 @@ julia> Meta.parse(\"x = \")\n ```\n \"\"\"\n function parse(str::AbstractString;\n-               filename=\"none\", raise::Bool=true, depwarn::Bool=true)\n-    ex, pos = parse(str, 1; filename, greedy=true, raise, depwarn)\n+               filename=\"none\", raise::Bool=true, depwarn::Bool=true, mod = nothing)\n+    ex, pos = parse(str, 1; filename, greedy=true, raise, depwarn, mod = mod)\n     if isexpr(ex, :error)\n         return ex\n     end\n@@ -398,12 +407,12 @@ function parse(str::AbstractString;\n     return ex\n end\n \n-function parseatom(text::AbstractString, pos::Integer; filename=\"none\", lineno=1)\n-    return _parse_string(text, String(filename), lineno, pos, :atom)\n+function parseatom(text::AbstractString, pos::Integer; filename=\"none\", lineno=1, mod = nothing)\n+    return _parse_string(text, String(filename), lineno, pos, :atom, parser_for_module(mod))\n end\n \n-function parseall(text::AbstractString; filename=\"none\", lineno=1)\n-    ex,_ = _parse_string(text, String(filename), lineno, 1, :all)\n+function parseall(text::AbstractString; filename=\"none\", lineno=1, mod = nothing)\n+    ex,_ = _parse_string(text, String(filename), lineno, 1, :all, parser_for_module(mod))\n     return ex\n end\n "
    },
    {
      "sha": "52ffdb3fb69bddbf045c4a6655b8370e94ea4191",
      "filename": "base/precompilation.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 12,
      "changes": 25,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fprecompilation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fprecompilation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fprecompilation.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -1058,19 +1058,19 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n         cachepaths = Base.find_all_in_cache_path(pkg)\n         freshpaths = String[]\n         cachepath_cache[pkg] = freshpaths\n-        sourcepath = Base.locate_package(pkg)\n+        sourcespec = Base.locate_package_load_spec(pkg)\n         single_requested_pkg = length(requested_pkgs) == 1 &&\n             (pkg in requested_pkgids || pkg.name in pkg_names)\n         for config in configs\n             pkg_config = (pkg, config)\n-            if sourcepath === nothing\n+            if sourcespec === nothing\n                 failed_deps[pkg_config] = \"Error: Missing source file for $(pkg)\"\n                 notify(was_processed[pkg_config])\n                 continue\n             end\n             # Heuristic for when precompilation is disabled, which must not over-estimate however for any dependent\n             # since it will also block precompilation of all dependents\n-            if _from_loading && single_requested_pkg && occursin(r\"\\b__precompile__\\(\\s*false\\s*\\)\", read(sourcepath, String))\n+            if _from_loading && single_requested_pkg && occursin(r\"\\b__precompile__\\(\\s*false\\s*\\)\", read(sourcespec.path, String))\n                 @lock print_lock begin\n                     Base.@logmsg logcalls \"Disabled precompiling $(repr(\"text/plain\", pkg)) since the text `__precompile__(false)` was found in file.\"\n                 end\n@@ -1088,7 +1088,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                         end\n                     end\n                     circular = pkg in circular_deps\n-                    freshpath = Base.compilecache_freshest_path(pkg; ignore_loaded, stale_cache, cachepath_cache, cachepaths, sourcepath, flags=cacheflags)\n+                    freshpath = Base.compilecache_freshest_path(pkg; ignore_loaded, stale_cache, cachepath_cache, cachepaths, sourcespec, flags=cacheflags)\n                     is_stale = freshpath === nothing\n                     if !is_stale\n                         push!(freshpaths, freshpath)\n@@ -1102,6 +1102,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                         std_pipe = Base.link_pipe!(Pipe(); reader_supports_async=true, writer_supports_async=true)\n                         t_monitor = @async monitor_std(pkg_config, std_pipe; single_requested_pkg)\n \n+                        local name\n                         try\n                             name = describe_pkg(pkg, is_project_dep, is_serial_dep, flags, cacheflags)\n                             @lock print_lock begin\n@@ -1126,7 +1127,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                             if _from_loading && pkg in requested_pkgids\n                                 # loading already took the cachefile_lock and printed logmsg for its explicit requests\n                                 t = @elapsed ret = begin\n-                                    Base.compilecache(pkg, sourcepath, std_pipe, std_pipe, !ignore_loaded;\n+                                    Base.compilecache(pkg, sourcespec, std_pipe, std_pipe, !ignore_loaded;\n                                                       flags, cacheflags, loadable_exts)\n                                 end\n                             else\n@@ -1138,7 +1139,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                                         return ErrorException(\"canceled\")\n                                     end\n                                     cachepaths = Base.find_all_in_cache_path(pkg)\n-                                    local freshpath = Base.compilecache_freshest_path(pkg; ignore_loaded, stale_cache, cachepath_cache, cachepaths, sourcepath, flags=cacheflags)\n+                                    local freshpath = Base.compilecache_freshest_path(pkg; ignore_loaded, stale_cache, cachepath_cache, cachepaths, sourcespec, flags=cacheflags)\n                                     local is_stale = freshpath === nothing\n                                     if !is_stale\n                                         push!(freshpaths, freshpath)\n@@ -1147,7 +1148,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                                     logcalls === CoreLogging.Debug && @lock print_lock begin\n                                         @debug \"Precompiling $(repr(\"text/plain\", pkg))\"\n                                     end\n-                                    Base.compilecache(pkg, sourcepath, std_pipe, std_pipe, !ignore_loaded;\n+                                    Base.compilecache(pkg, sourcespec, std_pipe, std_pipe, !ignore_loaded;\n                                                       flags, cacheflags, loadable_exts)\n                                 end\n                             end\n@@ -1165,7 +1166,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                                     cachefile, _ = ret::Tuple{String, Union{Nothing, String}}\n                                     push!(freshpaths, cachefile)\n                                     build_id, _ = Base.parse_cache_buildid(cachefile)\n-                                    stale_cache_key = (pkg, build_id, sourcepath, cachefile, ignore_loaded, cacheflags)::StaleCacheKey\n+                                    stale_cache_key = (pkg, build_id, sourcespec, cachefile, ignore_loaded, cacheflags)::StaleCacheKey\n                                     stale_cache[stale_cache_key] = false\n                                 end\n                             end\n@@ -1193,8 +1194,8 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                     notify(was_processed[pkg_config])\n                 catch err_outer\n                     # For debugging:\n-                    # println(\"Task failed $err_outer\")\n-                    # Base.display_error(ErrorException(\"\"), Base.catch_backtrace())# logging doesn't show here\n+                    println(\"Task failed $err_outer\")\n+                    Base.display_error(ErrorException(\"\"), Base.catch_backtrace())# logging doesn't show here\n                     handle_interrupt(err_outer, false)\n                     rethrow()\n                 end\n@@ -1207,8 +1208,8 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n         interrupted_or_done[] = true\n     catch err\n         # For debugging:\n-        # println(\"Task failed $err\")\n-        # Base.display_error(ErrorException(\"\"), Base.catch_backtrace())# logging doesn't show here\n+        println(\"Task failed $err\")\n+        Base.display_error(ErrorException(\"\"), Base.catch_backtrace())# logging doesn't show here\n         handle_interrupt(err, false) || rethrow()\n     finally\n         try"
    },
    {
      "sha": "ab6d086cdbd7205c0ccc0347bb354c715c3ef60e",
      "filename": "base/runtime_internals.jl",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fruntime_internals.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fruntime_internals.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fruntime_internals.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -1800,9 +1800,6 @@ hasintersect(@nospecialize(a), @nospecialize(b)) = typeintersect(a, b) !== Botto\n # scoping #\n ###########\n \n-_topmod(m::Module) = ccall(:jl_base_relative_to, Any, (Any,), m)::Module\n-\n-\n # high-level, more convenient method lookup functions\n \n function visit(f, mt::Core.MethodTable)"
    },
    {
      "sha": "5870b11c5ac183a9687273376c5bb263d8b2d4f0",
      "filename": "base/version.jl",
      "status": "modified",
      "additions": 467,
      "deletions": 0,
      "changes": 467,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fversion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/base%2Fversion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fversion.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -275,3 +275,470 @@ else\n end\n \n libllvm_path() = ccall(:jl_get_libllvm, Any, ())\n+\n+\n+################\n+# VersionBound #\n+################\n+struct VersionBound\n+    t::NTuple{3, UInt32}\n+    n::Int\n+    function VersionBound(tin::NTuple{n, Integer}) where {n}\n+        n <= 3 || throw(ArgumentError(\"VersionBound: you can only specify major, minor and patch versions\"))\n+        n == 0 && return new((0, 0, 0), n)\n+        n == 1 && return new((tin[1], 0, 0), n)\n+        n == 2 && return new((tin[1], tin[2], 0), n)\n+        n == 3 && return new((tin[1], tin[2], tin[3]), n)\n+        error(\"invalid $n\")\n+    end\n+end\n+VersionBound(t::Integer...) = VersionBound(t)\n+VersionBound(v::VersionNumber) = VersionBound(v.major, v.minor, v.patch)\n+\n+Base.getindex(b::VersionBound, i::Int) = b.t[i]\n+\n+function \u2272(v::VersionNumber, b::VersionBound)\n+    b.n == 0 && return true\n+    b.n == 1 && return v.major <= b[1]\n+    b.n == 2 && return (v.major, v.minor) <= (b[1], b[2])\n+    return (v.major, v.minor, v.patch) <= (b[1], b[2], b[3])\n+end\n+\n+function \u2272(b::VersionBound, v::VersionNumber)\n+    b.n == 0 && return true\n+    b.n == 1 && return v.major >= b[1]\n+    b.n == 2 && return (v.major, v.minor) >= (b[1], b[2])\n+    return (v.major, v.minor, v.patch) >= (b[1], b[2], b[3])\n+end\n+\n+function isless_ll(a::VersionBound, b::VersionBound)\n+    m, n = a.n, b.n\n+    for i in 1:min(m, n)\n+        a[i] < b[i] && return true\n+        a[i] > b[i] && return false\n+    end\n+    return m < n\n+end\n+\n+stricterlower(a::VersionBound, b::VersionBound) = isless_ll(a, b) ? b : a\n+\n+# Comparison between two upper bounds\n+function isless_uu(a::VersionBound, b::VersionBound)\n+    m, n = a.n, b.n\n+    for i in 1:min(m, n)\n+        a[i] < b[i] && return true\n+        a[i] > b[i] && return false\n+    end\n+    return m > n\n+end\n+\n+stricterupper(a::VersionBound, b::VersionBound) = isless_uu(a, b) ? a : b\n+\n+# `isjoinable` compares an upper bound of a range with the lower bound of the next range\n+# to determine if they can be joined, as in [1.5-2.8, 2.5-3] -> [1.5-3]. Used by `union!`.\n+# The equal-length-bounds case is special since e.g. `1.5` can be joined with `1.6`,\n+# `2.3.4` can be joined with `2.3.5` etc.\n+\n+function isjoinable(up::VersionBound, lo::VersionBound)\n+    up.n == 0 && lo.n == 0 && return true\n+    if up.n == lo.n\n+        n = up.n\n+        for i in 1:(n - 1)\n+            up[i] > lo[i] && return true\n+            up[i] < lo[i] && return false\n+        end\n+        up[n] < lo[n] - 1 && return false\n+        return true\n+    else\n+        l = min(up.n, lo.n)\n+        for i in 1:l\n+            up[i] > lo[i] && return true\n+            up[i] < lo[i] && return false\n+        end\n+    end\n+    return true\n+end\n+\n+Base.hash(r::VersionBound, h::UInt) = hash(r.t, hash(r.n, h))\n+\n+# Hot code\n+function VersionBound(s::AbstractString)\n+    s = strip(s)\n+    s == \"*\" && return VersionBound()\n+    first(s) == 'v' && (s = SubString(s, 2))\n+    l = lastindex(s)\n+\n+    p = findnext('.', s, 1)\n+    b = p === nothing ? l : (p - 1)\n+    i = parse(Int64, SubString(s, 1, b))\n+    p === nothing && return VersionBound(i)\n+\n+    a = p + 1\n+    p = findnext('.', s, a)\n+    b = p === nothing ? l : (p - 1)\n+    j = parse(Int64, SubString(s, a, b))\n+    p === nothing && return VersionBound(i, j)\n+\n+    a = p + 1\n+    p = findnext('.', s, a)\n+    b = p === nothing ? l : (p - 1)\n+    k = parse(Int64, SubString(s, a, b))\n+    p === nothing && return VersionBound(i, j, k)\n+\n+    error(\"invalid VersionBound string $(repr(s))\")\n+end\n+\n+################\n+# VersionRange #\n+################\n+struct VersionRange\n+    lower::VersionBound\n+    upper::VersionBound\n+    # NOTE: ranges are allowed to be empty; they are ignored by VersionSpec anyway\n+    function VersionRange(lo::VersionBound, hi::VersionBound)\n+        # lo.t == hi.t implies that digits past min(lo.n, hi.n) are zero\n+        # lo.n < hi.n example: 1.2-1.2.0 => 1.2.0\n+        # lo.n > hi.n example: 1.2.0-1.2 => 1.2\n+        lo.t == hi.t && (lo = hi)\n+        return new(lo, hi)\n+    end\n+end\n+VersionRange(b::VersionBound = VersionBound()) = VersionRange(b, b)\n+VersionRange(t::Integer...) = VersionRange(VersionBound(t...))\n+VersionRange(v::VersionNumber) = VersionRange(VersionBound(v))\n+VersionRange(lo::VersionNumber, hi::VersionNumber) = VersionRange(VersionBound(lo), VersionBound(hi))\n+\n+# The vast majority of VersionRanges are in practice equal to \"1\"\n+const VersionRange_1 = VersionRange(VersionBound(\"1\"), VersionBound(\"1\"))\n+function VersionRange(s::AbstractString)\n+    s == \"1\" && return VersionRange_1\n+    p = split(s, \"-\")\n+    if length(p) != 1 && length(p) != 2\n+        throw(ArgumentError(\"invalid version range: $(repr(s))\"))\n+    end\n+    lower = VersionBound(p[1])\n+    upper = length(p) == 1 ? lower : VersionBound(p[2])\n+    return VersionRange(lower, upper)\n+end\n+\n+function Base.isempty(r::VersionRange)\n+    for i in 1:min(r.lower.n, r.upper.n)\n+        r.lower[i] > r.upper[i] && return true\n+        r.lower[i] < r.upper[i] && return false\n+    end\n+    return false\n+end\n+\n+function Base.print(io::IO, r::VersionRange)\n+    m, n = r.lower.n, r.upper.n\n+    return if (m, n) == (0, 0)\n+        print(io, '*')\n+    elseif m == 0\n+        print(io, \"0 -\")\n+        join(io, r.upper.t, '.')\n+    elseif n == 0\n+        join(io, r.lower.t, '.')\n+        print(io, \" - *\")\n+    else\n+        join(io, r.lower.t[1:m], '.')\n+        if r.lower != r.upper\n+            print(io, \" - \")\n+            join(io, r.upper.t[1:n], '.')\n+        end\n+    end\n+end\n+Base.show(io::IO, r::VersionRange) = print(io, \"VersionRange(\\\"\", r, \"\\\")\")\n+\n+Base.in(v::VersionNumber, r::VersionRange) = r.lower \u2272 v \u2272 r.upper\n+\n+Base.intersect(a::VersionRange, b::VersionRange) = VersionRange(stricterlower(a.lower, b.lower), stricterupper(a.upper, b.upper))\n+\n+function Base.union!(ranges::Vector{<:VersionRange})\n+    l = length(ranges)\n+    l == 0 && return ranges\n+\n+    sort!(ranges, lt = (a, b) -> (isless_ll(a.lower, b.lower) || (a.lower == b.lower && isless_uu(a.upper, b.upper))))\n+\n+    k0 = 1\n+    ks = findfirst(!isempty, ranges)\n+    ks === nothing && return empty!(ranges)\n+\n+    lo, up, k0 = ranges[ks].lower, ranges[ks].upper, 1\n+    for k in (ks + 1):l\n+        isempty(ranges[k]) && continue\n+        lo1, up1 = ranges[k].lower, ranges[k].upper\n+        if isjoinable(up, lo1)\n+            isless_uu(up, up1) && (up = up1)\n+            continue\n+        end\n+        vr = VersionRange(lo, up)\n+        @assert !isempty(vr)\n+        ranges[k0] = vr\n+        k0 += 1\n+        lo, up = lo1, up1\n+    end\n+    vr = VersionRange(lo, up)\n+    if !isempty(vr)\n+        ranges[k0] = vr\n+        k0 += 1\n+    end\n+    resize!(ranges, k0 - 1)\n+    return ranges\n+end\n+\n+Base.minimum(r::VersionRange) = r.lower\n+\n+###############\n+# VersionSpec #\n+###############\n+struct VersionSpec\n+    ranges::Vector{VersionRange}\n+    VersionSpec(r::Vector{<:VersionRange}) = new(length(r) == 1 ? r : union!(r))\n+    VersionSpec(vs::VersionSpec) = vs\n+end\n+\n+VersionSpec(r::VersionRange) = VersionSpec(VersionRange[r])\n+VersionSpec(v::VersionNumber) = VersionSpec(VersionRange(v))\n+const _all_versionsspec = VersionSpec(VersionRange())\n+VersionSpec() = _all_versionsspec\n+VersionSpec(s::AbstractString) = VersionSpec(VersionRange(s))\n+VersionSpec(v::AbstractVector) = VersionSpec(map(VersionRange, v))\n+\n+# Hot code\n+function Base.in(v::VersionNumber, s::VersionSpec)\n+    for r in s.ranges\n+        v in r && return true\n+    end\n+    return false\n+end\n+\n+# Optimized batch version check for version lists\n+# Fills dest[1:n] indicating which versions are in the VersionSpec\n+# Optimized for sorted version lists (but works correctly even if unsorted)\n+# Note: Only fills indices 1:n, leaves rest of dest unchanged\n+function matches_spec_range!(dest::BitVector, versions::AbstractVector{VersionNumber}, spec::VersionSpec, n::Int)\n+    @assert length(versions) == n\n+    @assert length(dest) >= n\n+\n+    # Initialize to false\n+    dest[1:n] .= false\n+\n+    isempty(spec.ranges) && return dest\n+\n+    # Assumes versions are sorted (as created in Operations.jl:1002)\n+    # If sorted, this avoids O(n*m) comparisons by scanning linearly\n+    @inbounds for range in spec.ranges\n+        # Find first version that could be in range\n+        i = 1\n+        while i <= n && !(range.lower \u2272 versions[i])\n+            i += 1\n+        end\n+\n+        # Mark all versions in range\n+        while i <= n && versions[i] \u2272 range.upper\n+            dest[i] = true\n+            i += 1\n+        end\n+    end\n+\n+    return dest\n+end\n+\n+Base.copy(vs::VersionSpec) = VersionSpec(vs)\n+\n+const empty_versionspec = VersionSpec(VersionRange[])\n+const _empty_symbol = \"\u2205\"\n+\n+Base.isempty(s::VersionSpec) = all(isempty, s.ranges)\n+@assert isempty(empty_versionspec)\n+# Hot code, measure performance before changing\n+function Base.intersect(A::VersionSpec, B::VersionSpec)\n+    (isempty(A) || isempty(B)) && return copy(empty_versionspec)\n+    ranges = Vector{VersionRange}(undef, length(A.ranges) * length(B.ranges))\n+    i = 1\n+    @inbounds for a in A.ranges, b in B.ranges\n+        ranges[i] = intersect(a, b)\n+        i += 1\n+    end\n+    return VersionSpec(ranges)\n+end\n+Base.intersect(a::VersionNumber, B::VersionSpec) = a in B ? VersionSpec(a) : empty_versionspec\n+Base.intersect(A::VersionSpec, b::VersionNumber) = intersect(b, A)\n+\n+function Base.union(A::VersionSpec, B::VersionSpec)\n+    A == B && return A\n+    Ar = copy(A.ranges)\n+    append!(Ar, B.ranges)\n+    union!(Ar)\n+    return VersionSpec(Ar)\n+end\n+\n+Base.:(==)(A::VersionSpec, B::VersionSpec) = A.ranges == B.ranges\n+Base.hash(s::VersionSpec, h::UInt) = hash(s.ranges, h + (0x2fd2ca6efa023f44 % UInt))\n+\n+function Base.print(io::IO, s::VersionSpec)\n+    isempty(s) && return print(io, _empty_symbol)\n+    length(s.ranges) == 1 && return print(io, s.ranges[1])\n+    print(io, '[')\n+    for i in 1:length(s.ranges)\n+        1 < i && print(io, \", \")\n+        print(io, s.ranges[i])\n+    end\n+    return print(io, ']')\n+end\n+\n+function Base.show(io::IO, s::VersionSpec)\n+    print(io, \"VersionSpec(\")\n+    if length(s.ranges) == 1\n+        print(io, '\"', s.ranges[1], '\"')\n+    else\n+        print(io, \"[\")\n+        for i in 1:length(s.ranges)\n+            1 < i && print(io, \", \")\n+            print(io, '\"', s.ranges[i], '\"')\n+        end\n+        print(io, ']')\n+    end\n+    return print(io, \")\")\n+end\n+\n+Base.minimum(v::VersionSpec) = minimum(v.ranges[1])\n+\n+###################\n+# Semver notation #\n+###################\n+\n+function semver_spec(s::String; throw = true)\n+    ranges = VersionRange[]\n+    for ver in strip.(split(strip(s), ','))\n+        range = nothing\n+        found_match = false\n+        for (ver_reg, f) in ver_regs\n+            if occursin(ver_reg, ver)\n+                range = f(match(ver_reg, ver))\n+                found_match = true\n+                break\n+            end\n+        end\n+        if !found_match\n+            if throw\n+                error(\"invalid version specifier: \\\"$s\\\"\")\n+            else\n+                return nothing\n+            end\n+        end\n+        push!(ranges, range)\n+    end\n+    return VersionSpec(ranges)\n+end\n+\n+function semver_interval(m::RegexMatch)\n+    @assert length(m.captures) == 4\n+    n_significant = count(x -> x !== nothing, m.captures) - 1\n+    typ, _major, _minor, _patch = m.captures\n+    major = parse(Int, _major)\n+    minor = (n_significant < 2) ? 0 : parse(Int, _minor)\n+    patch = (n_significant < 3) ? 0 : parse(Int, _patch)\n+    if n_significant == 3 && major == 0 && minor == 0 && patch == 0\n+        error(\"invalid version: \\\"0.0.0\\\"\")\n+    end\n+    # Default type is :caret\n+    vertyp = (typ == \"\" || typ == \"^\") ? :caret : :tilde\n+    v0 = VersionBound((major, minor, patch))\n+    return if vertyp === :caret\n+        if major != 0\n+            return VersionRange(v0, VersionBound((v0[1],)))\n+        elseif minor != 0\n+            return VersionRange(v0, VersionBound((v0[1], v0[2])))\n+        else\n+            if n_significant == 1\n+                return VersionRange(v0, VersionBound((0,)))\n+            elseif n_significant == 2\n+                return VersionRange(v0, VersionBound((0, 0)))\n+            else\n+                return VersionRange(v0, VersionBound((0, 0, v0[3])))\n+            end\n+        end\n+    else\n+        if n_significant == 3 || n_significant == 2\n+            return VersionRange(v0, VersionBound((v0[1], v0[2])))\n+        else\n+            return VersionRange(v0, VersionBound((v0[1],)))\n+        end\n+    end\n+end\n+\n+const _inf = VersionBound(\"*\")\n+function inequality_interval(m::RegexMatch)\n+    @assert length(m.captures) == 4\n+    typ, _major, _minor, _patch = m.captures\n+    n_significant = count(x -> x !== nothing, m.captures) - 1\n+    major = parse(Int, _major)\n+    minor = (n_significant < 2) ? 0 : parse(Int, _minor)\n+    patch = (n_significant < 3) ? 0 : parse(Int, _patch)\n+    if n_significant == 3 && major == 0 && minor == 0 && patch == 0\n+        error(\"invalid version: 0.0.0\")\n+    end\n+    v = VersionBound(major, minor, patch)\n+    if occursin(r\"^<\\s*$\", typ)\n+        nil = VersionBound(0, 0, 0)\n+        if v[3] == 0\n+            if v[2] == 0\n+                v1 = VersionBound(v[1] - 1)\n+            else\n+                v1 = VersionBound(v[1], v[2] - 1)\n+            end\n+        else\n+            v1 = VersionBound(v[1], v[2], v[3] - 1)\n+        end\n+        return VersionRange(nil, v1)\n+    elseif occursin(r\"^=\\s*$\", typ)\n+        return VersionRange(v)\n+    elseif occursin(r\"^>=\\s*$\", typ) || occursin(r\"^\u2265\\s*$\", typ)\n+        return VersionRange(v, _inf)\n+    else\n+        error(\"invalid prefix $typ\")\n+    end\n+end\n+\n+function hyphen_interval(m::RegexMatch)\n+    @assert length(m.captures) == 6\n+    _lower_major, _lower_minor, _lower_patch, _upper_major, _upper_minor, _upper_patch = m.captures\n+    if isnothing(_lower_minor)\n+        lower_bound = VersionBound(parse(Int, _lower_major))\n+    elseif isnothing(_lower_patch)\n+        lower_bound = VersionBound(\n+            parse(Int, _lower_major),\n+            parse(Int, _lower_minor)\n+        )\n+    else\n+        lower_bound = VersionBound(\n+            parse(Int, _lower_major),\n+            parse(Int, _lower_minor),\n+            parse(Int, _lower_patch)\n+        )\n+    end\n+    if isnothing(_upper_minor)\n+        upper_bound = VersionBound(parse(Int, _upper_major))\n+    elseif isnothing(_upper_patch)\n+        upper_bound = VersionBound(\n+            parse(Int, _upper_major),\n+            parse(Int, _upper_minor)\n+        )\n+    else\n+        upper_bound = VersionBound(\n+            parse(Int, _upper_major),\n+            parse(Int, _upper_minor),\n+            parse(Int, _upper_patch)\n+        )\n+    end\n+    return VersionRange(lower_bound, upper_bound)\n+end\n+\n+const version = \"v?([0-9]+?)(?:\\\\.([0-9]+?))?(?:\\\\.([0-9]+?))?\"\n+const ver_regs =\n+    Pair{Regex, Any}[\n+    Regex(\"^([~^]?)?$version\\$\") => semver_interval, # 0.5 ^0.4 ~0.3.2\n+    Regex(\"^((?:\u2265\\\\s*)|(?:>=\\\\s*)|(?:=\\\\s*)|(?:<\\\\s*)|(?:=\\\\s*))v?$version\\$\") => inequality_interval, # < 0.2 >= 0.5,2\n+    Regex(\"^[\\\\s]*$version[\\\\s]*?\\\\s-\\\\s[\\\\s]*?$version[\\\\s]*\\$\") => hyphen_interval, # 0.7 - 1.3\n+]"
    },
    {
      "sha": "dd3658e555d2ada798de356beae5e96589d867b8",
      "filename": "doc/src/manual/code-loading.md",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/doc%2Fsrc%2Fmanual%2Fcode-loading.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/doc%2Fsrc%2Fmanual%2Fcode-loading.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fmanual%2Fcode-loading.md?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -438,6 +438,32 @@ Preferences in environments higher up in the environment stack get overridden by\n This allows depot-wide preference defaults to exist, with active projects able to merge or even completely overwrite these inherited preferences.\n See the docstring for `Preferences.set_preferences!()` for the full details of how to set preferences to allow or disallow merging.\n \n+### [Syntax Versioning](@id syntax-versioning)\n+\n+Syntax versioning allows packages to specify which version of Julia's syntax they use. In particular, different\n+packages can use different versions of the Julia syntax. This allows evolution of Julia's syntax in a non-breaking\n+way, while allowing packages to upgrade at their own pace. The syntax version is determined from the package's\n+corresponding Project.toml and propagates to all modules defined in the package.\n+\n+#### Syntax Version Determination\n+\n+The syntax version for a package is determined by the loading mechanism in the following order of precedence:\n+\n+1. If a `syntax.julia_version` field is present in the project file, it is used directly:\n+   ```toml\n+   name = \"MyPackage\"\n+   uuid = \"...\"\n+   syntax.julia_version = \"1.14\"\n+   ```\n+\n+2. Otherwise, if a `[compat]` section specifies a Julia version constraint, the minimum compatible version is used:\n+   ```toml\n+   [compat]\n+   julia = \"1.13-2\"  # implies syntax version 1.13.0\n+   ```\n+\n+3. If neither is specified, the current Julia version is used.\n+\n ## Conclusion\n \n Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage their projects without needing a precise understanding of these interactions. A call to `Pkg.add(\"X\")` will add to the appropriate project and manifest files, selected via `Pkg.activate(\"Y\")`, so that a future call to `import X` will load `X` without further thought."
    },
    {
      "sha": "d6e3893751c9f34e4c787fade4396311e91c7c9a",
      "filename": "src/ast.c",
      "status": "modified",
      "additions": 43,
      "deletions": 16,
      "changes": 59,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/src%2Fast.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/src%2Fast.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fast.c?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -1016,8 +1016,21 @@ static jl_value_t *jl_invoke_julia_macro(jl_array_t *args, jl_module_t *inmodule\n     margs[0] = jl_array_ptr_ref(args, 0);\n     // __source__ argument\n     jl_value_t *lno = jl_array_ptr_ref(args, 1);\n-    if (!jl_is_linenode(lno))\n+    jl_value_t *retry_lno = NULL;\n+    if (!jl_is_linenumbernode(lno)) {\n+        if (lno != jl_nothing) {\n+            // Special case: The magic @VERSION macro currently gets a special\n+            // Core.MacroSource for its __source__ argument. However, to avoid\n+            // giving this to macros that do not expect it, we check for that\n+            // special case and retry with just the LineNumberNode if needed.\n+            if (jl_typeof(lno) == jl_get_global(jl_core_module, jl_symbol(\"MacroSource\"))) {\n+                retry_lno = jl_fieldref_noalloc(lno, 0);\n+                goto lno_ok;\n+            }\n+        }\n         lno = jl_new_struct(jl_linenumbernode_type, jl_box_long(0), jl_nothing);\n+    }\n+lno_ok:\n     margs[1] = lno;\n     margs[2] = (jl_value_t*)inmodule;\n     for (i = 3; i < nargs; i++)\n@@ -1029,9 +1042,17 @@ static jl_value_t *jl_invoke_julia_macro(jl_array_t *args, jl_module_t *inmodule\n         ct->world_age = world;\n     jl_value_t *result;\n     JL_TRY {\n-        margs[0] = jl_toplevel_eval(*ctx, margs[0]);\n-        jl_method_instance_t *mfunc = jl_method_lookup(margs, nargs, ct->world_age);\n+        jl_module_t *ctx_module = *ctx;\n+        JL_GC_PROMISE_ROOTED(ctx_module);\n+        margs[0] = jl_toplevel_eval(ctx_module, margs[0]);\n+        jl_method_instance_t *mfunc = NULL;\n+        mfunc = jl_method_lookup(margs, nargs, ct->world_age);\n         JL_GC_PROMISE_ROOTED(mfunc);\n+        if (mfunc == NULL && retry_lno != NULL) {\n+            margs[1] = retry_lno;\n+            mfunc = jl_method_lookup(margs, nargs, ct->world_age);\n+            JL_GC_PROMISE_ROOTED(mfunc);\n+        }\n         if (mfunc == NULL) {\n             jl_method_error(margs[0], &margs[1], nargs, ct->world_age);\n             // unreachable\n@@ -1224,15 +1245,18 @@ JL_DLLEXPORT jl_value_t *jl_fl_lower(jl_value_t *expr, jl_module_t *inmodule,\n JL_DLLEXPORT jl_value_t *jl_lower(jl_value_t *expr, jl_module_t *inmodule,\n                                   const char *filename, int line, size_t world, bool_t warn)\n {\n-    jl_value_t *core_lower = NULL;\n-    if (jl_core_module)\n-        core_lower = jl_get_global_value(jl_core_module, jl_symbol(\"_lower\"), jl_current_task->world_age);\n-    if (!core_lower || core_lower == jl_nothing) {\n+    jl_value_t *julia_lower = NULL;\n+    if (inmodule) {\n+        julia_lower = jl_get_global(inmodule, jl_symbol(\"_internal_julia_lower\"));\n+    }\n+    if ((!julia_lower || julia_lower == jl_nothing) && jl_core_module)\n+        julia_lower = jl_get_global_value(jl_core_module, jl_symbol(\"_lower\"), jl_current_task->world_age);\n+    if (!julia_lower || julia_lower == jl_nothing) {\n         return jl_fl_lower(expr, inmodule, filename, line, world, warn);\n     }\n     jl_value_t **args;\n     JL_GC_PUSHARGS(args, 7);\n-    args[0] = core_lower;\n+    args[0] = julia_lower;\n     args[1] = expr;\n     args[2] = (jl_value_t*)inmodule;\n     args[3] = jl_cstr_to_string(filename);\n@@ -1288,20 +1312,23 @@ jl_code_info_t *jl_inner_ctor_body(jl_array_t *fieldkinds, jl_module_t *inmodule\n // `text` is passed as a pointer to allow raw non-String buffers to be used\n // without copying.\n jl_value_t *jl_parse(const char *text, size_t text_len, jl_value_t *filename,\n-                     size_t lineno, size_t offset, jl_value_t *options)\n+                     size_t lineno, size_t offset, jl_value_t *options, jl_module_t *inmodule)\n {\n-    jl_value_t *core_parse = NULL;\n-    if (jl_core_module) {\n-        core_parse = jl_get_global(jl_core_module, jl_symbol(\"_parse\"));\n+    jl_value_t *parser = NULL;\n+    if (inmodule) {\n+        parser = jl_get_global(inmodule, jl_symbol(\"_internal_julia_parse\"));\n+    }\n+    if ((!parser || parser == jl_nothing) && jl_core_module) {\n+        parser = jl_get_global(jl_core_module, jl_symbol(\"_parse\"));\n     }\n-    if (!core_parse || core_parse == jl_nothing) {\n+    if (!parser || parser == jl_nothing) {\n         // In bootstrap, directly call the builtin parser.\n         jl_value_t *result = jl_fl_parse(text, text_len, filename, lineno, offset, options);\n         return result;\n     }\n     jl_value_t **args;\n     JL_GC_PUSHARGS(args, 6);\n-    args[0] = core_parse;\n+    args[0] = parser;\n     args[1] = (jl_value_t*)jl_alloc_svec(2);\n     jl_svecset(args[1], 0, jl_box_uint8pointer((uint8_t*)text));\n     jl_svecset(args[1], 1, jl_box_long(text_len));\n@@ -1330,7 +1357,7 @@ JL_DLLEXPORT jl_value_t *jl_parse_all(const char *text, size_t text_len,\n {\n     jl_value_t *fname = jl_pchar_to_string(filename, filename_len);\n     JL_GC_PUSH1(&fname);\n-    jl_value_t *p = jl_parse(text, text_len, fname, lineno, 0, (jl_value_t*)jl_all_sym);\n+    jl_value_t *p = jl_parse(text, text_len, fname, lineno, 0, (jl_value_t*)jl_all_sym, NULL);\n     JL_GC_POP();\n     return jl_svecref(p, 0);\n }\n@@ -1343,7 +1370,7 @@ JL_DLLEXPORT jl_value_t *jl_parse_string(const char *text, size_t text_len,\n     jl_value_t *fname = jl_cstr_to_string(\"none\");\n     JL_GC_PUSH1(&fname);\n     jl_value_t *result = jl_parse(text, text_len, fname, 1, offset,\n-                                  (jl_value_t*)(greedy ? jl_statement_sym : jl_atom_sym));\n+                                  (jl_value_t*)(greedy ? jl_statement_sym : jl_atom_sym), NULL);\n     JL_GC_POP();\n     return result;\n }"
    },
    {
      "sha": "487486ce2996403113f62a62c9a4adad695ed4af",
      "filename": "src/julia_internal.h",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/src%2Fjulia_internal.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/src%2Fjulia_internal.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia_internal.h?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -932,6 +932,7 @@ STATIC_INLINE size_t module_usings_max(jl_module_t *m) JL_NOTSAFEPOINT {\n }\n \n JL_DLLEXPORT jl_sym_t *jl_module_name(jl_module_t *m) JL_NOTSAFEPOINT;\n+jl_module_t *jl_module_root(jl_module_t *m);\n void jl_add_scanned_method(jl_module_t *m, jl_method_t *meth);\n jl_value_t *jl_eval_global_var(jl_module_t *m JL_PROPAGATES_ROOT, jl_sym_t *e, size_t world);\n JL_DLLEXPORT jl_value_t *jl_eval_globalref(jl_globalref_t *g, size_t world);\n@@ -1366,7 +1367,7 @@ jl_tupletype_t *arg_type_tuple(jl_value_t *arg1, jl_value_t **args, size_t nargs\n JL_DLLEXPORT int jl_has_meta(jl_array_t *body, jl_sym_t *sym) JL_NOTSAFEPOINT;\n \n JL_DLLEXPORT jl_value_t *jl_parse(const char *text, size_t text_len, jl_value_t *filename,\n-                                  size_t lineno, size_t offset, jl_value_t *options);\n+                                  size_t lineno, size_t offset, jl_value_t *options, jl_module_t *inmodule);\n jl_code_info_t *jl_inner_ctor_body(jl_array_t *fieldkinds, jl_module_t *inmodule, const char *file, int line);\n jl_code_info_t *jl_outer_ctor_body(jl_value_t *thistype, size_t nfields, size_t nsparams, jl_module_t *inmodule, const char *file, int line);\n void jl_ctor_def(jl_value_t *ty, jl_value_t *functionloc);"
    },
    {
      "sha": "ee8fa97b7be36bd2760d14dbe5bdf0f76adefae4",
      "filename": "src/staticdata.c",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/src%2Fstaticdata.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/src%2Fstaticdata.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fstaticdata.c?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -3304,10 +3304,25 @@ static int ci_not_internal_cache(jl_code_instance_t *ci)\n     return !(jl_atomic_load_relaxed(&ci->flags) & JL_CI_FLAGS_NATIVE_CACHE_VALID) || jl_object_in_image(mi->def.value);\n }\n \n+static uint8_t jl_get_toplevel_syntax_version(void)\n+{\n+    jl_task_t *ct = jl_current_task;\n+    jl_module_t *toplevel = (jl_module_t*)jl_get_global_value(jl_base_module, jl_symbol(\"__toplevel__\"), ct->world_age);\n+    JL_GC_PROMISE_ROOTED(toplevel);\n+    jl_value_t *syntax_version = jl_get_global_value(toplevel, jl_symbol(\"_internal_syntax_version\"), ct->world_age);\n+    return jl_unbox_uint8(syntax_version);\n+}\n+\n static void jl_write_header_for_incremental(ios_t *f, jl_array_t *worklist, jl_array_t *mod_array, jl_array_t **udeps, int64_t *srctextpos, int64_t *checksumpos)\n {\n     *checksumpos = write_header(f, 0);\n     write_uint8(f, jl_cache_flags());\n+    // write the syntax version marker. Note that unlike a VersionNumber, this is\n+    // private to the serialization format and only needs to be reloaded by the\n+    // same version of Julia that wrote it. As a result, we don't store the full\n+    // VersionNumber, only an index of which of the supported syntax versions to\n+    // select.\n+    write_uint8(f, jl_get_toplevel_syntax_version());\n     // write description of contents (name, uuid, buildid)\n     write_worklist_for_header(f, worklist);\n     // Determine unique (module, abspath, fsize, hash, mtime) dependencies for the files defining modules in the worklist\n@@ -3359,6 +3374,7 @@ JL_DLLEXPORT void jl_create_system_image(void **_native_data, jl_array_t *workli\n         if (emit_split) {\n             checksumpos_ff = write_header(ff, 1);\n             write_uint8(ff, jl_cache_flags());\n+            write_uint8(ff, jl_get_toplevel_syntax_version());\n             write_mod_list(ff, mod_array);\n         }\n         else {\n@@ -4305,6 +4321,8 @@ static jl_value_t *jl_validate_cache_file(ios_t *f, jl_array_t *depmods, uint64_\n     if (pkgimage && !jl_match_cache_flags_current(flags)) {\n         return jl_get_exceptionf(jl_errorexception_type, \"Pkgimage flags mismatch\");\n     }\n+    // Syntax version mismatch is not fatal to load\n+    (void)read_uint8(f); // syntax_version\n     if (!pkgimage) {\n         // skip past the worklist\n         size_t len;"
    },
    {
      "sha": "16ebcd4b4ee125e3552c35efb23d7e384c01a418",
      "filename": "src/staticdata_utils.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/src%2Fstaticdata_utils.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/src%2Fstaticdata_utils.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fstaticdata_utils.c?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -652,7 +652,7 @@ static const char *jl_git_commit(void)\n \n \n // \"magic\" string and version header of .ji file\n-static const int JI_FORMAT_VERSION = 12;\n+static const int JI_FORMAT_VERSION = 13;\n static const char JI_MAGIC[] = \"\\373jli\\r\\n\\032\\n\"; // based on PNG signature\n static const uint16_t BOM = 0xFEFF; // byte-order marker\n static int64_t write_header(ios_t *s, uint8_t pkgimage)"
    },
    {
      "sha": "dd37bca3f5c359221808621a29a883667bef175c",
      "filename": "src/timing.c",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/src%2Ftiming.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/src%2Ftiming.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Ftiming.c?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -10,8 +10,6 @@\n #define DISABLE_FREQUENT_EVENTS\n #endif\n \n-jl_module_t *jl_module_root(jl_module_t *m);\n-\n #ifdef __cplusplus\n extern \"C\" {\n #endif"
    },
    {
      "sha": "b78ad6ec46b3cd80028631a67d08048bda9d04cf",
      "filename": "src/toplevel.c",
      "status": "modified",
      "additions": 36,
      "deletions": 21,
      "changes": 57,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/src%2Ftoplevel.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/src%2Ftoplevel.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Ftoplevel.c?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -111,7 +111,25 @@ static int jl_is__toplevel__mod(jl_module_t *mod, jl_task_t *ct)\n         (jl_value_t*)mod == jl_get_global_value(jl_base_module, jl_symbol(\"__toplevel__\"), ct->world_age);\n }\n \n-JL_DLLEXPORT jl_module_t *jl_begin_new_module(jl_module_t *parent_module, jl_sym_t *name,\n+JL_DLLEXPORT void jl_setup_new_module(jl_module_t *m, jl_value_t *syntax_version)\n+{\n+    jl_task_t *ct = jl_current_task;\n+    size_t last_age = ct->world_age;\n+    ct->world_age = jl_atomic_load_acquire(&jl_world_counter);\n+    jl_value_t *f = jl_get_global_value(jl_base_module, jl_symbol(\"_setup_module!\"), ct->world_age);\n+    if (f != NULL) {\n+        jl_value_t **fargs;\n+        JL_GC_PUSHARGS(fargs, 3);\n+        fargs[0] = f;\n+        fargs[1] = (jl_value_t*)m;\n+        fargs[2] = syntax_version;\n+        jl_apply(fargs, 3);\n+        JL_GC_POP();\n+    }\n+    ct->world_age = last_age;\n+}\n+\n+JL_DLLEXPORT jl_module_t *jl_begin_new_module(jl_module_t *parent_module, jl_sym_t *name, jl_value_t *syntax_version,\n                                               int std_imports, const char *filename, int lineno)\n {\n     jl_task_t *ct = jl_current_task;\n@@ -133,17 +151,7 @@ JL_DLLEXPORT jl_module_t *jl_begin_new_module(jl_module_t *parent_module, jl_sym\n \n     // add standard imports unless baremodule\n     if (std_imports && jl_base_module != NULL) {\n-        jl_module_t *base = jl_add_standard_imports(newm);\n-        jl_datatype_t *include_into = (jl_datatype_t *)jl_get_global(base, jl_symbol(\"IncludeInto\"));\n-        if (include_into) {\n-            form = jl_new_struct(include_into, newm);\n-            jl_set_initial_const(newm, jl_symbol(\"include\"), form, 0);\n-        }\n-        jl_datatype_t *eval_into = (jl_datatype_t *)jl_get_global(jl_core_module, jl_symbol(\"EvalInto\"));\n-        if (eval_into) {\n-            form = jl_new_struct(eval_into, newm);\n-            jl_set_initial_const(newm, jl_symbol(\"eval\"), form, 0);\n-        }\n+        jl_setup_new_module(newm, syntax_version);\n     }\n \n     if (parent_module == jl_main_module && name == jl_symbol(\"Base\") && jl_base_module == NULL) {\n@@ -216,21 +224,28 @@ JL_DLLEXPORT void jl_end_new_module(jl_module_t *newm) {\n static jl_value_t *jl_eval_module_expr(jl_module_t *parent_module, jl_expr_t *ex, const char **toplevel_filename, int *toplevel_lineno)\n {\n     assert(ex->head == jl_module_sym);\n-    if (jl_array_nrows(ex->args) != 3 || !jl_is_expr(jl_exprarg(ex, 2))) {\n-        jl_error(\"syntax: malformed module expression\");\n+\n+    jl_value_t *syntax_version = jl_nothing;\n+    int idx = 0;\n+    if (!jl_is_bool(jl_exprarg(ex, idx))) {\n+        syntax_version = jl_exprarg(ex, idx++);\n     }\n \n-    if (((jl_expr_t *)(jl_exprarg(ex, 2)))->head != jl_symbol(\"block\")) {\n-        jl_error(\"syntax: module expression third argument must be a block\");\n+    if (jl_array_nrows(ex->args) != idx+3 || !jl_is_expr(jl_exprarg(ex, idx+2))) {\n+        jl_error(\"syntax: malformed module expression\");\n     }\n-    jl_array_t *stmts = ((jl_expr_t*)jl_exprarg(ex, 2))->args;\n \n-    int std_imports = (jl_exprarg(ex, 0) == jl_true);\n-    jl_sym_t *name = (jl_sym_t*)jl_exprarg(ex, 1);\n+    int std_imports = (jl_exprarg(ex, idx++) == jl_true);\n+    jl_sym_t *name = (jl_sym_t*)jl_exprarg(ex, idx++);\n     if (!jl_is_symbol(name)) {\n         jl_type_error(\"module\", (jl_value_t*)jl_symbol_type, (jl_value_t*)name);\n     }\n \n+    if (((jl_expr_t *)(jl_exprarg(ex, idx)))->head != jl_symbol(\"block\")) {\n+        jl_error(\"syntax: module expression third argument must be a block\");\n+    }\n+    jl_array_t *stmts = ((jl_expr_t*)jl_exprarg(ex, idx))->args;\n+\n     int lineno = 0;\n     const char *filename = \"none\";\n     if (jl_array_nrows(stmts) > 0) {\n@@ -243,7 +258,7 @@ static jl_value_t *jl_eval_module_expr(jl_module_t *parent_module, jl_expr_t *ex\n         }\n     }\n \n-    jl_module_t *newm = jl_begin_new_module(parent_module, name, std_imports, filename, lineno);\n+    jl_module_t *newm = jl_begin_new_module(parent_module, name, syntax_version, std_imports, filename, lineno);\n     JL_GC_PROMISE_ROOTED(newm); // Rooted in jl_current_modules\n     jl_eval_toplevel_stmts(newm, stmts, 1, 0, toplevel_filename, toplevel_lineno);\n     jl_end_new_module(newm);\n@@ -830,7 +845,7 @@ static jl_value_t *jl_parse_eval_all(jl_module_t *module, jl_value_t *text,\n     JL_GC_PUSH3(&ast, &result, &expression);\n \n     ast = jl_svecref(jl_parse(jl_string_data(text), jl_string_len(text),\n-                              filename, 1, 0, (jl_value_t*)jl_all_sym), 0);\n+                              filename, 1, 0, (jl_value_t*)jl_all_sym, module), 0);\n     if (!jl_is_expr(ast) || ((jl_expr_t*)ast)->head != jl_toplevel_sym) {\n         jl_errorf(\"jl_parse_all() must generate a top level expression\");\n     }"
    },
    {
      "sha": "0c31315e9bea1177a9998e88173fb6b706d56b40",
      "filename": "stdlib/REPL/src/REPL.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPL.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -740,7 +740,7 @@ function run_frontend(repl::BasicREPL, backend::REPLBackendRef)\n                     rethrow()\n                 end\n             end\n-            ast = Base.parse_input_line(line)\n+            ast = Base.parse_input_line(line; mod=Base.active_module(repl))\n             (isa(ast,Expr) && ast.head === :incomplete) || break\n         end\n         if !isempty(line)\n@@ -814,7 +814,8 @@ REPLCompletionProvider() = REPLCompletionProvider(LineEdit.Modifiers())\n mutable struct ShellCompletionProvider <: CompletionProvider end\n struct LatexCompletions <: CompletionProvider end\n \n-Base.active_module((; mistate)::LineEditREPL) = mistate === nothing ? Main : mistate.active_module\n+Base.active_module(mistate::MIState) = mistate.active_module\n+Base.active_module((; mistate)::LineEditREPL) = mistate === nothing ? Main : Base.active_module(mistate)\n Base.active_module(::AbstractREPL) = Main\n Base.active_module(d::REPLDisplay) = Base.active_module(d.repl)\n \n@@ -1117,7 +1118,7 @@ end\n LineEdit.reset_state(hist::REPLHistoryProvider) = history_reset_state(hist)\n \n function return_callback(s)\n-    ast = Base.parse_input_line(takestring!(copy(LineEdit.buffer(s))), depwarn=false)\n+    ast = Base.parse_input_line(takestring!(copy(LineEdit.buffer(s))); mod=Base.active_module(s), depwarn=false)\n     return !(isa(ast, Expr) && ast.head === :incomplete)\n end\n \n@@ -1290,7 +1291,7 @@ function setup_interface(\n         repl = repl,\n         complete = replc,\n         # When we're done transform the entered line into a call to helpmode function\n-        on_done = respond(line::String->helpmode(outstream(repl), line, repl.mistate.active_module),\n+        on_done = respond(line::String->helpmode(outstream(repl), line, Base.active_module(repl)),\n                           repl, julia_prompt, pass_empty=true, suppress_on_semicolon=false))\n \n \n@@ -1371,7 +1372,7 @@ function setup_interface(\n     help_mode.hist = hp\n     dummy_pkg_mode.hist = hp\n \n-    julia_prompt.on_done = respond(x->Base.parse_input_line(x,filename=repl_filename(repl,hp)), repl, julia_prompt)\n+    julia_prompt.on_done = respond(x->Base.parse_input_line(x; filename=repl_filename(repl,hp), mod=Base.active_module(repl)), repl, julia_prompt)\n \n     shell_prompt_len = length(SHELL_PROMPT)\n     help_prompt_len = length(HELP_PROMPT)\n@@ -1535,7 +1536,7 @@ function setup_interface(\n                 dump_tail = false\n                 nl_pos = findfirst('\\n', input[oldpos:end])\n                 if s.current_mode == julia_prompt\n-                    ast, pos = Meta.parse(input, oldpos, raise=false, depwarn=false)\n+                    ast, pos = Meta.parse(input, oldpos, raise=false, depwarn=false, mod=Base.active_module(s))\n                     if (isa(ast, Expr) && (ast.head === :error || ast.head === :incomplete)) ||\n                             (pos > ncodeunits(input) && !endswith(input, '\\n'))\n                         # remaining text is incomplete (an error, or parser ran to the end but didn't stop with a newline):\n@@ -1791,7 +1792,7 @@ function run_frontend(repl::StreamREPL, backend::REPLBackendRef)\n         end\n         line = readline(repl.stream, keep=true)\n         if !isempty(line)\n-            ast = Base.parse_input_line(line)\n+            ast = Base.parse_input_line(line; mod=Base.active_module(repl))\n             if have_color\n                 print(repl.stream, Base.color_normal)\n             end"
    },
    {
      "sha": "b2b510e8e1e10db76c19e2334aad2d48244eb73b",
      "filename": "stdlib/REPL/src/REPLCompletions.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -993,6 +993,7 @@ end\n \n function completions(string::String, pos::Int, context_module::Module=Main, shift::Bool=true, hint::Bool=false)\n     # filename needs to be string so macro can be evaluated\n+    # TODO: JuliaSyntax version API here\n     node = parseall(CursorNode, string, ignore_errors=true, keep_parens=true, filename=\"none\")\n     cur = @something seek_pos(node, pos) node\n "
    },
    {
      "sha": "23d40cf21be307016d282cce52be6ec8f9f48b8b",
      "filename": "test/loading.jl",
      "status": "modified",
      "additions": 39,
      "deletions": 2,
      "changes": 41,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Floading.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -1840,8 +1840,8 @@ end\n         Base64_key = Base.PkgId(Base.UUID(\"2a0f44e3-6c83-55bd-87e4-b1978d98bd5f\"), \"Base64\")\n         oldBase64 = Base.unreference_module(Base64_key)\n         cc = Base.compilecache(Base64_key)\n-        sourcepath = Base.locate_package(Base64_key)\n-        @test Base.stale_cachefile(Base64_key, UInt128(0), sourcepath, cc[1]) !== true\n+        sourcespec = Base.locate_package_load_spec(Base64_key)\n+        @test Base.stale_cachefile(Base64_key, UInt128(0), sourcespec, cc[1]) !== true\n         empty!(DEPOT_PATH)\n         Base.require_stdlib(Base64_key)\n         push!(DEPOT_PATH, depot_path)\n@@ -1878,3 +1878,40 @@ end\n module M58272_to end\n @eval M58272_to import ..M58272_1: M58272_2.y, x\n @test @eval M58272_to x === 1\n+\n+@testset \"Syntax Versioning\" begin\n+    old_load_path = copy(LOAD_PATH)\n+    try\n+        # Test implicit environments (packages loaded from directories)\n+        push!(LOAD_PATH, joinpath(@__DIR__, \"project\", \"SyntaxVersioning\", \"implicit\"))\n+        # Explicit syntax.julia_version = \"1.13\"\n+        @test invokelatest(getglobal, (@eval (using Versioned1; Versioned1)), :ver) == v\"1.13\"\n+        # Explicit syntax.julia_version = \"1.14\"\n+        @test invokelatest(getglobal, (@eval (using Versioned2; Versioned2)), :ver) == v\"1.14\"\n+        # Inherited from compat.julia = \"1.13-2\"\n+        @test invokelatest(getglobal, (@eval (using Versioned3; Versioned3)), :ver) == v\"1.13\"\n+        # No syntax.julia_version, falls back to current VERSION\n+        @test invokelatest(getglobal, (@eval (using Versioned4; Versioned4)), :ver) == VersionNumber(VERSION.major, VERSION.minor)\n+        # Inherited from compat.julia = \"1.14-2\"\n+        @test invokelatest(getglobal, (@eval (using Versioned5; Versioned5)), :ver) == v\"1.14\"\n+    finally\n+        copy!(LOAD_PATH, old_load_path)\n+    end\n+\n+    # Test explicit environments (packages loaded from Manifest.toml)\n+    old_load_path = copy(LOAD_PATH)\n+    old_active_project = Base.ACTIVE_PROJECT[]\n+    try\n+        explicit_env = joinpath(@__DIR__, \"project\", \"SyntaxVersioning\", \"explicit\")\n+        Base.ACTIVE_PROJECT[] = joinpath(explicit_env, \"Project.toml\")\n+        empty!(LOAD_PATH)\n+        push!(LOAD_PATH, \"@\")\n+        # syntax.julia_version from Manifest = \"1.13\"\n+        @test invokelatest(getglobal, (@eval (using VersionedDep1; VersionedDep1)), :ver) == v\"1.13\"\n+        # syntax.julia_version from Manifest = \"1.14\"\n+        @test invokelatest(getglobal, (@eval (using VersionedDep2; VersionedDep2)), :ver) == v\"1.14\"\n+    finally\n+        Base.ACTIVE_PROJECT[] = old_active_project\n+        copy!(LOAD_PATH, old_load_path)\n+    end\n+end"
    },
    {
      "sha": "23fdf14c0ddc9506547ce5253b46b4d8b696c2ea",
      "filename": "test/project/SyntaxVersioning/explicit/Manifest.toml",
      "status": "added",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FManifest.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FManifest.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FManifest.toml?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,14 @@\n+# This file is machine-generated - editing it directly is not advised\n+\n+julia_version = \"1.14.0-DEV\"\n+manifest_format = \"2.1\"\n+\n+[[deps.VersionedDep1]]\n+path = \"VersionedDep1\"\n+uuid = \"f08855a0-36cb-4a32-8ae5-a227b709c612\"\n+syntax.julia_version = \"1.13.0\"\n+\n+[[deps.VersionedDep2]]\n+path = \"VersionedDep2\"\n+uuid = \"e127e659-a899-4a00-b565-5b74face18ba\"\n+syntax.julia_version = \"1.14.0\""
    },
    {
      "sha": "d5cfbb156a3a7f321f15e4f09de224ff42b49113",
      "filename": "test/project/SyntaxVersioning/explicit/Project.toml",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FProject.toml?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+[deps]\n+VersionedDep1 = \"f08855a0-36cb-4a32-8ae5-a227b709c612\"\n+VersionedDep2 = \"e127e659-a899-4a00-b565-5b74face18ba\""
    },
    {
      "sha": "0b35c64ade6c97851d7b00ac3cf45a708dbb5ea1",
      "filename": "test/project/SyntaxVersioning/explicit/VersionedDep1/Project.toml",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep1%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep1%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep1%2FProject.toml?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+name = \"VersionedDep1\"\n+uuid = \"f08855a0-36cb-4a32-8ae5-a227b709c612\"\n+syntax.julia_version = \"1.13\""
    },
    {
      "sha": "6154c45f97ee279cbfeaafbd97b7d9733b171d01",
      "filename": "test/project/SyntaxVersioning/explicit/VersionedDep1/src/VersionedDep1.jl",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep1%2Fsrc%2FVersionedDep1.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep1%2Fsrc%2FVersionedDep1.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep1%2Fsrc%2FVersionedDep1.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+module VersionedDep1\n+    const ver = (@Base.Experimental.VERSION).syntax\n+end"
    },
    {
      "sha": "2876fa5f51e556ee79b133de4f2db0b12acc2db0",
      "filename": "test/project/SyntaxVersioning/explicit/VersionedDep2/Project.toml",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep2%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep2%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep2%2FProject.toml?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+name = \"VersionedDep2\"\n+uuid = \"e127e659-a899-4a00-b565-5b74face18ba\"\n+syntax.julia_version = \"1.14\""
    },
    {
      "sha": "f3bf4197e66c15ad2ab929a4034c43dae58e24a6",
      "filename": "test/project/SyntaxVersioning/explicit/VersionedDep2/src/VersionedDep2.jl",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep2%2Fsrc%2FVersionedDep2.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep2%2Fsrc%2FVersionedDep2.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fexplicit%2FVersionedDep2%2Fsrc%2FVersionedDep2.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+module VersionedDep2\n+    const ver = (@Base.Experimental.VERSION).syntax\n+end"
    },
    {
      "sha": "30d8e2686b73f214f673e536d3602d81d0e33949",
      "filename": "test/project/SyntaxVersioning/implicit/Versioned1/Project.toml",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned1%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned1%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned1%2FProject.toml?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+name = \"Versioned1\"\n+uuid = \"5039f352-f8db-42c3-a2c5-1d61ed1e55b8\"\n+syntax.julia_version = \"1.13\""
    },
    {
      "sha": "0622ad832c31e3b7b2161e78b5801e2ebb2f8371",
      "filename": "test/project/SyntaxVersioning/implicit/Versioned1/src/Versioned1.jl",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned1%2Fsrc%2FVersioned1.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned1%2Fsrc%2FVersioned1.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned1%2Fsrc%2FVersioned1.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+module Versioned1\n+    const ver = (@Base.Experimental.VERSION).syntax\n+end"
    },
    {
      "sha": "576b6a53d083fef8bb24fdb5bf74102480801ae8",
      "filename": "test/project/SyntaxVersioning/implicit/Versioned2/Project.toml",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned2%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned2%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned2%2FProject.toml?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+name = \"Versioned2\"\n+uuid = \"3a4c0187-8e98-47c1-abc0-783d1a175621\"\n+syntax.julia_version = \"1.14\""
    },
    {
      "sha": "0cf90ce3dabde1716a0dd84ad897156abf6cefec",
      "filename": "test/project/SyntaxVersioning/implicit/Versioned2/src/Versioned2.jl",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned2%2Fsrc%2FVersioned2.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned2%2Fsrc%2FVersioned2.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned2%2Fsrc%2FVersioned2.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+module Versioned2\n+    const ver = (@Base.Experimental.VERSION).syntax\n+end"
    },
    {
      "sha": "3522ebf04a699f814797966f03079e4a8aa6a392",
      "filename": "test/project/SyntaxVersioning/implicit/Versioned3/Project.toml",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned3%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned3%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned3%2FProject.toml?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,5 @@\n+name = \"Versioned3\"\n+uuid = \"06d511b3-69b4-4d20-8d3b-d39263331254\"\n+\n+[compat]\n+julia = \"1.13 - 2\""
    },
    {
      "sha": "72ba851940b88883ca13832f4dca1999bcce00c9",
      "filename": "test/project/SyntaxVersioning/implicit/Versioned3/src/Versioned3.jl",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned3%2Fsrc%2FVersioned3.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned3%2Fsrc%2FVersioned3.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned3%2Fsrc%2FVersioned3.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+module Versioned3\n+    const ver = (@Base.Experimental.VERSION).syntax\n+end"
    },
    {
      "sha": "0bfee425a3cb72d3b14d0becee669fd9ee3183d8",
      "filename": "test/project/SyntaxVersioning/implicit/Versioned4/Project.toml",
      "status": "added",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned4%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned4%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned4%2FProject.toml?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,2 @@\n+name = \"Versioned4\"\n+uuid = \"3a4c0187-8e98-47c1-abc0-783d1a175621\""
    },
    {
      "sha": "837e942386fc3399fb7eafa2b832be62ec1c57c2",
      "filename": "test/project/SyntaxVersioning/implicit/Versioned4/src/Versioned4.jl",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned4%2Fsrc%2FVersioned4.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned4%2Fsrc%2FVersioned4.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned4%2Fsrc%2FVersioned4.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+module Versioned4\n+    const ver = (@Base.Experimental.VERSION).syntax\n+end"
    },
    {
      "sha": "f17617f42ce7222974c30613fc550ad53210d2f8",
      "filename": "test/project/SyntaxVersioning/implicit/Versioned5/Project.toml",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned5%2FProject.toml",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned5%2FProject.toml",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned5%2FProject.toml?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,5 @@\n+name = \"Versioned5\"\n+uuid = \"1805a4d1-8cc9-402d-b9fb-3f94ad9a89b5\"\n+\n+[compat]\n+julia = \"1.14 - 2\""
    },
    {
      "sha": "43a6dbd102291fa55350c2d6c7ec5de8915ced21",
      "filename": "test/project/SyntaxVersioning/implicit/Versioned5/src/Versioned5.jl",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned5%2Fsrc%2FVersioned5.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/4840ac9411e87761f71912dfef1327cb28eab383/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned5%2Fsrc%2FVersioned5.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fproject%2FSyntaxVersioning%2Fimplicit%2FVersioned5%2Fsrc%2FVersioned5.jl?ref=4840ac9411e87761f71912dfef1327cb28eab383",
      "patch": "@@ -0,0 +1,3 @@\n+module Versioned5\n+    const ver = (@Base.Experimental.VERSION).syntax\n+end"
    }
  ]
}