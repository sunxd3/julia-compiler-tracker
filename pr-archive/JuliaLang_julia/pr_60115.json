{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60115",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60115/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60115/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60115/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60115",
  "id": 3618750456,
  "node_id": "PR_kwDOABkWpM6zGSQw",
  "number": 60115,
  "title": "document metrics from GC_Num; rename one metric from GC_Num to match the name used by the equivalent C struct",
  "user": {
    "login": "d-netto",
    "id": 61364108,
    "node_id": "MDQ6VXNlcjYxMzY0MTA4",
    "avatar_url": "https://avatars.githubusercontent.com/u/61364108?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/d-netto",
    "html_url": "https://github.com/d-netto",
    "followers_url": "https://api.github.com/users/d-netto/followers",
    "following_url": "https://api.github.com/users/d-netto/following{/other_user}",
    "gists_url": "https://api.github.com/users/d-netto/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/d-netto/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/d-netto/subscriptions",
    "organizations_url": "https://api.github.com/users/d-netto/orgs",
    "repos_url": "https://api.github.com/users/d-netto/repos",
    "events_url": "https://api.github.com/users/d-netto/events{/privacy}",
    "received_events_url": "https://api.github.com/users/d-netto/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 195227131,
      "node_id": "MDU6TGFiZWwxOTUyMjcxMzE=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/GC",
      "name": "GC",
      "color": "2CD3F0",
      "default": false,
      "description": "Garbage collector"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 4,
  "created_at": "2025-11-13T00:15:02Z",
  "updated_at": "2025-11-14T22:33:31Z",
  "closed_at": "2025-11-14T22:33:29Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60115",
    "html_url": "https://github.com/JuliaLang/julia/pull/60115",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60115.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60115.patch",
    "merged_at": "2025-11-14T22:33:29Z"
  },
  "body": "See PR title. I plan to clean up the GC metrics code a bit more in subsequent PRs.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60115/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60115/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "d4c219049fd3d9bc69f82d59fc6650a745eb593e",
      "filename": "base/timing.jl",
      "status": "modified",
      "additions": 69,
      "deletions": 28,
      "changes": 97,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9f595ebbf8edd9a94dcc07549cf1ad1f33c4c52d/base%2Ftiming.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9f595ebbf8edd9a94dcc07549cf1ad1f33c4c52d/base%2Ftiming.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Ftiming.jl?ref=9f595ebbf8edd9a94dcc07549cf1ad1f33c4c52d",
      "patch": "@@ -2,35 +2,76 @@\n \n # This type must be kept in sync with the C struct in src/gc-interface.h\n struct GC_Num\n-    allocd          ::Int64 # GC internal\n-    deferred_alloc  ::Int64 # GC internal\n-    freed           ::Int64 # GC internal\n-    malloc          ::Int64\n-    realloc         ::Int64\n-    poolalloc       ::Int64\n-    bigalloc        ::Int64\n-    freecall        ::Int64\n-    total_time      ::Int64\n-    total_allocd    ::Int64 # GC internal\n-    collect         ::Csize_t # GC internal\n-    pause           ::Cint\n-    full_sweep      ::Cint\n-    max_pause       ::Int64\n-    max_memory      ::Int64\n-    time_to_safepoint           ::Int64\n-    max_time_to_safepoint       ::Int64\n-    total_time_to_safepoint     ::Int64\n-    sweep_time      ::Int64\n-    mark_time       ::Int64\n-    stack_pool_sweep_time ::Int64\n-    total_sweep_time  ::Int64\n-    total_sweep_page_walk_time              ::Int64\n-    total_sweep_madvise_time                ::Int64\n-    total_sweep_free_mallocd_memory_time    ::Int64\n-    total_mark_time   ::Int64\n+    # (GC Internal) Number of allocated bytes since the last collection. This field is reset\n+    # after the end of every garbage collection cycle, so it will always be zero if observed\n+    # during execution of Julia user code\n+    allocd::Int64\n+    # (GC Internal) Number of allocated bytes within a `gc_disable/gc_enable` block. This field is\n+    # reset after every garbage collection cycle and will always be zero in case of no use\n+    # of `gc_disable/gc_enable` blocks\n+    deferred_alloc::Int64\n+    # (GC Internal) Number of bytes freed bytes in the current collection cycle. This field is\n+    # reset after every garbage collection cycle and will always be zero when observed\n+    # during execution of Julia user code. It's incremented as memory is reclaimed during a collection,\n+    # used to gather some statistics within the collection itself and reset at the end of a GC cycle.\n+    freed::Int64\n+    # Number of `malloc/calloc` calls (never reset by the runtime)\n+    malloc::Int64\n+    # Number of `realloc` calls (never reset by the runtime)\n+    realloc::Int64\n+    # Number of pool allocation calls (never reset by the runtime)\n+    # NOTE: Julia's stock GC uses an internal (pool) allocator for objects up to 2032 bytes.\n+    # Larger objects are allocated through `malloc/calloc`.\n+    poolalloc::Int64\n+    # Number of allocations for \"big objects\" (non-array objects larger than 2032 bytes)\n+    # (never reset by the runtime)\n+    bigalloc::Int64\n+    # Number of `free` calls (never reset by the runtime)\n+    freecall::Int64\n+    # Total time spent in garbage collection (never reset by the runtime)\n+    total_time::Int64\n+    # (GC internal) Total number of bytes allocated since the program started\n+    total_allocd::Int64\n+    # (GC internal) Per-thread allocation quota before triggering a GC\n+    # NOTE: This field is no longer used by the heuristics in the stock GC\n+    interval::Csize_t\n+    # Duration of the last GC pause in nanoseconds\n+    pause::Cint\n+    # Number of full GC sweeps completed so far (never reset by the runtime)\n+    full_sweep::Cint\n+    # Maximum pause duration observed so far in nanoseconds\n+    max_pause::Int64\n+    # Maximum number of bytes allocated any point in time.\n+    # NOTE: This is aggregated over objects, not pages\n+    max_memory::Int64\n+    # Time taken to reach a safepoint in the last GC cycle in nanoseconds\n+    time_to_safepoint::Int64\n+    # Maximum time taken to reach a safepoint across all GCs in nanoseconds\n+    max_time_to_safepoint::Int64\n+    # Total time taken to reach safepoints across all GCs in nanoseconds\n+    total_time_to_safepoint::Int64\n+    # Time spent in the last GC sweeping phase in nanoseconds\n+    sweep_time::Int64\n+    # Time spent in the last GC marking phase in nanoseconds\n+    mark_time::Int64\n+    # Time spent sweeping stack pools in the last GC in nanoseconds\n+    stack_pool_sweep_time::Int64\n+    # Total time spent in sweeping phase across all GCs in nanoseconds\n+    total_sweep_time::Int64\n+    # Total time spent walking pool allocated pages during sweeping phase across all GCs in nanoseconds\n+    total_sweep_page_walk_time::Int64\n+    # Total time spent in madvise calls during sweeping phase across all GCs in nanoseconds\n+    total_sweep_madvise_time::Int64\n+    # Total time spent in freeing malloc'd memory during sweeping phase across all GCs in nanoseconds\n+    total_sweep_free_mallocd_memory_time::Int64\n+    # Total time spent in marking phase across all GCs in nanoseconds\n+    total_mark_time::Int64\n+    # Total time spent sweeping stack pools across all GCs in nanoseconds\n     total_stack_pool_sweep_time::Int64\n-    last_full_sweep ::Int64\n-    last_incremental_sweep ::Int64\n+    # Timestamp of the last full GC sweep in nanoseconds\n+    last_full_sweep::Int64\n+    # Timestamp of the last incremental GC sweep in nanoseconds\n+    last_incremental_sweep::Int64\n end\n \n gc_num() = ccall(:jl_gc_num, GC_Num, ())"
    },
    {
      "sha": "7905270b91795d5b5facbdce48e6e2097cee3060",
      "filename": "src/gc-interface.h",
      "status": "modified",
      "additions": 44,
      "deletions": 3,
      "changes": 47,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9f595ebbf8edd9a94dcc07549cf1ad1f33c4c52d/src%2Fgc-interface.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9f595ebbf8edd9a94dcc07549cf1ad1f33c4c52d/src%2Fgc-interface.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fgc-interface.h?ref=9f595ebbf8edd9a94dcc07549cf1ad1f33c4c52d",
      "patch": "@@ -26,34 +26,75 @@ struct _jl_genericmemory_t;\n \n // This struct must be kept in sync with the Julia type of the same name in base/timing.jl\n typedef struct {\n+    // (GC Internal) Number of allocated bytes since the last collection. This field is reset\n+    // after the end of every garbage collection cycle, so it will always be zero if observed\n+    // during execution of Julia user code\n     int64_t allocd;\n+    // (GC Internal) Number of allocated bytes within a `gc_disable/gc_enable` block. This field is\n+    // reset after every garbage collection cycle and will always be zero in case of no use\n+    // of `gc_disable/gc_enable` blocks\n     int64_t deferred_alloc;\n+    // (GC Internal) Number of bytes freed bytes in the current collection cycle. This field is\n+    // reset after every garbage collection cycle and will always be zero when observed\n+    // during execution of Julia user code. It's incremented as memory is reclaimed during a collection,\n+    // used to gather some statistics within the collection itself and reset at the end of a GC cycle.\n     int64_t freed;\n+    // Number of `malloc/calloc` calls (never reset by the runtime)\n     uint64_t malloc;\n+    // Number of `realloc` calls (never reset by the runtime)\n     uint64_t realloc;\n+    // Number of pool allocation calls (never reset by the runtime)\n+    // NOTE: Julia's stock GC uses an internal (pool) allocator for objects up to 2032 bytes.\n+    // Larger objects are allocated through `malloc/calloc`.\n     uint64_t poolalloc;\n+    // Number of allocations for \"big objects\" (non-array objects larger than 2032 bytes)\n+    // (never reset by the runtime)\n     uint64_t bigalloc;\n+    // Number of `free` calls (never reset by the runtime)\n     uint64_t freecall;\n+    // Total time spent in garbage collection (never reset by the runtime)\n     uint64_t total_time;\n+    // (GC internal) Total number of bytes allocated since the program started\n     uint64_t total_allocd;\n+    // (GC internal) Per-thread allocation quota before triggering a GC\n+    // NOTE: This field is no longer used by the heuristics in the stock GC\n     size_t interval;\n+    // Duration of the last GC pause in nanoseconds\n     int pause;\n+    // Number of full GC sweeps completed so far (never reset by the runtime)\n     int full_sweep;\n+    // Maximum pause duration observed so far in nanoseconds\n     uint64_t max_pause;\n+    // Maximum number of bytes allocated any point in time.\n+    // NOTE: This is aggregated over objects, not pages\n     uint64_t max_memory;\n+    // Time taken to reach a safepoint in the last GC cycle in nanoseconds\n     uint64_t time_to_safepoint;\n+    // Maximum time taken to reach a safepoint across all GCs in nanoseconds\n     uint64_t max_time_to_safepoint;\n+    // Total time taken to reach safepoints across all GCs in nanoseconds\n     uint64_t total_time_to_safepoint;\n+    // Time spent in the last GC sweeping phase in nanoseconds\n     uint64_t sweep_time;\n+    // Time spent in the last GC marking phase in nanoseconds\n     uint64_t mark_time;\n+    // Time spent sweeping stack pools in the last GC in nanoseconds\n     uint64_t stack_pool_sweep_time;\n+    // Total time spent in sweeping phase across all GCs in nanoseconds\n     uint64_t total_sweep_time;\n-    uint64_t    total_sweep_page_walk_time;\n-    uint64_t    total_sweep_madvise_time;\n-    uint64_t    total_sweep_free_mallocd_memory_time;\n+    // Total time spent walking pool allocated pages during sweeping phase across all GCs in nanoseconds\n+    uint64_t total_sweep_page_walk_time;\n+    // Total time spent in madvise calls during sweeping phase across all GCs in nanoseconds\n+    uint64_t total_sweep_madvise_time;\n+    // Total time spent in freeing malloc'd memory during sweeping phase across all GCs in nanoseconds\n+    uint64_t total_sweep_free_mallocd_memory_time;\n+    // Total time spent in marking phase across all GCs in nanoseconds\n     uint64_t total_mark_time;\n+    // Total time spent sweeping stack pools across all GCs in nanoseconds\n     uint64_t total_stack_pool_sweep_time;\n+    // Timestamp of the last full GC sweep in nanoseconds\n     uint64_t last_full_sweep;\n+    // Timestamp of the last incremental GC sweep in nanoseconds\n     uint64_t last_incremental_sweep;\n } jl_gc_num_t;\n "
    }
  ]
}