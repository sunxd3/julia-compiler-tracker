{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60370",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60370/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60370/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60370/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60370",
  "id": 3720679706,
  "node_id": "PR_kwDOABkWpM64bL70",
  "number": 60370,
  "title": "Move `SyntaxGraph`/`SyntaxTree` from JuliaLowering to JuliaSyntax",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9763847389,
      "node_id": "LA_kwDOABkWpM8AAAACRfh83Q",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/JuliaLowering",
      "name": "JuliaLowering",
      "color": "144fbf",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 1,
  "created_at": "2025-12-11T19:26:34Z",
  "updated_at": "2025-12-12T20:51:11Z",
  "closed_at": "2025-12-12T20:51:11Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60370",
    "html_url": "https://github.com/JuliaLang/julia/pull/60370",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60370.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60370.patch",
    "merged_at": "2025-12-12T20:51:11Z"
  },
  "body": "This is purely a code movement PR.  @c42f has noted that `SyntaxTree` may eventually replace `SyntaxNode` and should be part of JuliaSyntax.  Doing this code movement before https://github.com/JuliaLang/julia/pull/59870 would have been a mess, though, since the API to `SyntaxTree` is still under development.  \r\n\r\nEasiest to review commit-by-commit.  Summary of changes:\r\n- Move `syntax_graph.jl` and associated tests to JuliaSyntax, including parts of `ast.jl` that are necessary to construct trees (needed for parsing to `SyntaxTree`) and excluding anything that needs to know about lowering `Kind`s or `Bindings`\r\n- Update docstrings and file names to clarify the difference between the trees. Mention that `SyntaxTree` is unstable/JuliaLowering-only for now.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60370/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60370/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "6a1901540655bd20f3d9ae93dd7f3a67f5af1485",
      "filename": "JuliaLowering/src/JuliaLowering.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 5,
      "changes": 13,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2FJuliaLowering.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2FJuliaLowering.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2FJuliaLowering.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -13,15 +13,18 @@ else\n end\n \n using .JuliaSyntax: highlight, Kind, @KSet_str, is_leaf, children, numchildren,\n-    head, kind, flags, has_flags, numeric_flags, filename, first_byte,\n-    last_byte, byte_range, sourcefile, source_location, span, sourcetext,\n-    is_literal, is_number, is_operator, is_prec_assignment, is_prefix_call,\n-    is_infix_op_call, is_postfix_op_call, is_error\n+    head, kind, flags, has_flags, filename, first_byte, last_byte, byte_range,\n+    sourcefile, source_location, span, sourcetext, is_literal, is_infix_op_call,\n+    is_postfix_op_call, @isexpr, SyntaxHead, is_syntactic_operator,\n+    SyntaxGraph, SyntaxTree, SyntaxList, NodeId, SourceRef, SourceAttrType,\n+    ensure_attributes, ensure_attributes!, delete_attributes, newnode!, hasattr,\n+    setattr, setattr!, syntax_graph, is_compatible_graph,\n+    check_compatible_graph, copy_node, copy_ast, provenance, sourceref,\n+    reparent, makeleaf, makenode, mapchildren, mapleaf, flattened_provenance\n \n _include(\"kinds.jl\")\n _register_kinds()\n \n-_include(\"syntax_graph.jl\")\n _include(\"ast.jl\")\n _include(\"bindings.jl\")\n _include(\"utils.jl\")"
    },
    {
      "sha": "b8a70c468d5bee3fe3c25cce5e6b0e7aa013c3ab",
      "filename": "JuliaLowering/src/ast.jl",
      "status": "modified",
      "additions": 28,
      "deletions": 195,
      "changes": 223,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2Fast.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2Fast.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fast.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -56,7 +56,7 @@ collected later.\n \"\"\"\n current_lambda_bindings(ctx::AbstractLoweringContext) = nothing\n \n-function syntax_graph(ctx::AbstractLoweringContext)\n+function JuliaSyntax.syntax_graph(ctx::AbstractLoweringContext)\n     ctx.graph\n end\n \n@@ -90,80 +90,10 @@ Lexical scope ID\n \"\"\"\n const ScopeId = Int\n \n-#-------------------------------------------------------------------------------\n-# AST creation utilities\n-_node_id(graph::SyntaxGraph, ex::SyntaxTree) = (check_compatible_graph(graph, ex); ex._id)\n-function _node_id(graph::SyntaxGraph, ex)\n-    # Fallback to give a comprehensible error message for use with the @ast macro\n-    error(\"Attempt to use `$(repr(ex))` of type `$(typeof(ex))` as an AST node. Try annotating with `::K\\\"your_intended_kind\\\"?`\")\n-end\n-function _node_id(graph::SyntaxGraph, ex::AbstractVector{<:SyntaxTree})\n-    # Fallback to give a comprehensible error message for use with the @ast macro\n-    error(\"Attempt to use vector as an AST node. Did you mean to splat this? (content: `$(repr(ex))`)\")\n-end\n-\n-_node_ids(graph::SyntaxGraph) = ()\n-_node_ids(graph::SyntaxGraph, ::Nothing, cs...) = _node_ids(graph, cs...)\n-_node_ids(graph::SyntaxGraph, c, cs...) = (_node_id(graph, c), _node_ids(graph, cs...)...)\n-_node_ids(graph::SyntaxGraph, cs::SyntaxList, cs1...) = (_node_ids(graph, cs...)..., _node_ids(graph, cs1...)...)\n-function _node_ids(graph::SyntaxGraph, cs::SyntaxList)\n-    check_compatible_graph(graph, cs)\n-    cs.ids\n-end\n-\n-_unpack_srcref(graph, srcref::SyntaxTree) = _node_id(graph, srcref)\n-_unpack_srcref(graph, srcref::Tuple)      = _node_ids(graph, srcref...)\n-_unpack_srcref(graph, srcref)             = srcref\n-\n-function _push_nodeid!(graph::SyntaxGraph, ids::Vector{NodeId}, val)\n-    push!(ids, _node_id(graph, val))\n-end\n-function _push_nodeid!(graph::SyntaxGraph, ids::Vector{NodeId}, val::Nothing)\n-    nothing\n-end\n-function _append_nodeids!(graph::SyntaxGraph, ids::Vector{NodeId}, vals)\n-    for v in vals\n-        _push_nodeid!(graph, ids, v)\n-    end\n-end\n-function _append_nodeids!(graph::SyntaxGraph, ids::Vector{NodeId}, vals::SyntaxList)\n-    check_compatible_graph(graph, vals)\n-    append!(ids, vals.ids)\n-end\n-\n-# TODO: \"proto\", if SyntaxTree, is rarely different from srcref. reorganize to:\n-# newnode/newleaf(ctx, srcref, k::Kind[, attrs])\n-# makenode/makeleaf(ctx, old::SyntaxTree[, attrs])\n-\n-function makeleaf(graph::SyntaxGraph, srcref, proto::Union{Kind, SyntaxTree})\n-    id = newnode!(graph)\n-    ex = SyntaxTree(graph, id)\n-    copy_attrs!(ex, proto, true)\n-    ex.source = _unpack_srcref(graph, srcref)\n-    return ex\n-end\n-\n-function makeleaf(ctx::AbstractLoweringContext, srcref, proto)\n+function JuliaSyntax.makeleaf(ctx::AbstractLoweringContext, srcref, proto)\n     makeleaf(syntax_graph(ctx), srcref, proto)\n end\n \n-function makeleaf(ctx, srcref, proto, @nospecialize(attrs::AbstractVector))\n-    graph = syntax_graph(ctx)\n-    ex = makeleaf(graph, srcref, proto)\n-    for (k, v) in attrs\n-        setattr!(graph, ex._id, k, v)\n-    end\n-    return ex\n-end\n-\n-function makenode(ctx, srcref, proto, children, attrs=nothing)\n-    graph = syntax_graph(ctx)\n-    ex = isnothing(attrs) ? makeleaf(graph, srcref, proto) :\n-        makeleaf(graph, srcref, proto, attrs)\n-    setchildren!(graph, ex._id, children isa SyntaxList ? children.ids : children)\n-    return ex\n-end\n-\n function newleaf(ctx, srcref, k::Kind, @nospecialize(value))\n     leaf = makeleaf(ctx, srcref, k)\n     if k == K\"Identifier\" || k == K\"core\" || k == K\"top\" || k == K\"Symbol\" ||\n@@ -192,15 +122,6 @@ function newleaf(ctx, srcref, k::Kind, @nospecialize(value))\n     leaf\n end\n \n-# TODO: Replace this with makeleaf variant?\n-function mapleaf(ctx, src, kind)\n-    ex = makeleaf(syntax_graph(ctx), src, kind)\n-    # TODO: Value coercion might be broken here due to use of `name_val` vs\n-    # `value` vs ... ?\n-    copy_attrs!(ex, src)\n-    ex\n-end\n-\n # Convenience functions to create leaf nodes referring to identifiers within\n # the Core and Top modules.\n core_ref(ctx, ex, name) = newleaf(ctx, ex, K\"core\", name)\n@@ -228,6 +149,32 @@ end\n \n #-------------------------------------------------------------------------------\n # @ast macro\n+\n+function JuliaSyntax._node_id(graph::SyntaxGraph, ex)\n+    # Fallback to give a comprehensible error message for use with the @ast macro\n+    error(\"Attempt to use `$(repr(ex))` of type `$(typeof(ex))` as an AST node. Try annotating with `::K\\\"your_intended_kind\\\"?`\")\n+end\n+function JuliaSyntax._node_id(graph::SyntaxGraph, ex::AbstractVector{<:SyntaxTree})\n+    # Fallback to give a comprehensible error message for use with the @ast macro\n+    error(\"Attempt to use vector as an AST node. Did you mean to splat this? (content: `$(repr(ex))`)\")\n+end\n+\n+function _push_nodeid!(graph::SyntaxGraph, ids::Vector{NodeId}, val)\n+    push!(ids, JuliaSyntax._node_id(graph, val))\n+end\n+function _push_nodeid!(graph::SyntaxGraph, ids::Vector{NodeId}, val::Nothing)\n+    nothing\n+end\n+function _append_nodeids!(graph::SyntaxGraph, ids::Vector{NodeId}, vals)\n+    for v in vals\n+        _push_nodeid!(graph, ids, v)\n+    end\n+end\n+function _append_nodeids!(graph::SyntaxGraph, ids::Vector{NodeId}, vals::SyntaxList)\n+    check_compatible_graph(graph, vals)\n+    append!(ids, vals.ids)\n+end\n+\n function _match_srcref(ex)\n     if Meta.isexpr(ex, :macrocall) && ex.args[1] == Symbol(\"@HERE\")\n         QuoteNode(ex.args[2])\n@@ -398,120 +345,6 @@ macro ast(ctx, srcref, tree)\n     end\n end\n \n-#-------------------------------------------------------------------------------\n-# Mapping and copying of AST nodes\n-function copy_attrs!(dest, src, all=false)\n-    # TODO: Make this faster?\n-    for (name, attr) in pairs(src._graph.attributes)\n-        if (all || (name !== :source && name !== :kind && name !== :syntax_flags)) &&\n-                haskey(attr, src._id)\n-            dest_attr = getattr(dest._graph, name, nothing)\n-            if !isnothing(dest_attr)\n-                dest_attr[dest._id] = attr[src._id]\n-            end\n-        end\n-    end\n-end\n-\n-function copy_attrs!(dest, head::Union{Kind,JuliaSyntax.SyntaxHead}, all=false)\n-    if all\n-        setattr!(dest._graph, dest._id, :kind, kind(head))\n-        !(head isa Kind) && setattr!(dest._graph, dest._id, :syntax_flags, flags(head))\n-    end\n-end\n-\n-function mapchildren(f::Function, ctx, ex::SyntaxTree, do_map_child::Function)\n-    if is_leaf(ex)\n-        return ex\n-    end\n-    orig_children = children(ex)\n-    cs = nothing\n-    for (i,e) in enumerate(orig_children)\n-        newchild = do_map_child(i) ? f(e) : e\n-        if isnothing(cs)\n-            if newchild == e\n-                continue\n-            else\n-                cs = SyntaxList(ctx)\n-                append!(cs, orig_children[1:i-1])\n-            end\n-        end\n-        push!(cs::SyntaxList, newchild)\n-    end\n-    if isnothing(cs)\n-        # This function should be allocation-free if no children were changed\n-        # by the mapping and there's no extra_attrs\n-        return ex\n-    end\n-    cs::SyntaxList\n-    ex2 = makenode(ctx, ex, ex, cs)\n-    return ex2\n-end\n-\n-function mapchildren(f::Function, ctx, ex::SyntaxTree,\n-                     mapped_children::AbstractVector{<:Integer})\n-    j = Ref(firstindex(mapped_children))\n-    function do_map_child(i)\n-        ind = j[]\n-        if ind <= lastindex(mapped_children) && mapped_children[ind] == i\n-            j[] += 1\n-            true\n-        else\n-            false\n-        end\n-    end\n-    mapchildren(f, ctx, ex, do_map_child)\n-end\n-\n-function mapchildren(f::Function, ctx, ex::SyntaxTree)\n-    mapchildren(f, ctx, ex, i->true)\n-end\n-\n-\n-\"\"\"\n-Recursively copy AST `ex` into `ctx`.\n-\n-Special provenance handling: If `copy_source` is true, treat the `.source`\n-attribute as a reference and recurse on its contents.  Otherwise, treat it like\n-any other attribute.\n-\"\"\"\n-function copy_ast(ctx, ex::SyntaxTree; copy_source=true)\n-    graph1 = syntax_graph(ex)\n-    graph2 = syntax_graph(ctx)\n-    !copy_source && check_same_graph(graph1, graph2)\n-    id2 = _copy_ast(graph2, graph1, ex._id, Dict{NodeId, NodeId}(), copy_source)\n-    return SyntaxTree(graph2, id2)\n-end\n-\n-function _copy_ast(graph2::SyntaxGraph, graph1::SyntaxGraph,\n-                   id1::NodeId, seen, copy_source)\n-    let copied = get(seen, id1, nothing)\n-        isnothing(copied) || return copied\n-    end\n-    id2 = newnode!(graph2)\n-    seen[id1] = id2\n-    src1 = get(SyntaxTree(graph1, id1), :source, nothing)\n-    src2 = if !copy_source\n-        src1\n-    elseif src1 isa NodeId\n-        _copy_ast(graph2, graph1, src1, seen, copy_source)\n-    elseif src1 isa Tuple\n-        map(i->_copy_ast(graph2, graph1, i, seen, copy_source), src1)\n-    else\n-        src1\n-    end\n-    copy_attrs!(SyntaxTree(graph2, id2), SyntaxTree(graph1, id1), true)\n-    setattr!(graph2, id2, :source, src2)\n-    if !is_leaf(graph1, id1)\n-        cs = NodeId[]\n-        for cid in children(graph1, id1)\n-            push!(cs, _copy_ast(graph2, graph1, cid, seen, copy_source))\n-        end\n-        setchildren!(graph2, id2, cs)\n-    end\n-    return id2\n-end\n-\n #-------------------------------------------------------------------------------\n function set_scope_layer(ctx, ex, layer_id, force)\n     k = kind(ex)"
    },
    {
      "sha": "55c946cd084726f47da5c6f614c50c0e3343cc9f",
      "filename": "JuliaLowering/src/compat.jl",
      "status": "modified",
      "additions": 44,
      "deletions": 2,
      "changes": 46,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fcompat.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -209,7 +209,7 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n     elseif e isa String\n         st_id = _insert_tree_node(graph, K\"string\", src)\n         id_inner = _insert_tree_node(graph, K\"String\", src, [:value=>e])\n-        setchildren!(graph, st_id, [id_inner])\n+        JuliaSyntax.setchildren!(graph, st_id, [id_inner])\n         return st_id, src\n     elseif !(e isa Expr)\n         # There are other kinds we could potentially back-convert (e.g. Float),\n@@ -560,7 +560,7 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n         return st_id, src\n     else\n         st_child_ids, last_src = _insert_child_exprs(e.head, child_exprs, graph, src)\n-        setchildren!(graph, st_id, st_child_ids)\n+        JuliaSyntax.setchildren!(graph, st_id, st_child_ids)\n         return st_id, last_src\n     end\n end\n@@ -584,3 +584,45 @@ function _insert_child_exprs(head::Symbol, child_exprs::Vector{Any},\n     end\n     return st_child_ids, last_src\n end\n+\n+#-------------------------------------------------------------------------------\n+# SyntaxTree->Expr overrides\n+\n+function JuliaSyntax._expr_leaf_val(ex::SyntaxTree, _...)\n+    name = get(ex, :name_val, nothing)\n+    if !isnothing(name)\n+        n = Symbol(name)\n+        if kind(ex) === K\"Symbol\"\n+            return QuoteNode(n)\n+        elseif hasattr(ex, :scope_layer)\n+            Expr(:scope_layer, n, ex.scope_layer)\n+        else\n+            n\n+        end\n+    else\n+        val = get(ex, :value, nothing)\n+        if kind(ex) == K\"Value\" && val isa Expr || val isa LineNumberNode\n+            # Expr AST embedded in a SyntaxTree should be quoted rather than\n+            # becoming part of the output AST.\n+            QuoteNode(val)\n+        else\n+            val\n+        end\n+    end\n+end\n+\n+function JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, head::SyntaxHead,\n+                                      @nospecialize(arg), first::Bool)\n+    isa(arg, Expr) || return arg\n+    k = kind(head)\n+    coalesce_dot = k in KSet\"call dotcall curly\" ||\n+                   (k == K\"quote\" && has_flags(head, JuliaSyntax.COLON_QUOTE))\n+    if @isexpr(arg, :., 1) && arg.args[1] isa Tuple\n+        h, a = arg.args[1]::Tuple{SyntaxHead,Any}\n+        arg = ((coalesce_dot && first) || is_syntactic_operator(h)) ?\n+            Symbol(\".\", a) : Expr(:., a)\n+    end\n+    return arg\n+end\n+\n+Base.Expr(ex::SyntaxTree) = JuliaSyntax.to_expr(ex)"
    },
    {
      "sha": "6fd3d34f8937324d3116bd8c548c87167ba8975a",
      "filename": "JuliaLowering/src/desugaring.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fdesugaring.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -1113,7 +1113,7 @@ function flatten_ncat_rows!(flat_elems, nrow_spans, row_major, parent_layout_dim\n         layout_dim = 1\n         @chk parent_layout_dim != 1 (ex,\"Badly nested rows in `ncat`\")\n     elseif k == K\"nrow\"\n-        dim = numeric_flags(ex)\n+        dim = JuliaSyntax.numeric_flags(ex)\n         @chk dim > 0                (ex,\"Unsupported dimension $dim in ncat\")\n         @chk !row_major || dim != 2 (ex,\"2D `nrow` cannot be mixed with `row` in `ncat`\")\n         layout_dim = nrow_flipdim(row_major, dim)\n@@ -1146,7 +1146,7 @@ end\n # - ragged column first or row first\n function expand_ncat(ctx, ex)\n     is_typed = kind(ex) == K\"typed_ncat\"\n-    outer_dim = numeric_flags(ex)\n+    outer_dim = JuliaSyntax.numeric_flags(ex)\n     @chk outer_dim > 0 (ex,\"Unsupported dimension in ncat\")\n     eltype      = is_typed ? ex[1]     : nothing\n     elements    = is_typed ? ex[2:end] : ex[1:end]\n@@ -2208,7 +2208,7 @@ function expand_decls(ctx, ex)\n     bindings = children(ex)\n     stmts = SyntaxList(ctx)\n     for binding in bindings\n-        if is_prec_assignment(kind(binding))\n+        if JuliaSyntax.is_prec_assignment(kind(binding))\n             @chk numchildren(binding) == 2\n             # expand_assignment will create the type decls\n             make_lhs_decls(ctx, stmts, declkind, declmeta, binding[1], false)"
    },
    {
      "sha": "55802f5803032daf23ff93697c8f1800d2a99675",
      "filename": "JuliaLowering/src/macro_expansion.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fmacro_expansion.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -377,7 +377,7 @@ function remove_scope_layer!(ex)\n             remove_scope_layer!(c)\n         end\n     end\n-    deleteattr!(ex, :scope_layer)\n+    JuliaSyntax.deleteattr!(ex, :scope_layer)\n     ex\n end\n "
    },
    {
      "sha": "0e74710d4e57e3aed272635fcafd3de04c557e33",
      "filename": "JuliaLowering/src/utils.jl",
      "status": "modified",
      "additions": 207,
      "deletions": 3,
      "changes": 210,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2Futils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Fsrc%2Futils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Futils.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -1,10 +1,113 @@\n+attrsummary(name, value) = string(name)\n+attrsummary(name, value::Number) = \"$name=$value\"\n+\n+function _value_string(ex)\n+    k = kind(ex)\n+    str = k == K\"Identifier\" || JuliaSyntax.is_operator(k) ? ex.name_val :\n+          k == K\"Placeholder\" ? ex.name_val           :\n+          k == K\"SSAValue\"    ? \"%\"                   :\n+          k == K\"BindingId\"   ? \"#\"                   :\n+          k == K\"label\"       ? \"label\"               :\n+          k == K\"core\"        ? \"core.$(ex.name_val)\" :\n+          k == K\"top\"         ? \"top.$(ex.name_val)\"  :\n+          k == K\"Symbol\"      ? \":$(ex.name_val)\" :\n+          k == K\"globalref\"   ? \"$(ex.mod).$(ex.name_val)\" :\n+          k == K\"slot\"        ? \"slot\" :\n+          k == K\"latestworld\" ? \"latestworld\" :\n+          k == K\"static_parameter\" ? \"static_parameter\" :\n+          k == K\"symbolic_label\" ? \"label:$(ex.name_val)\" :\n+          k == K\"symbolic_goto\" ? \"goto:$(ex.name_val)\" :\n+          k == K\"SourceLocation\" ?\n+              \"SourceLocation:$(JuliaSyntax.filename(ex)):$(join(source_location(ex), ':'))\" :\n+          k == K\"Value\" && ex.value isa SourceRef ?\n+              \"SourceRef:$(JuliaSyntax.filename(ex)):$(join(source_location(ex), ':'))\" :\n+          repr(get(ex, :value, nothing))\n+    id = get(ex, :var_id, nothing)\n+    if isnothing(id)\n+        id = get(ex, :id, nothing)\n+    end\n+    if !isnothing(id)\n+        idstr = subscript_str(id)\n+        str = \"$(str)$idstr\"\n+    end\n+    if k == K\"slot\" || k == K\"BindingId\"\n+        p = provenance(ex)[1]\n+        while p isa SyntaxTree\n+            if kind(p) == K\"Identifier\"\n+                str = \"$(str)/$(p.name_val)\"\n+                break\n+            end\n+            p = provenance(p)[1]\n+        end\n+    end\n+    return str\n+end\n+\n+function _show_syntax_tree(io, ex, indent, show_kinds)\n+    val = get(ex, :value, nothing)\n+    nodestr = !is_leaf(ex) ? \"[$(untokenize(head(ex)))]\" : _value_string(ex)\n+\n+    treestr = rpad(string(indent, nodestr), 40)\n+    if show_kinds && is_leaf(ex)\n+        treestr = treestr*\" :: \"*string(kind(ex))\n+    end\n+\n+    std_attrs = Set([:name_val,:value,:kind,:syntax_flags,:source,:var_id])\n+    attrstr = join([attrsummary(n, getproperty(ex, n))\n+                    for n in JuliaSyntax.attrnames(ex) if n \u2209 std_attrs], \",\")\n+    treestr = string(rpad(treestr, 60), \" \u2502 $attrstr\")\n+\n+    println(io, treestr)\n+    if !is_leaf(ex)\n+        new_indent = indent*\"  \"\n+        for n in children(ex)\n+            _show_syntax_tree(io, n, new_indent, show_kinds)\n+        end\n+    end\n+end\n+\n+function Base.show(io::IO, ::MIME\"text/plain\", ex::SyntaxTree, show_kinds=true)\n+    anames = join(string.(JuliaSyntax.attrnames(syntax_graph(ex))), \",\")\n+    println(io, \"SyntaxTree with attributes $anames\")\n+    _show_syntax_tree(io, ex, \"\", show_kinds)\n+end\n+function _show_syntax_tree_sexpr(io, ex)\n+    if is_leaf(ex)\n+        if JuliaSyntax.is_error(ex)\n+            print(io, \"(\", untokenize(head(ex)), \")\")\n+        else\n+            print(io, _value_string(ex))\n+        end\n+    else\n+        print(io, \"(\", untokenize(head(ex)))\n+        first = true\n+        for n in children(ex)\n+            print(io, ' ')\n+            _show_syntax_tree_sexpr(io, n)\n+            first = false\n+        end\n+        print(io, ')')\n+    end\n+end\n+\n+function Base.show(io::IO, ::MIME\"text/x.sexpression\", node::SyntaxTree)\n+    _show_syntax_tree_sexpr(io, node)\n+end\n+\n+function Base.show(io::IO, node::SyntaxTree)\n+    _show_syntax_tree_sexpr(io, node)\n+end\n+\n+#-------------------------------------------------------------------------------\n # Error handling\n \n TODO(msg::AbstractString) = throw(ErrorException(\"Lowering TODO: $msg\"))\n TODO(ex::SyntaxTree, msg=\"\") = throw(LoweringError(ex, \"Lowering TODO: $msg\"))\n \n-# Errors found during lowering will result in LoweringError being thrown to\n-# indicate the syntax causing the error.\n+\"\"\"\n+An error generated while lowering user code `ex` (flisp: `Expr(:error, msg)`).\n+For errors in lowering itself, use `@assert`.\n+\"\"\"\n struct LoweringError <: Exception\n     ex::SyntaxTree\n     msg::String\n@@ -21,7 +124,6 @@ function Base.showerror(io::IO, exc::LoweringError; show_detail=true)\n     end\n end\n \n-#-------------------------------------------------------------------------------\n function _show_provtree(io::IO, ex::SyntaxTree, indent)\n     print(io, ex, \"\\n\")\n     prov = provenance(ex)\n@@ -184,3 +286,105 @@ else\n         esc(f)\n     end\n end\n+\n+#-------------------------------------------------------------------------------\n+# @SyntaxTree(::Expr)\n+\n+function _find_SyntaxTree_macro(ex, line)\n+    @assert !is_leaf(ex)\n+    for c in children(ex)\n+        rng = byte_range(c)\n+        firstline = JuliaSyntax.source_line(sourcefile(c), first(rng))\n+        lastline = JuliaSyntax.source_line(sourcefile(c), last(rng))\n+        if line < firstline || lastline < line\n+            continue\n+        end\n+        # We're in the line range. Either\n+        if firstline == line && kind(c) == K\"macrocall\" && begin\n+                    name = c[1]\n+                    if kind(name) == K\".\"\n+                        name = name[2]\n+                    end\n+                    @assert kind(name) == K\"Identifier\"\n+                    name.name_val == \"@SyntaxTree\"\n+                end\n+            # We find the node we're looking for. NB: Currently assuming a max\n+            # of one @SyntaxTree invocation per line. Though we could relax\n+            # this with more heuristic matching of the Expr-AST...\n+            @assert numchildren(c) == 2\n+            return c[2]\n+        elseif !is_leaf(c)\n+            # Recurse\n+            ex1 = _find_SyntaxTree_macro(c, line)\n+            if !isnothing(ex1)\n+                return ex1\n+            end\n+        end\n+    end\n+    return nothing # Will get here if multiple children are on the same line.\n+end\n+\n+# Translate JuliaLowering hygiene to esc() for use in @SyntaxTree\n+function _scope_layer_1_to_esc!(ex)\n+    if ex isa Expr\n+        if ex.head == :scope_layer\n+            @assert ex.args[2] === 1\n+            return esc(_scope_layer_1_to_esc!(ex.args[1]))\n+        else\n+            map!(_scope_layer_1_to_esc!, ex.args, ex.args)\n+            return ex\n+        end\n+    else\n+        return ex\n+    end\n+end\n+\n+\"\"\"\n+Macro to construct quoted SyntaxTree literals (instead of quoted Expr literals)\n+in normal Julia source code.\n+\n+Example:\n+\n+```julia\n+tree1 = @SyntaxTree :(some_unique_identifier)\n+tree2 = @SyntaxTree quote\n+    x = 1\n+    \\$tree1 = x\n+end\n+```\n+\"\"\"\n+macro SyntaxTree(ex_old)\n+    # The implementation here is hilarious and arguably very janky: we\n+    # 1. Briefly check but throw away the Expr-AST\n+    if !(Meta.isexpr(ex_old, :quote) || ex_old isa QuoteNode)\n+        throw(ArgumentError(\"@SyntaxTree expects a `quote` block or `:`-quoted expression\"))\n+    end\n+    # 2. Re-parse the current source file as SyntaxTree instead\n+    fname = isnothing(__source__.file) ? error(\"No current file\") : String(__source__.file)\n+    if occursin(r\"REPL\\[\\d+\\]\", fname)\n+        # Assume we should look at last history entry in REPL\n+        try\n+            # Wow digging in like this is an awful hack but `@SyntaxTree` is\n+            # already a hack so let's go for it I guess \ud83d\ude06\n+            text = Base.active_repl.mistate.interface.modes[1].hist.history[end]\n+            if !occursin(\"@SyntaxTree\", text)\n+                error(\"Text not found in last REPL history line\")\n+            end\n+        catch\n+            error(\"Text not found in REPL history\")\n+        end\n+    else\n+        text = read(fname, String)\n+    end\n+    full_ex = parseall(SyntaxTree, text)\n+    # 3. Using the current file and line number, dig into the re-parsed tree and\n+    # discover the piece of AST which should be returned.\n+    ex = _find_SyntaxTree_macro(full_ex, __source__.line)\n+    isnothing(ex) && error(\"_find_SyntaxTree_macro failed\")\n+    # 4. Do the first step of JuliaLowering's syntax lowering to get\n+    # syntax interpolations to work\n+    _, ex1 = expand_forms_1(__module__, ex, false, Base.tls_world_age())\n+    @assert kind(ex1) == K\"call\" && ex1[1].value == interpolate_ast\n+    Expr(:call, :interpolate_ast, SyntaxTree, ex1[3][1],\n+         map(e->_scope_layer_1_to_esc!(Expr(e)), ex1[4:end])...)\n+end"
    },
    {
      "sha": "6f212056937857f5b8e89d3c203ef36fd31bcd84",
      "filename": "JuliaLowering/test/ast.jl",
      "status": "added",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Ftest%2Fast.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Ftest%2Fast.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fast.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -0,0 +1,20 @@\n+@testset \"SyntaxTree\" begin\n+    # Expr conversion\n+    @test Expr(parsestmt(SyntaxTree, \"begin a + b ; c end\", filename=\"none\")) ==\n+        Meta.parse(\"begin a + b ; c end\")\n+\n+    # @SyntaxTree\n+    tree1 = JuliaLowering.@SyntaxTree :(some_unique_identifier)\n+    @test tree1 isa SyntaxTree\n+    @test kind(tree1) == K\"Identifier\"\n+    @test tree1.name_val == \"some_unique_identifier\"\n+\n+    tree2 = JuliaLowering.@SyntaxTree quote\n+        x\n+        $tree1\n+    end\n+    @test tree2 isa SyntaxTree\n+    @test kind(tree2) == K\"block\"\n+    @test kind(tree2[1]) == K\"Identifier\" && tree2[1].name_val == \"x\"\n+    @test kind(tree2[2]) == K\"Identifier\" && tree2[2].name_val == \"some_unique_identifier\"\n+end"
    },
    {
      "sha": "c27109bd2be474a1438086a6c2bdaa2f32746c4f",
      "filename": "JuliaLowering/test/compat.jl",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Ftest%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Ftest%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fcompat.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -89,37 +89,37 @@ const JL = JuliaLowering\n \n         if JS.is_infix_op_call(st) && (k === K\"call\" || k === K\"dotcall\")\n             # Infix calls are not preserved in Expr; we need to re-order the children\n-            pre_st_args = JL.NodeId[st[2]._id, st[1]._id]\n+            pre_st_args = JS.NodeId[st[2]._id, st[1]._id]\n             for c in st[3:end]\n                 push!(pre_st_args, c._id)\n             end\n             pre_st_flags = (JS.flags(st) & ~JS.INFIX_FLAG) | JS.PREFIX_CALL_FLAG\n-            JL.setchildren!(st._graph, st._id, pre_st_args)\n-            JL.setattr!(st._graph, st._id, :syntax_flags, pre_st_flags)\n+            JS.setchildren!(st._graph, st._id, pre_st_args)\n+            JS.setattr!(st._graph, st._id, :syntax_flags, pre_st_flags)\n         elseif JS.is_postfix_op_call(st) && (k === K\"call\" || k === K\"dotcall\")\n-            pre_st_args = JL.NodeId[st[end]._id]\n+            pre_st_args = JS.NodeId[st[end]._id]\n             for c in st[1:end-1]\n                 push!(pre_st_args, c._id)\n             end\n             pre_st_flags = (JS.flags(st) & ~JS.POSTFIX_OP_FLAG) | JS.PREFIX_CALL_FLAG\n-            JL.setchildren!(st._graph, st._id, pre_st_args)\n-            JL.setattr!(st._graph, st._id, :syntax_flags, pre_st_flags)\n+            JS.setchildren!(st._graph, st._id, pre_st_args)\n+            JS.setattr!(st._graph, st._id, :syntax_flags, pre_st_flags)\n         elseif k in JS.KSet\"tuple block macrocall\"\n-            JL.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.PARENS_FLAG)\n+            JS.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.PARENS_FLAG)\n         elseif k === K\"toplevel\"\n-            JL.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.TOPLEVEL_SEMICOLONS_FLAG)\n+            JS.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.TOPLEVEL_SEMICOLONS_FLAG)\n         end\n \n         if k in JS.KSet\"tuple call dotcall macrocall vect curly braces <: >:\"\n-            JL.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.TRAILING_COMMA_FLAG)\n+            JS.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.TRAILING_COMMA_FLAG)\n         end\n \n-        k === K\"quote\" && JL.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.COLON_QUOTE)\n-        k === K\"wrapper\" && JL.setattr!(st._graph, st._id, :kind, K\"block\")\n+        k === K\"quote\" && JS.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.COLON_QUOTE)\n+        k === K\"wrapper\" && JS.setattr!(st._graph, st._id, :kind, K\"block\")\n \n         # All ops are prefix ops in an expr.\n         # Ignore trivia (shows up on some K\"error\"s)\n-        JL.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) &\n+        JS.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) &\n             ~JS.PREFIX_OP_FLAG & ~JS.INFIX_FLAG & ~JS.TRIVIA_FLAG & ~JS.NON_TERMINAL_FLAG)\n \n         for c in JS.children(st)\n@@ -311,7 +311,7 @@ const JL = JuliaLowering\n \n         for p in programs\n             @testset \"`$(repr(p))`\" begin\n-                st_good = JS.parsestmt(JL.SyntaxTree, p; ignore_errors=true)\n+                st_good = JS.parsestmt(JS.SyntaxTree, p; ignore_errors=true)\n                 st_test = JL.expr_to_syntaxtree(Expr(st_good))\n                 @test st_roughly_equal(;st_good, st_test)\n             end\n@@ -324,7 +324,7 @@ const JL = JuliaLowering\n         ]\n         for p in toplevel_programs\n             @testset \"`$(repr(p))`\" begin\n-                st_good = JS.parseall(JL.SyntaxTree, p; ignore_errors=true)\n+                st_good = JS.parseall(JS.SyntaxTree, p; ignore_errors=true)\n                 st_test = JL.expr_to_syntaxtree(Expr(st_good))\n                 @test st_roughly_equal(;st_good, st_test)\n             end"
    },
    {
      "sha": "9f88bea4dff9a290985a3ca770346b17f2455656",
      "filename": "JuliaLowering/test/macros.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Ftest%2Fmacros.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Ftest%2Fmacros.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmacros.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -336,7 +336,7 @@ end\n     @sig_mismatch(1, 2, 3, 4)\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Error expanding macro\n     Caused by:\n-    MethodError: no method matching var\"@sig_mismatch\"(::JuliaLowering.MacroContext, ::JuliaLowering.SyntaxTree\"\"\")\n+    MethodError: no method matching var\"@sig_mismatch\"(\"\"\")\n end\n \n @testset \"old macros producing exotic expr heads\" begin"
    },
    {
      "sha": "95e3635d8829fb11e496ac9afead128225b1d983",
      "filename": "JuliaLowering/test/runtests.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fruntests.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -1,7 +1,7 @@\n include(\"utils.jl\")\n \n @testset \"JuliaLowering.jl\" begin\n-    include(\"syntax_graph.jl\")\n+    include(\"ast.jl\")\n \n     include(\"ir_tests.jl\")\n "
    },
    {
      "sha": "6ca0207f2dff316f90b7309b50d1828e881e5d3d",
      "filename": "JuliaLowering/test/utils.jl",
      "status": "modified",
      "additions": 0,
      "deletions": 16,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Ftest%2Futils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaLowering%2Ftest%2Futils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Futils.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -47,22 +47,6 @@ macro ast_(tree)\n     end\n end\n \n-function \u2248(ex1, ex2)\n-    if kind(ex1) != kind(ex2) || is_leaf(ex1) != is_leaf(ex2)\n-        return false\n-    end\n-    if is_leaf(ex1)\n-        return get(ex1, :value,    nothing) == get(ex2, :value,    nothing) &&\n-               get(ex1, :name_val, nothing) == get(ex2, :name_val, nothing)\n-    else\n-        if numchildren(ex1) != numchildren(ex2)\n-            return false\n-        end\n-        return all(c1 \u2248 c2 for (c1,c2) in zip(children(ex1), children(ex2)))\n-    end\n-end\n-\n-\n #-------------------------------------------------------------------------------\n function _format_as_ast_macro(io, ex, indent)\n     k = kind(ex)"
    },
    {
      "sha": "7413e4d54a72f8ed8a321370dd3520cfd376157d",
      "filename": "JuliaSyntax/src/JuliaSyntax.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Fsrc%2FJuliaSyntax.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Fsrc%2FJuliaSyntax.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2FJuliaSyntax.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -98,8 +98,11 @@ include(\"julia/literal_parsing.jl\")\n \n # Tree data structures\n include(\"porcelain/green_node.jl\")\n-include(\"porcelain/syntax_tree.jl\")\n+include(\"porcelain/syntax_node.jl\")\n include(\"integration/expr.jl\")\n+if VERSION >= v\"1.12\"\n+    include(\"porcelain/syntax_graph.jl\")\n+end\n \n # Hooks to integrate the parser with Base\n include(\"integration/hooks.jl\")"
    },
    {
      "sha": "37fc35462cd0f04131d4d28f96a480392c273aeb",
      "filename": "JuliaSyntax/src/porcelain/syntax_graph.jl",
      "status": "renamed",
      "additions": 221,
      "deletions": 277,
      "changes": 498,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -1,9 +1,3 @@\n-# TODO: This whole file should probably be moved to JuliaSyntax.\n-import .JuliaSyntax: ParseStream, RedTreeCursor, reverse_toplevel_siblings,\n-    has_toplevel_siblings, _unsafe_wrap_substring, parse_julia_literal, is_trivia,\n-    is_prefix_op_call, @isexpr, SyntaxHead, COLON_QUOTE, is_syntactic_operator,\n-    lower_identifier_name\n-\n const NodeId = Int\n \n \"\"\"\n@@ -113,19 +107,19 @@ function setchildren!(graph::SyntaxGraph, id::NodeId,\n     append!(graph.edges, children)\n end\n \n-function JuliaSyntax.is_leaf(graph::SyntaxGraph, id)\n+function is_leaf(graph::SyntaxGraph, id)\n     first(graph.edge_ranges[id]) == 0\n end\n \n-function JuliaSyntax.numchildren(graph::SyntaxGraph, id)\n+function numchildren(graph::SyntaxGraph, id)\n     length(graph.edge_ranges[id])\n end\n \n-function JuliaSyntax.children(graph::SyntaxGraph, id)\n+function children(graph::SyntaxGraph, id)\n     @view graph.edges[graph.edge_ranges[id]]\n end\n \n-function JuliaSyntax.children(graph::SyntaxGraph, id, r::UnitRange)\n+function children(graph::SyntaxGraph, id, r::UnitRange)\n     @view graph.edges[graph.edge_ranges[id][r]]\n end\n \n@@ -192,7 +186,12 @@ function is_compatible_graph(x, y)\n     syntax_graph(x).edges === syntax_graph(y).edges\n end\n \n-#-------------------------------------------------------------------------------\n+\"\"\"\n+    struct SyntaxTree\n+\n+An ECS-style AST used in JuliaLowering.  Unstable, but may eventually replace\n+SyntaxNode.\n+\"\"\"\n struct SyntaxTree{GraphType}\n     _graph::GraphType\n     _id::NodeId\n@@ -235,6 +234,21 @@ end\n Base.firstindex(ex::SyntaxTree) = 1\n Base.lastindex(ex::SyntaxTree) = numchildren(ex)\n \n+function Base.:\u2248(ex1::SyntaxTree, ex2::SyntaxTree)\n+    if kind(ex1) != kind(ex2) || is_leaf(ex1) != is_leaf(ex2)\n+        return false\n+    end\n+    if is_leaf(ex1)\n+        return get(ex1, :value,    nothing) == get(ex2, :value,    nothing) &&\n+               get(ex1, :name_val, nothing) == get(ex2, :name_val, nothing)\n+    else\n+        if numchildren(ex1) != numchildren(ex2)\n+            return false\n+        end\n+        return all(c1 \u2248 c2 for (c1,c2) in zip(children(ex1), children(ex2)))\n+    end\n+end\n+\n function hasattr(ex::SyntaxTree, name::Symbol)\n     attr = getattr(ex._graph, name, nothing)\n     return !isnothing(attr) && haskey(attr, ex._id)\n@@ -269,27 +283,27 @@ end\n \n # JuliaSyntax tree API\n \n-function JuliaSyntax.is_leaf(ex::SyntaxTree)\n+function is_leaf(ex::SyntaxTree)\n     is_leaf(ex._graph, ex._id)\n end\n \n-function JuliaSyntax.numchildren(ex::SyntaxTree)\n+function numchildren(ex::SyntaxTree)\n     numchildren(ex._graph, ex._id)\n end\n \n-function JuliaSyntax.children(ex::SyntaxTree)\n+function children(ex::SyntaxTree)\n     SyntaxList(ex._graph, children(ex._graph, ex._id))\n end\n \n-function JuliaSyntax.head(ex::SyntaxTree)\n-    JuliaSyntax.SyntaxHead(kind(ex), flags(ex))\n+function head(ex::SyntaxTree)\n+    SyntaxHead(kind(ex), flags(ex))\n end\n \n-function JuliaSyntax.kind(ex::SyntaxTree)\n-    ex.kind::JuliaSyntax.Kind\n+function kind(ex::SyntaxTree)\n+    ex.kind::Kind\n end\n \n-function JuliaSyntax.flags(ex::SyntaxTree)\n+function flags(ex::SyntaxTree)\n     get(ex, :syntax_flags, 0x0000)\n end\n \n@@ -301,29 +315,29 @@ struct SourceRef\n     last_byte::Int\n end\n \n-JuliaSyntax.sourcefile(src::SourceRef) = src.file\n-JuliaSyntax.byte_range(src::SourceRef) = src.first_byte:src.last_byte\n+sourcefile(src::SourceRef) = src.file\n+byte_range(src::SourceRef) = src.first_byte:src.last_byte\n \n # TODO: Adding these methods to support LineNumberNode is kind of hacky but we\n # can remove these after JuliaLowering becomes self-bootstrapping for macros\n # and we a proper SourceRef for @ast's @HERE form.\n-JuliaSyntax.byte_range(src::LineNumberNode) = 0:0\n-JuliaSyntax.source_location(src::LineNumberNode) = (src.line, 0)\n-JuliaSyntax.source_location(::Type{LineNumberNode}, src::LineNumberNode) = src\n-JuliaSyntax.source_line(src::LineNumberNode) = src.line\n+byte_range(src::LineNumberNode) = 0:0\n+source_location(src::LineNumberNode) = (src.line, 0)\n+source_location(::Type{LineNumberNode}, src::LineNumberNode) = src\n+source_line(src::LineNumberNode) = src.line\n # The follow somewhat strange cases are for where LineNumberNode is standing in\n # for SourceFile because we've only got Expr-based provenance info\n-JuliaSyntax.sourcefile(src::LineNumberNode) = src\n-JuliaSyntax.sourcetext(src::LineNumberNode) = SubString(\"\")\n-JuliaSyntax.source_location(src::LineNumberNode, byte_index::Integer) = (src.line, 0)\n-JuliaSyntax.source_location(::Type{LineNumberNode}, src::LineNumberNode, byte_index::Integer) = src\n-JuliaSyntax.filename(src::LineNumberNode) = string(src.file)\n+sourcefile(src::LineNumberNode) = src\n+sourcetext(src::LineNumberNode) = SubString(\"\")\n+source_location(src::LineNumberNode, byte_index::Integer) = (src.line, 0)\n+source_location(::Type{LineNumberNode}, src::LineNumberNode, byte_index::Integer) = src\n+filename(src::LineNumberNode) = string(src.file)\n \n-function JuliaSyntax.highlight(io::IO, src::LineNumberNode; note=\"\")\n+function highlight(io::IO, src::LineNumberNode; note=\"\")\n     print(io, src, \" - \", note)\n end\n \n-function JuliaSyntax.highlight(io::IO, src::SourceRef; kws...)\n+function highlight(io::IO, src::SourceRef; kws...)\n     highlight(io, src.file, first_byte(src):last_byte(src); kws...)\n end\n \n@@ -413,107 +427,6 @@ end\n \n const SourceAttrType = Union{SourceRef,LineNumberNode,NodeId,Tuple}\n \n-attrsummary(name, value) = string(name)\n-attrsummary(name, value::Number) = \"$name=$value\"\n-\n-function _value_string(ex)\n-    k = kind(ex)\n-    str = k == K\"Identifier\" || is_operator(k) ? ex.name_val :\n-          k == K\"Placeholder\" ? ex.name_val           :\n-          k == K\"SSAValue\"    ? \"%\"                   :\n-          k == K\"BindingId\"   ? \"#\"                   :\n-          k == K\"label\"       ? \"label\"               :\n-          k == K\"core\"        ? \"core.$(ex.name_val)\" :\n-          k == K\"top\"         ? \"top.$(ex.name_val)\"  :\n-          k == K\"Symbol\"      ? \":$(ex.name_val)\" :\n-          k == K\"globalref\"   ? \"$(ex.mod).$(ex.name_val)\" :\n-          k == K\"slot\"        ? \"slot\" :\n-          k == K\"latestworld\" ? \"latestworld\" :\n-          k == K\"static_parameter\" ? \"static_parameter\" :\n-          k == K\"symbolic_label\" ? \"label:$(ex.name_val)\" :\n-          k == K\"symbolic_goto\" ? \"goto:$(ex.name_val)\" :\n-          k == K\"SourceLocation\" ?\n-              \"SourceLocation:$(JuliaSyntax.filename(ex)):$(join(source_location(ex), ':'))\" :\n-          k == K\"Value\" && ex.value isa SourceRef ?\n-              \"SourceRef:$(JuliaSyntax.filename(ex)):$(join(source_location(ex), ':'))\" :\n-          repr(get(ex, :value, nothing))\n-    id = get(ex, :var_id, nothing)\n-    if isnothing(id)\n-        id = get(ex, :id, nothing)\n-    end\n-    if !isnothing(id)\n-        idstr = subscript_str(id)\n-        str = \"$(str)$idstr\"\n-    end\n-    if k == K\"slot\" || k == K\"BindingId\"\n-        p = provenance(ex)[1]\n-        while p isa SyntaxTree\n-            if kind(p) == K\"Identifier\"\n-                str = \"$(str)/$(p.name_val)\"\n-                break\n-            end\n-            p = provenance(p)[1]\n-        end\n-    end\n-    return str\n-end\n-\n-function _show_syntax_tree(io, ex, indent, show_kinds)\n-    val = get(ex, :value, nothing)\n-    nodestr = !is_leaf(ex) ? \"[$(untokenize(head(ex)))]\" : _value_string(ex)\n-\n-    treestr = rpad(string(indent, nodestr), 40)\n-    if show_kinds && is_leaf(ex)\n-        treestr = treestr*\" :: \"*string(kind(ex))\n-    end\n-\n-    std_attrs = Set([:name_val,:value,:kind,:syntax_flags,:source,:var_id])\n-    attrstr = join([attrsummary(n, getproperty(ex, n))\n-                    for n in attrnames(ex) if n \u2209 std_attrs], \",\")\n-    treestr = string(rpad(treestr, 60), \" \u2502 $attrstr\")\n-\n-    println(io, treestr)\n-    if !is_leaf(ex)\n-        new_indent = indent*\"  \"\n-        for n in children(ex)\n-            _show_syntax_tree(io, n, new_indent, show_kinds)\n-        end\n-    end\n-end\n-\n-function Base.show(io::IO, ::MIME\"text/plain\", ex::SyntaxTree, show_kinds=true)\n-    anames = join(string.(attrnames(syntax_graph(ex))), \",\")\n-    println(io, \"SyntaxTree with attributes $anames\")\n-    _show_syntax_tree(io, ex, \"\", show_kinds)\n-end\n-\n-function _show_syntax_tree_sexpr(io, ex)\n-    if is_leaf(ex)\n-        if is_error(ex)\n-            print(io, \"(\", untokenize(head(ex)), \")\")\n-        else\n-            print(io, _value_string(ex))\n-        end\n-    else\n-        print(io, \"(\", untokenize(head(ex)))\n-        first = true\n-        for n in children(ex)\n-            print(io, ' ')\n-            _show_syntax_tree_sexpr(io, n)\n-            first = false\n-        end\n-        print(io, ')')\n-    end\n-end\n-\n-function Base.show(io::IO, ::MIME\"text/x.sexpression\", node::SyntaxTree)\n-    _show_syntax_tree_sexpr(io, node)\n-end\n-\n-function Base.show(io::IO, node::SyntaxTree)\n-    _show_syntax_tree_sexpr(io, node)\n-end\n-\n function reparent(ctx, ex::SyntaxTree)\n     # Ensure `ex` has the same parent graph, in a somewhat loose sense.\n     # Could relax by copying if necessary?\n@@ -530,147 +443,8 @@ end\n \n syntax_graph(ex::SyntaxTree) = ex._graph\n \n-JuliaSyntax.sourcefile(ex::SyntaxTree) = sourcefile(sourceref(ex))\n-JuliaSyntax.byte_range(ex::SyntaxTree) = byte_range(sourceref(ex))\n-\n-function JuliaSyntax._expr_leaf_val(ex::SyntaxTree, _...)\n-    name = get(ex, :name_val, nothing)\n-    if !isnothing(name)\n-        n = Symbol(name)\n-        if kind(ex) === K\"Symbol\"\n-            return QuoteNode(n)\n-        elseif hasattr(ex, :scope_layer)\n-            Expr(:scope_layer, n, ex.scope_layer)\n-        else\n-            n\n-        end\n-    else\n-        val = get(ex, :value, nothing)\n-        if kind(ex) == K\"Value\" && val isa Expr || val isa LineNumberNode\n-            # Expr AST embedded in a SyntaxTree should be quoted rather than\n-            # becoming part of the output AST.\n-            QuoteNode(val)\n-        else\n-            val\n-        end\n-    end\n-end\n-\n-function JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, head::SyntaxHead,\n-                                      @nospecialize(arg), first::Bool)\n-    isa(arg, Expr) || return arg\n-    k = kind(head)\n-    coalesce_dot = k in KSet\"call dotcall curly\" ||\n-                   (k == K\"quote\" && has_flags(head, COLON_QUOTE))\n-    if @isexpr(arg, :., 1) && arg.args[1] isa Tuple\n-        h, a = arg.args[1]::Tuple{SyntaxHead,Any}\n-        arg = ((coalesce_dot && first) || is_syntactic_operator(h)) ?\n-            Symbol(\".\", a) : Expr(:., a)\n-    end\n-    return arg\n-end\n-\n-Base.Expr(ex::SyntaxTree) = JuliaSyntax.to_expr(ex)\n-\n-#--------------------------------------------------\n-function _find_SyntaxTree_macro(ex, line)\n-    @assert !is_leaf(ex)\n-    for c in children(ex)\n-        rng = byte_range(c)\n-        firstline = JuliaSyntax.source_line(sourcefile(c), first(rng))\n-        lastline = JuliaSyntax.source_line(sourcefile(c), last(rng))\n-        if line < firstline || lastline < line\n-            continue\n-        end\n-        # We're in the line range. Either\n-        if firstline == line && kind(c) == K\"macrocall\" && begin\n-                    name = c[1]\n-                    if kind(name) == K\".\"\n-                        name = name[2]\n-                    end\n-                    @assert kind(name) == K\"Identifier\"\n-                    name.name_val == \"@SyntaxTree\"\n-                end\n-            # We find the node we're looking for. NB: Currently assuming a max\n-            # of one @SyntaxTree invocation per line. Though we could relax\n-            # this with more heuristic matching of the Expr-AST...\n-            @assert numchildren(c) == 2\n-            return c[2]\n-        elseif !is_leaf(c)\n-            # Recurse\n-            ex1 = _find_SyntaxTree_macro(c, line)\n-            if !isnothing(ex1)\n-                return ex1\n-            end\n-        end\n-    end\n-    return nothing # Will get here if multiple children are on the same line.\n-end\n-\n-# Translate JuliaLowering hygiene to esc() for use in @SyntaxTree\n-function _scope_layer_1_to_esc!(ex)\n-    if ex isa Expr\n-        if ex.head == :scope_layer\n-            @assert ex.args[2] === 1\n-            return esc(_scope_layer_1_to_esc!(ex.args[1]))\n-        else\n-            map!(_scope_layer_1_to_esc!, ex.args, ex.args)\n-            return ex\n-        end\n-    else\n-        return ex\n-    end\n-end\n-\n-\"\"\"\n-Macro to construct quoted SyntaxTree literals (instead of quoted Expr literals)\n-in normal Julia source code.\n-\n-Example:\n-\n-```julia\n-tree1 = @SyntaxTree :(some_unique_identifier)\n-tree2 = @SyntaxTree quote\n-    x = 1\n-    \\$tree1 = x\n-end\n-```\n-\"\"\"\n-macro SyntaxTree(ex_old)\n-    # The implementation here is hilarious and arguably very janky: we\n-    # 1. Briefly check but throw away the Expr-AST\n-    if !(Meta.isexpr(ex_old, :quote) || ex_old isa QuoteNode)\n-        throw(ArgumentError(\"@SyntaxTree expects a `quote` block or `:`-quoted expression\"))\n-    end\n-    # 2. Re-parse the current source file as SyntaxTree instead\n-    fname = isnothing(__source__.file) ? error(\"No current file\") : String(__source__.file)\n-    if occursin(r\"REPL\\[\\d+\\]\", fname)\n-        # Assume we should look at last history entry in REPL\n-        try\n-            # Wow digging in like this is an awful hack but `@SyntaxTree` is\n-            # already a hack so let's go for it I guess \ud83d\ude06\n-            text = Base.active_repl.mistate.interface.modes[1].hist.history[end]\n-            if !occursin(\"@SyntaxTree\", text)\n-                error(\"Text not found in last REPL history line\")\n-            end\n-        catch\n-            error(\"Text not found in REPL history\")\n-        end\n-    else\n-        text = read(fname, String)\n-    end\n-    full_ex = parseall(SyntaxTree, text)\n-    # 3. Using the current file and line number, dig into the re-parsed tree and\n-    # discover the piece of AST which should be returned.\n-    ex = _find_SyntaxTree_macro(full_ex, __source__.line)\n-    isnothing(ex) && error(\"_find_SyntaxTree_macro failed\")\n-    # 4. Do the first step of JuliaLowering's syntax lowering to get\n-    # syntax interpolations to work\n-    _, ex1 = expand_forms_1(__module__, ex, false, Base.tls_world_age())\n-    @assert kind(ex1) == K\"call\" && ex1[1].value == interpolate_ast\n-    Expr(:call, :interpolate_ast, SyntaxTree, ex1[3][1],\n-         map(e->_scope_layer_1_to_esc!(Expr(e)), ex1[4:end])...)\n-end\n+sourcefile(ex::SyntaxTree) = sourcefile(sourceref(ex))\n+byte_range(ex::SyntaxTree) = byte_range(sourceref(ex))\n \n #-------------------------------------------------------------------------------\n # Lightweight vector of nodes ids with associated pointer to graph stored separately.\n@@ -792,11 +566,181 @@ end\n #     out\n # end\n \n+\n+#-------------------------------------------------------------------------------\n+# AST creation utilities\n+\n+# TODO: \"proto\", if SyntaxTree, is rarely different from srcref. reorganize to:\n+# newnode/newleaf(ctx, srcref, k::Kind[, attrs])\n+# makenode/makeleaf(ctx, old::SyntaxTree[, attrs])\n+\n+_node_id(graph::SyntaxGraph, ex::SyntaxTree) = (check_compatible_graph(graph, ex); ex._id)\n+\n+_node_ids(graph::SyntaxGraph) = ()\n+_node_ids(graph::SyntaxGraph, ::Nothing, cs...) = _node_ids(graph, cs...)\n+_node_ids(graph::SyntaxGraph, c, cs...) = (_node_id(graph, c), _node_ids(graph, cs...)...)\n+_node_ids(graph::SyntaxGraph, cs::SyntaxList, cs1...) = (_node_ids(graph, cs...)..., _node_ids(graph, cs1...)...)\n+function _node_ids(graph::SyntaxGraph, cs::SyntaxList)\n+    check_compatible_graph(graph, cs)\n+    cs.ids\n+end\n+\n+_unpack_srcref(graph, srcref::SyntaxTree) = _node_id(graph, srcref)\n+_unpack_srcref(graph, srcref::Tuple)      = _node_ids(graph, srcref...)\n+_unpack_srcref(graph, srcref)             = srcref\n+\n+function makeleaf(graph::SyntaxGraph, srcref, proto::Union{Kind, SyntaxTree})\n+    id = newnode!(graph)\n+    ex = SyntaxTree(graph, id)\n+    copy_attrs!(ex, proto, true)\n+    ex.source = _unpack_srcref(graph, srcref)\n+    return ex\n+end\n+\n+function makeleaf(ctx, srcref, proto, @nospecialize(attrs::AbstractVector))\n+    graph = syntax_graph(ctx)\n+    ex = makeleaf(graph, srcref, proto)\n+    for (k, v) in attrs\n+        setattr!(graph, ex._id, k, v)\n+    end\n+    return ex\n+end\n+\n+function makenode(ctx, srcref, proto, children, attrs=nothing)\n+    graph = syntax_graph(ctx)\n+    ex = isnothing(attrs) ? makeleaf(graph, srcref, proto) :\n+        makeleaf(graph, srcref, proto, attrs)\n+    setchildren!(graph, ex._id, children isa SyntaxList ? children.ids : children)\n+    return ex\n+end\n+\n+# TODO: Replace this with makeleaf variant?\n+function mapleaf(ctx, src, kind)\n+    ex = makeleaf(syntax_graph(ctx), src, kind)\n+    # TODO: Value coercion might be broken here due to use of `name_val` vs\n+    # `value` vs ... ?\n+    copy_attrs!(ex, src)\n+    ex\n+end\n+\n+#-------------------------------------------------------------------------------\n+# Mapping and copying of AST nodes\n+function copy_attrs!(dest, src, all=false)\n+    # TODO: Make this faster?\n+    for (name, attr) in pairs(src._graph.attributes)\n+        if (all || (name !== :source && name !== :kind && name !== :syntax_flags)) &&\n+                haskey(attr, src._id)\n+            dest_attr = getattr(dest._graph, name, nothing)\n+            if !isnothing(dest_attr)\n+                dest_attr[dest._id] = attr[src._id]\n+            end\n+        end\n+    end\n+end\n+\n+function copy_attrs!(dest, head::Union{Kind,SyntaxHead}, all=false)\n+    if all\n+        setattr!(dest._graph, dest._id, :kind, kind(head))\n+        !(head isa Kind) && setattr!(dest._graph, dest._id, :syntax_flags, flags(head))\n+    end\n+end\n+\n+function mapchildren(f::Function, ctx, ex::SyntaxTree, do_map_child::Function)\n+    if is_leaf(ex)\n+        return ex\n+    end\n+    orig_children = children(ex)\n+    cs = nothing\n+    for (i,e) in enumerate(orig_children)\n+        newchild = do_map_child(i) ? f(e) : e\n+        if isnothing(cs)\n+            if newchild == e\n+                continue\n+            else\n+                cs = SyntaxList(ctx)\n+                append!(cs, orig_children[1:i-1])\n+            end\n+        end\n+        push!(cs::SyntaxList, newchild)\n+    end\n+    if isnothing(cs)\n+        # This function should be allocation-free if no children were changed\n+        # by the mapping and there's no extra_attrs\n+        return ex\n+    end\n+    cs::SyntaxList\n+    ex2 = makenode(ctx, ex, ex, cs)\n+    return ex2\n+end\n+\n+function mapchildren(f::Function, ctx, ex::SyntaxTree,\n+                     mapped_children::AbstractVector{<:Integer})\n+    j = Ref(firstindex(mapped_children))\n+    function do_map_child(i)\n+        ind = j[]\n+        if ind <= lastindex(mapped_children) && mapped_children[ind] == i\n+            j[] += 1\n+            true\n+        else\n+            false\n+        end\n+    end\n+    mapchildren(f, ctx, ex, do_map_child)\n+end\n+\n+function mapchildren(f::Function, ctx, ex::SyntaxTree)\n+    mapchildren(f, ctx, ex, i->true)\n+end\n+\n+\n+\"\"\"\n+Recursively copy AST `ex` into `ctx`.\n+\n+Special provenance handling: If `copy_source` is true, treat the `.source`\n+attribute as a reference and recurse on its contents.  Otherwise, treat it like\n+any other attribute.\n+\"\"\"\n+function copy_ast(ctx, ex::SyntaxTree; copy_source=true)\n+    graph1 = syntax_graph(ex)\n+    graph2 = syntax_graph(ctx)\n+    !copy_source && check_same_graph(graph1, graph2)\n+    id2 = _copy_ast(graph2, graph1, ex._id, Dict{NodeId, NodeId}(), copy_source)\n+    return SyntaxTree(graph2, id2)\n+end\n+\n+function _copy_ast(graph2::SyntaxGraph, graph1::SyntaxGraph,\n+                   id1::NodeId, seen, copy_source)\n+    let copied = get(seen, id1, nothing)\n+        isnothing(copied) || return copied\n+    end\n+    id2 = newnode!(graph2)\n+    seen[id1] = id2\n+    src1 = get(SyntaxTree(graph1, id1), :source, nothing)\n+    src2 = if !copy_source\n+        src1\n+    elseif src1 isa NodeId\n+        _copy_ast(graph2, graph1, src1, seen, copy_source)\n+    elseif src1 isa Tuple\n+        map(i->_copy_ast(graph2, graph1, i, seen, copy_source), src1)\n+    else\n+        src1\n+    end\n+    copy_attrs!(SyntaxTree(graph2, id2), SyntaxTree(graph1, id1), true)\n+    setattr!(graph2, id2, :source, src2)\n+    if !is_leaf(graph1, id1)\n+        cs = NodeId[]\n+        for cid in children(graph1, id1)\n+            push!(cs, _copy_ast(graph2, graph1, cid, seen, copy_source))\n+        end\n+        setchildren!(graph2, id2, cs)\n+    end\n+    return id2\n+end\n+\n #-------------------------------------------------------------------------------\n-# Conversion from the raw parsed tree\n-# TODO: move to JuliaSyntax. Replace SyntaxNode?\n+# RawGreenNode->SyntaxTree\n \n-function JuliaSyntax.build_tree(::Type{SyntaxTree}, stream::ParseStream;\n+function build_tree(::Type{SyntaxTree}, stream::ParseStream;\n                                 filename=nothing, first_line=1)\n     cursor = RedTreeCursor(stream)\n     graph = SyntaxGraph()",
      "previous_filename": "JuliaLowering/src/syntax_graph.jl"
    },
    {
      "sha": "3724d1e517566baa4c68be01a33a43c4801f5076",
      "filename": "JuliaSyntax/src/porcelain/syntax_node.jl",
      "status": "renamed",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_node.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_node.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_node.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -82,11 +82,13 @@ function Base.:(==)(a::SyntaxData, b::SyntaxData)\n end\n \n \"\"\"\n-    SyntaxNode(source::SourceFile, raw::GreenNode{SyntaxHead};\n-               keep_parens=false, position::Integer=1)\n+    SyntaxNode(source::SourceFile, cursor::RedTreeCursor,\n+               raw::GreenNode{SyntaxHead}; keep_parens=false)\n \n-An AST node with a similar layout to `Expr`. Typically constructed from source\n-text by calling one of the parser API functions such as [`parseall`](@ref)\n+A pointer-y AST constructed by removing all trivia from the raw parser output\n+(see [`RawGreenNode`](@ref)).  The layout of `SyntaxNode` is different from that\n+of `Expr` due to the invariant that each node's children are in the order they\n+appeared in the source text.\n \"\"\"\n const SyntaxNode = TreeNode{SyntaxData}\n ",
      "previous_filename": "JuliaSyntax/src/porcelain/syntax_tree.jl"
    },
    {
      "sha": "bdfaa12934bc6d6002b88a9d445a43d7feb665cc",
      "filename": "JuliaSyntax/test/runtests.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fruntests.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -18,7 +18,10 @@ end\n include(\"parse_stream.jl\")\n include(\"parser.jl\")\n include(\"green_node.jl\")\n-include(\"syntax_tree.jl\")\n+include(\"syntax_node.jl\")\n+if VERSION >= v\"1.12\"\n+    include(\"syntax_graph.jl\")\n+end\n include(\"diagnostics.jl\")\n include(\"parser_api.jl\")\n include(\"expr.jl\")"
    },
    {
      "sha": "42583bab76bd77db710d689a3206d607409df10b",
      "filename": "JuliaSyntax/test/syntax_graph.jl",
      "status": "renamed",
      "additions": 27,
      "deletions": 42,
      "changes": 69,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Ftest%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Ftest%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fsyntax_graph.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "patch": "@@ -1,71 +1,56 @@\n+using .JuliaSyntax: SyntaxGraph, SyntaxTree, SyntaxList, freeze_attrs, unfreeze_attrs, ensure_attributes, ensure_attributes!, delete_attributes, copy_ast, attrdefs\n+\n @testset \"SyntaxGraph attrs\" begin\n     st = parsestmt(SyntaxTree, \"function foo end\")\n-    g_init = JuliaLowering.unfreeze_attrs(st._graph)\n-    gf1 = JuliaLowering.freeze_attrs(g_init)\n-    gu1 = JuliaLowering.unfreeze_attrs(gf1)\n+    g_init = unfreeze_attrs(st._graph)\n+    gf1 = freeze_attrs(g_init)\n+    gu1 = unfreeze_attrs(gf1)\n \n     # Check that freeze/unfreeze do their jobs\n     @test gf1.attributes isa NamedTuple\n     @test gu1.attributes isa Dict\n     @test Set(keys(gf1.attributes)) == Set(keys(gu1.attributes))\n \n     # ensure_attributes\n-    gf2 = JuliaLowering.ensure_attributes(gf1, test_attr=Symbol, foo=Type)\n-    gu2 = JuliaLowering.ensure_attributes(gu1, test_attr=Symbol, foo=Type)\n+    gf2 = ensure_attributes(gf1, test_attr=Symbol, foo=Type)\n+    gu2 = ensure_attributes(gu1, test_attr=Symbol, foo=Type)\n     # returns a graph with the same attribute storage\n     @test gf2.attributes isa NamedTuple\n     @test gu2.attributes isa Dict\n     # does its job\n-    @test (:test_attr=>Symbol) in JuliaLowering.attrdefs(gf2)\n-    @test (:foo=>Type) in JuliaLowering.attrdefs(gf2)\n+    @test (:test_attr=>Symbol) in attrdefs(gf2)\n+    @test (:foo=>Type) in attrdefs(gf2)\n     @test Set(keys(gf2.attributes)) == Set(keys(gu2.attributes))\n     # no mutation\n-    @test !((:test_attr=>Symbol) in JuliaLowering.attrdefs(gf1))\n-    @test !((:foo=>Type) in JuliaLowering.attrdefs(gf1))\n+    @test !((:test_attr=>Symbol) in attrdefs(gf1))\n+    @test !((:foo=>Type) in attrdefs(gf1))\n     @test Set(keys(gf1.attributes)) == Set(keys(gu1.attributes))\n \n     # delete_attributes\n-    gf3 = JuliaLowering.delete_attributes(gf2, :test_attr, :foo)\n-    gu3 = JuliaLowering.delete_attributes(gu2, :test_attr, :foo)\n+    gf3 = delete_attributes(gf2, :test_attr, :foo)\n+    gu3 = delete_attributes(gu2, :test_attr, :foo)\n     # returns a graph with the same attribute storage\n     @test gf3.attributes isa NamedTuple\n     @test gu3.attributes isa Dict\n     # does its job\n-    @test !((:test_attr=>Symbol) in JuliaLowering.attrdefs(gf3))\n-    @test !((:foo=>Type) in JuliaLowering.attrdefs(gf3))\n+    @test !((:test_attr=>Symbol) in attrdefs(gf3))\n+    @test !((:foo=>Type) in attrdefs(gf3))\n     @test Set(keys(gf3.attributes)) == Set(keys(gu3.attributes))\n     # no mutation\n-    @test (:test_attr=>Symbol) in JuliaLowering.attrdefs(gf2)\n-    @test (:foo=>Type) in JuliaLowering.attrdefs(gf2)\n+    @test (:test_attr=>Symbol) in attrdefs(gf2)\n+    @test (:foo=>Type) in attrdefs(gf2)\n     @test Set(keys(gf2.attributes)) == Set(keys(gu2.attributes))\n end\n \n-@testset \"SyntaxTree\" begin\n-    # Expr conversion\n-    @test Expr(parsestmt(SyntaxTree, \"begin a + b ; c end\", filename=\"none\")) ==\n-        Meta.parse(\"begin a + b ; c end\")\n-\n-    # Parsing to SyntaxTree: errors should fall through\n+@testset \"SyntaxTree parsing\" begin\n+    # Errors should fall through\n     @test parsestmt(SyntaxTree, \"@\"; ignore_errors=true) isa SyntaxTree\n     @test parsestmt(SyntaxTree, \"@@@\"; ignore_errors=true) isa SyntaxTree\n     @test parsestmt(SyntaxTree, \"(a b c)\"; ignore_errors=true) isa SyntaxTree\n     @test parsestmt(SyntaxTree, \"'a b c'\"; ignore_errors=true) isa SyntaxTree\n+end\n \n-    # @SyntaxTree\n-    tree1 = JuliaLowering.@SyntaxTree :(some_unique_identifier)\n-    @test tree1 isa SyntaxTree\n-    @test kind(tree1) == K\"Identifier\"\n-    @test tree1.name_val == \"some_unique_identifier\"\n-\n-    tree2 = JuliaLowering.@SyntaxTree quote\n-        x\n-        $tree1\n-    end\n-    @test tree2 isa SyntaxTree\n-    @test kind(tree2) == K\"block\"\n-    @test kind(tree2[1]) == K\"Identifier\" && tree2[1].name_val == \"x\"\n-    @test kind(tree2[2]) == K\"Identifier\" && tree2[2].name_val == \"some_unique_identifier\"\n-\n+@testset \"SyntaxTree utils\" begin\n     \"For filling required attrs in graphs created by hand\"\n     function testgraph(edge_ranges, edges, more_attrs...)\n         kinds = Dict(map(i->(i=>K\"block\"), eachindex(edge_ranges)))\n@@ -86,7 +71,7 @@ end\n                           map(i->i+3, 1:6)...\n                           map(LineNumberNode, 7:9)...])))\n         st = SyntaxTree(g, 1)\n-        stcopy = JuliaLowering.copy_ast(g, st)\n+        stcopy = copy_ast(g, st)\n         # Each node should be copied once\n         @test length(g.edge_ranges) === 18\n         @test st._id != stcopy._id\n@@ -95,7 +80,7 @@ end\n         @test st.source[1] !== stcopy.source[1]\n         @test st.source[1][1] !== stcopy.source[1][1]\n \n-        stcopy2 = JuliaLowering.copy_ast(g, st; copy_source=false)\n+        stcopy2 = copy_ast(g, st; copy_source=false)\n         # Only nodes 1-3 should be copied\n         @test length(g.edge_ranges) === 21\n         @test st._id != stcopy2._id\n@@ -105,13 +90,13 @@ end\n         @test st.source[1][1] === stcopy2.source[1][1]\n \n         # Copy into a new graph\n-        new_g = ensure_attributes!(SyntaxGraph(); JuliaLowering.attrdefs(g)...)\n-        stcopy3 = JuliaLowering.copy_ast(new_g, st)\n+        new_g = ensure_attributes!(SyntaxGraph(); attrdefs(g)...)\n+        stcopy3 = copy_ast(new_g, st)\n         @test length(new_g.edge_ranges) === 9\n         @test st \u2248 stcopy3\n \n-        new_g = ensure_attributes!(SyntaxGraph(); JuliaLowering.attrdefs(g)...)\n+        new_g = ensure_attributes!(SyntaxGraph(); attrdefs(g)...)\n         # Disallow for now, since we can't prevent dangling sourcerefs\n-        @test_throws ErrorException JuliaLowering.copy_ast(new_g, st; copy_source=false)\n+        @test_throws ErrorException copy_ast(new_g, st; copy_source=false)\n     end\n end",
      "previous_filename": "JuliaLowering/test/syntax_graph.jl"
    },
    {
      "sha": "3e2361ca56b2fa67f170fd907a0068ec9549e3e1",
      "filename": "JuliaSyntax/test/syntax_node.jl",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Ftest%2Fsyntax_node.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c01b49d68e95e48c2cace56223d103b96401718a/JuliaSyntax%2Ftest%2Fsyntax_node.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Ftest%2Fsyntax_node.jl?ref=c01b49d68e95e48c2cace56223d103b96401718a",
      "previous_filename": "JuliaSyntax/test/syntax_tree.jl"
    }
  ]
}