{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60474",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60474/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60474/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60474/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60474",
  "id": 3760881863,
  "node_id": "PR_kwDOABkWpM66gja3",
  "number": 60474,
  "title": "Allow parsing to `Expr`-structured `SyntaxTree`",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9763847389,
      "node_id": "LA_kwDOABkWpM8AAAACRfh83Q",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/JuliaLowering",
      "name": "JuliaLowering",
      "color": "144fbf",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 2,
  "created_at": "2025-12-24T19:27:23Z",
  "updated_at": "2025-12-29T20:11:01Z",
  "closed_at": "2025-12-29T16:53:06Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60474",
    "html_url": "https://github.com/JuliaLang/julia/pull/60474",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60474.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60474.patch",
    "merged_at": "2025-12-29T16:53:06Z"
  },
  "body": "PR 3 in the list described in https://github.com/JuliaLang/julia/pull/60373.  One more to go!\r\nAtop https://github.com/JuliaLang/julia/pull/60431.\r\n\r\nThis change allows parsing to \"`EST`\" (`SyntaxTree` with Expr structure for\r\ncompatibility with macros) by adding a way to convert `RawGreenNode` to `EST`.\r\nThis is pretty similar to our existing `RawGreenNode`->`Expr` conversion\r\n`node_to_expr`, so there's some unfortunate duplication here, but I did this\r\nover making `node_to_expr`'s output generic for a few reasons:\r\n- `RawGreenNode`->`Expr` is production code we're using today and is the\r\n  reference I'm testing this change against, so I don't want to screw with it.\r\n- Producing `SyntaxTree` means working with different constraints:\r\n  - We can't efficiently mutate the list of children after the tree is created.\r\n  - Nodes that are created and never used will stick around in the graph.\r\n  - Each node needs to remember what node it was converted from.\r\n- I've cleaned up the algorithm by postponing recursion on child nodes until\r\n  after we decide what child nodes there will be in most cases.\r\n- In a future where we pass provenance from parsing to macro-expansion by\r\n  default, we can just delete the old conversion and use\r\n  `RawGreenNode`->`EST`->`Expr` in its place.\r\n\r\n## Reviewer notes:\r\n- I have attempted to automate your job as much as possible.  Conversion\r\n  `RawGreenNode->EST->Expr` is tested against the existing `RawGreenNode->Expr`\r\n  conversion by parsing all julia files in `./JuliaLowering`, `./base`, `./test`\r\n  and the stdlibs like how JuliaSyntax tests parsing to `Expr` against the\r\n  flisp parser.\r\n- Cases can be compared against the existing conversion in `JuliaSyntax/expr.jl`\r\n  mostly one-to-one, but algorithm changes have simplified or moved a few cases.\r\n  Any cases that handle macro expansion output (`:scope_layer`, `K\"meta\"`) can\r\n  be ignored; this new conversion (and the old one too, once I make PR 4) will only\r\n  need to deal with surface syntax.\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60474/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60474/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "9e0e93214f7c8c4151ddf8eb2fba8736101656a8",
      "filename": "JuliaLowering/src/compat.jl",
      "status": "modified",
      "additions": 17,
      "deletions": 11,
      "changes": 28,
      "blob_url": "https://github.com/JuliaLang/julia/blob/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaLowering%2Fsrc%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaLowering%2Fsrc%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fcompat.jl?ref=33f036b0c603f8631733b52dd7c0db999a71467a",
      "patch": "@@ -656,6 +656,12 @@ end\n isa_lowering_ast_node(@nospecialize(e)) =\n     e isa Symbol || e isa QuoteNode || e isa Expr # || e isa GlobalRef\n \n+function is_expr_value(st::SyntaxTree)\n+    k = kind(st)\n+    return JuliaSyntax.is_literal(k) || k === K\"Value\" ||\n+        k === K\"core\" && st.name_val === \"nothing\"\n+end\n+\n function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)\n     st = if e === Core.nothing\n         # e.value can't be nothing in `K\"Value\"`, so represent with K\"core\"\n@@ -692,7 +698,6 @@ function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)\n     # elseif e isa GlobalRef\n         # TODO: Better-behaved as K\"globalref\", but lowering doesn't know this\n     else\n-        @assert !isa_lowering_ast_node(e)\n         # We may want additional special cases for other types where\n         # `Base.isa_ast_node(e)`, but `K\"Value\"` should be fine for most, since\n         # most are produced in or after lowering\n@@ -702,26 +707,27 @@ function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)\n         end\n         setattr!(newleaf(graph, src, K\"Value\"), :value, e)\n     end\n+    @assert isa_lowering_ast_node(e) || is_expr_value(st)\n \n     return st._id, src\n end\n \n function est_to_expr(st::SyntaxTree)\n     k = kind(st)\n-    return if k === K\"Identifier\"\n+    return if k === K\"core\" && numchildren(st) === 0 && st.name_val === \"nothing\"\n+        nothing\n+    elseif is_leaf(st) && hasattr(st, :name_val)\n         n = Symbol(st.name_val)\n         hasattr(st, :scope_layer) ? Expr(:scope_layer, n, st.scope_layer) : n\n-    elseif k === K\"Value\"\n+    elseif is_leaf(st) && is_expr_value(st)\n         v = st.value\n-        # Let `kind(st) === K\"Value\"` with `st.value isa Symbol` (or other AST\n-        # node).  Since we enforce that this is never produced by the reverse\n-        # Expr->SyntaxTree transformation, there is no lonely Expr for which\n-        # `st` is the only SyntaxTree representation.  This means we can pick\n-        # some other expr this represents, namely Expr(`(inert ,st.value))\n-        # rather than Expr(st.value).\n+        # Let `st.value isa Symbol` (or other AST node).  Since we enforce that\n+        # this is never produced by the reverse Expr->SyntaxTree transformation,\n+        # there is no lonely Expr for which `st` is the only SyntaxTree\n+        # representation.  This means we can pick some other expr this\n+        # represents, namely Expr(`(inert ,st.value)) rather than\n+        # Expr(st.value).\n         isa_lowering_ast_node(v) ? QuoteNode(v) : v\n-    elseif k === K\"core\" && numchildren(st) === 0 && st.name_val === \"nothing\"\n-        nothing\n     elseif k === K\"inert\"\n         QuoteNode(est_to_expr(st[1]))\n     else"
    },
    {
      "sha": "d41ada8635184e9b9d17f19df916f969eed9590a",
      "filename": "JuliaLowering/src/kinds.jl",
      "status": "modified",
      "additions": 0,
      "deletions": 7,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaLowering%2Fsrc%2Fkinds.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaLowering%2Fsrc%2Fkinds.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fkinds.jl?ref=33f036b0c603f8631733b52dd7c0db999a71467a",
      "patch": "@@ -14,14 +14,8 @@ function _register_kinds()\n             \"gc_preserve\"\n             \"gc_preserve_begin\"\n             \"gc_preserve_end\"\n-            # A literal Julia value of any kind, as might be inserted into the\n-            # AST during macro expansion\n-            \"Value\"\n             # A (quoted) `Symbol`\n             \"Symbol\"\n-            # QuoteNode; not quasiquote\n-            \"inert\"\n-            \"unknown_head\"\n             # TODO: Use `meta` for inbounds and loopinfo etc?\n             \"inbounds\"\n             \"boundscheck\"\n@@ -92,7 +86,6 @@ function _register_kinds()\n             \"_typevars\" # used for supplying already-allocated `TypeVar`s to `where`\n             \"with_static_parameters\"\n             \"top\"\n-            \"core\"\n             \"lambda\"\n             # \"A source location literal\" - a node which exists only to record\n             # a sourceref"
    },
    {
      "sha": "a8722c14ad5236f5c98202d30b50397af351522e",
      "filename": "JuliaLowering/test/compat.jl",
      "status": "modified",
      "additions": 120,
      "deletions": 68,
      "changes": 188,
      "blob_url": "https://github.com/JuliaLang/julia/blob/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaLowering%2Ftest%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaLowering%2Ftest%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fcompat.jl?ref=33f036b0c603f8631733b52dd7c0db999a71467a",
      "patch": "@@ -642,10 +642,86 @@ end\n     \"\"\"; expr_compat_mode=true) == 0xE\n end\n \n-@testset \"Expr<->EST\" begin\n+const JL_DIR = joinpath(@__DIR__, \"..\")\n+\n+# copied from JuliaSyntax/test/parse_packages.jl\n+function find_source_in_path(basedir)\n+    src_list = String[]\n+    for (root, dirs, files) in walkdir(basedir)\n+        append!(src_list, (joinpath(root, f) for f in files\n+                               if endswith(f, \".jl\") && (p = joinpath(root,f); !islink(p) && isfile(p))))\n+    end\n+    src_list\n+end\n+\n+function find_diff(e1, e2, loc=Ref(LineNumberNode(0)))\n+    if expr_equal_forgiving(e1, e2)\n+        return nothing, nothing\n+    elseif !(e1 isa Expr && e2 isa Expr) ||\n+        e1.head !== e2.head ||\n+        length(e1.args) !== length(e2.args)\n+        return (e1, e2), (loc[])\n+    else\n+        for i in 1:length(e1.args)\n+            e1.args[i] isa LineNumberNode && (loc[] = e1.args[i])\n+            (diff, path) = find_diff(e1.args[i], e2.args[i], loc)\n+            isnothing(diff) || return (diff, (e1.head, i, path))\n+        end\n+    end\n+end\n+\n+function test_each_in_path(test_f::Function, basedir)\n+    ran = 0\n+    for filepath in find_source_in_path(basedir)\n+        @testset \"$(relpath(filepath, basedir))\" begin\n+            str = try\n+                read(filepath, String)\n+            catch\n+                continue\n+            end\n+            ran += test_f(str)\n+        end\n+    end\n+    @test ran > 0\n+    nothing\n+end\n+\n+# ignore_linenums=false is good for checking, but too noisy to use much\n+function expr_equal_forgiving(e1, e2; ignore_linenums=true)\n+    !(e1 isa Expr && e2 isa Expr) && return e1 == e2\n+    if ignore_linenums\n+        e1, e2 = let e1b = Expr(e1.head), e2b = Expr(e2.head)\n+            e1b.args = filter(x->!(x isa LineNumberNode), e1.args)\n+            e2b.args = filter(x->!(x isa LineNumberNode), e2.args)\n+            e1b, e2b\n+        end\n+    end\n+\n+    e1.head === e2.head && length(e1.args) === length(e2.args) &&\n+        all(expr_equal_forgiving(a1, a2; ignore_linenums) for (a1, a2) in\n+                zip(e1.args, e2.args))\n+end\n \n-    local roundtrip = e->JuliaLowering.est_to_expr(JuliaLowering.expr_to_est(e))\n-    local roundtrip_eq = x->x==roundtrip(x)\n+@testset \"Expr<->EST\" begin\n+    function roundtrip(e)\n+        JuliaLowering.est_to_expr(JuliaLowering.expr_to_est(e))\n+    end\n+    function roundtrip_eq(str)\n+        e_ref = try\n+            JuliaSyntax.parseall(Expr, str)\n+        catch _\n+            nothing\n+        end\n+        isnothing(e_ref) && return 0\n+        e_test = roundtrip(e_ref)\n+        pass = expr_equal_forgiving(e_test, e_ref)\n+        @test pass\n+        if !pass\n+            ((e_ref_min, e_test_min), indices) = find_diff(e_ref, e_test)\n+            @info \"diff:\" e_ref_min e_test_min indices # e_ref e_test\n+        end\n+        return 1\n+    end\n \n     local expr_syntax = Any[\n         LineNumberNode(1)\n@@ -696,72 +772,8 @@ end\n             JL.est_to_expr(@ast_ [K\"inert\" [K\"inert\" [K\"call\" 1::K\"Value\"]]]) ==\n             QuoteNode(QuoteNode(Expr(:call, 1)))\n     end\n-\n-    # copied from JuliaSyntax/test/parse_packages.jl\n-    function find_source_in_path(basedir)\n-        src_list = String[]\n-        for (root, dirs, files) in walkdir(basedir)\n-            append!(src_list, (joinpath(root, f) for f in files\n-                                   if endswith(f, \".jl\") && (p = joinpath(root,f); !islink(p) && isfile(p))))\n-        end\n-        src_list\n-    end\n-\n-    function find_diff(e1, e2, indices=Int[])\n-        if expr_equal_forgiving(e1, e2)\n-            return nothing\n-        elseif !(e1 isa Expr && e2 isa Expr) ||\n-            e1.head !== e2.head ||\n-            length(e1.args) !== length(e2.args)\n-            return (e1, e2, indices)\n-        else\n-            for i in 1:length(e1.args)\n-                push!(indices, i)\n-                d = find_diff(e1.args[i], e2.args[i], indices)\n-                isnothing(d) || return d\n-                pop!(indices)\n-            end\n-        end\n-    end\n-\n-    function test_each_in_path(f::Function, basedir)\n-        for filepath in find_source_in_path(basedir)\n-            @testset \"$(relpath(filepath, basedir))\" begin\n-                e = try\n-                    JuliaSyntax.parseall(Expr, read(filepath, String))\n-                catch\n-                    continue\n-                end\n-                e2 = f(e)\n-                pass = expr_equal_forgiving(e, e2)\n-                @test pass\n-                if !pass\n-                    (parsed, roundtripped, indices) = find_diff(e, e2)\n-                    @info \"diff:\" outpath parsed roundtripped e e2\n-                end\n-            end\n-        end\n-    end\n-\n-    # ignore_linenums=false is good for checking, but too noisy to use much\n-    function expr_equal_forgiving(e1, e2; ignore_linenums=true)\n-        !(e1 isa Expr && e2 isa Expr) && return e1 == e2\n-        if ignore_linenums\n-            e1, e2 = let e1b = Expr(e1.head), e2b = Expr(e2.head)\n-                e1b.args = filter(x->!(x isa LineNumberNode), e1.args)\n-                e2b.args = filter(x->!(x isa LineNumberNode), e2.args)\n-                e1b, e2b\n-            end\n-        end\n-\n-        e1.head === e2.head && length(e1.args) === length(e2.args) &&\n-            all(expr_equal_forgiving(a1, a2; ignore_linenums) for (a1, a2) in\n-                    zip(e1.args, e2.args))\n-    end\n-\n     @testset \"bulk parsed code, no linenodes\" begin\n-        jl_dir = joinpath(@__DIR__, \"..\")\n-        test_each_in_path(roundtrip, jl_dir)\n+        test_each_in_path(roundtrip_eq, JL_DIR)\n     end\n \n     @testset \"linenodes equal (modules and functions have extra)\" begin\n@@ -785,3 +797,43 @@ end\n         @test e == roundtrip(e)\n     end\n end\n+\n+@testset \"Test RawGreenNode->EST->Expr against RawGreenNode->Expr\" begin\n+    function make_est(str)\n+        e_ref = try\n+            JS.parseall(Expr, str)\n+        catch _\n+            nothing\n+        end\n+        isnothing(e_ref) && return 0\n+        est_test = JS.parseall(SyntaxTree, str; expr_structure=true)\n+        e_test = JL.est_to_expr(est_test)\n+        pass = expr_equal_forgiving(e_test, e_ref)\n+        @test pass\n+        if !pass\n+            ((e_ref_min, e_test_min), indices) = find_diff(e_ref, e_test)\n+            @info \"diff:\" e_ref_min e_test_min indices # e_ref e_test\n+        end\n+        return 1\n+    end\n+\n+    @testset \"bulk parsed code, no linenodes\" begin\n+        test_each_in_path(make_est, JL_DIR)\n+\n+        basedir = joinpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\", \"base\")\n+        test_each_in_path(make_est, basedir)\n+\n+        base_testdir = joinpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\", \"test\")\n+        test_each_in_path(make_est, base_testdir)\n+\n+        @testset \"Parse Julia stdlib at $(Sys.STDLIB)\" begin\n+            for stdlib in readdir(Sys.STDLIB)\n+                fulldir = joinpath(Sys.STDLIB, stdlib)\n+                if isdir(fulldir)\n+                    test_each_in_path(make_est, joinpath(Sys.STDLIB, fulldir))\n+                end\n+            end\n+        end\n+\n+    end\n+end"
    },
    {
      "sha": "57e8eb94b6fc826ed88c6e636c662d0fbc0eb59f",
      "filename": "JuliaSyntax/src/integration/expr.jl",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fintegration%2Fexpr.jl?ref=33f036b0c603f8631733b52dd7c0db999a71467a",
      "patch": "@@ -217,6 +217,12 @@ function parseargs!(retexpr::Expr, loc::LineNumberNode, cursor, source, txtbuf::\n     return (firstchildhead, secondchildhead, firstchildrange)\n end\n \n+function version_to_expr(node)\n+    @assert kind(node) === K\"VERSION\"\n+    nv = numeric_flags(flags(node))\n+    return VersionNumber(1, nv \u00f7 10, nv % 10)\n+end\n+\n _expr_leaf_val(node::SyntaxNode, _...) = node.val\n _expr_leaf_val(cursor::RedTreeCursor, txtbuf::Vector{UInt8}, txtbuf_offset::UInt32) =\n     parse_julia_literal(txtbuf, head(cursor), byte_range(cursor) .+ txtbuf_offset)\n@@ -238,14 +244,13 @@ function node_to_expr(cursor, source, txtbuf::Vector{UInt8}, txtbuf_offset::UInt\n                 Expr(:error) :\n                 Expr(:error, \"$(_token_error_descriptions[k]): `$(source[srcrange])`\")\n         elseif k == K\"VERSION\"\n-            nv = numeric_flags(flags(nodehead))\n-            return VersionNumber(1, nv \u00f7 10, nv % 10)\n+            return version_to_expr(nodehead)\n         else\n             scoped_val = _expr_leaf_val(cursor, txtbuf, txtbuf_offset)\n             val = @isexpr(scoped_val, :scope_layer) ? scoped_val.args[1] : scoped_val\n             if val isa Union{Int128,UInt128,BigInt}\n                 # Ignore the values of large integers and convert them back to\n-                # symbolic/textural form for compatibility with the Expr\n+                # symbolic/textual form for compatibility with the Expr\n                 # representation of these.\n                 str = replace(source[srcrange], '_'=>\"\")\n                 macname = val isa Int128  ? Symbol(\"@int128_str\")  :\n@@ -547,7 +552,8 @@ end\n                 retexpr.head = :(=)\n             else\n                 a1 = args[1]\n-                if @isexpr(a1, :tuple)\n+                if @isexpr(a1, :tuple) &&\n+                    !has_flags(firstchildhead, TRAILING_COMMA_FLAG)\n                     # Convert to weird Expr forms for long-form anonymous functions.\n                     #\n                     # (function (tuple (... xs)) body) ==> (function (... xs) body)"
    },
    {
      "sha": "e27b4225ae43d32fdea42f4a41958a65a2508c4f",
      "filename": "JuliaSyntax/src/julia/kinds.jl",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fjulia%2Fkinds.jl?ref=33f036b0c603f8631733b52dd7c0db999a71467a",
      "patch": "@@ -1057,6 +1057,20 @@ register_kinds!(JuliaSyntax, 0, [\n         \"wrapper\"\n     \"END_SYNTAX_KINDS\"\n \n+    # Kinds not corresponding to surface syntax in RawGreenNode, but required\n+    # for parsing to a provenance-containing structure that is compatible with\n+    # Expr.  May shrink with syntax evolution.\n+    \"BEGIN_SYNTAXTREE_KINDS\"\n+        # A literal Julia value of any kind, as might be inserted into the\n+        # AST during macro expansion.  Only used in parsing to SyntaxTree.\n+        \"Value\"\n+        \"core\"\n+        \"unknown_head\"\n+        \"flatten\"\n+        # QuoteNode; not quasiquote\n+        \"inert\"\n+    \"END_SYNTAXTREE_KINDS\"\n+\n     # Special tokens\n     \"TOMBSTONE\"    # Empty placeholder for kind to be filled later\n     \"None\"         # Never emitted by lexer/parser"
    },
    {
      "sha": "fb37e2581e24878c3dfbae8a6e8e88437da92ac8",
      "filename": "JuliaSyntax/src/porcelain/syntax_graph.jl",
      "status": "modified",
      "additions": 505,
      "deletions": 4,
      "changes": 509,
      "blob_url": "https://github.com/JuliaLang/julia/blob/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/33f036b0c603f8631733b52dd7c0db999a71467a/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaSyntax%2Fsrc%2Fporcelain%2Fsyntax_graph.jl?ref=33f036b0c603f8631733b52dd7c0db999a71467a",
      "patch": "@@ -489,11 +489,13 @@ end\n function Base.push!(v::SyntaxList, ex::SyntaxTree)\n     check_compatible_graph(v, ex)\n     push!(v.ids, ex._id)\n+    v\n end\n \n function Base.pushfirst!(v::SyntaxList, ex::SyntaxTree)\n     check_compatible_graph(v, ex)\n     pushfirst!(v.ids, ex._id)\n+    v\n end\n \n function Base.similar(v::SyntaxList, size::Tuple=Base.size(v.ids))\n@@ -525,10 +527,19 @@ function Base.pop!(v::SyntaxList)\n     SyntaxTree(v.graph, pop!(v.ids))\n end\n \n+function Base.popfirst!(v::SyntaxList)\n+    SyntaxTree(v.graph, popfirst!(v.ids))\n+end\n+\n function Base.popat!(v::SyntaxList, i::Integer)\n     SyntaxTree(v.graph, popat!(v.ids, i))\n end\n \n+function Base.insert!(v::SyntaxList, i::Integer, st::SyntaxTree)\n+    insert!(v.ids, i, st._id)\n+    v\n+end\n+\n function Base.resize!(v::SyntaxList, n)\n     resize!(v.ids, n)\n     v\n@@ -731,17 +742,19 @@ end\n \n #-------------------------------------------------------------------------------\n # RawGreenNode->SyntaxTree\n+# WIP: expr_structure param will be deleted\n \n function build_tree(::Type{SyntaxTree}, stream::ParseStream;\n-                                filename=nothing, first_line=1)\n+                    filename=nothing, first_line=1,\n+                    expr_structure=false)\n     cursor = RedTreeCursor(stream)\n     graph = SyntaxGraph()\n     sf = SourceFile(stream; filename, first_line)\n     source = SourceRef(sf, first_byte(stream), last_byte(stream))\n     cs = SyntaxList(graph)\n     for c in reverse_toplevel_siblings(cursor)\n         is_trivia(c) && !is_error(c) && continue\n-        push!(cs, SyntaxTree(graph, sf, c))\n+        push!(cs, SyntaxTree(graph, sf, c; expr_structure))\n     end\n     # There may be multiple non-trivia toplevel nodes (e.g. parse error)\n     length(cs) === 1 && return only(cs)\n@@ -752,15 +765,20 @@ function build_tree(::Type{SyntaxTree}, stream::ParseStream;\n     return SyntaxTree(graph, id)\n end\n \n-function SyntaxTree(graph::SyntaxGraph, sf::SourceFile, cursor::RedTreeCursor)\n+function SyntaxTree(graph::SyntaxGraph, sf::SourceFile, cursor::RedTreeCursor; expr_structure)\n     ensure_attributes!(graph, kind=Kind, syntax_flags=UInt16,\n                        source=SourceAttrType, value=Any, name_val=String)\n     green_id = GC.@preserve sf begin\n         raw_offset, txtbuf = _unsafe_wrap_substring(sf.code)\n         offset = raw_offset - sf.byte_offset\n         _insert_green(graph, sf, txtbuf, offset, cursor)\n     end\n-    out = _green_to_ast(K\"None\", SyntaxTree(graph, green_id))\n+    gst = SyntaxTree(graph, green_id)\n+    if expr_structure\n+        out = _green_to_est(gst, 0, gst)\n+    else\n+        out = _green_to_ast(K\"None\", gst)\n+    end\n     @assert !isnothing(out) \"SyntaxTree requires >0 nontrivia nodes\"\n     return out\n end\n@@ -857,3 +875,486 @@ function _map_green_to_ast(parent::Kind, cs::SyntaxList; eq_to_kw=false)\n     end\n     return out\n end\n+\n+#-------------------------------------------------------------------------------\n+# WIP: RawGreenNode->EST.  This will replace `_green_to_ast` above, and could\n+# replace `node_to_expr` later.\n+\n+\"\"\"\n+Convert green `st` to a SyntaxTree with Expr structure.  `parent_i` is the final\n+position of `convert(st)` (our return value) within `convert(parent)`.  If\n+`parent_i == 0`, neither it nor our `parent` are known or relevant to this\n+conversion.\n+\n+We can't assume much about `st` since it's anything the parser produces.  Our\n+correctness is defined against existing text->Expr transformations.\n+\n+All node rearrangements and head changes are determined before recursing on\n+children, unlike in `node_to_expr`.  This is because these nodes are not mutable\n+and filling the graph with temporary nodes to fix up later is less desirable,\n+and also because knowing our parent's kind and our position within it\n+ahead-of-time makes conversion simpler.  By default, for each node `st`, we\n+  1. let `cs` be `children(st)` minus (non-recursively) all trivia and parens\n+  2. rearrange `cs` based on length(cs), their/our/parent's kind/flags, etc.\n+  3. let `ret_cs` be `map(convert, cs)`\n+  4. return our new node `convert(st)` with `ret_cs` as children.\n+However, we can stop and return an answer between any of these steps.  For\n+example, deleting a child is easy in (2), but new non-leaf children we insert\n+should be added to `ret_cs` rather than `cs` (unless the new child has\n+pre-transformation structure and we're OK with step 3 creating it again).\n+\"\"\"\n+function _green_to_est(parent::SyntaxTree, parent_i::Int,\n+                       st::SyntaxTree; kw_in_params=false)\n+    if !should_include_node(st)\n+        @assert kind(parent) === K\"None\" && parent_i === 0\n+        return nothing\n+    end\n+\n+    graph = syntax_graph(st)\n+    k = kind(st)\n+    coreref(s::String) = setattr!(newleaf(graph, st, K\"core\"), :name_val, s)\n+    symleaf(s::String) = setattr!(newleaf(graph, st, K\"Identifier\"), :name_val, s)\n+    valleaf(@nospecialize(v)) = setattr!(newleaf(graph, st, K\"Value\"), :value, v)\n+\n+    if is_leaf(st)\n+        return if k === K\"CmdMacroName\" || k === K\"StrMacroName\"\n+            name = lower_identifier_name(st.name_val, k)\n+            symleaf(name)\n+        elseif k === K\"VERSION\"\n+            valleaf(version_to_expr(st))\n+        elseif (v = get(st, :value, nothing); v isa Union{Int128,UInt128,BigInt})\n+            # syntax TODO: likely unnecessary; this is just to match RGN->Expr,\n+            # which added this to match flisp parsing text->Expr.\n+            macname = v isa Int128 ? \"@int128_str\" :\n+                v isa UInt128 ? \"@uint128_str\" : \"@big_str\"\n+            mac = valleaf(GlobalRef(Core, Symbol(macname)))\n+            arg = valleaf(replace(sourcetext(st), '_'=>\"\"))\n+            ret_cids = tree_ids(mac, coreref(\"nothing\"), arg)\n+            newnode(graph, st, K\"macrocall\", ret_cids)\n+        else\n+            st\n+        end\n+    end\n+\n+    # Non-leaf cases: each branch should either set `ret_k` and `cs` or recurse\n+    # manually and return a finished SyntaxTree\n+    ret_k::Kind = k\n+    cs = preprocessed_green_children(st)\n+    n_cs = length(cs)\n+\n+    if k === K\"string\" && n_cs > 0\n+        return _string_to_est(st, cs; unwrap_literal=true)\n+    elseif k === K\"cmdstring\" && n_cs > 0\n+        # (cmdstring _...) => (macrocall Core.@cmd lno joined_str)\n+        cmd_arg = _string_to_est(st, cs; unwrap_literal=true)\n+        loc_st = valleaf(source_location(LineNumberNode, st))\n+        return newnode(graph, st, K\"macrocall\", tree_ids(\n+            valleaf(GlobalRef(Core, Symbol(\"@cmd\"))), loc_st, cmd_arg))\n+    elseif k === K\"macro_name\" && n_cs === 1\n+        # \"M.@x\" => (. M (macro_name x)) => (. M @x)\n+        # \"@M.x\" => (macro_name (. M x)) => (. M @x)\n+        #           (macro_name else) => else\n+        if kind(cs[1]) === K\"Identifier\"\n+            return symleaf(lower_identifier_name(cs[1].name_val, K\"macro_name\"))\n+        else\n+            inner_st = cs[1]\n+            inner_cs = preprocessed_green_children(inner_st)\n+            if (length(inner_cs) === 2 && kind(inner_st) === K\".\" &&\n+                kind(inner_cs[2]) === K\"Identifier\")\n+                (lhs, raw_m) = _green_to_est(cs[1], 1, inner_cs[1]), inner_cs[2]\n+                mname_s = lower_identifier_name(raw_m.name_val, K\"macro_name\")\n+                mname = setattr!(mkleaf(raw_m), :name_val, mname_s)\n+                mname_inert = newnode(graph, raw_m, K\"inert\", tree_ids(mname))\n+                return mknode(inner_st, tree_ids(lhs, mname_inert))\n+            else\n+                return _green_to_est(parent, 1, inner_st)\n+            end\n+        end\n+    elseif k === K\"?\"\n+        ret_k = K\"if\"\n+    elseif k === K\"op=\" && n_cs === 3\n+        # (op= a + b) => (+= a b)\n+        # (.op= a + b) => (.+= a b) below\n+        op_s = string(cs[2]) * '='\n+        lhs = _green_to_est(st, 0, cs[1])\n+        rhs = _green_to_est(st, 0, cs[3])\n+        out = newnode(graph, st, K\"unknown_head\", tree_ids(lhs, rhs))\n+        return setattr!(out, :name_val, op_s)\n+    elseif k === K\".op=\" && n_cs === 3\n+        op_s = '.' * string(cs[2]) * '='\n+        lhs = _green_to_est(st, 0, cs[1])\n+        rhs = _green_to_est(st, 0, cs[3])\n+        out = newnode(graph, st, K\"unknown_head\", tree_ids(lhs, rhs))\n+        return setattr!(out, :name_val, op_s)\n+    elseif k === K\"macrocall\" && n_cs > 0\n+        # LineNumberNodes are not usually added to the tree as they are in Expr,\n+        # but this specifically inserts the macrocall child for compatibility\n+        loc_st = let loc = source_location(LineNumberNode, st)\n+            if n_cs >= 2 && kind(cs[2]) === K\"VERSION\"\n+                v = version_to_expr(popat!(cs, 2))\n+                loc = Core.MacroSource(loc, v)\n+            end\n+            valleaf(loc)\n+        end\n+        insert!(cs, 2, loc_st)\n+        # foo`x` parses to (macrocall foo::CmdMacroName (cmdstring ::CmdString))\n+        # so we need to unwrap the CmdString or else we get two macrocalls\n+        if n_cs >= 2 && kind(cs[1]) === K\"CmdMacroName\"\n+            ret_cs = _map_green_to_est(st, cs)\n+            ret_cs[3] = ret_cs[3][3] # node leak\n+            return mknode(st, ret_cs)\n+        end\n+        do_ex = kind(cs[end]) === K\"do\" ? pop!(cs) : nothing\n+        _reorder_parameters!(cs, 3)\n+        !isnothing(do_ex) && return _make_do_expression(st, cs, do_ex)\n+    elseif k === K\"doc\"\n+        # (doc str obj) => (macrocall Core.@doc lno str obj)\n+        ret_k = K\"macrocall\"\n+        pushfirst!(cs, valleaf(source_location(LineNumberNode, st)))\n+        pushfirst!(cs, valleaf(GlobalRef(Core, Symbol(\"@doc\"))))\n+    elseif k === K\"dotcall\" || k === K\"call\" && n_cs > 0\n+        if is_infix_op_call(st) || is_postfix_op_call(st)\n+            cs[2], cs[1] = cs[1], cs[2]\n+        end\n+        if is_postfix_op_call(st) && kind(cs[1]) == K\"Identifier\" &&\n+            cs[1].name_val === \"'\"\n+            popfirst!(cs)\n+            ret_k = K\"'\"\n+        end\n+        do_ex = kind(cs[end]) === K\"do\" ? pop!(cs) : nothing\n+        _reorder_parameters!(cs, 2)\n+        if k === K\"dotcall\"\n+            if is_prefix_call(st)\n+                # (dotcall f args...) => (. f (tuple args...))\n+                ret_cs = _map_green_to_est(st, cs)\n+                tuple = newnode(graph, st, K\"tuple\", ret_cs[2:end])\n+                return newnode(graph, st, K\".\", tree_ids(ret_cs[1], tuple))\n+            else\n+                # (dotcall + args...) => (call .+ args...)\n+                ret_k = K\"call\"\n+                if kind(cs[1]) === K\"Identifier\"\n+                    cs[1] = symleaf('.' * cs[1].name_val)\n+                end\n+            end\n+        end\n+        !isnothing(do_ex) && return _make_do_expression(st, cs, do_ex)\n+    elseif k === K\".\"\n+        if n_cs === 2\n+            # (. lhs rhs) => (. lhs (inert rhs))\n+            lhs = _green_to_est(st, 1, cs[1])\n+            rhs = _green_to_est(st, 2, cs[2])\n+            inert_rhs = kind(rhs) in KSet\"quote inert\" ? rhs :\n+                newnode(graph, cs[2], K\"inert\", tree_ids(rhs))\n+            return mknode(st, tree_ids(lhs, inert_rhs))\n+        elseif n_cs === 1\n+            # (. x) => (. x) or .x\n+            # TODO: This is the one place where K\"parens\" change the result,\n+            # meaning that either Expr is doing something wrong or SyntaxNode is\n+            # deleting semantics.\n+            paren_st = filter(should_include_node, children(parent))[1]\n+            coalesce_dot = !(kind(paren_st) === K\"parens\") && parent_i === 1 &&\n+                kind(parent) in KSet\"call dotcall curly quote\"\n+\n+            if (coalesce_dot || is_syntactic_operator(kind(cs[1])) ||\n+                kind(parent) === K\"comparison\" && iseven(parent_i))\n+                return symleaf('.' * cs[1].name_val)\n+            end\n+        end\n+    elseif k === K\"ref\" || k === K\"curly\"\n+        _reorder_parameters!(cs, 2)\n+    elseif k === K\"for\" && n_cs === 2\n+        # (for (iteration iter1) body) => (for iter1 body)\n+        iters = preprocessed_green_children(cs[1])\n+        if length(iters) === 1\n+            cs[1] = iters[1]\n+        end\n+    elseif k === K\"iteration\"\n+        # (for (iteration iter1 iters...) body) => (for (block iter1 iters...) body)\n+        @assert kind(parent) === K\"for\" && parent_i === 1\n+        ret_k = K\"block\"\n+    elseif k === K\"vect\" || k === K\"braces\"\n+        _reorder_parameters!(cs, 1)\n+    elseif k === K\"tuple\"\n+        # Unwrap singleton, no-trailing-comma tuple in a couple cases:\n+        # (function (tuple (... xs)) body) => (function (... xs) body)\n+        # (-> (tuple _) body) => (-> _ body), assuming _ not parameters\n+        if n_cs === 1 && parent_i === 1 &&\n+            !has_flags(st, TRAILING_COMMA_FLAG)\n+            p_k = kind(parent)\n+            c_k = kind(cs[1])\n+            if (p_k === K\"function\" && c_k === K\"...\") ||\n+                (p_k === K\"->\" && c_k !== K\"parameters\")\n+                return _green_to_est(parent, parent_i, cs[1])\n+            end\n+        elseif n_cs === 2 && kind(parent) === K\"->\" && parent_i === 1 &&\n+            kind(cs[2]) === K\"parameters\" && kind(cs[1]) !== K\"...\"\n+            # This case should really be deleted.\n+            # (-> (tuple x (parameters y)) _) => (-> (block x y) _)\n+            c2_cs = preprocessed_green_children(cs[2])\n+            if length(c2_cs) === 0\n+                ret_k = K\"block\"\n+                pop!(cs)\n+            elseif length(c2_cs) === 1\n+                ret_k = K\"block\"\n+                cs[2] = c2_cs[1]\n+            end\n+        end\n+        _reorder_parameters!(cs, 1)\n+    elseif k === K\"where\" && n_cs === 2\n+        # (where lhs (braces a b c)) => (where lhs a b c)\n+        if kind(cs[2]) === K\"braces\"\n+            rhs = pop!(cs)\n+            append!(cs, preprocessed_green_children(rhs))\n+            _reorder_parameters!(cs, 2)\n+        end\n+    elseif k === K\"try\"\n+        # anything => (try try_block e catch_block [finally_block] [else_block])\n+        try_ = cs[1]\n+        st_false = valleaf(false)\n+        catch_var = catch_ = else_ = finally_ = st_false\n+        for c in cs[2:end]\n+            inner_cs = preprocessed_green_children(c)\n+            if kind(c) === K\"catch\"\n+                if kind(inner_cs[1]) !== K\"Placeholder\"\n+                    catch_var = inner_cs[1]\n+                end\n+                catch_ = inner_cs[2]\n+            elseif kind(c) === K\"else\"\n+                else_ = only(inner_cs)\n+            elseif kind(c) === K\"finally\"\n+                finally_ = only(inner_cs)\n+            elseif kind(c) === K\"error\"\n+                return mknode(st, cs) # give up\n+            else\n+                @assert false \"Illegal subclause in `try`\"\n+            end\n+        end\n+        empty!(cs)\n+        push!(cs, try_, catch_var, catch_)\n+        if finally_ != st_false || else_ != st_false\n+            push!(cs, finally_)\n+            if else_ != st_false\n+                push!(cs, else_)\n+            end\n+        end\n+    elseif k === K\"generator\" && n_cs >= 2\n+        # let (g2 x iter) mean (generator x iter.children...)\n+        # (generator val iter_1 ... iter_n) =>\n+        # (flatten (g2 (... (flatten (g2 (g2 val i_n) i_{n-1})) ...) i_1))\n+        g_out = _green_to_est(st, 1, popfirst!(cs))\n+        for c in Iterators.reverse(cs)\n+            gen_cs = let rest = kind(c) === K\"iteration\" ?\n+                preprocessed_green_children(c) : SyntaxList(graph, tree_ids(c))\n+                rest = _map_green_to_est(st, rest; undef_parent=true)\n+                pushfirst!(rest, g_out)\n+            end\n+            g_out = mknode(st, gen_cs)\n+            if c !== cs[end]\n+                g_out = newnode(graph, c, K\"flatten\", tree_ids(g_out))\n+            end\n+        end\n+        return setattr!(g_out, :source, st._id) # outermost provenance\n+    elseif k === K\"filter\"\n+        @assert n_cs === 2\n+        # (filter (iteration is...) cond) => (filter cond is...)\n+        cond = pop!(cs)\n+        cs = preprocessed_green_children(cs[1])\n+        pushfirst!(cs, cond)\n+    elseif k === K\"in\"\n+        ret_k = K\"=\"\n+    elseif k === K\"nrow\" || k === K\"ncat\"\n+        pushfirst!(cs, valleaf(numeric_flags(flags(st))))\n+    elseif k === K\"typed_ncat\"\n+        insert!(cs, 2, valleaf(numeric_flags(flags(st))))\n+    elseif k === K\"elseif\"\n+        # (elseif cond body) => (elseif (block cond) body)\n+        # RGN->Expr block-wraps for linenodes; we do it for parity\n+        ret_cs = _map_green_to_est(st, cs)\n+        ret_cs[1] = newnode(graph, cs[1], K\"block\", tree_ids(ret_cs[1]))\n+        return mknode(st, ret_cs)\n+    elseif k === K\"->\" && kind(cs[2]) !== K\"block\"\n+        ret_cs = _map_green_to_est(st, cs)\n+        ret_cs[2] = newnode(graph, cs[2], K\"block\", tree_ids(ret_cs[2]))\n+        return mknode(st, ret_cs)\n+    elseif k === K\"function\" && n_cs >= 2 &&\n+        has_flags(st, SHORT_FORM_FUNCTION_FLAG)\n+        # (function-= callex body) => (= callex (block body))\n+        # exception: no block on \"x' = y\", or if body is already a block\n+        if kind(cs[2]) !== K\"block\" && !is_postfix_op_call(cs[1])\n+            ret_cs = _map_green_to_est(st, cs)\n+            ret_cs[2] = newnode(graph, cs[2], K\"block\", tree_ids(ret_cs[2]))\n+            return newnode(graph, st, K\"=\", ret_cs)\n+        end\n+        ret_k = K\"=\"\n+    elseif k === K\"module\"\n+        not_bare = valleaf(!has_flags(st, BARE_MODULE_FLAG))\n+        insert!(cs, kind(cs[1]) === K\"VERSION\" ? 2 : 1, not_bare)\n+    elseif k === K\"quote\" && n_cs === 1\n+        # (quote something_simple) => (inert something_simple)\n+        ret_c = _green_to_est(st, 1, cs[1])\n+        return is_leaf(ret_c) && kind(ret_c) !== K\"Bool\" ?\n+            newnode(graph, st, K\"inert\", tree_ids(ret_c)) :\n+            mknode(st, tree_ids(ret_c))\n+    elseif k === K\"do\"\n+        ret_k = K\"->\"\n+    elseif k === K\"block\"\n+        # (let (block x) _...) => (let x _...)\n+        # (let (block (= x y)) _...) => (let (= x y) _...)\n+        # (let (block (:: x y)) _...) => (let (:: x y) _...)\n+        # (struct _ (block (doc \"foo\" field1) (doc \"bar\" field2))) =>\n+        # (struct _ (block \"foo\" field1 \"bar\" field2))\n+        if kind(parent) === K\"let\" && parent_i === 1 && n_cs === 1\n+            out = _green_to_est(st, 1, cs[1])\n+            return kind(out) in KSet\"Identifier = ::\" ? out :\n+                mknode(st, tree_ids(out))\n+        elseif kind(parent) === K\"struct\" && parent_i === 3\n+            cs_tmp = SyntaxList(cs)\n+            for c in cs\n+                kind(c) === K\"doc\" ?\n+                    append!(cs_tmp, preprocessed_green_children(c)) :\n+                    push!(cs_tmp, c)\n+            end\n+            cs = cs_tmp\n+        end\n+    elseif (k === K\"local\" || k === K\"global\") && n_cs === 1\n+        # (local (const _)) => (const (local _))\n+        # (local (tuple a b c)) => (local a b c)\n+        if kind(cs[1]) === K\"const\"\n+            ret_c1_cs = _map_green_to_est(st, preprocessed_green_children(cs[1]))\n+            ret_cs = tree_ids(mknode(st, ret_c1_cs))\n+            return mknode(cs[1], ret_cs)\n+        elseif kind(cs[1]) === K\"tuple\"\n+            cs = preprocessed_green_children(cs[1])\n+        end\n+    elseif k === K\"return\" && n_cs === 0\n+        push!(cs, coreref(\"nothing\"))\n+    elseif k === K\"juxtapose\"\n+        ret_k = K\"call\"\n+        pushfirst!(cs, symleaf(\"*\"))\n+    elseif k === K\"struct\"\n+        is_mutable = valleaf(has_flags(st, MUTABLE_FLAG))\n+        pushfirst!(cs, is_mutable)\n+    elseif k === K\"importpath\"\n+        ret_k = K\".\"\n+        for i in eachindex(cs)\n+            if kind(cs[i]) === K\"inert\"\n+                inner_cs = preprocessed_green_children(cs[i])\n+                length(inner_cs) === 1 && (cs[i] = only(inner_cs))\n+            end\n+        end\n+    elseif k === K\"wrapper\" # parse errors only\n+        ret_k = K\"block\"\n+    elseif k === K\"parameters\"\n+        kw_in_params = kind(parent) === K\"parameters\" && parent_i === 1 ?\n+            kw_in_params : !(kind(parent) in KSet\"vect curly braces ref\")\n+    elseif k === K\"=\"\n+        p_k = kind(parent)\n+        because_params = p_k === K\"parameters\" && parent_i >= 1 && kw_in_params\n+        because_call = parent_i > 1 && (p_k == K\"ref\" ||\n+            p_k in KSet\"call dotcall\" && is_prefix_call(parent))\n+        ret_k = because_params || because_call ? K\"kw\" : K\"=\"\n+    end\n+\n+    # Recurse on `cs`.  If no children change, just return `st`.\n+    ret_cs = _map_green_to_est(st, cs; kw_in_params)\n+    return ret_cs.ids == children(st).ids && ret_k == kind(st) ?\n+        st : setattr!(mknode(st, ret_cs), :kind, ret_k)\n+end\n+\n+function _map_green_to_est(parent::SyntaxTree, cs::SyntaxList;\n+                           kw_in_params=false, undef_parent=false)\n+    ret_cs = SyntaxList(cs.graph)\n+    for (i, c) in enumerate(cs)\n+        new_c = _green_to_est(parent, undef_parent ? 0 : i, c; kw_in_params)\n+        @assert should_include_node(new_c)\n+        push!(ret_cs, new_c)\n+    end\n+    ret_cs\n+end\n+\n+# When converting, first delete trivia and wrapper nodes in children so we can\n+# observe child kinds before recursing, thus creating fewer \"temporary\" nodes\n+function preprocessed_green_children(st::SyntaxTree)\n+    cs = filter(should_include_node, children(st))\n+    for i in eachindex(cs)\n+        while kind(cs[i]) in KSet\"var char parens\"\n+            inner_cs = preprocessed_green_children(cs[i])\n+            if length(inner_cs) === 1\n+                cs[i] = inner_cs[1]\n+            end\n+        end\n+    end\n+    return cs\n+end\n+\n+# (call f a b (parameters c d) (parameters e)) =>\n+# (call f (parameters (parameters e) c d) a b)\n+function _reorder_parameters!(cs::SyntaxList, params_pos::Int)\n+    (length(cs) > params_pos && kind(cs[end]) === K\"parameters\") || return cs\n+    local param_ball = pop!(cs)\n+    while length(cs) >= 1 && kind(cs[end]) === K\"parameters\"\n+        next_ball_cs = pushfirst!(copy(children(cs[end])), param_ball)\n+        # `mknode` leaks nodes, but having multiple `parameters` blocks is\n+        # extremely rare nonsense syntax (`f(a,b;c=d;e)`)\n+        param_ball = mknode(cs[end], next_ball_cs)\n+        pop!(cs)\n+    end\n+    insert!(cs, params_pos, param_ball)\n+    nothing\n+end\n+\n+# (call args... (do _...)) -> (do (call args...) (-> _...))\n+#\n+# Expects preprocessed and rearranged `args`\n+function _make_do_expression(st::SyntaxTree, args::SyntaxList, doex::SyntaxTree)\n+    ret_doex = _green_to_est(st, 0, doex)\n+    ret_callex = mknode(st, _map_green_to_est(st, args))\n+    return newnode(st._graph, st, K\"do\", tree_ids(ret_callex, ret_doex))\n+end\n+\n+# A `string` or `cmdstring` may have multiple literal strings within (from\n+# newlines when triple-quoting).  A `string` may have interpolated values.\n+#\n+# (string \"a\" \"b\" \"c\") => \"abc\" # unwrap_literal=true\n+# (string \"a\" \"b\" \"c\" 1) => (string \"abc\" 1)\n+# (string \"a\" \"b\" (string \"c\" \"d\")) => (string \"ab\" (string \"cd\"))\n+#\n+# (cmdstring \"a\"::CmdString \"b\"::CmdString) => \"ab\"::CmdString\n+#\n+# Converting children-first (as _string_to_Expr does) would make this much\n+# harder by converting literal strings without the parent's knowledge\n+function _string_to_est(st::SyntaxTree, cs::SyntaxList; unwrap_literal)\n+    ret_cs = SyntaxList(st)\n+    literal_k = kind(st) === K\"cmdstring\" ? K\"CmdString\" : K\"String\"\n+    prev_str = cur_str = false\n+    next_str = length(cs) > 0 && kind(cs[1]) === literal_k\n+    buf = IOBuffer()\n+    for i in eachindex(cs)\n+        c = cs[i]\n+        (prev_str, cur_str) = (cur_str, next_str)\n+        next_str = i != lastindex(cs) && kind(cs[i+1]) === literal_k\n+        # optimization: push the current child mostly unchanged if the following\n+        # one isn't a literal string\n+        if !prev_str && cur_str && !next_str\n+            push!(ret_cs, c)\n+        elseif cur_str\n+            write(buf, c.value)\n+            if !next_str\n+                ret_c = newleaf(st._graph, st, literal_k)\n+                setattr!(ret_c, :value, String(take!(buf)))\n+                push!(ret_cs, ret_c)\n+            end\n+        else\n+            ret_c = kind(c) === K\"string\" ?\n+                _string_to_est(c, preprocessed_green_children(c);\n+                               unwrap_literal=false) :\n+                _green_to_est(st, i, c)\n+\n+            push!(ret_cs, ret_c)\n+        end\n+    end\n+    if unwrap_literal && length(ret_cs) === 1 && kind(ret_cs[1]) === literal_k\n+        return ret_cs[1]\n+    end\n+    return mknode(st, ret_cs)\n+end"
    }
  ]
}