{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59035",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59035/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59035/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59035/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59035",
  "id": 3244086424,
  "node_id": "PR_kwDOABkWpM6fny_k",
  "number": 59035,
  "title": "Add --target-sanitize=(memory|thread|address)",
  "user": {
    "login": "xal-0",
    "id": 33556084,
    "node_id": "MDQ6VXNlcjMzNTU2MDg0",
    "avatar_url": "https://avatars.githubusercontent.com/u/33556084?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/xal-0",
    "html_url": "https://github.com/xal-0",
    "followers_url": "https://api.github.com/users/xal-0/followers",
    "following_url": "https://api.github.com/users/xal-0/following{/other_user}",
    "gists_url": "https://api.github.com/users/xal-0/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/xal-0/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/xal-0/subscriptions",
    "organizations_url": "https://api.github.com/users/xal-0/orgs",
    "repos_url": "https://api.github.com/users/xal-0/repos",
    "events_url": "https://api.github.com/users/xal-0/events{/privacy}",
    "received_events_url": "https://api.github.com/users/xal-0/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 210703,
      "node_id": "MDU6TGFiZWwyMTA3MDM=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/building",
      "name": "building",
      "color": "444444",
      "default": false,
      "description": "Build system, or building Julia or its dependencies"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 9,
  "created_at": "2025-07-18T18:50:04Z",
  "updated_at": "2025-11-10T19:58:54Z",
  "closed_at": "2025-11-10T19:58:54Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59035",
    "html_url": "https://github.com/JuliaLang/julia/pull/59035",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59035.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59035.patch",
    "merged_at": "2025-11-10T19:58:54Z"
  },
  "body": "Adds three hidden options that can enable the Memory/Thread/AddressSanitizer\r\nLLVM passes even when Julia is not built with any sanitizers enabled.  In\r\nconjunction with #59033 this lets us build a ThreadSanitizer version of Julia in\r\nonly a few minutes rather than hours.\r\n\r\n- Adds the `--target-sanitize=(memory|thread|address)` flags to enable those\r\n  LLVM passes when compiling code ahead of time with `--output-*`.\r\n- JITted code will enable the passes for a sanitizer only if the runtime is\r\n  built with it.\r\n- Adds the corresponding options to `CodegenParams`.\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59035/reactions",
    "total_count": 6,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 6,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59035/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "0255a8f2dc6422bb0cc012724633690e6dbd9e6f",
      "filename": "base/options.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/base%2Foptions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/base%2Foptions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Foptions.jl?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -70,6 +70,9 @@ struct JLOptions\n     gc_sweep_always_full::Int8\n     compress_sysimage::Int8\n     alert_on_critical_error::Int8\n+    target_sanitize_memory::Int8\n+    target_sanitize_thread::Int8\n+    target_sanitize_address::Int8\n end\n \n # This runs early in the sysimage != is not defined yet"
    },
    {
      "sha": "3309a9a346db1fa5567ed19e9da6f9950446d25d",
      "filename": "base/reflection.jl",
      "status": "modified",
      "additions": 17,
      "deletions": 2,
      "changes": 19,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/base%2Freflection.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/base%2Freflection.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Freflection.jl?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -170,17 +170,32 @@ struct CodegenParams\n     \"\"\"\n     force_emit_all::Cint\n \n+    \"\"\"\n+    When enabled, run the MemorySanitizer pass.\n+    \"\"\"\n+    sanitize_memory::Cint\n+    \"\"\"\n+    When enabled, run the ThreadSanitizer pass.\n+    \"\"\"\n+    sanitize_thread::Cint\n+    \"\"\"\n+    When enabled, run the AddressSanitizer pass.\n+    \"\"\"\n+    sanitize_address::Cint\n+\n     function CodegenParams(; track_allocations::Bool=true, code_coverage::Bool=true,\n                    prefer_specsig::Bool=false,\n                    gnu_pubnames::Bool=true, debug_info_kind::Cint = default_debug_info_kind(),\n                    debug_info_level::Cint = Cint(JLOptions().debug_level), safepoint_on_entry::Bool=true,\n-                   gcstack_arg::Bool=true, use_jlplt::Bool=true, force_emit_all::Bool=false)\n+                   gcstack_arg::Bool=true, use_jlplt::Bool=true, force_emit_all::Bool=false,\n+                   sanitize_memory::Bool=false, sanitize_thread::Bool=false, sanitize_address::Bool=false)\n         return new(\n             Cint(track_allocations), Cint(code_coverage),\n             Cint(prefer_specsig),\n             Cint(gnu_pubnames), debug_info_kind,\n             debug_info_level, Cint(safepoint_on_entry),\n-            Cint(gcstack_arg), Cint(use_jlplt), Cint(force_emit_all))\n+            Cint(gcstack_arg), Cint(use_jlplt), Cint(force_emit_all),\n+            Cint(sanitize_memory), Cint(sanitize_thread), Cint(sanitize_address))\n     end\n end\n "
    },
    {
      "sha": "3e8e0334edaf88d962106301018211a13fe3fe83",
      "filename": "src/aotcompile.cpp",
      "status": "modified",
      "additions": 16,
      "deletions": 4,
      "changes": 20,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Faotcompile.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Faotcompile.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Faotcompile.cpp?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -477,7 +477,7 @@ static void resolve_workqueue(jl_codegen_params_t &params, egal_set &method_root\n             // emit specsig-to-(jl)invoke conversion\n             proto.decl->setLinkage(GlobalVariable::InternalLinkage);\n             //protodecl->setAlwaysInline();\n-            jl_init_function(proto.decl, params.TargetTriple);\n+            jl_init_function(proto.decl, params);\n             jl_method_instance_t *mi = jl_get_ci_mi(codeinst);\n             size_t nrealargs = jl_nparams(mi->specTypes); // number of actual arguments being passed\n             bool is_opaque_closure = jl_is_method(mi->def.value) && mi->def.method->is_for_opaque_closure;\n@@ -777,6 +777,10 @@ void *jl_emit_native_impl(jl_array_t *codeinfos, LLVMOrcThreadSafeModuleRef llvm\n     CreateNativeMax.updateMax(jl_array_nrows(codeinfos));\n     if (cgparams == NULL)\n         cgparams = &jl_default_cgparams;\n+    jl_cgparams_t target_cgparams = *cgparams;\n+    target_cgparams.sanitize_memory = jl_options.target_sanitize_memory;\n+    target_cgparams.sanitize_thread = jl_options.target_sanitize_thread;\n+    target_cgparams.sanitize_address = jl_options.target_sanitize_address;\n     jl_native_code_desc_t *data = new jl_native_code_desc_t;\n     orc::ThreadSafeContext ctx;\n     orc::ThreadSafeModule backing;\n@@ -795,7 +799,7 @@ void *jl_emit_native_impl(jl_array_t *codeinfos, LLVMOrcThreadSafeModuleRef llvm\n     jl_codegen_params_t params(ctxt, std::move(target_info.first), std::move(target_info.second));\n     if (!llvmmod)\n         params.getContext().setDiscardValueNames(true);\n-    params.params = cgparams;\n+    params.params = &target_cgparams;\n     assert(params.imaging_mode); // `_imaging_mode` controls if broken features like code-coverage are disabled\n     params.external_linkage = external_linkage;\n     params.temporary_roots = jl_alloc_array_1d(jl_array_any_type, 0);\n@@ -1565,7 +1569,11 @@ static AOTOutputs add_output_impl(Module &M, TargetMachine &SourceTM, ShardTimer\n                 SourceTM.getCodeModel(),\n                 SourceTM.getOptLevel()));\n         fixupTM(*PMTM);\n-        NewPM optimizer{std::move(PMTM), getOptLevel(jl_options.opt_level), OptimizationOptions::defaults(true, true)};\n+        auto options = OptimizationOptions::defaults(true, true);\n+        options.sanitize_memory = jl_options.target_sanitize_memory;\n+        options.sanitize_thread = jl_options.target_sanitize_thread;\n+        options.sanitize_address = jl_options.target_sanitize_address;\n+        NewPM optimizer{std::move(PMTM), getOptLevel(jl_options.opt_level), options};\n         optimizer.run(M);\n         assert(!verifyLLVMIR(M));\n         bool inject_aliases = false;\n@@ -2566,7 +2574,11 @@ void jl_get_llvmf_defn_impl(jl_llvmf_dump_t *dump, jl_method_instance_t *mi, jl_\n                 }\n                 assert(!verifyLLVMIR(*m.getModuleUnlocked()));\n                 if (optimize) {\n-                    NewPM PM{jl_ExecutionEngine->cloneTargetMachine(), getOptLevel(jl_options.opt_level)};\n+                    auto opts = OptimizationOptions::defaults();\n+                    opts.sanitize_memory = params.sanitize_memory;\n+                    opts.sanitize_thread = params.sanitize_thread;\n+                    opts.sanitize_address = params.sanitize_address;\n+                    NewPM PM{jl_ExecutionEngine->cloneTargetMachine(), getOptLevel(jl_options.opt_level), opts};\n                     //Safe b/c context lock is held by output\n                     PM.run(*m.getModuleUnlocked());\n                     assert(!verifyLLVMIR(*m.getModuleUnlocked()));"
    },
    {
      "sha": "a965242625cf89550e7c0aca785b7c988649a0d8",
      "filename": "src/codegen.cpp",
      "status": "modified",
      "additions": 23,
      "deletions": 28,
      "changes": 51,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fcodegen.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fcodegen.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcodegen.cpp?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -2713,8 +2713,9 @@ static void jl_name_jlfuncparams_args(jl_codegen_params_t &params, Function *F)\n     F->getArg(3)->setName(\"sparams::Any\");\n }\n \n-void jl_init_function(Function *F, const Triple &TT) JL_NOTSAFEPOINT\n+void jl_init_function(Function *F, const jl_codegen_params_t &params) JL_NOTSAFEPOINT\n {\n+    auto &TT = params.TargetTriple;\n     // set any attributes that *must* be set on all functions\n     AttrBuilder attr(F->getContext());\n     if (TT.isOSWindows() && TT.getArch() == Triple::x86) {\n@@ -2727,22 +2728,18 @@ void jl_init_function(Function *F, const Triple &TT) JL_NOTSAFEPOINT\n         attr.addUWTableAttr(llvm::UWTableKind::Default); // force NeedsWinEH\n     }\n     attr.addAttribute(\"frame-pointer\", \"all\");\n-    if (!TT.isOSWindows()) {\n-#if !defined(_COMPILER_ASAN_ENABLED_)\n+    if (!TT.isOSWindows() && !JL_FEAT_TEST(params, sanitize_address)) {\n         // ASAN won't like us accessing undefined memory causing spurious issues,\n         // and Windows has platform-specific handling which causes it to mishandle\n         // this annotation. Other platforms should just ignore this if they don't\n         // implement it.\n         attr.addAttribute(\"probe-stack\", \"inline-asm\");\n         //attr.addAttribute(\"stack-probe-size\", \"4096\"); // can use this to change the default\n-#endif\n     }\n-#if defined(_COMPILER_ASAN_ENABLED_)\n-    attr.addAttribute(Attribute::SanitizeAddress);\n-#endif\n-#if defined(_COMPILER_MSAN_ENABLED_)\n-    attr.addAttribute(Attribute::SanitizeMemory);\n-#endif\n+    if (JL_FEAT_TEST(params, sanitize_address))\n+        attr.addAttribute(Attribute::SanitizeAddress);\n+    if (JL_FEAT_TEST(params, sanitize_memory))\n+        attr.addAttribute(Attribute::SanitizeMemory);\n     F->addFnAttrs(attr);\n }\n \n@@ -6247,7 +6244,7 @@ static std::pair<Function*, Function*> get_oc_function(jl_codectx_t &ctx, jl_met\n         F = Function::Create(get_func_sig(ctx.builder.getContext()),\n                              Function::ExternalLinkage,\n                              proto_oc, jl_Module);\n-        jl_init_function(F, ctx.emission_context.TargetTriple);\n+        jl_init_function(F, ctx.emission_context);\n         jl_name_jlfunc_args(ctx.emission_context, F);\n         F->setAttributes(AttributeList::get(ctx.builder.getContext(), {get_func_attrs(ctx.builder.getContext()), F->getAttributes()}));\n     }\n@@ -6770,7 +6767,7 @@ static Function *emit_modifyhelper(jl_codectx_t &ctx2, const jl_cgval_t &op, con\n         ArgTy.push_back(ctx.builder.getPtrTy());\n     FunctionType *FT = FunctionType::get(elty, ArgTy, false);\n     Function *w = Function::Create(FT, GlobalVariable::PrivateLinkage, \"\", M);\n-    jl_init_function(w, ctx.emission_context.TargetTriple);\n+    jl_init_function(w, ctx.emission_context);\n     w->addFnAttr(Attribute::AlwaysInline);\n     w->setUnnamedAddr(GlobalValue::UnnamedAddr::Global);\n     Function::arg_iterator AI = w->arg_begin();\n@@ -6829,7 +6826,7 @@ Function *emit_tojlinvoke(jl_code_instance_t *codeinst, Value *theFunc, Module *\n     Function *f = Function::Create(ctx.types().T_jlfunc,\n             GlobalVariable::InternalLinkage,\n             name, M);\n-    jl_init_function(f, params.TargetTriple);\n+    jl_init_function(f, params);\n     jl_name_jlfunc_args(params, f);\n     //f->setAlwaysInline();\n     ctx.f = f; // for jl_Module\n@@ -7027,7 +7024,7 @@ void emit_specsig_to_fptr1(\n static void emit_fptr1_wrapper(Module *M, StringRef gf_thunk_name, Value *target, jl_value_t *rettype_const, jl_value_t *declrt, jl_value_t *jlrettype, jl_codegen_params_t &params)\n {\n     Function *w = Function::Create(get_func_sig(M->getContext()), GlobalVariable::ExternalLinkage, gf_thunk_name, M);\n-    jl_init_function(w, params.TargetTriple);\n+    jl_init_function(w, params);\n     w->setAttributes(AttributeList::get(M->getContext(), {get_func_attrs(M->getContext()), w->getAttributes()}));\n     w->addFnAttr(Attribute::OptimizeNone);\n     w->addFnAttr(Attribute::NoInline);\n@@ -7071,7 +7068,7 @@ static void emit_specsig_to_specsig(\n {\n     jl_returninfo_t returninfo = get_specsig_function(params, M, nullptr, gf_thunk_name, calltype, rettype, is_for_opaque_closure);\n     Function *gf_thunk = cast<Function>(returninfo.decl.getCallee());\n-    jl_init_function(gf_thunk, params.TargetTriple);\n+    jl_init_function(gf_thunk, params);\n     gf_thunk->setAttributes(AttributeList::get(gf_thunk->getContext(), {returninfo.attrs, gf_thunk->getAttributes()}));\n     emit_specsig_to_specsig(gf_thunk, returninfo.cc, returninfo.return_roots, calltype, rettype, is_for_opaque_closure, nargs, params, target, targetsig, targetrt, targetspec, rettype_const);\n }\n@@ -7317,7 +7314,7 @@ static Function *gen_cfun_wrapper(\n     Function *cw = Function::Create(functype,\n             GlobalVariable::ExternalLinkage,\n             funcName, M);\n-    jl_init_function(cw, params.TargetTriple);\n+    jl_init_function(cw, params);\n     cw->setAttributes(AttributeList::get(M->getContext(), {attributes, cw->getAttributes()}));\n \n     jl_codectx_t ctx(M->getContext(), params, 0, 0);\n@@ -7539,7 +7536,7 @@ static Function *gen_cfun_wrapper(\n                 FunctionType::get(getPointerTy(ctx.builder.getContext()), { getPointerTy(ctx.builder.getContext()), ctx.types().T_ppjlvalue }, false),\n                 GlobalVariable::ExternalLinkage,\n                 funcName, M);\n-        jl_init_function(cw_make, ctx.emission_context.TargetTriple);\n+        jl_init_function(cw_make, ctx.emission_context);\n         cw_make->getArg(0)->setName(\"wrapper\");\n         cw_make->getArg(1)->setName(\"newval\");\n         BasicBlock *b0 = BasicBlock::Create(ctx.builder.getContext(), \"top\", cw_make);\n@@ -7799,7 +7796,7 @@ static void gen_invoke_wrapper(jl_method_instance_t *lam, jl_value_t *abi, jl_va\n {\n     ++GeneratedInvokeWrappers;\n     Function *w = Function::Create(get_func_sig(M->getContext()), GlobalVariable::ExternalLinkage, funcName, M);\n-    jl_init_function(w, params.TargetTriple);\n+    jl_init_function(w, params);\n     jl_name_jlfunc_args(params, w);\n     w->setAttributes(AttributeList::get(M->getContext(), {get_func_attrs(M->getContext()), w->getAttributes()}));\n     w->addFnAttr(Attribute::OptimizeNone);\n@@ -8040,7 +8037,7 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n         Function *f = M ? cast_or_null<Function>(M->getNamedValue(name)) : NULL;\n         if (f == NULL) {\n             f = Function::Create(ftype, GlobalVariable::ExternalLinkage, name, M);\n-            jl_init_function(f, params.TargetTriple);\n+            jl_init_function(f, params);\n             if (params.params->debug_info_level >= 2) {\n                 ios_t sigbuf;\n                 ios_mem(&sigbuf, 0);\n@@ -8327,7 +8324,7 @@ static jl_llvm_functions_t\n                                           ArgNames, nreq);\n         f = cast<Function>(returninfo.decl.getCallee());\n         has_sret = (returninfo.cc == jl_returninfo_t::SRet || returninfo.cc == jl_returninfo_t::Union);\n-        jl_init_function(f, ctx.emission_context.TargetTriple);\n+        jl_init_function(f, ctx.emission_context);\n \n         // common pattern: see if all return statements are an argument in that\n         // case the apply-generic call can re-use the original box for the return\n@@ -8366,7 +8363,7 @@ static jl_llvm_functions_t\n         f = Function::Create(needsparams ? ctx.types().T_jlfuncparams : ctx.types().T_jlfunc,\n                              GlobalVariable::ExternalLinkage,\n                              declarations.specFunctionObject, M);\n-        jl_init_function(f, ctx.emission_context.TargetTriple);\n+        jl_init_function(f, ctx.emission_context);\n         if (needsparams)\n             jl_name_jlfuncparams_args(ctx.emission_context, f);\n         else\n@@ -8402,11 +8399,9 @@ static jl_llvm_functions_t\n     FnAttrs.addAttribute(Attribute::StackProtectStrong);\n #endif\n \n-#ifdef _COMPILER_TSAN_ENABLED_\n-    // TODO: enable this only when a argument like `-race` is passed to Julia\n-    //       add a macro for no_sanitize_thread\n-    FnAttrs.addAttribute(llvm::Attribute::SanitizeThread);\n-#endif\n+    // TODO: add a macro for no_sanitize_thread\n+    if (JL_FEAT_TEST(ctx, sanitize_thread))\n+        FnAttrs.addAttribute(llvm::Attribute::SanitizeThread);\n \n     // add the optimization level specified for this module, if any\n     int optlevel = jl_get_module_optlevel(ctx.module);\n@@ -9773,7 +9768,7 @@ jl_llvm_functions_t jl_emit_codedecls(\n                 Function *f = Function::Create(needsparams ? JuliaType::get_jlfuncparams_ty(M.getContext()) : JuliaType::get_jlfunc_ty(M.getContext()),\n                                      GlobalVariable::ExternalLinkage,\n                                      decls.specFunctionObject, M);\n-                jl_init_function(f, params.TargetTriple);\n+                jl_init_function(f, params);\n                 f->setAttributes(AttributeList::get(M.getContext(), {get_func_attrs(M.getContext()), f->getAttributes()}));\n             }\n         });\n@@ -9836,7 +9831,7 @@ static jl_llvm_functions_t jl_emit_oc_wrapper(orc::ThreadSafeModule &m, jl_codeg\n         std::string funcName = get_function_name(true, false, ctx.name, ctx.emission_context.TargetTriple);\n         jl_returninfo_t returninfo = get_specsig_function(params, M, NULL, funcName, mi->specTypes, rettype, true);\n         Function *gf_thunk = cast<Function>(returninfo.decl.getCallee());\n-        jl_init_function(gf_thunk, ctx.emission_context.TargetTriple);\n+        jl_init_function(gf_thunk, ctx.emission_context);\n         size_t nrealargs = jl_nparams(mi->specTypes);\n         emit_specsig_to_fptr1(gf_thunk, returninfo.cc, returninfo.return_roots,\n                 mi->specTypes, rettype, true, nrealargs, ctx.emission_context,"
    },
    {
      "sha": "5c2b9ce66678b00e3ea2ff0c19a20b3b71ad6ac6",
      "filename": "src/init.c",
      "status": "modified",
      "additions": 17,
      "deletions": 1,
      "changes": 18,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Finit.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Finit.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Finit.c?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -658,7 +658,23 @@ JL_DLLEXPORT jl_cgparams_t jl_default_cgparams = {\n         /* safepoint_on_entry */ 1,\n         /* gcstack_arg */ 1,\n         /* use_jlplt*/ 1 ,\n-        /*force_emit_all=*/ 0};\n+        /*force_emit_all=*/ 0,\n+#ifdef _COMPILER_MSAN_ENABLED_\n+        /* sanitize_memory */ 1,\n+#else\n+        /* sanitize_memory */ 0,\n+#endif\n+#ifdef _COMPILER_TSAN_ENABLED_\n+        /* sanitize_thread */ 1,\n+#else\n+        /* sanitize_thread */ 0,\n+#endif\n+#ifdef _COMPILER_ASAN_ENABLED_\n+        /* sanitize_address */ 1,\n+#else\n+        /* sanitize_address */ 0,\n+#endif\n+};\n \n static void init_global_mutexes(void) {\n     JL_MUTEX_INIT(&jl_modules_mutex, \"jl_modules_mutex\");"
    },
    {
      "sha": "0773d1a6c16a1edf1922dfabba6e2574a305c8f1",
      "filename": "src/jitlayers.cpp",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fjitlayers.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fjitlayers.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjitlayers.cpp?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -482,7 +482,7 @@ static int jl_analyze_workqueue(jl_code_instance_t *callee, jl_codegen_params_t\n                         // emit specsig-to-(jl)invoke conversion\n                         proto.decl->setLinkage(GlobalVariable::InternalLinkage);\n                         //protodecl->setAlwaysInline();\n-                        jl_init_function(proto.decl, params.TargetTriple);\n+                        jl_init_function(proto.decl, params);\n                         // TODO: maybe this can be cached in codeinst->specfptr?\n                         int8_t gc_state = jl_gc_unsafe_enter(ct->ptls); // codegen may contain safepoints (such as jl_subtype calls)\n                         jl_method_instance_t *mi = jl_get_ci_mi(codeinst);\n@@ -1450,7 +1450,7 @@ namespace {\n         auto operator()() JL_NOTSAFEPOINT {\n             auto TM = cantFail(JTMB.createTargetMachine());\n             fixupTM(*TM);\n-            auto NPM = std::make_unique<NewPM>(std::move(TM), O);\n+            auto NPM = std::make_unique<NewPM>(std::move(TM), O, OptimizationOptions::defaults());\n             // TODO this needs to be locked, as different resource pools may add to the printer vector at the same time\n             {\n                 std::lock_guard<std::mutex> lock(llvm_printing_mutex);"
    },
    {
      "sha": "5c1fb10a84205faf1a13e3812eb5bebf589259e0",
      "filename": "src/jitlayers.h",
      "status": "modified",
      "additions": 23,
      "deletions": 3,
      "changes": 26,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fjitlayers.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fjitlayers.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjitlayers.h?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -90,6 +90,9 @@ struct OptimizationOptions {\n     bool remove_ni;\n     bool cleanup;\n     bool warn_missed_transformations;\n+    bool sanitize_memory;\n+    bool sanitize_thread;\n+    bool sanitize_address;\n \n     static constexpr OptimizationOptions defaults(\n         bool lower_intrinsics=true,\n@@ -104,12 +107,29 @@ struct OptimizationOptions {\n         bool enable_vector_pipeline=true,\n         bool remove_ni=true,\n         bool cleanup=true,\n-        bool warn_missed_transformations=false) {\n+        bool warn_missed_transformations=false,\n+#ifdef _COMPILER_MSAN_ENABLED_\n+        bool sanitize_memory=true,\n+#else\n+        bool sanitize_memory=false,\n+#endif\n+#ifdef _COMPILER_TSAN_ENABLED_\n+        bool sanitize_thread=true,\n+#else\n+        bool sanitize_thread=false,\n+#endif\n+#ifdef _COMPILER_ASAN_ENABLED_\n+        bool sanitize_address=true\n+#else\n+        bool sanitize_address=false\n+#endif\n+) JL_NOTSAFEPOINT {\n         return {lower_intrinsics, dump_native, external_use, llvm_only,\n                 always_inline, enable_early_simplifications,\n                 enable_early_optimizations, enable_scalar_optimizations,\n                 enable_loop_optimizations, enable_vector_pipeline,\n-                remove_ni, cleanup, warn_missed_transformations};\n+                remove_ni, cleanup, warn_missed_transformations,\n+                sanitize_memory, sanitize_thread, sanitize_address};\n     }\n };\n \n@@ -335,7 +355,7 @@ void emit_specsig_to_fptr1(\n         jl_codegen_params_t &params,\n         Function *target) JL_NOTSAFEPOINT;\n Function *get_or_emit_fptr1(StringRef Name, Module *M) JL_NOTSAFEPOINT;\n-void jl_init_function(Function *F, const Triple &TT) JL_NOTSAFEPOINT;\n+void jl_init_function(Function *F, const jl_codegen_params_t &params) JL_NOTSAFEPOINT;\n \n void add_named_global(StringRef name, void *addr) JL_NOTSAFEPOINT;\n "
    },
    {
      "sha": "50ef415bc0bac868c9f322e59918b160673c4c3a",
      "filename": "src/jloptions.c",
      "status": "modified",
      "additions": 23,
      "deletions": 1,
      "changes": 24,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fjloptions.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fjloptions.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjloptions.c?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -163,6 +163,9 @@ JL_DLLEXPORT void jl_init_options(void)\n                         0, // gc_sweep_always_full\n                         0, // compress_sysimage\n                         0, // alert_on_critical_error\n+                        0, // target_sanitize_memory\n+                        0, // target_sanitize_thread\n+                        0, // target_sanitize_address\n     };\n     jl_options_initialized = 1;\n }\n@@ -300,7 +303,7 @@ static const char opts[]  =\n     \"                                               T (tebibytes), or % (percentage of physical memory).\\n\\n\"\n ;\n \n-static const char opts_hidden[]  =\n+static const char opts_hidden[] =\n     \"Switches (a '*' marks the default value, if applicable):\\n\\n\"\n     \" Option                                        Description\\n\"\n     \" ---------------------------------------------------------------------------------------------------\\n\"\n@@ -359,6 +362,13 @@ static const char opts_hidden[]  =\n     \"                                               B, K (kibibytes), M (mebibytes), G (gibibytes)\\n\"\n     \"                                               or T (tebibytes).\\n\"\n     \" --gc-sweep-always-full                        Makes the GC always do a full sweep of the heap\\n\"\n+    \" --target-sanitize=memory                      Instrument generated code for MemorySanitizer.\\n\"\n+    \" --target-sanitize=thread                      Instrument generated code for ThreadSanitizer.\\n\"\n+    \" --target-sanitize=address                     Instrument generated code for AddressSanitizer.\\n\"\n+    \"                                               The above options control the instrumentation of\\n\"\n+    \"                                               code generated by --output-* only. JITed code is\\n\"\n+    \"                                               instrumented if Julia itself is built with\\n\"\n+    \"                                               sanitizers.\\n\"\n ;\n \n JL_DLLEXPORT void jl_parse_opts(int *argcp, char ***argvp)\n@@ -416,6 +426,7 @@ JL_DLLEXPORT void jl_parse_opts(int *argcp, char ***argvp)\n            opt_trace_eval,\n            opt_experimental_features,\n            opt_compress_sysimage,\n+           opt_target_sanitize,\n     };\n     static const char* const shortopts = \"+vhqH:e:E:L:J:C:it:p:O:g:m:\";\n     static const struct option longopts[] = {\n@@ -489,6 +500,7 @@ JL_DLLEXPORT void jl_parse_opts(int *argcp, char ***argvp)\n         { \"trim\",  optional_argument, 0, opt_trim },\n         { \"compress-sysimage\", required_argument, 0, opt_compress_sysimage },\n         { \"trace-eval\",       optional_argument, 0, opt_trace_eval },\n+        { \"target-sanitize\", required_argument, 0, opt_target_sanitize },\n         { 0, 0, 0, 0 }\n     };\n \n@@ -1093,6 +1105,16 @@ JL_DLLEXPORT void jl_parse_opts(int *argcp, char ***argvp)\n             else if (!strcmp(optarg,\"no\"))\n                 jl_options.compress_sysimage = 0;\n             break;\n+        case opt_target_sanitize:\n+            if (!strcmp(optarg, \"memory\"))\n+                jl_options.target_sanitize_memory = 1;\n+            else if (!strcmp(optarg, \"thread\"))\n+                jl_options.target_sanitize_thread = 1;\n+            else if (!strcmp(optarg, \"address\"))\n+                jl_options.target_sanitize_address = 1;\n+            else\n+                jl_errorf(\"julia: invalid argument to --target-sanitize={memory|thread|address} (%s)\", optarg);\n+            break;\n         default:\n             jl_errorf(\"julia: unhandled option -- %c\\n\"\n                       \"This is a bug, please report it.\", c);"
    },
    {
      "sha": "14a5dfe83b43b4aaabb9946332b586b7de1a41ff",
      "filename": "src/jloptions.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fjloptions.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fjloptions.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjloptions.h?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -74,6 +74,9 @@ typedef struct {\n     int8_t gc_sweep_always_full;\n     int8_t compress_sysimage;\n     int8_t alert_on_critical_error;\n+    int8_t target_sanitize_memory;\n+    int8_t target_sanitize_thread;\n+    int8_t target_sanitize_address;\n } jl_options_t;\n \n #endif"
    },
    {
      "sha": "2937ec44eb2f5a2ca94f291c485e213ff4c4e683",
      "filename": "src/julia.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fjulia.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fjulia.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia.h?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -2641,6 +2641,7 @@ JL_DLLEXPORT void jl_set_safe_restore(jl_jmp_buf *) JL_NOTSAFEPOINT;\n // codegen interface ----------------------------------------------------------\n // The root propagation here doesn't have to be literal, but callers should\n // ensure that the return value outlives the MethodInstance\n+// Must be kept in sync with `base/reflection.jl` (CodegenParams)\n typedef struct {\n     int track_allocations;  // can we track allocations?\n     int code_coverage;      // can we measure coverage?\n@@ -2656,6 +2657,11 @@ typedef struct {\n \n     int use_jlplt; // Whether to use the Julia PLT mechanism or emit symbols directly\n     int force_emit_all; // Force emission of code for const return functions\n+\n+    // These options control the sanitizer passes and are used to AOT compile instrumented sysimages\n+    int sanitize_memory;\n+    int sanitize_thread;\n+    int sanitize_address;\n } jl_cgparams_t;\n extern JL_DLLEXPORT int jl_default_debug_info_kind;\n extern JL_DLLEXPORT jl_cgparams_t jl_default_cgparams;"
    },
    {
      "sha": "0481e04b8d19e5d4c15d412f48ac26bad342eb08",
      "filename": "src/pipeline.cpp",
      "status": "modified",
      "additions": 61,
      "deletions": 62,
      "changes": 123,
      "blob_url": "https://github.com/JuliaLang/julia/blob/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fpipeline.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/9a186c2e58745e49cbba8b44f5e3995f894ab062/src%2Fpipeline.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fpipeline.cpp?ref=9a186c2e58745e49cbba8b44f5e3995f894ab062",
      "patch": "@@ -96,7 +96,7 @@ using namespace llvm;\n namespace {\n     //Shamelessly stolen from Clang's approach to sanitizers\n     //TODO do we want to enable other sanitizers?\n-    static void addSanitizerPasses(ModulePassManager &MPM, OptimizationLevel O) JL_NOTSAFEPOINT {\n+    static void addSanitizerPasses(ModulePassManager &MPM, OptimizationLevel O, const OptimizationOptions &options) JL_NOTSAFEPOINT {\n         // Coverage sanitizer\n         // if (CodeGenOpts.hasSanitizeCoverage()) {\n         //   auto SancovOpts = getSancovOptsFromCGOpts(CodeGenOpts);\n@@ -105,67 +105,63 @@ namespace {\n         //       CodeGenOpts.SanitizeCoverageIgnorelistFiles));\n         // }\n \n-    #ifdef _COMPILER_MSAN_ENABLED_\n-        auto MSanPass = [&](/*SanitizerMask Mask, */bool CompileKernel) JL_NOTSAFEPOINT {\n-        // if (LangOpts.Sanitize.has(Mask)) {\n-            // int TrackOrigins = CodeGenOpts.SanitizeMemoryTrackOrigins;\n-            // bool Recover = CodeGenOpts.SanitizeRecover.has(Mask);\n-\n-            // MemorySanitizerOptions options(TrackOrigins, Recover, CompileKernel,{\n-            //                             CodeGenOpts.SanitizeMemoryParamRetval);\n-            MemorySanitizerOptions options;\n-            MPM.addPass(ModuleMemorySanitizerPass(options));\n-            FunctionPassManager FPM;\n-            FPM.addPass(MemorySanitizerPass(options));\n-            if (O != OptimizationLevel::O0) {\n-            // MemorySanitizer inserts complex instrumentation that mostly\n-            // follows the logic of the original code, but operates on\n-            // \"shadow\" values. It can benefit from re-running some\n-            // general purpose optimization passes.\n-            FPM.addPass(EarlyCSEPass());\n-            // TODO: Consider add more passes like in\n-            // addGeneralOptsForMemorySanitizer. EarlyCSEPass makes visible\n-            // difference on size. It's not clear if the rest is still\n-            // useful. InstCombinePass breaks\n-            // compiler-rt/test/msan/select_origin.cpp.\n-            }\n-            MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n-        // }\n-        };\n-        MSanPass(/*SanitizerKind::Memory, */false);\n-        // MSanPass(SanitizerKind::KernelMemory, true);\n-    #endif\n-\n-    #ifdef _COMPILER_TSAN_ENABLED_\n-        // if (LangOpts.Sanitize.has(SanitizerKind::Thread)) {\n-        MPM.addPass(ModuleThreadSanitizerPass());\n-        MPM.addPass(createModuleToFunctionPassAdaptor(ThreadSanitizerPass()));\n-        // }\n-    #endif\n+        if (options.sanitize_memory) {\n+            auto MSanPass = [&](/*SanitizerMask Mask, */bool CompileKernel) JL_NOTSAFEPOINT {\n+                // if (LangOpts.Sanitize.has(Mask)) {\n+                // int TrackOrigins = CodeGenOpts.SanitizeMemoryTrackOrigins;\n+                // bool Recover = CodeGenOpts.SanitizeRecover.has(Mask);\n+\n+                // MemorySanitizerOptions options(TrackOrigins, Recover, CompileKernel,{\n+                //                             CodeGenOpts.SanitizeMemoryParamRetval);\n+                MemorySanitizerOptions options;\n+                MPM.addPass(MemorySanitizerPass(options));\n+                FunctionPassManager FPM;\n+                if (O != OptimizationLevel::O0) {\n+                    // MemorySanitizer inserts complex instrumentation that mostly\n+                    // follows the logic of the original code, but operates on\n+                    // \"shadow\" values. It can benefit from re-running some\n+                    // general purpose optimization passes.\n+                    FPM.addPass(EarlyCSEPass());\n+                    // TODO: Consider add more passes like in\n+                    // addGeneralOptsForMemorySanitizer. EarlyCSEPass makes visible\n+                    // difference on size. It's not clear if the rest is still\n+                    // useful. InstCombinePass breaks\n+                    // compiler-rt/test/msan/select_origin.cpp.\n+                }\n+                MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n+                // }\n+            };\n+            MSanPass(/*SanitizerKind::Memory, */false);\n+            // MSanPass(SanitizerKind::KernelMemory, true);\n+        }\n \n+        if (options.sanitize_thread) {\n+            MPM.addPass(ModuleThreadSanitizerPass());\n+            MPM.addPass(createModuleToFunctionPassAdaptor(ThreadSanitizerPass()));\n+        }\n \n-    #ifdef _COMPILER_ASAN_ENABLED_\n-        auto ASanPass = [&](/*SanitizerMask Mask, */bool CompileKernel) JL_NOTSAFEPOINT {\n-        //   if (LangOpts.Sanitize.has(Mask)) {\n-            // bool UseGlobalGC = asanUseGlobalsGC(TargetTriple, CodeGenOpts);\n-            // bool UseOdrIndicator = CodeGenOpts.SanitizeAddressUseOdrIndicator;\n-            // llvm::AsanDtorKind DestructorKind =\n-            //     CodeGenOpts.getSanitizeAddressDtor();\n-            // AddressSanitizerOptions Opts;\n-            // Opts.CompileKernel = CompileKernel;\n-            // Opts.Recover = CodeGenOpts.SanitizeRecover.has(Mask);\n-            // Opts.UseAfterScope = CodeGenOpts.SanitizeAddressUseAfterScope;\n-            // Opts.UseAfterReturn = CodeGenOpts.getSanitizeAddressUseAfterReturn();\n-            // MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n-            //Let's assume the defaults are actually fine for our purposes\n-            // MPM.addPass(AddressSanitizerPass(\n-            //     Opts, UseGlobalGC, UseOdrIndicator, DestructorKind));\n-            MPM.addPass(AddressSanitizerPass(AddressSanitizerOptions(), true, false));\n-        //   }\n-        };\n-        ASanPass(/*SanitizerKind::Address, */false);\n-        // ASanPass(SanitizerKind::KernelAddress, true);\n-    #endif\n+        if (options.sanitize_address) {\n+            auto ASanPass = [&](/*SanitizerMask Mask, */bool CompileKernel) JL_NOTSAFEPOINT {\n+                //   if (LangOpts.Sanitize.has(Mask)) {\n+                // bool UseGlobalGC = asanUseGlobalsGC(TargetTriple, CodeGenOpts);\n+                // bool UseOdrIndicator = CodeGenOpts.SanitizeAddressUseOdrIndicator;\n+                // llvm::AsanDtorKind DestructorKind =\n+                //     CodeGenOpts.getSanitizeAddressDtor();\n+                // AddressSanitizerOptions Opts;\n+                // Opts.CompileKernel = CompileKernel;\n+                // Opts.Recover = CodeGenOpts.SanitizeRecover.has(Mask);\n+                // Opts.UseAfterScope = CodeGenOpts.SanitizeAddressUseAfterScope;\n+                // Opts.UseAfterReturn = CodeGenOpts.getSanitizeAddressUseAfterReturn();\n+                // MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n+                //Let's assume the defaults are actually fine for our purposes\n+                // MPM.addPass(AddressSanitizerPass(\n+                //     Opts, UseGlobalGC, UseOdrIndicator, DestructorKind));\n+                MPM.addPass(AddressSanitizerPass(AddressSanitizerOptions(), true, false));\n+                //   }\n+            };\n+            ASanPass(/*SanitizerKind::Address, */false);\n+            // ASanPass(SanitizerKind::KernelAddress, true);\n+        }\n \n         // auto HWASanPass = [&](SanitizerMask Mask, bool CompileKernel) {\n         //   if (LangOpts.Sanitize.has(Mask)) {\n@@ -608,7 +604,7 @@ static void buildCleanupPipeline(ModulePassManager &MPM, PassBuilder *PB, Optimi\n         }\n         invokeOptimizerLastCallbacks(MPM, PB, O);\n         MPM.addPass(createModuleToFunctionPassAdaptor(AnnotationRemarksPass()));\n-        addSanitizerPasses(MPM, O);\n+        addSanitizerPasses(MPM, O, options);\n         {\n             FunctionPassManager FPM;\n             JULIA_PASS(FPM.addPass(DemoteFloat16Pass()));\n@@ -832,7 +828,10 @@ static std::optional<std::pair<OptimizationLevel, OptimizationOptions>> parseJul\n             OPTION(enable_vector_pipeline),\n             OPTION(remove_ni),\n             OPTION(cleanup),\n-            OPTION(warn_missed_transformations)\n+            OPTION(warn_missed_transformations),\n+            OPTION(sanitize_memory),\n+            OPTION(sanitize_thread),\n+            OPTION(sanitize_address),\n #undef OPTION\n         };\n         while (!name.empty()) {"
    }
  ]
}