{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60376",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60376/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60376/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60376/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60376",
  "id": 3725049457,
  "node_id": "PR_kwDOABkWpM64p1FW",
  "number": 60376,
  "title": "Add heap sized based full gc heuristic",
  "user": {
    "login": "gbaraldi",
    "id": 28694980,
    "node_id": "MDQ6VXNlcjI4Njk0OTgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/28694980?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gbaraldi",
    "html_url": "https://github.com/gbaraldi",
    "followers_url": "https://api.github.com/users/gbaraldi/followers",
    "following_url": "https://api.github.com/users/gbaraldi/following{/other_user}",
    "gists_url": "https://api.github.com/users/gbaraldi/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gbaraldi/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gbaraldi/subscriptions",
    "organizations_url": "https://api.github.com/users/gbaraldi/orgs",
    "repos_url": "https://api.github.com/users/gbaraldi/repos",
    "events_url": "https://api.github.com/users/gbaraldi/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gbaraldi/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 195227131,
      "node_id": "MDU6TGFiZWwxOTUyMjcxMzE=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/GC",
      "name": "GC",
      "color": "2CD3F0",
      "default": false,
      "description": "Garbage collector"
    },
    {
      "id": 7980098453,
      "node_id": "LA_kwDOABkWpM8AAAAB26ajlQ",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/backport%201.12",
      "name": "backport 1.12",
      "color": "5CAAA4",
      "default": false,
      "description": "Change should be backported to release-1.12"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-12-12T22:43:12Z",
  "updated_at": "2026-01-09T13:32:33Z",
  "closed_at": "2025-12-16T20:00:32Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60376",
    "html_url": "https://github.com/JuliaLang/julia/pull/60376",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60376.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60376.patch",
    "merged_at": "2025-12-16T20:00:32Z"
  },
  "body": "Adresses https://github.com/JuliaLang/julia/issues/50658#issuecomment-3647219585 \r\n\r\nThis shouldn't ever trigger on normal Julia code, but might help when the gc counted malloc functions are used too much.\r\n\r\nAlso cleaned up the logic that was used for promoted_bytes. Trying to infer from the old bytes marked was unreliable. What actually matters is how many new objects we've seen ",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60376/reactions",
    "total_count": 3,
    "+1": 3,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60376/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "dc4afe48b8a68c664df09af6d8a3f6428129bcf9",
      "filename": "base/timing.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fe564b49764894978b4afc2b52ddf68483ceee14/base%2Ftiming.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fe564b49764894978b4afc2b52ddf68483ceee14/base%2Ftiming.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Ftiming.jl?ref=fe564b49764894978b4afc2b52ddf68483ceee14",
      "patch": "@@ -154,7 +154,7 @@ end\n @static if Base.USING_STOCK_GC\n # must be kept in sync with `src/gc-stock.h``\n const FULL_SWEEP_REASONS = [:FULL_SWEEP_REASON_SWEEP_ALWAYS_FULL, :FULL_SWEEP_REASON_FORCED_FULL_SWEEP,\n-                            :FULL_SWEEP_REASON_USER_MAX_EXCEEDED, :FULL_SWEEP_REASON_LARGE_PROMOTION_RATE]\n+                            :FULL_SWEEP_REASON_USER_MAX_EXCEEDED, :FULL_SWEEP_REASON_LARGE_PROMOTION_RATE, :FULL_SWEEP_REASON_LARGE_HEAP_GROWTH]\n end\n \n \"\"\""
    },
    {
      "sha": "5c8a5d107d2b3f080db96ebe7113c86f6f8f463f",
      "filename": "src/gc-stock.c",
      "status": "modified",
      "additions": 26,
      "deletions": 17,
      "changes": 43,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fe564b49764894978b4afc2b52ddf68483ceee14/src%2Fgc-stock.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fe564b49764894978b4afc2b52ddf68483ceee14/src%2Fgc-stock.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fgc-stock.c?ref=fe564b49764894978b4afc2b52ddf68483ceee14",
      "patch": "@@ -203,6 +203,7 @@ static int mark_reset_age = 0;\n \n static int64_t scanned_bytes; // young bytes scanned while marking\n static int64_t perm_scanned_bytes; // old bytes scanned while marking\n+static int64_t heap_size_after_last_full_gc = 0;\n int prev_sweep_full = 1;\n int current_sweep_full = 0;\n int next_sweep_full = 0;\n@@ -2256,13 +2257,13 @@ JL_DLLEXPORT void jl_gc_mark_queue_objarray(jl_ptls_t ptls, jl_value_t *parent,\n // `_new_obj` has its lowest bit tagged if it's in the remset (in which case we shouldn't update page metadata)\n FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_new_obj) JL_NOTSAFEPOINT\n {\n-    int meta_updated = (uintptr_t)_new_obj & GC_REMSET_PTR_TAG;\n+    int remset_object = (uintptr_t)_new_obj & GC_REMSET_PTR_TAG;\n     jl_value_t *new_obj = (jl_value_t *)((uintptr_t)_new_obj & ~(uintptr_t)GC_REMSET_PTR_TAG);\n     mark_obj: {\n         jl_taggedvalue_t *o = jl_astaggedvalue(new_obj);\n         uintptr_t vtag = o->header & ~(uintptr_t)0xf;\n         uint8_t bits = (gc_old(o->header) && !mark_reset_age) ? GC_OLD_MARKED : GC_MARKED;\n-        int update_meta = __likely(!meta_updated && !gc_verifying);\n+        int update_meta = __likely(!remset_object && !gc_verifying);\n         int foreign_alloc = 0;\n         if (update_meta && o->bits.in_image) {\n             foreign_alloc = 1;\n@@ -2362,7 +2363,7 @@ FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_\n                 uintptr_t nptr = (npointers << 2) | 1 | bits;\n                 new_obj = gc_mark_obj8(ptls, obj8_parent, obj8_begin, obj8_end, nptr);\n                 if (new_obj != NULL) {\n-                    if (!meta_updated)\n+                    if (!remset_object)\n                         goto mark_obj;\n                     else\n                         gc_ptr_queue_push(mq, new_obj);\n@@ -2484,7 +2485,7 @@ FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_\n             assert(obj8_begin < obj8_end);\n             new_obj = gc_mark_obj8(ptls, obj8_parent, obj8_begin, obj8_end, nptr);\n             if (new_obj != NULL) {\n-                if (!meta_updated)\n+                if (!remset_object)\n                     goto mark_obj;\n                 else\n                     gc_ptr_queue_push(mq, new_obj);\n@@ -2497,7 +2498,7 @@ FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_\n             assert(obj16_begin < obj16_end);\n             new_obj = gc_mark_obj16(ptls, obj16_parent, obj16_begin, obj16_end, nptr);\n             if (new_obj != NULL) {\n-                if (!meta_updated)\n+                if (!remset_object)\n                     goto mark_obj;\n                 else\n                     gc_ptr_queue_push(mq, new_obj);\n@@ -2512,7 +2513,7 @@ FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_\n             assert(obj32_begin < obj32_end);\n             new_obj = gc_mark_obj32(ptls, obj32_parent, obj32_begin, obj32_end, nptr);\n             if (new_obj != NULL) {\n-                if (!meta_updated)\n+                if (!remset_object)\n                     goto mark_obj;\n                 else\n                     gc_ptr_queue_push(mq, new_obj);\n@@ -3049,7 +3050,6 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n     uint64_t gc_start_time = jl_hrtime();\n     uint64_t mutator_time = gc_end_time == 0 ? old_mut_time : gc_start_time - gc_end_time;\n     uint64_t before_free_heap_size = jl_atomic_load_relaxed(&gc_heap_stats.heap_size);\n-    int64_t last_perm_scanned_bytes = perm_scanned_bytes;\n     uint64_t start_mark_time = jl_hrtime();\n     JL_PROBE_GC_MARK_BEGIN();\n     {\n@@ -3149,8 +3149,9 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n     gc_stats_all_pool();\n     gc_stats_big_obj();\n     gc_num.total_allocd += gc_num.allocd;\n-    if (!prev_sweep_full)\n-        promoted_bytes += perm_scanned_bytes - last_perm_scanned_bytes;\n+    // promoted_bytes are all the new bytes scanned that got promoted to old but that have never seen a full GC as old\n+    promoted_bytes += scanned_bytes;\n+    scanned_bytes = 0;\n     // 4. next collection decision\n     int remset_nptr = 0;\n     int sweep_full = next_sweep_full;\n@@ -3176,13 +3177,6 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n         recollect = 1;\n         gc_record_full_sweep_reason(FULL_SWEEP_REASON_FORCED_FULL_SWEEP);\n     }\n-    if (sweep_full) {\n-        // these are the difference between the number of gc-perm bytes scanned\n-        // on the first collection after sweep_full, and the current scan\n-        perm_scanned_bytes = 0;\n-        promoted_bytes = 0;\n-    }\n-    scanned_bytes = 0;\n     // 5. start sweeping\n     uint64_t start_sweep_time = jl_hrtime();\n     JL_PROBE_GC_SWEEP_BEGIN(sweep_full);\n@@ -3334,8 +3328,19 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n         target_heap = heap_size + jl_options.heap_target_increment;\n         jl_atomic_store_relaxed(&gc_heap_stats.heap_target, target_heap);\n     }\n-\n+    if (sweep_full) {\n+        // these are the difference between the number of gc-perm bytes scanned\n+        // on the first collection after sweep_full, and the current scan\n+        perm_scanned_bytes = 0;\n+        promoted_bytes = 0;\n+        heap_size_after_last_full_gc = jl_atomic_load_relaxed(&gc_heap_stats.heap_size);\n+    }\n+    // We want to trigger full GCs either if the heap size has grown a lot since the last full GC.\n+    // For this we use the overallocation function to see what a reasonable rate of growth is,\n+    // or if there is too much memory that has not seen a full GC after being promoted to old.\n     double old_ratio = (double)promoted_bytes/(double)heap_size;\n+    double expected_heap_size = overallocation(heap_size_after_last_full_gc, 0, UINT64_MAX) + heap_size_after_last_full_gc;\n+    double last_full_gc_heap_ratio = (double)heap_size/expected_heap_size;\n     if (heap_size > user_max) {\n         next_sweep_full = 1;\n         gc_record_full_sweep_reason(FULL_SWEEP_REASON_USER_MAX_EXCEEDED);\n@@ -3344,6 +3349,10 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n         next_sweep_full = 1;\n         gc_record_full_sweep_reason(FULL_SWEEP_REASON_LARGE_PROMOTION_RATE);\n     }\n+    else if (last_full_gc_heap_ratio > 1) {\n+        next_sweep_full = 1;\n+        gc_record_full_sweep_reason(FULL_SWEEP_REASON_LARGE_HEAP_GROWTH);\n+    }\n     else {\n         next_sweep_full = 0;\n     }"
    },
    {
      "sha": "d97d001daf2106d3fb055166c5eaee7af4bb997f",
      "filename": "src/gc-stock.h",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fe564b49764894978b4afc2b52ddf68483ceee14/src%2Fgc-stock.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fe564b49764894978b4afc2b52ddf68483ceee14/src%2Fgc-stock.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fgc-stock.h?ref=fe564b49764894978b4afc2b52ddf68483ceee14",
      "patch": "@@ -562,7 +562,8 @@ FORCE_INLINE void gc_big_object_link(bigval_t *sentinel_node, bigval_t *node) JL\n #define FULL_SWEEP_REASON_FORCED_FULL_SWEEP (1)\n #define FULL_SWEEP_REASON_USER_MAX_EXCEEDED (2)\n #define FULL_SWEEP_REASON_LARGE_PROMOTION_RATE (3)\n-#define FULL_SWEEP_NUM_REASONS (4)\n+#define FULL_SWEEP_REASON_LARGE_HEAP_GROWTH (4)\n+#define FULL_SWEEP_NUM_REASONS (5)\n \n extern JL_DLLEXPORT uint64_t jl_full_sweep_reasons[FULL_SWEEP_NUM_REASONS];\n STATIC_INLINE void gc_record_full_sweep_reason(int reason) JL_NOTSAFEPOINT"
    }
  ]
}