{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60105",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60105/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60105/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60105/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60105",
  "id": 3613579302,
  "node_id": "PR_kwDOABkWpM6y0xye",
  "number": 60105,
  "title": "Add JLJITLinkMemoryManager (ports memory manager to JITLink)",
  "user": {
    "login": "xal-0",
    "id": 33556084,
    "node_id": "MDQ6VXNlcjMzNTU2MDg0",
    "avatar_url": "https://avatars.githubusercontent.com/u/33556084?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/xal-0",
    "html_url": "https://github.com/xal-0",
    "followers_url": "https://api.github.com/users/xal-0/followers",
    "following_url": "https://api.github.com/users/xal-0/following{/other_user}",
    "gists_url": "https://api.github.com/users/xal-0/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/xal-0/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/xal-0/subscriptions",
    "organizations_url": "https://api.github.com/users/xal-0/orgs",
    "repos_url": "https://api.github.com/users/xal-0/repos",
    "events_url": "https://api.github.com/users/xal-0/events{/privacy}",
    "received_events_url": "https://api.github.com/users/xal-0/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 115858,
      "node_id": "MDU6TGFiZWwxMTU4NTg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/performance",
      "name": "performance",
      "color": "d7e102",
      "default": false,
      "description": "Must go faster"
    },
    {
      "id": 6961181883,
      "node_id": "LA_kwDOABkWpM8AAAABnus0uw",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/reverted",
      "name": "reverted",
      "color": "EC7B22",
      "default": false,
      "description": "This PR has since been reverted"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 5,
  "created_at": "2025-11-11T19:17:44Z",
  "updated_at": "2025-11-22T01:20:34Z",
  "closed_at": "2025-11-13T00:13:14Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60105",
    "html_url": "https://github.com/JuliaLang/julia/pull/60105",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60105.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60105.patch",
    "merged_at": "2025-11-13T00:13:14Z"
  },
  "body": "Ports our RTDyLD memory manager to JITLink in order to avoid memory use regressions after switching to JITLink everywhere (#60031).  This is a direct port: finalization must happen all at once, because it invalidates all allocation `wr_ptr`s.  I decided it wasn't worth it to associate `OnFinalizedFunction` callbacks with each block, since they are large enough to make it extremely likely that all in-flight allocations land in the same block; everything must be relocated before finalization can happen.\r\n\r\nI plan to add support for DualMapAllocator on ARM64 macOS, as well as an alternative for executable memory later.  For now, we fall back to the old MapperJITLinkMemoryManager.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60105/reactions",
    "total_count": 6,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 3,
    "rocket": 3,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60105/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "e36f9f80cfccfe433246214565e5de7072381f34",
      "filename": "src/cgmemmgr.cpp",
      "status": "modified",
      "additions": 187,
      "deletions": 46,
      "changes": 233,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c5c99642cdd11687c7cb4fafc39009694371ae82/src%2Fcgmemmgr.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c5c99642cdd11687c7cb4fafc39009694371ae82/src%2Fcgmemmgr.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcgmemmgr.cpp?ref=c5c99642cdd11687c7cb4fafc39009694371ae82",
      "patch": "@@ -3,7 +3,11 @@\n #include \"llvm-version.h\"\n #include \"platform.h\"\n \n+#include <llvm/ExecutionEngine/JITLink/JITLink.h>\n+#include <llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h>\n+#include <llvm/ExecutionEngine/Orc/MapperJITLinkMemoryManager.h>\n #include <llvm/ExecutionEngine/SectionMemoryManager.h>\n+\n #include \"julia.h\"\n #include \"julia_internal.h\"\n \n@@ -460,26 +464,36 @@ struct Block {\n     }\n };\n \n+struct Allocation {\n+    // Address to write to (the one returned by the allocation function)\n+    void *wr_addr;\n+    // Runtime address\n+    void *rt_addr;\n+    size_t sz;\n+    bool relocated;\n+};\n+\n class RWAllocator {\n     static constexpr int nblocks = 8;\n     Block blocks[nblocks]{};\n public:\n     RWAllocator() JL_NOTSAFEPOINT = default;\n-    void *alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n+    Allocation alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n     {\n         size_t min_size = (size_t)-1;\n         int min_id = 0;\n         for (int i = 0;i < nblocks && blocks[i].ptr;i++) {\n             if (void *ptr = blocks[i].alloc(size, align))\n-                return ptr;\n+                return {ptr, ptr, size, false};\n             if (blocks[i].avail < min_size) {\n                 min_size = blocks[i].avail;\n                 min_id = i;\n             }\n         }\n         size_t block_size = get_block_size(size);\n         blocks[min_id].reset(map_anon_page(block_size), block_size);\n-        return blocks[min_id].alloc(size, align);\n+        void *ptr = blocks[min_id].alloc(size, align);\n+        return {ptr, ptr, size, false};\n     }\n };\n \n@@ -519,16 +533,6 @@ struct SplitPtrBlock : public Block {\n     }\n };\n \n-struct Allocation {\n-    // Address to write to (the one returned by the allocation function)\n-    void *wr_addr;\n-    // Runtime address\n-    void *rt_addr;\n-    size_t sz;\n-    bool relocated;\n-};\n-\n-template<bool exec>\n class ROAllocator {\n protected:\n     static constexpr int nblocks = 8;\n@@ -556,7 +560,7 @@ class ROAllocator {\n     }\n     // Allocations that have not been finalized yet.\n     SmallVector<Allocation, 16> allocations;\n-    void *alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n+    Allocation alloc(size_t size, size_t align) JL_NOTSAFEPOINT\n     {\n         size_t min_size = (size_t)-1;\n         int min_id = 0;\n@@ -572,8 +576,9 @@ class ROAllocator {\n                     wr_ptr = get_wr_ptr(block, ptr, size, align);\n                 }\n                 block.state |= SplitPtrBlock::Alloc;\n-                allocations.push_back(Allocation{wr_ptr, ptr, size, false});\n-                return wr_ptr;\n+                Allocation a{wr_ptr, ptr, size, false};\n+                allocations.push_back(a);\n+                return a;\n             }\n             if (block.avail < min_size) {\n                 min_size = block.avail;\n@@ -594,18 +599,21 @@ class ROAllocator {\n #ifdef _OS_WINDOWS_\n         block.state = SplitPtrBlock::Alloc;\n         void *wr_ptr = get_wr_ptr(block, ptr, size, align);\n-        allocations.push_back(Allocation{wr_ptr, ptr, size, false});\n+        Allocation a{wr_ptr, ptr, size, false};\n+        allocations.push_back(a);\n         ptr = wr_ptr;\n #else\n         block.state = SplitPtrBlock::Alloc | SplitPtrBlock::InitAlloc;\n-        allocations.push_back(Allocation{ptr, ptr, size, false});\n+        Allocation a{ptr, ptr, size, false};\n+        allocations.push_back(a);\n #endif\n-        return ptr;\n+        return a;\n     }\n };\n \n-template<bool exec>\n-class DualMapAllocator : public ROAllocator<exec> {\n+class DualMapAllocator : public ROAllocator {\n+    bool exec;\n+\n protected:\n     void *get_wr_ptr(SplitPtrBlock &block, void *rt_ptr, size_t, size_t) override JL_NOTSAFEPOINT\n     {\n@@ -666,7 +674,7 @@ class DualMapAllocator : public ROAllocator<exec> {\n         }\n     }\n public:\n-    DualMapAllocator() JL_NOTSAFEPOINT\n+    DualMapAllocator(bool exec) JL_NOTSAFEPOINT : exec(exec)\n     {\n         assert(anon_hdl != -1);\n     }\n@@ -679,13 +687,13 @@ class DualMapAllocator : public ROAllocator<exec> {\n             finalize_block(block, true);\n             block.reset(nullptr, 0);\n         }\n-        ROAllocator<exec>::finalize();\n+        ROAllocator::finalize();\n     }\n };\n \n #ifdef _OS_LINUX_\n-template<bool exec>\n-class SelfMemAllocator : public ROAllocator<exec> {\n+class SelfMemAllocator : public ROAllocator {\n+    bool exec;\n     SmallVector<Block, 16> temp_buff;\n protected:\n     void *get_wr_ptr(SplitPtrBlock &block, void *rt_ptr,\n@@ -722,9 +730,7 @@ class SelfMemAllocator : public ROAllocator<exec> {\n         }\n     }\n public:\n-    SelfMemAllocator() JL_NOTSAFEPOINT\n-        : ROAllocator<exec>(),\n-          temp_buff()\n+    SelfMemAllocator(bool exec) JL_NOTSAFEPOINT : exec(exec), temp_buff()\n     {\n         assert(get_self_mem_fd() != -1);\n     }\n@@ -758,11 +764,25 @@ class SelfMemAllocator : public ROAllocator<exec> {\n         }\n         if (cached)\n             temp_buff.resize(1);\n-        ROAllocator<exec>::finalize();\n+        ROAllocator::finalize();\n     }\n };\n #endif // _OS_LINUX_\n \n+std::pair<std::unique_ptr<ROAllocator>, std::unique_ptr<ROAllocator>>\n+get_preferred_allocators() JL_NOTSAFEPOINT\n+{\n+#ifdef _OS_LINUX_\n+    if (get_self_mem_fd() != -1)\n+        return {std::make_unique<SelfMemAllocator>(false),\n+                std::make_unique<SelfMemAllocator>(true)};\n+#endif\n+    if (init_shared_map() != -1)\n+        return {std::make_unique<DualMapAllocator>(false),\n+                std::make_unique<DualMapAllocator>(true)};\n+    return {};\n+}\n+\n class RTDyldMemoryManagerJL : public SectionMemoryManager {\n     struct EHFrame {\n         uint8_t *addr;\n@@ -772,29 +792,18 @@ class RTDyldMemoryManagerJL : public SectionMemoryManager {\n     void operator=(const RTDyldMemoryManagerJL&) = delete;\n     SmallVector<EHFrame, 16> pending_eh;\n     RWAllocator rw_alloc;\n-    std::unique_ptr<ROAllocator<false>> ro_alloc;\n-    std::unique_ptr<ROAllocator<true>> exe_alloc;\n+    std::unique_ptr<ROAllocator> ro_alloc;\n+    std::unique_ptr<ROAllocator> exe_alloc;\n     size_t total_allocated;\n \n public:\n     RTDyldMemoryManagerJL() JL_NOTSAFEPOINT\n         : SectionMemoryManager(),\n           pending_eh(),\n           rw_alloc(),\n-          ro_alloc(),\n-          exe_alloc(),\n           total_allocated(0)\n     {\n-#ifdef _OS_LINUX_\n-        if (!ro_alloc && get_self_mem_fd() != -1) {\n-            ro_alloc.reset(new SelfMemAllocator<false>());\n-            exe_alloc.reset(new SelfMemAllocator<true>());\n-        }\n-#endif\n-        if (!ro_alloc && init_shared_map() != -1) {\n-            ro_alloc.reset(new DualMapAllocator<false>());\n-            exe_alloc.reset(new DualMapAllocator<true>());\n-        }\n+        std::tie(ro_alloc, exe_alloc) = get_preferred_allocators();\n     }\n     ~RTDyldMemoryManagerJL() override JL_NOTSAFEPOINT\n     {\n@@ -847,7 +856,7 @@ uint8_t *RTDyldMemoryManagerJL::allocateCodeSection(uintptr_t Size,\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITSize, Size);\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITCodeSize, Size);\n     if (exe_alloc)\n-        return (uint8_t*)exe_alloc->alloc(Size, Alignment);\n+        return (uint8_t*)exe_alloc->alloc(Size, Alignment).wr_addr;\n     return SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID,\n                                                      SectionName);\n }\n@@ -862,9 +871,9 @@ uint8_t *RTDyldMemoryManagerJL::allocateDataSection(uintptr_t Size,\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITSize, Size);\n     jl_timing_counter_inc(JL_TIMING_COUNTER_JITDataSize, Size);\n     if (!isReadOnly)\n-        return (uint8_t*)rw_alloc.alloc(Size, Alignment);\n+        return (uint8_t*)rw_alloc.alloc(Size, Alignment).wr_addr;\n     if (ro_alloc)\n-        return (uint8_t*)ro_alloc->alloc(Size, Alignment);\n+        return (uint8_t*)ro_alloc->alloc(Size, Alignment).wr_addr;\n     return SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID,\n                                                      SectionName, isReadOnly);\n }\n@@ -919,6 +928,133 @@ void RTDyldMemoryManagerJL::deregisterEHFrames(uint8_t *Addr,\n }\n #endif\n \n+class JLJITLinkMemoryManager : public jitlink::JITLinkMemoryManager {\n+    using OnFinalizedFunction =\n+        jitlink::JITLinkMemoryManager::InFlightAlloc::OnFinalizedFunction;\n+\n+    std::mutex Mutex;\n+    RWAllocator RWAlloc;\n+    std::unique_ptr<ROAllocator> ROAlloc;\n+    std::unique_ptr<ROAllocator> ExeAlloc;\n+    SmallVector<OnFinalizedFunction> FinalizedCallbacks;\n+    uint32_t InFlight{0};\n+\n+public:\n+    class InFlightAlloc;\n+\n+    static std::unique_ptr<JITLinkMemoryManager> Create()\n+    {\n+        auto [ROAlloc, ExeAlloc] = get_preferred_allocators();\n+        if (ROAlloc && ExeAlloc)\n+            return std::unique_ptr<JLJITLinkMemoryManager>(\n+                new JLJITLinkMemoryManager(std::move(ROAlloc), std::move(ExeAlloc)));\n+\n+        return cantFail(\n+            orc::MapperJITLinkMemoryManager::CreateWithMapper<orc::InProcessMemoryMapper>(\n+                /*Reservation Granularity*/ 16 * 1024 * 1024));\n+    }\n+\n+    void allocate(const jitlink::JITLinkDylib *JD, jitlink::LinkGraph &G,\n+                  OnAllocatedFunction OnAllocated) override;\n+\n+    void deallocate(std::vector<FinalizedAlloc> Allocs,\n+                    OnDeallocatedFunction OnDeallocated) override\n+    {\n+        jl_unreachable();\n+    }\n+\n+protected:\n+    JLJITLinkMemoryManager(std::unique_ptr<ROAllocator> ROAlloc,\n+                           std::unique_ptr<ROAllocator> ExeAlloc)\n+      : ROAlloc(std::move(ROAlloc)), ExeAlloc(std::move(ExeAlloc))\n+    {\n+    }\n+\n+    void finalize(OnFinalizedFunction OnFinalized)\n+    {\n+        SmallVector<OnFinalizedFunction> Callbacks;\n+        {\n+            std::unique_lock Lock{Mutex};\n+            FinalizedCallbacks.push_back(std::move(OnFinalized));\n+\n+            if (--InFlight > 0)\n+                return;\n+\n+            ROAlloc->finalize();\n+            ExeAlloc->finalize();\n+            Callbacks = std::move(FinalizedCallbacks);\n+        }\n+\n+        for (auto &CB : Callbacks)\n+            std::move(CB)(FinalizedAlloc{});\n+    }\n+};\n+\n+class JLJITLinkMemoryManager::InFlightAlloc\n+  : public jitlink::JITLinkMemoryManager::InFlightAlloc {\n+    JLJITLinkMemoryManager &MM;\n+    jitlink::LinkGraph &G;\n+\n+public:\n+    InFlightAlloc(JLJITLinkMemoryManager &MM, jitlink::LinkGraph &G) : MM(MM), G(G) {}\n+\n+    void abandon(OnAbandonedFunction OnAbandoned) override { jl_unreachable(); }\n+\n+    void finalize(OnFinalizedFunction OnFinalized) override\n+    {\n+        auto *GP = &G;\n+        MM.finalize([GP, OnFinalized =\n+                             std::move(OnFinalized)](Expected<FinalizedAlloc> FA) mutable {\n+            if (!FA)\n+                return OnFinalized(FA.takeError());\n+            // Need to handle dealloc actions when we GC code\n+            auto E = orc::shared::runFinalizeActions(GP->allocActions());\n+            if (!E)\n+                return OnFinalized(E.takeError());\n+            OnFinalized(std::move(FA));\n+        });\n+    }\n+};\n+\n+using orc::MemProt;\n+\n+void JLJITLinkMemoryManager::allocate(const jitlink::JITLinkDylib *JD,\n+                                      jitlink::LinkGraph &G,\n+                                      OnAllocatedFunction OnAllocated)\n+{\n+    jitlink::BasicLayout BL{G};\n+\n+    {\n+        std::unique_lock Lock{Mutex};\n+        for (auto &[AG, Seg] : BL.segments()) {\n+            if (AG.getMemLifetime() == orc::MemLifetime::NoAlloc)\n+                continue;\n+            assert(AG.getMemLifetime() == orc::MemLifetime::Standard);\n+\n+            auto Prot = AG.getMemProt();\n+            uint64_t Alignment = Seg.Alignment.value();\n+            uint64_t Size = Seg.ContentSize + Seg.ZeroFillSize;\n+            Allocation Alloc;\n+            if (Prot == (MemProt::Read | MemProt::Write))\n+                Alloc = RWAlloc.alloc(Size, Alignment);\n+            else if (Prot == MemProt::Read)\n+                Alloc = ROAlloc->alloc(Size, Alignment);\n+            else if (Prot == (MemProt::Read | MemProt::Exec))\n+                Alloc = ExeAlloc->alloc(Size, Alignment);\n+            else\n+                abort();\n+\n+            Seg.Addr = orc::ExecutorAddr::fromPtr(Alloc.rt_addr);\n+            Seg.WorkingMem = (char *)Alloc.wr_addr;\n+        }\n+    }\n+\n+    if (auto Err = BL.apply())\n+        return OnAllocated(std::move(Err));\n+\n+    ++InFlight;\n+    OnAllocated(std::make_unique<InFlightAlloc>(*this, G));\n+}\n }\n \n RTDyldMemoryManager* createRTDyldMemoryManager() JL_NOTSAFEPOINT\n@@ -930,3 +1066,8 @@ size_t getRTDyldMemoryManagerTotalBytes(RTDyldMemoryManager *mm) JL_NOTSAFEPOINT\n {\n     return ((RTDyldMemoryManagerJL*)mm)->getTotalBytes();\n }\n+\n+std::unique_ptr<jitlink::JITLinkMemoryManager> createJITLinkMemoryManager()\n+{\n+    return JLJITLinkMemoryManager::Create();\n+}"
    },
    {
      "sha": "90091cc1f38dbbbb2f30cef8e709fdf5e74a68d8",
      "filename": "src/jitlayers.cpp",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c5c99642cdd11687c7cb4fafc39009694371ae82/src%2Fjitlayers.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c5c99642cdd11687c7cb4fafc39009694371ae82/src%2Fjitlayers.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjitlayers.cpp?ref=c5c99642cdd11687c7cb4fafc39009694371ae82",
      "patch": "@@ -1208,12 +1208,6 @@ class JLMemoryUsagePlugin : public ObjectLinkingLayer::Plugin {\n #pragma clang diagnostic ignored \"-Wunused-function\"\n #endif\n \n-// TODO: Port our memory management optimisations to JITLink instead of using the\n-// default InProcessMemoryManager.\n-std::unique_ptr<jitlink::JITLinkMemoryManager> createJITLinkMemoryManager() JL_NOTSAFEPOINT {\n-    return cantFail(orc::MapperJITLinkMemoryManager::CreateWithMapper<orc::InProcessMemoryMapper>(/*Reservation Granularity*/ 16 * 1024 * 1024));\n-}\n-\n #ifdef _COMPILER_CLANG_\n #pragma clang diagnostic pop\n #endif\n@@ -1237,6 +1231,7 @@ class JLEHFrameRegistrar final : public jitlink::EHFrameRegistrar {\n };\n \n RTDyldMemoryManager *createRTDyldMemoryManager(void) JL_NOTSAFEPOINT;\n+std::unique_ptr<jitlink::JITLinkMemoryManager> createJITLinkMemoryManager() JL_NOTSAFEPOINT;\n \n // A simple forwarding class, since OrcJIT v2 needs a unique_ptr, while we have a shared_ptr\n class ForwardingMemoryManager : public RuntimeDyld::MemoryManager {"
    }
  ]
}