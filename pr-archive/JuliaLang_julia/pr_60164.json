{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60164",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60164/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60164/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60164/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60164",
  "id": 3637741140,
  "node_id": "PR_kwDOABkWpM60Fvtr",
  "number": 60164,
  "title": "Fix linearly indexed array math by reshaping arrays",
  "user": {
    "login": "jishnub",
    "id": 10461665,
    "node_id": "MDQ6VXNlcjEwNDYxNjY1",
    "avatar_url": "https://avatars.githubusercontent.com/u/10461665?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jishnub",
    "html_url": "https://github.com/jishnub",
    "followers_url": "https://api.github.com/users/jishnub/followers",
    "following_url": "https://api.github.com/users/jishnub/following{/other_user}",
    "gists_url": "https://api.github.com/users/jishnub/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jishnub/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jishnub/subscriptions",
    "organizations_url": "https://api.github.com/users/jishnub/orgs",
    "repos_url": "https://api.github.com/users/jishnub/repos",
    "events_url": "https://api.github.com/users/jishnub/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jishnub/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 62693664,
      "node_id": "MDU6TGFiZWw2MjY5MzY2NA==",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/arrays",
      "name": "arrays",
      "color": "006b75",
      "default": false,
      "description": "[a, r, r, a, y, s]"
    },
    {
      "id": 414648058,
      "node_id": "MDU6TGFiZWw0MTQ2NDgwNTg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/bugfix",
      "name": "bugfix",
      "color": "15ff91",
      "default": false,
      "description": "This change fixes an existing bug"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 5,
  "created_at": "2025-11-18T11:44:31Z",
  "updated_at": "2025-11-26T14:56:24Z",
  "closed_at": "2025-11-26T14:56:22Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60164",
    "html_url": "https://github.com/JuliaLang/julia/pull/60164",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60164.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60164.patch",
    "merged_at": "2025-11-26T14:56:22Z"
  },
  "body": "This was broken in https://github.com/JuliaLang/julia/pull/59961, as `map` deals with trailing singleton axes differently from broadcasting:\r\n```julia\r\njulia> map(+, ones(1), ones(1,1)) |> size\r\n(1,)\r\n\r\njulia> broadcast(+, ones(1), ones(1,1)) |> size\r\n(1, 1)\r\n```\r\nThis PR limits the new method to the case where the ndims match, in which case there are no trailing axes and the two are equivalent. The alternate approach suggested in https://github.com/JuliaLang/julia/pull/59961#issuecomment-3543230569 is to reshape the arrays, but this adds overhead that nullifies the performance improvement for small arrays.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60164/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60164/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "31ecb48daff68cae479d711fda45b2758bd94952",
      "filename": "base/arraymath.jl",
      "status": "modified",
      "additions": 18,
      "deletions": 6,
      "changes": 24,
      "blob_url": "https://github.com/JuliaLang/julia/blob/94ba21b88d42ccb210e7aea14ad1c5d35d99bcf5/base%2Farraymath.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/94ba21b88d42ccb210e7aea14ad1c5d35d99bcf5/base%2Farraymath.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Farraymath.jl?ref=94ba21b88d42ccb210e7aea14ad1c5d35d99bcf5",
      "patch": "@@ -9,8 +9,19 @@ end\n # Using map over broadcast enables vectorization for wide matrices with few rows.\n # This is because we use linear indexing in `map` as opposed to Cartesian indexing in broadcasting.\n # https://github.com/JuliaLang/julia/issues/47873#issuecomment-1352472461\n-function _broadcast_preserving_zero_d(f, A::Array, B::Array)\n-    map(f, A, B)\n+function _broadcast_preserving_zero_d(f, A::Array{<:Any,N}, B::Array{<:Any,N}, Cs::Array{<:Any,N}...) where {N}\n+    map(f, A, B, Cs...)\n+end\n+\n+function _broadcast_preserving_zero_d(f, A::Array, B::Array, Cs::Array...)\n+    # we already know that the shapes are compatible.\n+    # We just need to select the size corresponding to the higest ndims\n+    # and reshape all the arrays to that size\n+    arrays = (A, B, Cs...)\n+    sz = mapreduce(size, (x,y) -> length(x) > length(y) ? x : y, arrays)\n+    # Skip reshaping where possible to avoid the overhead\n+    arrays_sameshape = map(x -> length(sz) == ndims(x) ? x : reshape(x, sz), arrays)\n+    map(f, arrays_sameshape...)\n end\n \n function _broadcast_preserving_zero_d(f, A::Array, B::Number)\n@@ -28,11 +39,12 @@ for f in (:+, :-)\n     end\n end\n \n-function +(A::Array, Bs::Array...)\n-    for B in Bs\n-        promote_shape(A, B) # check size compatibility\n+function +(A::Array, B::Array, Cs::Array...)\n+    promote_shape(A, B)\n+    for C in Cs\n+        promote_shape(A, C) # check size compatibility\n     end\n-    map(+, A, Bs...)\n+    _broadcast_preserving_zero_d(+, A, B, Cs...)\n end\n \n for f in (:/, :\\, :*)"
    },
    {
      "sha": "122109cbff00678d2ab93b6ddac9bbcc5cb8236e",
      "filename": "test/abstractarray.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/JuliaLang/julia/blob/94ba21b88d42ccb210e7aea14ad1c5d35d99bcf5/test%2Fabstractarray.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/94ba21b88d42ccb210e7aea14ad1c5d35d99bcf5/test%2Fabstractarray.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fabstractarray.jl?ref=94ba21b88d42ccb210e7aea14ad1c5d35d99bcf5",
      "patch": "@@ -2376,3 +2376,16 @@ end\n     show(io, m2)\n     @test String(take!(io)) == \"Any[#= circular reference @-1 =# 3; 2 4;;; 5 7; 6 8]\"\n end\n+\n+@testset \"size promotion in addition/subtraction\" begin\n+    for A in Any[ones(), ones(1), ones(1,1,1)]\n+        @test +(A) == A\n+        for B in Any[ones(), ones(1), ones(1,1,1)]\n+            sz = ndims(A) > ndims(B) ? size(A) : size(B)\n+            @test A + B == fill(2.0,sz)\n+            @test A - B == zeros(sz)\n+            @test A + B + zeros() == A + B\n+            @test A - B - zeros() == A - B\n+        end\n+    end\n+end"
    }
  ]
}