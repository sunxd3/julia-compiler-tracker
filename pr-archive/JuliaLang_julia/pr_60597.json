{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60597",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60597/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60597/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60597/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60597",
  "id": 3792000467,
  "node_id": "PR_kwDOABkWpM68E1IS",
  "number": 60597,
  "title": "flisp: Port closure box optimization fixes from JuliaLowering.jl",
  "user": {
    "login": "aviatesk",
    "id": 40514306,
    "node_id": "MDQ6VXNlcjQwNTE0MzA2",
    "avatar_url": "https://avatars.githubusercontent.com/u/40514306?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/aviatesk",
    "html_url": "https://github.com/aviatesk",
    "followers_url": "https://api.github.com/users/aviatesk/followers",
    "following_url": "https://api.github.com/users/aviatesk/following{/other_user}",
    "gists_url": "https://api.github.com/users/aviatesk/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/aviatesk/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/aviatesk/subscriptions",
    "organizations_url": "https://api.github.com/users/aviatesk/orgs",
    "repos_url": "https://api.github.com/users/aviatesk/repos",
    "events_url": "https://api.github.com/users/aviatesk/events{/privacy}",
    "received_events_url": "https://api.github.com/users/aviatesk/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 13,
  "created_at": "2026-01-08T08:56:43Z",
  "updated_at": "2026-01-11T03:27:19Z",
  "closed_at": "2026-01-09T20:47:33Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60597",
    "html_url": "https://github.com/JuliaLang/julia/pull/60597",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60597.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60597.patch",
    "merged_at": "2026-01-09T20:47:33Z"
  },
  "body": "This change ports fixes for existing issues in closure box\r\noptimization from JuliaLowering.jl to flisp (JuliaLang/julia#37690). The fixes were\r\ndeveloped during discussions that arose while working on\r\nJuliaLang/julia#60567.\r\n\r\nThis consists of three commits, which should resolve all the\r\nissues raised in JuliaLang/julia#37690.\r\n\r\nFixes part of JuliaLang/julia#37690.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60597/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60597/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "c6e34d9db79fb74fed5ec932cd032d268589a5db",
      "filename": "src/julia-syntax.scm",
      "status": "modified",
      "additions": 23,
      "deletions": 13,
      "changes": 36,
      "blob_url": "https://github.com/JuliaLang/julia/blob/268f80d701808edc5686b83d8b9d8ca46df48abe/src%2Fjulia-syntax.scm",
      "raw_url": "https://github.com/JuliaLang/julia/raw/268f80d701808edc5686b83d8b9d8ca46df48abe/src%2Fjulia-syntax.scm",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia-syntax.scm?ref=268f80d701808edc5686b83d8b9d8ca46df48abe",
      "patch": "@@ -3943,11 +3943,12 @@ f(x) = yt(x)\n           (let ((am (all-methods-for ex stmts)))\n             (put! allmethods-table mn am)\n             am))))\n-  ;; This does a basic-block-local dominance analysis to find variables that\n+  ;; This does a syntactic block-local dominance analysis to find variables that\n   ;; are never used undef.\n   (let ((vi     (car (lam:vinfo lam)))\n         (args   (lam:argnames lam))\n         (decl   (table))\n+        (outer-decl (table))\n         (unused (table))  ;; variables not (yet) used (read from) in the current block\n         (live   (table))  ;; variables that have been set in the current block\n         (seen   (table))) ;; all variables we've seen assignments to\n@@ -3957,7 +3958,16 @@ f(x) = yt(x)\n                 (if (and (vinfo:capt v) (vinfo:sa v))\n                     (put! unused (car v) #t)))\n               vi)\n+    ;; Initialize decl with arguments since they're implicitly declared outside any loop\n+    (for-each (lambda (arg)\n+                (if (has? unused arg)\n+                    (put! decl arg #t)))\n+              args)\n     (define (restore old)\n+      (table.foreach (lambda (k v)\n+                       (if (and (has? old k) (not (has? unused k)))\n+                         (del! old k)))\n+                     outer-decl)\n       (table.foreach (lambda (k v)\n                        (if (not (has? old k))\n                            (put! unused k v)))\n@@ -3985,14 +3995,14 @@ f(x) = yt(x)\n     (define (declare! var)\n       (if (has? unused var)\n           (put! decl var #t)))\n-    (define (leave-loop! old-decls)\n-      ;; at the end of a loop, remove live variables that were declared outside,\n-      ;; since those might be assigned multiple times (issue #37690)\n-      (for-each (lambda (k)\n-                  (if (has? old-decls k)\n-                      (del! live k)))\n-                (table.keys live))\n-      (set! decl old-decls))\n+    (define (enter-loop!)\n+      (let ((outer-decl- outer-decl))\n+        (set! outer-decl decl)\n+        (set! decl (table.clone decl))\n+        outer-decl-))\n+    (define (leave-loop! old-outer-decl)\n+      (set! decl outer-decl)\n+      (set! outer-decl old-outer-decl))\n     (define (visit e)\n       ;; returns whether e contained a symboliclabel\n       (cond ((atom? e) (if (symbol? e) (mark-used e))\n@@ -4025,12 +4035,12 @@ f(x) = yt(x)\n                    (begin (restore prev) #f))))\n             ((or (eq? (car e) '_while) (eq? (car e) '_do_while))\n              (let ((prev  (table.clone live))\n-                   (decl- (table.clone decl)))\n+                   (old-decls (enter-loop!)))\n                (let ((result (eager-any visit (cdr e))))\n-                 (leave-loop! decl-)\n+                 (leave-loop! old-decls)\n                  (if result\n-                     #t\n-                     (begin (restore prev) #f)))))\n+                    #t\n+                    (begin (restore prev) #f)))))\n             ((eq? (car e) '=)\n              (begin0 (visit (caddr e))\n                      (assign! (cadr e))))"
    },
    {
      "sha": "874f5a0e34bd0ee2ebb2d8c4d8f3df0b3d23ddbf",
      "filename": "test/syntax.jl",
      "status": "modified",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/JuliaLang/julia/blob/268f80d701808edc5686b83d8b9d8ca46df48abe/test%2Fsyntax.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/268f80d701808edc5686b83d8b9d8ca46df48abe/test%2Fsyntax.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fsyntax.jl?ref=268f80d701808edc5686b83d8b9d8ca46df48abe",
      "patch": "@@ -1932,6 +1932,43 @@ let f = capture_with_conditional_label()  # should not throw\n     @test_throws UndefVarError(:x, :local) f(0)\n end\n \n+# Label can be jumped to, bypassing assignment - needs Box\n+let\n+    @goto L\n+    y = 1\n+    @label L\n+    f = ()->y\n+    @test_throws UndefVarError(:y, :local) f()\n+end\n+\n+# Argument reassigned inside loop needs Box (argument is implicitly declared outside loop)\n+function f_arg_loop(x)\n+    local f\n+    for i in 1:2\n+        x = i\n+        i == 1 && (f = ()->x;)\n+    end\n+    f()\n+end\n+@test f_arg_loop(0) == 2\n+\n+# Variable in while-true loop with break needs Box\n+function f_break_loop()\n+    local f\n+    local x\n+    i = 1\n+    while true\n+        x = i\n+        if i == 1\n+            f = ()->x\n+        end\n+        i >= 3 && break\n+        i += 1\n+    end\n+    f()\n+end\n+@test f_break_loop() == 3\n+\n # `_` should not create a global (or local)\n f30656(T) = (t, _)::Pair -> t >= T\n f30656(10)(11=>1)"
    }
  ]
}