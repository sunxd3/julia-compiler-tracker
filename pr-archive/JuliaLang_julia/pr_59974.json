{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59974",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59974/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59974/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59974/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59974",
  "id": 3558418628,
  "node_id": "PR_kwDOABkWpM6v-v8T",
  "number": 59974,
  "title": "inference: revisit all methods in cycle",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 421532175,
      "node_id": "MDU6TGFiZWw0MjE1MzIxNzU=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:inference",
      "name": "compiler:inference",
      "color": "bfdadc",
      "default": false,
      "description": "Type inference"
    },
    {
      "id": 5674040959,
      "node_id": "LA_kwDOABkWpM8AAAABUjL-fw",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/backport%201.10",
      "name": "backport 1.10",
      "color": "A49B65",
      "default": false,
      "description": "Change should be backported to the 1.10 release"
    },
    {
      "id": 6567868799,
      "node_id": "LA_kwDOABkWpM8AAAABh3m5fw",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/backport%201.11",
      "name": "backport 1.11",
      "color": "d4c5f9",
      "default": false,
      "description": "Change should be backported to release-1.11"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 3,
  "created_at": "2025-10-27T20:03:11Z",
  "updated_at": "2025-11-21T11:29:18Z",
  "closed_at": "2025-11-01T02:52:03Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59974",
    "html_url": "https://github.com/JuliaLang/julia/pull/59974",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59974.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59974.patch",
    "merged_at": "2025-11-01T02:52:03Z"
  },
  "body": "When encountering complicated cycles within cycles, make sure to revisit all applicable methods explicitly, since not all methods within the cycle will necessarily change return type after resolving the cycle. This shows up as the possibility of frames that don't get revisited before being cached, probably just caching `Union{}` as the call type instead. I always assumed this code was probably wrong, but didn't have any way to construct the counter-example to have confidence that fixing it would not cause some other side-effect. But still keep the backedge work lazy, since we don't want to allocate unnecessarily for a rarely used feature (recursion).\r\n\r\nFix #59943",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59974/reactions",
    "total_count": 2,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 2,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59974/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "a1f27205172cb6e7ccdd082e693db8e6da97643d",
      "filename": "Compiler/src/typeinfer.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 12,
      "changes": 17,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f5d319e7534658ca12301e8cabb5081069ac983c/Compiler%2Fsrc%2Ftypeinfer.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f5d319e7534658ca12301e8cabb5081069ac983c/Compiler%2Fsrc%2Ftypeinfer.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftypeinfer.jl?ref=f5d319e7534658ca12301e8cabb5081069ac983c",
      "patch": "@@ -891,17 +891,10 @@ function type_annotate!(::AbstractInterpreter, sv::InferenceState)\n end\n \n function merge_call_chain!(::AbstractInterpreter, parent::InferenceState, child::InferenceState)\n-    # add backedge of parent <- child\n-    # then add all backedges of parent <- parent.parent\n+    # update all cycleid to be in the same group\n     frames = parent.callstack::Vector{AbsIntState}\n     @assert child.callstack === frames\n     ancestorid = child.cycleid\n-    while true\n-        add_cycle_backedge!(parent, child)\n-        parent.cycleid === ancestorid && break\n-        child = parent\n-        parent = cycle_parent(child)::InferenceState\n-    end\n     # ensure that walking the callstack has the same cycleid (DAG)\n     for frameid = reverse(ancestorid:length(frames))\n         frame = frames[frameid]::InferenceState\n@@ -912,7 +905,6 @@ function merge_call_chain!(::AbstractInterpreter, parent::InferenceState, child:\n end\n \n function add_cycle_backedge!(caller::InferenceState, frame::InferenceState)\n-    update_valid_age!(caller, frame.world.valid_worlds)\n     backedge = (caller, caller.currpc)\n     contains_is(frame.cycle_backedges, backedge) || push!(frame.cycle_backedges, backedge)\n     return frame\n@@ -931,9 +923,8 @@ end\n # frame matching `mi` is encountered, then there is a cycle in the call graph\n # (i.e. `mi` is a descendant callee of itself). Upon encountering this cycle,\n # we \"resolve\" it by merging the call chain, which entails updating each intermediary\n-# frame's `cycleid` field and adding the appropriate backedges. Finally,\n-# we return `mi`'s pre-existing frame. If no cycles are found, `nothing` is\n-# returned instead.\n+# frame's `cycleid` field. Finally, we return `mi`'s pre-existing frame.\n+# If no cycles are found, `nothing` is returned instead.\n function resolve_call_cycle!(interp::AbstractInterpreter, mi::MethodInstance, parent::AbsIntState)\n     # TODO (#48913) implement a proper recursion handling for irinterp:\n     # This works most of the time currently just because the irinterp code doesn't get used much with\n@@ -1117,6 +1108,7 @@ function typeinf_edge(interp::AbstractInterpreter, method::Method, @nospecialize\n                     result.ci_as_edge = edge_ci # set the edge for the inliner usage\n                     VolatileInferenceResult(result)\n                 end\n+                isinferred || add_cycle_backedge!(caller, frame)\n                 mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,\n                     edge, edgecycle, edgelimited, volatile_inf_result)\n                 return true\n@@ -1134,6 +1126,7 @@ function typeinf_edge(interp::AbstractInterpreter, method::Method, @nospecialize\n     effects = adjust_effects(effects_for_cycle(frame.ipo_effects), method)\n     bestguess = frame.bestguess\n     exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)\n+    add_cycle_backedge!(caller, frame)\n     return Future(MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects, nothing, edgecycle, edgelimited))\n end\n "
    }
  ]
}