{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60013",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60013/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60013/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60013/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60013",
  "id": 3577078181,
  "node_id": "PR_kwDOABkWpM6w8czZ",
  "number": 60013,
  "title": "signals: Implement fake_stack_pop for Linux on x86_64 and i686",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 414648058,
      "node_id": "MDU6TGFiZWw0MTQ2NDgwNTg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/bugfix",
      "name": "bugfix",
      "color": "15ff91",
      "default": false,
      "description": "This change fixes an existing bug"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 2,
  "created_at": "2025-11-01T03:01:18Z",
  "updated_at": "2026-01-09T13:32:05Z",
  "closed_at": "2025-12-06T19:33:23Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60013",
    "html_url": "https://github.com/JuliaLang/julia/pull/60013",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60013.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60013.patch",
    "merged_at": "2025-12-06T19:33:23Z"
  },
  "body": "Add fake_stack_pop implementation for Linux platforms to improve stack unwinding in debuggers when analyzing core dumps from signals like SIGQUIT. This provides proper DWARF Call Frame Information (CFI) directives that help unwinders locate saved register values on the manipulated stack.\r\n\r\nThe implementation follows the same pattern as the existing macOS version, with fake_stack_pop now unified in signals-unix.c to support both platforms:\r\n- x86_64: Uses .cfi_def_cfa %rsp with offsets for %rip and %rsp\r\n- i686: Uses .cfi_def_cfa %esp with offsets for %eip and %esp\r\n- aarch64: Uses .cfi_def_cfa sp with offsets for lr and sp\r\n\r\nThe jl_call_in_ctx function on Linux now sets up the stack similarly to jl_call_in_state on macOS, pushing saved register state and a return address pointing to fake_stack_pop to enable proper unwinding.\r\n\r\n\ud83e\udd16 Generated with Claude Code",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60013/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60013/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "bde8a40f196d4c8ac738812f5e6f9be36a74c0bd",
      "filename": "src/julia_threads.h",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src%2Fjulia_threads.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/a934511542a269f20b697a5fc81dc28c3907d1fd/src%2Fjulia_threads.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjulia_threads.h?ref=a934511542a269f20b697a5fc81dc28c3907d1fd",
      "patch": "@@ -186,6 +186,13 @@ typedef struct _jl_tls_states_t {\n #else\n     void *signal_stack;\n     size_t signal_stack_size;\n+#endif\n+#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_) || defined(_OS_OPENBSD_)\n+    // Saved context from jl_call_in_ctx for stack unwinding\n+    uintptr_t signal_ctx_pc;\n+    uintptr_t signal_ctx_sp;\n+    void (*signal_ctx_fptr)(void);\n+    uintptr_t signal_ctx_arg;\n #endif\n     jl_thread_t system_id;\n     _Atomic(int16_t) suspend_count;"
    },
    {
      "sha": "c64a01068b34b517bfe18463a017bed1fa7cb506",
      "filename": "src/signals-mach.c",
      "status": "modified",
      "additions": 51,
      "deletions": 51,
      "changes": 102,
      "blob_url": "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src%2Fsignals-mach.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/a934511542a269f20b697a5fc81dc28c3907d1fd/src%2Fsignals-mach.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-mach.c?ref=a934511542a269f20b697a5fc81dc28c3907d1fd",
      "patch": "@@ -220,36 +220,36 @@ typedef arm_exception_state64_t host_exception_state_t;\n #define HOST_EXCEPTION_STATE_COUNT ARM_EXCEPTION_STATE64_COUNT\n #endif\n \n-// create a fake function that describes the variable manipulations in jl_call_in_state\n-__attribute__((naked)) static void fake_stack_pop(void)\n+// Create a fake function that describes the register manipulations in jl_call_in_state\n+// The callee-saved registers still may get smashed (by the cdecl fptr), since we didn't explicitly copy all of the\n+// state to the stack (to build a real sigreturn frame).\n+__attribute__((naked)) static void jl_fake_signal_return(void)\n {\n-#ifdef _CPU_X86_64_\n-    __asm__ volatile (\n-        \"  .cfi_signal_frame\\n\"\n-        \"  .cfi_def_cfa %rsp, 0\\n\" // CFA here uses %rsp directly\n-        \"  .cfi_offset %rip, 0\\n\" // previous value of %rip at CFA\n-        \"  .cfi_offset %rsp, 8\\n\" // previous value of %rsp at CFA\n-        \"  nop\\n\"\n-    );\n+#if defined(_CPU_X86_64_)\n+__asm__(\n+    \"  .cfi_signal_frame\\n\"\n+    \"  .cfi_def_cfa %rsp, 0\\n\" // CFA here uses %rsp directly\n+    \"  .cfi_offset %rip, 0\\n\" // previous value of %rip at CFA\n+    \"  .cfi_offset %rsp, 8\\n\" // previous value of %rsp at CFA\n+    \"  ud2\\n\"\n+    \"  ud2\\n\"\n+);\n #elif defined(_CPU_AARCH64_)\n-    __asm__ volatile (\n-        \"  .cfi_signal_frame\\n\"\n-        \"  .cfi_def_cfa sp, 0\\n\" // use sp as fp here\n-        \"  .cfi_offset lr, 0\\n\"\n-        \"  .cfi_offset sp, 8\\n\"\n-        // Anything else got smashed, since we didn't explicitly copy all of the\n-        // state object to the stack (to build a real sigreturn frame).\n-        // This is also not quite valid, since the AArch64 DWARF spec lacks the ability to define how to restore the LR register correctly,\n-        // so normally libunwind implementations on linux detect this function specially and hack around the invalid info:\n-        // https://github.com/llvm/llvm-project/commit/c82deed6764cbc63966374baf9721331901ca958\n-        \" nop\\n\"\n-    );\n-#else\n-CFI_NORETURN\n+__asm__(\n+    \"  .cfi_signal_frame\\n\"\n+    \"  .cfi_def_cfa sp, 0\\n\" // use sp as fp here\n+    // This is not quite valid, since the AArch64 DWARF spec lacks the ability to define how to restore the LR register correctly,\n+    // so normally libunwind implementations on linux detect this function specially and hack around the invalid info:\n+    // https://github.com/llvm/llvm-project/commit/c82deed6764cbc63966374baf9721331901ca958\n+    \"  .cfi_offset lr, 0\\n\"\n+    \"  .cfi_offset sp, 8\\n\"\n+    \"  brk #1\\n\"\n+    \"  brk #1\\n\"\n+);\n #endif\n }\n \n-static void jl_call_in_state(host_thread_state_t *state, void (*fptr)(void))\n+static void jl_call_in_state1(host_thread_state_t *state, void (*fptr)(void), uintptr_t arg0)\n {\n #ifdef _CPU_X86_64_\n     uintptr_t sp = state->__rsp;\n@@ -258,51 +258,59 @@ static void jl_call_in_state(host_thread_state_t *state, void (*fptr)(void))\n #endif\n     sp = (sp - 256) & ~(uintptr_t)15; // redzone and re-alignment\n     assert(sp % 16 == 0);\n-    sp -= 16;\n #ifdef _CPU_X86_64_\n-    // set return address to NULL\n-    *(uintptr_t*)sp = 0;\n-    // pushq %sp\n+    // push {%rsp, %rip}\n     sp -= sizeof(void*);\n     *(uintptr_t*)sp = state->__rsp;\n-    // pushq %rip\n     sp -= sizeof(void*);\n     *(uintptr_t*)sp = state->__rip;\n-    // pushq .fake_stack_pop + 1; aka call from fake_stack_pop\n+    // pushq .jl_fake_signal_return + 1; aka call from jl_fake_signal_return\n     sp -= sizeof(void*);\n-    *(uintptr_t*)sp = (uintptr_t)&fake_stack_pop + 1;\n+    *(uintptr_t*)sp = (uintptr_t)&jl_fake_signal_return + 1;\n     state->__rsp = sp; // set stack pointer\n     state->__rip = (uint64_t)fptr; // \"call\" the function\n+    state->__rdi = arg0;\n #elif defined(_CPU_AARCH64_)\n-    // push {%sp, %pc + 4}\n+    // push {%sp, %pc}\n     sp -= sizeof(void*);\n     *(uintptr_t*)sp = state->__sp;\n     sp -= sizeof(void*);\n     *(uintptr_t*)sp = (uintptr_t)state->__pc;\n     state->__sp = sp; // x31\n     state->__pc = (uint64_t)fptr; // pc\n-    state->__lr = (uintptr_t)&fake_stack_pop + 4; // x30\n+    state->__lr = (uintptr_t)&jl_fake_signal_return + 4; // x30\n+    state->__x[0] = arg0;\n #else\n #error \"julia: throw-in-context not supported on this platform\"\n #endif\n }\n \n static void jl_longjmp_in_state(host_thread_state_t *state, jl_jmp_buf jmpbuf)\n {\n-\n     if (!jl_simulate_longjmp(jmpbuf, (bt_context_t*)state)) {\n         // for sanitizer builds, fallback to calling longjmp on the original stack\n         // (this will fail for stack overflow, but that is hardly sanitizer-legal anyways)\n #ifdef _CPU_X86_64_\n-    state->__rdi = (uintptr_t)jmpbuf;\n-    state->__rsi = 1;\n+        uintptr_t sp = state->__rsp;\n+#elif defined(_CPU_AARCH64_)\n+        uintptr_t sp = state->__sp;\n+#endif\n+        sp = (sp - 256) & ~(uintptr_t)15; // redzone and re-alignment\n+        assert(sp % 16 == 0);\n+#ifdef _CPU_X86_64_\n+        state->__rdi = (uintptr_t)jmpbuf;\n+        state->__rsi = 1;\n+        state->__rsp = sp; // set stack pointer\n+        state->__rip = (uint64_t)longjmp; // \"call\" the function\n #elif defined(_CPU_AARCH64_)\n-    state->__x[0] = (uintptr_t)jmpbuf;\n-    state->__x[1] = 1;\n+        state->__x[0] = (uintptr_t)jmpbuf;\n+        state->__x[1] = 1;\n+        state->__sp = sp; // x31\n+        state->__pc = (uint64_t)longjmp; // pc\n+        state->__lr = (uintptr_t)0; // x30\n #else\n-#error \"julia: jl_longjmp_in_state not supported on this platform\"\n+#error \"julia: throw-in-context not supported on this platform\"\n #endif\n-        jl_call_in_state(state, (void (*)(void))longjmp);\n     }\n }\n \n@@ -577,7 +585,7 @@ static void jl_try_deliver_sigint(void)\n     HANDLE_MACH_ERROR(\"thread_resume\", ret);\n }\n \n-static void JL_NORETURN jl_exit_thread0_cb(int signo)\n+static void jl_exit_thread0_cb(int signo)\n {\n     jl_fprint_critical_error(ios_safe_stderr, signo, 0, NULL, jl_current_task);\n     jl_atexit_hook(128);\n@@ -602,15 +610,7 @@ static void jl_exit_thread0(int signo, jl_bt_element_t *bt_data, size_t bt_size)\n     ptls2->bt_size = bt_size; // <= JL_MAX_BT_SIZE\n     memcpy(ptls2->bt_data, bt_data, ptls2->bt_size * sizeof(bt_data[0]));\n \n-#ifdef _CPU_X86_64_\n-    // First integer argument. Not portable but good enough =)\n-    state.__rdi = signo;\n-#elif defined(_CPU_AARCH64_)\n-    state.__x[0] = signo;\n-#else\n-#error Fill in first integer argument here\n-#endif\n-    jl_call_in_state(&state, (void (*)(void))&jl_exit_thread0_cb);\n+    jl_call_in_state1(&state, (void (*)(void))&jl_exit_thread0_cb, signo);\n     unsigned int count = MACH_THREAD_STATE_COUNT;\n     ret = thread_set_state(thread, MACH_THREAD_STATE, (thread_state_t)&state, count);\n     HANDLE_MACH_ERROR(\"thread_set_state\", ret);"
    },
    {
      "sha": "232e32b3f335fef84456cf6839f78394267005cf",
      "filename": "src/signals-unix.c",
      "status": "modified",
      "additions": 149,
      "deletions": 28,
      "changes": 177,
      "blob_url": "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src%2Fsignals-unix.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/a934511542a269f20b697a5fc81dc28c3907d1fd/src%2Fsignals-unix.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-unix.c?ref=a934511542a269f20b697a5fc81dc28c3907d1fd",
      "patch": "@@ -70,6 +70,95 @@ int jl_simulate_longjmp(jl_jmp_buf mctx, bt_context_t *c) JL_NOTSAFEPOINT;\n static void jl_longjmp_in_ctx(int sig, void *_ctx, jl_jmp_buf jmpbuf);\n \n #if !defined(_OS_DARWIN_)\n+extern void jl_fake_signal_return(void);\n+// Create a trampoline function that does the stack manipulations for jl_call_in_ctx/jl_call_in_state\n+// The callee-saved registers still may get smashed (by the cdecl fptr), since we didn't explicitly copy all of the\n+// state to the stack (to build a real sigreturn frame).\n+#if (defined(_OS_LINUX_) || defined(_OS_FREEBSD_) || defined(_OS_OPENBSD_)) && defined(_CPU_X86_64_)\n+__asm__(\n+    \"  .type jl_fake_signal_return, @function\\n\"\n+    \"jl_fake_signal_return:\\n\"\n+    \"  .cfi_startproc\\n\"\n+    \"  .cfi_signal_frame\\n\"\n+    // Mark as end of stack until frame is set up\n+    \"  .cfi_undefined %rip\\n\"\n+    \"  .cfi_undefined %rsp\\n\"\n+    // rdi points to signal_ctx_pc in ptls (followed by signal_ctx_sp, signal_ctx_fptr, signal_ctx_arg)\n+    \"  pushq (%rdi)\\n\"        // push pc (signal_ctx_pc)\n+    \"  pushq 8(%rdi)\\n\"       // push sp (signal_ctx_sp)\n+    // stack layout: [sp, pc] (pc at higher address, like return address after call)\n+    \"  .cfi_def_cfa %rsp, 8\\n\"\n+    \"  .cfi_offset %rip, 0\\n\"  // previous %rip at CFA+0 (pc slot at rsp+8)\n+    \"  .cfi_offset %rsp, -8\\n\" // previous %rsp at CFA-8 (sp slot at rsp+0)\n+    \"  pushq 16(%rdi)\\n\"      // push fptr (signal_ctx_fptr)\n+    \"  .cfi_def_cfa %rsp, 16\\n\"\n+    \"  movq 24(%rdi), %rdi\\n\" // restore original rdi from signal_ctx_arg\n+    \"  subq $8, %rsp\\n\"       // align stack to 16 bytes\n+    \"  .cfi_def_cfa %rsp, 24\\n\"\n+    \"  callq *8(%rsp)\\n\"      // call fptr\n+    \"  ud2\\n\"                 // unreachable\n+    \"  .cfi_endproc\\n\"\n+    \"  .size jl_fake_signal_return, .-jl_fake_signal_return\\n\"\n+);\n+\n+#elif (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && defined(_CPU_X86_)\n+__asm__(\n+    \"  .type jl_fake_signal_return, @function\\n\"\n+    \"jl_fake_signal_return:\\n\"\n+    \"  .cfi_startproc\\n\"\n+    \"  .cfi_signal_frame\\n\"\n+    // Mark as end of stack until frame is set up\n+    \"  .cfi_undefined 1\\n\"\n+    // eax points to signal_ctx_pc in ptls (followed by signal_ctx_sp, signal_ctx_fptr, signal_ctx_arg)\n+    \"  pushl (%eax)\\n\"        // push pc (signal_ctx_pc)\n+    \"  pushl 4(%eax)\\n\"       // push sp (signal_ctx_sp)\n+    // stack layout: [sp, pc] (pc at higher address, like return address after call)\n+    \"  .cfi_def_cfa %esp, 4\\n\"\n+    \"  .cfi_offset %eip, 0\\n\"  // previous %eip at CFA+0 (pc slot at esp+4)\n+    \"  .cfi_offset %esp, -4\\n\" // previous %esp at CFA-4 (sp slot at esp+0)\n+    \"  pushl 8(%eax)\\n\"       // push fptr (signal_ctx_fptr)\n+    \"  .cfi_def_cfa %esp, 8\\n\"\n+    \"  movl 12(%eax), %eax\\n\" // restore original eax from signal_ctx_arg\n+    \"  subl $4, %esp\\n\"       // align stack to 16 bytes\n+    \"  .cfi_def_cfa %esp, 12\\n\"\n+    \"  calll *4(%esp)\\n\"      // call fptr\n+    \"  ud2\\n\"                 // unreachable\n+    \"  .cfi_endproc\\n\"\n+    \"  .size jl_fake_signal_return, .-jl_fake_signal_return\\n\"\n+);\n+#elif (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && defined(_CPU_AARCH64_)\n+__asm__(\n+    \"  .type jl_fake_signal_return, @function\\n\"\n+    \"jl_fake_signal_return:\\n\"\n+    \"  .cfi_startproc\\n\"\n+    \"  .cfi_signal_frame\\n\"\n+    // Mark as end of stack until frame is set up\n+    \"  .cfi_undefined 1\\n\"\n+    // x0 points to signal_ctx_pc in ptls (followed by signal_ctx_sp, signal_ctx_fptr, signal_ctx_arg)\n+    \"  ldp x1, x2, [x0]\\n\"      // load pc (x1) and sp (x2)\n+    \"  stp x2, x1, [sp, #-16]!\\n\" // push sp and pc (sp at lower addr, pc at higher addr)\n+    // stack layout: [sp, pc] (pc at higher address, like return address after call)\n+    \"  .cfi_def_cfa sp, 16\\n\"\n+    \"  .cfi_offset lr, -8\\n\"   // previous lr (pc) at CFA-8 (pc slot at sp+8)\n+    \"  .cfi_offset sp, -16\\n\"  // previous sp at CFA-16 (sp slot at sp+0)\n+    // This is not quite valid, since the AArch64 DWARF spec lacks the ability to define how to restore the LR register correctly,\n+    // so normally libunwind implementations on linux detect this function specially and hack around the invalid info:\n+    // https://github.com/llvm/llvm-project/commit/c82deed6764cbc63966374baf9721331901ca958\n+    \"  ldp x1, x2, [x0, #16]\\n\" // load fptr (x1) and saved x0 (x2)\n+    \"  mov x0, x2\\n\"           // restore original x0\n+    \"  blr x1\\n\"               // call fptr\n+    \"  brk #1\\n\"               // unreachable\n+    \"  .cfi_endproc\\n\"\n+    \"  .size jl_fake_signal_return, .-jl_fake_signal_return\\n\"\n+);\n+#else\n+extern void JL_NORETURN jl_fake_signal_return(void)\n+{\n+    CFI_NORETURN\n+    abort();\n+}\n+#endif\n+\n static inline uintptr_t jl_get_rsp_from_ctx(const void *_ctx)\n {\n #if defined(_OS_LINUX_) && defined(_CPU_X86_64_)\n@@ -123,46 +212,79 @@ JL_NO_ASAN static void jl_call_in_ctx(jl_ptls_t ptls, void (*fptr)(void), int si\n     // will not be part of the validation...\n     uintptr_t rsp = jl_get_rsp_from_ctx(_ctx);\n     rsp = (rsp - 256) & ~(uintptr_t)15; // redzone and re-alignment\n+    assert(rsp % 16 == 0);\n #if defined(_OS_LINUX_) && defined(_CPU_X86_64_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    rsp -= sizeof(void*);\n-    *(uintptr_t*)rsp = 0;\n-    ctx->uc_mcontext.gregs[REG_RSP] = rsp;\n-    ctx->uc_mcontext.gregs[REG_RIP] = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->uc_mcontext.gregs[REG_RIP];\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.gregs[REG_RSP];\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.gregs[REG_RDI];\n+    ctx->uc_mcontext.gregs[REG_RSP] = rsp; // set stack pointer\n+    ctx->uc_mcontext.gregs[REG_RDI] = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx\n+    ctx->uc_mcontext.gregs[REG_RIP] = (uintptr_t)&jl_fake_signal_return; // \"call\" jl_fake_signal_return\n #elif defined(_OS_FREEBSD_) && defined(_CPU_X86_64_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    rsp -= sizeof(void*);\n-    *(uintptr_t*)rsp = 0;\n-    ctx->uc_mcontext.mc_rsp = rsp;\n-    ctx->uc_mcontext.mc_rip = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->uc_mcontext.mc_rip;\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.mc_rsp;\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.mc_rdi;\n+    ctx->uc_mcontext.mc_rsp = rsp; // set stack pointer\n+    ctx->uc_mcontext.mc_rdi = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx\n+    ctx->uc_mcontext.mc_rip = (uintptr_t)&jl_fake_signal_return; // \"call\" jl_fake_signal_return\n #elif defined(_OS_LINUX_) && defined(_CPU_X86_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    rsp -= sizeof(void*);\n-    *(uintptr_t*)rsp = 0;\n-    ctx->uc_mcontext.gregs[REG_ESP] = rsp;\n-    ctx->uc_mcontext.gregs[REG_EIP] = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->uc_mcontext.gregs[REG_EIP];\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.gregs[REG_ESP];\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.gregs[REG_EAX];\n+    ctx->uc_mcontext.gregs[REG_ESP] = rsp; // set stack pointer\n+    ctx->uc_mcontext.gregs[REG_EAX] = (uintptr_t)&ptls->signal_ctx_pc; // set eax to point to signal_ctx\n+    ctx->uc_mcontext.gregs[REG_EIP] = (uintptr_t)&jl_fake_signal_return; // \"call\" jl_fake_signal_return\n #elif defined(_OS_FREEBSD_) && defined(_CPU_X86_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    rsp -= sizeof(void*);\n-    *(uintptr_t*)rsp = 0;\n-    ctx->uc_mcontext.mc_esp = rsp;\n-    ctx->uc_mcontext.mc_eip = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->uc_mcontext.mc_eip;\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.mc_esp;\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.mc_eax;\n+    ctx->uc_mcontext.mc_esp = rsp; // set stack pointer\n+    ctx->uc_mcontext.mc_eax = (uintptr_t)&ptls->signal_ctx_pc; // set eax to point to signal_ctx\n+    ctx->uc_mcontext.mc_eip = (uintptr_t)&jl_fake_signal_return; // \"call\" jl_fake_signal_return\n #elif defined(_OS_OPENBSD_) && defined(_CPU_X86_64_)\n     struct sigcontext *ctx = (struct sigcontext *)_ctx;\n-    rsp -= sizeof(void*);\n-    *(uintptr_t*)rsp = 0;\n-    ctx->sc_rsp = rsp;\n-    ctx->sc_rip = fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->sc_rip;\n+    ptls->signal_ctx_sp = ctx->sc_rsp;\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->sc_rdi;\n+    ctx->sc_rsp = rsp; // set stack pointer\n+    ctx->sc_rdi = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx\n+    ctx->sc_rip = (uintptr_t)&jl_fake_signal_return; // \"call\" jl_fake_signal_return\n #elif defined(_OS_LINUX_) && defined(_CPU_AARCH64_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    ctx->uc_mcontext.sp = rsp;\n-    ctx->uc_mcontext.regs[29] = 0; // Clear link register (x29)\n-    ctx->uc_mcontext.pc = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = (uintptr_t)ctx->uc_mcontext.pc;\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.sp;\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.regs[0];\n+    ctx->uc_mcontext.sp = rsp; // sp\n+    ctx->uc_mcontext.regs[0] = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx\n+    ctx->uc_mcontext.pc = (uint64_t)&jl_fake_signal_return; // pc\n+    ctx->uc_mcontext.regs[30] = 0; // clear lr (x30)\n #elif defined(_OS_FREEBSD_) && defined(_CPU_AARCH64_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n-    ctx->uc_mcontext.mc_gpregs.gp_sp = rsp;\n-    ctx->uc_mcontext.mc_gpregs.gp_x[29] = 0; // Clear link register (x29)\n-    ctx->uc_mcontext.mc_gpregs.gp_elr = (uintptr_t)fptr;\n+    // Save context in ptls for stack unwinding\n+    ptls->signal_ctx_pc = ctx->uc_mcontext.mc_gpregs.gp_elr;\n+    ptls->signal_ctx_sp = ctx->uc_mcontext.mc_gpregs.gp_sp;\n+    ptls->signal_ctx_fptr = fptr;\n+    ptls->signal_ctx_arg = ctx->uc_mcontext.mc_gpregs.gp_x[0];\n+    ctx->uc_mcontext.mc_gpregs.gp_sp = rsp; // set stack pointer\n+    ctx->uc_mcontext.mc_gpregs.gp_x[0] = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx\n+    ctx->uc_mcontext.mc_gpregs.gp_elr = (uintptr_t)&jl_fake_signal_return; // pc\n+    ctx->uc_mcontext.mc_gpregs.gp_lr = 0; // clear lr (x30)\n #elif defined(_OS_LINUX_) && defined(_CPU_ARM_)\n     ucontext_t *ctx = (ucontext_t*)_ctx;\n     uintptr_t target = (uintptr_t)fptr;\n@@ -549,9 +671,8 @@ static void jl_try_deliver_sigint(void)\n // Write only by signal handling thread, read only by main thread\n // no sync necessary.\n static int thread0_exit_signo = 0;\n-static void JL_NORETURN jl_exit_thread0_cb(void)\n+static void jl_exit_thread0_cb(void)\n {\n-CFI_NORETURN\n     jl_atomic_fetch_add(&jl_gc_disable_counter, -1);\n     jl_fprint_critical_error(ios_safe_stderr, thread0_exit_signo, 0, NULL, jl_current_task);\n     jl_atexit_hook(128);"
    }
  ]
}