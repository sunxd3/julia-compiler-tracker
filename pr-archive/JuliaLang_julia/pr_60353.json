{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60353",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60353/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60353/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60353/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60353",
  "id": 3716379762,
  "node_id": "PR_kwDOABkWpM64M87S",
  "number": 60353,
  "title": "codegen load/store/union cleanup and fix",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 183231688,
      "node_id": "MDU6TGFiZWwxODMyMzE2ODg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:codegen",
      "name": "compiler:codegen",
      "color": "d4c5f9",
      "default": false,
      "description": "Generation of LLVM IR and native code"
    },
    {
      "id": 4232017300,
      "node_id": "LA_kwDOABkWpM78P3WU",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/don't%20squash",
      "name": "don't squash",
      "color": "ff4500",
      "default": false,
      "description": "Don't squash merge"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 6,
  "created_at": "2025-12-10T18:46:04Z",
  "updated_at": "2025-12-12T08:50:54Z",
  "closed_at": "2025-12-11T12:23:47Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60353",
    "html_url": "https://github.com/JuliaLang/julia/pull/60353",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60353.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60353.patch",
    "merged_at": "2025-12-11T12:23:47Z"
  },
  "body": "Working with Claude to try to de-duplicate and simplify/cleanup some of the code here (esp. union_store) that has grown chaotic over time, and fix bugs.\r\n\r\nFix https://github.com/JuliaLang/julia/issues/60345, Fix #60355 (and other hypothetical similar issues)",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60353/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60353/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "c895ebb791210ebe9aedf66e0eb010b1e96335e0",
      "filename": "Compiler/test/codegen.jl",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3683074bb0c348236bf2bc1c79b5990c6d7ca59b/Compiler%2Ftest%2Fcodegen.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3683074bb0c348236bf2bc1c79b5990c6d7ca59b/Compiler%2Ftest%2Fcodegen.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Fcodegen.jl?ref=3683074bb0c348236bf2bc1c79b5990c6d7ca59b",
      "patch": "@@ -1075,3 +1075,13 @@ let io = IOBuffer()\n     str = String(take!(io))\n     @test occursin(\"julia.write_barrier\", str)\n end\n+\n+# Test phi node codegen for union types with inline roots\n+function union_phi_inline_roots(x::Bool)\n+    if x\n+        return (\"Q8\", 1)\n+    else\n+        return (\"Q10\", Ref(5))\n+    end\n+end\n+@test union_phi_inline_roots(true) === (\"Q8\", 1)"
    },
    {
      "sha": "e7810a8045457c8138325fdd33cde48802b21507",
      "filename": "src/cgutils.cpp",
      "status": "modified",
      "additions": 390,
      "deletions": 384,
      "changes": 774,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3683074bb0c348236bf2bc1c79b5990c6d7ca59b/src%2Fcgutils.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3683074bb0c348236bf2bc1c79b5990c6d7ca59b/src%2Fcgutils.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcgutils.cpp?ref=3683074bb0c348236bf2bc1c79b5990c6d7ca59b",
      "patch": "@@ -26,7 +26,6 @@ STATISTIC(SkippedMemcpys, \"Number of skipped memcpy instructions\");\n STATISTIC(EmittedGetfieldUnknowns, \"Number of unknown getfield calls emitted\");\n STATISTIC(EmittedGetfieldKnowns, \"Number of known getfield calls emitted\");\n STATISTIC(EmittedSetfield, \"Number of setfield calls emitted\");\n-STATISTIC(EmittedUnionLoads, \"Number of union loads emitted\");\n STATISTIC(EmittedVarargsLength, \"Number of varargs length calls emitted\");\n STATISTIC(EmittedArrayptr, \"Number of array ptr calls emitted\");\n STATISTIC(EmittedArrayElsize, \"Number of array elsize calls emitted\");\n@@ -38,6 +37,26 @@ STATISTIC(EmittedWriteBarriers, \"Number of write barriers emitted\");\n STATISTIC(EmittedNewStructs, \"Number of new structs emitted\");\n STATISTIC(EmittedDeferSignal, \"Number of deferred signals emitted\");\n \n+// Enum to represent field operation types, replacing multiple boolean parameters\n+enum class StoreKind {\n+    Set,         // setfield!/setglobal!/memoryrefset!\n+    Swap,        // swapfield!/swapglobal!/memoryrefswap!\n+    Replace,     // replacefield!/replaceglobal!/memoryrefreplace!\n+    Modify,      // modifyfield!/modifyglobal!/memoryrefmodify!\n+    SetOnce      // setfieldonce!/setglobalonce!/memoryrefsetonce!\n+};\n+\n+static const char *store_kind_name(StoreKind op, const char *suffix) {\n+    switch (op) {\n+    case StoreKind::Set:     return suffix[0] == 'g' ? \"setglobal!\" : suffix[0] == 'm' ? \"memoryrefset!\" : \"setfield!\";\n+    case StoreKind::Swap:    return suffix[0] == 'g' ? \"swapglobal!\" : suffix[0] == 'm' ? \"memoryrefswap!\" : \"swapfield!\";\n+    case StoreKind::Replace: return suffix[0] == 'g' ? \"replaceglobal!\" : suffix[0] == 'm' ? \"memoryrefreplace!\" : \"replacefield!\";\n+    case StoreKind::Modify:  return suffix[0] == 'g' ? \"modifyglobal!\" : suffix[0] == 'm' ? \"memoryrefmodify!\" : \"modifyfield!\";\n+    case StoreKind::SetOnce: return suffix[0] == 'g' ? \"setglobalonce!\" : suffix[0] == 'm' ? \"memoryrefsetonce!\" : \"setfieldonce!\";\n+    }\n+    return \"\";\n+}\n+\n static Value *track_pjlvalue(jl_codectx_t &ctx, Value *V)\n {\n     assert(V->getType() == ctx.types().T_pjlvalue);\n@@ -2320,13 +2339,72 @@ static void emit_lockstate_value(jl_codectx_t &ctx, Value *strct, bool newstate)\n     }\n }\n \n+// Helper to create a load with TBAA and alias scope metadata\n+static LoadInst *emit_aliased_load(jl_codectx_t &ctx, Type *elty, Value *ptr, Align alignment,\n+                                   MDNode *tbaa, MDNode *aliasscope, AtomicOrdering Order,\n+                                   bool maybe_mark_dereferenceable = false, bool maybe_null = true,\n+                                   jl_value_t *jltype_for_dereferenceable = nullptr)\n+{\n+    LoadInst *load = ctx.builder.CreateAlignedLoad(elty, ptr, alignment, false);\n+    load->setOrdering(Order);\n+    jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n+    ai.scope = MDNode::concatenate(aliasscope, ai.scope);\n+    ai.decorateInst(load);\n+    if (maybe_mark_dereferenceable && jltype_for_dereferenceable)\n+        maybe_mark_load_dereferenceable(load, maybe_null, jltype_for_dereferenceable);\n+    return load;\n+}\n+\n+// Helper to create a store with TBAA and alias scope metadata\n+static StoreInst *emit_aliased_store(jl_codectx_t &ctx, Value *val, Value *ptr, Align alignment,\n+                                     MDNode *tbaa, MDNode *aliasscope, AtomicOrdering Order)\n+{\n+    StoreInst *store = ctx.builder.CreateAlignedStore(val, ptr, alignment);\n+    store->setOrdering(Order);\n+    jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n+    ai.noalias = MDNode::concatenate(aliasscope, ai.noalias);\n+    ai.decorateInst(store);\n+    return store;\n+}\n+\n+// Load union type tag from ptindex, returns tindex+1 (1-indexed)\n+static Value *emit_load_tindex(jl_codectx_t &ctx, Value *ptindex, unsigned union_max, MDNode *tbaa_ptindex)\n+{\n+    assert(union_max > 0);\n+    jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa_ptindex);\n+    Instruction *tindex0 = ai.decorateInst(ctx.builder.CreateAlignedLoad(getInt8Ty(ctx.builder.getContext()), ptindex, Align(1)));\n+    tindex0->setMetadata(LLVMContext::MD_range, MDNode::get(ctx.builder.getContext(), {\n+        ConstantAsMetadata::get(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0)),\n+        ConstantAsMetadata::get(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), union_max)) }));\n+    return ctx.builder.CreateNUWAdd(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 1), tindex0);\n+}\n+\n // If `nullcheck` is not NULL and a pointer NULL check is necessary\n // store the pointer to be checked in `*nullcheck` instead of checking it\n static jl_cgval_t typed_load(jl_codectx_t &ctx, Value *ptr, Value *idx_0based, jl_value_t *jltype,\n                              MDNode *tbaa, MDNode *aliasscope, bool isboxed, AtomicOrdering Order,\n                              bool maybe_null_if_boxed = true, unsigned alignment = 0,\n-                             Value **nullcheck = nullptr)\n-{\n+                             Value **nullcheck = nullptr,\n+                             Value *ptindex = nullptr, MDNode *tbaa_ptindex = nullptr)\n+{\n+    // Handle union types (when ptindex is provided)\n+    if (ptindex != nullptr) {\n+        assert(jl_is_uniontype(jltype));\n+        size_t fsz = 0, al = 0;\n+        int union_max = jl_islayout_inline(jltype, &fsz, &al);\n+        Value *tindex = emit_load_tindex(ctx, ptindex, union_max, tbaa_ptindex ? tbaa_ptindex : tbaa);\n+        Value *data = ptr;\n+        if (fsz > 0) {\n+            AllocaInst *lv = emit_static_alloca(ctx, fsz, Align(al));\n+            setName(ctx.emission_context, lv, \"immutable_union\");\n+            jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n+            emit_memcpy(ctx, lv, ai, ptr, ai, fsz, Align(al), Align(al));\n+            data = lv;\n+        }\n+        return mark_julia_slot(fsz > 0 ? data : nullptr, jltype, tindex, tbaa);\n+    }\n+\n+    assert(isboxed || jl_is_concrete_type(jltype));\n     Type *elty = isboxed ? ctx.types().T_prjlvalue : julia_type_to_llvm(ctx, jltype);\n     if (type_is_ghost(elty)) {\n         if (isStrongerThanMonotonic(Order))\n@@ -2366,23 +2444,18 @@ static jl_cgval_t typed_load(jl_codectx_t &ctx, Value *ptr, Value *idx_0based, j\n     }\n     Value *instr = nullptr;\n     if (Order == AtomicOrdering::NotAtomic && !isboxed && jl_is_genericmemoryref_type(jltype)) {\n-        //We don't specify the stronger expected memory ordering here because of fears it may interfere with vectorization and other optimizations\n-        //if (Order == AtomicOrdering::NotAtomic)\n-        //    Order = AtomicOrdering::Monotonic;\n-        // load these FCA as individual fields, so LLVM does not need to split them later\n-        // and doesn't go on the stack (which may thwart gc_loaded later)\n+        // We don't specify the stronger expected memory ordering here because of fears\n+        // it may interfere with vectorization and other optimizations.\n+        // Load these FCA as individual fields, so LLVM does not need to split them later\n+        // and doesn't go on the stack (which may thwart gc_loaded later).\n         Value *fld0 = ctx.builder.CreateStructGEP(elty, ptr, 0);\n-        LoadInst *load0 = ctx.builder.CreateAlignedLoad(elty->getStructElementType(0), fld0, Align(alignment), false);\n-        load0->setOrdering(Order);\n-        jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-        ai.scope = MDNode::concatenate(aliasscope, ai.scope);\n-        ai.decorateInst(load0);\n+        LoadInst *load0 = emit_aliased_load(ctx, elty->getStructElementType(0), fld0, Align(alignment),\n+                                            tbaa, aliasscope, Order);\n         Value *fld1 = ctx.builder.CreateStructGEP(elty, ptr, 1);\n-        LoadInst *load1 = ctx.builder.CreateAlignedLoad(elty->getStructElementType(1), fld1, Align(alignment), false);\n+        LoadInst *load1 = emit_aliased_load(ctx, elty->getStructElementType(1), fld1, Align(alignment),\n+                                            tbaa, aliasscope, Order);\n         static_assert(offsetof(jl_genericmemoryref_t, ptr_or_offset) == 0, \"wrong field order\");\n         maybe_mark_load_dereferenceable(load1, true, sizeof(void*)*2, alignof(void*));\n-        load1->setOrdering(Order);\n-        ai.decorateInst(load1);\n         instr = Constant::getNullValue(elty);\n         instr = ctx.builder.CreateInsertValue(instr, load0, 0);\n         instr = ctx.builder.CreateInsertValue(instr, load1, 1);\n@@ -2391,14 +2464,8 @@ static jl_cgval_t typed_load(jl_codectx_t &ctx, Value *ptr, Value *idx_0based, j\n         return jl_cgval_t(instr, jltype, NULL);\n     }\n     else {\n-        LoadInst *load = ctx.builder.CreateAlignedLoad(elty, ptr, Align(alignment), false);\n-        load->setOrdering(Order);\n-        if (isboxed)\n-            maybe_mark_load_dereferenceable(load, true, jltype);\n-        jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-        ai.scope = MDNode::concatenate(aliasscope, ai.scope);\n-        ai.decorateInst(load);\n-        instr = load;\n+        instr = emit_aliased_load(ctx, elty, ptr, Align(alignment), tbaa, aliasscope, Order,\n+                                  isboxed, true, jltype);\n     }\n     if (elty != realelty)\n         instr = ctx.builder.CreateTrunc(instr, realelty);\n@@ -2431,15 +2498,19 @@ static jl_cgval_t typed_load(jl_codectx_t &ctx, Value *ptr, Value *idx_0based, j\n }\n \n static Function *emit_modifyhelper(jl_codectx_t &ctx2, const jl_cgval_t &op, const jl_cgval_t &modifyop, jl_value_t *jltype, Type *elty, jl_cgval_t rhs, const Twine &fname, bool gcstack_arg);\n+static void emit_unionmove(jl_codectx_t &ctx, Value *dest, jl_value_t *desttype,\n+        MDNode *tbaa_dst, const jl_cgval_t &src, Value *tindex, Value *skip, bool isVolatile=false);\n \n static jl_cgval_t typed_store(jl_codectx_t &ctx,\n         Value *ptr, jl_cgval_t rhs, jl_cgval_t cmpop,\n         jl_value_t *jltype, MDNode *tbaa, MDNode *aliasscope,\n         Value *parent,  // for the write barrier, NULL if no barrier needed\n         bool isboxed, AtomicOrdering Order, AtomicOrdering FailOrder, unsigned alignment,\n-        Value *needlock, bool issetfield, bool isreplacefield, bool isswapfield, bool ismodifyfield, bool issetfieldonce,\n+        Value *needlock, StoreKind op,\n         bool maybe_null_if_boxed, const jl_cgval_t *modifyop, const Twine &fname,\n-        jl_module_t *mod, jl_sym_t *var)\n+        jl_module_t *mod, jl_sym_t *var,\n+        // Union type support (set ptindex non-null for union stores)\n+        Value *ptindex = nullptr, MDNode *tbaa_ptindex = nullptr)\n {\n     auto newval = [&](const jl_cgval_t &lhs) { // for ismodifyfield\n         const jl_cgval_t argv[3] = { cmpop, lhs, rhs };\n@@ -2455,77 +2526,112 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n         ret = update_julia_type(ctx, ret, jltype);\n         return ret;\n     };\n-    if (isboxed)\n-        alignment = sizeof(void*);\n-    else if (!alignment)\n-        alignment = julia_alignment(jltype);\n-    Type *elty = isboxed ? ctx.types().T_prjlvalue : julia_type_to_llvm(ctx, jltype);\n-    if (type_is_ghost(elty) ||\n-            (issetfieldonce && !maybe_null_if_boxed) ||\n-            (issetfieldonce && !isboxed && !jl_type_hasptr(jltype))) {\n-        if (isStrongerThanMonotonic(Order))\n-            ctx.builder.CreateFence(Order);\n-        if (issetfield) {\n-            return rhs;\n-        }\n-        else if (isreplacefield) {\n-            Value *Success = emit_f_is(ctx, cmpop, ghostValue(ctx, jltype));\n-            Success = ctx.builder.CreateZExt(Success, getInt8Ty(ctx.builder.getContext()));\n-            const jl_cgval_t argv[2] = {ghostValue(ctx, jltype), mark_julia_type(ctx, Success, false, jl_bool_type)};\n-            jl_datatype_t *rettyp = jl_apply_cmpswap_type(jltype);\n-            return emit_new_struct(ctx, (jl_value_t*)rettyp, 2, argv);\n-        }\n-        else if (isswapfield) {\n-            return ghostValue(ctx, jltype);\n-        }\n-        else if (ismodifyfield) {\n-            jl_cgval_t oldval = ghostValue(ctx, jltype);\n-            const jl_cgval_t argv[2] = { oldval, newval(oldval) };\n-            jl_datatype_t *rettyp = jl_apply_modify_type(jltype);\n-            return emit_new_struct(ctx, (jl_value_t*)rettyp, 2, argv);\n-        }\n-        else { // issetfieldonce\n+\n+    // Union type setup\n+    bool is_union = ptindex != nullptr;\n+    MDNode *tbaa_tindex = is_union ? (tbaa_ptindex ? tbaa_ptindex : tbaa) : nullptr;\n+    jl_cgval_t rhs_union = rhs;\n+    if (is_union) {\n+        assert(!isboxed && Order == AtomicOrdering::NotAtomic);\n+        // Union SetOnce always returns false (no undefined element in these unions)\n+        if (op == StoreKind::SetOnce)\n             return mark_julia_const(ctx, jl_false);\n+        if (op != StoreKind::Modify) {\n+            rhs_union = convert_julia_type_to_union(ctx, rhs_union, jltype, false);\n+            if (rhs_union.typ == jl_bottom_type)\n+                return jl_cgval_t();\n         }\n     }\n-    // if FailOrder was inherited from Order, may need to remove Load-only effects now\n-    if (FailOrder == AtomicOrdering::AcquireRelease)\n-        FailOrder = AtomicOrdering::Acquire;\n-    if (FailOrder == AtomicOrdering::Release)\n-        FailOrder = AtomicOrdering::Monotonic;\n-    unsigned nb = isboxed ? sizeof(void*) : jl_datatype_size(jltype);\n-    AllocaInst *intcast = nullptr;\n+    auto store_union = [&](const jl_cgval_t &val, const jl_cgval_t &val_union) {\n+        Value *tindex = ctx.builder.CreateAnd(val_union.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER));\n+        Value *stindex = ctx.builder.CreateNUWSub(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 1));\n+        jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa_tindex);\n+        ai.decorateInst(ctx.builder.CreateAlignedStore(stindex, ptindex, Align(1)));\n+        if (!val.isghost)\n+            emit_unionmove(ctx, ptr, jltype, tbaa, val, tindex, /*skip*/nullptr);\n+    };\n+    auto load_union = [&]() {\n+        return typed_load(ctx, ptr, NULL, jltype, tbaa, nullptr, false,\n+                AtomicOrdering::NotAtomic, false, 0, nullptr, ptindex, tbaa_tindex);\n+    };\n+\n+    // Non-union setup\n+    Type *elty = nullptr;\n+    Type *realelty = nullptr;\n     Type *intcast_eltyp = nullptr;\n-    bool tracked_pointers = isboxed || CountTrackedPointers(elty).count > 0;\n-    if (!isboxed && Order != AtomicOrdering::NotAtomic && !elty->isIntOrPtrTy()) {\n-        intcast_eltyp = elty;\n-        elty = Type::getIntNTy(ctx.builder.getContext(), 8 * nb);\n-        if (!issetfield) {\n-            intcast = emit_static_alloca(ctx, elty, Align(alignment));\n-            setName(ctx.emission_context, intcast, \"atomic_store_box\");\n-        }\n-    }\n-    Type *realelty = elty;\n-    if (Order != AtomicOrdering::NotAtomic && isa<IntegerType>(elty)) {\n-        unsigned nb2 = PowerOf2Ceil(nb);\n-        if (nb != nb2)\n-            elty = Type::getIntNTy(ctx.builder.getContext(), 8 * nb2);\n-    }\n+    AllocaInst *intcast = nullptr;\n+    unsigned nb = 0;\n+    bool tracked_pointers = false;\n     Value *r = nullptr;\n-    if (issetfield || isswapfield || isreplacefield || issetfieldonce)  { // e.g. !ismodifyfield\n-        assert(isboxed || rhs.typ == jltype);\n-        if (isboxed) {\n-            r = boxed(ctx, rhs);\n+    if (!is_union) {\n+        if (isboxed)\n+            alignment = sizeof(void*);\n+        else if (!alignment)\n+            alignment = julia_alignment(jltype);\n+        elty = isboxed ? ctx.types().T_prjlvalue : julia_type_to_llvm(ctx, jltype);\n+        if (type_is_ghost(elty) ||\n+                (op == StoreKind::SetOnce && !maybe_null_if_boxed) ||\n+                (op == StoreKind::SetOnce && !isboxed && !jl_type_hasptr(jltype))) {\n+            if (isStrongerThanMonotonic(Order))\n+                ctx.builder.CreateFence(Order);\n+            switch (op) {\n+            case StoreKind::Set:\n+                return rhs;\n+            case StoreKind::Replace: {\n+                Value *Success = emit_f_is(ctx, cmpop, ghostValue(ctx, jltype));\n+                Success = ctx.builder.CreateZExt(Success, getInt8Ty(ctx.builder.getContext()));\n+                const jl_cgval_t argv[2] = {ghostValue(ctx, jltype), mark_julia_type(ctx, Success, false, jl_bool_type)};\n+                jl_datatype_t *rettyp = jl_apply_cmpswap_type(jltype);\n+                return emit_new_struct(ctx, (jl_value_t*)rettyp, 2, argv);\n+            }\n+            case StoreKind::Swap:\n+                return ghostValue(ctx, jltype);\n+            case StoreKind::Modify: {\n+                jl_cgval_t oldval = ghostValue(ctx, jltype);\n+                const jl_cgval_t argv[2] = { oldval, newval(oldval) };\n+                jl_datatype_t *rettyp = jl_apply_modify_type(jltype);\n+                return emit_new_struct(ctx, (jl_value_t*)rettyp, 2, argv);\n+            }\n+            case StoreKind::SetOnce:\n+                return mark_julia_const(ctx, jl_false);\n+            }\n+        }\n+        // if FailOrder was inherited from Order, may need to remove Load-only effects now\n+        if (FailOrder == AtomicOrdering::AcquireRelease)\n+            FailOrder = AtomicOrdering::Acquire;\n+        if (FailOrder == AtomicOrdering::Release)\n+            FailOrder = AtomicOrdering::Monotonic;\n+        nb = isboxed ? sizeof(void*) : jl_datatype_size(jltype);\n+        tracked_pointers = isboxed || CountTrackedPointers(elty).count > 0;\n+        if (!isboxed && Order != AtomicOrdering::NotAtomic && !elty->isIntOrPtrTy()) {\n+            intcast_eltyp = elty;\n+            elty = Type::getIntNTy(ctx.builder.getContext(), 8 * nb);\n+            if (op != StoreKind::Set) {\n+                intcast = emit_static_alloca(ctx, elty, Align(alignment));\n+                setName(ctx.emission_context, intcast, \"atomic_store_box\");\n+            }\n         }\n-        else if (intcast) {\n-            emit_unbox_store(ctx, rhs, intcast, ctx.tbaa().tbaa_stack, MaybeAlign(), intcast->getAlign());\n-            r = ctx.builder.CreateLoad(realelty, intcast);\n+        realelty = elty;\n+        if (Order != AtomicOrdering::NotAtomic && isa<IntegerType>(elty)) {\n+            unsigned nb2 = PowerOf2Ceil(nb);\n+            if (nb != nb2)\n+                elty = Type::getIntNTy(ctx.builder.getContext(), 8 * nb2);\n         }\n-        else if (aliasscope || Order != AtomicOrdering::NotAtomic || (tracked_pointers && rhs.inline_roots.empty())) {\n-            r = emit_unbox(ctx, realelty, rhs);\n+        if (op != StoreKind::Modify) {\n+            assert(isboxed || rhs.typ == jltype);\n+            if (isboxed) {\n+                r = boxed(ctx, rhs);\n+            }\n+            else if (intcast) {\n+                emit_unbox_store(ctx, rhs, intcast, ctx.tbaa().tbaa_stack, MaybeAlign(), intcast->getAlign());\n+                r = ctx.builder.CreateLoad(realelty, intcast);\n+            }\n+            else if (aliasscope || Order != AtomicOrdering::NotAtomic || (tracked_pointers && rhs.inline_roots.empty())) {\n+                r = emit_unbox(ctx, realelty, rhs);\n+            }\n+            if (realelty != elty)\n+                r = ctx.builder.CreateZExt(r, elty);\n         }\n-        if (realelty != elty)\n-            r = ctx.builder.CreateZExt(r, elty);\n     }\n     Value *instr = nullptr;\n     Value *Compare = nullptr;\n@@ -2535,46 +2641,30 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n         emit_lockstate_value(ctx, needlock, true);\n     jl_cgval_t oldval = rhs;\n     // TODO: we should do Release ordering for anything with CountTrackedPointers(elty).count > 0, instead of just isboxed\n-    if (issetfield || (Order == AtomicOrdering::NotAtomic && isswapfield)) {\n-        if (isswapfield) {\n-            auto *load = ctx.builder.CreateAlignedLoad(elty, ptr, Align(alignment));\n-            setName(ctx.emission_context, load, \"swap_load\");\n-            if (isboxed)\n-                load->setOrdering(AtomicOrdering::Unordered);\n-            jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-            ai.noalias = MDNode::concatenate(aliasscope, ai.noalias);\n-            ai.decorateInst(load);\n-            assert(realelty == elty);\n-            instr = load;\n-        }\n-        if (r) {\n-            jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-            ai.noalias = MDNode::concatenate(aliasscope, ai.noalias);\n-            if (false && !isboxed && Order == AtomicOrdering::NotAtomic && jl_is_genericmemoryref_type(jltype)) {\n-                // if enabled, store these FCA as individual fields, so LLVM does not need to split them later and they can use release ordering\n-                assert(r->getType() == ctx.types().T_jlgenericmemory);\n-                Value *f1 = ctx.builder.CreateExtractValue(r, 0);\n-                Value *f2 = ctx.builder.CreateExtractValue(r, 1);\n-                static_assert(offsetof(jl_genericmemoryref_t, ptr_or_offset) == 0, \"wrong field order\");\n-                StoreInst *store = ctx.builder.CreateAlignedStore(f1, ctx.builder.CreateStructGEP(ctx.types().T_jlgenericmemory, ptr, 0), Align(alignment));\n-                store->setOrdering(AtomicOrdering::Release);\n-                ai.decorateInst(store);\n-                store = ctx.builder.CreateAlignedStore(f2, ctx.builder.CreateStructGEP(ctx.types().T_jlgenericmemory, ptr, 1), Align(alignment));\n-                store->setOrdering(AtomicOrdering::Release);\n-                ai.decorateInst(store);\n+    if (op == StoreKind::Set || (Order == AtomicOrdering::NotAtomic && op == StoreKind::Swap)) {\n+        if (op == StoreKind::Swap) {\n+            if (is_union) {\n+                oldval = load_union();\n             }\n             else {\n-                StoreInst *store = ctx.builder.CreateAlignedStore(r, ptr, Align(alignment));\n-                store->setOrdering(Order == AtomicOrdering::NotAtomic && isboxed ? AtomicOrdering::Release : Order);\n-                ai.decorateInst(store);\n+                instr = emit_aliased_load(ctx, elty, ptr, Align(alignment), tbaa, aliasscope, isboxed ? AtomicOrdering::Unordered : AtomicOrdering::NotAtomic);\n+                setName(ctx.emission_context, instr, \"swap_load\");\n             }\n         }\n+        if (is_union) {\n+            store_union(rhs, rhs_union);\n+        }\n+        else if (r) {\n+            AtomicOrdering storeOrder = Order == AtomicOrdering::NotAtomic && isboxed ? AtomicOrdering::Release : Order;\n+            emit_aliased_store(ctx, r, ptr, Align(alignment), tbaa, aliasscope, storeOrder);\n+        }\n         else {\n             assert(Order == AtomicOrdering::NotAtomic && !isboxed && rhs.typ == jltype);\n             emit_unbox_store(ctx, rhs, ptr, tbaa, MaybeAlign(), Align(alignment));\n         }\n     }\n-    else if (isswapfield) {\n+    else if (op == StoreKind::Swap) {\n+        assert(!is_union); // union swap handled above in NotAtomic branch\n         if (Order == AtomicOrdering::Unordered)\n             Order = AtomicOrdering::Monotonic;\n         assert(Order != AtomicOrdering::NotAtomic && r);\n@@ -2585,7 +2675,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n         ai.decorateInst(store);\n         instr = store;\n     }\n-    else if (ismodifyfield && modifyop && !needlock && Order != AtomicOrdering::NotAtomic && !isboxed && realelty == elty && !intcast && elty->isIntegerTy() && !jl_type_hasptr(jltype)) {\n+    else if (op == StoreKind::Modify && modifyop && !needlock && Order != AtomicOrdering::NotAtomic && !isboxed && realelty == elty && !intcast && elty->isIntegerTy() && !jl_type_hasptr(jltype)) {\n         // emit this only if we have a possibility of optimizing it\n         if (Order == AtomicOrdering::Unordered)\n             Order = AtomicOrdering::Monotonic;\n@@ -2626,11 +2716,15 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n         rhs = mark_julia_type(ctx, ctx.builder.CreateExtractValue(oldnew, 1), isboxed, jltype);\n     }\n     else {\n-        // replacefield, modifyfield, swapfield, setfieldonce (isboxed && atomic)\n+        // replacefield, modifyfield, swapfield, setfieldonce\n+        assert(!is_union || (op == StoreKind::Replace || op == StoreKind::Modify));\n         DoneBB = BasicBlock::Create(ctx.builder.getContext(), \"done_xchg\", ctx.f);\n         bool needloop;\n         PHINode *Succ = nullptr, *Current = nullptr;\n-        if (isreplacefield) {\n+        if (is_union) {\n+            needloop = op == StoreKind::Modify;\n+        }\n+        else if (op == StoreKind::Replace) {\n             if (Order == AtomicOrdering::NotAtomic) {\n                 needloop = false;\n             }\n@@ -2644,12 +2738,9 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n                     BasicBlock *BB = BasicBlock::Create(ctx.builder.getContext(), \"ok_xchg\", ctx.f);\n                     ctx.builder.CreateCondBr(SameType, BB, SkipBB);\n                     ctx.builder.SetInsertPoint(SkipBB);\n-                    LoadInst *load = ctx.builder.CreateAlignedLoad(elty, ptr, Align(alignment));\n-                    setName(ctx.emission_context, load, \"atomic_replace_initial\");\n-                    load->setOrdering(FailOrder == AtomicOrdering::NotAtomic && isboxed ? AtomicOrdering::Monotonic : FailOrder);\n-                    jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-                    ai.noalias = MDNode::concatenate(aliasscope, ai.noalias);\n-                    instr = ai.decorateInst(load);\n+                    AtomicOrdering loadOrder = FailOrder == AtomicOrdering::NotAtomic && isboxed ? AtomicOrdering::Monotonic : FailOrder;\n+                    instr = emit_aliased_load(ctx, elty, ptr, Align(alignment), tbaa, aliasscope, loadOrder);\n+                    setName(ctx.emission_context, instr, \"atomic_replace_initial\");\n                     ctx.builder.CreateBr(DoneBB);\n                     ctx.builder.SetInsertPoint(DoneBB);\n                     Succ = ctx.builder.CreatePHI(getInt1Ty(ctx.builder.getContext()), 2);\n@@ -2680,19 +2771,17 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n                 needloop = true;\n             }\n         }\n-        else if (issetfieldonce) {\n+        else if (op == StoreKind::SetOnce) {\n             needloop = !isboxed && Order != AtomicOrdering::NotAtomic && nb > sizeof(void*);\n             if (Order != AtomicOrdering::NotAtomic)\n                 Compare = Constant::getNullValue(elty);\n         }\n         else { // swap or modify\n-            LoadInst *Current = ctx.builder.CreateAlignedLoad(elty, ptr, Align(alignment));\n-            Current->setOrdering(Order == AtomicOrdering::NotAtomic && !isboxed ? Order : AtomicOrdering::Monotonic);\n+            AtomicOrdering loadOrder = Order == AtomicOrdering::NotAtomic && !isboxed ? Order : AtomicOrdering::Monotonic;\n+            LoadInst *Current = emit_aliased_load(ctx, elty, ptr, Align(alignment), tbaa, aliasscope, loadOrder);\n             setName(ctx.emission_context, Current, \"atomic_initial\");\n-            jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-            ai.noalias = MDNode::concatenate(aliasscope, ai.noalias);\n-            Compare = ai.decorateInst(Current);\n-            needloop = !isswapfield || Order != AtomicOrdering::NotAtomic;\n+            Compare = Current;\n+            needloop = op != StoreKind::Swap || Order != AtomicOrdering::NotAtomic;\n         }\n         BasicBlock *BB = NULL;\n         PHINode *CmpPhi = NULL;\n@@ -2701,95 +2790,123 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n             BB = BasicBlock::Create(ctx.builder.getContext(), \"xchg\", ctx.f);\n             ctx.builder.CreateBr(BB);\n             ctx.builder.SetInsertPoint(BB);\n-            CmpPhi = ctx.builder.CreatePHI(elty, 2);\n-            CmpPhi->addIncoming(Compare, From);\n-            Compare = CmpPhi;\n+            if (!is_union) {\n+                // Non-union uses CmpPhi to track the compare value across loop iterations\n+                CmpPhi = ctx.builder.CreatePHI(elty, 2);\n+                CmpPhi->addIncoming(Compare, From);\n+                Compare = CmpPhi;\n+            }\n         }\n-        if (ismodifyfield) {\n-            if (needlock)\n-                emit_lockstate_value(ctx, needlock, false); // unlock\n-            Value *realCompare = Compare;\n-            if (realelty != elty)\n-                realCompare = ctx.builder.CreateTrunc(realCompare, realelty);\n-            if (intcast) {\n-                assert(!isboxed);\n-                ctx.builder.CreateStore(realCompare, intcast);\n-                if (tracked_pointers)\n-                    realCompare = ctx.builder.CreateLoad(intcast_eltyp, intcast);\n+        if (op == StoreKind::Modify) {\n+            // Load old value for Modify\n+            if (is_union) {\n+                oldval = load_union();\n+                if (needlock)\n+                    emit_lockstate_value(ctx, needlock, false); // unlock\n             }\n-            if (maybe_null_if_boxed && tracked_pointers) {\n-                Value *first_ptr = isboxed ? realCompare : extract_first_ptr(ctx, realCompare);\n-                assert(first_ptr);\n-                null_load_check(ctx, first_ptr, mod, var);\n+            else {\n+                Value *realCompare = Compare;\n+                if (realelty != elty)\n+                    realCompare = ctx.builder.CreateTrunc(realCompare, realelty);\n+                if (intcast) {\n+                    assert(!isboxed);\n+                    ctx.builder.CreateStore(realCompare, intcast);\n+                    if (tracked_pointers)\n+                        realCompare = ctx.builder.CreateLoad(intcast_eltyp, intcast);\n+                }\n+                if (needlock)\n+                    emit_lockstate_value(ctx, needlock, false); // unlock\n+                if (maybe_null_if_boxed && tracked_pointers) {\n+                    Value *first_ptr = isboxed ? realCompare : extract_first_ptr(ctx, realCompare);\n+                    assert(first_ptr);\n+                    null_load_check(ctx, first_ptr, mod, var);\n+                }\n+                if (intcast && !tracked_pointers)\n+                    oldval = mark_julia_slot(intcast, jltype, NULL, ctx.tbaa().tbaa_stack);\n+                else\n+                    oldval = mark_julia_type(ctx, realCompare, isboxed, jltype);\n             }\n-            if (intcast && !tracked_pointers)\n-                oldval = mark_julia_slot(intcast, jltype, NULL, ctx.tbaa().tbaa_stack);\n-            else\n-                oldval = mark_julia_type(ctx, realCompare, isboxed, jltype);\n+            // Compute new value\n             rhs = newval(oldval);\n-            if (isboxed) {\n-                r = boxed(ctx, rhs);\n-            }\n-            else if (intcast) {\n-                emit_unbox_store(ctx, rhs, intcast, ctx.tbaa().tbaa_stack, MaybeAlign(), intcast->getAlign());\n-                r = ctx.builder.CreateLoad(realelty, intcast);\n-                if (!tracked_pointers) // oldval is a slot, so put the oldval back\n-                    ctx.builder.CreateStore(realCompare, intcast);\n+            // Convert rhs to storable form\n+            if (is_union) {\n+                rhs_union = convert_julia_type_to_union(ctx, rhs, jltype, false);\n+                if (rhs_union.typ == jl_bottom_type)\n+                    return jl_cgval_t();\n             }\n-            else if (Order != AtomicOrdering::NotAtomic || (tracked_pointers && rhs.inline_roots.empty())) {\n-                r = emit_unbox(ctx, realelty, rhs);\n+            else {\n+                if (isboxed) {\n+                    r = boxed(ctx, rhs);\n+                }\n+                else if (intcast) {\n+                    Value *realCompare = Compare;\n+                    if (realelty != elty)\n+                        realCompare = ctx.builder.CreateTrunc(realCompare, realelty);\n+                    emit_unbox_store(ctx, rhs, intcast, ctx.tbaa().tbaa_stack, MaybeAlign(), intcast->getAlign());\n+                    r = ctx.builder.CreateLoad(realelty, intcast);\n+                    if (!tracked_pointers) // oldval is a slot, so put the oldval back\n+                        ctx.builder.CreateStore(realCompare, intcast);\n+                }\n+                else if (Order != AtomicOrdering::NotAtomic || (tracked_pointers && rhs.inline_roots.empty())) {\n+                    r = emit_unbox(ctx, realelty, rhs);\n+                }\n+                if (realelty != elty)\n+                    r = ctx.builder.CreateZExt(r, elty);\n             }\n-            if (realelty != elty)\n-                r = ctx.builder.CreateZExt(r, elty);\n             if (needlock)\n                 emit_lockstate_value(ctx, needlock, true); // relock\n             cmpop = oldval;\n         }\n         Value *Done;\n         if (Order == AtomicOrdering::NotAtomic) {\n-            // modifyfield or replacefield or setfieldonce\n-            assert(elty == realelty && !intcast);\n-            auto *load = ctx.builder.CreateAlignedLoad(elty, ptr, Align(alignment));\n-            jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-            ai.noalias = MDNode::concatenate(aliasscope, ai.noalias);\n-            ai.decorateInst(load);\n-            if (isboxed)\n-                load->setOrdering(AtomicOrdering::Monotonic);\n+            // Union Replace/Modify or non-atomic Replace/Modify/SetOnce\n+            // Load current value\n+            if (is_union) {\n+                oldval = load_union();\n+            }\n+            else {\n+                assert(elty == realelty && !intcast);\n+                AtomicOrdering loadOrder = isboxed ? AtomicOrdering::Monotonic : AtomicOrdering::NotAtomic;\n+                auto *load = emit_aliased_load(ctx, elty, ptr, Align(alignment), tbaa, aliasscope, loadOrder);\n+                instr = load;\n+                oldval = mark_julia_type(ctx, load, isboxed, jltype);\n+            }\n+            // Compare\n             Value *first_ptr = nullptr;\n-            if (maybe_null_if_boxed && !ismodifyfield)\n-                first_ptr = isboxed ? load : extract_first_ptr(ctx, load);\n-            oldval = mark_julia_type(ctx, load, isboxed, jltype);\n-            assert(!issetfieldonce || first_ptr != nullptr);\n-            if (issetfieldonce)\n+            if (!is_union && maybe_null_if_boxed && op != StoreKind::Modify)\n+                first_ptr = isboxed ? instr : extract_first_ptr(ctx, instr);\n+            assert(is_union || op != StoreKind::SetOnce || first_ptr != nullptr);\n+            if (op == StoreKind::SetOnce)\n                 Success = ctx.builder.CreateIsNull(first_ptr);\n             else\n                 Success = emit_f_is(ctx, oldval, cmpop, first_ptr, nullptr);\n-            if (needloop && ismodifyfield)\n-                CmpPhi->addIncoming(load, ctx.builder.GetInsertBlock());\n+            if (!is_union && needloop && op == StoreKind::Modify)\n+                CmpPhi->addIncoming(instr, ctx.builder.GetInsertBlock());\n             assert(Succ == nullptr);\n+            // Branch to XchgBB or loop/DoneBB\n             BasicBlock *XchgBB = BasicBlock::Create(ctx.builder.getContext(), \"xchg\", ctx.f);\n-            ctx.builder.CreateCondBr(Success, XchgBB, needloop && ismodifyfield ? BB : DoneBB);\n+            ctx.builder.CreateCondBr(Success, XchgBB, needloop && op == StoreKind::Modify ? BB : DoneBB);\n             ctx.builder.SetInsertPoint(XchgBB);\n-            if (r) {\n-                auto *store = ctx.builder.CreateAlignedStore(r, ptr, Align(alignment));\n-                jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-                ai.noalias = MDNode::concatenate(aliasscope, ai.noalias);\n-                ai.decorateInst(store);\n+            // Store new value\n+            if (is_union) {\n+                store_union(rhs, rhs_union);\n+            }\n+            else if (r) {\n+                emit_aliased_store(ctx, r, ptr, Align(alignment), tbaa, aliasscope, AtomicOrdering::NotAtomic);\n             }\n             else {\n                 assert(!isboxed && rhs.typ == jltype);\n                 emit_unbox_store(ctx, rhs, ptr, tbaa, MaybeAlign(), Align(alignment));\n             }\n             ctx.builder.CreateBr(DoneBB);\n-            instr = load;\n         }\n         else { // something atomic\n-            assert(r);\n+            assert(!is_union && r); // union requires NotAtomic\n             if (Order == AtomicOrdering::Unordered)\n                 Order = AtomicOrdering::Monotonic;\n             if (Order == AtomicOrdering::Monotonic && isboxed)\n                 Order = AtomicOrdering::Release;\n-            if (!isreplacefield && !issetfieldonce)\n+            if (op != StoreKind::Replace && op != StoreKind::SetOnce)\n                 FailOrder = AtomicOrdering::Monotonic;\n             else if (FailOrder == AtomicOrdering::Unordered)\n                 FailOrder = AtomicOrdering::Monotonic;\n@@ -2800,7 +2917,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n             instr = ctx.builder.Insert(ExtractValueInst::Create(store, 0));\n             Success = ctx.builder.Insert(ExtractValueInst::Create(store, 1));\n             Done = Success;\n-            if ((isreplacefield || issetfieldonce) && needloop) {\n+            if ((op == StoreKind::Replace || op == StoreKind::SetOnce) && needloop) {\n                 Value *realinstr = instr;\n                 if (realelty != elty)\n                     realinstr = ctx.builder.CreateTrunc(realinstr, realelty);\n@@ -2814,7 +2931,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n                 else {\n                     oldval = mark_julia_type(ctx, realinstr, isboxed, jltype);\n                 }\n-                if (issetfieldonce) {\n+                if (op == StoreKind::SetOnce) {\n                     assert(!isboxed && maybe_null_if_boxed);\n                     Value *first_ptr = extract_first_ptr(ctx, realinstr);\n                     assert(first_ptr != nullptr);\n@@ -2852,7 +2969,7 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n     if (needlock)\n         emit_lockstate_value(ctx, needlock, false);\n     if (parent != NULL && tracked_pointers && (!isboxed || !type_is_permalloc(rhs.typ))) {\n-        if (isreplacefield || issetfieldonce) {\n+        if (op == StoreKind::Replace || op == StoreKind::SetOnce) {\n             BasicBlock *BB = BasicBlock::Create(ctx.builder.getContext(), \"xchg_wb\", ctx.f);\n             DoneBB = BasicBlock::Create(ctx.builder.getContext(), \"done_xchg_wb\", ctx.f);\n             ctx.builder.CreateCondBr(Success, BB, DoneBB);\n@@ -2866,8 +2983,8 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n                 r = ctx.builder.CreateLoad(intcast_eltyp, intcast);\n             }\n             else if (!isboxed && intcast_eltyp) {\n-                assert(issetfield);\n-                // issetfield doesn't use intcast, so need to reload rhs with the correct type\n+                assert(op == StoreKind::Set);\n+                // setfield doesn't use intcast, so need to reload rhs with the correct type\n                 r = emit_unbox(ctx, intcast_eltyp, rhs);\n             }\n             if (!isboxed)\n@@ -2880,42 +2997,52 @@ static jl_cgval_t typed_store(jl_codectx_t &ctx,\n             assert(!rhs.inline_roots.empty());\n             emit_write_multibarrier(ctx, parent, rhs);\n         }\n-        if (isreplacefield || issetfieldonce) {\n+        if (op == StoreKind::Replace || op == StoreKind::SetOnce) {\n             ctx.builder.CreateBr(DoneBB);\n             ctx.builder.SetInsertPoint(DoneBB);\n         }\n     }\n-    if (ismodifyfield) {\n+    switch (op) {\n+    case StoreKind::Modify: {\n         const jl_cgval_t argv[2] = { oldval, rhs };\n         jl_datatype_t *rettyp = jl_apply_modify_type(jltype);\n         oldval = emit_new_struct(ctx, (jl_value_t*)rettyp, 2, argv);\n+        break;\n     }\n-    else if (issetfieldonce) {\n+    case StoreKind::SetOnce:\n         oldval = mark_julia_type(ctx, Success, false, jl_bool_type);\n-    }\n-    else if (!issetfield) { // swapfield or replacefield\n-        if (realelty != elty)\n-            instr = ctx.builder.Insert(CastInst::Create(Instruction::Trunc, instr, realelty));\n-        if (intcast) {\n-            ctx.builder.CreateStore(instr, intcast);\n-            if (tracked_pointers)\n-                instr = ctx.builder.CreateLoad(intcast_eltyp, intcast);\n-        }\n-        if (maybe_null_if_boxed && tracked_pointers) {\n-            Value *first_ptr = isboxed ? instr : extract_first_ptr(ctx, instr);\n-            assert(first_ptr);\n-            null_load_check(ctx, first_ptr, mod, var);\n+        break;\n+    case StoreKind::Set:\n+        break; // oldval already set\n+    case StoreKind::Swap:\n+    case StoreKind::Replace:\n+        if (!is_union) {\n+            // For non-union, convert instr (raw Value*) to oldval (jl_cgval_t)\n+            if (realelty != elty)\n+                instr = ctx.builder.Insert(CastInst::Create(Instruction::Trunc, instr, realelty));\n+            if (intcast) {\n+                ctx.builder.CreateStore(instr, intcast);\n+                if (tracked_pointers)\n+                    instr = ctx.builder.CreateLoad(intcast_eltyp, intcast);\n+            }\n+            if (maybe_null_if_boxed && tracked_pointers) {\n+                Value *first_ptr = isboxed ? instr : extract_first_ptr(ctx, instr);\n+                assert(first_ptr);\n+                null_load_check(ctx, first_ptr, mod, var);\n+            }\n+            if (intcast && !tracked_pointers)\n+                oldval = mark_julia_slot(intcast, jltype, NULL, ctx.tbaa().tbaa_stack);\n+            else\n+                oldval = mark_julia_type(ctx, instr, isboxed, jltype);\n         }\n-        if (intcast && !tracked_pointers)\n-            oldval = mark_julia_slot(intcast, jltype, NULL, ctx.tbaa().tbaa_stack);\n-        else\n-            oldval = mark_julia_type(ctx, instr, isboxed, jltype);\n-        if (isreplacefield) {\n+        // For union, oldval is already set from load_union()\n+        if (op == StoreKind::Replace) {\n             Success = ctx.builder.CreateZExt(Success, getInt8Ty(ctx.builder.getContext()));\n             const jl_cgval_t argv[2] = {oldval, mark_julia_type(ctx, Success, false, jl_bool_type)};\n             jl_datatype_t *rettyp = jl_apply_cmpswap_type(jltype);\n             oldval = emit_new_struct(ctx, (jl_value_t*)rettyp, 2, argv);\n         }\n+        break;\n     }\n     return oldval;\n }\n@@ -3114,28 +3241,6 @@ static bool emit_getfield_unknownidx(jl_codectx_t &ctx,\n     return false;\n }\n \n-static jl_cgval_t emit_unionload(jl_codectx_t &ctx, Value *addr, Value *ptindex,\n-        jl_value_t *jfty, size_t fsz, size_t al, MDNode *tbaa, bool mutabl,\n-        unsigned union_max, MDNode *tbaa_ptindex)\n-{\n-    ++EmittedUnionLoads;\n-    jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa_ptindex);\n-    Instruction *tindex0 = ai.decorateInst(ctx.builder.CreateAlignedLoad(getInt8Ty(ctx.builder.getContext()), ptindex, Align(1)));\n-    tindex0->setMetadata(LLVMContext::MD_range, MDNode::get(ctx.builder.getContext(), {\n-        ConstantAsMetadata::get(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0)),\n-        ConstantAsMetadata::get(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), union_max)) }));\n-    Value *tindex = ctx.builder.CreateNUWAdd(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 1), tindex0);\n-    if (fsz > 0 && mutabl) {\n-        // move value to an immutable stack slot (excluding tindex)\n-        AllocaInst *lv = emit_static_alloca(ctx, fsz, Align(al));\n-        setName(ctx.emission_context, lv, \"immutable_union\");\n-        jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);\n-        emit_memcpy(ctx, lv, ai, addr, ai, fsz, Align(al), Align(al));\n-        addr = lv;\n-    }\n-    return mark_julia_slot(fsz > 0 ? addr : nullptr, jfty, tindex, tbaa);\n-}\n-\n static bool isTBAA(MDNode *TBAA, std::initializer_list<const char*> const strset)\n {\n     if (!TBAA)\n@@ -3315,12 +3420,12 @@ static jl_cgval_t emit_getfield_knownidx(jl_codectx_t &ctx, const jl_cgval_t &st\n             size_t fsz = 0, al = 0;\n             int union_max = jl_islayout_inline(jfty, &fsz, &al);\n             size_t fsz1 = jl_field_size(jt, idx) - 1;\n-            bool isptr = (union_max == 0);\n-            assert(!isptr && fsz < jl_field_size(jt, idx)); (void)isptr;\n             Value *ptindex = emit_ptrgep(ctx, addr, fsz1);\n-            return emit_unionload(ctx, addr, ptindex, jfty, fsz, al, tbaa, false, union_max, strct.tbaa);\n+            Value *tindex = emit_load_tindex(ctx, ptindex, union_max, strct.tbaa);\n+            // inline_roots unions are always const - just compute the pointer\n+            return mark_julia_slot(fsz > 0 ? addr : nullptr, jfty, tindex, tbaa);\n         }\n-        else if (jfty == (jl_value_t*)jl_bool_type) {\n+        if (jfty == (jl_value_t*)jl_bool_type) {\n             unsigned align = jl_field_align(jt, idx);\n             return typed_load(ctx, addr, NULL, jfty, tbaa, nullptr, false,\n                     AtomicOrdering::NotAtomic, maybe_null, align, nullcheck);\n@@ -3346,34 +3451,26 @@ static jl_cgval_t emit_getfield_knownidx(jl_codectx_t &ctx, const jl_cgval_t &st\n                 null_pointer_check(ctx, fldv, nullcheck);\n             return mark_julia_type(ctx, fldv, true, jfty);\n         }\n-        else if (jl_is_uniontype(jfty)) {\n+        Value *ptindex = nullptr;\n+        int union_max = 0;\n+        if (jl_is_uniontype(jfty)) {\n+            ptindex = emit_ptrgep(ctx, staddr, byte_offset + jl_field_size(jt, idx) - 1);\n             size_t fsz = 0, al = 0;\n-            int union_max = jl_islayout_inline(jfty, &fsz, &al);\n-            bool isptr = (union_max == 0);\n-            assert(!isptr && fsz < jl_field_size(jt, idx)); (void)isptr;\n-            size_t fsz1 = jl_field_size(jt, idx) - 1;\n-            Value *ptindex = emit_ptrgep(ctx, staddr, byte_offset + fsz1);\n-            auto val = emit_unionload(ctx, addr, ptindex, jfty, fsz, al, tbaa, !jl_field_isconst(jt, idx), union_max, strct.tbaa);\n-            if (val.V && val.V != addr) {\n-                setNameWithField(ctx.emission_context, val.V, get_objname, jt, idx, Twine());\n-            }\n-            return val;\n+            union_max = jl_islayout_inline(jfty, &fsz, &al);\n         }\n-        assert(jl_is_concrete_type(jfty));\n-        if (jl_field_isconst(jt, idx) && !(maybe_null && (jfty == (jl_value_t*)jl_bool_type ||\n-                                            ((jl_datatype_t*)jfty)->layout->npointers))) {\n+        if (jl_field_isconst(jt, idx) && jfty != (jl_value_t*)jl_bool_type && !maybe_null) {\n             // just compute the pointer and let user load it when necessary\n-            return mark_julia_slot(addr, jfty, NULL, tbaa);\n+            // TODO: insert maybe_null handling here?\n+            Value *tindex = ptindex ? emit_load_tindex(ctx, ptindex, union_max, strct.tbaa) : nullptr;\n+            return mark_julia_slot(addr, jfty, tindex, tbaa);\n         }\n-        unsigned align = jl_field_align(jt, idx);\n         if (needlock)\n             emit_lockstate_value(ctx, needlock, true);\n         jl_cgval_t ret = typed_load(ctx, addr, NULL, jfty, tbaa, nullptr, false,\n                 needlock ? AtomicOrdering::NotAtomic : get_llvm_atomic_order(order),\n-                maybe_null, align, nullcheck);\n-        if (ret.V) {\n+                maybe_null, jl_field_align(jt, idx), nullcheck, ptindex, strct.tbaa);\n+        if (ret.V && ret.V != addr)\n             setNameWithField(ctx.emission_context, ret.V, get_objname, jt, idx, Twine());\n-        }\n         if (needlock)\n             emit_lockstate_value(ctx, needlock, false);\n         return ret;\n@@ -3804,17 +3901,18 @@ static void union_alloca_type(jl_uniontype_t *ut,\n     allunbox = for_each_uniontype_small(\n             [&](unsigned idx, jl_datatype_t *jt) {\n                 if (!jl_is_datatype_singleton(jt)) {\n-                    //size_t nb1, n_roots;\n-                    //std::tie(nb1, n_roots) = split_value_size(jt); // TODO: deal with using this later\n+                    //auto [nb1, n_roots] = split_value_size(jt); // TODO: deal with using this later\n                     size_t nb1 = jl_datatype_size(jt);\n                     size_t n_roots = jl_datatype_layout(jt)->npointers;\n                     size_t align1 = julia_alignment((jl_value_t*)jt);\n-                    if (nb1 > nbytes)\n-                        nbytes = nb1;\n-                    if (align1 > align)\n-                        align = align1;\n-                    if (align1 < min_align)\n-                        min_align = align1;\n+                    if (!allpointers(nb1, n_roots)) {\n+                        if (nb1 > nbytes)\n+                            nbytes = nb1;\n+                        if (align1 > align)\n+                            align = align1;\n+                        if (align1 < min_align)\n+                            min_align = align1;\n+                    }\n                     if (n_roots > inline_roots)\n                         inline_roots = n_roots;\n                 }\n@@ -4054,7 +4152,7 @@ static Value *boxed(jl_codectx_t &ctx, const jl_cgval_t &vinfo, bool is_promotab\n // copy src to dest, if src is justbits. if skip is true, the value of dest is undefined\n // TODO: rename this to just `emit_typed_move`\n static void emit_unionmove(jl_codectx_t &ctx, Value *dest, jl_value_t *desttype,\n-        MDNode *tbaa_dst, const jl_cgval_t &src, Value *skip, bool isVolatile=false)\n+        MDNode *tbaa_dst, const jl_cgval_t &src, Value *tindex, Value *skip, bool isVolatile)\n {\n     if (AllocaInst *ai = dyn_cast<AllocaInst>(dest))\n         // TODO: make this a lifetime_end & dereferenceable annotation?\n@@ -4082,7 +4180,7 @@ static void emit_unionmove(jl_codectx_t &ctx, Value *dest, jl_value_t *desttype,\n         }\n     }\n     else {\n-        Value *tindex = compute_tindex_unboxed(ctx, src, desttype, skip != nullptr);\n+        tindex = ctx.builder.CreateAnd(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0x7f));\n         if (skip)\n             tindex = ctx.builder.CreateSelect(skip, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0), tindex);\n         BasicBlock *defaultBB = BasicBlock::Create(ctx.builder.getContext(), \"union_move_skip\", ctx.f);\n@@ -4092,6 +4190,8 @@ static void emit_unionmove(jl_codectx_t &ctx, Value *dest, jl_value_t *desttype,\n         unsigned counter = 0;\n         bool allunboxed = for_each_uniontype_small(\n                 [&](unsigned idx, jl_datatype_t *jt) {\n+                    if (!jl_subtype((jl_value_t*)jt, src.typ))\n+                        return;\n                     unsigned nb = jl_datatype_size(jt);\n                     unsigned alignment = julia_alignment((jl_value_t*)jt);\n                     BasicBlock *tempBB = BasicBlock::Create(ctx.builder.getContext(), \"union_move\", ctx.f);\n@@ -4107,7 +4207,7 @@ static void emit_unionmove(jl_codectx_t &ctx, Value *dest, jl_value_t *desttype,\n \n                     ctx.builder.CreateBr(postBB);\n                 },\n-                src.typ,\n+                desttype,\n                 counter);\n         ctx.builder.SetInsertPoint(defaultBB);\n         if (!skip && allunboxed && (src.V == NULL || isa<AllocaInst>(src.V))) {\n@@ -4220,103 +4320,11 @@ static void emit_write_multibarrier(jl_codectx_t &ctx, Value *parent, const jl_c\n     emit_write_barrier(ctx, parent, ptrs);\n }\n \n-static jl_cgval_t union_store(jl_codectx_t &ctx,\n-        Value *ptr, Value *ptindex, jl_cgval_t rhs, jl_cgval_t cmp,\n-        jl_value_t *jltype, MDNode *tbaa, MDNode *tbaa_tindex,\n-        AtomicOrdering Order, AtomicOrdering FailOrder,\n-        Value *needlock, bool issetfield, bool isreplacefield, bool isswapfield, bool ismodifyfield, bool issetfieldonce,\n-        const jl_cgval_t *modifyop, const Twine &fname)\n-{\n-    assert(Order == AtomicOrdering::NotAtomic);\n-    if (issetfieldonce)\n-        return mark_julia_const(ctx, jl_false);\n-    auto newval = [&](const jl_cgval_t &lhs) { // for ismodifyfield\n-        const jl_cgval_t argv[3] = { cmp, lhs, rhs };\n-        jl_cgval_t ret;\n-        if (modifyop) {\n-            ret = emit_invoke(ctx, *modifyop, argv, 3, (jl_value_t*)jl_any_type, true);\n-        }\n-        else {\n-            Value *callval = emit_jlcall(ctx, jlapplygeneric_func, nullptr, argv, 3, julia_call);\n-            ret = mark_julia_type(ctx, callval, true, jl_any_type);\n-        }\n-        emit_typecheck(ctx, ret, jltype, fname);\n-        ret = update_julia_type(ctx, ret, jltype);\n-        return ret;\n-    };\n-    size_t fsz = 0, al = 0;\n-    int union_max = jl_islayout_inline(jltype, &fsz, &al);\n-    assert(union_max > 0);\n-    jl_cgval_t rhs_union = rhs;\n-    if (!ismodifyfield)\n-        rhs_union = convert_julia_type_to_union(ctx, rhs_union, jltype, false);\n-    if (rhs_union.typ == jl_bottom_type)\n-        return jl_cgval_t();\n-    if (needlock)\n-        emit_lockstate_value(ctx, needlock, true);\n-    BasicBlock *ModifyBB = NULL;\n-    if (ismodifyfield) {\n-        ModifyBB = BasicBlock::Create(ctx.builder.getContext(), \"modify_xchg\", ctx.f);\n-        ctx.builder.CreateBr(ModifyBB);\n-        ctx.builder.SetInsertPoint(ModifyBB);\n-    }\n-    jl_cgval_t oldval = rhs; // issetfield returns rhs\n-    if (!issetfield)\n-        oldval = emit_unionload(ctx, ptr, ptindex, jltype, fsz, al, tbaa, true, union_max, tbaa_tindex);\n-    Value *Success = NULL;\n-    BasicBlock *DoneBB = NULL;\n-    if (isreplacefield || ismodifyfield) {\n-        if (ismodifyfield) {\n-            if (needlock)\n-                emit_lockstate_value(ctx, needlock, false);\n-            rhs = newval(oldval);\n-            rhs_union = convert_julia_type_to_union(ctx, rhs, jltype, false);\n-            if (rhs_union.typ == jl_bottom_type)\n-                return jl_cgval_t();\n-            if (needlock)\n-                emit_lockstate_value(ctx, needlock, true);\n-            cmp = oldval;\n-            oldval = emit_unionload(ctx, ptr, ptindex, jltype, fsz, al, tbaa, true, union_max, tbaa_tindex);\n-        }\n-        BasicBlock *XchgBB = BasicBlock::Create(ctx.builder.getContext(), \"xchg\", ctx.f);\n-        DoneBB = BasicBlock::Create(ctx.builder.getContext(), \"done_xchg\", ctx.f);\n-        Success = emit_f_is(ctx, oldval, cmp);\n-        ctx.builder.CreateCondBr(Success, XchgBB, ismodifyfield ? ModifyBB : DoneBB);\n-        ctx.builder.SetInsertPoint(XchgBB);\n-    }\n-    Value *tindex = ctx.builder.CreateAnd(rhs_union.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER));\n-    tindex = ctx.builder.CreateNUWSub(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 1));\n-    jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa_tindex);\n-    ai.decorateInst(ctx.builder.CreateAlignedStore(tindex, ptindex, Align(1)));\n-    // copy data\n-    if (!rhs.isghost) {\n-        emit_unionmove(ctx, ptr, jltype, tbaa, rhs, /*skip*/nullptr);\n-    }\n-    if (isreplacefield || ismodifyfield) {\n-        ctx.builder.CreateBr(DoneBB);\n-        ctx.builder.SetInsertPoint(DoneBB);\n-    }\n-    if (needlock)\n-        emit_lockstate_value(ctx, needlock, false);\n-    if (isreplacefield) {\n-        Success = ctx.builder.CreateZExt(Success, getInt8Ty(ctx.builder.getContext()));\n-        jl_cgval_t argv[2] = {oldval, mark_julia_type(ctx, Success, false, jl_bool_type)};\n-        jl_datatype_t *rettyp = jl_apply_cmpswap_type(jltype);\n-        oldval = emit_new_struct(ctx, (jl_value_t*)rettyp, 2, argv);\n-    }\n-    else if (ismodifyfield) {\n-        jl_cgval_t argv[2] = {oldval, rhs};\n-        jl_datatype_t *rettyp = jl_apply_modify_type(jltype);\n-        oldval = emit_new_struct(ctx, (jl_value_t*)rettyp, 2, argv);\n-    }\n-    return oldval;\n-}\n-\n static jl_cgval_t emit_setfield(jl_codectx_t &ctx,\n         jl_datatype_t *sty, const jl_cgval_t &strct, size_t idx0,\n         jl_cgval_t rhs, jl_cgval_t cmp,\n         bool wb, AtomicOrdering Order, AtomicOrdering FailOrder,\n-        Value *needlock, bool issetfield, bool isreplacefield, bool isswapfield, bool ismodifyfield, bool issetfieldonce,\n+        Value *needlock, StoreKind op,\n         const jl_cgval_t *modifyop, const Twine &fname)\n {\n     auto get_objname = [&]() {\n@@ -4333,22 +4341,20 @@ static jl_cgval_t emit_setfield(jl_codectx_t &ctx,\n     }\n     jl_value_t *jfty = jl_field_type(sty, idx0);\n     bool isboxed = jl_field_isptr(sty, idx0);\n+    unsigned align = jl_field_align(sty, idx0);\n+    bool maybe_null = field_may_be_null(strct, sty, idx0);\n+    Value *ptindex = nullptr;\n     if (!isboxed && jl_is_uniontype(jfty)) {\n         size_t fsz1 = jl_field_size(sty, idx0) - 1;\n-        Value *ptindex = emit_ptrgep(ctx, addr, fsz1);\n+        ptindex = emit_ptrgep(ctx, addr, fsz1);\n         setNameWithField(ctx.emission_context, ptindex, get_objname, sty, idx0, Twine(\".tindex_ptr\"));\n-        return union_store(ctx, addr, ptindex, rhs, cmp, jfty, tbaa, strct.tbaa,\n-            Order, FailOrder,\n-            needlock, issetfield, isreplacefield, isswapfield, ismodifyfield, issetfieldonce,\n-            modifyop, fname);\n     }\n-    unsigned align = jl_field_align(sty, idx0);\n-    bool maybe_null = field_may_be_null(strct, sty, idx0);\n     return typed_store(ctx, addr, rhs, cmp, jfty, tbaa, nullptr,\n         wb ? boxed(ctx, strct) : nullptr,\n         isboxed, Order, FailOrder, align,\n-        needlock, issetfield, isreplacefield, isswapfield, ismodifyfield, issetfieldonce,\n-        maybe_null, modifyop, fname, nullptr, nullptr);\n+        needlock, op,\n+        maybe_null, modifyop, fname, nullptr, nullptr,\n+        ptindex, strct.tbaa);\n }\n \n static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t nargs, ArrayRef<jl_cgval_t> argv, bool is_promotable)\n@@ -4478,7 +4484,7 @@ static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t narg\n                     if (rhs_union.typ == jl_bottom_type)\n                         return jl_cgval_t();\n                     Value *tindex = ctx.builder.CreateAnd(rhs_union.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER));\n-                    tindex = ctx.builder.CreateNUWSub(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 1));\n+                    Value *stindex = ctx.builder.CreateNUWSub(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 1));\n                     size_t fsz = 0, al = 0;\n                     bool isptr = !jl_islayout_inline(jtype, &fsz, &al);\n                     assert(!isptr && fsz < jl_field_size(sty, i)); (void)isptr;\n@@ -4494,7 +4500,7 @@ static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t narg\n                             assert(lt->getStructElementType(llvm_idx) == ET);\n                             AllocaInst *lv = emit_static_alloca(ctx, fsz1, Align(al));\n                             setName(ctx.emission_context, lv, \"unioninit\");\n-                            emit_unionmove(ctx, lv, jtype, ctx.tbaa().tbaa_stack, fval_info, /*skip*/nullptr);\n+                            emit_unionmove(ctx, lv, jtype, ctx.tbaa().tbaa_stack, fval_info, tindex, /*skip*/nullptr);\n                             // emit all of the align-sized words\n                             unsigned i = 0;\n                             for (; i < fsz1 / al; i++) {\n@@ -4515,16 +4521,16 @@ static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t narg\n                             }\n                         }\n                         llvm_idx = ptindex;\n-                        fval = tindex;\n+                        fval = stindex;\n                         if (jl_is_vecelement_type(ty))\n                             fval = ctx.builder.CreateInsertValue(strct, fval, ArrayRef<unsigned>(llvm_idx));\n                     }\n                     else {\n                         Value *ptindex = emit_ptrgep(ctx, strct, offs + fsz1);\n                         jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_unionselbyte);\n-                        ai.decorateInst(ctx.builder.CreateAlignedStore(tindex, ptindex, Align(1)));\n+                        ai.decorateInst(ctx.builder.CreateAlignedStore(stindex, ptindex, Align(1)));\n                         if (!rhs_union.isghost)\n-                            emit_unionmove(ctx, dest, jtype, ctx.tbaa().tbaa_stack, fval_info, /*skip*/nullptr);\n+                            emit_unionmove(ctx, dest, jtype, ctx.tbaa().tbaa_stack, fval_info, tindex, /*skip*/nullptr);\n                     }\n                     assert(roots.empty());\n                 }\n@@ -4632,7 +4638,7 @@ static jl_cgval_t emit_new_struct(jl_codectx_t &ctx, jl_value_t *ty, size_t narg\n             rhs = update_julia_type(ctx, rhs, ft);\n             if (rhs.typ == jl_bottom_type)\n                 return jl_cgval_t();\n-            emit_setfield(ctx, sty, strctinfo, i, rhs, jl_cgval_t(), need_wb, AtomicOrdering::NotAtomic, AtomicOrdering::NotAtomic, nullptr, true, false, false, false, false, nullptr, \"new\");\n+            emit_setfield(ctx, sty, strctinfo, i, rhs, jl_cgval_t(), need_wb, AtomicOrdering::NotAtomic, AtomicOrdering::NotAtomic, nullptr, StoreKind::Set, nullptr, \"new\");\n         }\n         return strctinfo;\n     }"
    },
    {
      "sha": "0bb938c92d23a044bac6c865c78faf29bf2ec1c2",
      "filename": "src/codegen.cpp",
      "status": "modified",
      "additions": 235,
      "deletions": 215,
      "changes": 450,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3683074bb0c348236bf2bc1c79b5990c6d7ca59b/src%2Fcodegen.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3683074bb0c348236bf2bc1c79b5990c6d7ca59b/src%2Fcodegen.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcodegen.cpp?ref=3683074bb0c348236bf2bc1c79b5990c6d7ca59b",
      "patch": "@@ -1823,30 +1823,43 @@ struct jl_cgval_t {\n         // or drop this whole value if there are not enough roots to populate it\n         if (!inline_roots.empty()) {\n             size_t inline_roots_count;\n+            bool allunbox;\n             bool justpointers = false;\n             if (tindex) {\n-                bool allunbox;\n                 size_t nbytes, align, min_align;\n                 union_alloca_type((jl_uniontype_t*)typ, allunbox, nbytes, align, min_align, inline_roots_count);\n-                justpointers = allpointers(nbytes, inline_roots_count);\n+                justpointers = nbytes == 0;\n                 if (inline_roots_count > inline_roots.size())\n                     inline_roots_count = inline_roots.size();\n             }\n             else if (!deserves_stack(typ)) {\n                 inline_roots_count = 0;\n+                allunbox = false;\n             }\n             else {\n                 const jl_datatype_layout_t *layout = ((jl_datatype_t*)typ)->layout;\n                 inline_roots_count = layout ? layout->npointers : 0;\n                 justpointers = layout ? allpointers((jl_datatype_t*)typ) : 0;\n+                allunbox = true;\n             }\n             assert(v.TIndex || inline_roots.size() == inline_roots_count);\n             if (V == nullptr && constant == nullptr && !isghost && (inline_roots_count == 0 || (!tindex && !justpointers)))\n                 *this = jl_cgval_t(); // no data to populate this value\n             else if (inline_roots_count < inline_roots.size())\n-                inline_roots.truncate(inline_roots_count);\n-            else if (inline_roots_count > inline_roots.size())\n-                *this = jl_cgval_t(); // not enough roots to populate this value\n+                inline_roots.truncate(inline_roots_count); // drop excess roots\n+            else if (inline_roots_count > inline_roots.size()) {\n+                if (allunbox || Vboxed == nullptr) {\n+                    *this = jl_cgval_t(); // not enough roots/boxes to populate this value\n+                }\n+                else {\n+                    // kill unboxed elements, just keeping boxed ones\n+                    V = Vboxed;\n+                    inline_roots.truncate(0);\n+                    if (tindex)\n+                        tindex = ConstantInt::get(tindex->getType(), UNION_BOX_MARKER);\n+                    isboxed = true;\n+                }\n+            }\n             // drop data if all of the content is in the roots\n             if (inline_roots_count > 0 && justpointers && Vboxed == nullptr)\n                 V = nullptr;\n@@ -2295,7 +2308,6 @@ static bool valid_as_globalinit(const Value *v) {\n }\n \n static Value *zext_struct(jl_codectx_t &ctx, Value *V);\n-static std::pair<AllocaInst*, SmallVector<Value*,0>> split_value(jl_codectx_t &ctx, const jl_cgval_t &x, Align x_alignment);\n \n // TODO: in the future, assume all callers will handle the interior pointers separately, and have\n // have zext_struct strip them out, so we aren't saving those to the stack here causing shadow stores\n@@ -2606,24 +2618,26 @@ static jl_cgval_t convert_julia_type_to_union(jl_codectx_t &ctx, const jl_cgval_\n             Value *slotv;\n             MDNode *tbaa;\n             if (v.V == nullptr) {\n-                // v.V might be NULL if it was all constants before\n-                slotv = nullptr;\n-                tbaa = ctx.tbaa().tbaa_const;\n+                // v.V might be NULL if it was all constants or didn't have bits data before\n+                slotv = boxv;\n+                tbaa = v.inline_roots.empty() ? ctx.tbaa().tbaa_const : ctx.tbaa().tbaa_immut;\n             }\n             else if (!v.inline_roots.empty() || v.ispointer()) {\n-                Value *isboxv = ctx.builder.CreateIsNotNull(boxv);\n                 slotv = v.V;\n                 tbaa = v.tbaa;\n-                slotv = ctx.builder.CreateSelect(isboxv,\n-                            decay_derived(ctx, boxv),\n-                            decay_derived(ctx, slotv));\n             }\n             else {\n                 jl_cgval_t oldv = value_to_pointer(ctx, v.V, v.typ, v.TIndex);\n                 slotv = oldv.V;\n                 tbaa = oldv.tbaa;\n             }\n-            // recreate ret with new representation (except boxed bit of TIndex isn't set correctly but new_tindex isn't fully computed yet either)\n+            if (slotv != boxv) {\n+                Value *isboxv = ctx.builder.CreateIsNotNull(boxv);\n+                slotv = ctx.builder.CreateSelect(isboxv,\n+                            decay_derived(ctx, boxv),\n+                            decay_derived(ctx, slotv));\n+            }\n+            // recreate ret with new representation (except boxed bit of TIndex isn't set correctly yet, but new_tindex isn't fully computed yet either)\n             ret = jl_cgval_t(slotv, false, typ, v.TIndex, tbaa, ret.inline_roots);\n             assert(boxv->getType() == ctx.types().T_prjlvalue);\n             ret.Vboxed = boxv;\n@@ -2896,7 +2910,7 @@ static bool uses_specsig(jl_value_t *sig, bool needsparams, jl_value_t *rettype,\n         bool allunbox;\n         size_t nbytes, align, min_align, return_roots;\n         union_alloca_type((jl_uniontype_t*)rettype, allunbox, nbytes, align, min_align, return_roots);\n-        if (nbytes > 0)\n+        if (nbytes > 0 || return_roots > 0)\n             return true; // some elements of the union could be returned unboxed avoiding allocation\n     }\n     if (jl_nparams(sig) <= 3) // few parameters == more efficient to pass directly\n@@ -3342,7 +3356,7 @@ static jl_cgval_t emit_globalref(jl_codectx_t &ctx, jl_module_t *mod, jl_sym_t *\n \n static jl_cgval_t emit_globalop(jl_codectx_t &ctx, jl_module_t *mod, jl_sym_t *sym, jl_cgval_t rval, const jl_cgval_t &cmp,\n                                 AtomicOrdering Order, AtomicOrdering FailOrder,\n-                                bool issetglobal, bool isreplaceglobal, bool isswapglobal, bool ismodifyglobal, bool issetglobalonce,\n+                                StoreKind op,\n                                 const jl_cgval_t *modifyop, bool alloc)\n {\n     jl_binding_t *bnd = jl_get_module_binding(mod, sym, 1);\n@@ -3353,9 +3367,9 @@ static jl_cgval_t emit_globalop(jl_codectx_t &ctx, jl_module_t *mod, jl_sym_t *s\n             int possibly_deprecated = bpart->kind & PARTITION_FLAG_DEPWARN;\n             jl_value_t *ty = bpart->restriction;\n             if (ty != nullptr) {\n-                const std::string fname = issetglobal ? \"setglobal!\" : isreplaceglobal ? \"replaceglobal!\" : isswapglobal ? \"swapglobal!\" : ismodifyglobal ? \"modifyglobal!\" : \"setglobalonce!\";\n-                if (!ismodifyglobal) {\n-                    emit_typecheck(ctx, rval, ty, fname.c_str());\n+                const char *fname = store_kind_name(op, \"global\");\n+                if (op != StoreKind::Modify) {\n+                    emit_typecheck(ctx, rval, ty, fname);\n                     rval = update_julia_type(ctx, rval, ty);\n                     if (rval.typ == jl_bottom_type)\n                         return jl_cgval_t();\n@@ -3376,11 +3390,7 @@ static jl_cgval_t emit_globalop(jl_codectx_t &ctx, jl_module_t *mod, jl_sym_t *s\n                                 FailOrder,\n                                 0,\n                                 nullptr,\n-                                issetglobal,\n-                                isreplaceglobal,\n-                                isswapglobal,\n-                                ismodifyglobal,\n-                                issetglobalonce,\n+                                op,\n                                 maybe_null,\n                                 modifyop,\n                                 fname,\n@@ -3394,31 +3404,32 @@ static jl_cgval_t emit_globalop(jl_codectx_t &ctx, jl_module_t *mod, jl_sym_t *s\n     Value *s = literal_pointer_val(ctx, (jl_value_t*)sym);\n     ctx.builder.CreateCall(prepare_call(jlcheckbpwritable_func),\n         { bp, m, s });\n-    if (issetglobal) {\n+    switch (op) {\n+    case StoreKind::Set:\n         ctx.builder.CreateCall(prepare_call(jlcheckassign_func),\n                 { bp, m, s, mark_callee_rooted(ctx, boxed(ctx, rval)) });\n         return rval;\n-    }\n-    else if (isreplaceglobal) {\n+    case StoreKind::Replace: {\n         Value *r = ctx.builder.CreateCall(prepare_call(jlcheckreplace_func),\n                 { bp, m, s, boxed(ctx, cmp), boxed(ctx, rval) });\n         return mark_julia_type(ctx, r, true, jl_any_type);\n     }\n-    else if (isswapglobal) {\n+    case StoreKind::Swap: {\n         Value *r = ctx.builder.CreateCall(prepare_call(jlcheckswap_func),\n                 { bp, m, s, mark_callee_rooted(ctx, boxed(ctx, rval)) });\n         return mark_julia_type(ctx, r, true, jl_any_type);\n     }\n-    else if (ismodifyglobal) {\n+    case StoreKind::Modify: {\n         Value *r = ctx.builder.CreateCall(prepare_call(jlcheckmodify_func),\n                 { bp, m, s, boxed(ctx, cmp), boxed(ctx, rval) });\n         return mark_julia_type(ctx, r, true, jl_any_type);\n     }\n-    else if (issetglobalonce) {\n+    case StoreKind::SetOnce: {\n         Value *r = ctx.builder.CreateCall(prepare_call(jlcheckassignonce_func),\n                 { bp, m, s, mark_callee_rooted(ctx, boxed(ctx, rval)) });\n         return mark_julia_type(ctx, r, true, jl_bool_type);\n     }\n+    }\n     abort(); // unreachable\n }\n \n@@ -3477,8 +3488,8 @@ static Value *emit_bitsunion_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1,\n             BasicBlock *tempBB = BasicBlock::Create(ctx.builder.getContext(), \"unionbits_is\", ctx.f);\n             ctx.builder.SetInsertPoint(tempBB);\n             switchInst->addCase(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), idx), tempBB);\n-            jl_cgval_t sel_arg1(arg1, (jl_value_t*)jt, NULL);\n-            jl_cgval_t sel_arg2(arg2, (jl_value_t*)jt, NULL);\n+            jl_cgval_t sel_arg1 = update_julia_type(ctx, arg1, (jl_value_t*)jt);\n+            jl_cgval_t sel_arg2 = update_julia_type(ctx, arg2, (jl_value_t*)jt);\n             Value *cmp = emit_bits_compare(ctx, sel_arg1, sel_arg2);\n             tempBB = ctx.builder.GetInsertBlock(); // could have changed\n             phi->addIncoming(cmp, tempBB);\n@@ -3505,6 +3516,9 @@ static Value *emit_bitsunion_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1,\n static Value *emit_bits_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2)\n {\n     ++EmittedBitsCompares;\n+    if (arg1.typ == jl_bottom_type || arg2.typ == jl_bottom_type)\n+        return UndefValue::get(getInt1Ty(ctx.builder.getContext()));\n+\n     jl_value_t *argty = (arg1.constant ? jl_typeof(arg1.constant) : arg1.typ);\n     bool isboxed;\n     Type *at = julia_type_to_llvm(ctx, arg1.typ, &isboxed);\n@@ -3680,8 +3694,9 @@ static Value *emit_f_is(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgva\n             BasicBlock *postBB = BasicBlock::Create(ctx.builder.getContext(), \"post_is\", ctx.f);\n             ctx.builder.CreateCondBr(same_type, isaBB, postBB);\n             ctx.builder.SetInsertPoint(isaBB);\n-            Value *bitcmp = emit_bits_compare(ctx, jl_cgval_t(arg1, (jl_value_t*)typ, NULL),\n-                                              jl_cgval_t(arg2, (jl_value_t*)typ, NULL));\n+            Value *bitcmp = emit_bits_compare(ctx,\n+                    update_julia_type(ctx, arg1, (jl_value_t*)typ),\n+                    update_julia_type(ctx, arg2, (jl_value_t*)typ));\n             isaBB = ctx.builder.GetInsertBlock(); // might have changed\n             ctx.builder.CreateBr(postBB);\n             ctx.builder.SetInsertPoint(postBB);\n@@ -3706,28 +3721,38 @@ static Value *emit_f_is(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgva\n static bool emit_f_opglobal(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                             ArrayRef<jl_cgval_t> argv, size_t nargs, const jl_cgval_t *modifyop)\n {\n-    bool issetglobal = f == BUILTIN(setglobal);\n-    bool isreplaceglobal = f == BUILTIN(replaceglobal);\n-    bool isswapglobal = f == BUILTIN(swapglobal);\n-    bool ismodifyglobal = f == BUILTIN(modifyglobal);\n-    bool issetglobalonce = f == BUILTIN(setglobalonce);\n+    StoreKind op;\n+    if (f == BUILTIN(setglobal))\n+        op = StoreKind::Set;\n+    else if (f == BUILTIN(replaceglobal))\n+        op = StoreKind::Replace;\n+    else if (f == BUILTIN(swapglobal))\n+        op = StoreKind::Swap;\n+    else if (f == BUILTIN(modifyglobal))\n+        op = StoreKind::Modify;\n+    else {\n+        assert(f == BUILTIN(setglobalonce));\n+        op = StoreKind::SetOnce;\n+    }\n+    bool has_cmp = op == StoreKind::Replace || op == StoreKind::Modify;\n     const jl_cgval_t undefval;\n     const jl_cgval_t &mod = argv[1];\n     const jl_cgval_t &sym = argv[2];\n-    jl_cgval_t val = argv[isreplaceglobal || ismodifyglobal ? 4 : 3];\n-    const jl_cgval_t &cmp = isreplaceglobal || ismodifyglobal ? argv[3] : undefval;\n+    jl_cgval_t val = argv[has_cmp ? 4 : 3];\n+    const jl_cgval_t &cmp = has_cmp ? argv[3] : undefval;\n     enum jl_memory_order order = jl_memory_order_release;\n-    const std::string fname = issetglobal ? \"setglobal!\" : isreplaceglobal ? \"replaceglobal!\" : isswapglobal ? \"swapglobal!\" : ismodifyglobal ? \"modifyglobal!\" : \"setglobalonce!\";\n-    if (nargs >= (isreplaceglobal || ismodifyglobal ? 5 : 4)) {\n-        const jl_cgval_t &ord = argv[isreplaceglobal || ismodifyglobal ? 5 : 4];\n+    const char *fname = store_kind_name(op, \"global\");\n+    if (nargs >= (has_cmp ? 5u : 4u)) {\n+        const jl_cgval_t &ord = argv[has_cmp ? 5 : 4];\n         emit_typecheck(ctx, ord, (jl_value_t*)jl_symbol_type, fname);\n         if (!ord.constant)\n             return false;\n-        order = jl_get_atomic_order((jl_sym_t*)ord.constant, !issetglobal, true);\n+        order = jl_get_atomic_order((jl_sym_t*)ord.constant, op != StoreKind::Set, true);\n     }\n     enum jl_memory_order fail_order = order;\n-    if ((isreplaceglobal || issetglobalonce) && nargs == (isreplaceglobal ? 6 : 5)) {\n-        const jl_cgval_t &ord = argv[isreplaceglobal ? 6 : 5];\n+    bool has_fail_order = op == StoreKind::Replace || op == StoreKind::SetOnce;\n+    if (has_fail_order && nargs == (op == StoreKind::Replace ? 6u : 5u)) {\n+        const jl_cgval_t &ord = argv[op == StoreKind::Replace ? 6 : 5];\n         emit_typecheck(ctx, ord, (jl_value_t*)jl_symbol_type, fname);\n         if (!ord.constant)\n             return false;\n@@ -3740,19 +3765,16 @@ static bool emit_f_opglobal(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n     }\n \n     if (order == jl_memory_order_notatomic) {\n-        emit_atomic_error(ctx,\n-                issetglobal ? \"setglobal!: module binding cannot be written non-atomically\" :\n-                isreplaceglobal ? \"replaceglobal!: module binding cannot be written non-atomically\" :\n-                isswapglobal ? \"swapglobal!: module binding cannot be written non-atomically\" :\n-                ismodifyglobal ? \"modifyglobal!: module binding cannot be written non-atomically\" :\n-                \"setglobalonce!: module binding cannot be written non-atomically\");\n+        std::string msg(fname);\n+        msg += \": module binding cannot be written non-atomically\";\n+        emit_atomic_error(ctx, msg.c_str());\n         *ret = jl_cgval_t(); // unreachable\n         return true;\n     }\n     else if (fail_order == jl_memory_order_notatomic) {\n-        emit_atomic_error(ctx,\n-                isreplaceglobal ? \"replaceglobal!: module binding cannot be accessed non-atomically\" :\n-                \"setglobalonce!: module binding cannot be accessed non-atomically\");\n+        std::string msg(fname);\n+        msg += \": module binding cannot be accessed non-atomically\";\n+        emit_atomic_error(ctx, msg.c_str());\n         *ret = jl_cgval_t(); // unreachable\n         return true;\n     }\n@@ -3761,11 +3783,7 @@ static bool emit_f_opglobal(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n         if (mod.constant && jl_is_module(mod.constant)) {\n             *ret = emit_globalop(ctx, (jl_module_t*)mod.constant, (jl_sym_t*)sym.constant, val, cmp,\n                                  get_llvm_atomic_order(order), get_llvm_atomic_order(fail_order),\n-                                 issetglobal,\n-                                 isreplaceglobal,\n-                                 isswapglobal,\n-                                 ismodifyglobal,\n-                                 issetglobalonce,\n+                                 op,\n                                  modifyop,\n                                  false);\n             return true;\n@@ -3779,28 +3797,38 @@ static bool emit_f_opfield(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                            ArrayRef<jl_cgval_t> argv, size_t nargs, const jl_cgval_t *modifyop)\n {\n     ++EmittedOpfields;\n-    bool issetfield = f == BUILTIN(setfield);\n-    bool isreplacefield = f == BUILTIN(replacefield);\n-    bool isswapfield = f == BUILTIN(swapfield);\n-    bool ismodifyfield = f == BUILTIN(modifyfield);\n-    bool issetfieldonce = f == BUILTIN(setfieldonce);\n+    StoreKind op;\n+    if (f == BUILTIN(setfield))\n+        op = StoreKind::Set;\n+    else if (f == BUILTIN(replacefield))\n+        op = StoreKind::Replace;\n+    else if (f == BUILTIN(swapfield))\n+        op = StoreKind::Swap;\n+    else if (f == BUILTIN(modifyfield))\n+        op = StoreKind::Modify;\n+    else {\n+        assert(f == BUILTIN(setfieldonce));\n+        op = StoreKind::SetOnce;\n+    }\n+    bool has_cmp = op == StoreKind::Replace || op == StoreKind::Modify;\n     const jl_cgval_t undefval;\n     const jl_cgval_t &obj = argv[1];\n     const jl_cgval_t &fld = argv[2];\n-    jl_cgval_t val = argv[isreplacefield || ismodifyfield ? 4 : 3];\n-    const jl_cgval_t &cmp = isreplacefield || ismodifyfield ? argv[3] : undefval;\n+    jl_cgval_t val = argv[has_cmp ? 4 : 3];\n+    const jl_cgval_t &cmp = has_cmp ? argv[3] : undefval;\n     enum jl_memory_order order = jl_memory_order_notatomic;\n-    const std::string fname = issetfield ? \"setfield!\" : isreplacefield ? \"replacefield!\" : isswapfield ? \"swapfield!\" : ismodifyfield ? \"modifyfield!\" : \"setfieldonce!\";\n-    if (nargs >= (isreplacefield || ismodifyfield ? 5 : 4)) {\n-        const jl_cgval_t &ord = argv[isreplacefield || ismodifyfield ? 5 : 4];\n+    const char *fname = store_kind_name(op, \"field\");\n+    if (nargs >= (has_cmp ? 5u : 4u)) {\n+        const jl_cgval_t &ord = argv[has_cmp ? 5 : 4];\n         emit_typecheck(ctx, ord, (jl_value_t*)jl_symbol_type, fname);\n         if (!ord.constant)\n             return false;\n-        order = jl_get_atomic_order((jl_sym_t*)ord.constant, !issetfield, true);\n+        order = jl_get_atomic_order((jl_sym_t*)ord.constant, op != StoreKind::Set, true);\n     }\n     enum jl_memory_order fail_order = order;\n-    if ((isreplacefield || issetfieldonce) && nargs == (isreplacefield ? 6 : 5)) {\n-        const jl_cgval_t &ord = argv[isreplacefield ? 6 : 5];\n+    bool has_fail_order = op == StoreKind::Replace || op == StoreKind::SetOnce;\n+    if (has_fail_order && nargs == (op == StoreKind::Replace ? 6u : 5u)) {\n+        const jl_cgval_t &ord = argv[op == StoreKind::Replace ? 6 : 5];\n         emit_typecheck(ctx, ord, (jl_value_t*)jl_symbol_type, fname);\n         if (!ord.constant)\n             return false;\n@@ -3826,7 +3854,7 @@ static bool emit_f_opfield(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n         if (idx != -1) {\n             jl_value_t *ft = jl_field_type(uty, idx);\n             if (!jl_has_free_typevars(ft)) {\n-                if (!ismodifyfield) {\n+                if (op != StoreKind::Modify) {\n                     emit_typecheck(ctx, val, ft, fname);\n                     val = update_julia_type(ctx, val, ft);\n                     if (val.typ == jl_bottom_type)\n@@ -3838,42 +3866,31 @@ static bool emit_f_opfield(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                 bool needlock = isatomic && !isboxed && jl_datatype_size(jl_field_type(uty, idx)) > MAX_ATOMIC_SIZE;\n                 *ret = jl_cgval_t();\n                 if (isatomic == (order == jl_memory_order_notatomic)) {\n-                    emit_atomic_error(ctx,\n-                            issetfield ?\n-                            (isatomic ? \"setfield!: atomic field cannot be written non-atomically\"\n-                                      : \"setfield!: non-atomic field cannot be written atomically\") :\n-                            isreplacefield ?\n-                            (isatomic ? \"replacefield!: atomic field cannot be written non-atomically\"\n-                                      : \"replacefield!: non-atomic field cannot be written atomically\") :\n-                            isswapfield ?\n-                            (isatomic ? \"swapfield!: atomic field cannot be written non-atomically\"\n-                                      : \"swapfield!: non-atomic field cannot be written atomically\") :\n-                            ismodifyfield ?\n-                            (isatomic ? \"modifyfield!: atomic field cannot be written non-atomically\"\n-                                      : \"modifyfield!: non-atomic field cannot be written atomically\") :\n-                            (isatomic ? \"setfieldonce!: atomic field cannot be written non-atomically\"\n-                                      : \"setfieldonce!: non-atomic field cannot be written atomically\"));\n+                    std::string msg(fname);\n+                    msg += isatomic ? \": atomic field cannot be written non-atomically\"\n+                                    : \": non-atomic field cannot be written atomically\";\n+                    emit_atomic_error(ctx, msg.c_str());\n                 }\n                 else if (isatomic == (fail_order == jl_memory_order_notatomic)) {\n-                    emit_atomic_error(ctx,\n-                            isreplacefield ?\n-                            (isatomic ? \"replacefield!: atomic field cannot be accessed non-atomically\"\n-                                      : \"replacefield!: non-atomic field cannot be accessed atomically\") :\n-                            (isatomic ? \"setfieldonce!: atomic field cannot be accessed non-atomically\"\n-                                      : \"setfieldonce!: non-atomic field cannot be accessed atomically\"));\n+                    std::string msg(fname);\n+                    msg += isatomic ? \": atomic field cannot be accessed non-atomically\"\n+                                    : \": non-atomic field cannot be accessed atomically\";\n+                    emit_atomic_error(ctx, msg.c_str());\n                 }\n                 else if (!uty->name->mutabl) {\n-                    std::string msg = fname + \": immutable struct of type \"\n-                        + std::string(jl_symbol_name(uty->name->name))\n-                        + \" cannot be changed\";\n+                    std::string msg(fname);\n+                    msg += \": immutable struct of type \";\n+                    msg += jl_symbol_name(uty->name->name);\n+                    msg += \" cannot be changed\";\n                     emit_error(ctx, msg);\n                 }\n                 else if (jl_field_isconst(uty, idx)) {\n-                    std::string msg = fname + \": const field .\"\n-                        + std::string(jl_symbol_name((jl_sym_t*)jl_svecref(jl_field_names(uty), idx)))\n-                        + \" of type \"\n-                        + std::string(jl_symbol_name(uty->name->name))\n-                        + \" cannot be changed\";\n+                    std::string msg(fname);\n+                    msg += \": const field .\";\n+                    msg += jl_symbol_name((jl_sym_t*)jl_svecref(jl_field_names(uty), idx));\n+                    msg += \" of type \";\n+                    msg += jl_symbol_name(uty->name->name);\n+                    msg += \" cannot be changed\";\n                     emit_error(ctx, msg);\n                 }\n                 else {\n@@ -3886,7 +3903,7 @@ static bool emit_f_opfield(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                                 ? AtomicOrdering::NotAtomic\n                                 : get_llvm_atomic_order(fail_order),\n                             needlock ? boxed(ctx, obj) : nullptr,\n-                            issetfield, isreplacefield, isswapfield, ismodifyfield, issetfieldonce,\n+                            op,\n                             modifyop, fname);\n                 }\n                 return true;\n@@ -3926,15 +3943,24 @@ static jl_cgval_t emit_isdefinedglobal(jl_codectx_t &ctx, jl_module_t *modu, jl_\n static bool emit_f_opmemory(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                             ArrayRef<jl_cgval_t> argv, size_t nargs, const jl_cgval_t *modifyop)\n {\n-    bool issetmemory = f == BUILTIN(memoryrefset);\n-    bool isreplacememory = f == BUILTIN(memoryrefreplace);\n-    bool isswapmemory = f == BUILTIN(memoryrefswap);\n-    bool ismodifymemory = f == BUILTIN(memoryrefmodify);\n-    bool issetmemoryonce = f == BUILTIN(memoryrefsetonce);\n+    StoreKind op;\n+    if (f == BUILTIN(memoryrefset))\n+        op = StoreKind::Set;\n+    else if (f == BUILTIN(memoryrefreplace))\n+        op = StoreKind::Replace;\n+    else if (f == BUILTIN(memoryrefswap))\n+        op = StoreKind::Swap;\n+    else if (f == BUILTIN(memoryrefmodify))\n+        op = StoreKind::Modify;\n+    else {\n+        assert(f == BUILTIN(memoryrefsetonce));\n+        op = StoreKind::SetOnce;\n+    }\n+    bool has_cmp = op == StoreKind::Replace || op == StoreKind::Modify;\n \n     const jl_cgval_t undefval;\n     const jl_cgval_t &ref = argv[1];\n-    jl_cgval_t val = argv[isreplacememory || ismodifymemory ? 3 : 2];\n+    jl_cgval_t val = argv[has_cmp ? 3 : 2];\n     jl_value_t *mty_dt = jl_unwrap_unionall(ref.typ);\n     if (!jl_is_genericmemoryref_type(mty_dt) || !jl_is_concrete_type(mty_dt))\n         return false;\n@@ -3946,19 +3972,20 @@ static bool emit_f_opmemory(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n     if (kind != (jl_value_t*)jl_not_atomic_sym && kind != (jl_value_t*)jl_atomic_sym)\n         return false;\n \n-    const jl_cgval_t &cmp = isreplacememory || ismodifymemory ? argv[2] : undefval;\n+    const jl_cgval_t &cmp = has_cmp ? argv[2] : undefval;\n     enum jl_memory_order order = jl_memory_order_notatomic;\n-    const std::string fname = issetmemory ? \"memoryrefset!\" : isreplacememory ? \"memoryrefreplace!\" : isswapmemory ? \"memoryrefswap!\" : ismodifymemory ? \"memoryrefmodify!\" : \"memoryrefsetonce!\";\n+    const char *fname = store_kind_name(op, \"memory\");\n     {\n-        const jl_cgval_t &ord = argv[isreplacememory || ismodifymemory ? 4 : 3];\n+        const jl_cgval_t &ord = argv[has_cmp ? 4 : 3];\n         emit_typecheck(ctx, ord, (jl_value_t*)jl_symbol_type, fname);\n         if (!ord.constant)\n             return false;\n-        order = jl_get_atomic_order((jl_sym_t*)ord.constant, !issetmemory, true);\n+        order = jl_get_atomic_order((jl_sym_t*)ord.constant, op != StoreKind::Set, true);\n     }\n     enum jl_memory_order fail_order = order;\n-    if (isreplacememory || issetmemoryonce) {\n-        const jl_cgval_t &ord = argv[isreplacememory ? 5 : 4];\n+    bool has_fail_order = op == StoreKind::Replace || op == StoreKind::SetOnce;\n+    if (has_fail_order) {\n+        const jl_cgval_t &ord = argv[op == StoreKind::Replace ? 5 : 4];\n         emit_typecheck(ctx, ord, (jl_value_t*)jl_symbol_type, fname);\n         if (!ord.constant)\n             return false;\n@@ -3982,31 +4009,18 @@ static bool emit_f_opmemory(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n     if (al > JL_HEAP_ALIGNMENT)\n         al = JL_HEAP_ALIGNMENT;\n     if (isatomic == (order == jl_memory_order_notatomic)) {\n-        emit_atomic_error(ctx,\n-                issetmemory ?\n-                (isatomic ? \"memoryrefset!: atomic memory cannot be written non-atomically\"\n-                          : \"memoryrefset!: non-atomic memory cannot be written atomically\") :\n-                isreplacememory ?\n-                (isatomic ? \"memoryrefreplace!: atomic memory cannot be written non-atomically\"\n-                          : \"memoryrefreplace!: non-atomic memory cannot be written atomically\") :\n-                isswapmemory ?\n-                (isatomic ? \"memoryrefswap!: atomic memory cannot be written non-atomically\"\n-                          : \"memoryrefswap!: non-atomic memory cannot be written atomically\") :\n-                ismodifymemory ?\n-                (isatomic ? \"memoryrefmodify!: atomic memory cannot be written non-atomically\"\n-                          : \"memoryrefmodify!: non-atomic memory cannot be written atomically\") :\n-                (isatomic ? \"memoryrefsetonce!: atomic memory cannot be written non-atomically\"\n-                          : \"memoryrefsetonce!: non-atomic memory cannot be written atomically\"));\n+        std::string msg(fname);\n+        msg += isatomic ? \": atomic memory cannot be written non-atomically\"\n+                        : \": non-atomic memory cannot be written atomically\";\n+        emit_atomic_error(ctx, msg.c_str());\n         *ret = jl_cgval_t();\n         return true;\n     }\n     else if (isatomic == (fail_order == jl_memory_order_notatomic)) {\n-        emit_atomic_error(ctx,\n-                isreplacememory ?\n-                (isatomic ? \"memoryrefreplace!: atomic memory cannot be accessed non-atomically\"\n-                          : \"memoryrefreplace!: non-atomic memory cannot be accessed atomically\") :\n-                (isatomic ? \"memoryrefsetonce!: atomic memory cannot be accessed non-atomically\"\n-                          : \"memoryrefsetonce!: non-atomic memory cannot be accessed atomically\"));\n+        std::string msg(fname);\n+        msg += isatomic ? \": atomic memory cannot be accessed non-atomically\"\n+                        : \": non-atomic memory cannot be accessed atomically\";\n+        emit_atomic_error(ctx, msg.c_str());\n         *ret = jl_cgval_t();\n         return true;\n     }\n@@ -4024,7 +4038,7 @@ static bool emit_f_opmemory(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n         endBB->insertInto(ctx.f);\n         ctx.builder.SetInsertPoint(endBB);\n     }\n-    if (!ismodifymemory) {\n+    if (op != StoreKind::Modify) {\n         emit_typecheck(ctx, val, ety, fname);\n         val = update_julia_type(ctx, val, ety);\n         if (val.typ == jl_bottom_type)\n@@ -4036,6 +4050,13 @@ static bool emit_f_opmemory(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n     AtomicOrdering FailOrder = (needlock || fail_order <= jl_memory_order_notatomic)\n                         ? AtomicOrdering::NotAtomic\n                         : get_llvm_atomic_order(fail_order);\n+    Value *ptr = nullptr;\n+    Value *ptindex = nullptr;\n+    Value *lock = nullptr;\n+    Value *data_owner = nullptr;\n+    bool maybenull = true;\n+    MDNode *tbaa_ptindex = nullptr;\n+\n     if (isunion) {\n         assert(!isatomic && !needlock);\n         Value *V = emit_memoryref_FCA(ctx, ref, layout);\n@@ -4044,7 +4065,6 @@ static bool emit_f_opmemory(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n         Value *data = emit_genericmemoryptr(ctx, mem, layout, AddressSpace::Loaded);\n         Type *AT = ArrayType::get(IntegerType::get(ctx.builder.getContext(), 8 * al), (elsz + al - 1) / al);\n         // compute tindex from val\n-        Value *ptindex;\n         if (elsz == 0) {\n             ptindex = data;\n         }\n@@ -4054,48 +4074,40 @@ static bool emit_f_opmemory(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n             data = ctx.builder.CreateInBoundsGEP(AT, data, idx0);\n         }\n         ptindex = emit_ptrgep(ctx, ptindex, idx0);\n-        *ret = union_store(ctx, data, ptindex, val, cmp, ety,\n-            ctx.tbaa().tbaa_arraybuf, ctx.tbaa().tbaa_arrayselbyte,\n-            Order, FailOrder,\n-            nullptr, issetmemory, isreplacememory, isswapmemory, ismodifymemory, issetmemoryonce,\n-            modifyop, fname);\n+        ptr = data;\n+        tbaa_ptindex = ctx.tbaa().tbaa_arrayselbyte;\n     }\n     else {\n-        Value *ptr = (layout->size == 0 ? nullptr : emit_memoryref_ptr(ctx, ref, layout));\n-        Value *lock = nullptr;\n-        bool maybenull = true;\n+        ptr = (layout->size == 0 ? nullptr : emit_memoryref_ptr(ctx, ref, layout));\n         if (needlock) {\n             assert(ptr);\n             lock = ptr;\n             // ptr += sizeof(lock);\n             ptr = emit_ptrgep(ctx, ptr, LLT_ALIGN(sizeof(jl_mutex_t), JL_SMALL_BYTE_ALIGNMENT));\n         }\n-        Value *data_owner = NULL; // owner object against which the write barrier must check\n         if (isboxed || layout->first_ptr >= 0) { // if elements are just bits, don't need a write barrier\n             data_owner = emit_memoryref_mem(ctx, ref, layout);\n         }\n-        *ret = typed_store(ctx,\n-                    ptr,\n-                    val, cmp, ety,\n-                    isboxed ? ctx.tbaa().tbaa_ptrarraybuf : ctx.tbaa().tbaa_arraybuf,\n-                    ctx.noalias().aliasscope.current,\n-                    data_owner,\n-                    isboxed,\n-                    Order,\n-                    FailOrder,\n-                    al,\n-                    lock,\n-                    issetmemory,\n-                    isreplacememory,\n-                    isswapmemory,\n-                    ismodifymemory,\n-                    issetmemoryonce,\n-                    maybenull,\n-                    modifyop,\n-                    fname,\n-                    nullptr,\n-                    nullptr);\n     }\n+    *ret = typed_store(ctx,\n+                ptr,\n+                val, cmp, ety,\n+                isboxed ? ctx.tbaa().tbaa_ptrarraybuf : ctx.tbaa().tbaa_arraybuf,\n+                isunion ? nullptr : ctx.noalias().aliasscope.current,\n+                data_owner,\n+                isboxed,\n+                Order,\n+                FailOrder,\n+                al,\n+                lock,\n+                op,\n+                maybenull,\n+                modifyop,\n+                fname,\n+                nullptr,\n+                nullptr,\n+                ptindex,\n+                tbaa_ptindex);\n     return true;\n }\n \n@@ -4410,10 +4422,8 @@ static bool emit_builtin_call(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                     data = ctx.builder.CreateInBoundsGEP(AT, data, idx0);\n                 }\n                 ptindex = emit_ptrgep(ctx, ptindex, idx0);\n-                size_t elsz_c = 0, al_c = 0;\n-                int union_max = jl_islayout_inline(ety, &elsz_c, &al_c);\n-                assert(union_max && LLT_ALIGN(elsz_c, al_c) == elsz && al_c == al);\n-                *ret = emit_unionload(ctx, data, ptindex, ety, elsz_c, al, ctx.tbaa().tbaa_arraybuf, true, union_max, ctx.tbaa().tbaa_arrayselbyte);\n+                *ret = typed_load(ctx, data, NULL, ety, ctx.tbaa().tbaa_arraybuf, nullptr, false,\n+                        AtomicOrdering::NotAtomic, false, 0, nullptr, ptindex, ctx.tbaa().tbaa_arrayselbyte);\n             }\n             else {\n                 Value *ptr = (layout->size == 0 ? nullptr : emit_memoryref_ptr(ctx, ref, layout));\n@@ -5855,7 +5865,8 @@ static void emit_vi_assignment_unboxed(jl_codectx_t &ctx, jl_varinfo_t &vi, Valu\n             auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n             if (rval_info.TIndex) {\n                 Value *Vnull = Constant::getNullValue(ctx.types().T_prjlvalue);\n-                emit_unionmove(ctx, vi.value.V, vi.value.typ, tbaa, rval_info, /*skip*/isboxed, vi.isVolatile);\n+                if (vi.value.V)\n+                    emit_unionmove(ctx, vi.value.V, vi.value.typ, tbaa, rval_info, rval_info.TIndex, /*skip*/isboxed, vi.isVolatile);\n                 SmallVector<Value*,0> inline_roots(vi.inline_roots_count, Vnull);\n                 for (size_t i = 0; i < std::min(rval_info.inline_roots.size(), inline_roots.size()); ++i)\n                     inline_roots[i] = rval_info.inline_roots[i];\n@@ -5899,48 +5910,45 @@ static void emit_phinode_assign(jl_codectx_t &ctx, ssize_t idx, jl_value_t *r)\n         bool allunbox;\n         size_t min_align, nbytes, inline_roots;\n         dest = try_emit_union_alloca(ctx, ((jl_uniontype_t*)phiType), allunbox, min_align, nbytes, inline_roots);\n-        if (inline_roots) {\n-            assert(dest || allunbox);\n-            roots.resize(inline_roots);\n-            for (size_t nr = 0; nr < inline_roots; nr++) {\n-                auto root_phi = PHINode::Create(ctx.types().T_prjlvalue, jl_array_nrows(edges), \"root_phi\");\n-                root_phi->insertInto(BB, InsertPt);\n-                roots[nr] = root_phi;\n-            }\n-        }\n-        if (dest) {\n-            AllocaInst *phi = cast<AllocaInst>(dest->clone());\n-            phi->insertAfter(dest);\n+        if (dest || allunbox || inline_roots) {\n+            Value *ptr = nullptr;\n+            PHINode *ptr_phi = nullptr;\n+            auto tbaa = ctx.tbaa().tbaa_stack;\n             PHINode *Tindex_phi = PHINode::Create(getInt8Ty(ctx.builder.getContext()), jl_array_nrows(edges), \"tindex_phi\");\n             Tindex_phi->insertInto(BB, InsertPt);\n-            PHINode *ptr_phi = PHINode::Create(ctx.types().T_prjlvalue, jl_array_nrows(edges), \"ptr_phi\");\n-            ptr_phi->insertInto(BB, InsertPt);\n-            Value *isboxed = ctx.builder.CreateICmpNE(\n-                    ctx.builder.CreateAnd(Tindex_phi, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER)),\n-                    ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n-            ctx.builder.CreateMemCpy(phi, Align(min_align), dest, dest->getAlign(), nbytes, false);\n-            ctx.builder.CreateLifetimeEnd(dest);\n-            Value *ptr = ctx.builder.CreateSelect(isboxed,\n-                decay_derived(ctx, ptr_phi),\n-                decay_derived(ctx, phi));\n-            jl_cgval_t val = mark_julia_slot(ptr, phiType, Tindex_phi, best_tbaa(ctx.tbaa(), phiType),\n+            if (inline_roots) {\n+                roots.resize(inline_roots);\n+                for (size_t nr = 0; nr < inline_roots; nr++) {\n+                    auto root_phi = PHINode::Create(ctx.types().T_prjlvalue, jl_array_nrows(edges), \"root_phi\");\n+                    root_phi->insertInto(BB, InsertPt);\n+                    roots[nr] = root_phi;\n+                }\n+            }\n+            if (dest || inline_roots) {\n+                ptr_phi = PHINode::Create(ctx.types().T_prjlvalue, jl_array_nrows(edges), \"ptr_phi\");\n+                ptr_phi->insertInto(BB, InsertPt);\n+                if (dest) {\n+                    Value *isboxed = ctx.builder.CreateICmpNE(\n+                            ctx.builder.CreateAnd(Tindex_phi, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER)),\n+                            ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n+                    AllocaInst *phi = cast<AllocaInst>(dest->clone());\n+                    phi->insertAfter(dest);\n+                    ctx.builder.CreateMemCpy(phi, Align(min_align), dest, dest->getAlign(), nbytes, false);\n+                    ctx.builder.CreateLifetimeEnd(dest);\n+                    ptr = ctx.builder.CreateSelect(isboxed,\n+                        decay_derived(ctx, ptr_phi),\n+                        decay_derived(ctx, phi));\n+                }\n+                tbaa = best_tbaa(ctx.tbaa(), phiType);\n+            }\n+            jl_cgval_t val = mark_julia_slot(ptr, phiType, Tindex_phi, tbaa,\n                 roots.empty() ? ArrayRef<Value*>() : ArrayRef((Value *const *)&roots.front(), roots.size()));\n             val.Vboxed = ptr_phi;\n             ctx.PhiNodes.push_back(std::make_tuple(val, BB, dest, ptr_phi, roots, r));\n             ctx.SAvalues[idx] = val;\n             ctx.ssavalue_assigned[idx] = true;\n             return;\n         }\n-        else if (allunbox) {\n-            PHINode *Tindex_phi = PHINode::Create(getInt8Ty(ctx.builder.getContext()), jl_array_nrows(edges), \"tindex_phi\");\n-            Tindex_phi->insertInto(BB, InsertPt);\n-            jl_cgval_t val = mark_julia_slot(NULL, phiType, Tindex_phi, ctx.tbaa().tbaa_stack,\n-                roots.empty() ? ArrayRef<Value*>() : ArrayRef((Value *const *)&roots.front(), roots.size()));\n-            ctx.PhiNodes.push_back(std::make_tuple(val, BB, dest, (PHINode*)nullptr, roots, r));\n-            ctx.SAvalues[idx] = val;\n-            ctx.ssavalue_assigned[idx] = true;\n-            return;\n-        }\n     }\n     bool isboxed = !deserves_stack(phiType);\n     Type *vtype = isboxed ? ctx.types().T_prjlvalue : julia_type_to_llvm(ctx, phiType);\n@@ -6121,7 +6129,7 @@ static void emit_assignment(jl_codectx_t &ctx, jl_value_t *l, jl_value_t *r, ssi\n         sym = jl_globalref_name(l);\n     }\n     emit_globalop(ctx, mod, sym, rval_info, jl_cgval_t(), AtomicOrdering::Release, AtomicOrdering::NotAtomic,\n-                  true, false, false, false, false, nullptr, alloc);\n+                  StoreKind::Set, nullptr, alloc);\n     // Global variable. Does not need debug info because the debugger knows about\n     // its memory location.\n }\n@@ -7155,6 +7163,7 @@ static void emit_specsig_to_specsig(\n         break;\n     }\n     case jl_returninfo_t::Ghosts: {\n+        gf_retval = convert_julia_type_to_union(ctx, gf_retval, rettype, false);\n         Value *retval = compute_tindex_unboxed(ctx, gf_retval, rettype);\n         ctx.builder.CreateRet(retval);\n         break;\n@@ -8043,18 +8052,24 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n     }\n     else if (jl_is_uniontype(jlrettype)) {\n         bool allunbox;\n-        // TODO: optimize for case where sret is exactly the needed set of return_roots\n         size_t return_roots;\n         union_alloca_type((jl_uniontype_t*)jlrettype, allunbox, props.union_bytes, props.union_align,\n                 props.union_minalign, return_roots);\n+        tracked_count = return_roots;\n+        if (props.union_bytes == 0 && return_roots > 0) {\n+            // convert all_roots to only union_bytes\n+            props.union_bytes = return_roots * sizeof(void*);\n+            props.union_minalign = props.union_align = sizeof(void*);\n+            //return_roots = 0;\n+            //all_roots = true;\n+        }\n         props.return_roots = (int) return_roots;\n-        if (props.union_bytes || props.return_roots) {\n+        if (props.union_bytes) {\n             props.cc = jl_returninfo_t::Union;\n             fsig.push_back(PointerType::getUnqual(M->getContext()));\n             argnames.push_back(\"union_bytes_return\");\n             Type *pair[] = { T_prjlvalue, getInt8Ty(M->getContext()) };\n             rt = StructType::get(M->getContext(), ArrayRef<Type*>(pair));\n-            tracked_count = props.return_roots;\n         }\n         else if (allunbox) {\n             props.cc = jl_returninfo_t::Ghosts;\n@@ -8112,6 +8127,10 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n     }\n     if (props.cc == jl_returninfo_t::Union) {\n         AttrBuilder param(M->getContext());\n+        if (all_roots) {\n+            assert(!props.return_roots);\n+            param.addAttribute(\"julia.return_roots\", std::to_string(tracked_count));\n+        }\n         param.addAttribute(Attribute::NoAlias);\n         param.addAttribute(Attribute::NoCapture);\n         param.addAttribute(Attribute::NoUndef);\n@@ -9437,13 +9456,14 @@ static jl_llvm_functions_t\n                 break;\n             }\n             case jl_returninfo_t::Ghosts:\n+                retvalinfo = convert_julia_type_to_union(ctx, retvalinfo, jlrettype, false);\n                 retval = compute_tindex_unboxed(ctx, retvalinfo, jlrettype);\n                 break;\n             }\n             auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);\n             if (sret) {\n                 if (returninfo.return_roots || !inline_roots.empty() || retvalinfo.ispointer()) {\n-                    emit_unionmove(ctx, sret, jlrettype, ctx.tbaa().tbaa_stack, retvalinfo, /*skip*/isboxed_union);\n+                    emit_unionmove(ctx, sret, jlrettype, ctx.tbaa().tbaa_stack, retvalinfo, retvalinfo.TIndex, /*skip*/isboxed_union);\n                 }\n                 else if (retvalinfo.V) {\n                     Align align(returninfo.union_align);\n@@ -9739,7 +9759,7 @@ static jl_llvm_functions_t\n                 else if (jl_is_concrete_type(val.typ) || val.constant) {\n                     size_t tindex = get_box_tindex((jl_datatype_t*)(val.constant ? jl_typeof(val.constant) : val.typ), phiType);\n                     if (tindex && dest && (!VN || !val.isboxed)) {\n-                        emit_unionmove(ctx, dest, phiType, ctx.tbaa().tbaa_stack, val, nullptr);\n+                        emit_unionmove(ctx, dest, phiType, ctx.tbaa().tbaa_stack, val, RTindex, nullptr);\n                     }\n                 }\n                 else {\n@@ -9755,7 +9775,7 @@ static jl_llvm_functions_t\n                                 ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));\n                             skip = ctx.builder.CreateOr(isboxed, skip);\n                         }\n-                        emit_unionmove(ctx, dest, phiType, ctx.tbaa().tbaa_arraybuf, new_union, skip);\n+                        emit_unionmove(ctx, dest, phiType, ctx.tbaa().tbaa_stack, val, tindex, skip);\n                     }\n                 }\n                 for (size_t i = 0; i < std::min(new_union.inline_roots.size(), lroots.size()); ++i)"
    },
    {
      "sha": "384dc3c920088a91c1b2f90115ee28d73024574b",
      "filename": "src/intrinsics.cpp",
      "status": "modified",
      "additions": 25,
      "deletions": 17,
      "changes": 42,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3683074bb0c348236bf2bc1c79b5990c6d7ca59b/src%2Fintrinsics.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3683074bb0c348236bf2bc1c79b5990c6d7ca59b/src%2Fintrinsics.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fintrinsics.cpp?ref=3683074bb0c348236bf2bc1c79b5990c6d7ca59b",
      "patch": "@@ -876,7 +876,7 @@ static jl_cgval_t emit_pointerset(jl_codectx_t &ctx, ArrayRef<jl_cgval_t> argv)\n         if (!type_is_ghost(ptrty)) {\n             thePtr = ctx.builder.CreateInBoundsGEP(ptrty, thePtr, im1);\n             typed_store(ctx, thePtr, x, jl_cgval_t(), ety, ctx.tbaa().tbaa_data, nullptr, nullptr, isboxed,\n-                        AtomicOrdering::NotAtomic, AtomicOrdering::NotAtomic, align_nb, nullptr, true, false, false, false, false, false, nullptr, \"atomic_pointerset\", nullptr, nullptr);\n+                        AtomicOrdering::NotAtomic, AtomicOrdering::NotAtomic, align_nb, nullptr, StoreKind::Set, false, nullptr, \"atomic_pointerset\", nullptr, nullptr);\n         }\n     }\n     return e;\n@@ -1005,29 +1005,37 @@ static jl_cgval_t emit_atomic_pointerref(jl_codectx_t &ctx, ArrayRef<jl_cgval_t>\n // x(e[i], y) (modify)\n static jl_cgval_t emit_atomic_pointerop(jl_codectx_t &ctx, intrinsic f, ArrayRef<jl_cgval_t> argv, int nargs, const jl_cgval_t *modifyop)\n {\n-    bool issetfield = f == atomic_pointerset;\n-    bool isreplacefield = f == atomic_pointerreplace;\n-    bool isswapfield = f == atomic_pointerswap;\n-    bool ismodifyfield = f == atomic_pointermodify;\n+    StoreKind op;\n+    if (f == atomic_pointerset)\n+        op = StoreKind::Set;\n+    else if (f == atomic_pointerreplace)\n+        op = StoreKind::Replace;\n+    else if (f == atomic_pointerswap)\n+        op = StoreKind::Swap;\n+    else {\n+        assert(f == atomic_pointermodify);\n+        op = StoreKind::Modify;\n+    }\n+    bool has_cmp = op == StoreKind::Replace || op == StoreKind::Modify;\n     const jl_cgval_t undefval;\n     const jl_cgval_t &e = argv[0];\n-    jl_cgval_t x = isreplacefield || ismodifyfield ? argv[2] : argv[1];\n-    const jl_cgval_t &y = isreplacefield || ismodifyfield ? argv[1] : undefval;\n-    const jl_cgval_t &ord = isreplacefield || ismodifyfield ? argv[3] : argv[2];\n-    const jl_cgval_t &failord = isreplacefield ? argv[4] : undefval;\n+    jl_cgval_t x = has_cmp ? argv[2] : argv[1];\n+    const jl_cgval_t &y = has_cmp ? argv[1] : undefval;\n+    const jl_cgval_t &ord = has_cmp ? argv[3] : argv[2];\n+    const jl_cgval_t &failord = op == StoreKind::Replace ? argv[4] : undefval;\n \n     jl_value_t *aty = e.typ;\n     if (!jl_is_cpointer_type(aty) || !ord.constant || !jl_is_symbol(ord.constant))\n         return emit_runtime_call(ctx, f, argv, nargs);\n-    if (isreplacefield) {\n+    if (op == StoreKind::Replace) {\n         if (!failord.constant || !jl_is_symbol(failord.constant))\n             return emit_runtime_call(ctx, f, argv, nargs);\n     }\n     jl_value_t *ety = jl_tparam0(aty);\n     if (jl_is_typevar(ety))\n         return emit_runtime_call(ctx, f, argv, nargs);\n-    enum jl_memory_order order = jl_get_atomic_order((jl_sym_t*)ord.constant, !issetfield, true);\n-    enum jl_memory_order failorder = isreplacefield ? jl_get_atomic_order((jl_sym_t*)failord.constant, true, false) : order;\n+    enum jl_memory_order order = jl_get_atomic_order((jl_sym_t*)ord.constant, op != StoreKind::Set, true);\n+    enum jl_memory_order failorder = op == StoreKind::Replace ? jl_get_atomic_order((jl_sym_t*)failord.constant, true, false) : order;\n     if (order == jl_memory_order_invalid || failorder == jl_memory_order_invalid || failorder > order) {\n         emit_atomic_error(ctx, \"invalid atomic ordering\");\n         return jl_cgval_t(); // unreachable\n@@ -1041,8 +1049,8 @@ static jl_cgval_t emit_atomic_pointerop(jl_codectx_t &ctx, intrinsic f, ArrayRef\n         Value *thePtr = emit_unbox(ctx, ctx.types().T_pprjlvalue, e);\n         bool isboxed = true;\n         jl_cgval_t ret = typed_store(ctx, thePtr, x, y, ety, ctx.tbaa().tbaa_data, nullptr, nullptr, isboxed,\n-                    llvm_order, llvm_failorder, sizeof(jl_value_t*), nullptr, issetfield, isreplacefield, isswapfield, ismodifyfield, false, false, modifyop, \"atomic_pointermodify\", nullptr, nullptr);\n-        if (issetfield)\n+                    llvm_order, llvm_failorder, sizeof(jl_value_t*), nullptr, op, false, modifyop, \"atomic_pointermodify\", nullptr, nullptr);\n+        if (op == StoreKind::Set)\n             ret = e;\n         return ret;\n     }\n@@ -1053,7 +1061,7 @@ static jl_cgval_t emit_atomic_pointerop(jl_codectx_t &ctx, intrinsic f, ArrayRef\n         emit_error(ctx, msg);\n         return jl_cgval_t();\n     }\n-    if (!ismodifyfield) {\n+    if (op != StoreKind::Modify) {\n         emit_typecheck(ctx, x, ety, std::string(jl_intrinsic_name((int)f)));\n         x = update_julia_type(ctx, x, ety);\n         if (x.typ == jl_bottom_type)\n@@ -1084,8 +1092,8 @@ static jl_cgval_t emit_atomic_pointerop(jl_codectx_t &ctx, intrinsic f, ArrayRef\n         else\n             thePtr = nullptr; // could use any value here, since typed_store will not use it\n         jl_cgval_t ret = typed_store(ctx, thePtr, x, y, ety, ctx.tbaa().tbaa_data, nullptr, nullptr, isboxed,\n-                    llvm_order, llvm_failorder, nb, nullptr, issetfield, isreplacefield, isswapfield, ismodifyfield, false, false, modifyop, \"atomic_pointermodify\", nullptr, nullptr);\n-        if (issetfield)\n+                    llvm_order, llvm_failorder, nb, nullptr, op, false, modifyop, \"atomic_pointermodify\", nullptr, nullptr);\n+        if (op == StoreKind::Set)\n             ret = e;\n         return ret;\n     }"
    }
  ]
}