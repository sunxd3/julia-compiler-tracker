{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60400",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60400/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60400/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60400/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60400",
  "id": 3735378176,
  "node_id": "PR_kwDOABkWpM65Lzdd",
  "number": 60400,
  "title": "syntax-versioning: Define behavior in scripts and REPL",
  "user": {
    "login": "Keno",
    "id": 1291671,
    "node_id": "MDQ6VXNlcjEyOTE2NzE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1291671?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Keno",
    "html_url": "https://github.com/Keno",
    "followers_url": "https://api.github.com/users/Keno/followers",
    "following_url": "https://api.github.com/users/Keno/following{/other_user}",
    "gists_url": "https://api.github.com/users/Keno/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Keno/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Keno/subscriptions",
    "organizations_url": "https://api.github.com/users/Keno/orgs",
    "repos_url": "https://api.github.com/users/Keno/repos",
    "events_url": "https://api.github.com/users/Keno/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Keno/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-12-16T15:53:52Z",
  "updated_at": "2025-12-25T17:54:51Z",
  "closed_at": "2025-12-25T17:54:50Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60400",
    "html_url": "https://github.com/JuliaLang/julia/pull/60400",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60400.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60400.patch",
    "merged_at": "2025-12-25T17:54:49Z"
  },
  "body": "Syntax versioning is cued off of the `syntax.julia_version` entry in a package's Project.toml. But how should it behave in the REPL and in scripts? Unlike a package, the `Main` module does not have a well-defined Project associated with it - rather its loading behavior depends on the current active project.\r\n\r\nIt seems fairly clear that syntax versioning should also follow the active project, but what are the exact semantics? One possibility would be to check the active project's Project.toml every time we need to parse something. However, I think it would be somewhat surprising if the syntax version changed in the middle of a script due to a concurrent edit to the active Project.toml (at least in the absence of something like Revise).\r\n\r\nThis PR instead implements a ScopedValue-based latching mechanism that reads the syntax version:\r\n 1. At startup\r\n 2. For every REPL prompt\r\n\r\nOrdinary ScopedValue behavior determines what happens for e.g. tasks (i.e. a task started from one REPL prompt will continue using that prompt's syntax version for e.g. `include`'s), even if the active project changes in the meanwhile.\r\n\r\nNote that as a consequence of this, changing the active project in the middle of a script does not change the syntax version (not that it would anyway, because we parse the whole script before we eval it - but this makes it not take effect for `include` either).\r\n\r\nI think this is the most sane behavior. Other frontends that want to evaluate into Main can use the same mechanism as the REPL to decide on a policy that makes sense for their use cases.\r\n\r\nIt is possible we may want to extend the scoped value behavior to the active project itself as well, but it doesn't have the same TOCTOU issues that the syntax version has and scripts are relying on it being side-effecting, so it's not straightforward.\r\n\r\nFinally, this adjusts the creation of named environments to implicitly record the syntax version of the julia process that created the named environment. Of course, this is primarily supposed to catch the creation of the `v1.x` global default environments. That said, it's a bit odd that, if we launch 1.14 with an implicit `--project=@v1.13` and that environment does not exist, it would create that as a `1.14` syntax environment. Currently these versioned environments are not special, but maybe we should make them?",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60400/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60400/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "6bed531b155f42e9f9c9289653baaf64c3865913",
      "filename": "base/client.jl",
      "status": "modified",
      "additions": 12,
      "deletions": 4,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/base%2Fclient.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/base%2Fclient.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fclient.jl?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -307,9 +307,9 @@ function exec_options(opts)\n     # process cmds list\n     for (cmd, arg) in cmds\n         if cmd == 'e'\n-            Core.eval(Main, parse_input_line(arg))\n+            Core.eval(Main, parse_input_line(arg; mod=Main))\n         elseif cmd == 'E'\n-            invokelatest(show, Core.eval(Main, parse_input_line(arg)))\n+            invokelatest(show, Core.eval(Main, parse_input_line(arg; mod=Main)))\n             println()\n         elseif cmd == 'm'\n             entrypoint = push!(split(arg, \".\"), \"main\")\n@@ -552,12 +552,17 @@ The thrown errors are collected in a stack of exceptions.\n \"\"\"\n global err = nothing\n \n+const main_parser = Base.ScopedValues.ScopedValue{Any}(Core._parse)\n+function _internal_julia_parse(args...)\n+    main_parser[](args...)\n+end\n+\n # Used for memoizing require_stdlib of these modules\n global InteractiveUtils::Module\n global Distributed::Module\n \n # weakly exposes ans and err variables to Main\n-export ans, err\n+export ans, err, _internal_julia_parse\n end\n \n function should_use_main_entrypoint()\n@@ -573,7 +578,10 @@ function _start()\n     # clear any postoutput hooks that were saved in the sysimage\n     empty!(Base.postoutput_hooks)\n     local ret = 0\n-    try\n+    # `--project` has been processed at this point - latch the active project's syntax\n+    # version and use it for `-L`, `argfile`, etc. If launched, the REPL will re-evaluate\n+    # at each prompt.\n+    @Base.ScopedValues.with MainInclude.main_parser=>parser_for_active_project() try\n         repl_was_requested = exec_options(JLOptions())\n         if invokelatest(should_use_main_entrypoint) && !is_interactive\n             main = invokelatest(getglobal, Main, :main)"
    },
    {
      "sha": "da3bf546dfbcb5146474e63d6a66dad8456611ce",
      "filename": "base/experimental.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 15,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/base%2Fexperimental.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/base%2Fexperimental.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fexperimental.jl?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -746,20 +746,6 @@ macro reexport(ex)\n     return esc(calls)\n end\n \n-struct VersionedParse\n-    ver::VersionNumber\n-end\n-\n-function (vp::VersionedParse)(code, filename::String, lineno::Int, offset::Int, options::Symbol)\n-    if !isdefined(Base, :JuliaSyntax)\n-        if vp.ver === VERSION\n-            return Core._parse\n-        end\n-        error(\"JuliaSyntax module is required for syntax version $(vp.ver), but it is not loaded.\")\n-    end\n-    Base.JuliaSyntax.core_parser_hook(code, filename, lineno, offset, options; syntax_version=vp.ver)\n-end\n-\n struct VersionedLower\n     ver::VersionNumber\n end\n@@ -776,7 +762,7 @@ function (vp::VersionedLower)(@nospecialize(code), mod::Module,\n end\n \n function Base.set_syntax_version(m::Module, ver::VersionNumber)\n-    parser = VersionedParse(ver)\n+    parser = Base.VersionedParse(ver)\n     Core.declare_const(m, :_internal_julia_parse, parser)\n     #lowerer = VersionedLower(ver)\n     #Core.declare_const(m, :_internal_julia_lower, lowerer)"
    },
    {
      "sha": "f828fe474083f4a9e8d2a6b54258363d9c03f319",
      "filename": "base/initdefs.jl",
      "status": "modified",
      "additions": 15,
      "deletions": 1,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/base%2Finitdefs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/base%2Finitdefs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Finitdefs.jl?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -271,6 +271,19 @@ function init_active_project()\n     )\n end\n \n+function init_named_env!(path)\n+    try\n+        mkpath(dirname(path))\n+        open(path, \"w\") do io\n+            print(io, \"syntax.julia_version = \\\"\",VERSION,\"\\\"\")\n+        end\n+        return path\n+    catch e\n+        @warn \"Failed to initialize named environment at $path: $e\"\n+        return nothing\n+    end\n+end\n+\n ## load path expansion: turn LOAD_PATH entries into concrete paths ##\n cmd_suppresses_program(cmd) = cmd in ('e', 'E')\n \n@@ -307,7 +320,8 @@ function load_path_expand(env::AbstractString)::Union{String, Nothing}\n             end\n         end\n         isempty(DEPOT_PATH) && return nothing\n-        return abspath(DEPOT_PATH[1], \"environments\", name, project_names[end])\n+        new_named_env_path = abspath(DEPOT_PATH[1], \"environments\", name, project_names[end])\n+        return init_named_env!(new_named_env_path)\n     end\n     # otherwise, it's a path\n     path = abspath(env)"
    },
    {
      "sha": "208c7630b186b1de13ea3672190f453822689eda",
      "filename": "base/loading.jl",
      "status": "modified",
      "additions": 29,
      "deletions": 3,
      "changes": 32,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/base%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/base%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Floading.jl?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -988,6 +988,33 @@ function workspace_manifest(project_file)\n     return nothing\n end\n \n+struct VersionedParse\n+    ver::VersionNumber\n+end\n+\n+function (vp::VersionedParse)(code, filename::String, lineno::Int, offset::Int, options::Symbol)\n+    if !isdefined(Base, :JuliaSyntax)\n+        if vp.ver === VERSION\n+            return Core._parse\n+        end\n+        error(\"JuliaSyntax module is required for syntax version $(vp.ver), but it is not loaded.\")\n+    end\n+    Base.JuliaSyntax.core_parser_hook(code, filename, lineno, offset, options; syntax_version=vp.ver)\n+end\n+\n+function parser_for_active_project()\n+    project = active_project()\n+    sv = VERSION\n+    if project !== nothing && isfile(project)\n+        try\n+            sv = project_get_syntax_version(parsed_toml(project))\n+        catch e\n+            @warn \"Failed to read project $project - defaulting to latest syntax. err=$e\"\n+        end\n+    end\n+    VersionedParse(sv)\n+end\n+\n # find project file's corresponding manifest file\n function project_file_manifest_path(project_file::String)::Union{Nothing,String}\n     @lock require_lock begin\n@@ -2860,7 +2887,6 @@ function __require_prelocked(pkg::PkgId, env)\n \n     if JLOptions().use_compiled_modules == 1\n         if !generating_output(#=incremental=#false)\n-            project = active_project()\n             # spawn off a new incremental pre-compile task for recursive `require` calls\n             loaded = let spec = spec, reasons = reasons\n                 maybe_cachefile_lock(pkg, spec.path) do\n@@ -2940,7 +2966,7 @@ function __require_prelocked(pkg::PkgId, env)\n     if uuid !== old_uuid\n         ccall(:jl_set_module_uuid, Cvoid, (Any, NTuple{2, UInt64}), __toplevel__, uuid)\n     end\n-    __toplevel__._internal_julia_parse = Experimental.VersionedParse(spec.julia_syntax_version)\n+    __toplevel__._internal_julia_parse = VersionedParse(spec.julia_syntax_version)\n     unlock(require_lock)\n     try\n         include(__toplevel__, path)\n@@ -3275,7 +3301,7 @@ function include_package_for_output(pkg::PkgId, input::String, syntax_version::V\n \n     ccall(:jl_set_newly_inferred, Cvoid, (Any,), newly_inferred)\n     # This one changes the parser behavior\n-    __toplevel__._internal_julia_parse = Experimental.VersionedParse(syntax_version)\n+    __toplevel__._internal_julia_parse = VersionedParse(syntax_version)\n     # This one is the compatibility marker for cache loading\n     __toplevel__._internal_syntax_version = cache_syntax_version(syntax_version)\n     try"
    },
    {
      "sha": "21625da7d987a1c2b21f6e6eca378cb1b37e93b1",
      "filename": "base/show.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/base%2Fshow.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/base%2Fshow.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fshow.jl?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -2181,7 +2181,12 @@ function show_unquoted(io::IO, ex::Expr, indent::Int, prec::Int, quote_level::In\n             print(io, \"end\")\n         end\n \n+    elseif head === :module && nargs==4 && isa(args[1],VersionNumber) && isa(args[2],Bool)\n+        # New 4-argument form: (version, baremodule_flag, name, body)\n+        show_block(IOContext(io, beginsym=>false), args[2] ? :module : :baremodule, args[3], args[4], indent, quote_level)\n+        print(io, \"end\")\n     elseif head === :module && nargs==3 && isa(args[1],Bool)\n+        # Old 3-argument form: (baremodule_flag, name, body)\n         show_block(IOContext(io, beginsym=>false), args[1] ? :module : :baremodule, args[2], args[3], indent, quote_level)\n         print(io, \"end\")\n "
    },
    {
      "sha": "510bda0b1ae07a43e2fa4e0b049e721740f63b9b",
      "filename": "doc/src/manual/code-loading.md",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/doc%2Fsrc%2Fmanual%2Fcode-loading.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/doc%2Fsrc%2Fmanual%2Fcode-loading.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fmanual%2Fcode-loading.md?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -464,6 +464,17 @@ The syntax version for a package is determined by the loading mechanism in the f\n \n 3. If neither is specified, the current Julia version is used.\n \n+#### In scripts and the REPL\n+\n+Scripts and the REPL use the active project's syntax version. This determination happens:\n+\n+1. At startup after processing `--project`\n+2. Before parsing any REPL input, once for each prompt\n+\n+In particular, a manual `set_active_project` in a script will not change the syntax versioned used\n+for the rest of the script. However, doing so at the REPL (explicitly or implicitly via the Pkg\n+REPL mode) will affect the syntax version used to parse the *next* REPL input.\n+\n ## Conclusion\n \n Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage their projects without needing a precise understanding of these interactions. A call to `Pkg.add(\"X\")` will add to the appropriate project and manifest files, selected via `Pkg.activate(\"Y\")`, so that a future call to `import X` will load `X` without further thought."
    },
    {
      "sha": "5ece3b1ddc7e666a87062bc6c63dfa406e839db7",
      "filename": "stdlib/REPL/src/REPL.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 4,
      "changes": 17,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPL.jl?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -740,7 +740,7 @@ function run_frontend(repl::BasicREPL, backend::REPLBackendRef)\n                     rethrow()\n                 end\n             end\n-            ast = Base.parse_input_line(line; mod=Base.active_module(repl))\n+            ast = parse_repl_input_line(line, repl)\n             (isa(ast,Expr) && ast.head === :incomplete) || break\n         end\n         if !isempty(line)\n@@ -1121,8 +1121,17 @@ function history_reset_state(hist::REPLHistoryProvider)\n end\n LineEdit.reset_state(hist::REPLHistoryProvider) = history_reset_state(hist)\n \n+function parse_repl_input_line(line::String, repl; kwargs...)\n+    # N.B.: This re-latches the syntax version for `Main`. If `Base.active_module` is not `Main`,\n+    # then this does not affect the parser used for that module. We could probably skip this step\n+    # in that case, but let's just be consistent on the off chance that the active module tries\n+    # to `include(Main, ...)` or similar.\n+    @Base.ScopedValues.with Base.MainInclude.main_parser=>Base.parser_for_active_project() Base.parse_input_line(line;\n+        mod=Base.active_module(repl), kwargs...)\n+end\n+\n function return_callback(s)\n-    ast = Base.parse_input_line(takestring!(copy(LineEdit.buffer(s))); mod=Base.active_module(s), depwarn=false)\n+    ast = parse_repl_input_line(takestring!(copy(LineEdit.buffer(s))), s; depwarn=false)\n     return !(isa(ast, Expr) && ast.head === :incomplete)\n end\n \n@@ -1376,7 +1385,7 @@ function setup_interface(\n     help_mode.hist = hp\n     dummy_pkg_mode.hist = hp\n \n-    julia_prompt.on_done = respond(x->Base.parse_input_line(x; filename=repl_filename(repl,hp), mod=Base.active_module(repl)), repl, julia_prompt)\n+    julia_prompt.on_done = respond(x->parse_repl_input_line(x, repl; filename=repl_filename(repl,hp)), repl, julia_prompt)\n \n     shell_prompt_len = length(SHELL_PROMPT)\n     help_prompt_len = length(HELP_PROMPT)\n@@ -1800,7 +1809,7 @@ function run_frontend(repl::StreamREPL, backend::REPLBackendRef)\n         end\n         line = readline(repl.stream, keep=true)\n         if !isempty(line)\n-            ast = Base.parse_input_line(line; mod=Base.active_module(repl))\n+            ast = parse_repl_input_line(line, repl)\n             if have_color\n                 print(repl.stream, Base.color_normal)\n             end"
    },
    {
      "sha": "c6bbcbbb260b7a13ddaaef1e5b4229b990251f76",
      "filename": "stdlib/REPL/src/precompile.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/stdlib%2FREPL%2Fsrc%2Fprecompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/stdlib%2FREPL%2Fsrc%2Fprecompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2Fprecompile.jl?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -203,6 +203,7 @@ let\n         ccall(:jl_tag_newly_inferred_enable, Cvoid, ())\n         try\n             repl_workload()\n+            precompile(Tuple{typeof(Base.HashArrayMappedTries.next), Base.HashArrayMappedTries.HashState{Base.ScopedValues.ScopedValue{Any}}})\n             precompile(Tuple{typeof(Base.setindex!), Base.Dict{Any, Any}, Any, Char})\n             precompile(Tuple{typeof(Base.setindex!), Base.Dict{Any, Any}, Any, Int})\n             precompile(Tuple{typeof(Base.delete!), Base.Set{Any}, String})"
    },
    {
      "sha": "9b55d977efc2130c9dcbc8ff8ced19885cacb6c0",
      "filename": "stdlib/REPL/test/repl.jl",
      "status": "modified",
      "additions": 53,
      "deletions": 0,
      "changes": 53,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/stdlib%2FREPL%2Ftest%2Frepl.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/stdlib%2FREPL%2Ftest%2Frepl.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Frepl.jl?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -2039,3 +2039,56 @@ end\n         end\n     end\n end\n+\n+# Test that REPL picks up syntax version from active project and re-latches on project switch\n+@testset \"REPL syntax version switching\" begin\n+    mktempdir() do tmpdir\n+        # Create two projects with different syntax versions\n+        proj1 = joinpath(tmpdir, \"proj1\")\n+        proj2 = joinpath(tmpdir, \"proj2\")\n+        mkpath(proj1)\n+        mkpath(proj2)\n+        write(joinpath(proj1, \"Project.toml\"), \"syntax.julia_version = \\\"1.13\\\"\\n\")\n+        write(joinpath(proj2, \"Project.toml\"), \"syntax.julia_version = \\\"1.14\\\"\\n\")\n+        found_113 = found_114 = false\n+\n+        old_active_project = Base.ACTIVE_PROJECT[]\n+        try\n+            Base.set_active_project(joinpath(proj1, \"Project.toml\"))\n+\n+            fake_repl() do stdin_write, stdout_read, repl\n+                repl.specialdisplay = REPL.REPLDisplay(repl)\n+                repl.history_file = false\n+\n+                repltask = @async REPL.run_repl(repl)\n+\n+                # Wait for the first prompt\n+                readuntil(stdout_read, \"julia> \")\n+\n+                # Check syntax version is 1.13 from proj1\n+                write(stdin_write, \"(Base.Experimental.@VERSION).syntax\\r\")\n+                readuntil(stdout_read, \"v\\\"1.13\")\n+                found_113 = true\n+\n+                # Wait for next prompt\n+                readuntil(stdout_read, \"julia> \")\n+\n+                # Switch to proj2 with syntax version 1.14\n+                write(stdin_write, \"Base.set_active_project($(repr(joinpath(proj2, \"Project.toml\"))))\\r\")\n+                readuntil(stdout_read, \"julia> \")\n+\n+                # Next prompt should use syntax version 1.14 from proj2\n+                write(stdin_write, \"(Base.Experimental.@VERSION).syntax\\r\")\n+                readuntil(stdout_read, \"v\\\"1.14\")\n+                found_114 = true\n+\n+                write(stdin_write, '\\x04')\n+                Base.wait(repltask)\n+            end\n+        finally\n+            Base.set_active_project(old_active_project)\n+        end\n+        @test found_113\n+        @test found_114\n+    end\n+end"
    },
    {
      "sha": "6d6e1d9a133f6bcbc94b8f7c1c44f3e5c9e1d3fd",
      "filename": "test/loading.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/test%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/test%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Floading.jl?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -1901,8 +1901,8 @@ module M58272_to end\n     # Test explicit environments (packages loaded from Manifest.toml)\n     old_load_path = copy(LOAD_PATH)\n     old_active_project = Base.ACTIVE_PROJECT[]\n+    explicit_env = joinpath(@__DIR__, \"project\", \"SyntaxVersioning\", \"explicit\")\n     try\n-        explicit_env = joinpath(@__DIR__, \"project\", \"SyntaxVersioning\", \"explicit\")\n         Base.ACTIVE_PROJECT[] = joinpath(explicit_env, \"Project.toml\")\n         empty!(LOAD_PATH)\n         push!(LOAD_PATH, \"@\")\n@@ -1916,4 +1916,12 @@ module M58272_to end\n         Base.ACTIVE_PROJECT[] = old_active_project\n         copy!(LOAD_PATH, old_load_path)\n     end\n+\n+    # Test that the selected project affects code evaluation in `Main` for both `-e` and scripts\n+    @test parse(VersionNumber, read(`$(Base.julia_cmd()) --project=$(joinpath(explicit_env, \"VersionedDep1\")) -e 'print((Base.Experimental.@VERSION).syntax)'`, String)) == v\"1.13\"\n+    @test parse(VersionNumber, read(`$(Base.julia_cmd()) --project=$(joinpath(explicit_env, \"VersionedDep2\")) -e 'print((Base.Experimental.@VERSION).syntax)'`, String)) == v\"1.14\"\n+\n+    syntax_version_script = joinpath(@__DIR__, \"testhelpers\", \"print_syntax_version.jl\")\n+    @test parse(VersionNumber, read(`$(Base.julia_cmd()) --project=$(joinpath(explicit_env, \"VersionedDep1\")) $syntax_version_script`, String)) == v\"1.13\"\n+    @test parse(VersionNumber, read(`$(Base.julia_cmd()) --project=$(joinpath(explicit_env, \"VersionedDep2\")) $syntax_version_script`, String)) == v\"1.14\"\n end"
    },
    {
      "sha": "1825071ff446cf9e34522f5b019a29f33da14f89",
      "filename": "test/testhelpers/print_syntax_version.jl",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/fbf03865a5331ba8f25963fa63b024aa52b7bd54/test%2Ftesthelpers%2Fprint_syntax_version.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/fbf03865a5331ba8f25963fa63b024aa52b7bd54/test%2Ftesthelpers%2Fprint_syntax_version.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Ftesthelpers%2Fprint_syntax_version.jl?ref=fbf03865a5331ba8f25963fa63b024aa52b7bd54",
      "patch": "@@ -0,0 +1 @@\n+print((Base.Experimental.@VERSION).syntax)"
    }
  ]
}