{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59778",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59778/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59778/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59778/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59778",
  "id": 3495613871,
  "node_id": "PR_kwDOABkWpM6sthSs",
  "number": 59778,
  "title": "add syntax highlighting to the REPL input",
  "user": {
    "login": "KristofferC",
    "id": 1282691,
    "node_id": "MDQ6VXNlcjEyODI2OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1282691?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KristofferC",
    "html_url": "https://github.com/KristofferC",
    "followers_url": "https://api.github.com/users/KristofferC/followers",
    "following_url": "https://api.github.com/users/KristofferC/following{/other_user}",
    "gists_url": "https://api.github.com/users/KristofferC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KristofferC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KristofferC/subscriptions",
    "organizations_url": "https://api.github.com/users/KristofferC/orgs",
    "repos_url": "https://api.github.com/users/KristofferC/repos",
    "events_url": "https://api.github.com/users/KristofferC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KristofferC/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 42281298,
      "node_id": "MDU6TGFiZWw0MjI4MTI5OA==",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/REPL",
      "name": "REPL",
      "color": "c7def8",
      "default": false,
      "description": "Julia's REPL (Read Eval Print Loop)"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 8,
  "created_at": "2025-10-08T14:10:10Z",
  "updated_at": "2025-10-14T19:47:01Z",
  "closed_at": "2025-10-14T19:46:38Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59778",
    "html_url": "https://github.com/JuliaLang/julia/pull/59778",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59778.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59778.patch",
    "merged_at": "2025-10-14T19:46:38Z"
  },
  "body": "Python now ships their default REPL with syntax highlighting (https://realpython.com/python-repl-autocompletion-highlighting/#syntax-highlighting), and I find it unacceptable that the default Python REPL should be (in some cases) better than ours ( :wink: ).\r\n\r\nIt has long been possible to get syntax highlighting from the external OhMyREPL package, but now, since we have StyledStrings + JuliaSyntaxHighlighting as stdlibs, it seems kind of a waste not to use those for this. OhMyREPL also has to touch a lot of internals and there are some awkward corner cases with it so proper first-class support would avoid this.\r\n\r\nIn addition to the highlighting it also adds a little marker showing what parenthesis you are inside (analogous to https://kristofferc.github.io/OhMyREPL.jl/latest/features/bracket_highlighting/). The existing region marking is also implemented in the \"pass framework\" here.\r\n\r\nBy default, the JuliaSyntaxHighlighting is quite conservative:\r\n\r\n<img width=\"298\" height=\"226\" alt=\"image\" src=\"https://github.com/user-attachments/assets/64dbb301-17e1-4447-92ee-52906fb1fcc3\" />\r\n\r\nBut with a custom `faces.toml` file (as shown in the docs) you can fancy it up to your liking:\r\n\r\n<img width=\"294\" height=\"228\" alt=\"image\" src=\"https://github.com/user-attachments/assets/183539be-c4da-4d5d-92d4-ab46fae812b5\" />\r\n\r\nWIP Because of tests.\r\n\r\nWritten in a beautiful symbiosis between man and machine.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59778/reactions",
    "total_count": 25,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 18,
    "rocket": 7,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59778/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "e2ff10a08a8c847eca8f87f1956c187789ca3df8",
      "filename": "NEWS.md",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/NEWS.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f821b82e40c19972e464c96cf5dc1e2395917566/NEWS.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/NEWS.md?ref=f821b82e40c19972e464c96cf5dc1e2395917566",
      "patch": "@@ -97,6 +97,7 @@ Standard library changes\n #### REPL\n \n * The Julia REPL now support bracketed paste on Windows which should significantly speed up pasting large code blocks into the REPL ([#59825])\n+* The REPL now provides syntax highlighting for input as you type. See the REPL docs for more info about customization.\n * The display of `AbstractChar`s in the main REPL mode now includes LaTeX input information like what is shown in help mode ([#58181]).\n * Display of repeated frames and cycles in stack traces has been improved by bracketing them in the trace and treating them consistently ([#55841]).\n "
    },
    {
      "sha": "293d82334719bca8c25aef81a6fad4e57c776b83",
      "filename": "contrib/generate_precompile.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/contrib%2Fgenerate_precompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f821b82e40c19972e464c96cf5dc1e2395917566/contrib%2Fgenerate_precompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/contrib%2Fgenerate_precompile.jl?ref=f821b82e40c19972e464c96cf5dc1e2395917566",
      "patch": "@@ -41,6 +41,7 @@ precompile(Tuple{typeof(Base.Terminals.enable_bracketed_paste), Base.Terminals.T\n precompile(Tuple{typeof(Base.Terminals.width), Base.Terminals.TTYTerminal})\n precompile(Tuple{typeof(Base.Terminals.height), Base.Terminals.TTYTerminal})\n precompile(Tuple{typeof(Base.write), Base.Terminals.TTYTerminal, Array{UInt8, 1}})\n+precompile(Tuple{typeof(Base.isempty), Base.AnnotatedString{String}}\n \n # loading.jl - without these each precompile worker would precompile these because they're hit before pkgimages are loaded\n precompile(Base.__require, (Module, Symbol))"
    },
    {
      "sha": "47a386d867f0f38c7cd6bf2b49bb5f6ee6aa3ed4",
      "filename": "stdlib/REPL/docs/src/index.md",
      "status": "modified",
      "additions": 177,
      "deletions": 0,
      "changes": 177,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Fdocs%2Fsrc%2Findex.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Fdocs%2Fsrc%2Findex.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fdocs%2Fsrc%2Findex.md?ref=f821b82e40c19972e464c96cf5dc1e2395917566",
      "patch": "@@ -533,6 +533,183 @@ mmap(file::AbstractString, ::Type{T}, len::Integer) where T<:BitArray in Mmap at\n mmap(file::AbstractString, ::Type{T}, len::Integer, offset::Integer; grow, shared) where T<:BitArray in Mmap at Mmap/src/Mmap.jl:322\n ```\n \n+## Syntax Highlighting\n+\n+The REPL provides syntax highlighting for input as you type.\n+Syntax highlighting is enabled by default but can be disabled in your `~/.julia/config/startup.jl`:\n+\n+```julia\n+atreplinit() do repl\n+    repl.options.style_input = false\n+end\n+```\n+\n+### Customizing Syntax Highlighting Colors\n+\n+The default syntax highlighting theme is quite conservative but can be customized using a TOML file `faces.toml` (https://julialang.github.io/StyledStrings.jl/dev/#stdlib-styledstrings-face-toml) in `.julia/config` (or by explicitly loading the faces from a face toml file).\n+\n+\n+<details>\n+<summary>Example: Monokai color theme (click to expand)</summary>\n+\n+```toml\n+# Monokai color theme for Julia syntax highlighting\n+\n+[julia_macro]\n+foreground = \"#A6E22E\"\n+\n+[julia_symbol]\n+foreground = \"#AE81FF\"\n+\n+[julia_singleton_identifier]\n+inherit = \"julia_symbol\"\n+\n+[julia_type]\n+foreground = \"#66D9EF\"\n+\n+[julia_typedec]\n+foreground = \"#66D9EF\"\n+weight = \"bold\"\n+\n+[julia_comment]\n+foreground = \"#75715E\"\n+italic = true\n+\n+[julia_string]\n+foreground = \"#E6DB74\"\n+\n+[julia_regex]\n+inherit = \"julia_string\"\n+\n+[julia_backslash_literal]\n+foreground = \"#FD971F\"\n+inherit = \"julia_string\"\n+\n+[julia_string_delim]\n+foreground = \"#E6DB74\"\n+weight = \"bold\"\n+\n+[julia_cmdstring]\n+inherit = \"julia_string\"\n+\n+[julia_char]\n+inherit = \"julia_string\"\n+\n+[julia_char_delim]\n+inherit = \"julia_string_delim\"\n+\n+[julia_number]\n+foreground = \"#AE81FF\"\n+\n+[julia_bool]\n+foreground = \"#AE81FF\"\n+weight = \"bold\"\n+\n+[julia_funcall]\n+foreground = \"#A6E22E\"\n+\n+[julia_broadcast]\n+foreground = \"#F92672\"\n+weight = \"bold\"\n+\n+[julia_builtin]\n+foreground = \"#66D9EF\"\n+weight = \"bold\"\n+\n+[julia_operator]\n+foreground = \"#F92672\"\n+\n+[julia_comparator]\n+inherit = \"julia_operator\"\n+\n+[julia_assignment]\n+foreground = \"#F92672\"\n+weight = \"bold\"\n+\n+[julia_keyword]\n+foreground = \"#F92672\"\n+weight = \"bold\"\n+\n+[julia_parentheses]\n+foreground = \"#F8F8F2\"\n+\n+[julia_unpaired_parentheses]\n+background = \"#F92672\"\n+foreground = \"#F8F8F0\"\n+weight = \"bold\"\n+\n+[julia_error]\n+background = \"#F92672\"\n+foreground = \"#F8F8F0\"\n+\n+[julia_rainbow_paren_1]\n+foreground = \"#A6E22E\"\n+inherit = \"julia_parentheses\"\n+\n+[julia_rainbow_paren_2]\n+foreground = \"#66D9EF\"\n+inherit = \"julia_parentheses\"\n+\n+[julia_rainbow_paren_3]\n+foreground = \"#FD971F\"\n+inherit = \"julia_parentheses\"\n+\n+[julia_rainbow_paren_4]\n+inherit = \"julia_rainbow_paren_1\"\n+\n+[julia_rainbow_paren_5]\n+inherit = \"julia_rainbow_paren_2\"\n+\n+[julia_rainbow_paren_6]\n+inherit = \"julia_rainbow_paren_3\"\n+\n+# Rainbow brackets\n+[julia_rainbow_bracket_1]\n+foreground = \"#AE81FF\"\n+inherit = \"julia_parentheses\"\n+\n+[julia_rainbow_bracket_2]\n+foreground = \"#E6DB74\"\n+inherit = \"julia_parentheses\"\n+\n+[julia_rainbow_bracket_3]\n+inherit = \"julia_rainbow_bracket_1\"\n+\n+[julia_rainbow_bracket_4]\n+inherit = \"julia_rainbow_bracket_2\"\n+\n+[julia_rainbow_bracket_5]\n+inherit = \"julia_rainbow_bracket_1\"\n+\n+[julia_rainbow_bracket_6]\n+inherit = \"julia_rainbow_bracket_2\"\n+\n+# Rainbow curlies\n+[julia_rainbow_curly_1]\n+foreground = \"#F92672\"\n+inherit = \"julia_parentheses\"\n+\n+[julia_rainbow_curly_2]\n+foreground = \"#A6E22E\"\n+inherit = \"julia_parentheses\"\n+\n+[julia_rainbow_curly_3]\n+inherit = \"julia_rainbow_curly_1\"\n+\n+[julia_rainbow_curly_4]\n+inherit = \"julia_rainbow_curly_2\"\n+\n+[julia_rainbow_curly_5]\n+inherit = \"julia_rainbow_curly_1\"\n+\n+[julia_rainbow_curly_6]\n+inherit = \"julia_rainbow_curly_2\"\n+```\n+\n+</details>\n+\n+For a complete list of customizable faces, see the [JuliaSyntaxHighlighting package documentation](https://julialang.github.io/JuliaSyntaxHighlighting.jl/dev/).\n+\n ## Customizing Colors\n \n The colors used by Julia and the REPL can be customized, as well. To change the"
    },
    {
      "sha": "53cb5efe44d44edd25a33c6683507d193f6e103f",
      "filename": "stdlib/REPL/src/LineEdit.jl",
      "status": "modified",
      "additions": 74,
      "deletions": 22,
      "changes": 96,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FLineEdit.jl?ref=f821b82e40c19972e464c96cf5dc1e2395917566",
      "patch": "@@ -4,10 +4,13 @@ module LineEdit\n \n import ..REPL\n using ..REPL: AbstractREPL, Options\n+using ..REPL.StylingPasses: StylingPass, SyntaxHighlightPass, RegionHighlightPass, EnclosingParenHighlightPass, StylingContext, apply_styling_passes, merge_annotations\n \n using ..Terminals\n import ..Terminals: raw!, width, height, clear_line, beep\n \n+using StyledStrings\n+\n import Base: ensureroom, show, AnyDict, position\n using Base: something\n \n@@ -58,6 +61,7 @@ mutable struct Prompt <: TextInterface\n     on_done::Function\n     hist::HistoryProvider  # TODO?: rename this `hp` (consistency with other TextInterfaces), or is the type-assert useful for mode(s)?\n     sticky::Bool\n+    styling_passes::Vector{StylingPass}  # Styling passes to apply to input\n end\n \n show(io::IO, x::Prompt) = show(io, string(\"Prompt(\\\"\", prompt_string(x.prompt), \"\\\",...)\"))\n@@ -565,6 +569,8 @@ function maybe_show_hint(s::PromptState)\n     return nothing\n end\n \n+max_highlight_size::Int = 10000 # bytes\n+\n function refresh_multi_line(s::PromptState; kw...)\n     if s.refresh_wait !== nothing\n         close(s.refresh_wait)\n@@ -611,6 +617,42 @@ function refresh_multi_line(termbuf::TerminalBuffer, terminal::UnixTerminal, buf\n         reader isa Base.TTY && !Base.ispty(reader)::Bool\n     else false end\n \n+    # Get the styling passes from the prompt\n+    prompt_obj = nothing\n+    if prompt isa PromptState\n+        prompt_obj = prompt.p\n+    elseif prompt isa PrefixSearchState || prompt isa SearchState\n+        if isdefined(prompt, :parent) && prompt.parent isa Prompt\n+            prompt_obj = prompt.parent\n+        end\n+    end\n+\n+    styled_buffer = AnnotatedString(\"\")\n+    if buf.size > 0 && buf.size <= max_highlight_size\n+        full_input = String(buf.data[1:buf.size])\n+        if !isempty(full_input)\n+            passes = StylingPass[]\n+            context = StylingContext(buf_pos, regstart, regstop)\n+\n+            # Add prompt-specific styling passes if the prompt has them and styling is enabled\n+            enable_style_input = prompt_obj === nothing ? false :\n+                (isdefined(prompt_obj, :repl) && prompt_obj.repl !== nothing ?\n+                    prompt_obj.repl.options.style_input : false)\n+\n+            if enable_style_input && prompt_obj !== nothing\n+                append!(passes, prompt_obj.styling_passes)\n+            end\n+\n+            if region_active\n+                push!(passes, RegionHighlightPass())\n+            end\n+\n+            if !isempty(passes)\n+                styled_buffer = apply_styling_passes(full_input, passes, context)\n+            end\n+        end\n+    end\n+\n     # Now go through the buffer line by line\n     seek(buf, 0)\n     moreinput = true # add a blank line if there is a trailing newline on the last line\n@@ -636,12 +678,26 @@ function refresh_multi_line(termbuf::TerminalBuffer, terminal::UnixTerminal, buf\n         llength = textwidth(line)\n         slength = sizeof(line)\n         cur_row += 1\n-        # lwrite: what will be written to termbuf\n-        lwrite = region_active ? highlight_region(line, regstart, regstop, written, slength) :\n-                                 line\n+\n+        # Extract the portion of styled_buffer corresponding to this line.\n+        if !isempty(styled_buffer)\n+            # Calculate byte positions for this line in the buffer\n+            line_start_byte = written + 1\n+            line_end_byte = written + slength\n+\n+            # Convert to valid character indices (handles UTF-8 boundaries)\n+            start_idx = thisind(styled_buffer, line_start_byte)\n+            end_idx = thisind(styled_buffer, line_end_byte)\n+\n+            lwrite = @view styled_buffer[start_idx:end_idx]\n+        else\n+            lwrite = line\n+        end\n+\n         written += slength\n         cmove_col(termbuf, lindent + 1)\n-        write(termbuf, lwrite)\n+\n+        write(IOContext(termbuf, :color => hascolor(terminal)), lwrite)\n         # We expect to be line after the last valid output line (due to\n         # the '\\n' at the end of the previous line)\n         if curs_row == -1\n@@ -692,18 +748,6 @@ function refresh_multi_line(termbuf::TerminalBuffer, terminal::UnixTerminal, buf\n     return InputAreaState(cur_row, curs_row)\n end\n \n-function highlight_region(lwrite::Union{String,SubString{String}}, regstart::Int, regstop::Int, written::Int, slength::Int)\n-    if written <= regstop <= written+slength\n-        i = thisind(lwrite, regstop-written)\n-        lwrite = lwrite[1:i] * Base.disable_text_style[:reverse] * lwrite[nextind(lwrite, i):end]\n-    end\n-    if written <= regstart <= written+slength\n-        i = thisind(lwrite, regstart-written)\n-        lwrite = lwrite[1:i] * Base.text_colors[:reverse] * lwrite[nextind(lwrite, i):end]\n-    end\n-    return lwrite\n-end\n-\n function refresh_multi_line(terminal::UnixTerminal, args...; kwargs...)\n     outbuf = IOBuffer()\n     termbuf = TerminalBuffer(outbuf)\n@@ -999,7 +1043,9 @@ function edit_insert(s::PromptState, c::StringLike)\n         offset += position(buf) - beginofline(buf) # size of current line\n         spinner = '\\0'\n         delayup = !eof(buf) || old_wait\n-        if offset + textwidth(str) <= w && !(after == 0 && delayup)\n+        # Disable fast path when syntax highlighting is enabled\n+        use_fast_path = offset + textwidth(str) <= w && !(after == 0 && delayup) && !options(s).style_input\n+        if use_fast_path\n             # Avoid full update when appending characters to the end\n             # and an update of curs_row isn't necessary (conservatively estimated)\n             write(termbuf, str)\n@@ -2226,6 +2272,13 @@ function replace_line(s::PrefixSearchState, l::Union{String,SubString{String}})\n     nothing\n end\n \n+function write_prompt(terminal, s::SearchState, color::Bool)\n+    failed = s.failed ? \"failed \" : \"\"\n+    promptstr = s.backward ? \"($(failed)reverse-i-search)`\" : \"($(failed)forward-i-search)`\"\n+    write(terminal, promptstr)\n+    return textwidth(promptstr)\n+end\n+\n function refresh_multi_line(termbuf::TerminalBuffer, s::SearchState)\n     buf = IOBuffer()\n     unsafe_write(buf, pointer(s.query_buffer.data), s.query_buffer.ptr-1)\n@@ -2236,9 +2289,7 @@ function refresh_multi_line(termbuf::TerminalBuffer, s::SearchState)\n     write(buf, read(s.response_buffer, String))\n     buf.ptr = offset + ptr - 1\n     s.response_buffer.ptr = ptr\n-    failed = s.failed ? \"failed \" : \"\"\n-    ias = refresh_multi_line(termbuf, s.terminal, buf, s.ias,\n-                             s.backward ? \"($(failed)reverse-i-search)`\" : \"($(failed)forward-i-search)`\")\n+    ias = refresh_multi_line(termbuf, s.terminal, buf, s.ias, s)\n     s.ias = ias\n     return ias\n end\n@@ -2823,10 +2874,11 @@ function Prompt(prompt\n     on_enter = default_enter_cb,\n     on_done = ()->nothing,\n     hist = EmptyHistoryProvider(),\n-    sticky = false)\n+    sticky = false,\n+    styling_passes = StylingPass[])\n \n     return Prompt(prompt, prompt_prefix, prompt_suffix, output_prefix, output_prefix_prefix, output_prefix_suffix,\n-                   keymap_dict, repl, complete, on_enter, on_done, hist, sticky)\n+                   keymap_dict, repl, complete, on_enter, on_done, hist, sticky, styling_passes)\n end\n \n run_interface(::Prompt) = nothing"
    },
    {
      "sha": "f1f23ab1c382d166d92ae5f72cb85c226c6f80e7",
      "filename": "stdlib/REPL/src/REPL.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPL.jl?ref=f821b82e40c19972e464c96cf5dc1e2395917566",
      "patch": "@@ -66,6 +66,8 @@ using Base.Terminals\n abstract type AbstractREPL end\n \n include(\"options.jl\")\n+include(\"StylingPasses.jl\")\n+using .StylingPasses\n \n include(\"LineEdit.jl\")\n using .LineEdit\n@@ -1329,7 +1331,11 @@ function setup_interface(\n             (repl.envcolors ? Base.input_color : repl.input_color) : \"\",\n         repl = repl,\n         complete = replc,\n-        on_enter = return_callback)\n+        on_enter = return_callback,\n+        styling_passes = StylingPasses.StylingPass[\n+            StylingPasses.SyntaxHighlightPass(),\n+            StylingPasses.EnclosingParenHighlightPass()\n+        ])\n \n     # Setup help mode\n     help_mode = Prompt(contextual_prompt(repl, HELP_PROMPT),"
    },
    {
      "sha": "d3558dd925b29bd18563e2e477cd3e9bbecc9637",
      "filename": "stdlib/REPL/src/StylingPasses.jl",
      "status": "added",
      "additions": 165,
      "deletions": 0,
      "changes": 165,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Fsrc%2FStylingPasses.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Fsrc%2FStylingPasses.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FStylingPasses.jl?ref=f821b82e40c19972e464c96cf5dc1e2395917566",
      "patch": "@@ -0,0 +1,165 @@\n+# This file is a part of Julia. License is MIT: https://julialang.org/license\n+\n+# Each pass takes the input string and returns an AnnotatedString with styling annotations\n+\n+module StylingPasses\n+\n+using StyledStrings\n+using StyledStrings: Face\n+using JuliaSyntaxHighlighting\n+import Base: AnnotatedString, annotate!, annotations, JuliaSyntax\n+\n+export StylingPass, StylingContext, SyntaxHighlightPass, RegionHighlightPass,\n+       EnclosingParenHighlightPass, apply_styling_passes, merge_annotations\n+\n+# Context information passed to all styling passes\n+struct StylingContext\n+    cursor_pos::Int\n+    region_start::Int\n+    region_stop::Int\n+end\n+\n+StylingContext(cursor_pos::Int) = StylingContext(cursor_pos, 0, 0)\n+\n+abstract type StylingPass end\n+\n+function merge_annotations(annotated_strings::Vector{<:AnnotatedString})\n+    isempty(annotated_strings) && return AnnotatedString(\"\")\n+\n+    result = AnnotatedString(annotated_strings[1])\n+\n+    for source in annotated_strings\n+        for ann in annotations(source)\n+            annotate!(result, ann.region, ann.label, ann.value)\n+        end\n+    end\n+\n+    return result\n+end\n+\n+function apply_style(pass::StylingPass, input::String, context::StylingContext)\n+    return pass(input, context)::AnnotatedString{String}\n+end\n+\n+function apply_styling_passes(input::String, passes::Vector{StylingPass}, context::StylingContext)\n+    if isempty(passes)\n+        return AnnotatedString(input)\n+    end\n+\n+    results = [apply_style(pass, input, context) for pass in passes]\n+    return merge_annotations(results)\n+end\n+\n+# Applies Julia syntax highlighting\n+struct SyntaxHighlightPass <: StylingPass end\n+\n+function (::SyntaxHighlightPass)(input::String, ::StylingContext)\n+    try\n+        return JuliaSyntaxHighlighting.highlight(input)\n+    catch e\n+        e isa InterruptException && rethrow()\n+        @error \"Error in SyntaxHighlightPass\" exception=(e, catch_backtrace()) maxlog=1\n+        return AnnotatedString(input)\n+    end\n+end\n+\n+# Applies inverse video styling to the selected region\n+struct RegionHighlightPass <: StylingPass end\n+\n+function (::RegionHighlightPass)(input::String, context::StylingContext)\n+    result = AnnotatedString(input)\n+\n+    if context.region_start > 0 && context.region_stop >= context.region_start\n+        # Add inverse face to the region\n+        # Region positions are 1-based byte positions\n+        region_range = context.region_start:context.region_stop\n+        annotate!(result, region_range, :face, Face(inverse=true))\n+    end\n+\n+    return result\n+end\n+\n+# Applies bold styling to parentheses that enclose the cursor position\n+struct EnclosingParenHighlightPass <: StylingPass\n+    face::Face\n+end\n+\n+EnclosingParenHighlightPass() = EnclosingParenHighlightPass(Face(weight=:bold, underline=true))\n+\n+function (pass::EnclosingParenHighlightPass)(input::String, context::StylingContext)\n+    result = AnnotatedString(input)\n+\n+    if isempty(input) || context.cursor_pos < 1\n+        return result\n+    end\n+\n+    try\n+        ast = JuliaSyntax.parseall(JuliaSyntax.GreenNode, input; ignore_errors=true)\n+        paren_pairs = find_enclosing_parens(input, ast, context.cursor_pos)\n+\n+        for (open_pos, close_pos) in paren_pairs\n+            annotate!(result, open_pos:open_pos, :face, pass.face)\n+            annotate!(result, close_pos:close_pos, :face, pass.face)\n+        end\n+    catch e\n+        e isa InterruptException && rethrow()\n+        @error \"Error in EnclosingParenHighlightPass\" exception=(e, catch_backtrace()) maxlog=1\n+    end\n+\n+    return result\n+end\n+\n+function paren_type(k)\n+    if     k == JuliaSyntax.K\"(\";  1, :paren\n+    elseif k == JuliaSyntax.K\")\"; -1, :paren\n+    elseif k == JuliaSyntax.K\"[\";  1, :bracket\n+    elseif k == JuliaSyntax.K\"]\"; -1, :bracket\n+    elseif k == JuliaSyntax.K\"{\";  1, :curly\n+    elseif k == JuliaSyntax.K\"}\"; -1, :curly\n+    else                           0, :none\n+    end\n+end\n+\n+function find_enclosing_parens(content::String, ast, cursor_pos::Int)\n+    innermost_pairs = Dict{Symbol,Tuple{Int,Int}}()\n+    paren_stack = Tuple{Int,Int,Symbol}[]  # (open_pos, depth, type)\n+\n+    walk_tree(ast, content, 0) do node, offset\n+        nkind = JuliaSyntax.kind(node)\n+        pos = firstindex(content) + offset\n+\n+        depthchange, ptype = paren_type(nkind)\n+\n+        if ptype != :none\n+            if depthchange > 0\n+                # Opening paren - push to stack\n+                push!(paren_stack, (pos, length(paren_stack) + 1, ptype))\n+            elseif depthchange < 0 && !isempty(paren_stack)\n+                # Closing paren - pop from stack and check if cursor is inside\n+                open_pos, depth, open_ptype = pop!(paren_stack)\n+                if open_ptype == ptype && open_pos <= cursor_pos < pos\n+                    # Cursor is inside this paren pair - keep only innermost per type\n+                    # Only update if this is the first pair or if it's smaller (more inner) than existing\n+                    if !haskey(innermost_pairs, ptype) || (pos - open_pos) < (innermost_pairs[ptype][2] - innermost_pairs[ptype][1])\n+                        innermost_pairs[ptype] = (open_pos, pos)\n+                    end\n+                end\n+            end\n+        end\n+    end\n+\n+    return collect(values(innermost_pairs))\n+end\n+\n+function walk_tree(f::Function, node, content::String, offset::Int)\n+    f(node, offset)\n+\n+    if JuliaSyntax.numchildren(node) > 0\n+        for child in JuliaSyntax.children(node)\n+            walk_tree(f, child, content, offset)\n+            offset += JuliaSyntax.span(child)\n+        end\n+    end\n+end\n+\n+end # module StylingPasses"
    },
    {
      "sha": "fa46c49243bfde0dd459486d098fdfe54285b233",
      "filename": "stdlib/REPL/src/options.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Fsrc%2Foptions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Fsrc%2Foptions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2Foptions.jl?ref=f821b82e40c19972e464c96cf5dc1e2395917566",
      "patch": "@@ -28,6 +28,7 @@ mutable struct Options\n     # refresh after time delay\n     auto_refresh_time_delay::Float64\n     hint_tab_completes::Bool\n+    style_input::Bool # enable syntax highlighting for input\n     # default IOContext settings at the REPL\n     iocontext::Dict{Symbol,Any}\n end\n@@ -49,6 +50,7 @@ Options(;\n         auto_indent_time_threshold = 0.005,\n         auto_refresh_time_delay = 0.0, # this no longer seems beneficial\n         hint_tab_completes = true,\n+        style_input = true,\n         iocontext = Dict{Symbol,Any}()) =\n             Options(hascolor, extra_keymap, tabwidth,\n                     kill_ring_max, region_animation_duration,\n@@ -57,7 +59,7 @@ Options(;\n                     backspace_align, backspace_adjust, confirm_exit,\n                     auto_indent, auto_indent_tmp_off, auto_indent_bracketed_paste,\n                     auto_indent_time_threshold, auto_refresh_time_delay,\n-                    hint_tab_completes,\n+                    hint_tab_completes, style_input,\n                     iocontext)\n \n # for use by REPLs not having an options field"
    },
    {
      "sha": "3d8d75004eaa0f46827fbd627a741edb6c3d3712",
      "filename": "stdlib/REPL/test/repl.jl",
      "status": "modified",
      "additions": 123,
      "deletions": 3,
      "changes": 126,
      "blob_url": "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Ftest%2Frepl.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib%2FREPL%2Ftest%2Frepl.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Ftest%2Frepl.jl?ref=f821b82e40c19972e464c96cf5dc1e2395917566",
      "patch": "@@ -67,7 +67,7 @@ end\n #end\n \n # REPL tests\n-function fake_repl(@nospecialize(f); options::REPL.Options=REPL.Options(confirm_exit=false))\n+function fake_repl(@nospecialize(f); options::REPL.Options=REPL.Options(confirm_exit=false,style_input=false))\n     # Use pipes so we can easily do blocking reads\n     # In the future if we want we can add a test that the right object\n     # gets displayed by intercepting the display\n@@ -121,7 +121,7 @@ end\n # in the mix. If verification needs to be done, keep it to the bare minimum. Basically\n # this should make sure nothing crashes without depending on how exactly the control\n # characters are being used.\n-fake_repl(options = REPL.Options(confirm_exit=false,hascolor=true)) do stdin_write, stdout_read, repl\n+fake_repl(options = REPL.Options(confirm_exit=false,hascolor=true,style_input=false)) do stdin_write, stdout_read, repl\n     repl.specialdisplay = REPL.REPLDisplay(repl)\n     repl.history_file = false\n \n@@ -1893,7 +1893,7 @@ fake_repl() do stdin_write, stdout_read, repl\n     Base.wait(repltask)\n end\n ## hints disabled\n-fake_repl(options=REPL.Options(confirm_exit=false,hascolor=true,hint_tab_completes=false)) do stdin_write, stdout_read, repl\n+fake_repl(options=REPL.Options(confirm_exit=false,hascolor=true,hint_tab_completes=false,style_input=false)) do stdin_write, stdout_read, repl\n     repltask = @async begin\n         REPL.run_repl(repl)\n     end\n@@ -2029,3 +2029,123 @@ end\n     @test occursin(\"'+': ASCII/Unicode U+002B (category Sm: Symbol, math)\", output)\n     @test !occursin(\", input as \", output)\n end\n+\n+# Test syntax highlighting in REPL input\n+@testset \"Syntax highlighting\" begin\n+    using StyledStrings\n+    using REPL.StylingPasses\n+\n+    # Use withfaces to ensure consistent face definitions regardless of user config\n+    StyledStrings.withfaces(:julia_keyword => StyledStrings.Face(foreground=:red),\n+                            :julia_number => StyledStrings.Face(foreground=:blue)) do\n+\n+        # Test that julia_prompt has syntax highlighting passes\n+        fake_repl(options = REPL.Options(confirm_exit=false, style_input=true)) do stdin_write, stdout_read, repl\n+            repl.interface = REPL.setup_interface(repl)\n+            julia_prompt = repl.interface.modes[1]\n+            shell_mode = repl.interface.modes[3]\n+\n+            # Julia prompt should have syntax highlighting passes\n+            @test length(julia_prompt.styling_passes) == 2\n+            @test any(p -> p isa StylingPasses.SyntaxHighlightPass, julia_prompt.styling_passes)\n+            @test any(p -> p isa StylingPasses.EnclosingParenHighlightPass, julia_prompt.styling_passes)\n+\n+            # Shell mode should not have syntax highlighting passes\n+            @test length(shell_mode.styling_passes) == 0\n+\n+            # Test that syntax highlighting is actually applied\n+            repltask = @async begin\n+                REPL.run_repl(repl)\n+            end\n+\n+            # Test 1: Simple keyword highlighting\n+            write(stdin_write, \"function\")\n+            s = readuntil(stdout_read, \"function\", keep=true)\n+            # The keyword \"function\" should be styled (have escape code before it)\n+            # Look for \"function\" that appears after the prompt, not just anywhere\n+            # Extract just the input portion after \"julia> \"\n+            input_part = split(s, \"julia> \", keepempty=false)\n+            if !isempty(input_part)\n+                input_text = input_part[end]\n+                # If syntax highlighting is working, \"function\" will have an escape code before it\n+                # like \\e[31mfunction or similar\n+                @test occursin(r\"\\e\\[[0-9;]*m.*function\", input_text)\n+            end\n+            write(stdin_write, \"\\x03\")  # Ctrl-C to cancel\n+\n+            # Test 2: Unicode identifiers with syntax highlighting\n+            readuntil(stdout_read, \"julia> \")\n+            write(stdin_write, \"function \u03b1\u03b2(a, \u03b2)\")\n+            s = readuntil(stdout_read, \"\u03b2)\", keep=true)\n+            # Should highlight \"function\" keyword even with unicode following\n+            input_part = split(s, \"julia> \", keepempty=false)\n+            if !isempty(input_part)\n+                input_text = input_part[end]\n+                # Keyword should be styled\n+                @test occursin(r\"\\e\\[[0-9;]*m.*function\", input_text)\n+            end\n+            # Unicode should be preserved (may have ANSI codes interleaved, so check separately)\n+            @test occursin(\"\u03b1\", s)\n+            @test occursin(\"\u03b2\", s)\n+            @test occursin(\"(\", s)\n+            @test occursin(\")\", s)\n+            write(stdin_write, \"\\x03\")  # Ctrl-C to cancel\n+\n+            # Test 3: Multi-line input with syntax highlighting\n+            readuntil(stdout_read, \"julia> \")\n+            write(stdin_write, \"begin\\n\")\n+            readuntil(stdout_read, \"begin\")\n+            write(stdin_write, \"    local test_var_for_highlighting = 42\\n\")\n+            s = readuntil(stdout_read, \"42\", keep=true)\n+            # Should contain highlighting - the \"local\" keyword should be styled\n+            @test occursin(r\"\\e\\[[0-9;]*m.*local\", s)\n+            write(stdin_write, \"\\x03\")  # Ctrl-C to cancel before executing\n+            # Don't execute to avoid polluting Main module\n+\n+            # Test 4: Bracket highlighting (paren matching)\n+            readuntil(stdout_read, \"julia> \")\n+            write(stdin_write, \"(1 + (2 * 3))\")\n+            # Move cursor to be inside the inner parens: between 2 and *\n+            # Current position is at end: (1 + (2 * 3))|\n+            # Move left 5 times to get to: (1 + (2| * 3))\n+            for _ in 1:5\n+                write(stdin_write, \"\\e[D\")  # Left arrow\n+            end\n+            # Give it a moment to process and re-render\n+            sleep(0.1)\n+            # Now write a character to trigger re-render and capture output\n+            write(stdin_write, \" \")\n+            s = readuntil(stdout_read, \" \", keep=true)\n+            # The enclosing parens around \"2 * 3\" should be highlighted with bold/underline\n+            # We can't easily test the exact positioning, but we can verify that\n+            # there are ANSI codes for bold (\\e[1m) or underline (\\e[4m) present\n+            @test occursin(r\"\\e\\[[0-9;]*[14]m\", s)  # Contains bold or underline codes\n+            write(stdin_write, \"\\x03\")  # Ctrl-C to cancel\n+\n+            write(stdin_write, '\\x04')  # Exit\n+            Base.wait(repltask)\n+        end\n+\n+        # Test that syntax highlighting can be disabled\n+        fake_repl(options = REPL.Options(confirm_exit=false, style_input=false)) do stdin_write, stdout_read, repl\n+            repl.interface = REPL.setup_interface(repl)\n+\n+            repltask = @async begin\n+                REPL.run_repl(repl)\n+            end\n+\n+            # Even though the prompt has styling passes, they shouldn't be applied\n+            write(stdin_write, \"function\")\n+            s = readuntil(stdout_read, \"function\", keep=true)\n+            # With style_input=false, there should be no color codes from syntax highlighting\n+            # (there may still be prompt color codes, but not within the input text)\n+            lines = split(s, '\\n')\n+            # The last line should contain just \"function\" without color codes around it\n+            @test occursin(\"function\", s)\n+\n+            write(stdin_write, \"\\x03\")  # Ctrl-C to cancel\n+            write(stdin_write, '\\x04')  # Exit\n+            Base.wait(repltask)\n+        end\n+    end\n+end"
    }
  ]
}