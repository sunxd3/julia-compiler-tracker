{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59413",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59413/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59413/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59413/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59413",
  "id": 3360253345,
  "node_id": "PR_kwDOABkWpM6lpZ7S",
  "number": 59413,
  "title": "inference: reinfer and track missing code for inlining",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 421532175,
      "node_id": "MDU6TGFiZWw0MjE1MzIxNzU=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:inference",
      "name": "compiler:inference",
      "color": "bfdadc",
      "default": false,
      "description": "Type inference"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 13,
  "created_at": "2025-08-27T17:32:42Z",
  "updated_at": "2025-11-10T18:56:40Z",
  "closed_at": "2025-11-10T18:56:38Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59413",
    "html_url": "https://github.com/JuliaLang/julia/pull/59413",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59413.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59413.patch",
    "merged_at": "2025-11-10T18:56:38Z"
  },
  "body": "When code is potentially needed for inlining, but missing for any reason, be sure to regenerate it during inference with the correct `ci_meets_requirement` flags (SOURCE_MODE_GET_SOURCE instead of NOT_REQUIRED) so it is prepared for the optimizer if needed.\r\n\r\nThis was supposed to be the correct fix for someone else's bug with missing inlining when expected, but I don't remember what bug it was anymore.\r\n\r\n```\r\njulia> @atomic Base.method_instance(promote, (Float64,Int)).cache.inferred = 0x22\r\n0x22\r\n\r\njulia> @code_typed 1.0+1\r\nCodeInfo(\r\n    @ promotion.jl:433 within `+`\r\n1 \u2500 %1 =    invoke Base.promote(x::Float64, y::Int64)::Tuple{Float64, Float64}\r\n\u2502   %2 =   builtin Core.getfield(%1, 1)::Float64\r\n\u2502   %3 =   builtin Core.getfield(%1, 2)::Float64\r\n\u2502   @ promotion.jl:433 within `+` @ float.jl:492\r\n\u2502   %4 = intrinsic Base.add_float(%2, %3)::Float64\r\n\u2514\u2500\u2500      return %4\r\n) => Float64\r\n```\r\n\r\nFixes https://github.com/JuliaLang/julia/issues/59846",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59413/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59413/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "1728965e3702c9990398080768f73e23f56d5c70",
      "filename": "Compiler/src/abstractinterpretation.jl",
      "status": "modified",
      "additions": 111,
      "deletions": 102,
      "changes": 213,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fabstractinterpretation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fabstractinterpretation.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -53,6 +53,7 @@ end\n struct MethodMatchTarget\n     match::MethodMatch\n     edges::Vector{Union{Nothing,CodeInstance}}\n+    call_results::Vector{Union{Nothing,InferredCallResult}}\n     edge_idx::Int\n end\n \n@@ -93,17 +94,15 @@ mutable struct CallInferenceState\n     rettype\n     exctype\n     all_effects::Effects\n-    const_results::Union{Nothing,Vector{Union{Nothing,ConstResult}}} # keeps the results of inference with the extended lattice elements (if happened)\n     conditionals::Union{Nothing,Tuple{Vector{Any},Vector{Any}}} # keeps refinement information of call argument types when the return type is boolean\n     slotrefinements::Union{Nothing,Vector{Any}} # keeps refinement information on slot types obtained from call signature\n \n     # some additional fields for untyped objects (just to avoid capturing)\n-    func\n-    matches::Union{MethodMatches,UnionSplitMethodMatches}\n+    const func\n+    const matches::Union{MethodMatches,UnionSplitMethodMatches}\n     function CallInferenceState(@nospecialize(func), matches::Union{MethodMatches,UnionSplitMethodMatches})\n         return new(#=inferidx=#1, #=rettype=#Bottom, #=exctype=#Bottom, #=all_effects=#EFFECTS_TOTAL,\n-            #=const_results=#nothing, #=conditionals=#nothing, #=slotrefinements=#nothing,\n-            func, matches)\n+            #=conditionals=#nothing, #=slotrefinements=#nothing, func, matches)\n     end\n end\n \n@@ -124,7 +123,7 @@ function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(fun\n     end\n \n     (; valid_worlds, applicable) = matches\n-    update_valid_age!(sv, valid_worlds) # need to record the negative world now, since even if we don't generate any useful information, inlining might want to add an invoke edge and it won't have this information anymore\n+    update_valid_age!(sv, get_inference_world(interp), valid_worlds) # need to record the negative world now, since even if we don't generate any useful information, inlining might want to add an invoke edge and it won't have this information anymore\n     if bail_out_toplevel_call(interp, sv)\n         local napplicable = length(applicable)\n         for i = 1:napplicable\n@@ -146,7 +145,7 @@ function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(fun\n         local napplicable = length(applicable)\n         local multiple_matches = napplicable > 1\n         while state.inferidx <= napplicable\n-            (; match, edges, edge_idx) = applicable[state.inferidx]\n+            (; match, edges, call_results, edge_idx) = applicable[state.inferidx]\n             local method = match.method\n             local sig = match.spec_types\n             if bail_out_call(interp, InferenceLoopState(state.rettype, state.all_effects), sv)\n@@ -166,7 +165,7 @@ function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(fun\n             #end\n             mresult = abstract_call_method(interp, method, sig, match.sparams, multiple_matches, si, sv)::Future\n             function handle1(interp, sv)\n-                local (; rt, exct, effects, edge, volatile_inf_result) = mresult[]\n+                local (; rt, exct, effects, edge, call_result) = mresult[]\n                 this_conditional = ignorelimited(rt)\n                 this_rt = widenwrappedconditional(rt)\n                 this_exct = exct\n@@ -177,11 +176,10 @@ function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(fun\n                 this_arginfo = ArgInfo(arginfo.fargs, this_argtypes)\n                 const_call_result = abstract_call_method_with_const_args(interp,\n                     mresult[], state.func, this_arginfo, si, match, sv)\n-                const_result = volatile_inf_result\n                 if const_call_result !== nothing\n                     this_const_conditional = ignorelimited(const_call_result.rt)\n                     this_const_rt = widenwrappedconditional(const_call_result.rt)\n-                    const_edge = nothing\n+                    const_result = const_edge = nothing\n                     if this_const_rt \u2291\u209a this_rt\n                         # As long as the const-prop result we have is not *worse* than\n                         # what we found out on types, we'd like to use it. Even if the\n@@ -208,18 +206,14 @@ function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(fun\n                     end\n                     if const_edge !== nothing\n                         edge = const_edge\n-                        update_valid_age!(sv, world_range(const_edge))\n+                        update_valid_age!(sv, get_inference_world(interp), world_range(const_edge))\n+                    end\n+                    if const_result !== nothing\n+                        call_result = const_result\n                     end\n                 end\n \n                 state.all_effects = merge_effects(state.all_effects, effects)\n-                if const_result !== nothing\n-                    local const_results = state.const_results\n-                    if const_results === nothing\n-                        const_results = state.const_results = fill!(Vector{Union{Nothing,ConstResult}}(undef, napplicable), nothing)\n-                    end\n-                    const_results[state.inferidx] = const_result\n-                end\n                 @assert !(this_conditional isa Conditional || this_rt isa MustAlias) \"invalid lattice element returned from inter-procedural context\"\n                 if can_propagate_conditional(this_conditional, argtypes)\n                     # The only case where we need to keep this in rt is where\n@@ -245,6 +239,7 @@ function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(fun\n                     end\n                 end\n                 edges[edge_idx] = edge\n+                call_results[edge_idx] = call_result\n \n                 state.inferidx += 1\n                 return true\n@@ -260,11 +255,6 @@ function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(fun\n         seenall = state.inferidx > napplicable\n         retinfo = state.matches.info\n         if seenall # small optimization to skip some work that is already implied\n-            local const_results = state.const_results\n-            if const_results !== nothing\n-                @assert napplicable == nmatches(retinfo) == length(const_results)\n-                retinfo = ConstCallInfo(retinfo, const_results)\n-            end\n             if !fully_covering(state.matches) || any_ambig(state.matches)\n                 # Account for the fact that we may encounter a MethodError with a non-covered or ambiguous signature.\n                 state.all_effects = Effects(state.all_effects; nothrow=false)\n@@ -297,7 +287,6 @@ function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(fun\n             # there is unanalyzed candidate, widen type and effects to the top\n             state.rettype = state.exctype = Any\n             state.all_effects = Effects()\n-            state.const_results = nothing\n         end\n \n         # Also considering inferring the compilation signature for this method, so\n@@ -309,12 +298,13 @@ function abstract_call_gf_by_type(interp::AbstractInterpreter, @nospecialize(fun\n                 local napplicable = length(applicable)\n                 local multiple_matches = napplicable > 1\n                 while inferidx[] <= napplicable\n-                    (; match) = applicable[inferidx[]]\n+                    (; match, call_results, edge_idx) = applicable[inferidx[]]\n                     inferidx[] += 1\n                     local method = match.method\n                     local sig = match.spec_types\n                     mi = specialize_method(match; preexisting=true)\n-                    if mi === nothing || !const_prop_methodinstance_heuristic(interp, mi, arginfo, sv)\n+                    local call_result = call_results[edge_idx]\n+                    if mi === nothing || !(call_result isa InferenceResult) || !const_prop_methodinstance_heuristic(interp, call_result, mi, arginfo, sv)\n                         csig = get_compileable_sig(method, sig, match.sparams)\n                         if csig !== nothing && (!seenall || csig !== sig) # corresponds to whether the first look already looked at this, so repeating abstract_call_method is not useful\n                             #println(sig, \" changed to \", csig, \" for \", method)\n@@ -373,7 +363,7 @@ function find_union_split_method_matches(interp::AbstractInterpreter, argtypes::\n         thisinfo = MethodMatchInfo(thismatches, mt, sig_n, thisfullmatch)\n         push!(infos, thisinfo)\n         for idx = 1:length(thismatches)\n-            push!(applicable, MethodMatchTarget(thismatches[idx], thisinfo.edges, idx))\n+            push!(applicable, MethodMatchTarget(thismatches[idx], thisinfo.edges, thisinfo.call_results, idx))\n             push!(applicable_argtypes, arg_n)\n         end\n     end\n@@ -392,7 +382,7 @@ function find_simple_method_matches(interp::AbstractInterpreter, @nospecialize(a\n     fullmatch = any(match::MethodMatch->match.fully_covers, matches)\n     mt = Core.methodtable\n     info = MethodMatchInfo(matches, mt, atype, fullmatch)\n-    applicable = MethodMatchTarget[MethodMatchTarget(matches[idx], info.edges, idx) for idx = 1:length(matches)]\n+    applicable = MethodMatchTarget[MethodMatchTarget(matches[idx], info.edges, info.call_results, idx) for idx = 1:length(matches)]\n     return MethodMatches(applicable, info, matches.valid_worlds)\n end\n \n@@ -835,11 +825,11 @@ struct MethodCallResult\n     edge::Union{Nothing,CodeInstance}\n     edgecycle::Bool\n     edgelimited::Bool\n-    volatile_inf_result::Union{Nothing,VolatileInferenceResult}\n+    call_result::Union{Nothing,InferredCallResult}\n     function MethodCallResult(@nospecialize(rt), @nospecialize(exct), effects::Effects,\n                               edge::Union{Nothing,CodeInstance}, edgecycle::Bool, edgelimited::Bool,\n-                              volatile_inf_result::Union{Nothing,VolatileInferenceResult}=nothing)\n-        return new(rt, exct, effects, edge, edgecycle, edgelimited, volatile_inf_result)\n+                              call_result::Union{Nothing,InferredCallResult} = nothing)\n+        return new(rt, exct, effects, edge, edgecycle, edgelimited, call_result)\n     end\n end\n \n@@ -851,12 +841,12 @@ end\n struct ConstCallResult\n     rt::Any\n     exct::Any\n-    const_result::ConstResult\n+    const_result::InferredCallResult\n     effects::Effects\n     const_edge::Union{Nothing,CodeInstance}\n     function ConstCallResult(\n         @nospecialize(rt), @nospecialize(exct),\n-        const_result::ConstResult, effects::Effects,\n+        const_result::InferredCallResult, effects::Effects,\n         const_edge::Union{Nothing,CodeInstance})\n         return new(rt, exct, const_result, effects, const_edge)\n     end\n@@ -1058,7 +1048,9 @@ function maybe_get_const_prop_profitable(interp::AbstractInterpreter,\n         return nothing\n     end\n     mi = mi::MethodInstance\n-    if !force && !const_prop_methodinstance_heuristic(interp, mi, arginfo, sv)\n+    inf_result = result.call_result\n+    inf_result = inf_result isa InferenceResult ? inf_result : nothing\n+    if !force && !const_prop_methodinstance_heuristic(interp, inf_result, mi, arginfo, sv)\n         add_remark!(interp, sv, \"[constprop] Disabled by method instance heuristic\")\n         return nothing\n     end\n@@ -1212,7 +1204,7 @@ end\n # where we would spend a lot of time, but are probably unlikely to get an improved\n # result anyway.\n function const_prop_methodinstance_heuristic(interp::AbstractInterpreter,\n-    mi::MethodInstance, arginfo::ArgInfo, sv::AbsIntState)\n+    inf_result::Union{InferenceResult,Nothing}, mi::MethodInstance, arginfo::ArgInfo, sv::AbsIntState)\n     method = mi.def::Method\n     if method.is_for_opaque_closure\n         # Not inlining an opaque closure can be very expensive, so be generous\n@@ -1242,9 +1234,8 @@ function const_prop_methodinstance_heuristic(interp::AbstractInterpreter,\n         # was able to cut it down to something simple (inlineable in particular).\n         # If so, there will be a good chance we might be able to const prop\n         # all the way through and learn something new.\n-        code = get(code_cache(interp), mi, nothing)\n-        if isa(code, CodeInstance)\n-            inferred = @atomic :monotonic code.inferred\n+        if inf_result isa InferenceResult\n+            inferred = inf_result.src\n             # TODO propagate a specific `CallInfo` that conveys information about this call\n             if src_inlining_policy(interp, mi, inferred, NoCallInfo(), IR_FLAG_NULL)\n                 return true\n@@ -1256,42 +1247,42 @@ end\n \n function semi_concrete_eval_call(interp::AbstractInterpreter,\n     mi::MethodInstance, result::MethodCallResult, arginfo::ArgInfo, sv::AbsIntState)\n-    world = frame_world(sv)\n-    mi_cache = WorldView(code_cache(interp), world)\n-    codeinst = get(mi_cache, mi, nothing)\n-    if codeinst !== nothing\n-        irsv = IRInterpretationState(interp, codeinst, mi, arginfo.argtypes, world)\n-        if irsv !== nothing\n-            assign_parentchild!(irsv, sv)\n-            rt, (nothrow, noub) = ir_abstract_constant_propagation(interp, irsv)\n-            @assert !(rt isa Conditional || rt isa MustAlias) \"invalid lattice element returned from irinterp\"\n-            if !(isa(rt, Type) && hasintersect(rt, Bool))\n-                ir = irsv.ir\n-                # TODO (#48913) enable double inlining pass when there are any calls\n-                # that are newly resolved by irinterp\n-                # state = InliningState(interp)\n-                # ir = ssa_inlining_pass!(irsv.ir, state, propagate_inbounds(irsv))\n-                effects = result.effects\n-                if nothrow\n-                    effects = Effects(effects; nothrow=true)\n-                end\n-                if noub\n-                    effects = Effects(effects; noub=ALWAYS_TRUE)\n-                end\n-                exct = refine_exception_type(result.exct, effects)\n-                semi_concrete_result = SemiConcreteResult(codeinst, ir, effects, spec_info(irsv))\n-                const_edge = nothing # TODO use the edges from irsv?\n-                return ConstCallResult(rt, exct, semi_concrete_result, effects, const_edge)\n-            end\n-        end\n-    end\n-    return nothing\n+    call_result = result.call_result\n+    call_result isa InferenceResult || return nothing\n+    codeinst = call_result.ci\n+    codeinst isa CodeInstance || return nothing\n+    inferred = call_result.src\n+    src_inlining_policy(interp, mi, inferred, NoCallInfo(), IR_FLAG_NULL) || return nothing # hack to work-around test failures caused by #58183 until both it and #48913 are fixed\n+    irsv = IRInterpretationState(interp, codeinst, mi, arginfo.argtypes, inferred)\n+    irsv === nothing && return nothing\n+    assign_parentchild!(irsv, sv)\n+    rt, (nothrow, noub) = ir_abstract_constant_propagation(interp, irsv)\n+    @assert !(rt isa Conditional || rt isa MustAlias) \"invalid lattice element returned from irinterp\"\n+    if !(isa(rt, Type) && hasintersect(rt, Bool))\n+        ir = irsv.ir\n+        # TODO (#48913) enable double inlining pass when there are any calls\n+        # that are newly resolved by irinterp\n+        # state = InliningState(interp)\n+        # ir = ssa_inlining_pass!(irsv.ir, state, propagate_inbounds(irsv))\n+        effects = result.effects\n+        if nothrow\n+            effects = Effects(effects; nothrow=true)\n+        end\n+        if noub\n+            effects = Effects(effects; noub=ALWAYS_TRUE)\n+        end\n+        exct = refine_exception_type(result.exct, effects)\n+        # TODO: SemiConcreteResult fails to preserve the ci_as_edge value\n+        semi_concrete_result = SemiConcreteResult(codeinst, ir, effects, spec_info(irsv))\n+        const_edge = nothing # TODO use the edges from irsv?\n+        return ConstCallResult(rt, exct, semi_concrete_result, effects, const_edge)\n+    end\n+    nothing\n end\n \n function const_prop_result(inf_result::InferenceResult)\n     @assert isdefined(inf_result, :ci_as_edge) \"InferenceResult without ci_as_edge\"\n-    const_prop_result = ConstPropResult(inf_result)\n-    return ConstCallResult(inf_result.result, inf_result.exc_result, const_prop_result,\n+    return ConstCallResult(inf_result.result, inf_result.exc_result, inf_result,\n                            inf_result.ipo_effects, inf_result.ci_as_edge)\n end\n \n@@ -1311,14 +1302,14 @@ function const_prop_call(interp::AbstractInterpreter,\n     \ud835\udd43\u1d62 = typeinf_lattice(interp)\n     forwarded_argtypes = compute_forwarded_argtypes(interp, arginfo, sv)\n     # use `cache_argtypes` that has been constructed for fresh regular inference if available\n-    volatile_inf_result = result.volatile_inf_result\n-    if volatile_inf_result !== nothing\n-        cache_argtypes = volatile_inf_result.inf_result.argtypes\n+    call_result = result.call_result\n+    if call_result isa InferenceResult\n+        cache_argtypes = call_result.argtypes\n     else\n         cache_argtypes = matching_cache_argtypes(\ud835\udd43\u1d62, mi)\n     end\n     argtypes = matching_cache_argtypes(\ud835\udd43\u1d62, mi, forwarded_argtypes, cache_argtypes)\n-    inf_result = cache_lookup(\ud835\udd43\u1d62, mi, argtypes, inf_cache)\n+    inf_result = constprop_cache_lookup(\ud835\udd43\u1d62, mi, argtypes, inf_cache)\n     if inf_result !== nothing\n         # found the cache for this constant prop'\n         if inf_result.result === nothing\n@@ -1354,6 +1345,8 @@ function const_prop_call(interp::AbstractInterpreter,\n         callstack = frame.callstack::Vector{AbsIntState}\n         @assert callstack[end] === frame && length(callstack) == frame.frameid\n         pop!(callstack)\n+        # add to the cache to record that this will always fail\n+        push!(get_inference_cache(interp), inf_result)\n         return nothing\n     end\n     existing_edge = result.edge\n@@ -2221,10 +2214,10 @@ function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::Stmt\n     ft = widenconst(ft\u2032)\n     ft === Bottom && return Future(CallMeta(Bottom, Any, EFFECTS_THROWS, NoCallInfo()))\n     types = argtype_by_index(argtypes, 3)\n+    our_world = get_inference_world(interp)\n     if types isa Const && types.val isa Union{Method, CodeInstance}\n         method_or_ci = types.val\n         if isa(method_or_ci, CodeInstance)\n-            our_world = sv.world.this\n             argtype = argtypes_to_type(pushfirst!(argtype_tail(argtypes, 4), ft))\n             specsig = get_ci_abi(method_or_ci)\n             defdef = get_ci_mi(method_or_ci).def\n@@ -2237,17 +2230,17 @@ function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::Stmt\n             callee_valid_range = WorldRange(method_or_ci.min_world, method_or_ci.max_world)\n             if !(our_world in callee_valid_range)\n                 if our_world < first(callee_valid_range)\n-                    update_valid_age!(sv, WorldRange(first(sv.world.valid_worlds), first(callee_valid_range)-1))\n+                    update_valid_age!(sv, our_world, WorldRange(first(sv.valid_worlds), first(callee_valid_range)-1))\n                 else\n-                    update_valid_age!(sv, WorldRange(last(callee_valid_range)+1, last(sv.world.valid_worlds)))\n+                    update_valid_age!(sv, our_world, WorldRange(last(callee_valid_range)+1, last(sv.valid_worlds)))\n                 end\n                 return Future(CallMeta(Bottom, ErrorException, EFFECTS_THROWS, NoCallInfo()))\n             end\n             # TODO: When we add curing, we may want to assume this is nothrow\n             if (method_or_ci.owner === Nothing && method_ir_ci.def.def isa Method)\n                 exct = Union{exct, ErrorException}\n             end\n-            update_valid_age!(sv, callee_valid_range)\n+            update_valid_age!(sv, our_world, callee_valid_range)\n             return Future(CallMeta(method_or_ci.rettype, exct, Effects(decode_effects(method_or_ci.ipo_purity_bits), nothrow=(exct===Bottom)),\n                 InvokeCICallInfo(method_or_ci)))\n         else\n@@ -2280,7 +2273,7 @@ function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::Stmt\n         argtype = Tuple{ft, argtype.parameters...}\n         matched, valid_worlds = findsup(lookupsig, method_table(interp))\n         matched === nothing && return Future(CallMeta(Any, Any, Effects(), NoCallInfo()))\n-        update_valid_age!(sv, valid_worlds)\n+        update_valid_age!(sv, our_world, valid_worlds)\n         method = matched.method\n     end\n     tienv = ccall(:jl_type_intersection_with_env, Any, (Any, Any), nargtype, method.sig)::SimpleVector\n@@ -2292,7 +2285,7 @@ function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::Stmt\n     lookupsig_box = Core.Box(lookupsig)\n     invokecall = InvokeCall(types)\n     return Future{CallMeta}(mresult, interp, sv) do result, interp, sv\n-        (; rt, exct, effects, edge, volatile_inf_result) = result\n+        (; rt, exct, effects, edge, call_result) = result\n         local ft\u2032 = ft\u2032_box.contents\n         sig = match.spec_types\n         argtypes\u2032 = invoke_rewrite(arginfo.argtypes)\n@@ -2309,9 +2302,8 @@ function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::Stmt\n         f = singleton_type(ft\u2032)\n         const_call_result = abstract_call_method_with_const_args(interp,\n             result, f, arginfo\u2032, si, match, sv, invokecall)\n-        const_result = volatile_inf_result\n         if const_call_result !== nothing\n-            const_edge = nothing\n+            const_result = const_edge = nothing\n             if const_call_result.rt \u2291 rt\n                 (; rt, effects, const_result, const_edge) = const_call_result\n             end\n@@ -2320,11 +2312,14 @@ function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::Stmt\n             end\n             if const_edge !== nothing\n                 edge = const_edge\n-                update_valid_age!(sv, world_range(const_edge))\n+                update_valid_age!(sv, get_inference_world(interp), world_range(const_edge))\n+            end\n+            if const_result !== nothing\n+                call_result = const_result\n             end\n         end\n         rt = from_interprocedural!(interp, rt, sv, arginfo\u2032, sig)\n-        info = InvokeCallInfo(edge, match, const_result, lookupsig_box.contents)\n+        info = InvokeCallInfo(edge, match, call_result, lookupsig_box.contents)\n         if !match.fully_covers\n             effects = Effects(effects; nothrow=false)\n             exct = exct \u2294 TypeError\n@@ -2429,6 +2424,9 @@ function abstract_eval_getglobal(interp::AbstractInterpreter, sv::AbsIntState, s\n     end\n end\n \n+# The binding lookup code uses the current world to bound its scan to only those worlds that are currently valid\n+binding_world_hints(world::UInt, sv::AbsIntState) = WorldWithRange(world, sv.valid_worlds)\n+\n @nospecs function abstract_eval_get_binding_type(interp::AbstractInterpreter, sv::AbsIntState, M, s)\n     @nospecialize M s\n     \u2291 = partialorder(typeinf_lattice(interp))\n@@ -2438,7 +2436,8 @@ end\n             return CallMeta(Union{}, TypeError, EFFECTS_THROWS, NoCallInfo())\n         end\n         gr = GlobalRef(M, s)\n-        (valid_worlds, rt) = scan_leaf_partitions(interp, gr, sv.world) do interp::AbstractInterpreter, ::Core.Binding, partition::Core.BindingPartition\n+        world = get_inference_world(interp)\n+        (valid_worlds, rt) = scan_leaf_partitions(interp, gr, binding_world_hints(world, sv)) do interp::AbstractInterpreter, ::Core.Binding, partition::Core.BindingPartition\n             local rt\n             kind = binding_kind(partition)\n             if is_some_guard(kind) || kind == PARTITION_KIND_DECLARED\n@@ -2452,7 +2451,7 @@ end\n             end\n             rt\n         end\n-        update_valid_age!(sv, valid_worlds)\n+        update_valid_age!(sv, world, valid_worlds)\n         return CallMeta(rt, Union{}, EFFECTS_TOTAL, GlobalAccessInfo(convert(Core.Binding, gr)))\n     elseif !hasintersect(widenconst(M), Module) || !hasintersect(widenconst(s), Symbol)\n         return CallMeta(Union{}, TypeError, EFFECTS_THROWS, NoCallInfo())\n@@ -2587,7 +2586,8 @@ function abstract_eval_replaceglobal!(interp::AbstractInterpreter, sv::AbsIntSta\n                 s isa Symbol || return CallMeta(Union{}, TypeError, EFFECTS_THROWS, NoCallInfo())\n                 gr = GlobalRef(M, s)\n                 v\u2032 = RefValue{Any}(v)\n-                (valid_worlds, (rte, T)) = scan_leaf_partitions(interp, gr, sv.world) do interp::AbstractInterpreter, binding::Core.Binding, partition::Core.BindingPartition\n+                world = get_inference_world(interp)\n+                (valid_worlds, (rte, T)) = scan_leaf_partitions(interp, gr, binding_world_hints(world, sv)) do interp::AbstractInterpreter, binding::Core.Binding, partition::Core.BindingPartition\n                     partition_T = nothing\n                     partition_rte = abstract_eval_partition_load(interp, binding, partition)\n                     if binding_kind(partition) == PARTITION_KIND_GLOBAL\n@@ -2597,7 +2597,7 @@ function abstract_eval_replaceglobal!(interp::AbstractInterpreter, sv::AbsIntSta\n                     partition_rte = RTEffects(partition_rte.rt, partition_exct, partition_rte.effects)\n                     Pair{RTEffects, Any}(partition_rte, partition_T)\n                 end\n-                update_valid_age!(sv, valid_worlds)\n+                update_valid_age!(sv, world, valid_worlds)\n                 effects = merge_effects(rte.effects, Effects(setglobal!_effects, nothrow=rte.exct===Bottom))\n                 sg = CallMeta(Any, rte.exct, effects, GlobalAccessInfo(convert(Core.Binding, gr)))\n             else\n@@ -2818,15 +2818,14 @@ function abstract_call_opaque_closure(interp::AbstractInterpreter,\n     mresult = abstract_call_method(interp, ocmethod, sig, Core.svec(), false, si, sv)\n     ocsig_box = Core.Box(ocsig)\n     return Future{CallMeta}(mresult, interp, sv) do result, interp, sv\n-        (; rt, exct, effects, volatile_inf_result, edge, edgecycle) = result\n+        (; rt, exct, effects, call_result, edge, edgecycle) = result\n         \ud835\udd43\u209a = ipo_lattice(interp)\n         \u2291, \u22e4, \u2294 = partialorder(\ud835\udd43\u209a), strictneqpartialorder(\ud835\udd43\u209a), join(\ud835\udd43\u209a)\n-        const_result = volatile_inf_result\n         if !edgecycle\n             const_call_result = abstract_call_method_with_const_args(interp, result,\n                 #=f=#nothing, arginfo, si, match, sv)\n             if const_call_result !== nothing\n-                const_edge = nothing\n+                const_result = const_edge = nothing\n                 if const_call_result.rt \u2291 rt\n                     (; rt, effects, const_result, const_edge) = const_call_result\n                 end\n@@ -2835,7 +2834,10 @@ function abstract_call_opaque_closure(interp::AbstractInterpreter,\n                 end\n                 if const_edge !== nothing\n                     edge = const_edge\n-                    update_valid_age!(sv, world_range(const_edge))\n+                    update_valid_age!(sv, get_inference_world(interp), world_range(const_edge))\n+                end\n+                if const_result !== nothing\n+                    call_result = const_result\n                 end\n             end\n         end\n@@ -2849,7 +2851,7 @@ function abstract_call_opaque_closure(interp::AbstractInterpreter,\n             end\n         end\n         rt = from_interprocedural!(interp, rt, sv, arginfo, match.spec_types)\n-        info = OpaqueClosureCallInfo(edge, match, const_result)\n+        info = OpaqueClosureCallInfo(edge, match, call_result)\n         return CallMeta(rt, exct, effects, info)\n     end\n end\n@@ -3310,7 +3312,9 @@ function abstract_eval_isdefinedglobal(interp::AbstractInterpreter, mod::Module,\n         end\n     end\n \n-    (_, rte) = abstract_load_all_consistent_leaf_partitions(interp, gr, sv.world)\n+    world = get_inference_world(interp)\n+    (valid_worlds, rte) = abstract_load_all_consistent_leaf_partitions(interp, gr, binding_world_hints(world, sv))\n+    # XXX: it is unsound to ignore valid_worlds here\n     if rte.exct == Union{}\n         rt = Const(true)\n     elseif rte.rt === Union{} && rte.exct === UndefVarError\n@@ -3572,6 +3576,7 @@ world_range(ci::CodeInfo) = WorldRange(ci.min_world, ci.max_world)\n world_range(ci::CodeInstance) = WorldRange(ci.min_world, ci.max_world)\n world_range(compact::IncrementalCompact) = world_range(compact.ir)\n \n+# n.b. this function is not part of abstract eval (where it would be unsound) but rather for the optimizer to observe the result of abstract eval\n function abstract_eval_globalref_type(g::GlobalRef, src::Union{CodeInfo, IRCode, IncrementalCompact})\n     worlds = world_range(src)\n     (valid_worlds, rte) = abstract_load_all_consistent_leaf_partitions(nothing, g, WorldWithRange(min_world(worlds), worlds))\n@@ -3582,8 +3587,9 @@ function abstract_eval_globalref_type(g::GlobalRef, src::Union{CodeInfo, IRCode,\n end\n \n function lookup_binding_partition!(interp::AbstractInterpreter, g::Union{GlobalRef, Core.Binding}, sv::AbsIntState)\n-    partition = lookup_binding_partition(get_inference_world(interp), g)\n-    update_valid_age!(sv, WorldRange(partition.min_world, partition.max_world))\n+    world = get_inference_world(interp)\n+    partition = lookup_binding_partition(world, g)\n+    update_valid_age!(sv, world, WorldRange(partition.min_world, partition.max_world))\n     partition\n end\n \n@@ -3600,8 +3606,9 @@ end\n function abstract_eval_binding_partition!(interp::AbstractInterpreter, g::GlobalRef, sv::AbsIntState)\n     b = convert(Core.Binding, g)\n     partition = lookup_binding_partition!(interp, b, sv)\n-    valid_worlds, (_, partition) = walk_binding_partition(b, partition, get_inference_world(interp))\n-    update_valid_age!(sv, valid_worlds)\n+    world = get_inference_world(interp)\n+    valid_worlds, (_, partition) = walk_binding_partition(b, partition, world)\n+    update_valid_age!(sv, world, valid_worlds)\n     return partition\n end\n \n@@ -3713,8 +3720,9 @@ function abstract_eval_globalref(interp::AbstractInterpreter, g::GlobalRef, saw_\n     # For inference purposes, we don't particularly care which global binding we end up loading, we only\n     # care about its type. However, we would still like to terminate the world range for the particular\n     # binding we end up reaching such that codegen can emit a simpler pointer load.\n-    (valid_worlds, ret) = scan_leaf_partitions(abstract_eval_partition_load, interp, g, sv.world)\n-    update_valid_age!(sv, valid_worlds)\n+    world = get_inference_world(interp)\n+    (valid_worlds, ret) = scan_leaf_partitions(abstract_eval_partition_load, interp, g, binding_world_hints(world, sv))\n+    update_valid_age!(sv, world, valid_worlds)\n     return ret\n end\n \n@@ -3723,10 +3731,11 @@ function global_assignment_rt_exct(interp::AbstractInterpreter, sv::AbsIntState,\n         return Pair{Any,Any}(newty, Union{TypeError, ErrorException})\n     end\n     newty\u2032 = RefValue{Any}(newty)\n-    (valid_worlds, ret) = scan_partitions(interp, g, sv.world) do interp::AbstractInterpreter, ::Core.Binding, partition::Core.BindingPartition\n+    world = get_inference_world(interp)\n+    (valid_worlds, ret) = scan_partitions(interp, g, binding_world_hints(world, sv)) do interp::AbstractInterpreter, ::Core.Binding, partition::Core.BindingPartition\n         global_assignment_binding_rt_exct(interp, partition, newty\u2032[])\n     end\n-    update_valid_age!(sv, valid_worlds)\n+    update_valid_age!(sv, world, valid_worlds)\n     return ret\n end\n "
    },
    {
      "sha": "a632bae5dc55cf053ec968f2b76eb9a432f9d3fe",
      "filename": "Compiler/src/cicache.jl",
      "status": "modified",
      "additions": 23,
      "deletions": 40,
      "changes": 63,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fcicache.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fcicache.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fcicache.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -1,26 +1,5 @@\n # This file is a part of Julia. License is MIT: https://julialang.org/license\n \n-\"\"\"\n-    struct InternalCodeCache\n-\n-Internally, each `MethodInstance` keep a unique global cache of code instances\n-that have been created for the given method instance, stratified by world age\n-ranges. This struct abstracts over access to this cache.\n-\"\"\"\n-struct InternalCodeCache\n-    owner::Any # `jl_egal` is used for comparison\n-end\n-\n-function setindex!(cache::InternalCodeCache, ci::CodeInstance, mi::MethodInstance)\n-    @assert ci.owner === cache.owner\n-    m = mi.def\n-    if isa(m, Method)\n-        ccall(:jl_push_newly_inferred, Cvoid, (Any,), ci)\n-    end\n-    ccall(:jl_mi_cache_insert, Cvoid, (Any, Any), mi, ci)\n-    return cache\n-end\n-\n struct WorldRange\n     min_world::UInt\n     max_world::UInt\n@@ -49,39 +28,43 @@ function union(a::WorldRange, b::WorldRange)\n end\n \n \"\"\"\n-    struct WorldView\n+    struct InternalCodeCache\n \n-Takes a given cache and provides access to the cache contents for the given\n-range of world ages, rather than defaulting to the current active world age.\n+Internally, each `MethodInstance` keep a unique global cache of code instances\n+that have been created for the given method instance, stratified by world age\n+ranges. This struct abstracts over access to this cache.\n \"\"\"\n-struct WorldView{Cache}\n-    cache::Cache\n+struct InternalCodeCache\n+    owner::Any # `jl_egal` is used for comparison\n     worlds::WorldRange\n-    WorldView(cache::Cache, range::WorldRange) where Cache = new{Cache}(cache, range)\n+    InternalCodeCache(@nospecialize(owner), wr::WorldRange) = new(owner, wr)\n+    InternalCodeCache(@nospecialize(owner), args...) = new(owner, WorldRange(args...))\n end\n-WorldView(cache, args...) = WorldView(cache, WorldRange(args...))\n-WorldView(wvc::WorldView, wr::WorldRange) = WorldView(wvc.cache, wr)\n-WorldView(wvc::WorldView, args...) = WorldView(wvc.cache, args...)\n \n-function haskey(wvc::WorldView{InternalCodeCache}, mi::MethodInstance)\n-    return ccall(:jl_rettype_inferred, Any, (Any, Any, UInt, UInt), wvc.cache.owner, mi, first(wvc.worlds), last(wvc.worlds)) !== nothing\n+function setindex!(cache::InternalCodeCache, ci::CodeInstance, mi::MethodInstance)\n+    @assert ci.owner === cache.owner\n+    m = mi.def\n+    if isa(m, Method)\n+        ccall(:jl_push_newly_inferred, Cvoid, (Any,), ci)\n+    end\n+    ccall(:jl_mi_cache_insert, Cvoid, (Any, Any), mi, ci)\n+    return cache\n end\n \n-function get(wvc::WorldView{InternalCodeCache}, mi::MethodInstance, default)\n-    r = ccall(:jl_rettype_inferred, Any, (Any, Any, UInt, UInt), wvc.cache.owner, mi, first(wvc.worlds), last(wvc.worlds))\n+function haskey(wvc::InternalCodeCache, mi::MethodInstance)\n+    return ccall(:jl_rettype_inferred, Any, (Any, Any, UInt, UInt), wvc.owner, mi, first(wvc.worlds), last(wvc.worlds)) !== nothing\n+end\n+\n+function get(wvc::InternalCodeCache, mi::MethodInstance, default)\n+    r = ccall(:jl_rettype_inferred, Any, (Any, Any, UInt, UInt), wvc.owner, mi, first(wvc.worlds), last(wvc.worlds))\n     if r === nothing\n         return default\n     end\n     return r::CodeInstance\n end\n \n-function getindex(wvc::WorldView{InternalCodeCache}, mi::MethodInstance)\n+function getindex(wvc::InternalCodeCache, mi::MethodInstance)\n     r = get(wvc, mi, nothing)\n     r === nothing && throw(KeyError(mi))\n     return r::CodeInstance\n end\n-\n-function setindex!(wvc::WorldView{InternalCodeCache}, ci::CodeInstance, mi::MethodInstance)\n-    setindex!(wvc.cache, ci, mi)\n-    return wvc\n-end"
    },
    {
      "sha": "10c4976c9fd3da20d3e22c380230eb65b2d16259",
      "filename": "Compiler/src/inferenceresult.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Finferenceresult.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Finferenceresult.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Finferenceresult.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -89,7 +89,7 @@ function is_argtype_match(\ud835\udd43::AbstractLattice,\n     end\n end\n \n-function va_process_argtypes(\ud835\udd43::AbstractLattice, given_argtypes::Vector{Any}, nargs::UInt, isva::Bool)\n+function va_process_argtypes(\ud835\udd43::AbstractLattice, given_argtypes::Vector{Any}, nargs::UInt, isva::Bool, mi::MethodInstance)\n     nargs = Int(nargs)\n     if isva || (!isempty(given_argtypes) && isvarargtype(given_argtypes[end]))\n         isva_given_argtypes = Vector{Any}(undef, nargs)\n@@ -120,7 +120,10 @@ function va_process_argtypes(\ud835\udd43::AbstractLattice, given_argtypes::Vector{Any},\n         end\n         return isva_given_argtypes\n     end\n-    @assert length(given_argtypes) == nargs \"invalid `given_argtypes` for `mi`\"\n+    if length(given_argtypes) != nargs\n+        println(given_argtypes, \" != \", nargs, \" for \", mi)\n+        throw(AssertionError(\"invalid `given_argtypes` for `mi`\"))\n+    end\n     return given_argtypes\n end\n \n@@ -178,16 +181,17 @@ function elim_free_typevars(@nospecialize t)\n     end\n end\n \n-function cache_lookup(\ud835\udd43::AbstractLattice, mi::MethodInstance, given_argtypes::Vector{Any},\n-                      cache::Vector{InferenceResult})\n+function constprop_cache_lookup(\ud835\udd43::AbstractLattice, mi::MethodInstance, given_argtypes::Vector{Any}, cache::Vector{InferenceResult})\n     method = mi.def::Method\n     nargtypes = length(given_argtypes)\n     for cached_result in cache\n         cached_result.tombstone && continue # ignore deleted entries (due to LimitedAccuracy)\n         cached_result.linfo === mi || continue\n         cache_argtypes = cached_result.argtypes\n         @assert length(cache_argtypes) == nargtypes \"invalid `cache_argtypes` for `mi`\"\n-        cache_overridden_by_const = cached_result.overridden_by_const::BitVector\n+        cache_overridden_by_const = cached_result.overridden_by_const\n+        cache_overridden_by_const === nothing && continue\n+        cache_overridden_by_const = cache_overridden_by_const::BitVector\n         for i in 1:nargtypes\n             if !is_argtype_match(\ud835\udd43, given_argtypes[i], cache_argtypes[i], cache_overridden_by_const[i])\n                 @goto next_cache"
    },
    {
      "sha": "6f779a06b7633f9b3f136b150e5aa50d7d095c85",
      "filename": "Compiler/src/inferencestate.jl",
      "status": "modified",
      "additions": 27,
      "deletions": 27,
      "changes": 54,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Finferencestate.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Finferencestate.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Finferencestate.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -217,7 +217,6 @@ end\n const CACHE_MODE_NULL     = 0x00      # not cached, optimization optional\n const CACHE_MODE_GLOBAL   = 0x01 << 0 # cached globally, optimization required\n const CACHE_MODE_LOCAL    = 0x01 << 1 # cached locally, optimization required\n-const CACHE_MODE_VOLATILE = 0x01 << 2 # not cached, optimization required\n \n abstract type Handler end\n get_enter_idx(handler::Handler) = get_enter_idx_impl(handler)::Int\n@@ -262,7 +261,7 @@ intersect(world::WorldWithRange, valid_worlds::WorldRange) =\n mutable struct InferenceState\n     #= information about this method instance =#\n     linfo::MethodInstance\n-    world::WorldWithRange\n+    valid_worlds::WorldRange\n     mod::Module\n     sptypes::Vector{VarState}\n     slottypes::Vector{Any}\n@@ -349,7 +348,7 @@ mutable struct InferenceState\n         bb_vartable1 = bb_vartables[1] = VarTable(undef, nslots)\n         argtypes = result.argtypes\n \n-        argtypes = va_process_argtypes(typeinf_lattice(interp), argtypes, src.nargs, src.isva)\n+        argtypes = va_process_argtypes(typeinf_lattice(interp), argtypes, src.nargs, src.isva, mi)\n \n         nargtypes = length(argtypes)\n         for i = 1:nslots\n@@ -392,7 +391,7 @@ mutable struct InferenceState\n         parentid = frameid = cycleid = 0\n \n         this = new(\n-            mi, WorldWithRange(world, valid_worlds), mod, sptypes, slottypes, src, cfg, spec_info,\n+            mi, valid_worlds, mod, sptypes, slottypes, src, cfg, spec_info,\n             currbb, currpc, ip, handler_info, ssavalue_uses, bb_vartables, bb_saw_latestworld, ssavaluetypes, ssaflags, edges, stmt_info,\n             tasks, pclimitations, limitations, cycle_backedges, callstack, parentid, frameid, cycleid,\n             result, unreachable, bestguess, exc_bestguess, ipo_effects,\n@@ -401,9 +400,6 @@ mutable struct InferenceState\n             interp)\n \n         # some more setups\n-        if !iszero(cache_mode & CACHE_MODE_LOCAL)\n-            push!(get_inference_cache(interp), result)\n-        end\n         if !iszero(cache_mode & CACHE_MODE_GLOBAL)\n             push!(callstack, this)\n             this.cycleid = this.frameid = length(callstack)\n@@ -412,7 +408,7 @@ mutable struct InferenceState\n         # Apply generated function restrictions\n         if src.min_world != 1 || src.max_world != typemax(UInt)\n             # From generated functions\n-            update_valid_age!(this, WorldRange(src.min_world, src.max_world))\n+            update_valid_age!(this, world, WorldRange(src.min_world, src.max_world))\n         end\n \n         return this\n@@ -615,8 +611,6 @@ function convert_cache_mode(cache_mode::Symbol)\n         return CACHE_MODE_GLOBAL\n     elseif cache_mode === :local\n         return CACHE_MODE_LOCAL\n-    elseif cache_mode === :volatile\n-        return CACHE_MODE_VOLATILE\n     elseif cache_mode === :no\n         return CACHE_MODE_NULL\n     end\n@@ -821,7 +815,7 @@ mutable struct IRInterpretationState\n     const spec_info::SpecInfo\n     const ir::IRCode\n     const mi::MethodInstance\n-    world::WorldWithRange\n+    valid_worlds::WorldRange\n     curridx::Int\n     time_caches::Float64\n     time_paused::UInt64\n@@ -836,9 +830,10 @@ mutable struct IRInterpretationState\n     frameid::Int\n     parentid::Int\n \n-    function IRInterpretationState(interp::AbstractInterpreter,\n-        spec_info::SpecInfo, ir::IRCode, mi::MethodInstance, argtypes::Vector{Any},\n-        world::UInt, min_world::UInt, max_world::UInt)\n+    function IRInterpretationState(\n+            interp::AbstractInterpreter, spec_info::SpecInfo, ir::IRCode,\n+            mi::MethodInstance, argtypes::Vector{Any}, min_world::UInt, max_world::UInt\n+        )\n         curridx = 1\n         given_argtypes = Vector{Any}(undef, length(argtypes))\n         for i = 1:length(given_argtypes)\n@@ -856,28 +851,32 @@ mutable struct IRInterpretationState\n         ssa_refined = BitSet()\n         lazyreachability = LazyCFGReachability(ir)\n         valid_worlds = WorldRange(min_world, max_world == typemax(UInt) ? get_world_counter() : max_world)\n+        if !(get_inference_world(interp) in valid_worlds)\n+            error(\"invalid age range update\")\n+        end\n         tasks = WorkThunk[]\n         edges = Any[]\n         callstack = AbsIntState[]\n-        return new(spec_info, ir, mi, WorldWithRange(world, valid_worlds),\n+        return new(spec_info, ir, mi, valid_worlds,\n                 curridx, 0.0, 0, argtypes_refined, ir.sptypes, tpdum,\n                 ssa_refined, lazyreachability, tasks, edges, callstack, 0, 0)\n     end\n end\n \n-function IRInterpretationState(interp::AbstractInterpreter,\n-    codeinst::CodeInstance, mi::MethodInstance, argtypes::Vector{Any}, world::UInt)\n+function IRInterpretationState(\n+        interp::AbstractInterpreter, codeinst::CodeInstance, mi::MethodInstance,\n+        argtypes::Vector{Any}, @nospecialize(src)\n+    )\n     @assert get_ci_mi(codeinst) === mi \"method instance is not synced with code instance\"\n-    src = @atomic :monotonic codeinst.inferred\n     if isa(src, String)\n         src = _uncompressed_ir(codeinst, src)\n     else\n         isa(src, CodeInfo) || return nothing\n     end\n     spec_info = SpecInfo(src)\n     ir = inflate_ir(src, mi)\n-    argtypes = va_process_argtypes(optimizer_lattice(interp), argtypes, src.nargs, src.isva)\n-    return IRInterpretationState(interp, spec_info, ir, mi, argtypes, world,\n+    argtypes = va_process_argtypes(optimizer_lattice(interp), argtypes, src.nargs, src.isva, mi)\n+    return IRInterpretationState(interp, spec_info, ir, mi, argtypes,\n                                  codeinst.min_world, codeinst.max_world)\n end\n \n@@ -900,7 +899,7 @@ function print_callstack(frame::AbsIntState)\n         end\n         print(\"] \")\n         print(frame_instance(sv))\n-        is_cached(sv) || print(\"  [uncached]\")\n+        is_cached(sv) || print(\"  [not globally cached]\")\n         sv.parentid == idx - 1 || print(\" [parent=\", sv.parentid, \"]\")\n         isempty(callers_in_cycle(sv)) || print(\" [cycle=\", sv.cycleid, \"]\")\n         println()\n@@ -964,9 +963,6 @@ spec_info(sv::IRInterpretationState) = sv.spec_info\n propagate_inbounds(sv::AbsIntState) = spec_info(sv).propagate_inbounds\n method_for_inference_limit_heuristics(sv::AbsIntState) = spec_info(sv).method_for_inference_limit_heuristics\n \n-frame_world(sv::InferenceState) = sv.world.this\n-frame_world(sv::IRInterpretationState) = sv.world.this\n-\n function is_effect_overridden(sv::AbsIntState, effect::Symbol)\n     if is_effect_overridden(frame_instance(sv), effect)\n         return true\n@@ -986,9 +982,13 @@ has_conditional(\ud835\udd43::AbstractLattice, ::InferenceState) = has_conditional(\ud835\udd43)\n has_conditional(::AbstractLattice, ::IRInterpretationState) = false\n \n # work towards converging the valid age range for sv\n-function update_valid_age!(sv::AbsIntState, valid_worlds::WorldRange)\n-    sv.world = intersect(sv.world, valid_worlds)\n-    return sv.world.valid_worlds\n+function update_valid_age!(sv::AbsIntState, world, valid_worlds::WorldRange)\n+    valid_worlds = intersect(sv.valid_worlds, valid_worlds)\n+    if !(world in valid_worlds)\n+        error(\"invalid age range update\")\n+    end\n+    sv.valid_worlds = valid_worlds\n+    return valid_worlds\n end\n \n \"\"\""
    },
    {
      "sha": "b5704c488d273aa0ee99465f20517cb1c4ed47eb",
      "filename": "Compiler/src/optimize.jl",
      "status": "modified",
      "additions": 15,
      "deletions": 29,
      "changes": 44,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Foptimize.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Foptimize.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Foptimize.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -99,14 +99,9 @@ end\n \n const TOP_TUPLE = GlobalRef(Core, :tuple)\n \n-# This corresponds to the type of `CodeInfo`'s `inlining_cost` field\n-const InlineCostType = UInt16\n-const MAX_INLINE_COST = typemax(InlineCostType)\n-const MIN_INLINE_COST = InlineCostType(10)\n-const MaybeCompressed = Union{CodeInfo, String}\n-\n-is_inlineable(@nospecialize src::MaybeCompressed) =\n-    ccall(:jl_ir_inlining_cost, InlineCostType, (Any,), src) != MAX_INLINE_COST\n+inlining_cost(@nospecialize src) =\n+    src isa Union{MaybeCompressed,UInt8} ? ccall(:jl_ir_inlining_cost, InlineCostType, (Any,), src) : MAX_INLINE_COST\n+is_inlineable(@nospecialize src) = inlining_cost(src) != MAX_INLINE_COST\n set_inlineable!(src::CodeInfo, val::Bool) =\n     src.inlining_cost = (val ? MIN_INLINE_COST : MAX_INLINE_COST)\n \n@@ -158,47 +153,38 @@ end\n \n struct InliningState{Interp<:AbstractInterpreter}\n     edges::Vector{Any}\n-    world::UInt\n     interp::Interp\n     opt_cache::IdDict{MethodInstance,CodeInstance}\n end\n function InliningState(sv::InferenceState, interp::AbstractInterpreter,\n                        opt_cache::IdDict{MethodInstance,CodeInstance}=IdDict{MethodInstance,CodeInstance}())\n-    return InliningState(sv.edges, frame_world(sv), interp, opt_cache)\n+    return InliningState(sv.edges, interp, opt_cache)\n end\n function InliningState(interp::AbstractInterpreter,\n                        opt_cache::IdDict{MethodInstance,CodeInstance}=IdDict{MethodInstance,CodeInstance}())\n-    return InliningState(Any[], get_inference_world(interp), interp, opt_cache)\n+    return InliningState(Any[], interp, opt_cache)\n end\n \n struct OptimizerCache{CodeCache}\n-    wvc::WorldView{CodeCache}\n-    owner\n+    cache::CodeCache\n     opt_cache::IdDict{MethodInstance,CodeInstance}\n     function OptimizerCache(\n-        wvc::WorldView{CodeCache},\n-        @nospecialize(owner),\n+        cache::CodeCache,\n         opt_cache::IdDict{MethodInstance,CodeInstance}) where CodeCache\n-        new{CodeCache}(wvc, owner, opt_cache)\n+        return new{CodeCache}(cache, opt_cache)\n     end\n end\n-function get((; wvc, owner, opt_cache)::OptimizerCache, mi::MethodInstance, default)\n+function get((; cache, opt_cache)::OptimizerCache, mi::MethodInstance, default)\n     if haskey(opt_cache, mi)\n-        codeinst = opt_cache[mi]\n-        @assert codeinst.min_world \u2264 wvc.worlds.min_world &&\n-                wvc.worlds.max_world \u2264 codeinst.max_world &&\n-                codeinst.owner === owner\n-        @assert isdefined(codeinst, :inferred) && codeinst.inferred === nothing\n-        return codeinst\n+        return opt_cache[mi] # this is incomplete right now, but will be finished (by finish_cycle) before caching anything\n     end\n-    return get(wvc, mi, default)\n+    return get(cache, mi, default)\n end\n \n # get `code_cache(::AbstractInterpreter)` from `state::InliningState`\n function code_cache(state::InliningState)\n-    cache = WorldView(code_cache(state.interp), state.world)\n-    owner = cache_owner(state.interp)\n-    return OptimizerCache(cache, owner, state.opt_cache)\n+    cache = code_cache(state.interp)\n+    return OptimizerCache(cache, state.opt_cache)\n end\n \n mutable struct OptimizationResult\n@@ -678,15 +664,15 @@ GetNativeEscapeCache(interp::AbstractInterpreter) = GetNativeEscapeCache(code_ca\n function ((; code_cache)::GetNativeEscapeCache)(codeinst::Union{CodeInstance,MethodInstance})\n     if codeinst isa MethodInstance\n         codeinst = get(code_cache, codeinst, nothing)\n-        codeinst isa CodeInstance || return false\n+        codeinst === nothing && return false\n     end\n     argescapes = traverse_analysis_results(codeinst) do @nospecialize result\n         return result isa EscapeAnalysis.ArgEscapeCache ? result : nothing\n     end\n     if argescapes !== nothing\n         return argescapes\n     end\n-    effects = decode_effects(codeinst.ipo_purity_bits)\n+    effects = codeinst isa CodeInstance ? decode_effects(codeinst.ipo_purity_bits) : codeinst.ipo_effects\n     if is_effect_free(effects) && is_inaccessiblememonly(effects)\n         # We might not have run EA on simple frames without any escapes (e.g. when optimization\n         # is skipped when result is constant-folded by abstract interpretation). If those"
    },
    {
      "sha": "9d477cbff491c5c39dc705a6359ed838500d32e2",
      "filename": "Compiler/src/ssair/inlining.jl",
      "status": "modified",
      "additions": 80,
      "deletions": 141,
      "changes": 221,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fssair%2Finlining.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fssair%2Finlining.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2Finlining.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -793,6 +793,7 @@ function compileable_specialization(code::Union{MethodInstance,CodeInstance}, ef\n     # prefer using a CodeInstance gotten from the cache, since that is where the invoke target should get compiled to normally\n     # TODO: can this code be gotten directly from inference sometimes?\n     code = get(code_cache(state), mi_invoke, nothing)\n+    code isa InferenceResult && (code = code.ci)\n     if !isa(code, CodeInstance)\n         #println(\"missing code for \", mi_invoke, \" for \", mi)\n         code = mi_invoke\n@@ -801,24 +802,13 @@ function compileable_specialization(code::Union{MethodInstance,CodeInstance}, ef\n     return InvokeCase(code, effects, info)\n end\n \n-struct InferredResult\n+struct InferredCode\n     src::Any # CodeInfo or IRCode\n     effects::Effects\n     edge::CodeInstance\n-    InferredResult(@nospecialize(src), effects::Effects, edge::CodeInstance) = new(src, effects, edge)\n-end\n-@inline function get_cached_result(state::InliningState, mi::MethodInstance)\n-    code = get(code_cache(state), mi, nothing)\n-    if code isa CodeInstance\n-        if use_const_api(code)\n-            # in this case function can be inlined to a constant\n-            return ConstantCase(quoted(code.rettype_const), code)\n-        end\n-        return code\n-    end\n-    return nothing\n+    InferredCode(@nospecialize(src), effects::Effects, edge::CodeInstance) = new(src, effects, edge)\n end\n-@inline function get_local_result(inf_result::InferenceResult)\n+@inline function get_local_code(inf_result::InferenceResult)\n     @assert isdefined(inf_result, :ci_as_edge) \"InferenceResult without ci_as_edge\"\n     effects = inf_result.ipo_effects\n     if is_foldable_nothrow(effects)\n@@ -828,36 +818,25 @@ end\n             return ConstantCase(quoted(res.val), inf_result.ci_as_edge)\n         end\n     end\n-    return InferredResult(inf_result.src, effects, inf_result.ci_as_edge)\n+    return InferredCode(inf_result.src, effects, inf_result.ci_as_edge)\n end\n \n # the general resolver for usual and const-prop'ed calls\n-function resolve_todo(mi::MethodInstance, result::Union{Nothing,InferenceResult,VolatileInferenceResult},\n+function resolve_todo(mi::MethodInstance, call_result::Union{Nothing,InferenceResult},\n     @nospecialize(info::CallInfo), flag::UInt32, state::InliningState)\n     et = InliningEdgeTracker(state)\n \n-    preserve_local_sources = true\n-    if isa(result, InferenceResult)\n-        inferred_result = get_local_result(result)\n-    elseif isa(result, VolatileInferenceResult)\n-        inferred_result = get_local_result(result.inf_result)\n-        # volatile inference result can be inlined destructively\n-        preserve_local_sources = !result.inf_result.is_src_volatile | OptimizationParams(state.interp).preserve_local_sources\n-    else\n-        inferred_result = get_cached_result(state, mi)\n+    if call_result === nothing\n+        # there is no cached source available for this, but there might be code for the compilation sig\n+        return compileable_specialization(mi, Effects(), et, info, state)\n     end\n+\n+    inferred_result = get_local_code(call_result)\n     if inferred_result isa ConstantCase\n         add_inlining_edge!(et, inferred_result.edge)\n         return inferred_result\n-    elseif inferred_result isa InferredResult\n-        (; src, effects, edge) = inferred_result\n-    elseif inferred_result isa CodeInstance\n-        src = @atomic :monotonic inferred_result.inferred\n-        effects = decode_effects(inferred_result.ipo_purity_bits)\n-        edge = inferred_result\n-    else # there is no cached source available for this, but there might be code for the compilation sig\n-        return compileable_specialization(mi, Effects(), et, info, state)\n     end\n+    (; src, effects, edge) = inferred_result\n \n     # the duplicated check might have been done already within `analyze_method!`, but still\n     # we need it here too since we may come here directly using a constant-prop' result\n@@ -869,37 +848,7 @@ function resolve_todo(mi::MethodInstance, result::Union{Nothing,InferenceResult,\n         return compileable_specialization(edge, effects, et, info, state)\n \n     add_inlining_edge!(et, edge)\n-    if inferred_result isa CodeInstance\n-        ir, spec_info, debuginfo = retrieve_ir_for_inlining(inferred_result, src)\n-    else\n-        ir, spec_info, debuginfo = retrieve_ir_for_inlining(mi, src, preserve_local_sources)\n-    end\n-    return InliningTodo(mi, ir, spec_info, debuginfo, effects)\n-end\n-\n-# the special resolver for :invoke-d call\n-function resolve_todo(mi::MethodInstance, @nospecialize(info::CallInfo), flag::UInt32,\n-                      state::InliningState)\n-    if !OptimizationParams(state.interp).inlining || is_stmt_noinline(flag)\n-        return nothing\n-    end\n-\n-    et = InliningEdgeTracker(state)\n-\n-    cached_result = get_cached_result(state, mi)\n-    if cached_result isa ConstantCase\n-        add_inlining_edge!(et, cached_result.edge)\n-        return cached_result\n-    elseif cached_result isa CodeInstance\n-        src = @atomic :monotonic cached_result.inferred\n-        effects = decode_effects(cached_result.ipo_purity_bits)\n-    else # there is no cached source available, bail out\n-        return nothing\n-    end\n-\n-    src_inlining_policy(state.interp, mi, src, info, flag) || return nothing\n-    ir, spec_info, debuginfo = retrieve_ir_for_inlining(cached_result, src)\n-    add_inlining_edge!(et, cached_result)\n+    ir, spec_info, debuginfo = retrieve_ir_for_inlining(mi, src, true)\n     return InliningTodo(mi, ir, spec_info, debuginfo, effects)\n end\n \n@@ -918,10 +867,11 @@ function may_have_fcalls(m::Method)\n     return ccall(:jl_ir_flag_has_fcall, Bool, (Any,), src)\n end\n \n-function analyze_method!(match::MethodMatch, argtypes::Vector{Any},\n-    @nospecialize(info::CallInfo), flag::UInt32, state::InliningState;\n-    allow_typevars::Bool,\n-    volatile_inf_result::Union{Nothing,VolatileInferenceResult}=nothing)\n+function analyze_method!(\n+        call_result::Union{Nothing,InferenceResult}, match::MethodMatch, argtypes::Vector{Any},\n+        @nospecialize(info::CallInfo), flag::UInt32, state::InliningState;\n+        allow_typevars::Bool\n+    )\n     method = match.method\n \n     # Check that we have the correct number of arguments\n@@ -951,7 +901,7 @@ function analyze_method!(match::MethodMatch, argtypes::Vector{Any},\n     # Get the specialization for this method signature\n     # (later we will decide what to do with it)\n     mi = specialize_method(match)\n-    return resolve_todo(mi, volatile_inf_result, info, flag, state)\n+    return resolve_todo(mi, call_result, info, flag, state)\n end\n \n function retrieve_ir_for_inlining(cached_result::CodeInstance, src::String)\n@@ -994,7 +944,7 @@ function handle_single_case!(todo::Vector{Pair{Int,Any}},\n         ir[SSAValue(idx)][:stmt] = case.val\n     elseif isa(case, InvokeCase)\n         is_foldable_nothrow(case.effects) && inline_const_if_inlineable!(ir[SSAValue(idx)]) && return nothing\n-        isinvoke && rewrite_invoke_exprargs!(stmt)\n+        isinvoke && invoke_rewrite!(stmt)\n         if stmt.head === :invoke\n             stmt.args[1] = case.invoke\n         else\n@@ -1005,13 +955,13 @@ function handle_single_case!(todo::Vector{Pair{Int,Any}},\n     elseif case === nothing\n         # Do, well, nothing\n     else\n-        isinvoke && rewrite_invoke_exprargs!(stmt)\n+        isinvoke && invoke_rewrite!(stmt)\n         push!(todo, idx=>(case::InliningTodo))\n     end\n     return nothing\n end\n \n-rewrite_invoke_exprargs!(expr::Expr) = (expr.args = invoke_rewrite(expr.args); expr)\n+invoke_rewrite!(expr::Expr) = (expr.args = invoke_rewrite(expr.args); expr)\n \n function is_valid_type_for_apply_rewrite(@nospecialize(typ), params::OptimizationParams)\n     if isa(typ, Const) && (v = typ.val; isa(v, SimpleVector))\n@@ -1180,17 +1130,16 @@ function handle_invoke_call!(todo::Vector{Pair{Int,Any}},\n         item = semiconcrete_result_item(result, info, flag, state)\n     else\n         argtypes = invoke_rewrite(sig.argtypes)\n-        if isa(result, ConstPropResult)\n-            mi = result.result.linfo\n+        if isa(result, InferenceResult)\n+            mi = result.linfo\n             validate_sparams(mi.sparam_vals) || return nothing\n             if Union{} !== argtypes_to_type(argtypes) <: mi.def.sig\n-                item = resolve_todo(mi, result.result, info, flag, state)\n+                item = resolve_todo(mi, result, info, flag, state)\n                 handle_single_case!(todo, ir, idx, stmt, item, true)\n                 return nothing\n             end\n         end\n-        volatile_inf_result = result isa VolatileInferenceResult ? result : nothing\n-        item = analyze_method!(match, argtypes, info, flag, state; allow_typevars=false, volatile_inf_result)\n+        item = analyze_method!(result, match, argtypes, info, flag, state; allow_typevars=false)\n     end\n     handle_single_case!(todo, ir, idx, stmt, item, true)\n     return nothing\n@@ -1306,39 +1255,31 @@ function process_simple!(todo::Vector{Pair{Int,Any}}, ir::IRCode, idx::Int, flag\n     return stmt, sig\n end\n \n-function handle_any_const_result!(cases::Vector{InliningCase},\n-    @nospecialize(result), match::MethodMatch, argtypes::Vector{Any},\n-    @nospecialize(info::CallInfo), flag::UInt32, state::InliningState;\n-    allow_typevars::Bool)\n-    if isa(result, ConcreteResult)\n-        return handle_concrete_result!(cases, result, match, info, state)\n-    elseif isa(result, SemiConcreteResult)\n-        return handle_semi_concrete_result!(cases, result, match, info, flag, state)\n-    elseif isa(result, ConstPropResult)\n-        return handle_const_prop_result!(cases, result, match, info, flag, state; allow_typevars)\n+function handle_any_call_result!(\n+        cases::Vector{InliningCase}, @nospecialize(call_result::Union{Nothing,InferredCallResult}),\n+        match::MethodMatch, argtypes::Vector{Any}, @nospecialize(info::CallInfo),\n+        flag::UInt32, state::InliningState;\n+        allow_typevars::Bool\n+    )\n+    if isa(call_result, ConcreteResult)\n+        return handle_concrete_result!(cases, call_result, match, info, state)\n+    elseif isa(call_result, SemiConcreteResult)\n+        return handle_semi_concrete_result!(cases, call_result, match, info, flag, state)\n     else\n-        @assert result === nothing || result isa VolatileInferenceResult\n-        return handle_match!(cases, match, argtypes, info, flag, state; allow_typevars, volatile_inf_result = result)\n+        return handle_call_result!(cases, call_result, match, argtypes, info, flag, state; allow_typevars)\n     end\n end\n \n-function info_effects(@nospecialize(result), match::MethodMatch, state::InliningState)\n-    if isa(result, ConcreteResult)\n-        return result.effects\n-    elseif isa(result, SemiConcreteResult)\n-        return result.effects\n-    elseif isa(result, ConstPropResult)\n-        return result.result.ipo_effects\n-    else\n-        mi = specialize_method(match; preexisting=true)\n-        if isa(mi, MethodInstance)\n-            code = get(code_cache(state), mi, nothing)\n-            if code isa CodeInstance\n-                return decode_effects(code.ipo_purity_bits)\n-            end\n-        end\n+function info_effects(@nospecialize(call_result::Union{Nothing,InferredCallResult}), match::MethodMatch, state::InliningState)\n+    if call_result === nothing\n         return Effects()\n-    end\n+    elseif isa(call_result, InferenceResult)\n+        return call_result.ipo_effects\n+    elseif isa(call_result, ConcreteResult)\n+        return call_result.effects\n+    elseif isa(call_result, SemiConcreteResult)\n+        return call_result.effects\n+    else error(\"Unknown InferredCallResult type\") end\n end\n \n function compute_inlining_cases(@nospecialize(info::CallInfo), flag::UInt32, sig::Signature,\n@@ -1361,8 +1302,8 @@ function compute_inlining_cases(@nospecialize(info::CallInfo), flag::UInt32, sig\n         local split_fully_covered = false\n         for (j, match) in enumerate(meth)\n             all_result_count += 1\n-            result = getresult(info, all_result_count)\n-            joint_effects = merge_effects(joint_effects, info_effects(result, match, state))\n+            call_result = getresult(info, all_result_count)\n+            joint_effects = merge_effects(joint_effects, info_effects(call_result, match, state))\n             split_fully_covered |= match.fully_covers\n             if !validate_sparams(match.sparams)\n                 if match.fully_covers\n@@ -1378,8 +1319,8 @@ function compute_inlining_cases(@nospecialize(info::CallInfo), flag::UInt32, sig\n             elseif !(match.spec_types <: match.method.sig) # the requirement for correct union-split\n                 handled_all_cases = false\n             else\n-                handled_all_cases &= handle_any_const_result!(cases,\n-                    result, match, argtypes, info, flag, state; allow_typevars=false)\n+                handled_all_cases &= handle_any_call_result!(cases,\n+                    call_result, match, argtypes, info, flag, state; allow_typevars=false)\n             end\n         end\n         fully_covered &= split_fully_covered\n@@ -1393,9 +1334,9 @@ function compute_inlining_cases(@nospecialize(info::CallInfo), flag::UInt32, sig\n             # so try to handle it by bypassing validate_sparams\n             (i, j, k) = revisit_idx\n             match = getsplit(info, i)[j]\n-            result = getresult(info, k)\n-            handled_all_cases &= handle_any_const_result!(cases,\n-                result, match, argtypes, info, flag, state; allow_typevars=true)\n+            call_result = getresult(info, k)\n+            handled_all_cases &= handle_any_call_result!(cases,\n+                call_result, match, argtypes, info, flag, state; allow_typevars=true)\n         end\n         if !fully_covered\n             # We will emit an inline MethodError in this case, but that info already came inference, so we must already have the uncovered edge for it\n@@ -1418,28 +1359,18 @@ function handle_call!(todo::Vector{Pair{Int,Any}},\n     handle_cases!(todo, ir, idx, stmt, atype, cases, handled_all_cases, fully_covered, joint_effects)\n end\n \n-function handle_match!(cases::Vector{InliningCase},\n-    match::MethodMatch, argtypes::Vector{Any}, @nospecialize(info::CallInfo), flag::UInt32,\n-    state::InliningState;\n-    allow_typevars::Bool, volatile_inf_result::Union{Nothing,VolatileInferenceResult})\n+function handle_call_result!(\n+        cases::Vector{InliningCase}, call_result::Union{Nothing,InferenceResult},\n+        match::MethodMatch, argtypes::Vector{Any}, @nospecialize(info::CallInfo), flag::UInt32,\n+        state::InliningState;\n+        allow_typevars::Bool\n+    )\n     # We may see duplicated dispatch signatures here when a signature gets widened\n     # during abstract interpretation: for the purpose of inlining, we can just skip\n     # processing this dispatch candidate (unless unmatched type parameters are present)\n     !allow_typevars && any(case::InliningCase->case.sig === match.spec_types, cases) && return true\n-    item = analyze_method!(match, argtypes, info, flag, state; allow_typevars, volatile_inf_result)\n-    item === nothing && return false\n-    push!(cases, InliningCase(match.spec_types, item))\n-    return true\n-end\n \n-function handle_const_prop_result!(cases::Vector{InliningCase}, result::ConstPropResult,\n-    match::MethodMatch, @nospecialize(info::CallInfo), flag::UInt32, state::InliningState;\n-    allow_typevars::Bool)\n-    mi = result.result.linfo\n-    if !validate_sparams(mi.sparam_vals)\n-        (allow_typevars && !may_have_fcalls(mi.def::Method)) || return false\n-    end\n-    item = resolve_todo(mi, result.result, info, flag, state)\n+    item = analyze_method!(call_result, match, argtypes, info, flag, state; allow_typevars)\n     item === nothing && return false\n     push!(cases, InliningCase(match.spec_types, item))\n     return true\n@@ -1521,18 +1452,12 @@ function handle_opaque_closure_call!(todo::Vector{Pair{Int,Any}},\n     ir::IRCode, idx::Int, stmt::Expr, info::OpaqueClosureCallInfo,\n     flag::UInt32, sig::Signature, state::InliningState)\n     result = info.result\n-    if isa(result, ConstPropResult)\n-        mi = result.result.linfo\n-        validate_sparams(mi.sparam_vals) || return nothing\n-        item = resolve_todo(mi, result.result, info, flag, state)\n-    elseif isa(result, ConcreteResult)\n+    if isa(result, ConcreteResult)\n         item = concrete_result_item(result, info, state)\n     elseif isa(result, SemiConcreteResult)\n-        item = item = semiconcrete_result_item(result, info, flag, state)\n+        item = semiconcrete_result_item(result, info, flag, state)\n     else\n-        @assert result === nothing || result isa VolatileInferenceResult\n-        volatile_inf_result = result\n-        item = analyze_method!(info.match, sig.argtypes, info, flag, state; allow_typevars=false, volatile_inf_result)\n+        item = analyze_method!(result, info.match, sig.argtypes, info, flag, state; allow_typevars=false)\n     end\n     handle_single_case!(todo, ir, idx, stmt, item)\n     return nothing\n@@ -1541,7 +1466,6 @@ end\n function handle_modifyop!_call!(ir::IRCode, idx::Int, stmt::Expr, info::ModifyOpInfo, state::InliningState)\n     info = info.info\n     info isa MethodResultPure && (info = info.info)\n-    info isa ConstCallInfo && (info = info.call)\n     info isa MethodMatchInfo || return nothing\n     length(info.edges) == length(info.results) == 1 || return nothing\n     match = info.results[1]::MethodMatch\n@@ -1586,6 +1510,7 @@ function handle_finalizer_call!(ir::IRCode, idx::Int, stmt::Expr, info::Finalize\n         item1 = cases[1].item\n         if isa(item1, InliningTodo)\n             code = get(code_cache(state), item1.mi, nothing) # COMBAK: this seems like a bad design, can we use stmt_info instead to store the correct info?\n+            code isa InferenceResult && (code = code.ci)\n             if code isa CodeInstance\n                 push!(stmt.args, true)\n                 push!(stmt.args, code)\n@@ -1600,12 +1525,26 @@ function handle_finalizer_call!(ir::IRCode, idx::Int, stmt::Expr, info::Finalize\n     return nothing\n end\n \n+# the special resolver for :invoke-d call\n function handle_invoke_expr!(todo::Vector{Pair{Int,Any}}, ir::IRCode,\n     idx::Int, stmt::Expr, @nospecialize(info::CallInfo), flag::UInt32, sig::Signature, state::InliningState)\n     edge = stmt.args[1]\n     mi = isa(edge, MethodInstance) ? edge : get_ci_mi(edge::CodeInstance)\n-    case = resolve_todo(mi, info, flag, state)\n-    handle_single_case!(todo, ir, idx, stmt, case, false)\n+    call_result = nothing\n+    let info = info\n+        info isa MethodResultPure && (info = info.info)\n+        if isa(info, InvokeCallInfo)\n+            call_result = info.result\n+        elseif isa(info, MethodMatchInfo)\n+            # We didn't preserve the converted info when inserting :invoke node so we cannot recover this with accuracy.\n+            # Since that info isn't used, but this is enough for the \"apply `ssa_inlining_pass` multiple times\" test\n+            if length(info.edges) == length(info.results) == 1\n+                call_result = getresult(info, 1)\n+            end\n+        end\n+    end\n+    item = resolve_todo(mi, call_result, info, flag, state)\n+    handle_single_case!(todo, ir, idx, stmt, item)\n     return nothing\n end\n "
    },
    {
      "sha": "7b67a6a3c28801db4de2c36cfe50756afa20cdc0",
      "filename": "Compiler/src/ssair/irinterp.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fssair%2Firinterp.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fssair%2Firinterp.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2Firinterp.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -6,7 +6,7 @@ function collect_limitations!(@nospecialize(typ), ::IRInterpretationState)\n end\n \n function concrete_eval_invoke(interp::AbstractInterpreter, ci::CodeInstance, argtypes::Vector{Any}, parent::IRInterpretationState)\n-    world = frame_world(parent)\n+    world = get_inference_world(interp)\n     effects = decode_effects(ci.ipo_purity_bits)\n     if (is_foldable(effects) && is_all_const_arg(argtypes, #=start=#1) &&\n         (is_nonoverlayed(interp) || is_nonoverlayed(effects)))\n@@ -22,7 +22,8 @@ function concrete_eval_invoke(interp::AbstractInterpreter, ci::CodeInstance, arg\n         if is_constprop_edge_recursed(mi, parent)\n             return Pair{Any,Tuple{Bool,Bool}}(nothing, (is_nothrow(effects), is_noub(effects)))\n         end\n-        newirsv = IRInterpretationState(interp, ci, mi, argtypes, world)\n+        src = ci_get_source(interp, ci)\n+        newirsv = IRInterpretationState(interp, ci, mi, argtypes, src)\n         if newirsv !== nothing\n             assign_parentchild!(newirsv, parent)\n             return ir_abstract_constant_propagation(interp, newirsv)\n@@ -35,10 +36,10 @@ function abstract_eval_invoke_inst(interp::AbstractInterpreter, inst::Instructio\n     stmt = inst[:stmt]::Expr\n     ci = stmt.args[1]\n     if ci isa MethodInstance\n-        world = frame_world(irsv)\n-        mi_cache = WorldView(code_cache(interp), world)\n+        mi_cache = code_cache(interp)\n         code = get(mi_cache, ci, nothing)\n         code === nothing && return Pair{Any,Tuple{Bool,Bool}}(nothing, (false, false))\n+        code isa InferenceResult && (code = code.ci) # COMBAK: we shouldn't discard the src so easily here, as we might not be able to get it back again\n     else\n         code = ci::CodeInstance\n     end"
    },
    {
      "sha": "f7cb7953f88f70fecd73dcb7e1c6d96cda457bea",
      "filename": "Compiler/src/ssair/legacy.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fssair%2Flegacy.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fssair%2Flegacy.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2Flegacy.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -13,7 +13,7 @@ function inflate_ir!(ci::CodeInfo, mi::MethodInstance)\n     if ci.slottypes === nothing\n         argtypes = va_process_argtypes(fallback_lattice,\n             matching_cache_argtypes(fallback_lattice, mi),\n-            ci.nargs, ci.isva)\n+            ci.nargs, ci.isva, mi)\n     else\n         argtypes = ci.slottypes[1:ci.nargs]\n     end"
    },
    {
      "sha": "0a739815f4ac9ab6c7151259bbea5233e97a7660",
      "filename": "Compiler/src/ssair/passes.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fssair%2Fpasses.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fssair%2Fpasses.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2Fpasses.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -1586,7 +1586,10 @@ function try_inline_finalizer!(ir::IRCode, argexprs::Vector{Any}, idx::Int,\n             add_inlining_edge!(et, code)\n             return true\n         end\n-        src = @atomic :monotonic code.inferred\n+        # COMBAK: this has awkward and unreliable global cache effects, but\n+        # this doesn't respect the bottom-up inliner order so we do not have\n+        # CallInfo anymore. See `handle_finalizer_call!` too.\n+        src = ci_get_source(inlining.interp, code)\n     else\n         return false\n     end\n@@ -1729,7 +1732,7 @@ function try_resolve_finalizer!(ir::IRCode, alloc_idx::Int, finalizer_idx::Int,\n             if inline::Bool && try_inline_finalizer!(ir, argexprs, loc, ci, info, inlining, attach_after)\n                 # the finalizer body has been inlined\n             else\n-                newinst = add_flag(NewInstruction(Expr(:invoke, ci, argexprs...), Nothing), flag)\n+                newinst = add_flag(NewInstruction(Expr(:invoke, ci, argexprs...), Any), flag)\n                 insert_node!(ir, loc, newinst, attach_after)\n             end\n         end"
    },
    {
      "sha": "2947a381be959472e99bd8a3083d11a668c0c359",
      "filename": "Compiler/src/ssair/show.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fssair%2Fshow.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fssair%2Fshow.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2Fshow.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -1154,7 +1154,7 @@ function Base.show(io::IO, mi_info::Timings.InferenceFrameInfo)\n             show_tuple_as_call(io, def.name, mi.specTypes; argnames, qualified=true)\n         end\n     else\n-        di = mi.cache.inferred.debuginfo\n+        di = mi.cache.debuginfo\n         file, line = debuginfo_firstline(di)\n         file = string(file)\n         line = isempty(file) || line < 0 ? \"<unknown>\" : \"$file:$line\""
    },
    {
      "sha": "5a2188060e6e58ed552444985f097b8e5e1cedce",
      "filename": "Compiler/src/stmtinfo.jl",
      "status": "modified",
      "additions": 32,
      "deletions": 50,
      "changes": 82,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fstmtinfo.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Fstmtinfo.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fstmtinfo.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -24,6 +24,23 @@ end\n struct NoCallInfo <: CallInfo end\n add_edges_impl(::Vector{Any}, ::NoCallInfo) = nothing\n \n+# InferredCallResult is defined in types.jl so that InferenceResult can inherit from it\n+\n+struct ConcreteResult <: InferredCallResult\n+    edge::CodeInstance\n+    effects::Effects\n+    result\n+    ConcreteResult(edge::CodeInstance, effects::Effects) = new(edge, effects)\n+    ConcreteResult(edge::CodeInstance, effects::Effects, @nospecialize val) = new(edge, effects, val)\n+end\n+\n+struct SemiConcreteResult <: InferredCallResult\n+    edge::CodeInstance\n+    ir::IRCode\n+    effects::Effects\n+    spec_info::SpecInfo\n+end\n+\n \"\"\"\n     info::MethodMatchInfo <: CallInfo\n \n@@ -38,10 +55,12 @@ struct MethodMatchInfo <: CallInfo\n     atype\n     fullmatch::Bool\n     edges::Vector{Union{Nothing,CodeInstance}}\n+    call_results::Vector{Union{Nothing,InferredCallResult}}\n     function MethodMatchInfo(\n         results::MethodLookupResult, mt::MethodTable, @nospecialize(atype), fullmatch::Bool)\n         edges = fill!(Vector{Union{Nothing,CodeInstance}}(undef, length(results)), nothing)\n-        return new(results, mt, atype, fullmatch, edges)\n+        call_results = fill!(Vector{Union{Nothing,InferredCallResult}}(undef, length(results)), nothing)\n+        return new(results, mt, atype, fullmatch, edges, call_results)\n     end\n end\n add_edges_impl(edges::Vector{Any}, info::MethodMatchInfo) = _add_edges_impl(edges, info)\n@@ -137,7 +156,7 @@ function add_one_edge!(edges::Vector{Any}, edge::CodeInstance)\n end\n nsplit_impl(::MethodMatchInfo) = 1\n getsplit_impl(info::MethodMatchInfo, idx::Int) = (@assert idx == 1; info.results)\n-getresult_impl(::MethodMatchInfo, ::Int) = nothing\n+getresult_impl(info::MethodMatchInfo, idx::Int) = info.call_results[idx]\n \n \"\"\"\n     info::UnionSplitInfo <: CallInfo\n@@ -157,52 +176,16 @@ _add_edges_impl(edges::Vector{Any}, info::UnionSplitInfo, mi_edge::Bool=false) =\n     for split in info.split; _add_edges_impl(edges, split, mi_edge); end\n nsplit_impl(info::UnionSplitInfo) = length(info.split)\n getsplit_impl(info::UnionSplitInfo, idx::Int) = getsplit(info.split[idx], 1)\n-getresult_impl(::UnionSplitInfo, ::Int) = nothing\n-\n-abstract type ConstResult end\n-\n-struct ConstPropResult <: ConstResult\n-    result::InferenceResult\n-end\n-\n-struct ConcreteResult <: ConstResult\n-    edge::CodeInstance\n-    effects::Effects\n-    result\n-    ConcreteResult(edge::CodeInstance, effects::Effects) = new(edge, effects)\n-    ConcreteResult(edge::CodeInstance, effects::Effects, @nospecialize val) = new(edge, effects, val)\n-end\n-\n-struct SemiConcreteResult <: ConstResult\n-    edge::CodeInstance\n-    ir::IRCode\n-    effects::Effects\n-    spec_info::SpecInfo\n-end\n-\n-# XXX Technically this does not represent a result of constant inference, but rather that of\n-#     regular edge inference. It might be more appropriate to rename `ConstResult` and\n-#     `ConstCallInfo` to better reflect the fact that they represent either of local or\n-#     volatile inference result.\n-struct VolatileInferenceResult <: ConstResult\n-    inf_result::InferenceResult\n-end\n-\n-\"\"\"\n-    info::ConstCallInfo <: CallInfo\n-\n-The precision of this call was improved using constant information.\n-In addition to the original call information `info.call`, this info also keeps the results\n-of constant inference `info.results::Vector{Union{Nothing,ConstResult}}`.\n-\"\"\"\n-struct ConstCallInfo <: CallInfo\n-    call::Union{MethodMatchInfo,UnionSplitInfo}\n-    results::Vector{Union{Nothing,ConstResult}}\n+function getresult_impl(info::UnionSplitInfo, idx::Int)\n+    for split in info.split\n+        n = length(split.call_results)\n+        if idx \u2264 n\n+            return split.call_results[idx]\n+        else\n+            idx -= n\n+        end\n+    end\n end\n-add_edges_impl(edges::Vector{Any}, info::ConstCallInfo) = add_edges!(edges, info.call)\n-nsplit_impl(info::ConstCallInfo) = nsplit(info.call)\n-getsplit_impl(info::ConstCallInfo, idx::Int) = getsplit(info.call, idx)\n-getresult_impl(info::ConstCallInfo, idx::Int) = info.results[idx]\n \n \"\"\"\n     info::MethodResultPure <: CallInfo\n@@ -291,7 +274,7 @@ Optionally keeps `info.result::InferenceResult` that keeps constant information.\n struct InvokeCallInfo <: CallInfo\n     edge::Union{Nothing,CodeInstance}\n     match::MethodMatch\n-    result::Union{Nothing,ConstResult}\n+    result::Union{Nothing,InferredCallResult}\n     atype # ::Type\n end\n add_edges_impl(edges::Vector{Any}, info::InvokeCallInfo) =\n@@ -397,7 +380,6 @@ getsplit_impl(info::InvokeCallInfo, idx::Int) = (@assert idx == 1; MethodLookupR\n     WorldRange(typemin(UInt), typemax(UInt)), false))\n getresult_impl(info::InvokeCallInfo, idx::Int) = (@assert idx == 1; info.result)\n \n-\n \"\"\"\n     info::OpaqueClosureCallInfo\n \n@@ -408,7 +390,7 @@ Optionally keeps `info.result::InferenceResult` that keeps constant information.\n struct OpaqueClosureCallInfo <: CallInfo\n     edge::Union{Nothing,CodeInstance}\n     match::MethodMatch\n-    result::Union{Nothing,ConstResult}\n+    result::Union{Nothing,InferredCallResult}\n end\n function add_edges_impl(edges::Vector{Any}, info::OpaqueClosureCallInfo)\n     edge = info.edge"
    },
    {
      "sha": "98c062ff5b6ca0893cb7e58b72785429af0ed830",
      "filename": "Compiler/src/tfuncs.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Ftfuncs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Ftfuncs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftfuncs.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -3186,7 +3186,7 @@ function abstract_applicable(interp::AbstractInterpreter, argtypes::Vector{Any},\n             rt = Bool # too many matches to analyze\n         else\n             (; valid_worlds, applicable) = matches\n-            update_valid_age!(sv, valid_worlds)\n+            update_valid_age!(sv, get_inference_world(interp), valid_worlds)\n             napplicable = length(applicable)\n             if napplicable == 0\n                 rt = Const(false) # never any matches\n@@ -3228,7 +3228,7 @@ function _hasmethod_tfunc(interp::AbstractInterpreter, argtypes::Vector{Any}, sv\n         types = rewrap_unionall(Tuple{ft, unwrapped.parameters...}, types)::Type\n     end\n     match, valid_worlds = findsup(types, method_table(interp))\n-    update_valid_age!(sv, valid_worlds)\n+    update_valid_age!(sv, get_inference_world(interp), valid_worlds)\n     if match === nothing\n         rt = Const(false)\n         vresults = MethodLookupResult(Any[], valid_worlds, true)"
    },
    {
      "sha": "2ae0c627b1b4d9332fe5051a4fb9a030e9775b86",
      "filename": "Compiler/src/typeinfer.jl",
      "status": "modified",
      "additions": 315,
      "deletions": 173,
      "changes": 488,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Ftypeinfer.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Ftypeinfer.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftypeinfer.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -17,7 +17,6 @@ using ..Compiler: -, +, :, Vector, length, first, empty!, push!, pop!, @inline,\n # What we record for any given frame we infer during type inference.\n struct InferenceFrameInfo\n     mi::Core.MethodInstance\n-    world::UInt64\n     sptypes::Vector{Compiler.VarState}\n     slottypes::Vector{Any}\n     nargs::Int\n@@ -26,7 +25,6 @@ end\n function _typeinf_identifier(frame::Compiler.InferenceState)\n     mi_info = InferenceFrameInfo(\n         frame.linfo,\n-        frame_world(sv),\n         copy(frame.sptypes),\n         copy(frame.slottypes),\n         length(frame.result.argtypes),\n@@ -75,7 +73,7 @@ start the ROOT() timer again. `ROOT()` measures all time spent _outside_ inferen\n function reset_timings() end\n push!(_timings, Timing(\n     # The MethodInstance for ROOT(), and default empty values for other fields.\n-    InferenceFrameInfo(ROOTmi, 0x0, Compiler.VarState[], Any[Core.Const(ROOT)], 1),\n+    InferenceFrameInfo(ROOTmi, Compiler.VarState[], Any[Core.Const(ROOT)], 1),\n     _time_ns()))\n function close_current_timer() end\n function enter_new_timer(frame) end\n@@ -104,31 +102,51 @@ end\n function finish!(interp::AbstractInterpreter, caller::InferenceState, validation_world::UInt, time_before::UInt64)\n     result = caller.result\n     edges = result_edges(interp, caller)\n-    #@assert last(result.valid_worlds) <= get_world_counter() || isempty(edges)\n-    if caller.cache_mode === CACHE_MODE_LOCAL\n-        @assert !isdefined(result, :ci)\n-        result.src = transform_result_for_local_cache(interp, result, edges)\n-    elseif isdefined(result, :ci)\n+    valid_worlds = caller.valid_worlds\n+    min_world, max_world = first(valid_worlds), last(valid_worlds)\n+    result.valid_worlds = valid_worlds\n+    caller.src.min_world = min_world\n+    caller.src.max_world = max_world\n+    #@assert max_world <= get_world_counter() || isempty(edges)\n+    if isdefined(result, :ci)\n         ci = result.ci\n         mi = result.linfo\n-        # if we aren't cached, we don't need this edge\n-        # but our caller might, so let's just make it anyways\n-        if last(result.valid_worlds) >= validation_world\n-            # if we can record all of the backedges in the global reverse-cache,\n-            # we can now widen our applicability in the global cache too\n-            store_backedges(ci, edges)\n+        result_type = result.result\n+        result_type isa LimitedAccuracy && (result_type = result_type.typ)\n+        @assert !(result_type === nothing)\n+        const_flag = is_result_constabi_eligible(result)\n+        if isa(result_type, Const)\n+            rettype_const = result_type.val\n+            const_flags = const_flag ? 0x3 : 0x2\n+        elseif isa(result_type, PartialOpaque)\n+            rettype_const = result_type\n+            const_flags = 0x2\n+        elseif isconstType(result_type)\n+            rettype_const = result_type.parameters[1]\n+            const_flags = 0x2\n+        elseif isa(result_type, PartialStruct)\n+            rettype_const = (_getundefs(result_type), result_type.fields)\n+            const_flags = 0x2\n+        elseif isa(result_type, InterConditional)\n+            rettype_const = result_type\n+            const_flags = 0x2\n+        elseif isa(result_type, InterMustAlias)\n+            rettype_const = result_type\n+            const_flags = 0x2\n+        else\n+            rettype_const = nothing\n+            const_flags = 0x0\n         end\n         inferred_result = nothing\n-        uncompressed = result.src\n-        const_flag = is_result_constabi_eligible(result)\n         debuginfo = nothing\n+        const_flag = is_result_constabi_eligible(result)\n         discard_src = caller.cache_mode === CACHE_MODE_NULL || const_flag\n         if !discard_src\n             inferred_result = transform_result_for_cache(interp, result, edges)\n             if inferred_result !== nothing\n-                uncompressed = inferred_result\n+                result.src = inferred_result\n                 debuginfo = get_debuginfo(inferred_result)\n-                # Inlining may fast-path the global cache via `VolatileInferenceResult`, so store it back here\n+                # Inlining may fast-path the global cache via InferenceResult, so store it back here\n                 result.src = inferred_result\n             else\n                 if isa(result.src, OptimizationState)\n@@ -145,50 +163,79 @@ function finish!(interp::AbstractInterpreter, caller::InferenceState, validation\n                     resize!(inferred_result.slotnames, nslots)\n                 end\n                 inferred_result = maybe_compress_codeinfo(interp, mi, inferred_result)\n-                result.is_src_volatile = false\n             elseif ci.owner === nothing\n                 # The global cache can only handle objects that codegen understands\n                 inferred_result = nothing\n             end\n+        else\n+            result.src = nothing\n         end\n         if debuginfo === nothing\n             debuginfo = DebugInfo(mi)\n         end\n-        min_world, max_world = first(result.valid_worlds), last(result.valid_worlds)\n+        # if we aren't cached, we don't need this edge\n+        # but our caller might, so let's just make it anyways\n+        if max_world >= validation_world\n+            # if we can record all of the backedges in the global reverse-cache,\n+            # we can now widen our applicability in the global cache too\n+            store_backedges(ci, edges)\n+        end\n         ipo_effects = encode_effects(result.ipo_effects)\n         time_now = _time_ns()\n         time_self_ns = caller.time_self_ns + (time_now - time_before)\n         time_total = (time_now - caller.time_start - caller.time_paused) * 1e-9\n+        ccall(:jl_fill_codeinst, Cvoid, (Any, Any, Any, Any, Int32, UInt, UInt, UInt32, Any, Any, Any),\n+            ci, widenconst(result_type), widenconst(result.exc_result), rettype_const, const_flags,\n+            min_world, max_world,\n+            ipo_effects, result.analysis_results, debuginfo, edges)\n         ccall(:jl_update_codeinst, Cvoid, (Any, Any, Int32, UInt, UInt, UInt32, Any, Float64, Float64, Float64, Any, Any),\n             ci, inferred_result, const_flag, min_world, max_world, ipo_effects,\n             result.analysis_results, time_total, caller.time_caches, time_self_ns * 1e-9, debuginfo, edges)\n-        if is_cached(caller) # CACHE_MODE_GLOBAL\n-            cache_result!(interp, result, ci)\n+    elseif caller.cache_mode === CACHE_MODE_LOCAL\n+        result.src = transform_result_for_local_cache(interp, result)\n+    end\n+    nothing\n+end\n+\n+function promotecache!(interp::AbstractInterpreter, caller::InferenceState)\n+    result = caller.result\n+    if isdefined(result, :ci)\n+        ci = result.ci\n+        mi = result.linfo\n+        if is_already_cached(interp, result)\n+            # convert to a local cache or insert it now globally\n+            engine_reject(interp, ci)\n+            caller.cache_mode = CACHE_MODE_LOCAL\n+        end\n+        if !iszero(caller.cache_mode & CACHE_MODE_GLOBAL)\n+            code_cache(interp)[mi] = ci\n         end\n         engine_reject(interp, ci)\n         codegen = codegen_cache(interp)\n-        if !discard_src && codegen !== nothing && (isa(uncompressed, CodeInfo) || isa(uncompressed, OptimizationState))\n+        if codegen !== nothing\n+            uncompressed = result.src\n             if isa(uncompressed, OptimizationState)\n-                uncompressed = ir_to_codeinf!(uncompressed, edges)\n+                uncompressed = ir_to_codeinf!(uncompressed, ci.edges)\n+                result.src = uncompressed\n             end\n-            # record that the caller could use this result to generate code when required, if desired, to avoid repeating n^2 work\n-            codegen[ci] = uncompressed\n-            if bootstrapping_compiler && inferred_result == nothing\n-                # This is necessary to get decent bootstrapping performance\n-                # when compiling the compiler to inject everything eagerly\n-                # where codegen can start finding and using it right away\n-                if mi.def isa Method && isa_compileable_sig(mi) && is_cached(caller)\n-                    ccall(:jl_add_codeinst_to_jit, Cvoid, (Any, Any), ci, uncompressed)\n+            if isa(uncompressed, CodeInfo)\n+                # record that the caller could use this result to generate code when required, if desired, to avoid repeating n^2 work\n+                codegen[ci] = uncompressed\n+                if bootstrapping_compiler && !(ci.inferred isa MaybeCompressed)\n+                    # This is necessary to get decent bootstrapping performance\n+                    # when compiling the compiler to inject everything eagerly\n+                    # where codegen can start finding and using it right away\n+                    if mi.def isa Method && isa_compileable_sig(mi) && is_cached(caller)\n+                        ccall(:jl_add_codeinst_to_jit, Cvoid, (Any, Any), ci, uncompressed)\n+                    end\n                 end\n             end\n         end\n     end\n-    return nothing\n-end\n-\n-function cache_result!(interp::AbstractInterpreter, result::InferenceResult, ci::CodeInstance)\n-    mi = result.linfo\n-    code_cache(interp)[mi] = ci\n+    if !iszero(caller.cache_mode & CACHE_MODE_LOCAL)\n+        push!(get_inference_cache(interp), result)\n+    end\n+    nothing\n end\n \n function finish!(interp::AbstractInterpreter, mi::MethodInstance, ci::CodeInstance, src::CodeInfo)\n@@ -223,16 +270,20 @@ function finish!(interp::AbstractInterpreter, mi::MethodInstance, ci::CodeInstan\n     return nothing\n end\n \n-function finish_nocycle(::AbstractInterpreter, frame::InferenceState, time_before::UInt64)\n+function finish_nocycle(interp::AbstractInterpreter, frame::InferenceState, time_before::UInt64)\n     opt_cache = IdDict{MethodInstance,CodeInstance}()\n-    finishinfer!(frame, frame.interp, frame.cycleid, opt_cache)\n+    finishinfer!(frame, interp, frame.cycleid, opt_cache)\n     opt = frame.result.src\n-    if opt isa OptimizationState # implies `may_optimize(caller.interp) === true`\n-        optimize(frame.interp, opt, frame.result)\n+    if opt isa OptimizationState # implies `may_optimize(interp) === true`\n+        optimize(interp, opt, frame.result)\n+        # check the valid_worlds hasn't been narrowed by added :invoke edges\n+        valid_worlds = intersect(frame.valid_worlds, compute_recursive_worlds(opt.inlining.edges))\n+        update_valid_age!(frame, get_inference_world(interp), valid_worlds)\n     end\n     empty!(opt_cache)\n     validation_world = get_world_counter()\n-    finish!(frame.interp, frame, validation_world, time_before)\n+    finish!(interp, frame, validation_world, time_before)\n+    promotecache!(interp, frame)\n     if isdefined(frame.result, :ci)\n         # After validation, under the world_counter_lock, set max_world to typemax(UInt) for all dependencies\n         # (recursively). From that point onward the ordinary backedge mechanism is responsible for maintaining\n@@ -247,7 +298,8 @@ function finish_nocycle(::AbstractInterpreter, frame::InferenceState, time_befor\n     return nothing\n end\n \n-function finish_cycle(::AbstractInterpreter, frames::Vector{AbsIntState}, cycleid::Int, time_before::UInt64)\n+function finish_cycle(interp::AbstractInterpreter, frames::Vector{AbsIntState}, cycleid::Int, time_before::UInt64)\n+    world = get_inference_world(interp)\n     cycle_valid_worlds = WorldRange()\n     cycle_valid_effects = EFFECTS_TOTAL\n     for frameid = cycleid:length(frames)\n@@ -257,13 +309,13 @@ function finish_cycle(::AbstractInterpreter, frames::Vector{AbsIntState}, cyclei\n         # all frames in the cycle should have the same bits of `valid_worlds` and `effects`\n         # that are simply the intersection of each partial computation, without having\n         # dependencies on each other (unlike rt and exct)\n-        cycle_valid_worlds = intersect(cycle_valid_worlds, caller.world.valid_worlds)\n+        cycle_valid_worlds = intersect(cycle_valid_worlds, caller.valid_worlds)\n         cycle_valid_effects = merge_effects(cycle_valid_effects, caller.ipo_effects)\n     end\n     opt_cache = IdDict{MethodInstance,CodeInstance}()\n     for frameid = cycleid:length(frames)\n         caller = frames[frameid]::InferenceState\n-        adjust_cycle_frame!(caller, cycle_valid_worlds, cycle_valid_effects)\n+        adjust_cycle_frame!(caller, world, cycle_valid_worlds, cycle_valid_effects)\n         finishinfer!(caller, caller.interp, cycleid, opt_cache)\n         time_now = _time_ns()\n         caller.time_self_ns += (time_now - time_before)\n@@ -276,6 +328,7 @@ function finish_cycle(::AbstractInterpreter, frames::Vector{AbsIntState}, cyclei\n         opt = caller.result.src\n         if opt isa OptimizationState # implies `may_optimize(caller.interp) === true`\n             optimize(caller.interp, opt, caller.result)\n+            cycle_valid_worlds = intersect(cycle_valid_worlds, compute_recursive_worlds(opt.inlining.edges))\n             time_now = _time_ns()\n             caller.time_self_ns += (time_now - time_before)\n             time_before = time_now\n@@ -295,6 +348,7 @@ function finish_cycle(::AbstractInterpreter, frames::Vector{AbsIntState}, cyclei\n         caller.time_start = time_start\n         caller.time_caches = time_caches\n         caller.time_paused = time_paused\n+        update_valid_age!(caller, world, cycle_valid_worlds)\n         finish!(caller.interp, caller, validation_world, time_before)\n         if isdefined(caller.result, :ci)\n             push!(cis, caller.result.ci)\n@@ -305,6 +359,11 @@ function finish_cycle(::AbstractInterpreter, frames::Vector{AbsIntState}, cyclei\n         parent.time_caches += time_caches\n         parent.time_paused += time_paused\n     end\n+    # After everything is finished, promote the work into visible caches\n+    for frameid = cycleid:length(frames)\n+        caller = frames[frameid]::InferenceState\n+        promotecache!(caller.interp, caller)\n+    end\n     # After validation, under the world_counter_lock, set max_world to typemax(UInt) for all dependencies\n     # (recursively). From that point onward the ordinary backedge mechanism is responsible for maintaining\n     # validity.\n@@ -313,8 +372,8 @@ function finish_cycle(::AbstractInterpreter, frames::Vector{AbsIntState}, cyclei\n     return nothing\n end\n \n-function adjust_cycle_frame!(sv::InferenceState, cycle_valid_worlds::WorldRange, cycle_valid_effects::Effects)\n-    update_valid_age!(sv, cycle_valid_worlds)\n+function adjust_cycle_frame!(sv::InferenceState, world::UInt, cycle_valid_worlds::WorldRange, cycle_valid_effects::Effects)\n+    update_valid_age!(sv, world, cycle_valid_worlds)\n     sv.ipo_effects = cycle_valid_effects\n     # traverse the callees of this cycle that are tracked within `sv.cycle_backedges`\n     # and adjust their statements so that they are consistent with the new `cycle_valid_effects`\n@@ -399,7 +458,8 @@ function inline_cost_model(interp::AbstractInterpreter, result::InferenceResult,\n     end\n end\n \n-function transform_result_for_local_cache(interp::AbstractInterpreter, result::InferenceResult, edges::SimpleVector)\n+function transform_result_for_local_cache(interp::AbstractInterpreter, result::InferenceResult)\n+    ## XXX: this must perform the exact same operations as transform_result_for_cache to avoid introducing soundness bugs\n     if is_result_constabi_eligible(result)\n         return nothing\n     end\n@@ -418,7 +478,7 @@ function transform_result_for_cache(interp::AbstractInterpreter, result::Inferen\n     if isa(src, OptimizationState)\n         opt = src\n         inlining_cost = compute_inlining_cost(interp, result, opt.optresult)\n-        discard_optimized_result(interp, opt, inlining_cost) && return nothing\n+        discard_optimized_result(interp, inlining_cost) && return nothing\n         src = ir_to_codeinf!(opt)\n     end\n     if isa(src, CodeInfo)\n@@ -432,7 +492,7 @@ function transform_result_for_cache(interp::AbstractInterpreter, result::Inferen\n     return src\n end\n \n-function discard_optimized_result(interp::AbstractInterpreter, _#=::OptimizationState=#, inlining_cost#=::InlineCostType=#)\n+function discard_optimized_result(interp::AbstractInterpreter, inlining_cost::InlineCostType)\n     may_discard_trees(interp) || return false\n     return inlining_cost == MAX_INLINE_COST\n end\n@@ -443,6 +503,7 @@ function maybe_compress_codeinfo(interp::AbstractInterpreter, mi::MethodInstance\n     can_discard_trees = may_discard_trees(interp)\n     cache_the_tree = !can_discard_trees || is_inlineable(ci)\n     cache_the_tree || return nothing\n+    # TODO: do we want to augment edges here with any :invoke targets that we got from inlining (such that we didn't have a direct edge to it already)?\n     may_compress(interp) && return ccall(:jl_compress_ir, String, (Any, Any), def, ci)\n     return ci\n end\n@@ -593,14 +654,16 @@ function finishinfer!(me::InferenceState, interp::AbstractInterpreter, cycleid::\n         end\n     end\n     result = me.result\n-    result.valid_worlds = me.world.valid_worlds\n     result.result = bestguess\n     ipo_effects = result.ipo_effects = me.ipo_effects = adjust_effects(me)\n     result.exc_result = me.exc_bestguess = refine_exception_type(me.exc_bestguess, ipo_effects)\n-    me.src.rettype = widenconst(ignorelimited(bestguess))\n-    me.src.ssaflags = me.ssaflags\n-    me.src.min_world = first(me.world.valid_worlds)\n-    me.src.max_world = last(me.world.valid_worlds)\n+    src = me.src\n+    src.rettype = widenconst(ignorelimited(bestguess))\n+    src.ssaflags = me.ssaflags\n+    valid_worlds = me.valid_worlds\n+    min_world, max_world = first(valid_worlds), last(valid_worlds)\n+    src.min_world = min_world\n+    src.max_world = max_world\n     istoplevel = !(me.linfo.def isa Method)\n     istoplevel || compute_edges!(me) # don't add backedges to toplevel method instance\n \n@@ -614,7 +677,7 @@ function finishinfer!(me::InferenceState, interp::AbstractInterpreter, cycleid::\n         result.src = nothing\n         result.tombstone = true\n         me.cache_mode = CACHE_MODE_NULL\n-        set_inlineable!(me.src, false)\n+        set_inlineable!(src, false)\n     else\n         # annotate fulltree with type information,\n         # either because we are the outermost code, or we might use this later\n@@ -628,52 +691,25 @@ function finishinfer!(me::InferenceState, interp::AbstractInterpreter, cycleid::\n         if doopt\n             result.src = OptimizationState(me, interp, opt_cache)\n         else\n-            result.src = me.src # for reflection etc.\n+            result.src = src # for reflection etc.\n         end\n     end\n \n-    maybe_validate_code(me.linfo, me.src, \"inferred\")\n+    maybe_validate_code(me.linfo, src, \"inferred\")\n \n-    # finish populating inference results into the CodeInstance if possible, and maybe cache that globally for use elsewhere\n+    # check global cache again for :invoke use, and put in the opt_cache if it wasn't there at this time\n     if isdefined(result, :ci)\n-        result_type = result.result\n-        result_type isa LimitedAccuracy && (result_type = result_type.typ)\n-        @assert !(result_type === nothing)\n-        if isa(result_type, Const)\n-            rettype_const = result_type.val\n-            const_flags = is_result_constabi_eligible(result) ? 0x3 : 0x2\n-        elseif isa(result_type, PartialOpaque)\n-            rettype_const = result_type\n-            const_flags = 0x2\n-        elseif isconstType(result_type)\n-            rettype_const = result_type.parameters[1]\n-            const_flags = 0x2\n-        elseif isa(result_type, PartialStruct)\n-            rettype_const = (_getundefs(result_type), result_type.fields)\n-            const_flags = 0x2\n-        elseif isa(result_type, InterConditional)\n-            rettype_const = result_type\n-            const_flags = 0x2\n-        elseif isa(result_type, InterMustAlias)\n-            rettype_const = result_type\n-            const_flags = 0x2\n-        else\n-            rettype_const = nothing\n-            const_flags = 0x0\n-        end\n-\n-        di = nothing\n-        edges = empty_edges # `edges` will be updated within `finish!`\n         ci = result.ci\n-        min_world, max_world = first(result.valid_worlds), last(result.valid_worlds)\n-        ccall(:jl_fill_codeinst, Cvoid, (Any, Any, Any, Any, Int32, UInt, UInt, UInt32, Any, Any, Any),\n-            ci, widenconst(result_type), widenconst(result.exc_result), rettype_const, const_flags,\n-            min_world, max_world,\n-            encode_effects(result.ipo_effects), result.analysis_results, di, edges)\n-        if is_cached(me) # CACHE_MODE_GLOBAL\n-            already_cached = is_already_cached(me.interp, result, ci)\n-            if already_cached\n-                me.cache_mode = CACHE_MODE_VOLATILE\n+        ipo_effects = encode_effects(result.ipo_effects)\n+        # populate a few fields that won't change again (and are inspected by optimization)\n+        @atomic :monotonic ci.ipo_purity_bits = ipo_effects\n+        ci.analysis_results = result.analysis_results\n+        if !iszero(me.cache_mode & CACHE_MODE_GLOBAL)\n+            ci = result.ci\n+            if is_already_cached(me.interp, result)\n+                # convert to a local cache\n+                engine_reject(interp, ci)\n+                me.cache_mode = CACHE_MODE_LOCAL\n             else\n                 opt_cache[result.linfo] = ci\n             end\n@@ -682,11 +718,11 @@ function finishinfer!(me::InferenceState, interp::AbstractInterpreter, cycleid::\n     nothing\n end\n \n-function is_already_cached(interp::AbstractInterpreter, result::InferenceResult, ::CodeInstance)\n+function is_already_cached(interp::AbstractInterpreter, result::InferenceResult)\n     # check if the existing linfo metadata is also sufficient to describe the current inference result\n     # to decide if it is worth caching this right now\n     mi = result.linfo\n-    cache = WorldView(code_cache(interp), result.valid_worlds)\n+    cache = code_cache(interp, result.valid_worlds)\n     if haskey(cache, mi)\n         # n.b.: accurate edge representation might cause the CodeInstance for this to be constructed later\n         @assert isdefined(cache[mi], :inferred)\n@@ -788,6 +824,18 @@ function compute_edges!(sv::InferenceState)\n     nothing\n end\n \n+function compute_recursive_worlds(edges::Vector{Any})\n+    range = WorldRange(typemin(UInt), typemax(UInt))\n+    for edge in edges\n+        if edge isa CodeInstance\n+            wr = WorldRange(edge.min_world, edge.max_world)\n+            iszero(last(wr.max_world)) && continue # part of the current cycle, not yet valid\n+            range = intersect(range, wr)\n+        end\n+    end\n+    return range\n+end\n+\n function record_slot_assign!(sv::InferenceState)\n     # look at all assignments to slots\n     # and union the set of types stored there\n@@ -954,20 +1002,49 @@ end\n ipo_effects(code::CodeInstance) = decode_effects(code.ipo_purity_bits)\n \n # return cached result of regular inference\n-function return_cached_result(interp::AbstractInterpreter, method::Method, codeinst::CodeInstance, caller::AbsIntState, edgecycle::Bool, edgelimited::Bool)\n+function return_cached_result(interp::AbstractInterpreter, method::Method, codeinst::CodeInstance, @nospecialize(src), caller::AbsIntState, edgecycle::Bool, edgelimited::Bool)\n     rt = cached_return_type(codeinst)\n     exct = codeinst.exctype\n     effects = ipo_effects(codeinst)\n-    update_valid_age!(caller, WorldRange(min_world(codeinst), max_world(codeinst)))\n+    valid_worlds = WorldRange(min_world(codeinst), max_world(codeinst))\n+    if src !== nothing\n+        # Create an InferenceResult to preserve cached source lookup\n+        inf_result = InferenceResult(codeinst.def, typeinf_lattice(interp))\n+        inf_result.result = rt\n+        inf_result.exc_result = exct\n+        inf_result.src = src::CodeInfo\n+        inf_result.ipo_effects = effects\n+        inf_result.ci_as_edge = inf_result.ci = codeinst\n+        inf_result.valid_worlds = valid_worlds\n+        push!(get_inference_cache(interp), inf_result)\n+    else\n+        inf_result = nothing\n+    end\n+    update_valid_age!(caller, get_inference_world(interp), valid_worlds)\n+    caller.time_caches += reinterpret(Float16, codeinst.time_infer_total)\n+    caller.time_caches += reinterpret(Float16, codeinst.time_infer_cache_saved)\n+    return Future(MethodCallResult(interp, caller, method, rt, exct, effects, codeinst, edgecycle, edgelimited, inf_result))\n+end\n+\n+function return_cached_result(interp::AbstractInterpreter, method::Method, inf_result::InferenceResult, @nospecialize(src), caller::AbsIntState, edgecycle::Bool, edgelimited::Bool)\n+    rt = inf_result.result\n+    exct = inf_result.exc_result\n+    if src !== nothing\n+        inf_result.src = src::CodeInfo\n+    end\n+    effects = inf_result.ipo_effects\n+    codeinst = inf_result.ci\n+    update_valid_age!(caller, get_inference_world(interp), inf_result.valid_worlds)\n     caller.time_caches += reinterpret(Float16, codeinst.time_infer_total)\n     caller.time_caches += reinterpret(Float16, codeinst.time_infer_cache_saved)\n-    return Future(MethodCallResult(interp, caller, method, rt, exct, effects, codeinst, edgecycle, edgelimited))\n+    return Future(MethodCallResult(interp, caller, method, rt, exct, effects, codeinst, edgecycle, edgelimited, inf_result))\n end\n \n+\n function MethodCallResult(::AbstractInterpreter, sv::AbsIntState, method::Method,\n                           @nospecialize(rt), @nospecialize(exct), effects::Effects,\n                           edge::Union{Nothing,CodeInstance}, edgecycle::Bool, edgelimited::Bool,\n-                          volatile_inf_result::Union{Nothing,VolatileInferenceResult}=nothing)\n+                          call_result::Union{Nothing,InferredCallResult} = nothing)\n     if edge === nothing\n         edgecycle = edgelimited = true\n     end\n@@ -990,32 +1067,38 @@ function MethodCallResult(::AbstractInterpreter, sv::AbsIntState, method::Method\n         end\n     end\n \n-    return MethodCallResult(rt, exct, effects, edge, edgecycle, edgelimited, volatile_inf_result)\n+    return MethodCallResult(rt, exct, effects, edge, edgecycle, edgelimited, call_result)\n+end\n+\n+function codeinst_edges_sub(existing_edge::CodeInstance, min_world::UInt, max_world::UInt, edges::SimpleVector)\n+    # return if the existing edge has more restrictions than the other arguments (more edges and narrower worlds)\n+    if existing_edge.min_world >= min_world &&\n+       existing_edge.max_world <= max_world &&\n+       existing_edge.edges == edges\n+        return true\n+    end\n+    return false\n end\n \n # allocate a dummy `edge::CodeInstance` to be added by `add_edges!`, reusing an existing_edge if possible\n # TODO: fill this in fully correctly (currently IPO info such as effects and return types are lost)\n function codeinst_as_edge(interp::AbstractInterpreter, sv::InferenceState, @nospecialize existing_edge)\n-    mi = sv.linfo\n-    min_world, max_world = first(sv.world.valid_worlds), last(sv.world.valid_worlds)\n+    edges = Core.svec(sv.edges...)\n+    min_world, max_world = first(sv.valid_worlds), last(sv.valid_worlds)\n     if max_world >= get_world_counter()\n         max_world = typemax(UInt)\n     end\n-    edges = Core.svec(sv.edges...)\n-    if existing_edge isa CodeInstance\n-        # return an existing_edge, if the existing edge has more restrictions already (more edges and narrower worlds)\n-        if existing_edge.min_world >= min_world &&\n-           existing_edge.max_world <= max_world &&\n-           existing_edge.edges == edges\n-            return existing_edge\n-        end\n+    if existing_edge isa CodeInstance && codeinst_edges_sub(existing_edge, min_world, max_world, edges)\n+        return existing_edge\n     end\n+    mi = sv.linfo\n     ci = CodeInstance(mi, cache_owner(interp), Any, Any, nothing, nothing, zero(Int32),\n         min_world, max_world, zero(UInt32), nothing, nothing, edges)\n     if max_world == typemax(UInt)\n         # if we can record all of the backedges in the global reverse-cache,\n         # we can now widen our applicability in the global cache too\n-        # TODO: this should probably come after we decide this edge is even useful\n+        # XXX: this should come after we decide this edge is even useful\n+        # (e.g. this is the job of jl_promote_ci_to_current)\n         store_backedges(ci, edges)\n     end\n     return ci\n@@ -1027,19 +1110,31 @@ function typeinf_edge(interp::AbstractInterpreter, method::Method, @nospecialize\n     cache_mode = CACHE_MODE_GLOBAL # cache edge targets globally by default\n     force_inline = is_stmt_inline(get_curr_ssaflag(caller))\n     edge_ci = nothing\n-    # check cache with SOURCE_MODE_NOT_REQUIRED source_mode\n-    let codeinst = get(code_cache(interp), mi, nothing)\n-        if codeinst isa CodeInstance # return existing rettype if the code is already inferred\n-            inferred = @atomic :monotonic codeinst.inferred\n-            if inferred === nothing && force_inline\n-                # we already inferred this edge before and decided to discard the inferred code,\n-                # nevertheless we re-infer it here again in order to propagate the re-inferred\n-                # source to the inliner as a volatile result\n-                cache_mode = CACHE_MODE_VOLATILE\n-                edge_ci = codeinst\n-            else\n+    let code = get(code_cache(interp), mi, nothing)\n+        codeinst = code\n+        if code isa InferenceResult\n+            inferred = code.src\n+            codeinst = code.ci\n+        elseif code isa CodeInstance # return existing rettype if the code is already inferred\n+            inferred = @atomic :monotonic code.inferred\n+        else\n+            inferred = nothing\n+        end\n+        if codeinst isa CodeInstance\n+            need_inlineable_code = may_optimize(interp) && (force_inline || is_inlineable(inferred))\n+            if need_inlineable_code\n+                src = ci_get_source(interp, codeinst, inferred)\n+                if src === nothing\n+                    # Re-infer to get the appropriate source representation\n+                    cache_mode = CACHE_MODE_LOCAL\n+                    edge_ci = codeinst\n+                else # no reinference needed\n+                    @assert codeinst.def === mi \"MethodInstance for cached edge does not match\"\n+                    return return_cached_result(interp, method, code, src, caller, edgecycle, edgelimited)\n+                end\n+            else # no reinference needed\n                 @assert codeinst.def === mi \"MethodInstance for cached edge does not match\"\n-                return return_cached_result(interp, method, codeinst, caller, edgecycle, edgelimited)\n+                return return_cached_result(interp, method, code, nothing, caller, edgecycle, edgelimited)\n             end\n         end\n     end\n@@ -1060,27 +1155,43 @@ function typeinf_edge(interp::AbstractInterpreter, method::Method, @nospecialize\n             reserve_start = _time_ns() # subtract engine_reserve (thread-synchronization) time from callers to avoid double-counting\n             ci_from_engine = engine_reserve(interp, mi)\n             caller.time_paused += (_time_ns() - reserve_start)\n-            edge_ci = ci_from_engine\n-            codeinst = get(code_cache(interp), mi, nothing)\n+            code = get(code_cache(interp), mi, nothing)\n+            codeinst = code\n+            if code isa InferenceResult\n+                inferred = code.src\n+                codeinst = code.ci\n+            elseif code isa CodeInstance # return existing rettype if the code is already inferred\n+                inferred = @atomic :monotonic code.inferred\n+            else\n+                inferred = nothing\n+            end\n             if codeinst isa CodeInstance # return existing rettype if the code is already inferred\n                 engine_reject(interp, ci_from_engine)\n                 ci_from_engine = nothing\n-                inferred = @atomic :monotonic codeinst.inferred\n-                if inferred === nothing && force_inline\n-                    cache_mode = CACHE_MODE_VOLATILE\n-                    edge_ci = codeinst\n+                need_inlineable_code = may_optimize(interp) && (force_inline || is_inlineable(inferred))\n+                if need_inlineable_code\n+                    src = ci_get_source(interp, codeinst, inferred)\n+                    if src === nothing\n+                        cache_mode = CACHE_MODE_LOCAL\n+                        edge_ci = codeinst\n+                    else\n+                        @assert codeinst.def === mi \"MethodInstance for cached edge does not match\"\n+                        return return_cached_result(interp, method, code, src, caller, edgecycle, edgelimited)\n+                    end\n                 else\n                     @assert codeinst.def === mi \"MethodInstance for cached edge does not match\"\n-                    return return_cached_result(interp, method, codeinst, caller, edgecycle, edgelimited)\n+                    return return_cached_result(interp, method, code, nothing, caller, edgecycle, edgelimited)\n                 end\n             end\n         else\n             ci_from_engine = nothing\n         end\n         result = InferenceResult(mi, typeinf_lattice(interp))\n-        if ci_from_engine !== nothing\n-            result.ci = ci_from_engine\n-        end\n+        result.ci = if ci_from_engine !== nothing\n+                ci_from_engine\n+            else\n+                ccall(:jl_new_codeinst_uninit, Any, (Any, Any), mi, cache_owner(interp))::CodeInstance\n+            end\n         frame = InferenceState(result, cache_mode, interp) # always use the cache for edge targets\n         if frame === nothing\n             add_remark!(interp, caller, \"[typeinf_edge] Failed to retrieve source\")\n@@ -1095,22 +1206,29 @@ function typeinf_edge(interp::AbstractInterpreter, method::Method, @nospecialize\n         # while splitting off the rest of the work for this caller into a separate workq thunk\n         let mresult = Future{MethodCallResult}()\n             push!(caller.tasks, function get_infer_result(interp, caller)\n-                update_valid_age!(caller, frame.world.valid_worlds)\n+                update_valid_age!(caller, get_inference_world(interp), frame.valid_worlds)\n                 local isinferred = is_inferred(frame)\n-                local edge = isinferred ? edge_ci : nothing\n-                local effects = isinferred ? frame.result.ipo_effects : # effects are adjusted already within `finish` for ipo_effects\n-                    adjust_effects(effects_for_cycle(frame.ipo_effects), method)\n+                local effects\n+                local edge = nothing\n+                local call_result = nothing\n+                if isinferred\n+                    edge = result.ci\n+                    if edge_ci isa CodeInstance && codeinst_edges_sub(edge_ci, edge.min_world, edge.max_world, edge.edges)\n+                        edge = edge_ci # override the edge for tracking invalidation\n+                    end\n+                    result.ci_as_edge = edge # override the edge for tracking purposes\n+                    effects = result.ipo_effects # effects are adjusted already within `finish` for ipo_effects\n+                    call_result = result\n+                else\n+                    effects = adjust_effects(effects_for_cycle(frame.ipo_effects), method)\n+                    add_cycle_backedge!(caller, frame)\n+                end\n                 local bestguess = frame.bestguess\n                 local exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)\n                 # propagate newly inferred source to the inliner, allowing efficient inlining w/o deserialization:\n                 # note that this result is cached globally exclusively, so we can use this local result destructively\n-                local volatile_inf_result = if isinferred && edge_ci isa CodeInstance\n-                    result.ci_as_edge = edge_ci # set the edge for the inliner usage\n-                    VolatileInferenceResult(result)\n-                end\n-                isinferred || add_cycle_backedge!(caller, frame)\n                 mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,\n-                    edge, edgecycle, edgelimited, volatile_inf_result)\n+                    edge, edgecycle, edgelimited, call_result)\n                 return true\n             end)\n             return mresult\n@@ -1122,7 +1240,7 @@ function typeinf_edge(interp::AbstractInterpreter, method::Method, @nospecialize\n     end\n     # return the current knowledge about this cycle\n     frame = frame::InferenceState\n-    update_valid_age!(caller, frame.world.valid_worlds)\n+    update_valid_age!(caller, get_inference_world(interp), frame.valid_worlds)\n     effects = adjust_effects(effects_for_cycle(frame.ipo_effects), method)\n     bestguess = frame.bestguess\n     exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)\n@@ -1179,6 +1297,8 @@ function codeinfo_for_const(::AbstractInterpreter, mi::MethodInstance, worlds::W\n     tree.min_world = first(worlds)\n     tree.max_world = last(worlds)\n     tree.edges = edges\n+    tree.nargs = UInt(nargs)\n+    tree.isva = method.isva\n     set_inlineable!(tree, true)\n     tree.parent = mi\n     return tree\n@@ -1244,7 +1364,7 @@ function typeinf_frame(interp::AbstractInterpreter, mi::MethodInstance, run_opti\n     if run_optimizer\n         if result_is_constabi(interp, frame.result)\n             rt = frame.result.result::Const\n-            src = codeinfo_for_const(interp, frame.linfo, frame.world.valid_worlds, Core.svec(frame.edges...), rt.val)\n+            src = codeinfo_for_const(interp, frame.linfo, frame.valid_worlds, Core.svec(frame.edges...), rt.val)\n         else\n             opt = OptimizationState(frame, interp)\n             optimize(interp, opt, frame.result)\n@@ -1297,29 +1417,55 @@ end\n \"\"\"\n     ci_has_source(interp::AbstractInterpreter, code::CodeInstance)\n \n-Determine whether this CodeInstance is something that could be compiled from\n-source that interp has.\n+Determine whether this CodeInstance is something that will return something\n+compileable by ci_get_source.\n \"\"\"\n function ci_has_source(interp::AbstractInterpreter, code::CodeInstance)\n     codegen = codegen_cache(interp)\n     codegen === nothing && return false\n     use_const_api(code) && return true\n-    haskey(codegen, code) && return true\n+    inf = get(codegen, code, nothing)\n+    inf === nothing || return true\n     inf = @atomic :monotonic code.inferred\n     if isa(inf, String)\n         inf = _uncompressed_ir(code, inf)\n     end\n-    if code.owner === nothing\n-        if isa(inf, CodeInfo)\n-            codegen[code] = inf\n-            return true\n-        end\n-    elseif inf !== nothing\n+    if isa(inf, CodeInfo)\n+        codegen[code] = inf\n         return true\n     end\n     return false\n end\n \n+# Get source if available for inlining, otherwise return nothing\n+# populates codegen cache for code, if successful\n+function ci_get_source(interp::AbstractInterpreter, code::CodeInstance, @nospecialize src)\n+    codegen = codegen_cache(interp)\n+    if codegen !== nothing\n+        inf = get(codegen, code, nothing)\n+        inf === nothing || return inf\n+    end\n+    if use_const_api(code)\n+        return codeinfo_for_const(interp, get_ci_mi(code), WorldRange(code.min_world, code.max_world), code.edges, code.rettype_const)\n+    end\n+    if isa(src, String)\n+        src = _uncompressed_ir(code, src)\n+    end\n+    if isa(src, CodeInfo)\n+        if codegen !== nothing\n+            codegen[code] = src\n+        end\n+        return src\n+    elseif isa(src, IRCode)\n+        error(\"IRCode is unexpected\")\n+    end\n+    return nothing\n+end\n+\n+function ci_get_source(interp::AbstractInterpreter, code::CodeInstance)\n+    return ci_get_source(interp, code, isdefined(code, :inferred) ? code.inferred : nothing)\n+end\n+\n function ci_has_invoke(code::CodeInstance)\n     return (@atomic :monotonic code.invoke) !== C_NULL\n end\n@@ -1335,6 +1481,7 @@ end\n function typeinf_ext(interp::AbstractInterpreter, mi::MethodInstance, source_mode::UInt8)\n     start_time = ccall(:jl_typeinf_timing_begin, UInt64, ())\n     let code = get(code_cache(interp), mi, nothing)\n+        code isa InferenceResult && (code = code.ci)\n         if code isa CodeInstance\n             # see if this code already exists in the cache\n             if ci_meets_requirement(interp, code, source_mode)\n@@ -1347,6 +1494,7 @@ function typeinf_ext(interp::AbstractInterpreter, mi::MethodInstance, source_mod\n     ci = engine_reserve(interp, mi)\n     # check cache again if it is still new after reserving in the engine\n     let code = get(code_cache(interp), mi, nothing)\n+        code isa InferenceResult && (code = code.ci)\n         if code isa CodeInstance\n             # see if this code already exists in the cache\n             if ci_meets_requirement(interp, code, source_mode)\n@@ -1369,7 +1517,7 @@ function typeinf_ext(interp::AbstractInterpreter, mi::MethodInstance, source_mod\n         end\n     end\n     result = InferenceResult(mi, typeinf_lattice(interp))\n-    result.ci = ci\n+    result.ci = result.ci_as_edge = ci\n     frame = InferenceState(result, #=cache_mode=#:global, interp)\n     if frame === nothing\n         engine_reject(interp, ci)\n@@ -1520,23 +1668,17 @@ function add_codeinsts_to_jit!(interp::AbstractInterpreter, ci, source_mode::UIn\n         callee = pop!(workqueue)\n         ci_has_invoke(callee) && continue\n         isinspected(workqueue, callee) && continue\n-        src = get(codegen, callee, nothing)\n+        src = ci_get_source(interp, callee)\n         if !isa(src, CodeInfo)\n-            src = @atomic :monotonic callee.inferred\n-            if isa(src, String)\n-                src = _uncompressed_ir(callee, src)\n+            newcallee = typeinf_ext(workqueue.interp, callee.def, source_mode) # always SOURCE_MODE_ABI\n+            if newcallee isa CodeInstance\n+                callee === ci && (ci = newcallee) # ci stopped meeting the requirements after typeinf_ext last checked, try again with newcallee\n+                push!(workqueue, newcallee)\n             end\n-            if !isa(src, CodeInfo)\n-                newcallee = typeinf_ext(workqueue.interp, callee.def, source_mode) # always SOURCE_MODE_ABI\n-                if newcallee isa CodeInstance\n-                    callee === ci && (ci = newcallee) # ci stopped meeting the requirements after typeinf_ext last checked, try again with newcallee\n-                    push!(workqueue, newcallee)\n-                end\n-                if newcallee !== callee\n-                    markinspected!(workqueue, callee)\n-                end\n-                continue\n+            if newcallee !== callee\n+                markinspected!(workqueue, callee)\n             end\n+            continue\n         end\n         markinspected!(workqueue, callee)\n         mi = get_ci_mi(callee)"
    },
    {
      "sha": "6f0cb514562093d9b65ed7f343e3f4865e71297c",
      "filename": "Compiler/src/types.jl",
      "status": "modified",
      "additions": 53,
      "deletions": 10,
      "changes": 63,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Ftypes.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Fsrc%2Ftypes.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftypes.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -1,5 +1,4 @@\n # This file is a part of Julia. License is MIT: https://julialang.org/license\n-#\n \n const WorkThunk = Any\n # #@eval struct WorkThunk\n@@ -8,6 +7,12 @@ const WorkThunk = Any\n # end\n # (p::WorkThunk)() = p.thunk()\n \n+# This corresponds to the type of `CodeInfo`'s `inlining_cost` field\n+const InlineCostType = UInt16\n+const MAX_INLINE_COST = typemax(InlineCostType)\n+const MIN_INLINE_COST = InlineCostType(10)\n+const MaybeCompressed = Union{CodeInfo, String}\n+\n \"\"\"\n     AbstractInterpreter\n \n@@ -85,6 +90,10 @@ struct AnalysisResults\n end\n const NULL_ANALYSIS_RESULTS = AnalysisResults(nothing)\n \n+# Abstract type for call inference results that can be stored in CallInfo\n+# This is defined here so that InferenceResult can inherit from it\n+abstract type InferredCallResult end\n+\n \"\"\"\n     result::InferenceResult\n \n@@ -95,7 +104,7 @@ There are two constructor available:\n - `InferenceResult(mi::MethodInstance, argtypes::Vector{Any}, overridden_by_const::BitVector)`\n   for constant inference, with extended lattice information included in `result.argtypes`.\n \"\"\"\n-mutable struct InferenceResult\n+mutable struct InferenceResult <: InferredCallResult\n     #=== constant fields ===#\n     const linfo::MethodInstance\n     const argtypes::Vector{Any}\n@@ -109,19 +118,18 @@ mutable struct InferenceResult\n     ipo_effects::Effects              # if inference is finished\n     effects::Effects                  # if optimization is finished\n     analysis_results::AnalysisResults # AnalysisResults with e.g. result::ArgEscapeCache if optimized, otherwise NULL_ANALYSIS_RESULTS\n-    is_src_volatile::Bool             # `src` has been cached globally as the compressed format already, allowing `src` to be used destructively\n     tombstone::Bool\n \n     #=== uninitialized fields ===#\n-    ci::CodeInstance                  # CodeInstance if this result may be added to the cache\n-    ci_as_edge::CodeInstance          # CodeInstance as the edge representing locally cached result\n+    ci::CodeInstance                  # CodeInstance that will contain the result in full\n+    ci_as_edge::CodeInstance          # CodeInstance, that is preferred just for use when representing the result as the edge\n     function InferenceResult(mi::MethodInstance, argtypes::Vector{Any}, overridden_by_const::Union{Nothing,BitVector})\n         result = exc_result = src = nothing\n         valid_worlds = WorldRange()\n         ipo_effects = effects = Effects()\n         analysis_results = NULL_ANALYSIS_RESULTS\n         return new(mi, argtypes, overridden_by_const, result, exc_result, src,\n-            valid_worlds, ipo_effects, effects, analysis_results, #=is_src_volatile=#false, false)\n+            valid_worlds, ipo_effects, effects, analysis_results, false)\n     end\n end\n function InferenceResult(mi::MethodInstance, \ud835\udd43::AbstractLattice=fallback_lattice)\n@@ -492,10 +500,45 @@ typeinf_lattice(::AbstractInterpreter) = InferenceLattice(BaseInferenceLattice.i\n ipo_lattice(::AbstractInterpreter) = InferenceLattice(IPOResultLattice.instance)\n optimizer_lattice(::AbstractInterpreter) = SimpleInferenceLattice.instance\n \n+struct OverlayCodeCache{Cache}\n+    globalcache::Cache\n+    localcache::Vector{InferenceResult}\n+end\n+\n+setindex!(cache::OverlayCodeCache, ci::CodeInstance, mi::MethodInstance) = (setindex!(cache.globalcache, ci, mi); cache)\n+\n+haskey(cache::OverlayCodeCache, mi::MethodInstance) = get(cache, mi, nothing) !== nothing\n+\n+function get(cache::OverlayCodeCache, mi::MethodInstance, default)\n+    for cached_result in Iterators.reverse(cache.localcache)\n+        cached_result.tombstone && continue # ignore deleted entries (due to LimitedAccuracy)\n+        cached_result.linfo === mi || continue\n+        cached_result.overridden_by_const === nothing || continue\n+        isdefined(cached_result, :ci) || continue\n+        ci = cached_result.ci\n+        isdefined(ci, :inferred) || continue\n+        return cached_result\n+    end\n+    return get(cache.globalcache, mi, default)\n+end\n+\n+function getindex(cache::OverlayCodeCache, mi::MethodInstance)\n+    r = get(cache, mi, nothing)\n+    r === nothing && throw(KeyError(mi))\n+    return r\n+end\n+\n+code_cache(interp::AbstractInterpreter, #=extended_range=#::WorldRange) = code_cache(interp)\n+\n function code_cache(interp::AbstractInterpreter)\n-  cache = InternalCodeCache(cache_owner(interp))\n-  worlds = WorldRange(get_inference_world(interp))\n-  return WorldView(cache, worlds)\n+    cache = InternalCodeCache(cache_owner(interp), get_inference_world(interp))\n+    return OverlayCodeCache(cache, get_inference_cache(interp))\n+end\n+\n+function code_cache(interp::NativeInterpreter, extended_range::WorldRange)\n+    @assert get_inference_world(interp) in extended_range\n+    cache = InternalCodeCache(cache_owner(interp), extended_range)\n+    return OverlayCodeCache(cache, get_inference_cache(interp))\n end\n \n get_escape_cache(interp::AbstractInterpreter) = GetNativeEscapeCache(interp)\n@@ -513,7 +556,7 @@ function add_edges!(edges::Vector{Any}, info::CallInfo)\n end\n nsplit(info::CallInfo) = nsplit_impl(info)::Union{Nothing,Int}\n getsplit(info::CallInfo, idx::Int) = getsplit_impl(info, idx)::MethodLookupResult\n-getresult(info::CallInfo, idx::Int) = getresult_impl(info, idx)#=::Union{Nothing,ConstResult}=#\n+getresult(info::CallInfo, idx::Int) = getresult_impl(info, idx)#=::Union{Nothing,InferenceResult}=#\n \n add_edges_impl(::Vector{Any}, ::CallInfo) = error(\"\"\"\n     All `CallInfo` is required to implement `add_edges_impl(::Vector{Any}, ::CallInfo)`\"\"\")"
    },
    {
      "sha": "fb0ddbdce7a96f181ada6acf196e15847ebd7259",
      "filename": "Compiler/test/AbstractInterpreter.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Ftest%2FAbstractInterpreter.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Ftest%2FAbstractInterpreter.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2FAbstractInterpreter.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -494,29 +494,32 @@ struct CustomData\n     inferred\n     CustomData(@nospecialize inferred) = new(inferred)\n end\n-function Compiler.transform_result_for_cache(interp::CustomDataInterp, result::Compiler.InferenceResult, edges::Core.SimpleVector)\n+function Compiler.transform_result_for_cache(\n+    interp::CustomDataInterp, result::Compiler.InferenceResult, edges::Core.SimpleVector)\n     inferred_result = @invoke Compiler.transform_result_for_cache(\n         interp::Compiler.AbstractInterpreter, result::Compiler.InferenceResult, edges::Core.SimpleVector)\n     return CustomData(inferred_result)\n end\n-function Compiler.src_inlining_policy(interp::CustomDataInterp, @nospecialize(src),\n-                            @nospecialize(info::Compiler.CallInfo), stmt_flag::UInt32)\n+function Compiler.src_inlining_policy(\n+    interp::CustomDataInterp, @nospecialize(src), @nospecialize(info::Compiler.CallInfo),\n+    stmt_flag::UInt32)\n     if src isa CustomData\n         src = src.inferred\n     end\n-    return @invoke Compiler.src_inlining_policy(interp::Compiler.AbstractInterpreter, src::Any,\n-                                          info::Compiler.CallInfo, stmt_flag::UInt32)\n+    return @invoke Compiler.src_inlining_policy(\n+        interp::Compiler.AbstractInterpreter, src::Any, info::Compiler.CallInfo,\n+        stmt_flag::UInt32)\n end\n Compiler.retrieve_ir_for_inlining(cached_result::CodeInstance, src::CustomData) =\n     Compiler.retrieve_ir_for_inlining(cached_result, src.inferred)\n Compiler.retrieve_ir_for_inlining(mi::MethodInstance, src::CustomData, preserve_local_sources::Bool) =\n     Compiler.retrieve_ir_for_inlining(mi, src.inferred, preserve_local_sources)\n let src = code_typed((Int,); interp=CustomDataInterp()) do x\n-        return sin(x) + cos(x)\n+        return (@noinline sin(x)) + (@noinline cos(x))\n     end |> only |> first\n     @test count(isinvoke(:sin), src.code) == 1\n     @test count(isinvoke(:cos), src.code) == 1\n-    @test count(isinvoke(:+), src.code) == 0\n+    @test_broken count(isinvoke(:+), src.code) == 0\n end\n \n # ephemeral cache mode\n@@ -525,9 +528,9 @@ func_ext_cache1(a) = func_ext_cache2(a) * cos(a)\n func_ext_cache2(a) = sin(a)\n let interp = DebugInterp()\n     @test Base.infer_return_type(func_ext_cache1, (Float64,); interp) === Float64\n-    @test isdefined(interp, :code_cache)\n+    @test isdefined(interp, :global_cache)\n     found = false\n-    for (mi, codeinst) in interp.code_cache.dict\n+    for (mi, codeinst) in interp.global_cache.dict\n         if mi.def.name === :func_ext_cache2\n             found = true\n             break\n@@ -538,7 +541,7 @@ end\n \n @newinterp InvokeInterp\n struct InvokeOwner end\n-codegen = IdDict{CodeInstance, CodeInfo}()\n+global codegen::IdDict{CodeInstance, CodeInfo} = IdDict{CodeInstance, CodeInfo}()\n Compiler.cache_owner(::InvokeInterp) = InvokeOwner()\n Compiler.codegen_cache(::InvokeInterp) = codegen\n let interp = InvokeInterp()"
    },
    {
      "sha": "5d7dc01b2a9efc67149059b3aa19fe50720a034d",
      "filename": "Compiler/test/EAUtils.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Ftest%2FEAUtils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Ftest%2FEAUtils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2FEAUtils.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -11,8 +11,8 @@ using .Compiler: EscapeAnalysis as EA\n \n # imports\n import .Compiler:\n-    AbstractInterpreter, NativeInterpreter, WorldView, WorldRange, InferenceParams,\n-    OptimizationParams, get_world_counter, get_inference_cache, ipo_dataflow_analysis!\n+    AbstractInterpreter, InferenceParams, OptimizationParams,\n+    get_world_counter, get_inference_cache, ipo_dataflow_analysis!\n # usings\n using Core.IR\n using .Compiler: InferenceResult, InferenceState, OptimizationState, IRCode"
    },
    {
      "sha": "db60d2a924a5bfb787f5a0a5e5f03a6e9c8000f7",
      "filename": "Compiler/test/inline.jl",
      "status": "modified",
      "additions": 10,
      "deletions": 18,
      "changes": 28,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Ftest%2Finline.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Ftest%2Finline.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Finline.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -631,10 +631,12 @@ g41299(f::Tf, args::Vararg{Any,N}) where {Tf,N} = f(args...)\n \n # https://github.com/JuliaLang/julia/issues/42078\n # idempotency of callsite inlining\n-function getcache(mi::Core.MethodInstance)\n+function getcacheci(mi::Core.MethodInstance)\n     cache = Compiler.code_cache(Compiler.NativeInterpreter())\n     codeinst = Compiler.get(cache, mi, nothing)\n-    return isnothing(codeinst) ? nothing : codeinst\n+    codeinst === nothing && return nothing\n+    codeinst isa Compiler.InferenceResult && (codeinst = codeinst.ci)\n+    return codeinst\n end\n @noinline f42078(a) = sum(sincos(a))\n let\n@@ -652,7 +654,7 @@ let\n     end\n     let # make sure to discard the inferred source\n         mi = only(methods(f42078)).specializations::Core.MethodInstance\n-        codeinst = getcache(mi)::Core.CodeInstance\n+        codeinst = getcacheci(mi)::Core.CodeInstance\n         @atomic codeinst.inferred = nothing\n     end\n \n@@ -1856,7 +1858,7 @@ let i::Int, continue_::Bool\n     i = findfirst(isinvoke(:func_mul_int), ir.stmts.stmt)\n     @test i !== nothing\n     # now delete the callsite flag, and see the second inlining pass can inline the call\n-    @eval Compiler $ir.stmts[$i][:flag] &= ~IR_FLAG_NOINLINE\n+    ir.stmts[i][:flag] &= ~Compiler.IR_FLAG_NOINLINE\n     inlining = Compiler.InliningState(interp)\n     ir = Compiler.ssa_inlining_pass!(ir, inlining, false)\n     @test findfirst(isinvoke(:func_mul_int), ir.stmts.stmt) === nothing\n@@ -1879,22 +1881,12 @@ let i::Int, continue_::Bool\n     ir, = only(Base.code_ircode(multi_inlining2, (Int,Int); optimize_until=\"CC: INLINING\", interp))\n     i = findfirst(isinvoke(:func_mul_int), ir.stmts.stmt)\n     @test i !== nothing\n-    # now delete the callsite flag, and see the second inlining pass can inline the call\n-    @eval Compiler $ir.stmts[$i][:flag] &= ~IR_FLAG_NOINLINE\n+    # now delete the callsite flag, and see the second inlining pass does not inline the call, since inference recorded it should not\n+    ir.stmts[i][:flag] &= ~Compiler.IR_FLAG_NOINLINE\n     inlining = Compiler.InliningState(interp)\n     ir = Compiler.ssa_inlining_pass!(ir, inlining, false)\n-    @test findfirst(isinvoke(:func_mul_int), ir.stmts.stmt) === nothing\n-    @test (i = findfirst(iscall((ir, Core.Intrinsics.mul_int)), ir.stmts.stmt)) !== nothing\n-    lins = Compiler.IRShow.buildLineInfoNode(ir.debuginfo, nothing, i)\n-    @test_broken (continue_ = length(lins) == 3) # see TODO in `ir_inline_linetable!`\n-    if continue_\n-        def1 = lins[1].method\n-        @test def1 isa Core.MethodInstance && def1.def.name === :multi_inlining2\n-        def2 = lins[2].method\n-        @test def2 isa Core.MethodInstance && def2.def.name === :call_func_mul_int\n-        def3 = lins[3].method\n-        @test def3 isa Core.MethodInstance && def3.def.name === :call_func_mul_int\n-    end\n+    @test findfirst(isinvoke(:func_mul_int), ir.stmts.stmt) !== nothing\n+    @test findfirst(iscall((ir, Core.Intrinsics.mul_int)), ir.stmts.stmt) === nothing\n end\n \n # Test special purpose inliner for Core.ifelse"
    },
    {
      "sha": "964912e8a6013bd379eef337a5534d9970cc8c80",
      "filename": "Compiler/test/newinterp.jl",
      "status": "modified",
      "additions": 10,
      "deletions": 11,
      "changes": 21,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Ftest%2Fnewinterp.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/Compiler%2Ftest%2Fnewinterp.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Ftest%2Fnewinterp.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -14,11 +14,10 @@ When the `ephemeral_cache=true` option is specified, `NewInterpreter` will hold\n `CodeInstance` in an ephemeral non-integrated cache, rather than in the integrated\n `Compiler.InternalCodeCache`.\n Keep in mind that ephemeral cache lacks support for invalidation and doesn't persist across\n-sessions. However it is an usual Julia object of the type `code_cache::IdDict{MethodInstance,CodeInstance}`,\n+sessions. However it is an usual Julia object of the type `global_cache::IdDict{MethodInstance,CodeInstance}`,\n making it easier for debugging and inspecting the compiler behavior.\n \"\"\"\n macro newinterp(InterpName, ephemeral_cache::Bool=false)\n-    cache_token = QuoteNode(gensym(string(InterpName, \"CacheToken\")))\n     InterpCacheName = esc(Symbol(string(InterpName, \"Cache\")))\n     InterpName = esc(InterpName)\n     C = Core\n@@ -35,31 +34,31 @@ macro newinterp(InterpName, ephemeral_cache::Bool=false)\n             inf_params::$Compiler.InferenceParams\n             opt_params::$Compiler.OptimizationParams\n             inf_cache::Vector{$Compiler.InferenceResult}\n-            $(ephemeral_cache && :(code_cache::$InterpCacheName))\n+            $(ephemeral_cache && :(global_cache::$InterpCacheName))\n             function $InterpName(meta = nothing;\n                                  world::UInt = Base.get_world_counter(),\n                                  inf_params::$Compiler.InferenceParams = $Compiler.InferenceParams(),\n                                  opt_params::$Compiler.OptimizationParams = $Compiler.OptimizationParams(),\n                                  inf_cache::Vector{$Compiler.InferenceResult} = $Compiler.InferenceResult[],\n                                  $(ephemeral_cache ?\n-                                    Expr(:kw, :(code_cache::$InterpCacheName), :($InterpCacheName())) :\n+                                    Expr(:kw, :(global_cache::$InterpCacheName), :($InterpCacheName())) :\n                                     Expr(:kw, :_, :nothing)))\n                 return $(ephemeral_cache ?\n-                    :(new(meta, world, inf_params, opt_params, inf_cache, code_cache)) :\n+                    :(new(meta, world, inf_params, opt_params, inf_cache, global_cache)) :\n                     :(new(meta, world, inf_params, opt_params, inf_cache)))\n             end\n         end\n         $Compiler.InferenceParams(interp::$InterpName) = interp.inf_params\n         $Compiler.OptimizationParams(interp::$InterpName) = interp.opt_params\n         $Compiler.get_inference_world(interp::$InterpName) = interp.world\n         $Compiler.get_inference_cache(interp::$InterpName) = interp.inf_cache\n-        $Compiler.cache_owner(::$InterpName) = $cache_token\n+        $Compiler.cache_owner(::$InterpName) = $InterpName\n         $(ephemeral_cache && quote\n-        $Compiler.code_cache(interp::$InterpName) = $Compiler.WorldView(interp.code_cache, $Compiler.WorldRange(interp.world))\n-        $Compiler.get(wvc::$Compiler.WorldView{$InterpCacheName}, mi::$C.MethodInstance, default) = get(wvc.cache.dict, mi, default)\n-        $Compiler.getindex(wvc::$Compiler.WorldView{$InterpCacheName}, mi::$C.MethodInstance) = getindex(wvc.cache.dict, mi)\n-        $Compiler.haskey(wvc::$Compiler.WorldView{$InterpCacheName}, mi::$C.MethodInstance) = haskey(wvc.cache.dict, mi)\n-        $Compiler.setindex!(wvc::$Compiler.WorldView{$InterpCacheName}, ci::$C.CodeInstance, mi::$C.MethodInstance) = setindex!(wvc.cache.dict, ci, mi)\n+        $Compiler.code_cache(interp::$InterpName) = $Compiler.OverlayCodeCache(interp.global_cache, interp.inf_cache)\n+        $Compiler.get(cache::$InterpCacheName, mi::$C.MethodInstance, default) = get(cache.dict, mi, default)\n+        $Compiler.getindex(cache::$InterpCacheName, mi::$C.MethodInstance) = getindex(cache.dict, mi)\n+        $Compiler.haskey(cache::$InterpCacheName, mi::$C.MethodInstance) = haskey(cache.dict, mi)\n+        $Compiler.setindex!(cache::$InterpCacheName, ci::$C.CodeInstance, mi::$C.MethodInstance) = setindex!(cache.dict, ci, mi)\n         end)\n     end\n end"
    },
    {
      "sha": "8f79f22ef176101eae237f2c0212fa910745fa66",
      "filename": "contrib/generate_precompile.jl",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/contrib%2Fgenerate_precompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/contrib%2Fgenerate_precompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/contrib%2Fgenerate_precompile.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -52,9 +52,7 @@ precompile(Tuple{typeof(Base.Threads.atomic_add!), Base.Threads.Atomic{Int}, Int\n precompile(Tuple{typeof(Base.Threads.atomic_sub!), Base.Threads.Atomic{Int}, Int})\n precompile(Tuple{Type{Pair{A, B} where B where A}, Base.PkgId, UInt128})\n precompile(Tuple{typeof(Base.in!), Tuple{Module, String, UInt64, UInt32, Float64}, Base.Set{Any}})\n-precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:allow_typevars, :volatile_inf_result), Tuple{Bool, Nothing}}, typeof(Base.Compiler.handle_match!), Array{Base.Compiler.InliningCase, 1}, Core.MethodMatch, Array{Any, 1}, Base.Compiler.CallInfo, UInt32, Base.Compiler.InliningState{Base.Compiler.NativeInterpreter}})\n precompile(Tuple{typeof(Base.Compiler.ir_to_codeinf!), Base.Compiler.OptimizationState{Base.Compiler.NativeInterpreter}})\n-precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:allow_typevars, :volatile_inf_result), Tuple{Bool, Base.Compiler.VolatileInferenceResult}}, typeof(Base.Compiler.handle_match!), Array{Base.Compiler.InliningCase, 1}, Core.MethodMatch, Array{Any, 1}, Base.Compiler.CallInfo, UInt32, Base.Compiler.InliningState{Base.Compiler.NativeInterpreter}})\n precompile(Tuple{typeof(Base.getindex), Type{Pair{Base.PkgId, UInt128}}, Pair{Base.PkgId, UInt128}, Pair{Base.PkgId, UInt128}, Pair{Base.PkgId, UInt128}, Vararg{Pair{Base.PkgId, UInt128}}})\n precompile(Tuple{typeof(Base.Compiler.ir_to_codeinf!), Base.Compiler.OptimizationState{Base.Compiler.NativeInterpreter}, Core.SimpleVector})\n precompile(Tuple{typeof(Base.Compiler.ir_to_codeinf!), Base.Compiler.OptimizationState{Base.Compiler.NativeInterpreter}})"
    },
    {
      "sha": "59ed115afd23d5863648ac9b69da574b2fd87239",
      "filename": "src/jltypes.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/src%2Fjltypes.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/src%2Fjltypes.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjltypes.c?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -3719,7 +3719,7 @@ void jl_init_types(void) JL_GC_DISABLED\n                         jl_emptysvec,\n                         0, 1, 1);\n     jl_svecset(jl_code_instance_type->types, 2, jl_code_instance_type);\n-    const static uint32_t code_instance_constfields[1]  = { 0b000001110100011100011 }; // Set fields 1, 2, 6-8, 12, 14-16 as const\n+    const static uint32_t code_instance_constfields[1]  = { 0b000001110000011100011 }; // Set fields 1, 2, 6-8, 14-16 as const\n     const static uint32_t code_instance_atomicfields[1] = { 0b111110001011100011100 }; // Set fields 3-5, 9-12, 13, 17-21 as atomic\n     // Fields 4-5 are only operated on by construction and deserialization, so are effectively const at runtime\n     // Fields ipo_purity_bits and analysis_results are not currently threadsafe or reliable, as they get mutated after optimization, but are not declared atomic"
    },
    {
      "sha": "e225eb2fe10dfbd8456817dc7e531bf3bd260cfd",
      "filename": "src/staticdata.c",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/src%2Fstaticdata.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/src%2Fstaticdata.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fstaticdata.c?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -3325,12 +3325,6 @@ static void jl_write_header_for_incremental(ios_t *f, jl_array_t *worklist, jl_a\n JL_DLLEXPORT void jl_create_system_image(void **_native_data, jl_array_t *worklist, bool_t emit_split,\n                                          ios_t **s, ios_t **z, jl_array_t **udeps, int64_t *srctextpos, jl_array_t *module_init_order)\n {\n-    if (jl_options.strip_ir || jl_options.trim) {\n-        // make sure this is precompiled for jl_foreach_reachable_mtable\n-        jl_get_loaded_modules();\n-    }\n-    jl_gc_collect(JL_GC_FULL);\n-    jl_gc_collect(JL_GC_INCREMENTAL);   // sweep finalizers\n     JL_TIMING(SYSIMG_DUMP, SYSIMG_DUMP);\n \n     // iff emit_split\n@@ -3377,6 +3371,8 @@ JL_DLLEXPORT void jl_create_system_image(void **_native_data, jl_array_t *workli\n     if (_native_data != NULL)\n         native_functions = *_native_data;\n \n+    jl_gc_collect(JL_GC_FULL);\n+    jl_gc_collect(JL_GC_INCREMENTAL);   // sweep finalizers\n     // Make sure we don't run any Julia code concurrently after this point\n     // since it will invalidate our serialization preparations\n     jl_gc_enable_finalizers(ct, 0);"
    },
    {
      "sha": "993730b15b19b719f86e88c7e57e011856406eb3",
      "filename": "stdlib/REPL/src/REPLCompletions.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPLCompletions.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -605,7 +605,7 @@ function CC.concrete_eval_eligible(interp::REPLInterpreter, @nospecialize(f),\n     if (interp.limit_aggressive_inference ? is_repl_frame(sv) : is_call_stack_uncached(sv))\n         neweffects = CC.Effects(result.effects; consistent=CC.ALWAYS_TRUE)\n         result = CC.MethodCallResult(result.rt, result.exct, neweffects, result.edge,\n-                                     result.edgecycle, result.edgelimited, result.volatile_inf_result)\n+                                     result.edgecycle, result.edgelimited, result.call_result)\n     end\n     ret = @invoke CC.concrete_eval_eligible(interp::CC.AbstractInterpreter, f::Any,\n                                             result::CC.MethodCallResult, arginfo::CC.ArgInfo,"
    },
    {
      "sha": "5da669b92013854a69c9b16247ed47c71eacafcd",
      "filename": "test/cmdlineargs.jl",
      "status": "modified",
      "additions": 18,
      "deletions": 17,
      "changes": 35,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/test%2Fcmdlineargs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/test%2Fcmdlineargs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fcmdlineargs.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -29,9 +29,10 @@ end\n function test_read_success(cmd::Cmd, expected_type::Type=String)\n     success, out, err = readchomperrors(cmd)\n     if !success\n-        println(\"---- Command failed: $cmd\")\n-        println(\"stdout:$out\")\n-        println(\"stderr: $err\")\n+        println(\"---- Command failed: \")\n+        show(cmd)\n+        println(\"stdout:\\n\", out)\n+        println(\"stderr:\\n\", err)\n         println(\"----\")\n     end\n     @test success\n@@ -336,21 +337,21 @@ let exename = `$(Base.julia_cmd()) --startup-file=no --color=no`\n     end\n \n     # --home\n-    @test success(`$exename -H $(Sys.BINDIR)`)\n-    @test success(`$exename --home=$(Sys.BINDIR)`)\n+    @test \"\" == test_read_success(`$exename -H $(Sys.BINDIR)`)\n+    @test \"\" == test_read_success(`$exename --home=$(Sys.BINDIR)`)\n \n     # --eval\n-    @test  success(`$exename -e \"exit(0)\"`)\n+    @test \"\" == test_read_success(`$exename -e \"exit(0)\"`)\n     @test errors_not_signals(`$exename -e \"exit(1)\"`)\n-    @test  success(`$exename --eval=\"exit(0)\"`)\n+    @test \"\" == test_read_success(`$exename --eval=\"exit(0)\"`)\n     @test errors_not_signals(`$exename --eval=\"exit(1)\"`)\n     @test errors_not_signals(`$exename -e`)\n     @test errors_not_signals(`$exename --eval`)\n     # --eval --interactive (replaced --post-boot)\n-    @test  success(`$exename -i -e \"exit(0)\"`)\n+    @test \"\" == test_read_success(`$exename -i -e \"exit(0)\"`)\n     @test errors_not_signals(`$exename -i -e \"exit(1)\"`)\n     # issue #34924\n-    @test  success(`$exename -e 'const LOAD_PATH=1'`)\n+    @test \"\" == test_read_success(`$exename -e 'const LOAD_PATH=1'`)\n \n     # --print\n     @test read(`$exename -E \"1+1\"`, String) == \"2\\n\"\n@@ -1096,10 +1097,10 @@ let exename = `$(Base.julia_cmd()) --startup-file=no --color=no`\n         cd(testdir) do\n             rm(testdir)\n             @test Base.current_project() === nothing\n-            @test success(`$exename -e \"exit(0)\"`)\n+            @test \"\" == test_read_success(`$exename -e \"exit(0)\"`)\n             for load_path in [\"\", \"@\", \"@.\"]\n                 withenv(\"JULIA_LOAD_PATH\" => load_path) do\n-                    @test success(`$exename -e \"exit(!(Base.load_path() == []))\"`)\n+                    @test \"\" == test_read_success(`$exename -e \"exit(!(Base.load_path() == []))\"`)\n                 end\n             end\n         end\n@@ -1296,7 +1297,7 @@ for yn in (\"no\", \"yes\")\n end\n \n # issue #39259, shadowing `ARGS`\n-@test success(`$(Base.julia_cmd()) --startup-file=no -e 'ARGS=1'`)\n+@test \"\" == test_read_success(`$(Base.julia_cmd()) --startup-file=no -e 'ARGS=1'`)\n \n @testset \"- as program file reads from stdin\" begin\n     for args in (`- foo bar`, `-- - foo bar`)\n@@ -1363,9 +1364,9 @@ end\n # test --bug-report=rr\n if Sys.islinux() && Sys.ARCH in (:i686, :x86_64) # rr is only available on these platforms\n     mktempdir() do temp_trace_dir\n-        @test success(pipeline(setenv(`$(Base.julia_cmd()) --bug-report=rr-local -e 'exit()'`,\n-                                      \"JULIA_RR_RECORD_ARGS\" => \"-n --nested=ignore\",\n-                                      \"_RR_TRACE_DIR\" => temp_trace_dir); #=stderr, stdout=#))\n+        test_read_success(setenv(`$(Base.julia_cmd()) --bug-report=rr-local -e 'exit()'`,\n+                                 \"JULIA_RR_RECORD_ARGS\" => \"-n --nested=ignore\",\n+                                 \"_RR_TRACE_DIR\" => temp_trace_dir))\n     end\n end\n \n@@ -1453,7 +1454,7 @@ end\n \n @testset \"--strip-metadata\" begin\n     mktempdir() do dir\n-        @test success(pipeline(`$(Base.julia_cmd()) --strip-metadata -t1,0 --output-o $(dir)/sys.o.a -e 0`, stderr=stderr, stdout=stdout))\n+        @test \"\" == test_read_success(`$(Base.julia_cmd()) --strip-metadata -t1,0 --output-o $(dir)/sys.o.a -e 0`)\n         if isfile(joinpath(dir, \"sys.o.a\"))\n             Base.Linking.link_image(joinpath(dir, \"sys.o.a\"), joinpath(dir, \"sys.so\"))\n             @test readchomp(`$(Base.julia_cmd()) -t1,0 -J $(dir)/sys.so -E 'hasmethod(sort, (Vector{Int},), (:dims,))'`) == \"true\"\n@@ -1462,4 +1463,4 @@ end\n end\n \n # https://github.com/JuliaLang/julia/issues/58229 Recursion in jitlinking with inline=no\n-@test success(`$(Base.julia_cmd()) --inline=no -e 'Base.compilecache(Base.identify_package(\"Pkg\"))'`)\n+@test \"\" == test_read_success(`$(Base.julia_cmd()) --inline=no -e 'Base.compilecache(Base.identify_package(\"Pkg\"))'`)"
    },
    {
      "sha": "c71500afcbe39aeae70c9465e29265fb533e7e96",
      "filename": "test/core.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/0d19993bc53839836bd9aad370681b5d03cd8eab/test%2Fcore.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/0d19993bc53839836bd9aad370681b5d03cd8eab/test%2Fcore.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fcore.jl?ref=0d19993bc53839836bd9aad370681b5d03cd8eab",
      "patch": "@@ -16,7 +16,7 @@ include(\"tempdepot.jl\")\n # sanity tests that our built-in types are marked correctly for const fields\n for (T, c) in (\n         (Core.CodeInfo, []),\n-        (Core.CodeInstance, [:def, :owner, :rettype, :exctype, :rettype_const, :analysis_results, :time_infer_total, :time_infer_cache_saved, :time_infer_self]),\n+        (Core.CodeInstance, [:def, :owner, :rettype, :exctype, :rettype_const, :time_infer_total, :time_infer_cache_saved, :time_infer_self]),\n         (Core.Method, [#=:name, :module, :file, :line, :primary_world, :sig, :slot_syms, :external_mt, :nargs, :called, :nospecialize, :nkw, :isva, :is_for_opaque_closure, :constprop=#]),\n         (Core.MethodInstance, [#=:def, :specTypes, :sparam_vals=#]),\n         (Core.MethodTable, [:cache, :module, :name]),"
    }
  ]
}