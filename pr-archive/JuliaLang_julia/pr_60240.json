{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60240",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60240/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60240/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60240/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60240",
  "id": 3662960260,
  "node_id": "PR_kwDOABkWpM61aatq",
  "number": 60240,
  "title": "REPL: Use event to orchestrate precompilation script",
  "user": {
    "login": "IanButterworth",
    "id": 1694067,
    "node_id": "MDQ6VXNlcjE2OTQwNjc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1694067?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/IanButterworth",
    "html_url": "https://github.com/IanButterworth",
    "followers_url": "https://api.github.com/users/IanButterworth/followers",
    "following_url": "https://api.github.com/users/IanButterworth/following{/other_user}",
    "gists_url": "https://api.github.com/users/IanButterworth/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/IanButterworth/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/IanButterworth/subscriptions",
    "organizations_url": "https://api.github.com/users/IanButterworth/orgs",
    "repos_url": "https://api.github.com/users/IanButterworth/repos",
    "events_url": "https://api.github.com/users/IanButterworth/events{/privacy}",
    "received_events_url": "https://api.github.com/users/IanButterworth/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 210703,
      "node_id": "MDU6TGFiZWwyMTA3MDM=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/building",
      "name": "building",
      "color": "444444",
      "default": false,
      "description": "Build system, or building Julia or its dependencies"
    },
    {
      "id": 42281298,
      "node_id": "MDU6TGFiZWw0MjI4MTI5OA==",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/REPL",
      "name": "REPL",
      "color": "c7def8",
      "default": false,
      "description": "Julia's REPL (Read Eval Print Loop)"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 10,
  "created_at": "2025-11-25T12:54:35Z",
  "updated_at": "2025-12-05T20:36:07Z",
  "closed_at": "2025-12-05T20:36:06Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60240",
    "html_url": "https://github.com/JuliaLang/julia/pull/60240",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60240.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60240.patch",
    "merged_at": "2025-12-05T20:36:05Z"
  },
  "body": "Fixes #60239 \r\n\r\n- ~Make building the stdlibs throw if they error(!).. I believe they used to but regressed somewhere..~ #60308 \r\n- Add a prompt `Base.event` to REPL and use it to orchestrate the precompile script, rather than awkwardly reading for prompt prints",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60240/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60240/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "64576f55f8b9a1819867e395ac4ea7e3230113bd",
      "filename": "stdlib/REPL/src/LineEdit.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib%2FREPL%2Fsrc%2FLineEdit.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FLineEdit.jl?ref=443ece3094de43696047f3e2c7091aa16f6a5a5a",
      "patch": "@@ -85,9 +85,11 @@ mutable struct MIState\n     line_modify_lock::Base.ReentrantLock\n     hint_generation_lock::Base.ReentrantLock\n     n_keys_pressed::Int\n+    # Optional event that gets notified each time the prompt is ready for input\n+    prompt_ready_event::Union{Nothing, Base.Event}\n end\n \n-MIState(i, mod, c, a, m) = MIState(i, mod, mod, c, a, m, String[], 0, Char[], 0, :none, :none, Channel{Function}(), Base.ReentrantLock(), Base.ReentrantLock(), 0)\n+MIState(i, mod, c, a, m) = MIState(i, mod, mod, c, a, m, String[], 0, Char[], 0, :none, :none, Channel{Function}(), Base.ReentrantLock(), Base.ReentrantLock(), 0, nothing)\n \n const BufferLike = Union{MIState,ModeState,IOBuffer}\n const State = Union{MIState,ModeState}\n@@ -2977,6 +2979,10 @@ function prompt!(term::TextTerminal, prompt::ModalInterface, s::MIState = init_s\n     enable_bracketed_paste(term)\n     try\n         activate(prompt, s, term, term)\n+        # Notify that prompt is ready for input\n+        if s.prompt_ready_event !== nothing\n+            notify(s.prompt_ready_event)\n+        end\n         old_state = mode(s)\n         # spawn this because the main repl task is sticky (due to use of @async and _wait2)\n         # and we want to not block typing when the repl task thread is busy"
    },
    {
      "sha": "f9f8c90d0f049e5612350dd051547368d402097e",
      "filename": "stdlib/REPL/src/REPL.jl",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib%2FREPL%2Fsrc%2FREPL.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2FREPL.jl?ref=443ece3094de43696047f3e2c7091aa16f6a5a5a",
      "patch": "@@ -779,14 +779,18 @@ mutable struct LineEditREPL <: AbstractREPL\n     interface::ModalInterface\n     backendref::REPLBackendRef\n     frontend_task::Task\n+    # Optional event to notify when the prompt is ready (used by precompilation)\n+    prompt_ready_event::Union{Nothing, Base.Event}\n     function LineEditREPL(t,hascolor,prompt_color,input_color,answer_color,shell_color,help_color,pkg_color,history_file,in_shell,in_help,envcolors)\n         opts = Options()\n         opts.hascolor = hascolor\n         if !hascolor\n             opts.beep_colors = [\"\"]\n         end\n-        new(t,hascolor,prompt_color,input_color,answer_color,shell_color,help_color,pkg_color,history_file,in_shell,\n+        r = new(t,hascolor,prompt_color,input_color,answer_color,shell_color,help_color,pkg_color,history_file,in_shell,\n             in_help,envcolors,false,nothing, opts, nothing, Tuple{String,Int}[])\n+        r.prompt_ready_event = nothing\n+        r\n     end\n end\n outstream(r::LineEditREPL) = (t = r.t; t isa TTYTerminal ? t.out_stream : t)\n@@ -1665,6 +1669,10 @@ function run_frontend(repl::LineEditREPL, backend::REPLBackendRef)\n     end\n     repl.backendref = backend\n     repl.mistate = LineEdit.init_state(terminal(repl), interface)\n+    # Copy prompt_ready_event from repl to mistate (used by precompilation)\n+    if isdefined(repl, :prompt_ready_event) && repl.prompt_ready_event !== nothing\n+        repl.mistate.prompt_ready_event = repl.prompt_ready_event\n+    end\n     run_interface(terminal(repl), interface, repl.mistate)\n     # Terminate Backend\n     put!(backend.repl_channel, (nothing, -1))"
    },
    {
      "sha": "4bd76e8da7585fae390a07547fa497bc860cb197",
      "filename": "stdlib/REPL/src/precompile.jl",
      "status": "modified",
      "additions": 48,
      "deletions": 64,
      "changes": 112,
      "blob_url": "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib%2FREPL%2Fsrc%2Fprecompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib%2FREPL%2Fsrc%2Fprecompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FREPL%2Fsrc%2Fprecompile.jl?ref=443ece3094de43696047f3e2c7091aa16f6a5a5a",
      "patch": "@@ -15,42 +15,55 @@ finally\n end\n \n function repl_workload()\n-    # these are intentionally triggered\n+    # Capture debug output to show if something goes wrong\n+    debug_output = IOBuffer()\n+\n+    # Errors that are intentionally triggered by the script\n     allowed_errors = [\n         \"BoundsError: attempt to access 0-element Vector{Any} at index [1]\",\n         \"MethodError: no method matching f(::$Int, ::$Int)\",\n         \"Padding of type\", # reinterpret docstring has ERROR examples\n     ]\n-    function check_errors(out)\n-        str = String(out)\n-        if occursin(\"ERROR:\", str) && !any(occursin(e, str) for e in allowed_errors)\n-            @error \"Unexpected error (Review REPL precompilation with debug_output on):\\n$str\" exception=(\n-                Base.PrecompilableError(), Base.backtrace())\n-            exit(1)\n+\n+    function check_output()\n+        str = String(take!(copy(debug_output)))\n+        for line in eachline(IOBuffer(str))\n+            if occursin(\"ERROR:\", line) && !any(e -> occursin(e, line), allowed_errors)\n+                println(stderr, \"\"\"\n+                ========================================================================\n+                ERROR: Unexpected error during REPL precompilation\n+                ========================================================================\n+                Debug output:\n+                ------------------------------------------------------------------------\n+                \"\"\")\n+                println(stderr, str)\n+                println(stderr, \"========================================================================\")\n+                error(\"REPL precompilation encountered unexpected error: $line\")\n+            end\n         end\n     end\n-    ## Debugging options\n-    # View the code sent to the repl by setting this to `stdout`\n-    debug_output = devnull # or stdout\n \n     CTRL_C = '\\x03'\n     CTRL_D = '\\x04'\n     CTRL_R = '\\x12'\n     UP_ARROW = \"\\e[A\"\n     DOWN_ARROW = \"\\e[B\"\n \n-    # This is notified as soon as the first prompt appears\n-    repl_init_event = Base.Event()\n-    repl_init_done_event = Base.Event()\n+    # Event that REPL notifies each time it's ready for input (autoreset so each wait blocks until next notify)\n+    prompt_ready = Base.Event(true)\n+    # Event to signal that REPL.activate has been called\n+    activate_done = Base.Event()\n \n     atreplinit() do repl\n-        # Main is closed so we can't evaluate in it, but atreplinit runs at\n-        # a time that repl.mistate === nothing so REPL.activate fails. So do\n-        # it async and wait for the first prompt to know its ready.\n+        # Set the prompt_ready_event on the repl - run_frontend will copy it to mistate\n+        if repl isa REPL.LineEditREPL\n+            repl.prompt_ready_event = prompt_ready\n+        end\n+        # Start async task to wait for first prompt then activate the module\n         t = @async begin\n-            wait(repl_init_event)\n+            wait(prompt_ready)\n             REPL.activate(REPL.Precompile; interactive_utils=false)\n-            notify(repl_init_done_event)\n+            notify(activate_done)\n         end\n         Base.errormonitor(t)\n     end\n@@ -83,14 +96,6 @@ function repl_workload()\n     println(\"done\")\n     \"\"\"\n \n-    JULIA_PROMPT = \"julia> \"\n-    # The help text for `reinterpret` has example `julia>` prompts in it,\n-    # so use the longer prompt to avoid desychronization.\n-    ACTIVATED_JULIA_PROMPT = \"(REPL.Precompile) julia> \"\n-    PKG_PROMPT = \"pkg> \"\n-    SHELL_PROMPT = \"shell> \"\n-    HELP_PROMPT = \"help?> \"\n-\n     tmphistfile = tempname()\n     write(tmphistfile, \"\"\"\n     # time: 2020-10-31 13:16:39 AWST\n@@ -120,20 +125,16 @@ function repl_workload()\n             Base._fd(pts) == rawpts || Base.close_stdio(rawpts)\n         end\n         # Prepare a background process to copy output from `ptm` until `pts` is closed\n-        output_copy = Base.BufferStream()\n         tee = @async try\n             while !eof(ptm)\n                 l = readavailable(ptm)\n                 write(debug_output, l)\n-                write(output_copy, l)\n             end\n-            write(debug_output, \"\\n#### EOF ####\\n\")\n         catch ex\n             if !(ex isa Base.IOError && ex.code == Base.UV_EIO)\n                 rethrow() # ignore EIO on ptm after pts dies\n             end\n         finally\n-            close(output_copy)\n             close(ptm)\n         end\n         Base.errormonitor(tee)\n@@ -159,46 +160,27 @@ function repl_workload()\n                 redirect_stderr(isopen(orig_stderr) ? orig_stderr : devnull)\n             end\n             schedule(repltask)\n-            # wait for the definitive prompt before start writing to the TTY\n-            check_errors(readuntil(output_copy, JULIA_PROMPT, keep=true))\n-\n-            # Switch to the activated prompt\n-            notify(repl_init_event)\n-            wait(repl_init_done_event)\n+            # Wait for the first prompt, then for activate to complete\n+            wait(activate_done)\n+            # Send a newline to get the activated prompt\n             write(ptm, \"\\n\")\n-            # The prompt prints twice - once for the restatement of the input, once\n-            # to indicate ready for the new prompt.\n-            check_errors(readuntil(output_copy, ACTIVATED_JULIA_PROMPT, keep=true))\n-            check_errors(readuntil(output_copy, ACTIVATED_JULIA_PROMPT, keep=true))\n+            # Wait for the new prompt to be ready\n+            wait(prompt_ready)\n \n-            write(debug_output, \"\\n#### REPL STARTED ####\\n\")\n             # Input our script\n             precompile_lines = split(repl_script::String, '\\n'; keepempty=false)\n-            curr = 0\n             for l in precompile_lines\n-                sleep(0.01) # try to let a bit of output accumulate before reading again\n-                curr += 1\n-                # push our input\n-                write(debug_output, \"\\n#### inputting statement: ####\\n$(repr(l))\\n####\\n\")\n-                # If the line ends with a CTRL_C, don't write an extra newline, which would\n-                # cause a second empty prompt. Our code below expects one new prompt per\n-                # input line and can race out of sync with the unexpected second line.\n-                endswith(l, CTRL_C) ? write(ptm, l) : write(ptm, l, \"\\n\")\n-                check_errors(readuntil(output_copy, \"\\n\"))\n-                # wait for the next prompt-like to appear\n-                check_errors(readuntil(output_copy, \"\\n\"))\n-                strbuf = \"\"\n-                while !eof(output_copy)\n-                    strbuf *= String(readavailable(output_copy))\n-                    occursin(ACTIVATED_JULIA_PROMPT, strbuf) && break\n-                    occursin(PKG_PROMPT, strbuf) && break\n-                    occursin(SHELL_PROMPT, strbuf) && break\n-                    occursin(HELP_PROMPT, strbuf) && break\n-                    sleep(0.01) # try to let a bit of output accumulate before reading again\n+                # If the line ends with a CTRL_C, don't write an extra newline\n+                # CTRL_C cancels input but doesn't print a new prompt, so don't wait\n+                if endswith(l, CTRL_C)\n+                    write(ptm, l)\n+                    sleep(0.1)  # Brief pause to let CTRL_C be processed\n+                else\n+                    write(ptm, l, \"\\n\")\n+                    # Wait for REPL to signal it's ready for next input\n+                    wait(prompt_ready)\n                 end\n-                check_errors(strbuf)\n             end\n-            write(debug_output, \"\\n#### COMPLETED - Closing REPL ####\\n\")\n             write(ptm, \"$CTRL_D\")\n             wait(repltask)\n         finally\n@@ -208,7 +190,9 @@ function repl_workload()\n         end\n         wait(tee)\n     end\n-    write(debug_output, \"\\n#### FINISHED ####\\n\")\n+    # Check for any unexpected errors in the output\n+    check_output()\n+    rm(tmphistfile, force=true)\n     nothing\n end\n "
    },
    {
      "sha": "3dbab7332e76b9fbf595e40cc06f3f6d69a08e7f",
      "filename": "test/precompile.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/test%2Fprecompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/443ece3094de43696047f3e2c7091aa16f6a5a5a/test%2Fprecompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fprecompile.jl?ref=443ece3094de43696047f3e2c7091aa16f6a5a5a",
      "patch": "@@ -1419,7 +1419,7 @@ precompile_test_harness(\"conflicting namespaces\") do dir\n         try\n             for i = 1:2\n                 @test readchomp(pipeline(`$exename -E $(testcode)`, stderr=fname)) == \"nothing\"\n-                @test read(fname, String) == \"Iterators\\n\"\n+                @test endswith(read(fname, String), \"Iterators\\n\")\n             end\n         finally\n             rm(fname, force=true)"
    }
  ]
}