{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60316",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60316/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60316/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60316/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60316",
  "id": 3696407769,
  "node_id": "PR_kwDOABkWpM63KYJM",
  "number": 60316,
  "title": "[JuliaLowering] Refactor scope resolution pass",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 250223102,
      "node_id": "MDU6TGFiZWwyNTAyMjMxMDI=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:lowering",
      "name": "compiler:lowering",
      "color": "5319e7",
      "default": false,
      "description": "Syntax lowering (compiler front end, 2nd stage)"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 9,
  "created_at": "2025-12-04T20:24:05Z",
  "updated_at": "2025-12-12T01:38:34Z",
  "closed_at": "2025-12-11T18:05:19Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60316",
    "html_url": "https://github.com/JuliaLang/julia/pull/60316",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60316.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60316.patch",
    "merged_at": "2025-12-11T18:05:18Z"
  },
  "body": "## Fixes\r\n\r\n### Soft scope\r\nWe currently treat flisp's `'(block (softscope true))` as a scope that \"is\r\nsoft\", but this isn't correct. It should behave more like a toggle, where if the\r\nscope surrounding `(softscope true)` is the top-level thunk, neutral scopes not\r\nprotected by a hard scope become permeable to already-defined globals.  I've\r\nadded `K\"softscope\"` for this.\r\n\r\nFixes https://github.com/JuliaLang/JuliaLowering.jl/issues/101.\r\n`JuliaLowering.activate!()` should be much more usable in the REPL now, as\r\nglobals won't be accidentally eaten by the \"soft scope.\"\r\n\r\n### Shadowing behaviour\r\nFound while cleaning up the lhs-resolution step with the change above.  This PR\r\nallows static parameters to be shadowed by globals and locals as long as they're\r\nexplicit (and not in the same scope).  flisp allows this with globals, and the\r\nexplicit locals that desugar to `local-def` forms (which JuliaLowering doesn't\r\nhave).\r\n\r\nThis change is more permissive than flisp in the local case, since after looking\r\ninto why shadowing was disallowed I realized it was just was just to prevent\r\nassignment to the static parameter (#32623).  The flisp fix leads to some funny\r\nbehaviour:\r\n\r\n```\r\njulia> function f(x::T) where T\r\n     let\r\n         global T # remove this T and the other two will fight\r\n         let; local T; end\r\n     end\r\n     end\r\nf (generic function with 1 method)\r\n```\r\n\r\n### Bindings/LambdaBindings\r\nIn figuring out how to use the variable bookkeeping system, I ran into inaccuracies.\r\n\r\n`LambdaBindings` is currently a per-lambda map from unique variable to four\r\nflags: `captured`, `read`, `assigned`, and `called`.  I think (but correct me if\r\nI'm wrong @c42f) this was a misinterpretation of the holy text: in flisp\r\nlowering, a local variable captured by some other lambda does show up in both\r\nlambdas' variable lists, but is the same underlying object, and flag mutations\r\non one variable are seen by all lambdas.\r\n\r\nI tried to think of other reasons for tracking vinfo per lambda within lowering,\r\nbut if we're doing something about the capture-boxing issue, we need something\r\nmore complex anyway.\r\n\r\nThis PR moves all vinfo to `BindingInfo` and deletes the incorrect bookkeeping\r\nin `LambdaBindings`. We still need to have a per-lambda flag for capturedness\r\n(different from the variable-level `capt` vinfo flag). With the added flags,\r\nI've just made BindingInfo mutable since our previous workflow (BindingId is an\r\nindex into a vector; mutate the vector) doesn't give us the benefits of\r\nimmutability anyway.\r\n\r\n## Enhancements\r\n- Scopes are retained until the end of the pass, so consumers like JETLS can\r\n  answer questions like \"what names are available at my cursor?\"  Recreating\r\n  this previously-discarded information was a bit hacky! [[1]](https://github.com/aviatesk/JETLS.jl/blob/6b43afe9e6f5392fc63714a8127a7653e94d9dba/src/utils/ast.jl#L115-L200) [[2]](https://github.com/iuliadmtru/ScopeVars/blob/f7da77eb07d644d3bcd57a3677791b6158d2d8b1/src/find_scope_vars.jl)\r\n- Hopefully enough tests and explanatory comments to make up for the large diff\r\n\r\n## TODO\r\n- Our use of `K\"local\"` in desugaring is dubious in some places\r\n- I've added `expr_compat_mode` to the scope analysis context, but we still need\r\n  to implement flisp hygiene exemptions for globals (see note in test/scopes.jl).\r\n- Reviewing the IR changes, the `#self#` argument still has extra flags set in\r\n  some cases.  This is an existing desugaring bug with a comment that took me\r\n  too long to find: we shouldnn't be using the same `#self#` binding for\r\n  multiple methods defined by one function body\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60316/reactions",
    "total_count": 5,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 5,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60316/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "f27f88729f666b00653a781f3d12973dfb63e281",
      "filename": "JuliaLowering/src/ast.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fast.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fast.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fast.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -66,7 +66,7 @@ Unique symbolic identity for a variable, constant, label, or other entity\n const IdTag = Int\n \n \"\"\"\n-Id for scope layers in macro expansion\n+Id for hygienic scope layers in macro expansion\n \"\"\"\n const LayerId = Int\n \n@@ -85,6 +85,11 @@ struct ScopeLayer\n     is_macro_expansion::Bool # FIXME\n end\n \n+\"\"\"\n+Lexical scope ID\n+\"\"\"\n+const ScopeId = Int\n+\n #-------------------------------------------------------------------------------\n # AST creation utilities\n _node_id(graph::SyntaxGraph, ex::SyntaxTree) = (check_compatible_graph(graph, ex); ex._id)\n@@ -170,7 +175,8 @@ function newleaf(ctx, srcref, k::Kind, @nospecialize(value))\n         setattr!(leaf._graph, leaf._id, :id, value)\n     elseif k == K\"symbolic_label\"\n         setattr!(leaf._graph, leaf._id, :name_val, value)\n-    elseif k in KSet\"TOMBSTONE SourceLocation latestworld latestworld_if_toplevel\"\n+    elseif k in KSet\"TOMBSTONE SourceLocation latestworld latestworld_if_toplevel\n+                     softscope\"\n         # no attributes\n     else\n         val = k == K\"Integer\" ? convert(Int,     value) :"
    },
    {
      "sha": "c9dfaebd6074c22cc9b4829107728db6d91c2c5a",
      "filename": "JuliaLowering/src/bindings.jl",
      "status": "modified",
      "additions": 88,
      "deletions": 157,
      "changes": 245,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fbindings.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fbindings.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fbindings.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -1,74 +1,69 @@\n \"\"\"\n Metadata about a binding\n \"\"\"\n-struct BindingInfo\n-    id::IdTag                 # Unique integer identifying this binding\n-    name::String\n-    kind::Symbol              # :local :global :argument :static_parameter\n-    node_id::Int              # ID of associated K\"BindingId\" node in the syntax graph\n-    mod::Union{Nothing,Module} # Set when `kind === :global`\n+mutable struct BindingInfo\n+    const id::IdTag                 # Unique integer identifying this binding\n+    const name::String\n+    const kind::Symbol              # :local :global :argument :static_parameter\n+    const node_id::Int              # ID of some K\"BindingId\" node in the syntax graph\n+    const mod::Union{Nothing,Module} # Set when `kind === :global`\n     type::Union{Nothing,SyntaxTree} # Type, for bindings declared like x::T = 10\n-    n_assigned::Int32         # Number of times variable is assigned to\n     is_const::Bool            # Constant, cannot be reassigned\n     is_ssa::Bool              # Single assignment, defined before use\n-    is_captured::Bool         # Variable is captured by some lambda\n-    is_always_defined::Bool   # A local that we know has an assignment that dominates all usages (is never undef)\n     is_internal::Bool         # True for internal bindings generated by the compiler\n     is_ambiguous_local::Bool  # Local, but would be global in soft scope (ie, the REPL)\n-    is_nospecialize::Bool     # @nospecialize on this argument (only valid for kind == :argument)\n+\n+    # flisp: vinfo\n+    is_nospecialize::Bool # @nospecialize on this argument (only valid for kind == :argument)\n+    is_read::Bool\n+    is_called::Bool\n+    is_assigned::Bool # the implicit assignment to arguments doesn't count\n+    is_assigned_once::Bool\n+    is_captured::Bool\n+    is_always_defined::Bool\n+    is_used_undef::Bool\n end\n \n function BindingInfo(id::IdTag, name::AbstractString, kind::Symbol, node_id::Integer;\n                      mod::Union{Nothing,Module} = nothing,\n                      type::Union{Nothing,SyntaxTree} = nothing,\n-                     n_assigned::Integer = 0,\n                      is_const::Bool = false,\n                      is_ssa::Bool = false,\n-                     is_captured::Bool = false,\n-                     is_always_defined::Bool = is_ssa,\n                      is_internal::Bool = false,\n                      is_ambiguous_local::Bool = false,\n-                     is_nospecialize::Bool = false)\n-    BindingInfo(id, name, kind, node_id, mod, type, n_assigned, is_const,\n-                is_ssa, is_captured, is_always_defined,\n-                is_internal, is_ambiguous_local, is_nospecialize)\n+                     is_nospecialize::Bool = false,\n+                     is_read::Bool = false,\n+                     is_called::Bool = false,\n+                     is_assigned::Bool = false,\n+                     is_assigned_once::Bool = false,\n+                     is_captured::Bool = false,\n+                     is_always_defined::Bool = is_ssa || kind === :argument,\n+                     is_used_undef::Bool = false)\n+    BindingInfo(id, name, kind, node_id, mod, type, is_const, is_ssa,\n+                is_internal, is_ambiguous_local, is_nospecialize, is_read,\n+                is_called, is_assigned, is_assigned_once, is_captured,\n+                is_always_defined, is_used_undef)\n end\n \n function Base.show(io::IO, binfo::BindingInfo)\n-    print(io, \"BindingInfo(\", binfo.id, \", \",\n-          repr(binfo.name), \", \",\n-          repr(binfo.kind), \", \",\n-          binfo.node_id)\n-    if !isnothing(binfo.mod)\n-        print(io, \", mod=\", binfo.mod)\n-    end\n-    if !isnothing(binfo.type)\n-        print(io, \", type=\", binfo.type)\n-    end\n-    if binfo.n_assigned != 0\n-        print(io, \", n_assigned=\", binfo.n_assigned)\n-    end\n-    if binfo.is_const\n-        print(io, \", is_const=\", binfo.is_const)\n-    end\n-    if binfo.is_ssa\n-        print(io, \", is_ssa=\", binfo.is_ssa)\n-    end\n-    if binfo.is_captured\n-        print(io, \", is_captured=\", binfo.is_captured)\n-    end\n-    if binfo.is_always_defined != binfo.is_ssa\n-        print(io, \", is_always_defined=\", binfo.is_always_defined)\n-    end\n-    if binfo.is_internal\n-        print(io, \", is_internal=\", binfo.is_internal)\n-    end\n-    if binfo.is_ambiguous_local\n-        print(io, \", is_ambiguous_local=\", binfo.is_ambiguous_local)\n-    end\n-    if binfo.is_nospecialize\n-        print(io, \", is_nospecialize=\", binfo.is_nospecialize)\n-    end\n+    print(io, \"BindingInfo(\", binfo.id,\n+          \", \", repr(binfo.name),\n+          \", \", repr(binfo.kind),\n+          \", \", binfo.node_id)\n+    !isnothing(binfo.mod)    && print(io, \", mod=\", binfo.mod)\n+    !isnothing(binfo.type)   && print(io, \", type=\", binfo.type)\n+    binfo.is_const           && print(io, \", is_const=true\")\n+    binfo.is_ssa             && print(io, \", is_ssa=true\")\n+    binfo.is_internal        && print(io, \", is_internal=true\")\n+    binfo.is_ambiguous_local && print(io, \", is_ambiguous_local=true\")\n+    binfo.is_nospecialize    && print(io, \", is_nospecialize=true\")\n+    binfo.is_read            && print(io, \", is_read=true\")\n+    binfo.is_called          && print(io, \", is_called=true\")\n+    binfo.is_assigned        && print(io, \", is_assigned=true\")\n+    binfo.is_assigned_once   && print(io, \", is_assigned_once=true\")\n+    binfo.is_captured        && print(io, \", is_captured=true\")\n+    binfo.is_always_defined  && print(io, \", is_always_defined=true\")\n+    binfo.is_used_undef      && print(io, \", is_used_undef=true\")\n     print(io, \")\")\n end\n \n@@ -106,147 +101,83 @@ function _binding_id(ex::SyntaxTree)\n     ex.var_id\n end\n \n-function update_binding!(bindings::Bindings, x;\n-        type=nothing, is_const=nothing, add_assigned=0,\n-        is_always_defined=nothing, is_captured=nothing)\n-    id = _binding_id(x)\n-    b = lookup_binding(bindings, id)\n-    bindings.info[id] = BindingInfo(\n-        b.id,\n-        b.name,\n-        b.kind,\n-        b.node_id,\n-        b.mod,\n-        isnothing(type) ? b.type : type,\n-        b.n_assigned + add_assigned,\n-        isnothing(is_const) ? b.is_const : is_const,\n-        b.is_ssa,\n-        isnothing(is_captured) ? b.is_captured : is_captured,\n-        isnothing(is_always_defined) ? b.is_always_defined : is_always_defined,\n-        b.is_internal,\n-        b.is_ambiguous_local,\n-        b.is_nospecialize\n-    )\n-end\n-\n-function lookup_binding(bindings::Bindings, x)\n+function get_binding(bindings::Bindings, x)\n     bindings.info[_binding_id(x)]\n end\n \n-function lookup_binding(ctx::AbstractLoweringContext, x)\n-    lookup_binding(ctx.bindings, x)\n+function get_binding(ctx::AbstractLoweringContext, x)\n+    get_binding(ctx.bindings, x)\n end\n \n-function update_binding!(ctx::AbstractLoweringContext, x; kws...)\n-    update_binding!(ctx.bindings, x; kws...)\n-end\n-\n-function new_binding(ctx::AbstractLoweringContext, srcref::SyntaxTree,\n-                     name::AbstractString, kind::Symbol; kws...)\n+function _new_binding(ctx::AbstractLoweringContext, srcref::SyntaxTree,\n+                      name::AbstractString, kind::Symbol; kws...)\n     binding_id = next_binding_id(ctx.bindings)\n+    # A binding is only useful when it shows up in the tree, so create its tree\n+    # node eagerly and share it among uses (see `binding_ex`)\n     ex = @ast ctx srcref binding_id::K\"BindingId\"\n-    add_binding(ctx.bindings, BindingInfo(binding_id, name, kind, ex._id; kws...))\n-    ex\n+    b = BindingInfo(binding_id, name, kind, ex._id; kws...)\n+    add_binding(ctx.bindings, b)\n+    return b\n end\n \n # Create a new SSA binding\n function ssavar(ctx::AbstractLoweringContext, srcref, name=\"tmp\")\n     nameref = makeleaf(ctx, srcref, K\"Identifier\")\n     nameref.name_val = name\n-    new_binding(ctx, nameref, name, :local; is_ssa=true, is_internal=true)\n+    binding_ex(ctx, _new_binding(ctx, nameref, name, :local;\n+                                 is_ssa=true, is_internal=true))\n end\n \n # Create a new local mutable binding or lambda argument\n-function new_local_binding(ctx::AbstractLoweringContext, srcref, name; kind=:local, kws...)\n+function new_local_binding(ctx::AbstractLoweringContext, srcref, name;\n+                           kind=:local, kws...)\n     @assert kind === :local || kind === :argument\n     nameref = makeleaf(ctx, srcref, K\"Identifier\")\n     nameref.name_val = name\n-    ex = new_binding(ctx, nameref, name, kind; is_internal=true, kws...)\n+    b = _new_binding(ctx, nameref, name, kind; is_internal=true, kws...)\n     lbindings = current_lambda_bindings(ctx)\n     if !isnothing(lbindings)\n-        init_lambda_binding(lbindings, ex.var_id)\n+        init_lambda_binding(lbindings, b.id, false)\n     end\n-    ex\n+    binding_ex(ctx, b)\n end\n \n function new_global_binding(ctx::AbstractLoweringContext, srcref, name, mod; kws...)\n     nameref = makeleaf(ctx, srcref, K\"Identifier\")\n     nameref.name_val = name\n-    new_binding(ctx, nameref, name, :global; is_internal=true, mod=mod, kws...)\n+    binding_ex(ctx, _new_binding(\n+        ctx, nameref, name, :global; is_internal=true, mod=mod, kws...))\n end\n \n-function binding_ex(ctx::AbstractLoweringContext, id::IdTag)\n+function binding_ex(ctx::AbstractLoweringContext, b::BindingInfo)\n     # Reconstruct the SyntaxTree for this binding. We keep only the node_id\n     # here, because that's got a concrete type. Whereas if we stored SyntaxTree\n     # that would contain the type of the graph used in the pass where the\n     # bindings were created and we'd need to call reparent(), etc.\n-    SyntaxTree(syntax_graph(ctx), lookup_binding(ctx, id).node_id)\n-end\n-\n-\n-#-------------------------------------------------------------------------------\n-\"\"\"\n-Metadata about how a binding is used within some enclosing lambda\n-\"\"\"\n-struct LambdaBindingInfo\n-    is_captured::Bool\n-    is_read::Bool\n-    is_assigned::Bool\n-    # Binding was the function name in a call. Used for specialization\n-    # heuristics in the optimizer.\n-    is_called::Bool\n-end\n-\n-LambdaBindingInfo() = LambdaBindingInfo(false, false, false, false)\n-\n-function LambdaBindingInfo(parent::LambdaBindingInfo;\n-                           is_captured = nothing,\n-                           is_read     = nothing,\n-                           is_assigned = nothing,\n-                           is_called   = nothing)\n-    LambdaBindingInfo(\n-        isnothing(is_captured) ? parent.is_captured : is_captured,\n-        isnothing(is_read)     ? parent.is_read     : is_read,\n-        isnothing(is_assigned) ? parent.is_assigned : is_assigned,\n-        isnothing(is_called)   ? parent.is_called   : is_called,\n-    )\n+    SyntaxTree(syntax_graph(ctx), b.node_id)\n end\n+binding_ex(ctx, id::IdTag) = binding_ex(ctx, get_binding(ctx, id))\n \n+# One lambda's variables\n struct LambdaBindings\n-    # Bindings used within the lambda\n+    # Binding ID of #self#\n     self::IdTag\n-    bindings::Dict{IdTag,LambdaBindingInfo}\n-end\n-\n-LambdaBindings(self::IdTag = 0) = LambdaBindings(self, Dict{IdTag,LambdaBindings}())\n-\n-function init_lambda_binding(bindings::LambdaBindings, id; kws...)\n-    @assert !haskey(bindings.bindings, id)\n-    bindings.bindings[id] = LambdaBindingInfo(LambdaBindingInfo(); kws...)\n-end\n-\n-function update_lambda_binding!(bindings::LambdaBindings, x; kws...)\n-    id = _binding_id(x)\n-    binfo = bindings.bindings[id]\n-    bindings.bindings[id] = LambdaBindingInfo(binfo; kws...)\n-end\n-\n-function update_lambda_binding!(ctx::AbstractLoweringContext, x; kws...)\n-    update_lambda_binding!(current_lambda_bindings(ctx), x; kws...)\n-end\n-\n-function lookup_lambda_binding(bindings::LambdaBindings, x)\n-    get(bindings.bindings, _binding_id(x), nothing)\n-end\n-\n-function lookup_lambda_binding(ctx::AbstractLoweringContext, x)\n-    lookup_lambda_binding(current_lambda_bindings(ctx), x)\n-end\n-\n-function has_lambda_binding(bindings::LambdaBindings, x)\n-    haskey(bindings.bindings, _binding_id(x))\n-end\n-\n-function has_lambda_binding(ctx::AbstractLoweringContext, x)\n-    has_lambda_binding(current_lambda_bindings(ctx), x)\n+    # For finding the parent lambda in variable analysis\n+    scope_id::ScopeId\n+    # A map from every referenced local binding ID to whether the local is\n+    # captured (true) or native to this lambda (false).  References in inner\n+    # lambdas count: `inner.locals_capt[id]` implies `haskey(locals_capt, id)`\n+    # TODO: If we use scope ID as a lambda ID and give BindingInfo a field\n+    # noting which lambda it belongs to, we could just make this a BitSet of\n+    # vars present, where we tell if a binding is captured by comparing\n+    # this.scope_id with the BindingInfo's scope_id.\n+    locals_capt::Dict{IdTag,Bool}\n+end\n+\n+LambdaBindings(self::IdTag = 0, scope_id::ScopeId = 0) =\n+    LambdaBindings(self, scope_id, Dict{IdTag,LambdaBindings}())\n+\n+function init_lambda_binding(bindings::LambdaBindings, id::IdTag, capt::Bool)\n+    @assert !haskey(bindings.locals_capt, id)\n+    bindings.locals_capt[id] = capt\n end"
    },
    {
      "sha": "7ff31cee0e971367beba01c6a8f27c957c3f6440",
      "filename": "JuliaLowering/src/closure_conversion.jl",
      "status": "modified",
      "additions": 16,
      "deletions": 18,
      "changes": 34,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fclosure_conversion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fclosure_conversion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fclosure_conversion.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -61,7 +61,8 @@ function captured_var_access(ctx, ex)\n end\n \n function get_box_contents(ctx::ClosureConversionCtx, var, box_ex)\n-    undef_var = new_local_binding(ctx, var, lookup_binding(ctx, var.var_id).name)\n+    undef_var = new_local_binding(ctx, var, get_binding(ctx, var.var_id).name;\n+                                  is_used_undef=true)\n     @ast ctx var [K\"block\"\n         box := box_ex\n         # Lower in an UndefVar check to a similarly named variable\n@@ -149,7 +150,7 @@ function make_globaldecl(ctx, src_ex, mod, name, strong=false, type=nothing; ret\n end\n \n function convert_global_assignment(ctx, ex, var, rhs0)\n-    binfo = lookup_binding(ctx, var)\n+    binfo = get_binding(ctx, var)\n     @assert binfo.kind == :global\n     stmts = SyntaxList(ctx)\n     decl = make_globaldecl(ctx, ex, binfo.mod, binfo.name, true; ret_nothing=true)\n@@ -197,7 +198,7 @@ function convert_assignment(ctx, ex)\n         return @ast ctx ex [K\"=\" var rhs0]\n     end\n     @chk kind(var) == K\"BindingId\"\n-    binfo = lookup_binding(ctx, var)\n+    binfo = get_binding(ctx, var)\n     if binfo.kind == :global\n         convert_global_assignment(ctx, ex, var, rhs0)\n     else\n@@ -233,10 +234,8 @@ end\n function closure_type_fields(ctx, srcref, closure_binds, is_opaque)\n     capture_ids = Vector{IdTag}()\n     for lambda_bindings in closure_binds.lambdas\n-        for (id, lbinfo) in lambda_bindings.bindings\n-            if lbinfo.is_captured\n-                push!(capture_ids, id)\n-            end\n+        for (id, is_capt) in lambda_bindings.locals_capt\n+            is_capt && push!(capture_ids, id)\n         end\n     end\n     # sort here to avoid depending on undefined Dict iteration order.\n@@ -253,7 +252,7 @@ function closure_type_fields(ctx, srcref, closure_binds, is_opaque)\n     else\n         field_names = Dict{String,IdTag}()\n         for id in capture_ids\n-            binfo = lookup_binding(ctx, id)\n+            binfo = get_binding(ctx, id)\n             # We name each field of the closure after the variable which was closed\n             # over, for clarity. Adding a suffix can be necessary when collisions\n             # occur due to macro expansion and generated bindings\n@@ -305,20 +304,19 @@ function is_boxed(binfo::BindingInfo)\n     # True for\n     # * :argument when it's not reassigned\n     # * :static_parameter (these can't be reassigned)\n-    defined_but_not_assigned = binfo.is_always_defined && binfo.n_assigned == 0\n+    defined_but_not_assigned = binfo.is_always_defined && !binfo.is_assigned\n     # For now, we box almost everything but later we'll want to do dominance\n     # analysis on the untyped IR.\n     return binfo.is_captured && !defined_but_not_assigned\n end\n \n function is_boxed(ctx, x)\n-    is_boxed(lookup_binding(ctx, x))\n+    is_boxed(get_binding(ctx, x))\n end\n \n # Is captured in the closure's `self` argument\n function is_self_captured(ctx, x)\n-    lbinfo = lookup_lambda_binding(ctx, x)\n-    !isnothing(lbinfo) && lbinfo.is_captured\n+    get(ctx.lambda_bindings.locals_capt, _binding_id(x), false)\n end\n \n # Map the children of `ex` through _convert_closures, lifting any toplevel\n@@ -359,7 +357,7 @@ function _convert_closures(ctx::ClosureConversionCtx, ex)\n     elseif k == K\"isdefined\"\n         # Convert isdefined expr to function for closure converted variables\n         var = ex[1]\n-        binfo = lookup_binding(ctx, var)\n+        binfo = get_binding(ctx, var)\n         if is_boxed(binfo)\n             access = is_self_captured(ctx, var) ? captured_var_access(ctx, var) : var\n             @ast ctx ex [K\"call\"\n@@ -382,7 +380,7 @@ function _convert_closures(ctx::ClosureConversionCtx, ex)\n         end\n     elseif k == K\"decl\"\n         @assert kind(ex[1]) == K\"BindingId\"\n-        binfo = lookup_binding(ctx, ex[1])\n+        binfo = get_binding(ctx, ex[1])\n         if binfo.kind == :global\n             # flisp has this, but our K\"assert\" handling is in a previous pass\n             # [K\"assert\" \"toplevel_only\"::K\"Symbol\" [K\"inert\" ex]]\n@@ -393,7 +391,7 @@ function _convert_closures(ctx::ClosureConversionCtx, ex)\n     elseif k == K\"global\"\n         # Leftover `global` forms become weak globals.\n         mod, name = if kind(ex[1]) == K\"BindingId\"\n-            binfo = lookup_binding(ctx, ex[1])\n+            binfo = get_binding(ctx, ex[1])\n             @assert binfo.kind == :global\n             binfo.mod, binfo.name\n         else\n@@ -404,7 +402,7 @@ function _convert_closures(ctx::ClosureConversionCtx, ex)\n         @ast ctx ex [K\"unused_only\" make_globaldecl(ctx, ex, mod, name, false)]\n     elseif k == K\"local\"\n         var = ex[1]\n-        binfo = lookup_binding(ctx, var)\n+        binfo = get_binding(ctx, var)\n         if binfo.is_captured\n             @ast ctx ex [K\"=\" var [K\"call\" \"Box\"::K\"core\"]]\n         elseif !binfo.is_always_defined\n@@ -482,14 +480,14 @@ function _convert_closures(ctx::ClosureConversionCtx, ex)\n         end\n     elseif k == K\"function_type\"\n         func_name = ex[1]\n-        if kind(func_name) == K\"BindingId\" && lookup_binding(ctx, func_name).kind === :local\n+        if kind(func_name) == K\"BindingId\" && get_binding(ctx, func_name).kind === :local\n             ctx.closure_infos[func_name.var_id].type_name\n         else\n             @ast ctx ex [K\"call\" \"Typeof\"::K\"core\" func_name]\n         end\n     elseif k == K\"method_defs\"\n         name = ex[1]\n-        is_closure = kind(name) == K\"BindingId\" && lookup_binding(ctx, name).kind === :local\n+        is_closure = kind(name) == K\"BindingId\" && get_binding(ctx, name).kind === :local\n         cap_rewrite = is_closure ? ctx.closure_infos[name.var_id] : nothing\n         ctx2 = ClosureConversionCtx(ctx.graph, ctx.bindings, ctx.mod,\n                                     ctx.closure_bindings, cap_rewrite, ctx.lambda_bindings,"
    },
    {
      "sha": "fe7376f83486d4405ce5b78b104122522eb20b3d",
      "filename": "JuliaLowering/src/compat.jl",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fcompat.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -520,15 +520,6 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n     elseif e.head === :islocal || e.head === :isglobal\n         st_k = K\"extension\"\n         child_exprs = [Expr(:quoted_symbol, e.head), e.args[1]]\n-    elseif e.head === :block && nargs >= 1 &&\n-        e.args[1] isa Expr && e.args[1].head === :softscope\n-        # (block (softscope true) ex) produced with every REPL prompt.\n-        # :hardscope exists too, but should just be a let, and appears to be\n-        # unused in the wild.\n-        ensure_attributes!(graph; scope_type=Symbol)\n-        st_k = K\"scope_block\"\n-        st_attrs[:scope_type] = :soft\n-        child_exprs = e.args[2:end]\n     end\n \n     #---------------------------------------------------------------------------"
    },
    {
      "sha": "ad850e5a56d539ed158eef33eda7d56ad0aed005",
      "filename": "JuliaLowering/src/desugaring.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fdesugaring.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -51,7 +51,7 @@ end\n \n function contains_ssa_binding(ctx, ex)\n     contains_unquoted(ex) do e\n-        kind(e) == K\"BindingId\" && lookup_binding(ctx, e).is_ssa\n+        kind(e) == K\"BindingId\" && get_binding(ctx, e).is_ssa\n     end\n end\n \n@@ -2970,6 +2970,9 @@ function expand_function_def(ctx, ex, docs, rewrite_call=identity, rewrite_body=\n         name\n     elseif kind(name) == K\"tuple\"\n         # Anonymous function syntax `function (x,y) ... end`\n+        name = mapchildren(ctx, name) do a\n+            kind(a) === K\"=\" ? @ast(ctx, a, [K\"kw\" children(a)...]) : a\n+        end\n         @ast ctx name [K\"call\"\n             \"#anon#\"::K\"Placeholder\"\n             children(name)..."
    },
    {
      "sha": "8240d235e4865c4fcc2bf248d9c447055fe620e7",
      "filename": "JuliaLowering/src/kinds.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fkinds.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fkinds.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fkinds.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -78,6 +78,11 @@ function _register_kinds()\n             \"break_block\"\n             # Like block, but introduces a lexical scope; used during scope resolution.\n             \"scope_block\"\n+            # Equivalent to Expr(:softscope).  If found in the top-level thunk,\n+            # all enclosed neutral scopes become soft scopes.  :hardscope exists\n+            # too, but is always produced inside scope-blocks, so we represent\n+            # it with an attribute on our scope-blocks.\n+            \"softscope\"\n             # [K\"always_defined\" x] is an assertion that variable `x` is assigned before use\n             # ('local-def in flisp implementation is K\"local\" plus K\"always_defined\"\n             \"always_defined\"\n@@ -105,6 +110,8 @@ function _register_kinds()\n             \"_opaque_closure\"\n             # The enclosed statements must be executed at top level\n             \"toplevel_butfirst\"\n+            # like v = val, except that if `v` turns out global (either\n+            # implicitly or by explicit `global`), it gains an implicit `const`\n             \"assign_or_constdecl_if_global\"\n             \"moved_local\"\n             \"label\""
    },
    {
      "sha": "da9821e5ad1a21c54a34cd31db40df4e7490adb7",
      "filename": "JuliaLowering/src/linear_ir.jl",
      "status": "modified",
      "additions": 22,
      "deletions": 25,
      "changes": 47,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Flinear_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Flinear_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Flinear_ir.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -6,7 +6,7 @@ function is_valid_ir_argument(ctx, ex)\n     if is_simple_atom(ctx, ex) || k in KSet\"inert top core quote static_eval\"\n         true\n     elseif k == K\"BindingId\"\n-        binfo = lookup_binding(ctx, ex)\n+        binfo = get_binding(ctx, ex)\n         bk = binfo.kind\n         bk === :slot\n         # TODO: We should theoretically be able to allow `bk ===\n@@ -20,7 +20,7 @@ function is_valid_ir_argument(ctx, ex)\n end\n \n function is_ssa(ctx, ex)\n-    kind(ex) == K\"BindingId\" && lookup_binding(ctx, ex).is_ssa\n+    kind(ex) == K\"BindingId\" && get_binding(ctx, ex).is_ssa\n end\n \n # Target to jump to, including info on try handler nesting and catch block\n@@ -101,10 +101,8 @@ function is_valid_body_ir_argument(ctx, ex)\n     if is_valid_ir_argument(ctx, ex)\n         true\n     elseif kind(ex) == K\"BindingId\"\n-        binfo = lookup_binding(ctx, ex)\n-        # Arguments are always defined\n-        # TODO: use equiv of vinfo:never-undef when we have it\n-        binfo.kind == :argument\n+        binfo = get_binding(ctx, ex)\n+        binfo.kind == :argument && binfo.is_always_defined\n     else\n         false\n     end\n@@ -116,12 +114,12 @@ function is_simple_arg(ctx, ex)\n            k == K\"top\" || k == K\"core\" || k == K\"globalref\" || k == K\"static_eval\"\n end\n \n+# flisp note: arguments are always counted as single-assign, so effects on\n+# arguments within compile_args are thrown out (intentional?)\n function is_single_assign_var(ctx::LinearIRContext, ex)\n     kind(ex) == K\"BindingId\" || return false\n-    binfo = lookup_binding(ctx, ex)\n-    # Arguments are always single-assign\n-    # TODO: Use equiv of vinfo:sa when we have it\n-    return binfo.kind == :argument\n+    binfo = get_binding(ctx, ex)\n+    return binfo.kind == :argument || binfo.is_assigned_once\n end\n \n function is_const_read_arg(ctx, ex)\n@@ -143,7 +141,7 @@ end\n \n function check_no_local_bindings(ctx, ex, msg)\n     contains_nonglobal_binding = contains_unquoted(ex) do e\n-        kind(e) == K\"BindingId\" && lookup_binding(ctx, e).kind !== :global\n+        kind(e) == K\"BindingId\" && get_binding(ctx, e).kind !== :global\n     end\n     if contains_nonglobal_binding\n         throw(LoweringError(ex, msg))\n@@ -314,7 +312,7 @@ end\n # `op` may be either K\"=\" (where global assignments are converted to setglobal!)\n # or K\"constdecl\".  flisp: emit-assignment-or-setglobal\n function emit_simple_assignment(ctx, srcref, lhs, rhs, op=K\"=\")\n-    binfo = lookup_binding(ctx, lhs.var_id)\n+    binfo = get_binding(ctx, lhs.var_id)\n     if binfo.kind == :global\n         emit(ctx, @ast ctx srcref [\n             K\"call\"\n@@ -614,7 +612,7 @@ function compile(ctx::LinearIRContext, ex, needs_value, in_tail_pos)\n         elseif k == K\"constdecl\" && numchildren(ex) == 1\n             # No RHS - make undefined constant\n             mod, name = if kind(ex[1]) == K\"BindingId\"\n-                binfo = lookup_binding(ctx, ex[1])\n+                binfo = get_binding(ctx, ex[1])\n                 binfo.mod, binfo.name\n             else\n                 @assert kind(ex[1]) == K\"Value\" && typeof(ex[1].value) === GlobalRef\n@@ -903,7 +901,7 @@ function unnecessary_newvar_ids(ctx, stmts)\n         k = kind(ex)\n         if k == K\"newvar\"\n             id = ex[1].var_id\n-            if !lookup_binding(ctx, id).is_captured\n+            if !get_binding(ctx, id).is_captured\n                 push!(vars, id)\n             end\n         elseif k == K\"goto\" || k == K\"gotoifnot\" || (k == K\"=\" && kind(ex[2]) == K\"enter\")\n@@ -969,7 +967,7 @@ function _renumber(ctx, ssa_rewrites, slot_rewrites, label_table, ex)\n             makeleaf(ctx, ex, K\"SSAValue\", [:var_id=>ssa_rewrites[id]])\n         else\n             new_id = get(slot_rewrites, id, nothing)\n-            binfo = lookup_binding(ctx, id)\n+            binfo = get_binding(ctx, id)\n             if !isnothing(new_id)\n                 sk = binfo.kind == :local || binfo.kind == :argument ? K\"slot\"             :\n                      binfo.kind == :static_parameter                 ? K\"static_parameter\" :\n@@ -1071,31 +1069,30 @@ function compile_lambda(outer_ctx, ex)\n         else\n             @assert kind(arg) == K\"BindingId\"\n             id = arg.var_id\n-            binfo = lookup_binding(ctx, id)\n-            lbinfo = lookup_lambda_binding(ctx, id)\n+            binfo = get_binding(ctx, id)\n             @assert binfo.kind == :local || binfo.kind == :argument\n-            # FIXME: is_single_assign, is_maybe_undef\n             push!(slots, Slot(binfo.name, :argument, binfo.is_nospecialize,\n-                              lbinfo.is_read, false, false, lbinfo.is_called))\n+                              binfo.is_read, binfo.is_assigned_once,\n+                              binfo.is_used_undef, binfo.is_called))\n             slot_rewrites[id] = length(slots)\n         end\n     end\n     # Sorting the lambda locals is required to remove dependence on Dict iteration order.\n-    for (id, lbinfo) in sort(collect(pairs(lambda_bindings.bindings)), by=first)\n-        if !lbinfo.is_captured\n-            binfo = lookup_binding(ctx.bindings, id)\n+    for (id, is_capt) in sort(collect(pairs(lambda_bindings.locals_capt)), by=first)\n+        if !is_capt\n+            binfo = get_binding(ctx.bindings, id)\n             if binfo.kind == :local\n-                # FIXME: is_single_assign, is_maybe_undef\n                 push!(slots, Slot(binfo.name, :local, false,\n-                                  lbinfo.is_read, false, false, lbinfo.is_called))\n+                                  binfo.is_read, binfo.is_assigned_once,\n+                                  binfo.is_used_undef, binfo.is_called))\n                 slot_rewrites[id] = length(slots)\n             end\n         end\n     end\n     for (i,arg) in enumerate(children(static_parameters))\n         @assert kind(arg) == K\"BindingId\"\n         id = arg.var_id\n-        info = lookup_binding(ctx.bindings, id)\n+        info = get_binding(ctx.bindings, id)\n         @assert info.kind == :static_parameter\n         slot_rewrites[id] = i\n     end"
    },
    {
      "sha": "719f8390ae399356775a81846e613a06b5e48acb",
      "filename": "JuliaLowering/src/scope_analysis.jl",
      "status": "modified",
      "additions": 362,
      "deletions": 462,
      "changes": 824,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fscope_analysis.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Fsrc%2Fscope_analysis.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fscope_analysis.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -17,493 +17,407 @@ function NameKey(ex::SyntaxTree)\n     NameKey(ex.name_val, ex.scope_layer)\n end\n \n-#-------------------------------------------------------------------------------\n-_insert_if_not_present!(dict, key, val) = get!(dict, key, val)\n-\n-function _find_scope_vars!(ctx, assignments, locals, destructured_args, globals, used_names, used_bindings, ex)\n-    k = kind(ex)\n-    if k == K\"Identifier\"\n-        _insert_if_not_present!(used_names, NameKey(ex), ex)\n-    elseif k == K\"BindingId\"\n-        push!(used_bindings, ex.var_id)\n-    elseif is_leaf(ex) || is_quoted(k) ||\n-            k in KSet\"scope_block lambda module toplevel\"\n-        return\n-    elseif k == K\"local\"\n-        if getmeta(ex, :is_destructured_arg, false)\n-            push!(destructured_args, ex[1])\n-        else\n-            _insert_if_not_present!(locals, NameKey(ex[1]), ex)\n-        end\n-    elseif k == K\"global\"\n-        if !(kind(ex[1]) == K\"Value\" && ex[1].value isa GlobalRef)\n-            _insert_if_not_present!(globals, NameKey(ex[1]), ex)\n-        end\n-    elseif k == K\"assign_or_constdecl_if_global\"\n-        # like v = val, except that if `v` turns out global(either implicitly or\n-        # by explicit `global`), it gains an implicit `const`\n-        _insert_if_not_present!(assignments, NameKey(ex[1]), ex)\n-    elseif k == K\"=\" || k == K\"constdecl\"\n-        v = decl_var(ex[1])\n-        if !(kind(v) in KSet\"BindingId globalref Value Placeholder\")\n-            _insert_if_not_present!(assignments, NameKey(v), v)\n-        end\n-        if k != K\"constdecl\" || numchildren(ex) == 2\n-            _find_scope_vars!(ctx, assignments, locals, destructured_args, globals, used_names, used_bindings, ex[2])\n-        end\n-    elseif k == K\"function_decl\"\n-        v = ex[1]\n-        kv = kind(v)\n-        if kv == K\"Identifier\"\n-            _insert_if_not_present!(assignments, NameKey(v), v)\n-        elseif kv == K\"BindingId\"\n-            binfo = lookup_binding(ctx, v)\n-            if !binfo.is_ssa && binfo.kind != :global\n-                @assert false \"allow local BindingId as function name?\"\n-            end\n-        else\n-            @assert false\n-        end\n-    else\n-        for e in children(ex)\n-            _find_scope_vars!(ctx, assignments, locals, destructured_args, globals, used_names, used_bindings, e)\n-        end\n-    end\n+struct ScopeInfo\n+    # index into ctx.scopes\n+    id::ScopeId\n+    # 0 if top-level thunk\n+    parent_id::ScopeId\n+    # Own ID if lambda, else some parent ID\n+    lambda_id::ScopeId\n+    # Tree introducing this scope\n+    node_id::NodeId\n+    # True in the top-level scope, and any neutral scope nested within it not\n+    # protected by a hard scope.  Becomes soft if `ctx.enable_soft_scopes`.\n+    is_permeable::Bool\n+    binding_assignments::Dict{IdTag, NodeId}\n+    assignments::Dict{NameKey, NodeId}\n+    # Map from variable names to binding IDs for resolution.  Includes all\n+    # locals, args, sparams, and explicit globals belonging to this scope.\n+    # Variables captured from an outer scope are not included.  The top-level\n+    # scope also contains all globals for resolution to fall back to.\n+    vars::Dict{NameKey,IdTag}\n+    # See `LambdaBindings`. Nothing if not a lambda scope.\n+    locals_capt::Union{Nothing, Dict{IdTag,Bool}}\n end\n \n-# Find names of all identifiers used in the given expression, grouping them\n-# into sets by type of usage.\n-#\n-# NB: This only works properly after desugaring\n-function find_scope_vars(ctx, ex)\n-    ExT = typeof(ex)\n-    assignments = Dict{NameKey,ExT}()\n-    locals = Dict{NameKey,ExT}()\n-    destructured_args = Vector{ExT}()\n-    globals = Dict{NameKey,ExT}()\n-    used_names = Dict{NameKey,ExT}()\n-    used_bindings = Set{IdTag}()\n-    for e in children(ex)\n-        _find_scope_vars!(ctx, assignments, locals, destructured_args, globals, used_names, used_bindings, e)\n-    end\n-\n-    # Sort by key so that id generation is deterministic\n-    assignments = sort!(collect(pairs(assignments)), by=first)\n-    locals      = sort!(collect(pairs(locals)),      by=first)\n-    globals     = sort!(collect(pairs(globals)),     by=first)\n-    used_names  = sort!(collect(pairs(used_names)),  by=first)\n-    used_bindings = sort!(collect(used_bindings))\n+function ScopeInfo(ctx, parent_id, node_id, is_lambda, is_permeable)\n+    id = length(ctx.scopes) + 1\n+    lambda_id = is_lambda ? id : ctx.scopes[parent_id].lambda_id\n \n-    return assignments, locals, destructured_args, globals, used_names, used_bindings\n-end\n-\n-struct ScopeInfo\n-    # True if scope is the global top level scope\n-    is_toplevel_global_scope::Bool\n-    # True if scope is part of top level code, or a non-lambda scope nested\n-    # inside top level code. Thus requiring special scope resolution rules.\n-    in_toplevel_thunk::Bool\n-    # Soft/hard scope. For top level thunks only\n-    is_soft::Bool\n-    is_hard::Bool\n-    # Map from variable names to IDs which appear in this scope but not in the\n-    # parent scope\n-    # TODO: Rename to `locals` or local_bindings?\n-    var_ids::Dict{NameKey,IdTag}\n-    # Bindings used by the enclosing lambda\n-    lambda_bindings::LambdaBindings\n+    s = ScopeInfo(\n+        id, parent_id, lambda_id, node_id, is_permeable,\n+        Dict{IdTag, NodeId}(), Dict{NameKey, NodeId}(), Dict{NameKey,IdTag}(),\n+        is_lambda ? Dict{IdTag,Bool}() : nothing)\n+    push!(ctx.scopes, s)\n+    return s\n end\n \n struct ScopeResolutionContext{GraphType} <: AbstractLoweringContext\n     graph::GraphType\n     bindings::Bindings\n     mod::Module\n+    # Every lexical scope, indexed by ScopeId\n+    scopes::Vector{ScopeInfo}\n+    # Current stack of scopes to look for names in, innermost scope last\n+    scope_stack::Vector{ScopeId}\n+    # Macro hygienic scopes (confusing name here)\n     scope_layers::Vector{ScopeLayer}\n-    # name=>id mappings for all discovered global vars\n-    global_vars::Dict{NameKey,IdTag}\n-    # Stack of name=>id mappings for each scope, innermost scope last.\n-    scope_stack::Vector{ScopeInfo}\n-    # Variables which were implicitly global due to being assigned to in top\n-    # level code\n-    implicit_toplevel_globals::Set{NameKey}\n+    # Usually, globals in the top scope are ignored.  This is a subset that may\n+    # be assigned to without the `global` keyword in soft scopes due to being\n+    # assigned to at top level, or passing the defined-and-owned-global check.\n+    soft_assignable_globals::Set{NameKey}\n+    enable_soft_scopes::Bool\n+    expr_compat_mode::Bool\n end\n \n-function ScopeResolutionContext(ctx)\n+function ScopeResolutionContext(ctx, ex)\n     graph = ensure_attributes(ctx.graph, lambda_bindings=LambdaBindings)\n-    ScopeResolutionContext(graph,\n-                           ctx.bindings,\n-                           ctx.mod,\n-                           ctx.scope_layers,\n-                           Dict{NameKey,IdTag}(),\n-                           Vector{ScopeInfo}(),\n-                           Set{NameKey}())\n+    ScopeResolutionContext(\n+        graph,\n+        ctx.bindings,\n+        ctx.mod,\n+        Vector{ScopeInfo}(),\n+        Vector{ScopeId}(),\n+        ctx.scope_layers,\n+        Set{NameKey}(),\n+        contains_softscope_marker(ex),\n+        ctx.expr_compat_mode)\n end\n \n-function current_lambda_bindings(ctx::ScopeResolutionContext)\n-    last(ctx.scope_stack).lambda_bindings\n+function contains_softscope_marker(ex)\n+    kind(ex) == K\"softscope\" ||\n+        needs_resolution(ex) && any(contains_softscope_marker, children(ex))\n end\n \n-function lookup_var(ctx, varkey::NameKey, exclude_toplevel_globals=false)\n-    for i in lastindex(ctx.scope_stack):-1:1\n-        ids = ctx.scope_stack[i].var_ids\n-        id = get(ids, varkey, nothing)\n-        if !isnothing(id) && (!exclude_toplevel_globals ||\n-                              i > 1 || lookup_binding(ctx, id).kind != :global)\n-            return id\n-        end\n+top_scope(ctx) = ctx.scopes[1]\n+is_top_scope(scope::ScopeInfo) = scope.parent_id === 0\n+enclosing_lambda(ctx, scope::ScopeInfo) = ctx.scopes[scope.lambda_id]\n+parent(ctx, scope::ScopeInfo) = is_top_scope(scope) ? nothing :\n+    ctx.scopes[scope.parent_id]\n+\n+_var_str(v) = v === :local ? \"local variable\" :\n+    v === :global ? \"global variable\" :\n+    v === :argument ? \"argument\" :\n+    v === :destructured_arg ? \"destructured argument\" :\n+    v === :static_parameter ? \"static parameter\" : \"unknown\"\n+\n+# Declare `ex` in `scope`, unless a binding already exists with the same name in\n+# scope, or id anywhere.  Throw an error if a name conflict occurs.  The rules\n+# for conflict: declaring a local (or global) twice with the same name is a\n+# no-op, but doing so with an argument or static parameter is an error.  A\n+# variable usually can't be two things in one scope, but flisp has quirks.\n+function maybe_declare_in_scope!(ctx, scope::ScopeInfo, ex, new_k::Symbol)\n+    if kind(ex) === K\"BindingId\"\n+        bid = ex.var_id\n+        @assert get_binding(ctx, bid).kind === new_k\n+        record_lambda_var!(ctx, scope, get_binding(ctx, bid), capt=false)\n+        return bid\n+    elseif kind(ex) === K\"Placeholder\"\n+        return nothing\n+    end\n+    bid = get(scope.vars, NameKey(ex), nothing)\n+    old_k = isnothing(bid) ? nothing : get_binding(ctx, bid).kind\n+    if isnothing(old_k)\n+        if new_k === :argument\n+            declare_in_scope!(ctx, scope, ex, :argument;\n+                              is_nospecialize=getmeta(ex, :nospecialize, false))\n+        else\n+            real_k = new_k === :destructured_arg ? :local : new_k\n+            declare_in_scope!(ctx, scope, ex, real_k)\n+        end\n+    elseif old_k === new_k\n+        (new_k === :global || new_k === :local) && return bid\n+        throw(LoweringError(ex, \"function $(_var_str(new_k)) name not unique\"))\n+    # See note in test/scopes.jl: \"globals may overlap args or sparams\"\n+    # elseif new_k === :global && old_k in (:argument, :static_parameter)\n+    #     declare_in_scope!(ctx, scope, ex, :global)\n+    else\n+        throw(LoweringError(ex, \"\"\"\n+        $(_var_str(new_k)) name `$(NameKey(ex).name)` conflicts with an \\\n+        existing $(_var_str(old_k)) from the same scope\"\"\"))\n     end\n-    return exclude_toplevel_globals ? nothing : get(ctx.global_vars, varkey, nothing)\n-end\n-\n-function var_kind(ctx, id::IdTag)\n-    lookup_binding(ctx, id).kind\n-end\n-\n-function var_kind(ctx, varkey::NameKey, exclude_toplevel_globals=false)\n-    id = lookup_var(ctx, varkey, exclude_toplevel_globals)\n-    isnothing(id) ? nothing : lookup_binding(ctx, id).kind\n end\n \n-function init_binding(ctx, srcref, varkey::NameKey, kind::Symbol; kws...)\n-    id = kind === :global ? get(ctx.global_vars, varkey, nothing) : nothing\n-    if isnothing(id)\n-        mod = kind === :global ? ctx.scope_layers[varkey.layer].mod : nothing\n-        ex = new_binding(ctx, srcref, varkey.name, kind; mod=mod, kws...)\n-        id = ex.var_id\n-    end\n-    if kind === :global\n-        ctx.global_vars[varkey] = id\n+# globals are added to both `scope` and the top scope\n+function declare_in_scope!(ctx, scope::ScopeInfo, ex, bk::Symbol; kws...)\n+    nk = NameKey(ex)\n+    if bk === :global\n+        declaration_scope = top_scope(ctx)\n+        mod = ctx.scope_layers[ex.scope_layer].mod\n+    else\n+        declaration_scope = scope\n+        mod = nothing\n     end\n-    id\n+    b = _new_binding(ctx, ex, nk.name, bk; mod, kws...)\n+    declaration_scope.vars[nk] = b.id\n+    scope.vars[nk] = b.id\n+    @assert !haskey(enclosing_lambda(ctx, scope).locals_capt, b.id)\n+    record_lambda_var!(ctx, scope, b, capt=false)\n+    return b.id\n end\n \n-# Add lambda arguments and static parameters\n-function add_lambda_args(ctx, var_ids, args, args_kind)\n-    for arg in args\n-        ka = kind(arg)\n-        if ka == K\"Identifier\"\n-            varkey = NameKey(arg)\n-            if haskey(var_ids, varkey)\n-                vk = lookup_binding(ctx, var_ids[varkey]).kind\n-                _is_arg(k) = k == :argument || k == :local\n-                msg = _is_arg(vk) && _is_arg(args_kind) ? \"function argument name not unique\"         :\n-                      vk == :static_parameter && args_kind == :static_parameter ? \"function static parameter name not unique\" :\n-                      \"static parameter name not distinct from function argument\"\n-                throw(LoweringError(arg, msg))\n-            end\n-            is_always_defined = args_kind == :argument\n-            id = init_binding(ctx, arg, varkey, args_kind;\n-                              is_nospecialize=getmeta(arg, :nospecialize, false),\n-                              is_always_defined=is_always_defined)\n-            var_ids[varkey] = id\n-        elseif ka != K\"BindingId\" && ka != K\"Placeholder\"\n-            throw(LoweringError(arg, \"Unexpected lambda arg kind\"))\n+# If `b` is local and not yet recorded in the lambda bindings, mark it as\n+# `capt`.  Also, (if `capt==true`), add it to any parent lambdas.\n+function record_lambda_var!(ctx, scope::ScopeInfo, b; capt)\n+    if b.kind === :global || b.is_ssa\n+        return\n+    end\n+    lam = enclosing_lambda(ctx, scope)\n+    if !haskey(lam.locals_capt, b.id)\n+        lam.locals_capt[b.id] = capt\n+        b.is_captured = capt\n+        s2 = parent(ctx, lam)\n+        if capt && !isnothing(s2)\n+            record_lambda_var!(ctx, s2, b, capt=true)\n         end\n     end\n end\n \n-# Analyze identifier usage within a scope\n-# * Allocate a new binding for each identifier which the scope introduces.\n-# * Record the identifier=>binding mapping in a lookup table\n-# * Return a `ScopeInfo` with the mapping plus additional scope metadata\n-function analyze_scope(ctx, ex, scope_type, is_toplevel_global_scope=false,\n-                       lambda_args=nothing, lambda_static_parameters=nothing)\n-    parentscope = isempty(ctx.scope_stack) ? nothing : ctx.scope_stack[end]\n-    is_outer_lambda_scope = kind(ex) == K\"lambda\"\n-    in_toplevel_thunk = is_toplevel_global_scope ||\n-        (!is_outer_lambda_scope && parentscope.in_toplevel_thunk)\n-\n-    assignments, locals, destructured_args, globals,\n-        used_names, used_bindings = find_scope_vars(ctx, ex)\n-\n-    # Construct a mapping from identifiers to bindings\n-    #\n-    # This will contain a binding ID for each variable which is introduced by\n-    # the scope, including\n-    # * Explicit locals\n-    # * Explicit globals\n-    # * Implicit locals created by assignment\n-    var_ids = Dict{NameKey,IdTag}()\n-\n-    if !isnothing(lambda_args)\n-        add_lambda_args(ctx, var_ids, lambda_args, :argument)\n-        add_lambda_args(ctx, var_ids, lambda_static_parameters, :static_parameter)\n-        add_lambda_args(ctx, var_ids, destructured_args, :local)\n-    end\n+function needs_resolution(ex)\n+    kind(ex) === K\"Identifier\" ||\n+        !is_leaf(ex) && !is_quoted(ex) && !(kind(ex) in KSet\"toplevel module\")\n+end\n \n-    # Add explicit locals\n-    for (varkey,e) in locals\n-        if haskey(var_ids, varkey)\n-            vk = lookup_binding(ctx, var_ids[varkey]).kind\n-            if vk === :argument && is_outer_lambda_scope\n-                throw(LoweringError(e, \"local variable name `$(varkey.name)` conflicts with an argument\"))\n-            elseif vk === :static_parameter\n-                throw(LoweringError(e, \"local variable name `$(varkey.name)` conflicts with a static parameter\"))\n-            end\n-        elseif var_kind(ctx, varkey) === :static_parameter\n-            throw(LoweringError(e, \"local variable name `$(varkey.name)` conflicts with a static parameter\"))\n-        else\n-            var_ids[varkey] = init_binding(ctx, e[1], varkey, :local)\n+function resolve_name(ctx, ex; exclude_toplevel_globals=false)\n+    for sid in reverse(ctx.scope_stack)\n+        bid = get(ctx.scopes[sid].vars, NameKey(ex), nothing)\n+        isnothing(bid) && continue\n+        b = get_binding(ctx, bid)\n+        if !exclude_toplevel_globals || sid !== top_scope(ctx).id || b.kind !== :global\n+            return b\n         end\n     end\n+end\n \n-    # Add explicit globals\n-    for (varkey,e) in globals\n-        if haskey(var_ids, varkey)\n-            vk = lookup_binding(ctx, var_ids[varkey]).kind\n-            if vk === :local\n-                throw(LoweringError(e, \"Variable `$(varkey.name)` declared both local and global\"))\n-            elseif vk === :argument && is_outer_lambda_scope\n-                throw(LoweringError(e, \"global variable name `$(varkey.name)` conflicts with an argument\"))\n-            elseif vk === :static_parameter\n-                throw(LoweringError(e, \"global variable name `$(varkey.name)` conflicts with a static parameter\"))\n+function _find_scope_decls!(ctx, scope, ex)\n+    k = kind(ex)\n+    if k === K\"local\" && kind(ex[1]) === K\"Identifier\"\n+        var_k = getmeta(ex, :is_destructured_arg, false) ?\n+            :destructured_arg : :local\n+        maybe_declare_in_scope!(ctx, scope, ex[1], var_k)\n+    elseif k === K\"global\" && kind(ex[1]) === K\"Identifier\"\n+        maybe_declare_in_scope!(ctx, scope, ex[1], :global)\n+    elseif k in KSet\"= constdecl assign_or_constdecl_if_global function_decl\"\n+        k1 = kind(ex[1])\n+        if k1 === K\"BindingId\"\n+            b = get_binding(ctx, ex[1])\n+            if k === K\"function_decl\" && !b.is_ssa && b.kind !== :global\n+                @assert false \"allow local BindingId as function name?\"\n             end\n-        elseif var_kind(ctx, varkey) === :static_parameter\n-            throw(LoweringError(e, \"global variable name `$(varkey.name)` conflicts with a static parameter\"))\n+            get!(scope.binding_assignments, b.id, ex[1]._id)\n+        elseif k1 === K\"Identifier\"\n+            get!(scope.assignments, NameKey(ex[1]), ex[1]._id)\n+        elseif k1 === K\"Placeholder\"\n+            @assert k !== K\"function_decl\"\n+        else\n+            @assert false \"Unknown kind in assignment\"\n         end\n-        var_ids[varkey] = init_binding(ctx, e[1], varkey, :global)\n-    end\n-\n-    # Compute implicit locals and globals\n-    if is_toplevel_global_scope\n-        is_hard_scope = false\n-        is_soft_scope = false\n-\n-        # Assignments are implicitly global at top level, unless they come from\n-        # a macro expansion\n-        for (varkey,e) in assignments\n-            vk = haskey(var_ids, varkey) ?\n-                 lookup_binding(ctx, var_ids[varkey]).kind :\n-                 var_kind(ctx, varkey, true)\n-            if vk === nothing\n-                if ctx.scope_layers[varkey.layer].is_macro_expansion\n-                    var_ids[varkey] = init_binding(ctx, e, varkey, :local)\n-                else\n-                    init_binding(ctx, e, varkey, :global)\n-                    push!(ctx.implicit_toplevel_globals, varkey)\n-                end\n-            end\n+        if (k === K\"=\" || k === K\"assign_or_constdecl_if_global\" ||\n+            k === K\"constdecl\" && numchildren(ex) == 2)\n+            _find_scope_decls!(ctx, scope, ex[2])\n         end\n-    else\n-        is_hard_scope = in_toplevel_thunk && (parentscope.is_hard || scope_type === :hard)\n-        is_soft_scope = in_toplevel_thunk && !is_hard_scope &&\n-                        (scope_type === :neutral ? parentscope.is_soft : scope_type === :soft)\n-\n-        # Outside top level code, most assignments create local variables implicitly\n-        for (varkey,e) in assignments\n-            vk = haskey(var_ids, varkey) ?\n-                 lookup_binding(ctx, var_ids[varkey]).kind :\n-                 var_kind(ctx, varkey, true)\n-            if vk === :static_parameter\n-                throw(LoweringError(e, \"local variable name `$(varkey.name)` conflicts with a static parameter\"))\n-            elseif vk !== nothing\n-                continue\n-            end\n-            # Assignment is to a newly discovered variable name\n-            is_ambiguous_local = false\n-            if in_toplevel_thunk && !is_hard_scope\n-                # In a top level thunk but *inside* a nontrivial scope\n-                layer = ctx.scope_layers[varkey.layer]\n-                if !layer.is_macro_expansion && (varkey in ctx.implicit_toplevel_globals ||\n-                        is_defined_and_owned_global(layer.mod, Symbol(varkey.name)))\n-                    # Special scope rules to make assignments to globals work\n-                    # like assignments to locals do inside a function.\n-                    if is_soft_scope\n-                        # Soft scope (eg, for loop in REPL) => treat as a global\n-                        init_binding(ctx, e, varkey, :global)\n-                        continue\n-                    else\n-                        # Ambiguous case (eg, nontrivial scopes in package top level code)\n-                        # => Treat as local but generate warning when assigned to\n-                        is_ambiguous_local = true\n-                    end\n-                end\n-            end\n-            var_ids[varkey] = init_binding(ctx, e, varkey, :local;\n-                                           is_ambiguous_local=is_ambiguous_local)\n+    elseif needs_resolution(ex) && !(k === K\"scope_block\" || k === K\"lambda\")\n+        for e in children(ex)\n+            _find_scope_decls!(ctx, scope, e)\n         end\n     end\n+end\n \n-    #--------------------------------------------------\n-    # At this point we've discovered all the bindings defined in this scope and\n-    # added them to `var_ids`.\n-    #\n-    # Next we record information about how the new bindings relate to the\n-    # enclosing lambda\n-    # * All non-globals are recorded (kind :local and :argument will later be turned into slots)\n-    # * Captured variables are detected and recorded\n-    #\n-    # TODO: Move most or-all of this to the VariableAnalysis sub-pass\n-    lambda_bindings = if is_outer_lambda_scope\n-        if isempty(lambda_args)\n-            LambdaBindings()\n-        else\n-            selfarg = first(lambda_args)\n-            selfid = kind(selfarg) == K\"BindingId\" ?\n-                     selfarg.var_id : var_ids[NameKey(selfarg)]\n-            LambdaBindings(selfid)\n+# Produce a complete ScopeInfo and add it to the stack of active scopes.  This\n+# means finding all variables declared and used in the scope `ex` and generating\n+# the (identifier,layer)=>binding_id mapping `scope.vars`\n+function enter_scope!(ctx, ex)\n+    @assert kind(ex) in KSet\"lambda scope_block\"\n+    # Note that generated functions produce lambdas with this false\n+    is_toplevel_thunk = kind(ex) === K\"lambda\" && ex.is_toplevel_thunk\n+    parent_id = (is_toplevel_thunk || isempty(ctx.scope_stack)) ?\n+        0 : ctx.scopes[ctx.scope_stack[end]].id\n+    is_permeable = is_toplevel_thunk ||\n+        kind(ex) === K\"scope_block\" && ex.scope_type === :neutral\n+    scope = ScopeInfo(ctx, parent_id, ex._id, kind(ex) === K\"lambda\", is_permeable)\n+    lambda_scope = ctx.scopes[scope.lambda_id]\n+    push!(ctx.scope_stack, scope.id)\n+\n+    #---------------------------------------------------------------------------\n+    # Find explicit decls that may influence assignment assignment resolution\n+    if kind(ex) === K\"lambda\"\n+        for c in children(ex[1])\n+            @assert kind(c) in KSet\"Identifier BindingId Placeholder\"\n+            maybe_declare_in_scope!(ctx, scope, c, :argument)\n+        end\n+        for c in children(ex[2])\n+            @assert kind(c) in KSet\"Identifier BindingId Placeholder\"\n+            maybe_declare_in_scope!(ctx, scope, c, :static_parameter)\n+        end\n+        for c in children(ex)[3:end]\n+            _find_scope_decls!(ctx, scope, c)\n         end\n     else\n-        parentscope.lambda_bindings\n-    end\n-\n-    for id in values(var_ids)\n-        binfo = lookup_binding(ctx, id)\n-        if !binfo.is_ssa && binfo.kind !== :global\n-            init_lambda_binding(lambda_bindings, id)\n+        for c in children(ex)\n+            _find_scope_decls!(ctx, scope, c)\n         end\n     end\n \n-    # FIXME: This assumes used bindings are internal to the lambda and cannot\n-    # be from the environment, and also assumes they are assigned. That's\n-    # correct for now but in general we should go by the same code path that\n-    # identifiers do.\n-    for id in used_bindings\n-        binfo = lookup_binding(ctx, id)\n-        if (binfo.kind === :local && !binfo.is_ssa) || binfo.kind === :argument ||\n-                binfo.kind === :static_parameter\n-            if !has_lambda_binding(lambda_bindings, id)\n-                init_lambda_binding(lambda_bindings, id)\n-            end\n-        end\n+    #---------------------------------------------------------------------------\n+    # Find assignment targets, possibly introducing implicit locals and globals\n+    for (bid, node_id) in sort!(collect(scope.binding_assignments))\n+        # Mutable nameless bindings may be introduced in desugaring.  These\n+        # should be capturable, and may be local to the nearest lambda or\n+        # global.  Desugaring should ensure these are never used undef.\n+        maybe_declare_in_scope!(ctx, scope, SyntaxTree(ctx.graph, node_id),\n+                                get_binding(ctx, bid).kind)\n     end\n-\n-    for (varkey, e) in used_names\n-        id = haskey(var_ids, varkey) ? var_ids[varkey] : lookup_var(ctx, varkey)\n-        if id === nothing\n-            # Identifiers which are used but not defined in some scope are\n-            # newly discovered global bindings\n-            init_binding(ctx, e, varkey, :global)\n-        elseif !in_toplevel_thunk\n-            binfo = lookup_binding(ctx, id)\n-            if binfo.kind !== :global\n-                if !has_lambda_binding(lambda_bindings, id)\n-                    # Used vars from a scope *outside* the current lambda are captured\n-                    init_lambda_binding(lambda_bindings, id, is_captured=true)\n-                    update_binding!(ctx, id; is_captured=true)\n+    for (vk, node_id) in sort!(collect(scope.assignments))\n+        local ex = SyntaxTree(ctx.graph, node_id)\n+        b = resolve_name(ctx, ex)\n+        if b === nothing\n+            if is_toplevel_thunk && !ctx.scope_layers[vk.layer].is_macro_expansion\n+                push!(ctx.soft_assignable_globals, vk)\n+                declare_in_scope!(ctx, top_scope(ctx), ex, :global)\n+            elseif scope.is_permeable && is_defined_and_owned_global(\n+                ctx.scope_layers[vk.layer].mod, Symbol(vk.name))\n+                # special soft scope rules: existing global variables are assigned to\n+                if ctx.enable_soft_scopes\n+                    push!(ctx.soft_assignable_globals, vk)\n+                    declare_in_scope!(ctx, top_scope(ctx), ex, :global)\n+                else\n+                    declare_in_scope!(ctx, scope, ex, :local; is_ambiguous_local=true)\n                 end\n+            else\n+                declare_in_scope!(ctx, scope, ex, :local)\n             end\n-        end\n-    end\n-\n-    if !in_toplevel_thunk\n-        for (varkey,_) in assignments\n-            id = haskey(var_ids, varkey) ? var_ids[varkey] : lookup_var(ctx, varkey)\n-            binfo = lookup_binding(ctx, id)\n-            if binfo.kind !== :global\n-                if !has_lambda_binding(lambda_bindings, id)\n-                    # Assigned vars from a scope *outside* the current lambda are captured\n-                    init_lambda_binding(lambda_bindings, id, is_captured=true)\n-                    update_binding!(ctx, id; is_captured=true)\n-                end\n+        elseif b.kind === :global\n+            if is_toplevel_thunk\n+                # assign-existing and make visible to soft scope\n+                push!(ctx.soft_assignable_globals, vk)\n+            elseif !isnothing(resolve_name(ctx, ex; exclude_toplevel_globals=true)) ||\n+                (ctx.enable_soft_scopes && scope.is_permeable &&\n+                vk in ctx.soft_assignable_globals)\n+                # assign-existing-global if this is an explicit global that\n+                # isn't at top level, or if the soft scope exception applies\n+            else\n+                declare_in_scope!(ctx, scope, ex, :local)\n             end\n+        elseif b.kind === :static_parameter\n+            throw(LoweringError(ex, \"cannot overwrite a static parameter\"))\n+        elseif b.kind === :local || b.kind === :argument\n+            # unambiguous assignment to existing variable\n+            record_lambda_var!(ctx, scope, b, capt=true)\n         end\n     end\n \n-    return ScopeInfo(is_toplevel_global_scope, in_toplevel_thunk, is_soft_scope,\n-                     is_hard_scope, var_ids, lambda_bindings)\n+    return scope\n end\n \n function add_local_decls!(ctx, stmts, srcref, scope)\n     # Add local decls to start of block so that closure conversion can\n     # initialize if necessary.\n-    for id in sort!(collect(values(scope.var_ids)))\n-        binfo = lookup_binding(ctx, id)\n+    for id in sort!(collect(values(scope.vars)))\n+        binfo = get_binding(ctx, id)\n         if binfo.kind == :local\n             push!(stmts, @ast ctx srcref [K\"local\" binding_ex(ctx, id)])\n         end\n     end\n end\n \n-function _resolve_scopes(ctx, ex::SyntaxTree)\n+function _resolve_scopes(ctx, ex::SyntaxTree,\n+                         @nospecialize(scope::Union{Nothing, ScopeInfo}))\n     k = kind(ex)\n+    @assert scope isa ScopeInfo || k === K\"lambda\"\n     if k == K\"Identifier\"\n-        @ast ctx ex lookup_var(ctx, NameKey(ex))::K\"BindingId\"\n-    elseif is_leaf(ex) || is_quoted(ex) || k == K\"toplevel\"\n+        b = resolve_name(ctx, ex)\n+        # Unresolved names are assumed global\n+        if isnothing(b)\n+            gid = declare_in_scope!(ctx, top_scope(ctx), ex, :global)\n+            b = get_binding(ctx, gid)\n+        end\n+        # Locals not present in the current lambda need capturing\n+        record_lambda_var!(ctx, scope, b, capt=true)\n+        newleaf(ctx, ex, K\"BindingId\", b.id)\n+    elseif k === K\"BindingId\"\n+        record_lambda_var!(ctx, scope, get_binding(ctx, ex), capt=true)\n+        ex\n+    elseif k == K\"softscope\"\n+        makeleaf(ctx, ex, K\"TOMBSTONE\")\n+    elseif !needs_resolution(ex)\n         ex\n-    # elseif k == K\"global\"\n-    #     ex\n     elseif k == K\"local\"\n         # Local declarations have a value of `nothing` according to flisp\n         # lowering.\n         # TODO: Should local decls be disallowed in value position?\n         @ast ctx ex \"nothing\"::K\"core\"\n     elseif k == K\"decl\"\n-        ex_out = mapchildren(e->_resolve_scopes(ctx, e), ctx, ex)\n+        ex_out = mapchildren(e->_resolve_scopes(ctx, e, scope), ctx, ex)\n         name = ex_out[1]\n         if kind(name) != K\"Placeholder\"\n-            binfo = lookup_binding(ctx, name)\n-            if binfo.kind == :global && !ctx.scope_stack[end].in_toplevel_thunk\n+            binfo = get_binding(ctx, name)\n+            if binfo.kind == :global && !is_top_scope(enclosing_lambda(ctx, scope))\n                 throw(LoweringError(ex, \"type declarations for global variables must be at top level, not inside a function\"))\n             end\n         end\n         id = ex_out[1]\n         if kind(id) != K\"Placeholder\"\n-            binfo = lookup_binding(ctx, id)\n+            binfo = get_binding(ctx, id)\n             if !isnothing(binfo.type)\n                 throw(LoweringError(ex, \"multiple type declarations found for `$(binfo.name)`\"))\n             end\n-            update_binding!(ctx, id; type=ex_out[2])\n+            binfo.type = ex_out[2]\n         end\n         ex_out\n     elseif k == K\"always_defined\"\n-        id = lookup_var(ctx, NameKey(ex[1]))\n-        update_binding!(ctx, id; is_always_defined=true)\n+        resolve_name(ctx, ex[1]).is_always_defined = true\n         makeleaf(ctx, ex, K\"TOMBSTONE\")\n     elseif k == K\"lambda\"\n-        is_toplevel_thunk = ex.is_toplevel_thunk\n-        scope = analyze_scope(ctx, ex, nothing, is_toplevel_thunk,\n-                              children(ex[1]), children(ex[2]))\n+        newscope = enter_scope!(ctx, ex)\n+        arg_bindings = _resolve_scopes(ctx, ex[1], newscope)\n+        sparam_bindings = _resolve_scopes(ctx, ex[2], newscope)\n \n-        push!(ctx.scope_stack, scope)\n-        arg_bindings = _resolve_scopes(ctx, ex[1])\n-        sparm_bindings = _resolve_scopes(ctx, ex[2])\n+        self_id = numchildren(arg_bindings) === 0 ? 0 : arg_bindings[1].var_id\n+        lambda_bindings = LambdaBindings(self_id, newscope.id, newscope.locals_capt)\n         body_stmts = SyntaxList(ctx)\n-        add_local_decls!(ctx, body_stmts, ex, scope)\n-        body = _resolve_scopes(ctx, ex[3])\n+        add_local_decls!(ctx, body_stmts, ex, newscope)\n+        body = _resolve_scopes(ctx, ex[3], newscope)\n         if kind(body) == K\"block\"\n             append!(body_stmts, children(body))\n         else\n             push!(body_stmts, body)\n         end\n-        ret_var = numchildren(ex) == 4 ? _resolve_scopes(ctx, ex[4]) : nothing\n+        ret_var = numchildren(ex) == 4 ?\n+            _resolve_scopes(ctx, ex[4], newscope) : nothing\n         pop!(ctx.scope_stack)\n \n-        @ast ctx ex [K\"lambda\"(lambda_bindings=scope.lambda_bindings,\n-                               is_toplevel_thunk=is_toplevel_thunk,\n+        @ast ctx ex [K\"lambda\"(;lambda_bindings=lambda_bindings,\n+                               is_toplevel_thunk=ex.is_toplevel_thunk,\n                                toplevel_pure=false)\n             arg_bindings\n-            sparm_bindings\n+            sparam_bindings\n             [K\"block\"\n                 body_stmts...\n             ]\n             ret_var\n         ]\n     elseif k == K\"scope_block\"\n-        scope = analyze_scope(ctx, ex, ex.scope_type)\n-        push!(ctx.scope_stack, scope)\n+        newscope = enter_scope!(ctx, ex)\n         stmts = SyntaxList(ctx)\n-        add_local_decls!(ctx, stmts, ex, scope)\n+        add_local_decls!(ctx, stmts, ex, newscope)\n         for e in children(ex)\n-            push!(stmts, _resolve_scopes(ctx, e))\n+            push!(stmts, _resolve_scopes(ctx, e, newscope))\n         end\n         pop!(ctx.scope_stack)\n         @ast ctx ex [K\"block\" stmts...]\n     elseif k == K\"extension\"\n         etype = extension_type(ex)\n         if etype == \"islocal\"\n-            id = lookup_var(ctx, NameKey(ex[2]))\n-            islocal = !isnothing(id) && var_kind(ctx, id) != :global\n+            b = resolve_name(ctx, ex[2])\n+            islocal = !isnothing(b) && b.kind !== :global\n             @ast ctx ex islocal::K\"Bool\"\n         elseif etype == \"isglobal\"\n             e2 = ex[2]\n             @chk kind(e2) in KSet\"Identifier Placeholder\"\n-            isglobal = if kind(e2) == K\"Identifier\"\n-                id = lookup_var(ctx, NameKey(e2))\n-                isnothing(id) || var_kind(ctx, id) == :global\n-            else\n-                false\n-            end\n+            isglobal = kind(e2) == K\"Identifier\" &&\n+                let b = resolve_name(ctx, e2)\n+                    isnothing(b) || b.kind === :global\n+                end\n             @ast ctx ex isglobal::K\"Bool\"\n         elseif etype == \"locals\"\n             stmts = SyntaxList(ctx)\n@@ -519,9 +433,9 @@ function _resolve_scopes(ctx, ex::SyntaxTree)\n                     ]\n                 ]\n             ])\n-            for scope in ctx.scope_stack\n-                for id in values(scope.var_ids)\n-                    binfo = lookup_binding(ctx, id)\n+            for sid in ctx.scope_stack\n+                for id in values(ctx.scopes[sid].vars)\n+                    binfo = get_binding(ctx, id)\n                     if binfo.kind == :global || binfo.is_internal\n                         continue\n                     end\n@@ -544,18 +458,18 @@ function _resolve_scopes(ctx, ex::SyntaxTree)\n         etype = extension_type(ex)\n         if etype == \"require_existing_locals\"\n             for v in ex[2:end]\n-                vk = var_kind(ctx, NameKey(v))\n-                if vk !== :local\n+                b = resolve_name(ctx, v)\n+                if isnothing(b) || !(b.kind in (:local, :argument))\n                     throw(LoweringError(v, \"`outer` annotations must match with a local variable in an outer scope but no such variable was found\"))\n                 end\n             end\n         elseif etype == \"global_toplevel_only\"\n-            if !ctx.scope_stack[end].is_toplevel_global_scope\n+            if !is_top_scope(scope)\n                 e = ex[2][1]\n                 throw(LoweringError(e, \"$(kind(e)) is only allowed in global scope\"))\n             end\n         elseif etype == \"toplevel_only\"\n-            if !ctx.scope_stack[end].in_toplevel_thunk\n+            if !is_top_scope(enclosing_lambda(ctx, scope))\n                 e = ex[2][1]\n                 throw(LoweringError(e, \"this syntax is only allowed in top level code\"))\n             end\n@@ -564,33 +478,43 @@ function _resolve_scopes(ctx, ex::SyntaxTree)\n         end\n         makeleaf(ctx, ex, K\"TOMBSTONE\")\n     elseif k == K\"function_decl\"\n-        resolved = mapchildren(e->_resolve_scopes(ctx, e), ctx, ex)\n+        resolved = mapchildren(e->_resolve_scopes(ctx, e, scope), ctx, ex)\n         name = resolved[1]\n         if kind(name) == K\"BindingId\"\n-            bk = lookup_binding(ctx, name).kind\n+            bk = get_binding(ctx, name).kind\n             if bk == :argument\n                 throw(LoweringError(name, \"Cannot add method to a function argument\"))\n-            elseif bk == :global && !ctx.scope_stack[end].in_toplevel_thunk\n-                throw(LoweringError(name,\n-                    \"Global method definition needs to be placed at the top level, or use `eval()`\"))\n+            elseif bk == :global && !is_top_scope(enclosing_lambda(ctx, scope))\n+                throw(LoweringError(name, \"\"\"\n+                    Global method definition needs to be placed at the top \\\n+                    level, or use `eval()`\"\"\"))\n             end\n         end\n         resolved\n+    elseif k == K\"constdecl\"\n+        resolved = mapchildren(e->_resolve_scopes(ctx, e, scope), ctx, ex)\n+        @assert kind(resolved[1]) === K\"BindingId\"\n+        if get_binding(ctx, resolved[1].var_id).kind === :local\n+            throw(LoweringError(ex, \"unsupported `const` declaration on local variable\"))\n+        elseif !is_top_scope(enclosing_lambda(ctx, scope))\n+            throw(LoweringError(ex, \"unsupported `const` inside function\"))\n+        end\n+        resolved\n     elseif k == K\"assign_or_constdecl_if_global\"\n-        id = _resolve_scopes(ctx, ex[1])\n-        bk = lookup_binding(ctx, id).kind\n+        id = _resolve_scopes(ctx, ex[1], scope)\n+        bk = get_binding(ctx, id).kind\n         @assert numchildren(ex) === 2\n         assignment_kind = bk == :global ? K\"constdecl\" : K\"=\"\n-        @ast ctx ex _resolve_scopes(ctx, [assignment_kind ex[1] ex[2]])\n+        @ast ctx ex _resolve_scopes(ctx, [assignment_kind ex[1] ex[2]], scope)\n     else\n-        mapchildren(e->_resolve_scopes(ctx, e), ctx, ex)\n+        mapchildren(e->_resolve_scopes(ctx, e, scope), ctx, ex)\n     end\n end\n \n-function _resolve_scopes(ctx, exs::AbstractVector)\n+function _resolve_scopes(ctx, exs::AbstractVector, scope)\n     out = SyntaxList(ctx)\n     for e in exs\n-        push!(out, _resolve_scopes(ctx, e))\n+        push!(out, _resolve_scopes(ctx, e, scope))\n     end\n     out\n end\n@@ -609,6 +533,7 @@ struct VariableAnalysisContext{GraphType} <: AbstractLoweringContext\n     graph::GraphType\n     bindings::Bindings\n     mod::Module\n+    scopes::Vector{ScopeInfo}\n     lambda_bindings::LambdaBindings\n     # Stack of method definitions for closure naming\n     method_def_stack::SyntaxList{GraphType}\n@@ -617,34 +542,31 @@ struct VariableAnalysisContext{GraphType} <: AbstractLoweringContext\n     closure_bindings::Dict{IdTag,ClosureBindings}\n end\n \n-function VariableAnalysisContext(graph, bindings, mod, lambda_bindings)\n-    VariableAnalysisContext(graph, bindings, mod, lambda_bindings,\n+function VariableAnalysisContext(graph, bindings, mod, scopes, lambda_bindings)\n+    graph = ensure_attributes(graph, lambda_bindings=LambdaBindings)\n+    VariableAnalysisContext(graph, bindings, mod, scopes, lambda_bindings,\n                             SyntaxList(graph), Dict{IdTag,ClosureBindings}())\n end\n \n-function current_lambda_bindings(ctx::VariableAnalysisContext)\n-    ctx.lambda_bindings\n-end\n-\n function init_closure_bindings!(ctx, fname)\n     func_name_id = fname.var_id\n-    @assert lookup_binding(ctx, func_name_id).kind === :local\n+    @assert get_binding(ctx, func_name_id).kind === :local\n     get!(ctx.closure_bindings, func_name_id) do\n         name_stack = Vector{String}()\n         for parentname in ctx.method_def_stack\n             if kind(parentname) == K\"BindingId\"\n-                push!(name_stack, lookup_binding(ctx, parentname).name)\n+                push!(name_stack, get_binding(ctx, parentname).name)\n             end\n         end\n-        push!(name_stack, lookup_binding(ctx, func_name_id).name)\n+        push!(name_stack, get_binding(ctx, func_name_id).name)\n         ClosureBindings(name_stack)\n     end\n end\n \n function find_any_local_binding(ctx, ex)\n     k = kind(ex)\n     if k == K\"BindingId\"\n-        bkind = lookup_binding(ctx, ex.var_id).kind\n+        bkind = get_binding(ctx, ex.var_id).kind\n         if bkind != :global && bkind != :static_parameter\n             return ex\n         end\n@@ -659,24 +581,25 @@ function find_any_local_binding(ctx, ex)\n     return nothing\n end\n \n-# Update ctx.bindings and ctx.lambda_bindings metadata based on binding usage\n+function add_assign!(b::BindingInfo)\n+    b.is_assigned_once = !b.is_assigned\n+    b.is_assigned = true\n+end\n+\n+# Update ctx.bindings metadata based on binding usage\n function analyze_variables!(ctx, ex)\n     k = kind(ex)\n     if k == K\"BindingId\"\n-        if has_lambda_binding(ctx, ex)\n-            # TODO: Move this after closure conversion so that we don't need\n-            # to model the closure conversion transformations here.\n-            update_lambda_binding!(ctx, ex, is_read=true)\n-        else\n-            binfo = lookup_binding(ctx, ex.var_id)\n-            if !binfo.is_ssa && binfo.kind != :global\n-                # The type of typed locals is invisible in the previous pass,\n-                # but is filled in here.\n-                init_lambda_binding(ctx.lambda_bindings, ex.var_id, is_captured=true, is_read=true)\n-                update_binding!(ctx, ex, is_captured=true)\n-            end\n-        end\n-    elseif is_leaf(ex) || is_quoted(ex)\n+        b = get_binding(ctx, ex.var_id)\n+        b.is_read = true\n+        # The type of typed locals is invisible in the previous pass,\n+        # but is filled in here.\n+        scope = ctx.scopes[ctx.lambda_bindings.scope_id]\n+        record_lambda_var!(ctx, scope, b, capt=true)\n+        @assert b.kind === :global || b.is_ssa || haskey(ctx.lambda_bindings.locals_capt, b.id)\n+    elseif k == K\"Identifier\"\n+        @assert false\n+    elseif !needs_resolution(ex)\n         return\n     elseif k == K\"static_eval\"\n         badvar = find_any_local_binding(ctx, ex[1])\n@@ -691,48 +614,36 @@ function analyze_variables!(ctx, ex)\n     elseif k == K\"=\"\n         lhs = ex[1]\n         if kind(lhs) != K\"Placeholder\"\n-            update_binding!(ctx, lhs, add_assigned=1)\n-            if has_lambda_binding(ctx, lhs)\n-                update_lambda_binding!(ctx, lhs, is_assigned=true)\n-            end\n-            lhs_binfo = lookup_binding(ctx, lhs)\n-            if !isnothing(lhs_binfo.type)\n+            b = get_binding(ctx, lhs)\n+            add_assign!(b)\n+            scope = ctx.scopes[ctx.lambda_bindings.scope_id]\n+            record_lambda_var!(ctx, scope, b, capt=true)\n+            if !isnothing(b.type)\n                 # Assignments introduce a variable's type later during closure\n                 # conversion, but we must model that explicitly here.\n-                analyze_variables!(ctx, lhs_binfo.type)\n+                analyze_variables!(ctx, b.type)\n             end\n         end\n         analyze_variables!(ctx, ex[2])\n     elseif k == K\"function_decl\"\n         name = ex[1]\n-        if lookup_binding(ctx, name.var_id).kind === :local\n+        b = get_binding(ctx, name.var_id)\n+        if b.kind === :local\n             init_closure_bindings!(ctx, name)\n         end\n-        update_binding!(ctx, name, add_assigned=1)\n-        if has_lambda_binding(ctx, name)\n-            update_lambda_binding!(ctx, name, is_assigned=true)\n-        end\n+        add_assign!(b)\n     elseif k == K\"function_type\"\n-        if kind(ex[1]) != K\"BindingId\" || lookup_binding(ctx, ex[1]).kind !== :local\n+        if kind(ex[1]) != K\"BindingId\" || get_binding(ctx, ex[1]).kind !== :local\n             analyze_variables!(ctx, ex[1])\n         end\n     elseif k == K\"constdecl\"\n-        id = ex[1]\n-        if kind(id) == K\"BindingId\"\n-            if lookup_binding(ctx, id).kind == :local\n-                throw(LoweringError(ex, \"unsupported `const` declaration on local variable\"))\n-            end\n-            update_binding!(ctx, id; is_const=true)\n-        end\n+        b = get_binding(ctx, ex[1].var_id)\n+        b.is_const = true\n+        add_assign!(b)\n     elseif k == K\"call\"\n         name = ex[1]\n         if kind(name) == K\"BindingId\"\n-            id = name.var_id\n-            if has_lambda_binding(ctx, id)\n-                # TODO: Move this after closure conversion so that we don't need\n-                # to model the closure conversion transformations.\n-                update_lambda_binding!(ctx, id, is_called=true)\n-            end\n+            get_binding(ctx, name.var_id).is_called = true\n         end\n         foreach(e->analyze_variables!(ctx, e), children(ex))\n     elseif k == K\"method_defs\"\n@@ -755,27 +666,15 @@ function analyze_variables!(ctx, ex)\n             func_name = last(ctx.method_def_stack)\n             if kind(func_name) == K\"BindingId\"\n                 func_name_id = func_name.var_id\n-                if lookup_binding(ctx, func_name_id).kind === :local\n+                if get_binding(ctx, func_name_id).kind === :local\n                     push!(ctx.closure_bindings[func_name_id].lambdas, lambda_bindings)\n                 end\n             end\n         end\n-        ctx2 = VariableAnalysisContext(ctx.graph, ctx.bindings, ctx.mod, lambda_bindings,\n-                                       ctx.method_def_stack, ctx.closure_bindings)\n+        ctx2 = VariableAnalysisContext(\n+            ctx.graph, ctx.bindings, ctx.mod, ctx.scopes, lambda_bindings,\n+            ctx.method_def_stack, ctx.closure_bindings)\n         foreach(e->analyze_variables!(ctx2, e), ex[3:end]) # body & return type\n-        for (id,lbinfo) in pairs(lambda_bindings.bindings)\n-            if lbinfo.is_captured\n-                # Add any captured bindings to the enclosing lambda, if necessary.\n-                outer_lbinfo = lookup_lambda_binding(ctx.lambda_bindings, id)\n-                if isnothing(outer_lbinfo)\n-                    # Inner lambda captures a variable. If it's not yet present\n-                    # in the outer lambda, the outer lambda must capture it as\n-                    # well so that the closure associated to the inner lambda\n-                    # can be initialized when `function_decl` is hit.\n-                    init_lambda_binding(ctx.lambda_bindings, id, is_captured=true, is_read=true)\n-                end\n-            end\n-        end\n     else\n         foreach(e->analyze_variables!(ctx, e), children(ex))\n     end\n@@ -792,7 +691,7 @@ function resolve_scopes(ctx::ScopeResolutionContext, ex)\n             ex\n         ]\n     end\n-    _resolve_scopes(ctx, ex)\n+    _resolve_scopes(ctx, ex, nothing)\n end\n \n \"\"\"\n@@ -806,9 +705,10 @@ This pass also records the set of binding IDs used locally within the\n enclosing lambda form and information about variables captured by closures.\n \"\"\"\n @fzone \"JL: resolve_scopes\" function resolve_scopes(ctx::DesugaringContext, ex)\n-    ctx2 = ScopeResolutionContext(ctx)\n+    ctx2 = ScopeResolutionContext(ctx, ex)\n     ex2 = resolve_scopes(ctx2, reparent(ctx2, ex))\n-    ctx3 = VariableAnalysisContext(ctx2.graph, ctx2.bindings, ctx2.mod, ex2.lambda_bindings)\n+    ctx3 = VariableAnalysisContext(\n+        ctx2.graph, ctx2.bindings, ctx2.mod, ctx2.scopes, ex2.lambda_bindings)\n     analyze_variables!(ctx3, ex2)\n     ctx3, ex2\n end"
    },
    {
      "sha": "80b65398b42fc21380abf45afb8e7374e72c9d3c",
      "filename": "JuliaLowering/test/assignments_ir.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fassignments_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fassignments_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fassignments_ir.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -54,7 +54,7 @@ end\n 7   SourceLocation::3:9\n 8   (call core.svec %\u2085 %\u2086 %\u2087)\n 9   --- method core.nothing %\u2088\n-    slots: [slot\u2081/#self#(!read) slot\u2082/c(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/c(!read,single_assign)]\n     1   TestMod.d\n     2   (= slot\u2082/c %\u2081)\n     3   (return %\u2081)"
    },
    {
      "sha": "18faa643e1f307155739879090bdbcb2792a4a36",
      "filename": "JuliaLowering/test/closures_ir.jl",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fclosures_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fclosures_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fclosures_ir.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -26,7 +26,7 @@ end\n 16  SourceLocation::3:14\n 17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n 18  --- method core.nothing %\u2081\u2087\n-    slots: [slot\u2081/#self#(!read) slot\u2082/y slot\u2083/x(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/y slot\u2083/x(!read,maybe_undef)]\n     1   TestMod.+\n     2   (call core.getfield slot\u2081/#self# :x)\n     3   (call core.isdefined %\u2082 :contents)\n@@ -130,7 +130,7 @@ end\n 18  SourceLocation::1:10\n 19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n 20  --- method core.nothing %\u2081\u2089\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/g(called) slot\u2084/x(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(single_assign) slot\u2083/g(single_assign,called) slot\u2084/x(!read,maybe_undef)]\n     1   (= slot\u2082/x (call core.Box slot\u2082/x))\n     2   TestMod.#f#g##0\n     3   (new %\u2082 slot\u2082/x)\n@@ -170,7 +170,7 @@ end\n 10  SourceLocation::2:14\n 11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n 12  --- method core.nothing %\u2081\u2081\n-    slots: [slot\u2081/#self#(!read) slot\u2082/y(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/y(!read,single_assign)]\n     1   (call core.getfield slot\u2081/#self# :x)\n     2   (= slot\u2082/y %\u2081)\n     3   (return %\u2081)\n@@ -182,7 +182,7 @@ end\n 18  SourceLocation::1:10\n 19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n 20  --- method core.nothing %\u2081\u2089\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/g slot\u2084/z(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/g(single_assign) slot\u2084/z(!read,single_assign)]\n     1   TestMod.#f#g##1\n     2   (call core.typeof slot\u2082/x)\n     3   (call core.apply_type %\u2081 %\u2082)\n@@ -215,7 +215,7 @@ end\n 10  SourceLocation::2:14\n 11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n 12  --- method core.nothing %\u2081\u2081\n-    slots: [slot\u2081/#self#(!read) slot\u2082/T(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/T(!read,maybe_undef)]\n     1   TestMod.use\n     2   (call core.getfield slot\u2081/#self# :T)\n     3   (call core.isdefined %\u2082 :contents)\n@@ -237,7 +237,7 @@ end\n 21  SourceLocation::1:10\n 22  (call core.svec %\u2081\u2088 %\u2082\u2080 %\u2082\u2081)\n 23  --- method core.nothing %\u2082\u2082\n-    slots: [slot\u2081/#self#(!read) slot\u2082/#arg1#(!read) slot\u2083/g]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/#arg1#(!read) slot\u2083/g(single_assign)]\n     1   TestMod.#f#g##2\n     2   static_parameter\u2081\n     3   (new %\u2081 %\u2082)\n@@ -274,7 +274,7 @@ end\n 10  SourceLocation::2:14\n 11  (call core.svec %\u2088 %\u2089 %\u2081\u2080)\n 12  --- method core.nothing %\u2081\u2081\n-    slots: [slot\u2081/#self#(!read) slot\u2082/z]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/z(single_assign)]\n     1   (= slot\u2082/z 3)\n     2   (call core.getfield slot\u2081/#self# :y)\n     3   (call core.isdefined %\u2082 :contents)\n@@ -289,7 +289,7 @@ end\n 18  SourceLocation::1:10\n 19  (call core.svec %\u2081\u2086 %\u2081\u2087 %\u2081\u2088)\n 20  --- method core.nothing %\u2081\u2089\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/g slot\u2084/y]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/g(single_assign) slot\u2084/y(single_assign)]\n     1   (= slot\u2084/y (call core.Box))\n     2   TestMod.#f#g##3\n     3   (call core.typeof slot\u2082/x)\n@@ -320,7 +320,7 @@ function f_nest(x)\n     end\n end\n #---------------------\n-slots: [slot\u2081/#self#(!read) slot\u2082/y(!read) slot\u2083/h_nest]\n+slots: [slot\u2081/#self#(!read) slot\u2082/y slot\u2083/h_nest(single_assign)]\n 1   TestMod.#f_nest#g_nest#h_nest##0\n 2   (call core.getfield slot\u2081/#self# :x)\n 3   (call core.typeof %\u2082)\n@@ -354,7 +354,7 @@ end\n 11  SourceLocation::3:14\n 12  (call core.svec %\u2089 %\u2081\u2080 %\u2081\u2081)\n 13  --- code_info\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read,maybe_undef)]\n     1   TestMod.+\n     2   (captured_local 1)\n     3   (call core.isdefined %\u2082 :contents)\n@@ -465,7 +465,7 @@ end\n LoweringError:\n function f(::g) where {g}\n     function g()\n-#            \u2559 \u2500\u2500 local variable name `g` conflicts with a static parameter\n+#            \u2559 \u2500\u2500 cannot overwrite a static parameter\n     end\n end\n \n@@ -483,7 +483,7 @@ end\n 6   (call core.apply_type core.Tuple core.Any %\u2085)\n 7   (call core.apply_type core.Union)\n 8   --- opaque_closure_method  core.nothing 2 false SourceLocation::2:31\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/z slot\u2084/y(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/z slot\u2084/y(!read,maybe_undef)]\n     1   TestMod.-\n     2   TestMod.+\n     3   TestMod.*\n@@ -554,7 +554,7 @@ end\n 15  SourceLocation::2:14\n 16  (call core.svec %\u2081\u2083 %\u2081\u2084 %\u2081\u2085)\n 17  --- method core.nothing %\u2081\u2086\n-    slots: [slot\u2081/#self#(!read) slot\u2082/recursive_b(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/recursive_b(!read,maybe_undef)]\n     1   (call core.getfield slot\u2081/#self# :recursive_b)\n     2   (call core.isdefined %\u2081 :contents)\n     3   (gotoifnot %\u2082 label\u2085)\n@@ -580,7 +580,7 @@ end\n 31  SourceLocation::5:14\n 32  (call core.svec %\u2082\u2089 %\u2083\u2080 %\u2083\u2081)\n 33  --- method core.nothing %\u2083\u2082\n-    slots: [slot\u2081/#self#(!read) slot\u2082/recursive_a(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/recursive_a(!read,maybe_undef)]\n     1   (call core.getfield slot\u2081/#self# :recursive_a)\n     2   (call core.isdefined %\u2081 :contents)\n     3   (gotoifnot %\u2082 label\u2085)\n@@ -638,7 +638,7 @@ end\n 28  SourceLocation::2:14\n 29  (call core.svec %\u2082\u2086 %\u2082\u2087 %\u2082\u2088)\n 30  --- method core.nothing %\u2082\u2089\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/#self#(!read) slot\u2084/y(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/#self# slot\u2084/y(!read,maybe_undef)]\n     1   (meta :nkw 1)\n     2   TestMod.+\n     3   (call core.getfield slot\u2081/#self# :y)\n@@ -658,7 +658,7 @@ end\n 36  SourceLocation::2:14\n 37  (call core.svec %\u2083\u2084 %\u2083\u2085 %\u2083\u2086)\n 38  --- code_info\n-    slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/kwtmp slot\u2085/x(!read) slot\u2086/#f_kw_closure#0(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/kwtmp slot\u2085/x(!read) slot\u2086/#f_kw_closure#0(!read,maybe_undef)]\n     1   (newvar slot\u2085/x)\n     2   (call core.isdefined slot\u2082/kws :x)\n     3   (gotoifnot %\u2082 label\u2081\u2084)\n@@ -702,7 +702,7 @@ end\n 47  SourceLocation::2:14\n 48  (call core.svec %\u2084\u2085 %\u2084\u2086 %\u2084\u2087)\n 49  --- method core.nothing %\u2084\u2088\n-    slots: [slot\u2081/#self# slot\u2082/#f_kw_closure#0(!read)]\n+    slots: [slot\u2081/#self# slot\u2082/#f_kw_closure#0(!read,maybe_undef)]\n     1   (call core.getfield slot\u2081/#self# :#f_kw_closure#0)\n     2   (call core.isdefined %\u2081 :contents)\n     3   (gotoifnot %\u2082 label\u2085)\n@@ -729,7 +729,7 @@ let T=Blah\n     x\n end\n #---------------------\n-slots: [slot\u2081/#self#(!read) slot\u2082/T(!read) slot\u2083/tmp(!read)]\n+slots: [slot\u2081/#self#(!read) slot\u2082/T(!read,maybe_undef) slot\u2083/tmp(!read)]\n 1   2.0\n 2   (call core.getfield slot\u2081/#self# :x)\n 3   (call core.getfield slot\u2081/#self# :T)"
    },
    {
      "sha": "bb627691809962f164008144ff6ca864974194a3",
      "filename": "JuliaLowering/test/compat.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fcompat.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -628,4 +628,7 @@ const JL = JuliaLowering\n             @ast_ [K\"call\" \"identity\"::K\"Identifier\" LineNumberNode(1)::K\"Value\"]\n \n     end\n+\n+    @test JuliaLowering.expr_to_syntaxtree(Expr(:block, Expr(:softscope, true))) \u2248\n+        @ast_ [K\"block\" [K\"softscope\" true::K\"Bool\"]]\n end"
    },
    {
      "sha": "2f14c331859dacdc53bc639065d0be09a2317989",
      "filename": "JuliaLowering/test/decls_ir.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fdecls_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fdecls_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fdecls_ir.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -238,6 +238,14 @@ let\n #        \u2514\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 unsupported `const` declaration on local variable\n end\n \n+########################################\n+# Error: Const not supported in function scope\n+function (); global g; const g = 1; end\n+#---------------------\n+LoweringError:\n+function (); global g; const g = 1; end\n+#                           \u2514\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 unsupported `const` inside function\n+\n ########################################\n # Type decl on function argument\n function f(x)"
    },
    {
      "sha": "8ad8a9aaf8088b492c46c2ef1ca30d264976aeb6",
      "filename": "JuliaLowering/test/demo.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fdemo.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fdemo.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fdemo.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -13,7 +13,7 @@ function var_kind(ctx, ex)\n     if isnothing(id)\n         return nothing\n     end\n-    binfo = lookup_binding(ctx, id)\n+    binfo = get_binding(ctx, id)\n     return binfo.kind == :local ?\n         (binfo.is_captured ? :local_captured : :local) :\n         binfo.kind\n@@ -25,7 +25,7 @@ function var_mod(ctx, ex)\n     if isnothing(id)\n         return nothing\n     end\n-    return lookup_binding(ctx, id).mod\n+    return get_binding(ctx, id).mod\n end\n \n function formatsrc(ex; kws...)"
    },
    {
      "sha": "b31f796b06860dbe9c8ebd3697ccb466b72bf5e4",
      "filename": "JuliaLowering/test/functions_ir.jl",
      "status": "modified",
      "additions": 78,
      "deletions": 78,
      "changes": 156,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Ffunctions_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Ffunctions_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Ffunctions_ir.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -144,18 +144,18 @@ end\n #---------------------\n 1   (method TestMod.f)\n 2   latestworld\n-3   (= slot\u2082/U (call core.TypeVar :U))\n-4   (= slot\u2083/V (call core.TypeVar :V))\n-5   (= slot\u2081/T (call core.TypeVar :T))\n+3   (= slot\u2081/U (call core.TypeVar :U))\n+4   (= slot\u2082/V (call core.TypeVar :V))\n+5   (= slot\u2083/T (call core.TypeVar :T))\n 6   TestMod.f\n 7   (call core.Typeof %\u2086)\n-8   slot\u2081/T\n-9   slot\u2082/U\n-10  slot\u2083/V\n+8   slot\u2083/T\n+9   slot\u2081/U\n+10  slot\u2082/V\n 11  (call core.svec %\u2087 %\u2088 %\u2089 %\u2081\u2080)\n-12  slot\u2082/U\n-13  slot\u2083/V\n-14  slot\u2081/T\n+12  slot\u2081/U\n+13  slot\u2082/V\n+14  slot\u2083/T\n 15  (call core.svec %\u2081\u2082 %\u2081\u2083 %\u2081\u2084)\n 16  SourceLocation::1:10\n 17  (call core.svec %\u2081\u2081 %\u2081\u2085 %\u2081\u2086)\n@@ -236,17 +236,17 @@ end\n #---------------------\n 1   (method TestMod.f)\n 2   latestworld\n-3   (= slot\u2082/T (call core.TypeVar :T))\n+3   (= slot\u2081/T (call core.TypeVar :T))\n 4   TestMod.AbstractVector\n-5   slot\u2082/T\n+5   slot\u2081/T\n 6   (call core.apply_type %\u2084 %\u2085)\n-7   (= slot\u2081/S (call core.TypeVar :S %\u2086))\n+7   (= slot\u2082/S (call core.TypeVar :S %\u2086))\n 8   TestMod.f\n 9   (call core.Typeof %\u2088)\n-10  slot\u2081/S\n+10  slot\u2082/S\n 11  (call core.svec %\u2089 core.Any %\u2081\u2080)\n-12  slot\u2082/T\n-13  slot\u2081/S\n+12  slot\u2081/T\n+13  slot\u2082/S\n 14  (call core.svec %\u2081\u2082 %\u2081\u2083)\n 15  SourceLocation::1:10\n 16  (call core.svec %\u2081\u2081 %\u2081\u2084 %\u2081\u2085)\n@@ -446,7 +446,7 @@ end\n 29  SourceLocation::1:10\n 30  (call core.svec %\u2082\u2087 %\u2082\u2088 %\u2082\u2089)\n 31  --- method core.nothing %\u2083\u2080\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/z(!read)]\n+    slots: [slot\u2081/#self#(called) slot\u2082/x slot\u2083/y slot\u2084/z(!read)]\n     1   (call core.tuple slot\u2082/x slot\u2083/y)\n     2   (return %\u2081)\n 32  latestworld\n@@ -490,7 +490,7 @@ end\n 23  SourceLocation::1:10\n 24  (call core.svec %\u2082\u2081 %\u2082\u2082 %\u2082\u2083)\n 25  --- method core.nothing %\u2082\u2084\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y]\n+    slots: [slot\u2081/#self#(called) slot\u2082/x slot\u2083/y]\n     1   (call core.tuple slot\u2082/x slot\u2083/y)\n     2   (return %\u2081)\n 26  latestworld\n@@ -537,7 +537,7 @@ end\n 26  SourceLocation::1:10\n 27  (call core.svec %\u2082\u2084 %\u2082\u2085 %\u2082\u2086)\n 28  --- method core.nothing %\u2082\u2087\n-    slots: [slot\u2081/#self#(!read) slot\u2082/#arg1#(!read) slot\u2083/y slot\u2084/z]\n+    slots: [slot\u2081/#self#(called) slot\u2082/#arg1# slot\u2083/y slot\u2084/z]\n     1   (call core.tuple slot\u2083/y slot\u2084/z)\n     2   (return %\u2081)\n 29  latestworld\n@@ -572,7 +572,7 @@ end\n 17  SourceLocation::1:10\n 18  (call core.svec %\u2081\u2085 %\u2081\u2086 %\u2081\u2087)\n 19  --- method core.nothing %\u2081\u2088\n-    slots: [slot\u2081/#self#(!read) slot\u2082/#arg1#(!read) slot\u2083/x]\n+    slots: [slot\u2081/#self#(called) slot\u2082/#arg1# slot\u2083/x]\n     1   slot\u2083/x\n     2   (return %\u2081)\n 20  latestworld\n@@ -587,16 +587,16 @@ end\n #---------------------\n 1   (method TestMod.f)\n 2   latestworld\n-3   (= slot\u2082/T (call core.TypeVar :T))\n-4   slot\u2082/T\n-5   (= slot\u2081/S (call core.TypeVar :S %\u2084))\n-6   slot\u2081/S\n+3   (= slot\u2081/T (call core.TypeVar :T))\n+4   slot\u2081/T\n+5   (= slot\u2082/S (call core.TypeVar :S %\u2084))\n+6   slot\u2082/S\n 7   (= slot\u2083/U (call core.TypeVar :U %\u2086))\n 8   TestMod.f\n 9   (call core.Typeof %\u2088)\n-10  slot\u2082/T\n+10  slot\u2081/T\n 11  (call core.svec %\u2089 %\u2081\u2080)\n-12  slot\u2082/T\n+12  slot\u2081/T\n 13  (call core.svec %\u2081\u2082)\n 14  SourceLocation::1:10\n 15  (call core.svec %\u2081\u2081 %\u2081\u2083 %\u2081\u2084)\n@@ -607,11 +607,11 @@ end\n 17  latestworld\n 18  TestMod.f\n 19  (call core.Typeof %\u2081\u2088)\n-20  slot\u2082/T\n-21  slot\u2081/S\n+20  slot\u2081/T\n+21  slot\u2082/S\n 22  (call core.svec %\u2081\u2089 %\u2082\u2080 %\u2082\u2081)\n-23  slot\u2082/T\n-24  slot\u2081/S\n+23  slot\u2081/T\n+24  slot\u2082/S\n 25  (call core.svec %\u2082\u2083 %\u2082\u2084)\n 26  SourceLocation::1:10\n 27  (call core.svec %\u2082\u2082 %\u2082\u2085 %\u2082\u2086)\n@@ -622,18 +622,18 @@ end\n 29  latestworld\n 30  TestMod.f\n 31  (call core.Typeof %\u2083\u2080)\n-32  slot\u2082/T\n-33  slot\u2081/S\n+32  slot\u2081/T\n+33  slot\u2082/S\n 34  slot\u2083/U\n 35  (call core.svec %\u2083\u2081 %\u2083\u2082 %\u2083\u2083 %\u2083\u2084)\n-36  slot\u2082/T\n-37  slot\u2081/S\n+36  slot\u2081/T\n+37  slot\u2082/S\n 38  slot\u2083/U\n 39  (call core.svec %\u2083\u2086 %\u2083\u2087 %\u2083\u2088)\n 40  SourceLocation::1:10\n 41  (call core.svec %\u2083\u2085 %\u2083\u2089 %\u2084\u2080)\n 42  --- method core.nothing %\u2084\u2081\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/z]\n+    slots: [slot\u2081/#self#(called) slot\u2082/x slot\u2083/y slot\u2084/z]\n     1   (call core.tuple slot\u2082/x slot\u2083/y slot\u2084/z)\n     2   (return %\u2081)\n 43  latestworld\n@@ -650,11 +650,11 @@ end\n #---------------------\n 1   (method TestMod.f)\n 2   latestworld\n-3   (= slot\u2082/T (call core.TypeVar :T))\n+3   (= slot\u2081/T (call core.TypeVar :T))\n 4   TestMod.AbstractVector\n-5   slot\u2082/T\n+5   slot\u2081/T\n 6   (call core.apply_type %\u2084 %\u2085)\n-7   (= slot\u2081/S (call core.TypeVar :S %\u2086))\n+7   (= slot\u2082/S (call core.TypeVar :S %\u2086))\n 8   (= slot\u2083/U (call core.TypeVar :U))\n 9   TestMod.f\n 10  (call core.Typeof %\u2089)\n@@ -670,10 +670,10 @@ end\n 16  latestworld\n 17  TestMod.f\n 18  (call core.Typeof %\u2081\u2087)\n-19  slot\u2081/S\n+19  slot\u2082/S\n 20  (call core.svec %\u2081\u2088 core.Any %\u2081\u2089)\n-21  slot\u2082/T\n-22  slot\u2081/S\n+21  slot\u2081/T\n+22  slot\u2082/S\n 23  (call core.svec %\u2082\u2081 %\u2082\u2082)\n 24  SourceLocation::1:10\n 25  (call core.svec %\u2082\u2080 %\u2082\u2083 %\u2082\u2084)\n@@ -684,17 +684,17 @@ end\n 27  latestworld\n 28  TestMod.f\n 29  (call core.Typeof %\u2082\u2088)\n-30  slot\u2081/S\n+30  slot\u2082/S\n 31  slot\u2083/U\n 32  (call core.svec %\u2082\u2089 core.Any %\u2083\u2080 %\u2083\u2081)\n-33  slot\u2082/T\n-34  slot\u2081/S\n+33  slot\u2081/T\n+34  slot\u2082/S\n 35  slot\u2083/U\n 36  (call core.svec %\u2083\u2083 %\u2083\u2084 %\u2083\u2085)\n 37  SourceLocation::1:10\n 38  (call core.svec %\u2083\u2082 %\u2083\u2086 %\u2083\u2087)\n 39  --- method core.nothing %\u2083\u2088\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/z]\n+    slots: [slot\u2081/#self#(called) slot\u2082/x slot\u2083/y slot\u2084/z]\n     1   static_parameter\u2081\n     2   static_parameter\u2082\n     3   static_parameter\u2083\n@@ -731,7 +731,7 @@ end\n 16  SourceLocation::1:10\n 17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n 18  --- method core.nothing %\u2081\u2087\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/ys]\n+    slots: [slot\u2081/#self#(called) slot\u2082/x(!read) slot\u2083/ys]\n     1   slot\u2083/ys\n     2   (return %\u2081)\n 19  latestworld\n@@ -777,7 +777,7 @@ end\n 16  SourceLocation::1:10\n 17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n 18  --- method core.nothing %\u2081\u2087\n-    slots: [slot\u2081/#self#(!read) slot\u2082/xs]\n+    slots: [slot\u2081/#self#(called) slot\u2082/xs]\n     1   slot\u2082/xs\n     2   (return %\u2081)\n 19  latestworld\n@@ -812,7 +812,7 @@ end\n 16  SourceLocation::1:10\n 17  (call core.svec %\u2081\u2084 %\u2081\u2085 %\u2081\u2086)\n 18  --- method core.nothing %\u2081\u2087\n-    slots: [slot\u2081/#self#(!read) slot\u2082/xs]\n+    slots: [slot\u2081/#self# slot\u2082/xs]\n     1   slot\u2082/xs\n     2   (return %\u2081)\n 19  latestworld\n@@ -833,7 +833,7 @@ end\n 7   SourceLocation::1:10\n 8   (call core.svec %\u2085 %\u2086 %\u2087)\n 9   --- method core.nothing %\u2088\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/destructured_arg slot\u2084/w(!read) slot\u2085/iterstate slot\u2086/y(!read) slot\u2087/z(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/destructured_arg slot\u2084/w(!read) slot\u2085/iterstate(single_assign) slot\u2086/y(!read,single_assign) slot\u2087/z(!read,single_assign)]\n     1   (call top.indexed_iterate slot\u2083/destructured_arg 1)\n     2   (= slot\u2086/y (call core.getfield %\u2081 1))\n     3   (= slot\u2085/iterstate (call core.getfield %\u2081 2))\n@@ -873,7 +873,7 @@ end\n 17  SourceLocation::1:10\n 18  (call core.svec %\u2081\u2085 %\u2081\u2086 %\u2081\u2087)\n 19  --- method core.nothing %\u2081\u2088\n-    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/x(!read)]\n+    slots: [slot\u2081/#self#(called) slot\u2082/destructured_arg slot\u2083/x(!read,single_assign)]\n     1   (call top.indexed_iterate slot\u2082/destructured_arg 1)\n     2   (= slot\u2083/x (call core.getfield %\u2081 1))\n     3   (return core.nothing)\n@@ -907,7 +907,7 @@ end\n 15  SourceLocation::1:10\n 16  (call core.svec %\u2081\u2083 %\u2081\u2084 %\u2081\u2085)\n 17  --- method core.nothing %\u2081\u2086\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/tmp(!read)]\n+    slots: [slot\u2081/#self#(called) slot\u2082/x(!read) slot\u2083/tmp(!read)]\n     1   TestMod.T\n     2   (= slot\u2083/tmp core.nothing)\n     3   slot\u2083/tmp\n@@ -1029,7 +1029,7 @@ end\n 7   SourceLocation::1:10\n 8   (call core.svec %\u2085 %\u2086 %\u2087)\n 9   --- method core.nothing %\u2088\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read,single_assign)]\n     1   (return 1)\n     2   (= slot\u2082/x core.nothing)\n 10  latestworld\n@@ -1113,7 +1113,7 @@ end\n 15  SourceLocation::1:10\n 16  (call core.svec %\u2081\u2083 %\u2081\u2084 %\u2081\u2085)\n 17  --- method core.nothing %\u2081\u2086\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/#self#(!read) slot\u2085/a slot\u2086/b]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/#self#(called) slot\u2085/a slot\u2086/b]\n     1   (meta :nkw 2)\n     2   (call core.tuple slot\u2085/a slot\u2086/b slot\u2082/x slot\u2083/y)\n     3   (return %\u2082)\n@@ -1126,7 +1126,7 @@ end\n 24  SourceLocation::1:10\n 25  (call core.svec %\u2082\u2082 %\u2082\u2083 %\u2082\u2084)\n 26  --- method core.nothing %\u2082\u2085\n-    slots: [slot\u2081/#self#(called) slot\u2082/kws slot\u2083/#self#]\n+    slots: [slot\u2081/#self#(called) slot\u2082/kws slot\u2083/#self#(called)]\n     1   (call slot\u2081/#self# slot\u2082/kws slot\u2083/#self# 1 1.0)\n     2   (return %\u2081)\n 27  latestworld\n@@ -1139,7 +1139,7 @@ end\n 34  SourceLocation::1:10\n 35  (call core.svec %\u2083\u2082 %\u2083\u2083 %\u2083\u2084)\n 36  --- method core.nothing %\u2083\u2085\n-    slots: [slot\u2081/#self#(called) slot\u2082/kws slot\u2083/#self# slot\u2084/a]\n+    slots: [slot\u2081/#self#(called) slot\u2082/kws slot\u2083/#self#(called) slot\u2084/a]\n     1   (call slot\u2081/#self# slot\u2082/kws slot\u2083/#self# slot\u2084/a 1.0)\n     2   (return %\u2081)\n 37  latestworld\n@@ -1153,7 +1153,7 @@ end\n 45  SourceLocation::1:10\n 46  (call core.svec %\u2084\u2083 %\u2084\u2084 %\u2084\u2085)\n 47  --- method core.nothing %\u2084\u2086\n-    slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/a slot\u2085/b slot\u2086/kwtmp slot\u2087/x(!read) slot\u2088/y(!read)]\n+    slots: [slot\u2081/#self#(called) slot\u2082/kws slot\u2083/#self#(called) slot\u2084/a slot\u2085/b slot\u2086/kwtmp slot\u2087/x(!read) slot\u2088/y(!read)]\n     1   (newvar slot\u2087/x)\n     2   (newvar slot\u2088/y)\n     3   (call core.isdefined slot\u2082/kws :x)\n@@ -1227,7 +1227,7 @@ end\n 72  SourceLocation::1:10\n 73  (call core.svec %\u2087\u2080 %\u2087\u2081 %\u2087\u2082)\n 74  --- method core.nothing %\u2087\u2083\n-    slots: [slot\u2081/#self# slot\u2082/a slot\u2083/b]\n+    slots: [slot\u2081/#self#(called) slot\u2082/a slot\u2083/b]\n     1   TestMod.#f_kw_simple#0\n     2   (call %\u2081 'a' true slot\u2081/#self# slot\u2082/a slot\u2083/b)\n     3   (return %\u2082)\n@@ -1263,7 +1263,7 @@ end\n 12  SourceLocation::1:10\n 13  (call core.svec %\u2081\u2080 %\u2081\u2081 %\u2081\u2082)\n 14  --- method core.nothing %\u2081\u2083\n-    slots: [slot\u2081/#self#(!read) slot\u2082/all_kws slot\u2083/#self#(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/all_kws slot\u2083/#self#]\n     1   (meta :nkw 1)\n     2   slot\u2082/all_kws\n     3   (return %\u2082)\n@@ -1320,7 +1320,7 @@ end\n 12  SourceLocation::1:10\n 13  (call core.svec %\u2081\u2080 %\u2081\u2081 %\u2081\u2082)\n 14  --- method core.nothing %\u2081\u2083\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/non_x_kws(!read) slot\u2084/#self#(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read) slot\u2083/non_x_kws(!read) slot\u2084/#self#]\n     1   (meta :nkw 2)\n     2   TestMod.all_kws\n     3   (return %\u2082)\n@@ -1333,9 +1333,9 @@ end\n 21  SourceLocation::1:10\n 22  (call core.svec %\u2081\u2089 %\u2082\u2080 %\u2082\u2081)\n 23  --- method core.nothing %\u2082\u2082\n-    slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/kwtmp slot\u2085/non_x_kws(!read) slot\u2086/x(!read)]\n-    1   (newvar slot\u2085/non_x_kws)\n-    2   (newvar slot\u2086/x)\n+    slots: [slot\u2081/#self#(!read) slot\u2082/kws slot\u2083/#self# slot\u2084/kwtmp slot\u2085/x(!read) slot\u2086/non_x_kws(!read)]\n+    1   (newvar slot\u2085/x)\n+    2   (newvar slot\u2086/non_x_kws)\n     3   (call core.isdefined slot\u2082/kws :x)\n     4   (gotoifnot %\u2083 label\u2088)\n     5   (call core.getfield slot\u2082/kws :x)\n@@ -1384,37 +1384,37 @@ end\n 2   latestworld\n 3   (method TestMod.#f_kw_sparams#0)\n 4   latestworld\n-5   (= slot\u2082/X (call core.TypeVar :X))\n-6   (= slot\u2081/A (call core.TypeVar :A))\n+5   (= slot\u2081/X (call core.TypeVar :X))\n+6   (= slot\u2082/A (call core.TypeVar :A))\n 7   TestMod.#f_kw_sparams#0\n 8   (call core.Typeof %\u2087)\n-9   slot\u2081/A\n-10  slot\u2082/X\n+9   slot\u2082/A\n+10  slot\u2081/X\n 11  TestMod.f_kw_sparams\n 12  (call core.Typeof %\u2081\u2081)\n-13  slot\u2082/X\n+13  slot\u2081/X\n 14  (call core.svec %\u2088 %\u2089 %\u2081\u2080 %\u2081\u2082 %\u2081\u2083)\n-15  slot\u2082/X\n-16  slot\u2081/A\n+15  slot\u2081/X\n+16  slot\u2082/A\n 17  (call core.svec %\u2081\u2085 %\u2081\u2086)\n 18  SourceLocation::1:10\n 19  (call core.svec %\u2081\u2084 %\u2081\u2087 %\u2081\u2088)\n 20  --- method core.nothing %\u2081\u2089\n-    slots: [slot\u2081/#self#(!read) slot\u2082/a(!read) slot\u2083/b(!read) slot\u2084/#self#(!read) slot\u2085/x(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/a(!read) slot\u2083/b(!read) slot\u2084/#self# slot\u2085/x(!read)]\n     1   (meta :nkw 2)\n     2   static_parameter\u2081\n     3   static_parameter\u2082\n     4   (call core.tuple %\u2082 %\u2083)\n     5   (return %\u2084)\n 21  latestworld\n-22  (= slot\u2084/X (call core.TypeVar :X))\n-23  (= slot\u2083/A (call core.TypeVar :A))\n+22  (= slot\u2083/X (call core.TypeVar :X))\n+23  (= slot\u2084/A (call core.TypeVar :A))\n 24  (call core.typeof core.kwcall)\n 25  TestMod.f_kw_sparams\n 26  (call core.Typeof %\u2082\u2085)\n-27  slot\u2084/X\n+27  slot\u2083/X\n 28  (call core.svec %\u2082\u2084 core.NamedTuple %\u2082\u2086 %\u2082\u2087)\n-29  slot\u2084/X\n+29  slot\u2083/X\n 30  (call core.svec %\u2082\u2089)\n 31  SourceLocation::1:10\n 32  (call core.svec %\u2082\u2088 %\u2083\u2080 %\u2083\u2081)\n@@ -1456,13 +1456,13 @@ end\n     34  (call %\u2083\u2083 %\u2081\u2080 %\u2082\u2085 slot\u2083/#self# slot\u2084/x)\n     35  (return %\u2083\u2084)\n 34  latestworld\n-35  (= slot\u2086/X (call core.TypeVar :X))\n-36  (= slot\u2085/A (call core.TypeVar :A))\n+35  (= slot\u2085/X (call core.TypeVar :X))\n+36  (= slot\u2086/A (call core.TypeVar :A))\n 37  TestMod.f_kw_sparams\n 38  (call core.Typeof %\u2083\u2087)\n-39  slot\u2086/X\n+39  slot\u2085/X\n 40  (call core.svec %\u2083\u2088 %\u2083\u2089)\n-41  slot\u2086/X\n+41  slot\u2085/X\n 42  (call core.svec %\u2084\u2081)\n 43  SourceLocation::1:10\n 44  (call core.svec %\u2084\u2080 %\u2084\u2082 %\u2084\u2083)\n@@ -1604,7 +1604,7 @@ end\n 17  SourceLocation::1:10\n 18  (call core.svec %\u2081\u2085 %\u2081\u2086 %\u2081\u2087)\n 19  --- method core.nothing %\u2081\u2088\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/maybe_gen_stuff slot\u2085/nongen_stuff]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/y slot\u2084/maybe_gen_stuff(single_assign) slot\u2085/nongen_stuff(single_assign)]\n     1   (meta :generated (new JuliaLowering.GeneratedFunctionStub false TestMod.#f_partially_generated@generator#0 SourceRef::1:37 (call core.svec :#self# :x :y) (call core.svec)))\n     2   TestMod.bothgen\n     3   (= slot\u2085/nongen_stuff (call %\u2082 slot\u2082/x slot\u2083/y))"
    },
    {
      "sha": "e2d790b0ea49fb9738c4370b8e941bc4c1608467",
      "filename": "JuliaLowering/test/generators_ir.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fgenerators_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fgenerators_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fgenerators_ir.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -37,7 +37,7 @@\n 8   SourceLocation::1:2\n 9   (call core.svec %\u2086 %\u2087 %\u2088)\n 10  --- method core.nothing %\u2089\n-    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/iterstate slot\u2084/x slot\u2085/y]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/iterstate(single_assign) slot\u2084/x(single_assign) slot\u2085/y(single_assign)]\n     1   (call top.indexed_iterate slot\u2082/destructured_arg 1)\n     2   (= slot\u2084/x (call core.getfield %\u2081 1))\n     3   (= slot\u2083/iterstate (call core.getfield %\u2081 2))\n@@ -72,7 +72,7 @@\n 8   SourceLocation::1:29\n 9   (call core.svec %\u2086 %\u2087 %\u2088)\n 10  --- method core.nothing %\u2089\n-    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/iterstate slot\u2084/x slot\u2085/y(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/iterstate(single_assign) slot\u2084/x(single_assign) slot\u2085/y(!read,single_assign)]\n     1   (call top.indexed_iterate slot\u2082/destructured_arg 1)\n     2   (= slot\u2084/x (call core.getfield %\u2081 1))\n     3   (= slot\u2083/iterstate (call core.getfield %\u2081 2))\n@@ -136,7 +136,7 @@ LoweringError:\n 8   SourceLocation::1:2\n 9   (call core.svec %\u2086 %\u2087 %\u2088)\n 10  --- method core.nothing %\u2089\n-    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/iterstate slot\u2084/x(!read) slot\u2085/y(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/destructured_arg slot\u2083/iterstate slot\u2084/x(!read,single_assign) slot\u2085/y(!read,single_assign)]\n     1   (call top.indexed_iterate slot\u2082/destructured_arg 1)\n     2   (= slot\u2084/x (call core.getfield %\u2081 1))\n     3   (= slot\u2083/iterstate (call core.getfield %\u2081 2))\n@@ -206,7 +206,7 @@ LoweringError:\n 12  SourceLocation::1:2\n 13  (call core.svec %\u2081\u2080 %\u2081\u2081 %\u2081\u2082)\n 14  --- method core.nothing %\u2081\u2083\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/x]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x slot\u2083/x(single_assign)]\n     1   slot\u2082/x\n     2   (= slot\u2083/x %\u2081)\n     3   slot\u2083/x\n@@ -270,12 +270,12 @@ T[(x,y) for x in xs, y in ys]\n 21  (call top.not_int %\u2082\u2080)\n 22  (gotoifnot %\u2082\u2081 label\u2084\u2084)\n 23  slot\u2084/y\n-24  (= slot\u2086/y %\u2082\u2083)\n+24  (= slot\u2085/y %\u2082\u2083)\n 25  slot\u2082/next\n-26  (= slot\u2085/x (call core.getfield %\u2082\u2085 1))\n+26  (= slot\u2086/x (call core.getfield %\u2082\u2085 1))\n 27  (call core.getfield %\u2082\u2085 2)\n-28  slot\u2085/x\n-29  slot\u2086/y\n+28  slot\u2086/x\n+29  slot\u2085/y\n 30  (call core.tuple %\u2082\u2088 %\u2082\u2089)\n 31  (gotoifnot %\u2085 label\u2083\u2084)\n 32  (call top.push! %\u2087 %\u2083\u2080)"
    },
    {
      "sha": "308a5eb56f2c396aa14fa14798adf3030402056d",
      "filename": "JuliaLowering/test/macros_ir.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fmacros_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fmacros_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmacros_ir.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -72,7 +72,7 @@ end\n 7   SourceLocation::1:7\n 8   (call core.svec %\u2085 %\u2086 %\u2087)\n 9   --- method core.nothing %\u2088\n-    slots: [slot\u2081/#self#(!read) slot\u2082/__context__ slot\u2083/ex(!read) slot\u2084/ctx(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/__context__ slot\u2083/ex(!read) slot\u2084/ctx(!read,single_assign)]\n     1   slot\u2082/__context__\n     2   (= slot\u2084/ctx %\u2081)\n     3   (return %\u2081)"
    },
    {
      "sha": "b9935d3a6527661ab270c68a81b84d2f7625282e",
      "filename": "JuliaLowering/test/scopes.jl",
      "status": "modified",
      "additions": 285,
      "deletions": 16,
      "changes": 301,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fscopes.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fscopes.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fscopes.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -58,23 +58,292 @@ begin\n end\n \"\"\") === :outer_y\n \n-# wrap expression in scope block of `scope_type`\n-function wrapscope(ex, scope_type)\n-    g = JuliaLowering.ensure_attributes(ex._graph, scope_type=Symbol)\n-    ex = JuliaLowering.reparent(g, ex)\n-    makenode(g, ex, K\"scope_block\", [ex._id], [:scope_type=>scope_type])\n+#=\n+| old\\new: || global     | local | arg                | sparam             |\n+|----------++------------+-------+--------------------+--------------------|\n+| global   || no-op      | (*)   |                    |                    |\n+| local    || error (*)  | no-op |                    |                    |\n+| arg      || shadow(??) | error | error (not unique) |                    |\n+| sparam   || shadow(??) | error | error (sparam/arg) | error (not unique) |\n+=#\n+@testset \"Conflicts in the same local scope\" begin\n+\n+    # no-op cases.  It would probably be clearer (but breaking) if these were\n+    # errors like the conflict cases (two of the same decl should never do\n+    # anything, and the user might be expecting two variables).\n+    @testset \"global,global\" begin\n+        s = \"function (); global g; global g; 1; end\"\n+        @test JuliaLowering.include_string(test_mod, s) isa Function\n+    end\n+    @testset \"local,local\" begin\n+        s = \"function (); local l; local l; end\"\n+        @test JuliaLowering.include_string(test_mod, s) isa Function\n+    end\n+\n+    # locals may not overlap args/sparams/globals\n+    @testset \"global,local/local,global\" begin\n+        s = \"function (); global g; local g; end\"\n+        @test_throws LoweringError JuliaLowering.include_string(test_mod, s)\n+    end\n+    @testset \"arg,local\" begin\n+        s = \"function (x); local x; end\"\n+        @test_throws LoweringError JuliaLowering.include_string(test_mod, s)\n+    end\n+    @testset \"sparam,local\" begin\n+        s = \"function (a::s) where {s}; local s; end\"\n+        @test_throws LoweringError JuliaLowering.include_string(test_mod, s)\n+    end\n+\n+    # globals may overlap args or sparams (buggy?)  TODO: decide whether it's\n+    # worth replicating this behaviour.  We would likely need to copy the way\n+    # flisp nests an extra scope block in every lambda.\n+    @testset \"arg,global\" begin\n+        s = \"function (a); global a = 1; a; end\"\n+        @test_broken f = JuliaLowering.include_string(test_mod, s)\n+        @test_broken f isa Function\n+        @test_broken f(999) === 1\n+        @test_broken isdefinedglobal(test_mod, :a)\n+    end\n+    @testset \"sparam,global\" begin\n+        s = \"function (a::s) where {s}; global s = 1; s; end\"\n+        @test_broken f = JuliaLowering.include_string(test_mod, s)\n+        @test_broken f isa Function\n+        @test_broken f(999) === 1\n+        @test_broken isdefinedglobal(test_mod, :s)\n+    end\n+\n+    # sp/arg conflict\n+    @testset \"arg,sparam\" begin\n+        s = \"function (a) where {a}; end\"\n+        @test_throws LoweringError JuliaLowering.include_string(test_mod, s)\n+    end\n+    @testset \"arg,arg\" begin\n+        s = \"function (a,a); end\"\n+        @test_throws LoweringError JuliaLowering.include_string(test_mod, s)\n+    end\n+    @testset \"sparam,sparam\" begin\n+        s = \"function () where {s,s}; end\"\n+        @test_throws LoweringError JuliaLowering.include_string(test_mod, s)\n+    end\n+\n+    # (not in table) destructured args are handled internally like locals, but\n+    # should have similar conflict rules to arguments\n+    @testset \"destructured-arg,destructured-arg/arg/local/sp/global\" begin\n+        s = \"function ((x,x)); end\"\n+        @test_throws LoweringError JuliaLowering.include_string(test_mod, s)\n+        s = \"function ((x,y),x); end\"\n+        @test_throws LoweringError JuliaLowering.include_string(test_mod, s)\n+        s = \"function ((x,y)) where {x}; end\"\n+        @test_throws LoweringError JuliaLowering.include_string(test_mod, s)\n+        s = \"function ((x,y)); global x; x; end\"\n+        @test_throws LoweringError JuliaLowering.include_string(test_mod, s)\n+        # quirk: flisp is OK with this\n+        s = \"function ((x,y)); local x; end\"\n+        @test JuliaLowering.include_string(test_mod, s) isa Function\n+    end\n+\n+end\n+\n+@testset \"basic softscope (uses internal lowering nodes, not surface syntax)\" begin\n+    # wrap expression in scope block of `scope_type` (:neutral or :hard)\n+    function wrapscope(ex, scope_type)\n+        g = JuliaLowering.ensure_attributes(ex._graph, scope_type=Symbol)\n+        ex = JuliaLowering.reparent(g, ex)\n+        makenode(g, ex, K\"scope_block\", [ex._id], [:scope_type=>scope_type])\n+    end\n+    function use_soft(ex::SyntaxTree)\n+        @ast ex._graph ex [K\"block\" (::K\"softscope\") ex]\n+    end\n+\n+    assign_z_2 = parsestmt(SyntaxTree, \"begin z = 2 end\", filename=\"foo.jl\")\n+    Base.eval(test_mod, :(z=1))\n+    @test test_mod.z == 1\n+    # hard scopes will always create a new binding; softscope mode is ignored\n+    JuliaLowering.eval(test_mod, wrapscope(assign_z_2, :hard))\n+    @test test_mod.z == 1\n+    JuliaLowering.eval(test_mod, use_soft(wrapscope(assign_z_2, :hard)))\n+    @test test_mod.z == 1\n+    # neutral (eg, for loops) and hard (eg, let) scopes create a new binding for z\n+    JuliaLowering.eval(test_mod, wrapscope(assign_z_2, :neutral))\n+    @test test_mod.z == 1\n+    # but soft scope mode makes assignment in neutral scope assign to global `z`\n+    JuliaLowering.eval(test_mod, use_soft(wrapscope(assign_z_2, :neutral)))\n+    @test test_mod.z == 2\n+end\n+\n+# Switch to Core.eval for sanity-checking\n+expr_eval(mod, ex) = JuliaLowering.eval(mod, ex)\n+\n+enable_softscope(e) = Expr(:block, Expr(:softscope, true), e)\n+inner_neutral(e) = :(for _ in 1:1; $e; end)\n+inner_func(e) = :((function (); $e end)(#=called=#))\n+inner_hard(e) = :(let; $e end)\n+\n+outer_none(e) = :(begin\n+                      local lname = false\n+                      global gname = false\n+                      $e\n+                  end)\n+outer_neutral(e) = :(try # use try so that a value is returned\n+                         local lname = false\n+                         global gname = false\n+                         $e\n+                     catch what\n+                         rethrow(what)\n+                     end)\n+outer_hard(e) = :(let lname = false # takes a different code path in flisp\n+                      global gname = false\n+                      $e\n+                  end)\n+outer_func(e) = :((function (argname::spname = false) where spname\n+                       local lname = false\n+                       global gname = false\n+                       $e\n+                   end)(#=called=#))\n+\n+lhs_names = (:lname, :gname, :argname, :spname)\n+\n+# For each distinct outer and inner scope, and each kind of variable in the\n+# outer scope, set the same name to true from the inner scope\n+@testset \"Behaviour of `=` in local scope (shadow or assign-existing)\" begin\n+    expected_outer_vals = Dict{Tuple{Bool, Function, Function}, Tuple}(\n+        (true,  outer_none,    inner_func   ) => (true,false),\n+        (true,  outer_none,    inner_hard   ) => (true,false),\n+        (true,  outer_none,    inner_neutral) => (true,true),\n+        (true,  outer_neutral, inner_func   ) => (true,true),\n+        (true,  outer_neutral, inner_hard   ) => (true,true),\n+        (true,  outer_neutral, inner_neutral) => (true,true),\n+        (true,  outer_hard,    inner_func   ) => (true,true),\n+        (true,  outer_hard,    inner_hard   ) => (true,true),\n+        (true,  outer_hard,    inner_neutral) => (true,true),\n+        (true,  outer_func,    inner_func   ) => (true,true,true),\n+        (true,  outer_func,    inner_hard   ) => (true,true,true),\n+        (true,  outer_func,    inner_neutral) => (true,true,true),\n+        (false, outer_none,    inner_func   ) => (true,false),\n+        (false, outer_none,    inner_hard   ) => (true,false),\n+        (false, outer_none,    inner_neutral) => (true,false),\n+        (false, outer_neutral, inner_func   ) => (true,true),\n+        (false, outer_neutral, inner_hard   ) => (true,true),\n+        (false, outer_neutral, inner_neutral) => (true,true),\n+        (false, outer_hard,    inner_func   ) => (true,true),\n+        (false, outer_hard,    inner_hard   ) => (true,true),\n+        (false, outer_hard,    inner_neutral) => (true,true),\n+        (false, outer_func,    inner_func   ) => (true,true,true),\n+        (false, outer_func,    inner_hard   ) => (true,true,true),\n+        (false, outer_func,    inner_neutral) => (true,true,true),\n+    )\n+    expected_s(b::Bool) = b ? \"assignment to outer var\" : \"brand-new var\"\n+\n+    tmp_test_mod = Module()\n+    tmp_test_mod_2 = Module()\n+\n+    for soft_mode in (true, false),\n+        outer_s in (outer_none, outer_neutral, outer_hard, outer_func),\n+        inner_s in (inner_func, inner_hard, inner_neutral),\n+        (lhs_i, lhs) in enumerate(lhs_names)\n+\n+        ex = outer_s(Expr(:block, inner_s(:($lhs = true)), lhs))\n+        soft_mode && (ex = enable_softscope(ex))\n+\n+        if lhs in (:argname, :spname) && parent !== outer_func\n+            continue\n+        elseif lhs === :spname\n+            @test_throws LoweringError expr_eval(tmp_test_mod, ex)\n+        else\n+            expected = expected_outer_vals[(soft_mode, outer_s, inner_s)][lhs_i]\n+            ok = expr_eval(tmp_test_mod, ex) === expected\n+            !ok && error(\"expected $(expected_s(expected)), got $(expected_s(!expected))\\n\", ex)\n+            @test ok\n+        end\n+\n+        if lhs === :gname\n+            Base.delete_binding(tmp_test_mod, :gname)\n+            Base.delete_binding(tmp_test_mod_2, :gname)\n+        end\n+    end\n+end\n+\n+@testset \"global declarations at top level are ignored in assignment resolution\" begin\n+    suggest_global(e) = :(begin; global declared_unassigned_global; $e; end)\n+    for soft_mode in (true, false), scope in (inner_func, inner_hard, inner_neutral)\n+        ex = scope(:(declared_unassigned_global = true))\n+        soft_mode && (ex = enable_softscope(ex))\n+        expr_eval(test_mod, ex)\n+        global_assigned = @invokelatest isdefined(test_mod, :declared_unassigned_global)\n+        global_assigned && error(\"global should not be assigned. settings: $soft_mode $scope\\n\")\n+        @test !global_assigned\n+    end\n+\n+    @testset \"soft scope isn't top level\" begin\n+        ex = quote\n+            begin\n+                for i in 1:1; global soft_assigned_explicit_global = 1; end\n+                for i in 1:1; soft_assigned_explicit_global = 2; end\n+            end\n+        end\n+        expr_eval(test_mod, enable_softscope(ex))\n+        @test test_mod.soft_assigned_explicit_global === 1\n+    end\n+end\n+\n+# Distinct from the stateful \"existing global\" check (probably to get around the\n+# case where the global only becomes existing within the expression being\n+# lowered)\n+@testset \"assignments at top level can influence assignment resolution in soft scopes\" begin\n+    for soft_mode in (true, false),\n+        s1 in (inner_neutral, (e)->inner_neutral(inner_neutral(e))),\n+        g_assign in (:(assigned_global = false), :(global assigned_global = false))\n+\n+        inner_assign_islocal = s1(Expr(\n+            :block,\n+            :(assigned_global = true),\n+            Expr(:(=), :out, Expr(:islocal, :assigned_global))))\n+\n+        for ex in (Expr(:block, :(local out), inner_assign_islocal, g_assign, :out),\n+                   Expr(:block, :(local out), g_assign, inner_assign_islocal, :out))\n+\n+            if soft_mode\n+                ex = enable_softscope(ex)\n+                ok = expr_eval(test_mod, ex) === false\n+                !ok && error(\"expected assignment to global\\n\", ex)\n+                @test ok\n+            else\n+                # some of these produce warning in flisp\n+                ok = expr_eval(test_mod, ex) === true\n+                !ok && error(\"expected assignment to local\\n\", ex)\n+                @test ok\n+            end\n+            Base.delete_binding(test_mod, :assigned_global)\n+        end\n+    end\n end\n \n-assign_z_2 = parsestmt(SyntaxTree, \"begin z = 2 end\", filename=\"foo.jl\")\n-Base.eval(test_mod, :(z=1))\n-@test test_mod.z == 1\n-# neutral (eg, for loops) and hard (eg, let) scopes create a new binding for z\n-JuliaLowering.eval(test_mod, wrapscope(assign_z_2, :neutral))\n-@test test_mod.z == 1\n-JuliaLowering.eval(test_mod, wrapscope(assign_z_2, :hard))\n-@test test_mod.z == 1\n-# but wrapping neutral scope in soft scope uses the existing binding in test_mod\n-JuliaLowering.eval(test_mod, wrapscope(wrapscope(assign_z_2, :neutral), :soft))\n-@test test_mod.z == 2\n+# Note: Certain flisp (un)hygiene behaviour is yet to be implemented.\n+# In flisp, with no escaping:\n+# - Top-level functions are unhygienic and declared in the macro's module\n+# - Top level globals are unhygienic and declared in the calling module\n+#   - this includes abstract, primitive, and struct types\n+# - Top-level `x=y` implicitly declares hygienic globals (but it is not breaking\n+#   to make them local)\n+#\n+# See https://github.com/JuliaLang/julia/issues/53667 for more quirks\n+@testset \"unescaped macro expansions introduce a hygienic scope\" begin\n+    @eval test_mod module macro_mod\n+        macro m(x); x; end\n+        macro mesc(x); esc(x); end\n+    end\n+\n+    JuliaLowering.include_string(test_mod, \"macro_mod.@m function f_local_1(); 1; end\")\n+    @test !isdefined(test_mod.macro_mod, :f_local_1)\n+    JuliaLowering.include_string(test_mod, \"macro_mod.@mesc function f_nonlocal_2(); 1; end\")\n+    @test isdefined(test_mod, :f_nonlocal_2)\n+    # An unescaped const is local to a macro expansion\n+    @test_throws LoweringError JuliaLowering.include_string(test_mod, \"macro_mod.@m const c_local_1 = 1\")\n+    # The const may be escaped into test_mod\n+    JuliaLowering.include_string(test_mod, \"macro_mod.@mesc const c_nonlocal_2 = 1\")\n+    @test isdefined(test_mod, :c_nonlocal_2)\n+    JuliaLowering.include_string(test_mod, \"macro_mod.@mesc const c_nonlocal_3 = 1\"; expr_compat_mode=true)\n+    @test isdefined(test_mod, :c_nonlocal_3)\n+end\n \n end"
    },
    {
      "sha": "80c49569d18dd866447efd16bc46a516f4d84e6a",
      "filename": "JuliaLowering/test/scopes_ir.jl",
      "status": "modified",
      "additions": 29,
      "deletions": 64,
      "changes": 93,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fscopes_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Fscopes_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fscopes_ir.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -11,7 +11,7 @@ end\n #---------------------\n 1   TestMod.rhs\n 2   TestMod.T\n-3   (newvar slot\u2081/T)\n+3   (newvar slot\u2082/T)\n 4   (= slot\u2083/tmp %\u2081)\n 5   slot\u2083/tmp\n 6   (call core.isa %\u2085 %\u2082)\n@@ -21,9 +21,9 @@ end\n 10  (call top.convert %\u2082 %\u2089)\n 11  (= slot\u2083/tmp (call core.typeassert %\u2081\u2080 %\u2082))\n 12  slot\u2083/tmp\n-13  (= slot\u2082/x %\u2081\u2082)\n-14  (= slot\u2081/T 1)\n-15  slot\u2081/T\n+13  (= slot\u2081/x %\u2081\u2082)\n+14  (= slot\u2082/T 1)\n+15  slot\u2082/T\n 16  (return %\u2081\u2085)\n \n ########################################\n@@ -139,25 +139,22 @@ begin\n     end\n end\n #---------------------\n-1   (= slot\u2081/y (call core.Box))\n-2   2\n-3   slot\u2081/y\n-4   (call core.setfield! %\u2083 :contents %\u2082)\n-5   (method TestMod.f)\n-6   latestworld\n-7   TestMod.f\n-8   (call core.Typeof %\u2087)\n-9   (call core.svec %\u2088 core.Any)\n-10  (call core.svec)\n-11  SourceLocation::3:14\n-12  (call core.svec %\u2089 %\u2081\u2080 %\u2081\u2081)\n-13  --- method core.nothing %\u2081\u2082\n+1   (= slot\u2081/y 2)\n+2   (method TestMod.f)\n+3   latestworld\n+4   TestMod.f\n+5   (call core.Typeof %\u2084)\n+6   (call core.svec %\u2085 core.Any)\n+7   (call core.svec)\n+8   SourceLocation::3:14\n+9   (call core.svec %\u2086 %\u2087 %\u2088)\n+10  --- method core.nothing %\u2089\n     slots: [slot\u2081/#self#(!read) slot\u2082/x(!read)]\n     1   (call core.tuple false true true)\n     2   (return %\u2081)\n-14  latestworld\n-15  TestMod.f\n-16  (return %\u2081\u2085)\n+11  latestworld\n+12  TestMod.f\n+13  (return %\u2081\u2082)\n \n ########################################\n # @islocal with global\n@@ -231,7 +228,7 @@ end\n #---------------------\n LoweringError:\n function f(x, (x,))\n-#              \u2559 \u2500\u2500 function argument name not unique\n+#              \u2559 \u2500\u2500 destructured argument name `x` conflicts with an existing argument from the same scope\n end\n \n ########################################\n@@ -251,7 +248,7 @@ end\n #---------------------\n LoweringError:\n function f(x::x) where x\n-#                      \u2559 \u2500\u2500 static parameter name not distinct from function argument\n+#                      \u2559 \u2500\u2500 static parameter name `x` conflicts with an existing argument from the same scope\n end\n \n ########################################\n@@ -261,7 +258,7 @@ end\n #---------------------\n LoweringError:\n function f((x,), (x,))\n-#                 \u2559 \u2500\u2500 function argument name not unique\n+#                 \u2559 \u2500\u2500 destructured argument name `x` conflicts with an existing local variable from the same scope\n end\n \n ########################################\n@@ -275,7 +272,7 @@ LoweringError:\n let\n     local x\n     global x\n-#          \u2559 \u2500\u2500 Variable `x` declared both local and global\n+#          \u2559 \u2500\u2500 global variable name `x` conflicts with an existing local variable from the same scope\n end\n \n ########################################\n@@ -287,7 +284,7 @@ end\n LoweringError:\n function f(x)\n     local x\n-#         \u2559 \u2500\u2500 local variable name `x` conflicts with an argument\n+#         \u2559 \u2500\u2500 local variable name `x` conflicts with an existing argument from the same scope\n end\n \n ########################################\n@@ -299,7 +296,7 @@ end\n LoweringError:\n function f(x)\n     global x\n-#          \u2559 \u2500\u2500 global variable name `x` conflicts with an argument\n+#          \u2559 \u2500\u2500 global variable name `x` conflicts with an existing argument from the same scope\n end\n \n ########################################\n@@ -312,7 +309,7 @@ end\n LoweringError:\n function f((x,))\n     global x\n-#          \u2559 \u2500\u2500 Variable `x` declared both local and global\n+#          \u2559 \u2500\u2500 global variable name `x` conflicts with an existing local variable from the same scope\n end\n \n ########################################\n@@ -324,7 +321,7 @@ end\n LoweringError:\n function f(::T) where T\n     local T\n-#         \u2559 \u2500\u2500 local variable name `T` conflicts with a static parameter\n+#         \u2559 \u2500\u2500 local variable name `T` conflicts with an existing static parameter from the same scope\n end\n \n ########################################\n@@ -336,39 +333,7 @@ end\n LoweringError:\n function f(::T) where T\n     global T\n-#          \u2559 \u2500\u2500 global variable name `T` conflicts with a static parameter\n-end\n-\n-########################################\n-# Error: Conflicting static parameter and local in nested scope\n-function f(::T) where T\n-    let\n-        local T\n-    end\n-end\n-#---------------------\n-LoweringError:\n-function f(::T) where T\n-    let\n-        local T\n-#             \u2559 \u2500\u2500 local variable name `T` conflicts with a static parameter\n-    end\n-end\n-\n-########################################\n-# Error: Conflicting static parameter and global in nested scope\n-function f(::T) where T\n-    let\n-        global T\n-    end\n-end\n-#---------------------\n-LoweringError:\n-function f(::T) where T\n-    let\n-        global T\n-#              \u2559 \u2500\u2500 global variable name `T` conflicts with a static parameter\n-    end\n+#          \u2559 \u2500\u2500 global variable name `T` conflicts with an existing static parameter from the same scope\n end\n \n ########################################\n@@ -383,7 +348,7 @@ LoweringError:\n function f(::T) where T\n     let\n         T = rhs\n-#       \u2559 \u2500\u2500 local variable name `T` conflicts with a static parameter\n+#       \u2559 \u2500\u2500 cannot overwrite a static parameter\n     end\n end\n \n@@ -472,7 +437,7 @@ end\n 29  SourceLocation::3:12\n 30  (call core.svec %\u2082\u2087 %\u2082\u2088 %\u2082\u2089)\n 31  --- code_info\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read,maybe_undef)]\n     1   (captured_local 1)\n     2   (call core.isdefined %\u2081 :contents)\n     3   (gotoifnot %\u2082 label\u2085)\n@@ -510,7 +475,7 @@ end\n 13  SourceLocation::2:12\n 14  (call core.svec %\u2081\u2081 %\u2081\u2082 %\u2081\u2083)\n 15  --- code_info\n-    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read)]\n+    slots: [slot\u2081/#self#(!read) slot\u2082/x(!read,maybe_undef)]\n     1   TestMod.+\n     2   (captured_local 1)\n     3   (call core.isdefined %\u2082 :contents)"
    },
    {
      "sha": "90771486b0ee128e2ef249789a08896bd0459125",
      "filename": "JuliaLowering/test/typedefs_ir.jl",
      "status": "modified",
      "additions": 42,
      "deletions": 42,
      "changes": 84,
      "blob_url": "https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Ftypedefs_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/903568acd680da424c4513332a8914a436471ceb/JuliaLowering%2Ftest%2Ftypedefs_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Ftypedefs_ir.jl?ref=903568acd680da424c4513332a8914a436471ceb",
      "patch": "@@ -537,17 +537,17 @@ end\n #---------------------\n 1   (call core.declare_global TestMod :X false)\n 2   latestworld\n-3   (= slot\u2082/U (call core.TypeVar :U))\n+3   (= slot\u2083/U (call core.TypeVar :U))\n 4   TestMod.S\n 5   TestMod.T\n-6   (= slot\u2083/V (call core.TypeVar :V %\u2084 %\u2085))\n-7   slot\u2082/U\n-8   slot\u2083/V\n+6   (= slot\u2084/V (call core.TypeVar :V %\u2084 %\u2085))\n+7   slot\u2083/U\n+8   slot\u2084/V\n 9   (call core.svec %\u2087 %\u2088)\n 10  (call core.svec)\n 11  (call core.svec)\n 12  (call core._structtype TestMod :X %\u2089 %\u2081\u2080 %\u2081\u2081 false 0)\n-13  (= slot\u2084/X %\u2081\u2082)\n+13  (= slot\u2082/X %\u2081\u2082)\n 14  TestMod.Z\n 15  (call core._setsuper! %\u2081\u2082 %\u2081\u2084)\n 16  (call core.isdefinedglobal TestMod :X false)\n@@ -569,20 +569,20 @@ end\n 32  (call top.getproperty %\u2083\u2081 :body)\n 33  (call top.getproperty %\u2083\u2082 :parameters)\n 34  (call top.indexed_iterate %\u2083\u2083 1)\n-35  (= slot\u2082/U (call core.getfield %\u2083\u2084 1))\n+35  (= slot\u2083/U (call core.getfield %\u2083\u2084 1))\n 36  (= slot\u2081/iterstate (call core.getfield %\u2083\u2084 2))\n 37  slot\u2081/iterstate\n 38  (call top.indexed_iterate %\u2083\u2083 2 %\u2083\u2087)\n-39  (= slot\u2083/V (call core.getfield %\u2083\u2088 1))\n+39  (= slot\u2084/V (call core.getfield %\u2083\u2088 1))\n 40  (call core.svec)\n 41  (call core._typebody! %\u2082\u2088 %\u2081\u2082 %\u2084\u2080)\n 42  (call core.declare_const TestMod :X %\u2084\u2081)\n 43  latestworld\n-44  slot\u2082/U\n-45  slot\u2083/V\n+44  slot\u2083/U\n+45  slot\u2084/V\n 46  TestMod.X\n-47  slot\u2082/U\n-48  slot\u2083/V\n+47  slot\u2083/U\n+48  slot\u2084/V\n 49  (call core.apply_type %\u2084\u2086 %\u2084\u2087 %\u2084\u2088)\n 50  (call core.apply_type core.Type %\u2084\u2089)\n 51  (call core.UnionAll %\u2084\u2085 %\u2085\u2080)\n@@ -715,13 +715,13 @@ end\n #---------------------\n 1   (call core.declare_global TestMod :X false)\n 2   latestworld\n-3   (= slot\u2081/U (call core.TypeVar :U))\n-4   slot\u2081/U\n+3   (= slot\u2082/U (call core.TypeVar :U))\n+4   slot\u2082/U\n 5   (call core.svec %\u2084)\n 6   (call core.svec :x)\n 7   (call core.svec)\n 8   (call core._structtype TestMod :X %\u2085 %\u2086 %\u2087 false 1)\n-9   (= slot\u2082/X %\u2088)\n+9   (= slot\u2081/X %\u2088)\n 10  (call core._setsuper! %\u2088 core.Any)\n 11  (call core.isdefinedglobal TestMod :X false)\n 12  (gotoifnot %\u2081\u2081 label\u2081\u2086)\n@@ -741,15 +741,15 @@ end\n 26  (call top.getproperty %\u2082\u2085 :body)\n 27  (call top.getproperty %\u2082\u2086 :parameters)\n 28  (call top.indexed_iterate %\u2082\u2087 1)\n-29  (= slot\u2081/U (call core.getfield %\u2082\u2088 1))\n-30  slot\u2081/U\n+29  (= slot\u2082/U (call core.getfield %\u2082\u2088 1))\n+30  slot\u2082/U\n 31  (call core.svec %\u2083\u2080)\n 32  (call core._typebody! %\u2082\u2083 %\u2088 %\u2083\u2081)\n 33  (call core.declare_const TestMod :X %\u2083\u2082)\n 34  latestworld\n-35  slot\u2081/U\n+35  slot\u2082/U\n 36  TestMod.X\n-37  slot\u2081/U\n+37  slot\u2082/U\n 38  (call core.apply_type %\u2083\u2086 %\u2083\u2087)\n 39  (call core.apply_type core.Type %\u2083\u2088)\n 40  (call core.UnionAll %\u2083\u2085 %\u2083\u2089)\n@@ -774,9 +774,9 @@ end\n 46  latestworld\n 47  TestMod.X\n 48  (call core.apply_type core.Type %\u2084\u2087)\n-49  slot\u2081/U\n+49  slot\u2082/U\n 50  (call core.svec %\u2084\u2088 %\u2084\u2089)\n-51  slot\u2081/U\n+51  slot\u2082/U\n 52  (call core.svec %\u2085\u2081)\n 53  SourceLocation::1:1\n 54  (call core.svec %\u2085\u2080 %\u2085\u2082 %\u2085\u2083)\n@@ -803,14 +803,14 @@ end\n 4   TestMod.Vector\n 5   slot\u2083/T\n 6   (call core.apply_type %\u2084 %\u2085)\n-7   (= slot\u2082/S (call core.TypeVar :S %\u2086))\n+7   (= slot\u2084/S (call core.TypeVar :S %\u2086))\n 8   slot\u2083/T\n-9   slot\u2082/S\n+9   slot\u2084/S\n 10  (call core.svec %\u2088 %\u2089)\n 11  (call core.svec :v)\n 12  (call core.svec)\n 13  (call core._structtype TestMod :X %\u2081\u2080 %\u2081\u2081 %\u2081\u2082 false 1)\n-14  (= slot\u2084/X %\u2081\u2083)\n+14  (= slot\u2082/X %\u2081\u2083)\n 15  (call core._setsuper! %\u2081\u2083 core.Any)\n 16  (call core.isdefinedglobal TestMod :X false)\n 17  (gotoifnot %\u2081\u2086 label\u2082\u2081)\n@@ -835,19 +835,19 @@ end\n 36  (= slot\u2081/iterstate (call core.getfield %\u2083\u2084 2))\n 37  slot\u2081/iterstate\n 38  (call top.indexed_iterate %\u2083\u2083 2 %\u2083\u2087)\n-39  (= slot\u2082/S (call core.getfield %\u2083\u2088 1))\n+39  (= slot\u2084/S (call core.getfield %\u2083\u2088 1))\n 40  TestMod.Vector\n-41  slot\u2082/S\n+41  slot\u2084/S\n 42  (call core.apply_type %\u2084\u2080 %\u2084\u2081)\n 43  (call core.svec %\u2084\u2082)\n 44  (call core._typebody! %\u2082\u2088 %\u2081\u2083 %\u2084\u2083)\n 45  (call core.declare_const TestMod :X %\u2084\u2084)\n 46  latestworld\n 47  slot\u2083/T\n-48  slot\u2082/S\n+48  slot\u2084/S\n 49  TestMod.X\n 50  slot\u2083/T\n-51  slot\u2082/S\n+51  slot\u2084/S\n 52  (call core.apply_type %\u2084\u2089 %\u2085\u2080 %\u2085\u2081)\n 53  (call core.apply_type core.Type %\u2085\u2082)\n 54  (call core.UnionAll %\u2084\u2088 %\u2085\u2083)\n@@ -874,11 +874,11 @@ end\n 62  TestMod.X\n 63  (call core.apply_type core.Type %\u2086\u2082)\n 64  TestMod.Vector\n-65  slot\u2082/S\n+65  slot\u2084/S\n 66  (call core.apply_type %\u2086\u2084 %\u2086\u2085)\n 67  (call core.svec %\u2086\u2083 %\u2086\u2086)\n 68  slot\u2083/T\n-69  slot\u2082/S\n+69  slot\u2084/S\n 70  (call core.svec %\u2086\u2088 %\u2086\u2089)\n 71  SourceLocation::1:1\n 72  (call core.svec %\u2086\u2087 %\u2087\u2080 %\u2087\u2081)\n@@ -960,7 +960,7 @@ end\n 47  SourceLocation::4:5\n 48  (call core.svec %\u2084\u2085 %\u2084\u2086 %\u2084\u2087)\n 49  --- code_info\n-    slots: [slot\u2081/#ctor-self#(!read) slot\u2082/f(!read)]\n+    slots: [slot\u2081/#ctor-self#(!read) slot\u2082/f(!read,maybe_undef)]\n     1   (captured_local 1)\n     2   (call core.isdefined %\u2081 :contents)\n     3   (gotoifnot %\u2082 label\u2085)\n@@ -1039,15 +1039,15 @@ end\n 1   (newvar slot\u2085/f)\n 2   (call core.declare_global TestMod :X false)\n 3   latestworld\n-4   (= slot\u2082/S (call core.TypeVar :S))\n-5   (= slot\u2083/T (call core.TypeVar :T))\n-6   slot\u2082/S\n-7   slot\u2083/T\n+4   (= slot\u2083/S (call core.TypeVar :S))\n+5   (= slot\u2084/T (call core.TypeVar :T))\n+6   slot\u2083/S\n+7   slot\u2084/T\n 8   (call core.svec %\u2086 %\u2087)\n 9   (call core.svec :x)\n 10  (call core.svec)\n 11  (call core._structtype TestMod :X %\u2088 %\u2089 %\u2081\u2080 false 1)\n-12  (= slot\u2084/X %\u2081\u2081)\n+12  (= slot\u2082/X %\u2081\u2081)\n 13  (call core._setsuper! %\u2081\u2081 core.Any)\n 14  (call core.isdefinedglobal TestMod :X false)\n 15  (gotoifnot %\u2081\u2084 label\u2081\u2089)\n@@ -1068,11 +1068,11 @@ end\n 30  (call top.getproperty %\u2082\u2089 :body)\n 31  (call top.getproperty %\u2083\u2080 :parameters)\n 32  (call top.indexed_iterate %\u2083\u2081 1)\n-33  (= slot\u2082/S (call core.getfield %\u2083\u2082 1))\n+33  (= slot\u2083/S (call core.getfield %\u2083\u2082 1))\n 34  (= slot\u2081/iterstate (call core.getfield %\u2083\u2082 2))\n 35  slot\u2081/iterstate\n 36  (call top.indexed_iterate %\u2083\u2081 2 %\u2083\u2085)\n-37  (= slot\u2083/T (call core.getfield %\u2083\u2086 1))\n+37  (= slot\u2084/T (call core.getfield %\u2083\u2086 1))\n 38  (call core.svec core.Any)\n 39  (call core._typebody! %\u2082\u2086 %\u2081\u2081 %\u2083\u2088)\n 40  (call core.declare_const TestMod :X %\u2083\u2089)\n@@ -1193,13 +1193,13 @@ end\n #---------------------\n 1   (call core.declare_global TestMod :X false)\n 2   latestworld\n-3   (= slot\u2081/T (call core.TypeVar :T))\n-4   slot\u2081/T\n+3   (= slot\u2082/T (call core.TypeVar :T))\n+4   slot\u2082/T\n 5   (call core.svec %\u2084)\n 6   (call core.svec :x :y)\n 7   (call core.svec)\n 8   (call core._structtype TestMod :X %\u2085 %\u2086 %\u2087 false 2)\n-9   (= slot\u2082/X %\u2088)\n+9   (= slot\u2081/X %\u2088)\n 10  (call core._setsuper! %\u2088 core.Any)\n 11  (call core.isdefinedglobal TestMod :X false)\n 12  (gotoifnot %\u2081\u2081 label\u2081\u2086)\n@@ -1219,8 +1219,8 @@ end\n 26  (call top.getproperty %\u2082\u2085 :body)\n 27  (call top.getproperty %\u2082\u2086 :parameters)\n 28  (call top.indexed_iterate %\u2082\u2087 1)\n-29  (= slot\u2081/T (call core.getfield %\u2082\u2088 1))\n-30  slot\u2081/T\n+29  (= slot\u2082/T (call core.getfield %\u2082\u2088 1))\n+30  slot\u2082/T\n 31  TestMod.A\n 32  (call core.svec %\u2083\u2080 %\u2083\u2081)\n 33  (call core._typebody! %\u2082\u2083 %\u2088 %\u2083\u2082)"
    }
  ]
}