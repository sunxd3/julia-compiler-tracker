{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60543",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60543/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60543/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60543/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60543",
  "id": 3778852288,
  "node_id": "PR_kwDOABkWpM67Z8l5",
  "number": 60543,
  "title": "Test: add broken/skip/context keywords to all `@test_*` macros",
  "user": {
    "login": "IanButterworth",
    "id": 1694067,
    "node_id": "MDQ6VXNlcjE2OTQwNjc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1694067?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/IanButterworth",
    "html_url": "https://github.com/IanButterworth",
    "followers_url": "https://api.github.com/users/IanButterworth/followers",
    "following_url": "https://api.github.com/users/IanButterworth/following{/other_user}",
    "gists_url": "https://api.github.com/users/IanButterworth/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/IanButterworth/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/IanButterworth/subscriptions",
    "organizations_url": "https://api.github.com/users/IanButterworth/orgs",
    "repos_url": "https://api.github.com/users/IanButterworth/repos",
    "events_url": "https://api.github.com/users/IanButterworth/events{/privacy}",
    "received_events_url": "https://api.github.com/users/IanButterworth/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 402147973,
      "node_id": "MDU6TGFiZWw0MDIxNDc5NzM=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/testsystem",
      "name": "testsystem",
      "color": "e99695",
      "default": false,
      "description": "The unit testing framework and Test stdlib"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 1,
  "created_at": "2026-01-04T05:33:36Z",
  "updated_at": "2026-01-07T18:55:48Z",
  "closed_at": "2026-01-07T18:55:46Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60543",
    "html_url": "https://github.com/JuliaLang/julia/pull/60543",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60543.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60543.patch",
    "merged_at": "2026-01-07T18:55:46Z"
  },
  "body": "Add support for broken=, skip=, and context= keyword arguments to additional test macros for consistency with `@test`.\r\n\r\n- `@test_throws`: now supports broken/skip/context keywords\r\n- `@test_warn`/`@test_nowarn`: now supports broken/skip keywords\r\n- `@test_logs`: now supports broken/skip keywords\r\n- `@test_deprecated`: now supports broken/skip keywords\r\n\r\nExtract common keyword parsing into extract_broken_skip_kws helper function to reduce code duplication.\r\n\r\nDeveloped with Claude",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60543/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 1,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60543/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "2b144a05e9d3b35cb08d13d0069988542de5569d",
      "filename": "NEWS.md",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c2717f92796bbbccc374d9566294fc500b9901df/NEWS.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c2717f92796bbbccc374d9566294fc500b9901df/NEWS.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/NEWS.md?ref=c2717f92796bbbccc374d9566294fc500b9901df",
      "patch": "@@ -67,6 +67,9 @@ Standard library changes\n   that provides additional information displayed on test failure. This is useful for\n   debugging which specific case failed in parameterized tests ([#60501]).\n \n+* `@test_throws`, `@test_warn`, `@test_nowarn`, `@test_logs`, and `@test_deprecated` now support\n+  `broken` and `skip` keyword arguments for consistency with `@test` ([#60543]).\n+\n #### InteractiveUtils\n \n #### Dates"
    },
    {
      "sha": "b774bc7d56aa0118aa512f66fecf6e965c2b1905",
      "filename": "stdlib/Test/src/Test.jl",
      "status": "modified",
      "additions": 291,
      "deletions": 130,
      "changes": 421,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c2717f92796bbbccc374d9566294fc500b9901df/stdlib%2FTest%2Fsrc%2FTest.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c2717f92796bbbccc374d9566294fc500b9901df/stdlib%2FTest%2Fsrc%2FTest.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FTest%2Fsrc%2FTest.jl?ref=c2717f92796bbbccc374d9566294fc500b9901df",
      "patch": "@@ -776,6 +776,39 @@ function get_test_result(ex, source)\n     result\n end\n \n+# Helper to extract broken= and skip= keyword arguments from macro calls.\n+# Returns (broken, skip) where each is either `nothing` or the value expression.\n+# If `other_valid` is provided, those keywords are also accepted and returned in\n+# the third element as a Dict.\n+function extract_broken_skip_kws(kws, macroname; other_valid=())\n+    broken = nothing\n+    skip = nothing\n+    others = Dict{Symbol,Any}()\n+    for kw in kws\n+        if !(kw isa Expr && kw.head === :(=))\n+            error(\"invalid $macroname call: expected keyword argument, got $kw\")\n+        end\n+        kw_name = kw.args[1]\n+        kw_val = kw.args[2]\n+        if kw_name === :broken\n+            broken !== nothing && error(\"invalid $macroname call: cannot set broken keyword multiple times\")\n+            broken = kw_val\n+        elseif kw_name === :skip\n+            skip !== nothing && error(\"invalid $macroname call: cannot set skip keyword multiple times\")\n+            skip = kw_val\n+        elseif kw_name in other_valid\n+            haskey(others, kw_name) && error(\"invalid $macroname call: cannot set $kw_name keyword multiple times\")\n+            others[kw_name] = kw_val\n+        else\n+            error(\"invalid $macroname call: unknown keyword argument $kw_name\")\n+        end\n+    end\n+    if broken !== nothing && skip !== nothing\n+        error(\"invalid $macroname call: cannot set both skip and broken keywords\")\n+    end\n+    return broken, skip, others\n+end\n+\n # An internal function, called by the code generated by the @test\n # macro to actually perform the evaluation and manage the result.\n function do_test(result::ExecutionResult, @nospecialize(orig_expr), context=nothing)\n@@ -830,6 +863,8 @@ end\n \"\"\"\n     @test_throws exception expr\n     @test_throws extype pattern expr\n+    @test_throws exception expr broken=cond\n+    @test_throws exception expr skip=cond\n     @test_throws exception expr context=ctx\n \n Tests that the expression `expr` throws `exception`.\n@@ -845,8 +880,16 @@ a message pattern are tested. The `extype` must be a type, and `pattern` may be\n a string, regular expression, or list of strings occurring in the displayed error message,\n a matching function, or a value.\n \n-The optional `context=ctx` keyword provides additional context that will be displayed\n-if the test fails (wrong exception type, wrong message, or no exception thrown).\n+# Keyword Arguments\n+\n+* `broken=cond`: if `cond==true`, indicates a test that should pass but currently\n+  consistently fails. The test will be recorded as `Broken` if it fails (no exception\n+  or wrong exception), or as `Error` if it unexpectedly passes.\n+* `skip=cond`: if `cond==true`, marks a test that should not be executed but should\n+  be included in test summary reporting as `Broken`. This can be useful for tests\n+  that intermittently fail, or tests of not-yet-implemented functionality.\n+* `context=ctx`: provides additional context that will be displayed if the test fails\n+  (wrong exception type, wrong message, or no exception thrown).\n \n !!! compat \"Julia 1.8\"\n     The ability to specify anything other than a type or a value as `exception` requires Julia v1.8 or later.\n@@ -857,6 +900,9 @@ if the test fails (wrong exception type, wrong message, or no exception thrown).\n !!! compat \"Julia 1.14\"\n     The `context` keyword argument requires at least Julia 1.14.\n \n+!!! compat \"Julia 1.14\"\n+    The `broken` and `skip` keyword arguments require at least Julia 1.14.\n+\n # Examples\n ```jldoctest\n julia> @test_throws BoundsError [1, 2, 3][4]\n@@ -885,41 +931,72 @@ In the third example, instead of matching a single string it could alternatively\n In the final example, both the exception type (`ErrorException`) and message pattern (`\"error foo\"`) are tested.\n \"\"\"\n macro test_throws(args...)\n-    # Parse arguments: expect (extype, ex) or (extype, pattern, ex), with optional context=... at end\n+    # Parse arguments: expect (extype, ex) or (extype, pattern, ex), with optional keyword args at end\n     nargs = length(args)\n     nargs >= 2 || error(\"@test_throws requires at least 2 arguments\")\n \n-    # Check for context=... keyword at end\n-    ctx = nothing\n-    if nargs >= 3 && args[end] isa Expr && args[end].head === :(=) && args[end].args[1] === :context\n-        ctx = esc(args[end].args[2])\n+    # Collect keyword arguments from the end (they look like positional `kw=val` expressions)\n+    kws = Any[]\n+    while nargs >= 3 && args[end] isa Expr && args[end].head === :(=) && args[end].args[1] in (:broken, :skip, :context)\n+        pushfirst!(kws, args[end])\n         args = args[1:end-1]\n         nargs -= 1\n     end\n \n+    broken, skip, others = extract_broken_skip_kws(kws, \"@test_throws\"; other_valid=(:context,))\n+    ctx = get(others, :context, nothing)\n+    ctx = ctx !== nothing ? esc(ctx) : nothing\n+    broken = broken !== nothing ? esc(broken) : nothing\n+    skip = skip !== nothing ? esc(skip) : nothing\n+\n     if nargs == 2\n         extype, ex = args\n         pattern = nothing\n     elseif nargs == 3\n         extype, pattern, ex = args\n         pattern = esc(pattern)\n     else\n-        error(\"@test_throws expects 2 or 3 positional arguments (plus optional context=...)\")\n+        error(\"@test_throws expects 2 or 3 positional arguments (plus optional keyword arguments)\")\n     end\n \n     orig_ex = Expr(:inert, ex)\n-    ex = Expr(:block, __source__, esc(ex))\n-    result = quote\n+    testex = Expr(:block, __source__, esc(ex))\n+    source = QuoteNode(__source__)\n+\n+    # Build the try-catch expression\n+    trycatch = quote\n         try\n-            Returned($ex, nothing, $(QuoteNode(__source__)))\n+            Returned($testex, nothing, $source)\n         catch _e\n             if $(esc(extype)) != InterruptException && _e isa InterruptException\n                 rethrow()\n             end\n-            Threw(_e, Base.current_exceptions(), $(QuoteNode(__source__)))\n+            Threw(_e, Base.current_exceptions(), $source)\n+        end\n+    end\n+\n+    if skip !== nothing\n+        result = quote\n+            if $skip\n+                record(get_testset(), Broken(:skipped, $orig_ex))\n+            elseif $(broken !== nothing && broken)\n+                do_broken_test_throws($trycatch, $orig_ex, $(esc(extype)), $pattern, $ctx)\n+            else\n+                do_test_throws($trycatch, $orig_ex, $(esc(extype)), $pattern, $ctx)\n+            end\n+        end\n+    elseif broken !== nothing\n+        result = quote\n+            if $broken\n+                do_broken_test_throws($trycatch, $orig_ex, $(esc(extype)), $pattern, $ctx)\n+            else\n+                do_test_throws($trycatch, $orig_ex, $(esc(extype)), $pattern, $ctx)\n+            end\n         end\n+    else\n+        result = :(do_test_throws($trycatch, $orig_ex, $(esc(extype)), $pattern, $ctx))\n     end\n-    return :(do_test_throws($result, $orig_ex, $(esc(extype)), $pattern, $ctx))\n+    return result\n end\n \n const MACROEXPAND_LIKE = Symbol.((\"@macroexpand\", \"@macroexpand1\", \"macroexpand\"))\n@@ -937,109 +1014,155 @@ function isequalexception(a::UndefVarError, b::UndefVarError)\n     return isequal(a.var, b.var) && isequal(a.scope, b.scope)\n end\n \n-# An internal function, called by the code generated by @test_throws\n-# to evaluate and catch the thrown exception - if it exists\n-function do_test_throws(result::ExecutionResult, @nospecialize(orig_expr), extype, pattern=nothing, context=nothing)\n-    context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)\n-    if isa(result, Threw)\n-        # Check that the right type of exception was thrown\n-        success = false\n-        message_only = false\n-        exc = result.exception\n-\n-        # Handle three-argument form (type + pattern)\n-        if pattern !== nothing\n-            # In 3-arg form, first argument must be a type\n-            if !isa(extype, Type)\n-                testres = Fail(:test_throws_wrong, orig_expr, extype, exc, context_str, result.source, false, \"First argument must be an exception type in three-argument form\")\n-                record(get_testset(), testres)\n-                return\n-            end\n+# Helper to format extype for display (handles 3-arg form)\n+function format_extype_display(extype, pattern)\n+    if pattern !== nothing\n+        pattern_str = isa(pattern, AbstractString) ? repr(pattern) :\n+                     isa(pattern, Function) ? \"< match function >\" :\n+                     string(pattern)\n+        return string(extype) * \" with pattern \" * pattern_str\n+    end\n+    return extype\n+end\n \n-            # Format combined expected value for display\n-            pattern_str = isa(pattern, AbstractString) ? repr(pattern) :\n-                         isa(pattern, Function) ? \"< match function >\" :\n-                         string(pattern)\n-            combined_expected = string(extype) * \" with pattern \" * pattern_str\n-\n-            # Check both type and pattern\n-            type_success = isa(exc, extype)\n-            if type_success\n-                exc_msg = sprint(showerror, exc)\n-                pattern_success = contains_warn(exc_msg, pattern)\n-                success = pattern_success\n-            else\n-                success = false\n-            end\n-            extype = combined_expected  # Use combined format for all results\n+# Check if an exception matches the expected type/pattern.\n+# Returns (success::Bool, message_only::Bool, exc_display, extype_display, error_msg::Union{String,Nothing})\n+# where error_msg is set if there's an error in the test specification itself.\n+function check_exception_match(result::ExecutionResult, @nospecialize(orig_expr), extype, pattern)\n+    if !isa(result, Threw)\n+        # No exception was thrown\n+        extype_display = format_extype_display(extype, pattern)\n+        return false, false, nothing, extype_display, nothing\n+    end\n+\n+    exc = result.exception\n+    message_only = false\n+\n+    # Handle three-argument form (type + pattern)\n+    if pattern !== nothing\n+        # In 3-arg form, first argument must be a type\n+        if !isa(extype, Type)\n+            return false, false, exc, extype, \"First argument must be an exception type in three-argument form\"\n+        end\n+\n+        # Format combined expected value for display\n+        extype_display = format_extype_display(extype, pattern)\n+\n+        # Check both type and pattern\n+        type_success = isa(exc, extype)\n+        if type_success\n+            exc_msg = sprint(showerror, exc)\n+            success = contains_warn(exc_msg, pattern)\n         else\n-            # Original two-argument form logic\n-            # NB: Throwing LoadError from macroexpands is deprecated, but in order to limit\n-            # the breakage in package tests we add extra logic here.\n-            from_macroexpand =\n-                orig_expr isa Expr &&\n-                orig_expr.head in (:call, :macrocall) &&\n-                orig_expr.args[1] in MACROEXPAND_LIKE\n-            if isa(extype, Type)\n-                success =\n-                    if from_macroexpand && extype == LoadError && exc isa Exception\n-                        Base.depwarn(\"macroexpand no longer throws a LoadError so `@test_throws LoadError ...` is deprecated and passed without checking the error type!\", :do_test_throws)\n-                        true\n-                    elseif extype == ErrorException && isa(exc, FieldError)\n-                        Base.depwarn(lazy\"Using ErrorException to test field access is deprecated; use FieldError instead.\", :do_test_throws)\n-                        true\n-                    else\n-                        isa(exc, extype)\n-                    end\n-            elseif isa(extype, Exception) || !isa(exc, Exception)\n-                if extype isa LoadError && !(exc isa LoadError) && typeof(extype.error) == typeof(exc)\n-                    extype = extype.error # deprecated\n-                end\n-                # Support `UndefVarError(:x)` meaning `UndefVarError(:x, scope)` for any `scope`.\n-                # Retains the behaviour from pre-v1.11 when `UndefVarError` didn't have `scope`.\n-                if isa(extype, UndefVarError) && !isdefined(extype, :scope)\n-                    success = exc isa UndefVarError && exc.var == extype.var\n-                else isa(exc, typeof(extype))\n-                    success = isequalexception(exc, extype)\n-                end\n+            success = false\n+        end\n+        return success, false, exc, extype_display, nothing\n+    end\n+\n+    # Two-argument form logic\n+    # NB: Throwing LoadError from macroexpands is deprecated, but in order to limit\n+    # the breakage in package tests we add extra logic here.\n+    # Note: orig_expr may be wrapped in Expr(:inert, ...), so we need to unwrap it\n+    unwrapped_expr = orig_expr isa Expr && orig_expr.head === :inert && length(orig_expr.args) == 1 ? orig_expr.args[1] : orig_expr\n+    from_macroexpand =\n+        unwrapped_expr isa Expr &&\n+        unwrapped_expr.head in (:call, :macrocall) &&\n+        (unwrapped_expr.args[1] in MACROEXPAND_LIKE ||\n+         (unwrapped_expr.args[1] isa GlobalRef && unwrapped_expr.args[1].name in MACROEXPAND_LIKE))\n+\n+    extype_display = extype\n+\n+    if isa(extype, Type)\n+        success =\n+            if from_macroexpand && extype == LoadError && exc isa Exception\n+                Base.depwarn(\"macroexpand no longer throws a LoadError so `@test_throws LoadError ...` is deprecated and passed without checking the error type!\", :do_test_throws)\n+                true\n+            elseif extype == ErrorException && isa(exc, FieldError)\n+                Base.depwarn(lazy\"Using ErrorException to test field access is deprecated; use FieldError instead.\", :do_test_throws)\n+                true\n             else\n-                message_only = true\n-                exc = sprint(showerror, exc)\n-                success = contains_warn(exc, extype)\n-                exc = repr(exc)\n-                if isa(extype, AbstractString)\n-                    extype = repr(extype)\n-                elseif isa(extype, Function)\n-                    extype = \"< match function >\"\n-                end\n+                isa(exc, extype)\n             end\n+    elseif isa(extype, Exception) || !isa(exc, Exception)\n+        # Decorated LoadErrors are unwrapped if the actual exception matches the inner exception\n+        extype_for_match = extype\n+        if extype isa LoadError && !(exc isa LoadError) && typeof(extype.error) == typeof(exc)\n+            extype_for_match = extype.error # deprecated: use inner exception for matching\n+            extype_display = extype.error\n         end\n-        if success\n-            testres = Pass(:test_throws, orig_expr, extype, exc, result.source, message_only)\n+        # Support `UndefVarError(:x)` meaning `UndefVarError(:x, scope)` for any `scope`.\n+        # Retains the behaviour from pre-v1.11 when `UndefVarError` didn't have `scope`.\n+        if isa(extype_for_match, UndefVarError) && !isdefined(extype_for_match, :scope)\n+            success = exc isa UndefVarError && exc.var == extype_for_match.var\n+        elseif isa(exc, typeof(extype_for_match))\n+            success = isequalexception(exc, extype_for_match)\n         else\n-            excs = result.current_exceptions\n-            bt = scrub_exc_stack(excs, nothing, extract_file(result.source))\n-            bt_str = try # try the latest world for this, since we might have eval'd new code for show\n-                Base.invokelatest(sprint, Base.show_exception_stack, bt; context=stdout)\n-            catch ex\n-                \"#=ERROR showing exception stack=# \" *\n-                    try\n-                        sprint(Base.showerror, ex, catch_backtrace(); context=stdout)\n-                    catch\n-                        \"of type \" * string(typeof(ex))\n-                    end\n-            end\n-            testres = Fail(:test_throws_wrong, orig_expr, extype, exc, context_str, result.source, message_only, bt_str)\n+            success = false\n         end\n     else\n-        # Handle no exception case - need to format extype properly for 3-arg form\n-        if pattern !== nothing\n-            pattern_str = isa(pattern, AbstractString) ? repr(pattern) :\n-                         isa(pattern, Function) ? \"< match function >\" :\n-                         string(pattern)\n-            extype = string(extype) * \" with pattern \" * pattern_str\n+        message_only = true\n+        exc_msg = sprint(showerror, exc)\n+        success = contains_warn(exc_msg, extype)\n+        exc = repr(exc_msg)\n+        if isa(extype, AbstractString)\n+            extype_display = repr(extype)\n+        elseif isa(extype, Function)\n+            extype_display = \"< match function >\"\n         end\n-        testres = Fail(:test_throws_nothing, orig_expr, extype, nothing, context_str, result.source, false)\n+    end\n+\n+    return success, message_only, exc, extype_display, nothing\n+end\n+\n+# An internal function, called by the code generated by @test_throws\n+# to evaluate and catch the thrown exception - if it exists\n+function do_test_throws(result::ExecutionResult, @nospecialize(orig_expr), extype, pattern=nothing, context=nothing)\n+    context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)\n+\n+    success, message_only, exc, extype_display, error_msg = check_exception_match(result, orig_expr, extype, pattern)\n+\n+    # Handle specification errors\n+    if error_msg !== nothing\n+        testres = Fail(:test_throws_wrong, orig_expr, extype, exc, context_str, result.source, false, error_msg)\n+        record(get_testset(), testres)\n+        return\n+    end\n+\n+    if success\n+        testres = Pass(:test_throws, orig_expr, extype_display, exc, result.source, message_only)\n+    elseif isa(result, Threw)\n+        excs = result.current_exceptions\n+        bt = scrub_exc_stack(excs, nothing, extract_file(result.source))\n+        bt_str = try # try the latest world for this, since we might have eval'd new code for show\n+            Base.invokelatest(sprint, Base.show_exception_stack, bt; context=stdout)\n+        catch ex\n+            \"#=ERROR showing exception stack=# \" *\n+                try\n+                    sprint(Base.showerror, ex, catch_backtrace(); context=stdout)\n+                catch\n+                    \"of type \" * string(typeof(ex))\n+                end\n+        end\n+        testres = Fail(:test_throws_wrong, orig_expr, extype_display, exc, context_str, result.source, message_only, bt_str)\n+    else\n+        testres = Fail(:test_throws_nothing, orig_expr, extype_display, nothing, context_str, result.source, false)\n+    end\n+    record(get_testset(), testres)\n+end\n+\n+# An internal function, called by the code generated by @test_throws with broken=true\n+# to evaluate and catch the thrown exception - if it exists\n+function do_broken_test_throws(result::ExecutionResult, @nospecialize(orig_expr), extype, pattern=nothing, context=nothing)\n+    context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)\n+\n+    success, _, _, extype_display, _ = check_exception_match(result, orig_expr, extype, pattern)\n+\n+    if success\n+        # Test passed when it was expected to be broken - this is an error (unexpected pass)\n+        testres = Error(:test_unbroken, orig_expr, extype_display, nothing, result.source, context_str)\n+    else\n+        # Test failed as expected for a broken test\n+        testres = Broken(:test_throws, orig_expr)\n     end\n     record(get_testset(), testres)\n end\n@@ -1056,6 +1179,8 @@ contains_warn(output, S::Union{AbstractArray,Tuple}) = all(s -> contains_warn(ou\n \n \"\"\"\n     @test_warn msg expr\n+    @test_warn msg expr broken=cond\n+    @test_warn msg expr skip=cond\n \n Test whether evaluating `expr` results in [`stderr`](@ref) output that contains\n the `msg` string or matches the `msg` regular expression.  If `msg` is\n@@ -1067,50 +1192,86 @@ See also [`@test_nowarn`](@ref) to check for the absence of error output.\n \n Note: Warnings generated by `@warn` cannot be tested with this macro. Use\n [`@test_logs`](@ref) instead.\n+\n+# Keyword Arguments\n+\n+* `broken=cond`: if `cond==true`, indicates a test that should pass but currently\n+  consistently fails.\n+* `skip=cond`: if `cond==true`, marks a test that should not be executed but should\n+  be included in test summary reporting as `Broken`.\n+\n+!!! compat \"Julia 1.14\"\n+    The `broken` and `skip` keyword arguments require at least Julia 1.14.\n \"\"\"\n-macro test_warn(msg, expr)\n-    test_warn_expr(expr, msg)\n+macro test_warn(msg, expr, kws...)\n+    broken, skip, _ = extract_broken_skip_kws(kws, \"@test_warn\")\n+    test_warn_expr(expr, msg, __source__, broken, skip, false)\n end\n \n \"\"\"\n     @test_nowarn expr\n+    @test_nowarn expr broken=cond\n+    @test_nowarn expr skip=cond\n \n Test whether evaluating `expr` results in empty [`stderr`](@ref) output\n (no warnings or other messages).  Returns the result of evaluating `expr`.\n \n Note: The absence of warnings generated by `@warn` cannot be tested\n with this macro. Use [`@test_logs`](@ref) instead.\n+\n+# Keyword Arguments\n+\n+* `broken=cond`: if `cond==true`, indicates a test that should pass but currently\n+  consistently fails.\n+* `skip=cond`: if `cond==true`, marks a test that should not be executed but should\n+  be included in test summary reporting as `Broken`.\n+\n+!!! compat \"Julia 1.14\"\n+    The `broken` and `skip` keyword arguments require at least Julia 1.14.\n \"\"\"\n-macro test_nowarn(expr)\n+macro test_nowarn(expr, kws...)\n+    broken, skip, _ = extract_broken_skip_kws(kws, \"@test_nowarn\")\n     # allow printing the content of `stderr` again to `stderr` here while suppressing it\n     # for `@test_warn`. If that shouldn't be used, this could just be `test_warn_expr(expr, #=msg=#isempty)`\n     test_warn_expr(expr, function (s)\n         print(stderr, s) # this is helpful for debugging\n         isempty(s)\n-    end)\n+    end, __source__, broken, skip, true)\n end\n \n-function test_warn_expr(@nospecialize(expr), @nospecialize(msg))\n-    return :(let fname = tempname()\n-        try\n-            f = open(fname, \"w\")\n-            stdold = stderr\n-            redirect_stderr(f)\n-            ret = try\n-                # We deliberately don't use the thunk versions of open/redirect\n-                # to ensure that adding the macro does not change the toplevel-ness\n-                # of the resulting expression.\n-                $(esc(expr))\n-            finally\n-                redirect_stderr(stdold)\n-                close(f)\n+function test_warn_expr(@nospecialize(expr), @nospecialize(msg), source, broken, skip, print_stderr::Bool)\n+    orig_expr = QuoteNode(expr)\n+    return quote\n+        if $(skip !== nothing && esc(skip))\n+            record(get_testset(), Broken(:skipped, $orig_expr))\n+            nothing\n+        else\n+            let fname = tempname()\n+                try\n+                    f = open(fname, \"w\")\n+                    stdold = stderr\n+                    redirect_stderr(f)\n+                    ret = try\n+                        # We deliberately don't use the thunk versions of open/redirect\n+                        # to ensure that adding the macro does not change the toplevel-ness\n+                        # of the resulting expression.\n+                        $(esc(expr))\n+                    finally\n+                        redirect_stderr(stdold)\n+                        close(f)\n+                    end\n+                    if $(broken !== nothing && esc(broken))\n+                        @test contains_warn(read(fname, String), $(esc(msg))) broken=true\n+                    else\n+                        @test contains_warn(read(fname, String), $(esc(msg)))\n+                    end\n+                    ret\n+                finally\n+                    rm(fname, force=true)\n+                end\n             end\n-            @test contains_warn(read(fname, String), $(esc(msg)))\n-            ret\n-        finally\n-            rm(fname, force=true)\n         end\n-    end)\n+    end\n end\n \n #-----------------------------------------------------------------------"
    },
    {
      "sha": "ab044184e0bac03c60aaf414cc424eaeb826562b",
      "filename": "stdlib/Test/src/logging.jl",
      "status": "modified",
      "additions": 132,
      "deletions": 29,
      "changes": 161,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c2717f92796bbbccc374d9566294fc500b9901df/stdlib%2FTest%2Fsrc%2Flogging.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c2717f92796bbbccc374d9566294fc500b9901df/stdlib%2FTest%2Fsrc%2Flogging.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FTest%2Fsrc%2Flogging.jl?ref=c2717f92796bbbccc374d9566294fc500b9901df",
      "patch": "@@ -233,39 +233,72 @@ patterns and set the `min_level` accordingly:\n \n If you want to test the absence of warnings (or error messages) in\n [`stderr`](@ref) which are not generated by `@warn`, see [`@test_nowarn`](@ref).\n+\n+# Keyword Arguments\n+\n+* `broken=cond`: if `cond==true`, indicates a test that should pass but currently\n+  consistently fails.\n+* `skip=cond`: if `cond==true`, marks a test that should not be executed but should\n+  be included in test summary reporting as `Broken`.\n+\n+!!! compat \"Julia 1.14\"\n+    The `broken` and `skip` keyword arguments require at least Julia 1.14.\n \"\"\"\n macro test_logs(exs...)\n     length(exs) >= 1 || throw(ArgumentError(\"\"\"`@test_logs` needs at least one arguments.\n                                Usage: `@test_logs [msgs...] expr_to_run`\"\"\"))\n     patterns = Any[]\n     kwargs = Any[]\n+    kws = Any[]\n     for e in exs[1:end-1]\n         if e isa Expr && e.head === :(=)\n-            push!(kwargs, esc(Expr(:kw, e.args...)))\n+            if e.args[1] in (:broken, :skip)\n+                push!(kws, e)\n+            else\n+                push!(kwargs, esc(Expr(:kw, e.args...)))\n+            end\n         else\n             push!(patterns, esc(e))\n         end\n     end\n+    broken, skip, _ = extract_broken_skip_kws(kws, \"@test_logs\")\n     expression = exs[end]\n     orig_expr = QuoteNode(expression)\n     sourceloc = QuoteNode(__source__)\n     Base.remove_linenums!(quote\n-        let testres=nothing, value=nothing\n-            try\n-                didmatch,logs,value = match_logs($(patterns...); $(kwargs...)) do\n-                    $(esc(expression))\n-                end\n-                if didmatch\n-                    testres = Pass(:test, $orig_expr, nothing, value, $sourceloc)\n-                else\n-                    testres = LogTestFailure($orig_expr, $sourceloc,\n-                                             $(QuoteNode(exs[1:end-1])), logs)\n+        if $(skip !== nothing && esc(skip))\n+            Test.record(Test.get_testset(), Broken(:skipped, $orig_expr))\n+            nothing\n+        else\n+            let testres=nothing, value=nothing\n+                try\n+                    didmatch,logs,value = match_logs($(patterns...); $(kwargs...)) do\n+                        $(esc(expression))\n+                    end\n+                    if $(broken !== nothing && esc(broken))\n+                        if didmatch\n+                            testres = Error(:test_unbroken, $orig_expr, didmatch, nothing, $sourceloc)\n+                        else\n+                            testres = Broken(:test, $orig_expr)\n+                        end\n+                    else\n+                        if didmatch\n+                            testres = Pass(:test, $orig_expr, nothing, value, $sourceloc)\n+                        else\n+                            testres = LogTestFailure($orig_expr, $sourceloc,\n+                                                     $(QuoteNode(exs[1:end-1])), logs)\n+                        end\n+                    end\n+                catch e\n+                    if $(broken !== nothing && esc(broken))\n+                        testres = Broken(:test, $orig_expr)\n+                    else\n+                        testres = Error(:test_error, $orig_expr, e, Base.current_exceptions(), $sourceloc)\n+                    end\n                 end\n-            catch e\n-                testres = Error(:test_error, $orig_expr, e, Base.current_exceptions(), $sourceloc)\n+                Test.record(Test.get_testset(), testres)\n+                value\n             end\n-            Test.record(Test.get_testset(), testres)\n-            value\n         end\n     end)\n end\n@@ -307,6 +340,8 @@ end\n \n \"\"\"\n     @test_deprecated [pattern] expression\n+    @test_deprecated [pattern] expression broken=cond\n+    @test_deprecated [pattern] expression skip=cond\n \n When `--depwarn=yes`, test that `expression` emits a deprecation warning and\n return the value of `expression`.  The log message string will be matched\n@@ -315,6 +350,16 @@ against `pattern` which defaults to `r\"deprecated\"i`.\n When `--depwarn=no`, simply return the result of executing `expression`.  When\n `--depwarn=error`, check that an ErrorException is thrown.\n \n+# Keyword Arguments\n+\n+* `broken=cond`: if `cond==true`, indicates a test that should pass but currently\n+  consistently fails.\n+* `skip=cond`: if `cond==true`, marks a test that should not be executed but should\n+  be included in test summary reporting as `Broken`.\n+\n+!!! compat \"Julia 1.14\"\n+    The `broken` and `skip` keyword arguments require at least Julia 1.14.\n+\n # Examples\n \n ```\n@@ -326,25 +371,83 @@ When `--depwarn=no`, simply return the result of executing `expression`.  When\n ```\n \"\"\"\n macro test_deprecated(exs...)\n-    1 <= length(exs) <= 2 || throw(ArgumentError(\"\"\"`@test_deprecated` expects one or two arguments.\n-                               Usage: `@test_deprecated [pattern] expr_to_run`\"\"\"))\n-    pattern = length(exs) == 1 ? r\"deprecated\"i : esc(exs[1])\n-    expression = esc(exs[end])\n+    # Parse arguments: [pattern] expression [broken=...] [skip=...]\n+    length(exs) >= 1 || throw(ArgumentError(\"\"\"`@test_deprecated` expects at least one argument.\n+                               Usage: `@test_deprecated [pattern] expr_to_run [broken=cond] [skip=cond]`\"\"\"))\n+    pattern = r\"deprecated\"i\n+    expression = nothing\n+    kws = Any[]\n+\n+    # Helper to check if an expression is a string macro (like r\"...\" or s\"...\")\n+    is_string_macro(e) = e isa Expr && e.head === :macrocall &&\n+                         length(e.args) >= 1 && e.args[1] isa Symbol &&\n+                         endswith(String(e.args[1]), \"_str\")\n+\n+    for (i, e) in enumerate(exs)\n+        if e isa Expr && e.head === :(=)\n+            if e.args[1] in (:broken, :skip)\n+                push!(kws, e)\n+            else\n+                # This is the expression (like `f(x=1)`)\n+                expression !== nothing && throw(ArgumentError(\"\"\"`@test_deprecated` expects at most one expression.\n+                               Usage: `@test_deprecated [pattern] expr_to_run [broken=cond] [skip=cond]`\"\"\"))\n+                expression = e\n+            end\n+        elseif e isa Expr && e.head === :call\n+            # This is the expression (function call)\n+            expression !== nothing && throw(ArgumentError(\"\"\"`@test_deprecated` expects at most one expression.\n+                               Usage: `@test_deprecated [pattern] expr_to_run [broken=cond] [skip=cond]`\"\"\"))\n+            expression = e\n+        elseif e isa Expr && e.head === :macrocall && !is_string_macro(e)\n+            # This is the expression (macro call, but not a string macro like r\"...\")\n+            expression !== nothing && throw(ArgumentError(\"\"\"`@test_deprecated` expects at most one expression.\n+                               Usage: `@test_deprecated [pattern] expr_to_run [broken=cond] [skip=cond]`\"\"\"))\n+            expression = e\n+        elseif i == 1 && (e isa Union{Regex, String, Symbol} || is_string_macro(e) ||\n+                         (e isa Expr && e.head \u2209 (:call, :macrocall)))\n+            # First non-keyword argument that's a Regex, String, Symbol (variable), string macro,\n+            # or non-call expression is the pattern\n+            pattern = e\n+        else\n+            # Assume it's the expression\n+            expression !== nothing && throw(ArgumentError(\"\"\"`@test_deprecated` expects at most one expression.\n+                               Usage: `@test_deprecated [pattern] expr_to_run [broken=cond] [skip=cond]`\"\"\"))\n+            expression = e\n+        end\n+    end\n+\n+    expression === nothing && throw(ArgumentError(\"\"\"`@test_deprecated` needs an expression to run.\n+                               Usage: `@test_deprecated [pattern] expr_to_run [broken=cond] [skip=cond]`\"\"\"))\n+\n+    broken, skip, _ = extract_broken_skip_kws(kws, \"@test_deprecated\")\n+\n+    pattern_esc = esc(pattern)\n+    expression_esc = esc(expression)\n+    broken_esc = broken !== nothing ? esc(broken) : false\n+    skip_esc = skip !== nothing ? esc(skip) : false\n+\n     res = quote\n-        dw = Base.JLOptions().depwarn\n-        if dw == 2\n-            # TODO: Remove --depwarn=error if possible and replace with a more\n-            # flexible mechanism so we don't have to do this.\n-            @test_throws ErrorException $expression\n-        elseif dw == 1\n-            @test_logs (:warn, $pattern, Ignored(), :depwarn) match_mode=:any $expression\n+        if $skip_esc\n+            Test.record(Test.get_testset(), Broken(:skipped, $(QuoteNode(expression))))\n+            nothing\n         else\n-            $expression\n+            dw = Base.JLOptions().depwarn\n+            if dw == 2\n+                # TODO: Remove --depwarn=error if possible and replace with a more\n+                # flexible mechanism so we don't have to do this.\n+                @test_throws ErrorException $expression_esc broken=$broken_esc\n+            elseif dw == 1\n+                @test_logs (:warn, $pattern_esc, Ignored(), :depwarn) match_mode=:any broken=$broken_esc $expression_esc\n+            else\n+                $expression_esc\n+            end\n         end\n     end\n     # Propagate source code location of @test_logs to @test macro\n     # FIXME: Use rewrite_sourceloc!() for this - see #22623\n-    res.args[4].args[2].args[2].args[2] = __source__\n-    res.args[4].args[3].args[2].args[2].args[2] = __source__\n+    # Structure: res.args[2] = outer if, .args[3] = else block, .args[4] = inner if\n+    # Inner if: .args[2] = @test_throws block, .args[3] = elseif with @test_logs\n+    res.args[2].args[3].args[4].args[2].args[2].args[2] = __source__\n+    res.args[2].args[3].args[4].args[3].args[2].args[2].args[2] = __source__\n     res\n end"
    },
    {
      "sha": "2daf9e67b44b92bc4caf3637926b4c2eaf1b5850",
      "filename": "stdlib/Test/test/runtests.jl",
      "status": "modified",
      "additions": 180,
      "deletions": 0,
      "changes": 180,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c2717f92796bbbccc374d9566294fc500b9901df/stdlib%2FTest%2Ftest%2Fruntests.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c2717f92796bbbccc374d9566294fc500b9901df/stdlib%2FTest%2Ftest%2Fruntests.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FTest%2Ftest%2Fruntests.jl?ref=c2717f92796bbbccc374d9566294fc500b9901df",
      "patch": "@@ -133,6 +133,116 @@ end\n # Test printing of Fail results\n include(\"nothrow_testset.jl\")\n \n+# Test @test_throws with broken/skip keywords\n+@testset \"@test_throws broken keyword\" begin\n+    # broken=false should behave normally\n+    @test_throws ErrorException error(\"test\") broken=false\n+\n+    # broken=true with no exception should record as Broken\n+    let results = @testset NoThrowTestSet begin\n+            @test_throws ErrorException 1+1 broken=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+        @test results[1].test_type === :test_throws\n+    end\n+\n+    # broken=true with wrong exception type should record as Broken\n+    let results = @testset NoThrowTestSet begin\n+            @test_throws BoundsError error(\"wrong type\") broken=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+    end\n+\n+    # broken=true with correct exception should record as Error (unexpected pass)\n+    let results = @testset NoThrowTestSet begin\n+            @test_throws ErrorException error(\"test\") broken=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Error\n+        @test results[1].test_type === :test_unbroken\n+    end\n+end\n+\n+@testset \"@test_throws skip keyword\" begin\n+    # skip=true should record Broken(:skipped) and not execute\n+    let results = @testset NoThrowTestSet begin\n+            @test_throws ErrorException error(\"should not run\") skip=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+        @test results[1].test_type === :skipped\n+    end\n+\n+    # skip=false should behave normally\n+    @test_throws ErrorException error(\"test\") skip=false\n+end\n+\n+@testset \"@test_throws context keyword\" begin\n+    # context should be included in failure output\n+    let fails = @testset NoThrowTestSet begin\n+            @test_throws ErrorException 1+1 context=\"extra info\"\n+        end\n+        @test length(fails) == 1\n+        @test fails[1] isa Test.Fail\n+        @test fails[1].context == \"\\\"extra info\\\"\"\n+    end\n+end\n+\n+@testset \"@test_warn/@test_nowarn broken/skip keywords\" begin\n+    # @test_warn with broken=true when test fails (no warning) should be Broken\n+    let results = @testset NoThrowTestSet begin\n+            @test_warn \"expected warning\" 1+1 broken=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+    end\n+\n+    # @test_warn with broken=true when test passes should be Error (unexpected pass)\n+    let results = @testset NoThrowTestSet begin\n+            @test_warn \"foo\" (println(stderr, \"foo\"); 1) broken=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Error\n+        @test results[1].test_type === :test_unbroken\n+    end\n+\n+    # @test_nowarn with broken=true when test fails (has warning) should be Broken\n+    let results = @testset NoThrowTestSet begin\n+            @test_nowarn (println(stderr, \"oops\"); 1) broken=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+    end\n+\n+    # @test_nowarn with broken=true when test passes should be Error (unexpected pass)\n+    let results = @testset NoThrowTestSet begin\n+            @test_nowarn 1+1 broken=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Error\n+        @test results[1].test_type === :test_unbroken\n+    end\n+\n+    # skip=true should record Broken(:skipped) and not execute\n+    let results = @testset NoThrowTestSet begin\n+            @test_warn \"foo\" error(\"should not run\") skip=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+        @test results[1].test_type === :skipped\n+    end\n+\n+    let results = @testset NoThrowTestSet begin\n+            @test_nowarn error(\"should not run\") skip=true\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+        @test results[1].test_type === :skipped\n+    end\n+end\n+\n let fails = @testset NoThrowTestSet begin\n         # 1 - Fail - wrong exception\n         @test_throws OverflowError error()\n@@ -1188,6 +1298,51 @@ erronce() = @error \"an error\" maxlog=1\n     @test startswith(fails[4].value, \"ErrorException\")\n end\n \n+@testset \"@test_logs broken/skip keywords\" begin\n+    # broken=true when logs don't match should be Broken\n+    let results = @testset NoThrowTestSet begin\n+            @test_logs (:warn,) broken=true @info \"wrong level\"\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+        @test results[1].test_type === :test\n+    end\n+\n+    # broken=true when logs match should be Error (unexpected pass)\n+    let results = @testset NoThrowTestSet begin\n+            @test_logs (:info,) broken=true @info \"correct\"\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Error\n+        @test results[1].test_type === :test_unbroken\n+    end\n+\n+    # broken=true when expression errors should be Broken\n+    let results = @testset NoThrowTestSet begin\n+            @test_logs (:info,) broken=true error(\"test error\")\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+    end\n+\n+    # skip=true should record Broken(:skipped)\n+    let results = @testset NoThrowTestSet begin\n+            @test_logs (:info,) skip=true error(\"should not run\")\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+        @test results[1].test_type === :skipped\n+    end\n+\n+    # broken and skip work with other kwargs\n+    let results = @testset NoThrowTestSet begin\n+            @test_logs (:debug,) min_level=Debug broken=true @info \"wrong\"\n+        end\n+        @test length(results) == 1\n+        @test results[1] isa Test.Broken\n+    end\n+end\n+\n let code = quote\n         function newfunc()\n             42\n@@ -1208,6 +1363,31 @@ let code = quote\n             @test fails[1] isa Test.LogTestFailure\n             @test fails[2] isa Test.LogTestFailure\n         end\n+\n+        @testset \"@test_deprecated broken/skip keywords\" begin\n+            # broken=true when deprecation warning is missing should be Broken\n+            results = @testset NoThrowTestSet begin\n+                @test_deprecated newfunc() broken=true\n+            end\n+            @test length(results) == 1\n+            @test results[1] isa Test.Broken\n+\n+            # broken=true when deprecation warning is present should be Error\n+            results = @testset NoThrowTestSet begin\n+                @test_deprecated oldfunc() broken=true\n+            end\n+            @test length(results) == 1\n+            @test results[1] isa Test.Error\n+            @test results[1].test_type === :test_unbroken\n+\n+            # skip=true should record Broken(:skipped)\n+            results = @testset NoThrowTestSet begin\n+                @test_deprecated error(\"should not run\") skip=true\n+            end\n+            @test length(results) == 1\n+            @test results[1] isa Test.Broken\n+            @test results[1].test_type === :skipped\n+        end\n     end\n     incl = \"include($(repr(joinpath(@__DIR__, \"nothrow_testset.jl\"))))\"\n     cmd = `$(Base.julia_cmd()) --startup-file=no --depwarn=yes -e 'using Test' -e $incl -e $code`"
    }
  ]
}