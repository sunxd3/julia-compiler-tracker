{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59966",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59966/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59966/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59966/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59966",
  "id": 3557499661,
  "node_id": "PR_kwDOABkWpM6v7mi1",
  "number": 59966,
  "title": "Remove some duplicate code from the GC mark phase",
  "user": {
    "login": "d-netto",
    "id": 61364108,
    "node_id": "MDQ6VXNlcjYxMzY0MTA4",
    "avatar_url": "https://avatars.githubusercontent.com/u/61364108?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/d-netto",
    "html_url": "https://github.com/d-netto",
    "followers_url": "https://api.github.com/users/d-netto/followers",
    "following_url": "https://api.github.com/users/d-netto/following{/other_user}",
    "gists_url": "https://api.github.com/users/d-netto/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/d-netto/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/d-netto/subscriptions",
    "organizations_url": "https://api.github.com/users/d-netto/orgs",
    "repos_url": "https://api.github.com/users/d-netto/repos",
    "events_url": "https://api.github.com/users/d-netto/events{/privacy}",
    "received_events_url": "https://api.github.com/users/d-netto/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 195227131,
      "node_id": "MDU6TGFiZWwxOTUyMjcxMzE=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/GC",
      "name": "GC",
      "color": "2CD3F0",
      "default": false,
      "description": "Garbage collector"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-10-27T16:01:56Z",
  "updated_at": "2025-10-30T02:53:40Z",
  "closed_at": "2025-10-30T02:53:35Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59966",
    "html_url": "https://github.com/JuliaLang/julia/pull/59966",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59966.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59966.patch",
    "merged_at": "2025-10-30T02:53:35Z"
  },
  "body": "This PR removes a function that special-cased single-threaded marking.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59966/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59966/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "f831b42471c1be66043c3da7d3c430b2e2c38726",
      "filename": "src/gc-debug.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/edda3d851b2090e4a547d48628c62fb36295fd50/src%2Fgc-debug.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/edda3d851b2090e4a547d48628c62fb36295fd50/src%2Fgc-debug.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fgc-debug.c?ref=edda3d851b2090e4a547d48628c62fb36295fd50",
      "patch": "@@ -193,7 +193,7 @@ static void gc_verify_track(jl_ptls_t ptls)\n             gc_mark_finlist(&mq, &ptls2->finalizers, 0);\n         }\n         gc_mark_finlist(&mq, &finalizer_list_marked, 0);\n-        gc_mark_loop_serial_(ptls, &mq);\n+        gc_collect_neighbors(ptls, &mq);\n         if (lostval_parents.len == 0) {\n             jl_safe_printf(\"Could not find the missing link. We missed a toplevel root. This is odd.\\n\");\n             break;\n@@ -255,7 +255,7 @@ void gc_verify(jl_ptls_t ptls)\n         gc_mark_finlist(&mq, &ptls2->finalizers, 0);\n     }\n     gc_mark_finlist(&mq, &finalizer_list_marked, 0);\n-    gc_mark_loop_serial_(ptls, &mq);\n+    gc_collect_neighbors(ptls, &mq);\n     int clean_len = bits_save[GC_CLEAN].len;\n     for(int i = 0; i < clean_len + bits_save[GC_OLD].len; i++) {\n         jl_taggedvalue_t *v = (jl_taggedvalue_t*)bits_save[i >= clean_len ? GC_OLD : GC_CLEAN].items[i >= clean_len ? i - clean_len : i];"
    },
    {
      "sha": "80cc7e1b2304c7cce3414c4ecc7097a283f5d989",
      "filename": "src/gc-stock.c",
      "status": "modified",
      "additions": 27,
      "deletions": 53,
      "changes": 80,
      "blob_url": "https://github.com/JuliaLang/julia/blob/edda3d851b2090e4a547d48628c62fb36295fd50/src%2Fgc-stock.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/edda3d851b2090e4a547d48628c62fb36295fd50/src%2Fgc-stock.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fgc-stock.c?ref=edda3d851b2090e4a547d48628c62fb36295fd50",
      "patch": "@@ -27,7 +27,7 @@ _Atomic(int) gc_n_threads_sweeping_stacks;\n // Temporary for the `ptls->gc_tls.page_metadata_allocd` used during parallel sweeping (padded to avoid false sharing)\n _Atomic(jl_gc_padded_page_stack_t *) gc_allocd_scratch;\n // `tid` of mutator thread that triggered GC\n-_Atomic(int) gc_master_tid;\n+_Atomic(int) gc_initiator_tid;\n // counter for sharing work when sweeping stacks\n _Atomic(int) gc_ptls_sweep_idx;\n // counter for round robin of giving back stack pages to the OS\n@@ -2514,8 +2514,7 @@ FORCE_INLINE void gc_mark_outrefs(jl_ptls_t ptls, jl_gc_markqueue_t *mq, void *_\n     }\n }\n \n-// Used in gc-debug\n-void gc_mark_loop_serial_(jl_ptls_t ptls, jl_gc_markqueue_t *mq) JL_NOTSAFEPOINT\n+void gc_collect_neighbors(jl_ptls_t ptls, jl_gc_markqueue_t *mq) JL_NOTSAFEPOINT\n {\n     while (1) {\n         void *new_obj = (void *)gc_ptr_queue_pop(&ptls->gc_tls.mark_queue);\n@@ -2527,35 +2526,14 @@ void gc_mark_loop_serial_(jl_ptls_t ptls, jl_gc_markqueue_t *mq) JL_NOTSAFEPOINT\n     }\n }\n \n-// Drain items from worker's own chunkqueue\n-void gc_drain_own_chunkqueue(jl_ptls_t ptls, jl_gc_markqueue_t *mq) JL_NOTSAFEPOINT\n-{\n-    jl_gc_chunk_t c = {.cid = GC_empty_chunk};\n-    do {\n-        c = gc_chunkqueue_pop(mq);\n-        if (c.cid != GC_empty_chunk) {\n-            gc_mark_chunk(ptls, mq, &c);\n-            gc_mark_loop_serial_(ptls, mq);\n-        }\n-    } while (c.cid != GC_empty_chunk);\n-}\n-\n-// Main mark loop. Stack (allocated on the heap) of `jl_value_t *`\n-// is used to keep track of processed items. Maintaining this stack (instead of\n-// native one) avoids stack overflow when marking deep objects and\n-// makes it easier to implement parallel marking via work-stealing\n-JL_EXTENSION NOINLINE void gc_mark_loop_serial(jl_ptls_t ptls) JL_NOTSAFEPOINT\n-{\n-    gc_mark_loop_serial_(ptls, &ptls->gc_tls.mark_queue);\n-    gc_drain_own_chunkqueue(ptls, &ptls->gc_tls.mark_queue);\n-}\n-\n void gc_mark_and_steal(jl_ptls_t ptls) JL_NOTSAFEPOINT\n {\n-    int master_tid = jl_atomic_load(&gc_master_tid);\n-    assert(master_tid != -1);\n     jl_gc_markqueue_t *mq = &ptls->gc_tls.mark_queue;\n-    jl_gc_markqueue_t *mq_master = &gc_all_tls_states[master_tid]->gc_tls.mark_queue;\n+    jl_gc_markqueue_t *mq_initiator = mq;\n+    int initiator_tid = jl_atomic_load(&gc_initiator_tid);\n+    if (initiator_tid != -1) {\n+        mq_initiator = &gc_all_tls_states[initiator_tid]->gc_tls.mark_queue;\n+    }\n     void *new_obj;\n     jl_gc_chunk_t c;\n     pop : {\n@@ -2604,8 +2582,8 @@ void gc_mark_and_steal(jl_ptls_t ptls) JL_NOTSAFEPOINT\n                 goto pop;\n             }\n         }\n-        // Try to steal chunk from master thread\n-        c = gc_chunkqueue_steal_from(mq_master);\n+        // Try to steal chunk from initiator thread\n+        c = gc_chunkqueue_steal_from(mq_initiator);\n         if (c.cid != GC_empty_chunk) {\n             gc_mark_chunk(ptls, mq, &c);\n             goto pop;\n@@ -2629,8 +2607,8 @@ void gc_mark_and_steal(jl_ptls_t ptls) JL_NOTSAFEPOINT\n             if (new_obj != NULL)\n                 goto mark;\n         }\n-        // Try to steal pointer from master thread\n-        new_obj = gc_ptr_queue_steal_from(mq_master);\n+        // Try to steal pointer from initiator thread\n+        new_obj = gc_ptr_queue_steal_from(mq_initiator);\n         if (new_obj != NULL)\n             goto mark;\n     }\n@@ -2655,7 +2633,7 @@ size_t gc_count_work_in_queue(jl_ptls_t ptls) JL_NOTSAFEPOINT\n  * - No work items shall be in any thread's queues when `gc_should_mark` observes\n  * that `gc_n_threads_marking` is zero.\n  *\n- * - No work item shall be stolen from the master thread (i.e. mutator thread which started\n+ * - No work item shall be stolen from the initiator thread (i.e. mutator thread which started\n  * GC and which helped the `jl_n_markthreads` - 1 threads to mark) after\n  * `gc_should_mark` observes that `gc_n_threads_marking` is zero. This property is\n  * necessary because we call `gc_mark_loop_serial` after marking the finalizer list in\n@@ -2681,7 +2659,7 @@ int gc_should_mark(void) JL_NOTSAFEPOINT\n         if (n_threads_marking == 0) {\n             break;\n         }\n-        int tid = jl_atomic_load_relaxed(&gc_master_tid);\n+        int tid = jl_atomic_load_relaxed(&gc_initiator_tid);\n         assert(tid != -1);\n         assert(gc_all_tls_states != NULL);\n         size_t work = gc_count_work_in_queue(gc_all_tls_states[tid]);\n@@ -2712,10 +2690,10 @@ void gc_wake_all_for_marking(jl_ptls_t ptls) JL_NOTSAFEPOINT\n     uv_mutex_unlock(&gc_threads_lock);\n }\n \n-void gc_mark_loop_parallel(jl_ptls_t ptls, int master) JL_NOTSAFEPOINT\n+void gc_mark_loop(jl_ptls_t ptls, int mark_loop_initiator) JL_NOTSAFEPOINT\n {\n-    if (master) {\n-        jl_atomic_store(&gc_master_tid, ptls->tid);\n+    if (mark_loop_initiator) {\n+        jl_atomic_store(&gc_initiator_tid, ptls->tid);\n         jl_atomic_fetch_add(&gc_n_threads_marking, 1);\n         gc_wake_all_for_marking(ptls);\n         gc_mark_and_steal(ptls);\n@@ -2731,20 +2709,10 @@ void gc_mark_loop_parallel(jl_ptls_t ptls, int master) JL_NOTSAFEPOINT\n     }\n }\n \n-void gc_mark_loop(jl_ptls_t ptls) JL_NOTSAFEPOINT\n-{\n-    if (jl_n_markthreads == 0 || gc_heap_snapshot_enabled) {\n-        gc_mark_loop_serial(ptls);\n-    }\n-    else {\n-        gc_mark_loop_parallel(ptls, 1);\n-    }\n-}\n-\n void gc_mark_loop_barrier(void) JL_NOTSAFEPOINT\n {\n     assert(jl_atomic_load_relaxed(&gc_n_threads_marking) == 0);\n-    jl_atomic_store_relaxed(&gc_master_tid, -1);\n+    jl_atomic_store_relaxed(&gc_initiator_tid, -1);\n }\n \n void gc_mark_clean_reclaim_sets(void) JL_NOTSAFEPOINT\n@@ -3079,7 +3047,13 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n             gc_invoke_callbacks(jl_gc_cb_root_scanner_t,\n                 gc_cblist_root_scanner, (collection));\n         }\n-        gc_mark_loop(ptls);\n+\n+        if (single_threaded_mark) {\n+            gc_mark_and_steal(ptls);\n+        }\n+        else {\n+            gc_mark_loop(ptls, 1);\n+        }\n         gc_mark_loop_barrier();\n         gc_mark_clean_reclaim_sets();\n \n@@ -3108,7 +3082,7 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n         gc_mark_finlist(mq, &finalizer_list_marked, orig_marked_len);\n         // \"Flush\" the mark stack before flipping the reset_age bit\n         // so that the objects are not incorrectly reset.\n-        gc_mark_loop_serial(ptls);\n+        gc_mark_and_steal(ptls);\n         // Conservative marking relies on age to tell allocated objects\n         // and freelist entries apart.\n         mark_reset_age = !jl_gc_conservative_gc_support_enabled();\n@@ -3117,7 +3091,7 @@ static int _jl_gc_collect(jl_ptls_t ptls, jl_gc_collection_t collection) JL_NOTS\n         // and should not be referenced by any old objects so this won't break\n         // the GC invariant.\n         gc_mark_finlist(mq, &to_finalize, 0);\n-        gc_mark_loop_serial(ptls);\n+        gc_mark_and_steal(ptls);\n         mark_reset_age = 0;\n     }\n \n@@ -3657,7 +3631,7 @@ void jl_parallel_gc_threadfun(void *arg)\n         }\n         uv_mutex_unlock(&gc_threads_lock);\n         assert(jl_atomic_load_relaxed(&ptls->gc_state) == JL_GC_PARALLEL_COLLECTOR_THREAD);\n-        gc_mark_loop_parallel(ptls, 0);\n+        gc_mark_loop(ptls, 0);\n         if (may_sweep_stack(ptls)) {\n             assert(jl_atomic_load_relaxed(&ptls->gc_state) == JL_GC_PARALLEL_COLLECTOR_THREAD);\n             sweep_stack_pool_loop();"
    },
    {
      "sha": "d6d7384826b3646e5def2713bdf8e13d197a39d1",
      "filename": "src/gc-stock.h",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/edda3d851b2090e4a547d48628c62fb36295fd50/src%2Fgc-stock.h",
      "raw_url": "https://github.com/JuliaLang/julia/raw/edda3d851b2090e4a547d48628c62fb36295fd50/src%2Fgc-stock.h",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fgc-stock.h?ref=edda3d851b2090e4a547d48628c62fb36295fd50",
      "patch": "@@ -493,9 +493,8 @@ extern uv_barrier_t thread_init_done;\n void gc_mark_queue_all_roots(jl_ptls_t ptls, jl_gc_markqueue_t *mq);\n void gc_mark_finlist_(jl_gc_markqueue_t *mq, jl_value_t *fl_parent, jl_value_t **fl_begin, jl_value_t **fl_end) JL_NOTSAFEPOINT;\n void gc_mark_finlist(jl_gc_markqueue_t *mq, arraylist_t *list, size_t start) JL_NOTSAFEPOINT;\n-void gc_mark_loop_serial_(jl_ptls_t ptls, jl_gc_markqueue_t *mq);\n-void gc_mark_loop_serial(jl_ptls_t ptls);\n-void gc_mark_loop_parallel(jl_ptls_t ptls, int master);\n+void gc_collect_neighbors(jl_ptls_t ptls, jl_gc_markqueue_t *mq) JL_NOTSAFEPOINT;\n+void gc_mark_loop(jl_ptls_t ptls, int mark_loop_initiator) JL_NOTSAFEPOINT;\n void gc_sweep_pool_parallel(jl_ptls_t ptls);\n void gc_free_pages(void);\n void sweep_stack_pool_loop(void) JL_NOTSAFEPOINT;"
    }
  ]
}