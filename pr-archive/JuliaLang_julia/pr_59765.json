{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/59765",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/59765/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/59765/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/59765/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/59765",
  "id": 3489740621,
  "node_id": "PR_kwDOABkWpM6sZ1b5",
  "number": 59765,
  "title": "precompile: fail in (closer to) linear time and linear error messages",
  "user": {
    "login": "vtjnash",
    "id": 330950,
    "node_id": "MDQ6VXNlcjMzMDk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/330950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vtjnash",
    "html_url": "https://github.com/vtjnash",
    "followers_url": "https://api.github.com/users/vtjnash/followers",
    "following_url": "https://api.github.com/users/vtjnash/following{/other_user}",
    "gists_url": "https://api.github.com/users/vtjnash/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vtjnash/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vtjnash/subscriptions",
    "organizations_url": "https://api.github.com/users/vtjnash/orgs",
    "repos_url": "https://api.github.com/users/vtjnash/repos",
    "events_url": "https://api.github.com/users/vtjnash/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vtjnash/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 240125929,
      "node_id": "MDU6TGFiZWwyNDAxMjU5Mjk=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:precompilation",
      "name": "compiler:precompilation",
      "color": "fad8c7",
      "default": false,
      "description": "Precompilation of modules"
    },
    {
      "id": 1071716919,
      "node_id": "MDU6TGFiZWwxMDcxNzE2OTE5",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/needs%20pkgeval",
      "name": "needs pkgeval",
      "color": "dd526b",
      "default": false,
      "description": "Tests for all registered packages should be run with this change"
    },
    {
      "id": 6961181883,
      "node_id": "LA_kwDOABkWpM8AAAABnus0uw",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/reverted",
      "name": "reverted",
      "color": "EC7B22",
      "default": false,
      "description": "This PR has since been reverted"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 5,
  "created_at": "2025-10-07T02:46:33Z",
  "updated_at": "2025-10-31T02:08:26Z",
  "closed_at": "2025-10-23T14:08:33Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/59765",
    "html_url": "https://github.com/JuliaLang/julia/pull/59765",
    "diff_url": "https://github.com/JuliaLang/julia/pull/59765.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/59765.patch",
    "merged_at": "2025-10-23T14:08:32Z"
  },
  "body": "Do not allow serial compile fallbacks, since this causes performance\r\nand output degredation when serial precompile fails. The precompilepkg\r\ndriver already ensured DAG ordering, so this work is not necessary or\r\nuseful to repeat. A bit of code cleanup and asking for Claude to\r\ndescribe the argument list as well, plus a test to start to cover any\r\nof this file's code functionality in CI unit tests.\r\n\r\nThis then lets us fix a lot of the error printing issues too, since we\r\nknow each package will only get one chance to load, not once for each\r\nappearance in the dependency tree. Now it tries to be slightly more\r\ncareful about when and where output should be printed: progress goes to\r\nlogio (either io or devnull) while output goes to io always and errors\r\nget returned without duplicating both the error text and output\r\nmessages of them also.\r\n    \r\nThe main logic here is that we need to print all output if any\r\nrequested packages failed, but we print only output from successful\r\npackages if all requested packages succeeded. If a package was\r\nsuccessful, then its output is required to be printed since it will not\r\nbe regenerated in the future (we don't reprint precompile output on\r\nloading since that might be obnoxious for us to implement). If a\r\nrequired package is successful however, none of the failures mattered\r\nand they will be regenerated in the future when they are required, so\r\nthose should be completely filtered out.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/59765/reactions",
    "total_count": 8,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 8,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/59765/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "6462051b9677013478d06a8b120e683aee45e7d5",
      "filename": "base/precompilation.jl",
      "status": "modified",
      "additions": 168,
      "deletions": 81,
      "changes": 249,
      "blob_url": "https://github.com/JuliaLang/julia/blob/1b89cc25e636da382dc6fd37bf0f228630226690/base%2Fprecompilation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/1b89cc25e636da382dc6fd37bf0f228630226690/base%2Fprecompilation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fprecompilation.jl?ref=1b89cc25e636da382dc6fd37bf0f228630226690",
      "patch": "@@ -406,7 +406,7 @@ function excluded_circular_deps_explanation(io::IOContext{IO}, ext_to_parent::Di\n             else\n                 line = \" \u2514\" * \"\u2500\" ^j * \" \"\n             end\n-            hascolor = get(io, :color, false)::Bool\n+            hascolor = get(io, :color, false)::Bool # XXX: this output does not go to `io` so this is bad to call here\n             line = _color_string(line, :light_black, hascolor) * full_name(ext_to_parent, pkg) * \"\\n\"\n             cycle_str *= line\n         end\n@@ -471,6 +471,76 @@ function collect_all_deps(direct_deps, dep, alldeps=Set{Base.PkgId}())\n end\n \n \n+\"\"\"\n+    precompilepkgs(pkgs; kwargs...)\n+\n+Precompile packages and their dependencies, with support for parallel compilation,\n+progress tracking, and various compilation configurations.\n+\n+`pkgs::Union{Vector{String}, Vector{PkgId}}`: Packages to precompile. When\n+empty (default), precompiles all project dependencies. When specified,\n+precompiles only the given packages and their dependencies (unless\n+`manifest=true`).\n+\n+!!! note\n+    Errors will only throw when precompiling the top-level dependencies, given that\n+    not all manifest dependencies may be loaded by the top-level dependencies on the given system.\n+    This can be overridden to make errors in all dependencies throw by setting the kwarg `strict` to `true`\n+\n+# Keyword Arguments\n+- `internal_call::Bool`: Indicates this is an automatic precompilation call\n+  from somewhere external (e.g. Pkg). Do not use this parameter.\n+\n+- `strict::Bool`: Controls error reporting scope. When `false` (default), only reports\n+  errors for direct project dependencies. Only relevant when `manifest=true`.\n+\n+- `warn_loaded::Bool`: When `true` (default), checks for and warns about packages that are\n+  precompiled but already loaded with a different version. Displays a warning that Julia\n+  needs to be restarted to use the newly precompiled versions.\n+\n+- `timing::Bool`: When `true` (not default), displays timing information for\n+  each package compilation, but only if compilation might have succeeded.\n+  Disables fancy progress bar output (timing is shown in simple text mode).\n+\n+- `_from_loading::Bool`: Internal flag indicating the call originated from the\n+  package loading system. When `true` (not default): returns early instead of\n+  throwing when packages are not found; suppresses progress messages when not\n+  in an interactive session; allows packages outside the current environment to\n+  be added as serial precompilation jobs; skips LOADING_CACHE initialization;\n+  and changes cachefile locking behavior.\n+\n+- `configs::Union{Config,Vector{Config}}`: Compilation configurations to use. Each Config\n+  is a `Pair{Cmd, Base.CacheFlags}` specifying command flags and cache flags. When\n+  multiple configs are provided, each package is precompiled for each configuration.\n+\n+- `io::IO`: Output stream for progress messages, warnings, and errors. Can be\n+  redirected (e.g., to `devnull` when called from loading in non-interactive mode).\n+\n+- `fancyprint::Bool`: Controls output format. When `true`, displays an animated progress\n+  bar with spinners. When `false`, instead enables `timing` mode. Automatically\n+  disabled when `timing=true` or when called from loading in non-interactive mode.\n+\n+- `manifest::Bool`: Controls the scope of packages to precompile. When `false` (default),\n+  precompiles only packages specified in `pkgs` and their dependencies. When `true`,\n+  precompiles all packages in the manifest (workspace mode), typically used by Pkg for\n+  workspace precompile requests.\n+\n+- `ignore_loaded::Bool`: Controls whether already-loaded packages affect cache\n+  freshness checks. When `false` (not default), loaded package versions are considered when\n+  determining if cache files are fresh.\n+\n+# Return\n+- `Vector{String}`: Paths to cache files for the requested packages.\n+- `Nothing`: precompilation should be skipped\n+\n+# Notes\n+- Packages in circular dependency cycles are skipped with a warning.\n+- Packages with `__precompile__(false)` are skipped if they are from loading to\n+  avoid repeated work on every session.\n+- Parallel compilation is controlled by `JULIA_NUM_PRECOMPILE_TASKS` environment variable\n+  (defaults to CPU_THREADS + 1, capped at 16, halved on Windows).\n+- Extensions are precompiled when all their triggers are available in the environment.\n+\"\"\"\n function precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}}=String[];\n                         internal_call::Bool=false,\n                         strict::Bool = false,\n@@ -497,7 +567,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                          timing::Bool,\n                          _from_loading::Bool,\n                          configs::Vector{Config},\n-                         _io::IOContext{IO},\n+                         io::IOContext{IO},\n                          fancyprint::Bool,\n                          manifest::Bool,\n                          ignore_loaded::Bool)\n@@ -535,16 +605,18 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n     # suppress precompilation progress messages when precompiling for loading packages, except during interactive sessions\n     # or when specified by logging heuristics that explicitly require it\n     # since the complicated IO implemented here can have somewhat disastrous consequences when happening in the background (e.g. #59599)\n-    io = _io\n+    logio = io\n     logcalls = nothing\n-    if _from_loading && !isinteractive()\n-        io = IOContext{IO}(devnull)\n-        fancyprint = false\n+    if _from_loading\n+        if !isinteractive()\n+            logio = IOContext{IO}(devnull)\n+            fancyprint = false\n+        end\n         logcalls = isinteractive() ? CoreLogging.Info : CoreLogging.Debug # sync with Base.compilecache\n     end\n \n     nconfigs = length(configs)\n-    hascolor = get(io, :color, false)::Bool\n+    hascolor = get(logio, :color, false)::Bool\n     color_string(cstr::String, col::Union{Int64, Symbol}) = _color_string(cstr, col, hascolor)\n \n     stale_cache = Dict{StaleCacheKey, Bool}()\n@@ -745,8 +817,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n             pkg_names = [pkg.name for pkg in project_deps]\n         end\n         keep = Set{Base.PkgId}()\n-        for dep in direct_deps\n-            dep_pkgid = first(dep)\n+        for dep_pkgid in keys(direct_deps)\n             if dep_pkgid.name in pkg_names\n                 push!(keep, dep_pkgid)\n                 collect_all_deps(direct_deps, dep_pkgid, keep)\n@@ -835,9 +906,10 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n     pkg_liveprinted = Ref{Union{Nothing, PkgId}}(nothing)\n \n     function monitor_std(pkg_config, pipe; single_requested_pkg=false)\n-        pkg, config = pkg_config\n+        local pkg, config = pkg_config\n         try\n-            liveprinting = false\n+            local liveprinting = false\n+            local thistaskwaiting = false\n             while !eof(pipe)\n                 local str = readline(pipe, keep=true)\n                 if single_requested_pkg && (liveprinting || !isempty(str))\n@@ -850,15 +922,18 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                     end\n                 end\n                 write(get!(IOBuffer, std_outputs, pkg_config), str)\n-                if !in(pkg_config, taskwaiting) && occursin(\"waiting for IO to finish\", str)\n-                    !fancyprint && @lock print_lock begin\n-                        println(io, pkg.name, color_string(\" Waiting for background task / IO / timer.\", Base.warn_color()))\n+                if thistaskwaiting\n+                    if occursin(\"Waiting for background task / IO / timer\", str)\n+                        thistaskwaiting = true\n+                        !liveprinting && !fancyprint && @lock print_lock begin\n+                            println(io, pkg.name, color_string(str, Base.warn_color()))\n+                        end\n+                        push!(taskwaiting, pkg_config)\n                     end\n-                    push!(taskwaiting, pkg_config)\n-                end\n-                if !fancyprint && in(pkg_config, taskwaiting)\n-                    @lock print_lock begin\n-                        print(io, str)\n+                else\n+                    # XXX: don't just re-enable IO for random packages without printing the context for them first\n+                    !liveprinting && !fancyprint && @lock print_lock begin\n+                        print(io, ansi_cleartoendofline, str)\n                     end\n                 end\n             end\n@@ -874,10 +949,10 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n             (isempty(pkg_queue) || interrupted_or_done[]) && return\n             @lock print_lock begin\n                 if target[] !== nothing\n-                    printpkgstyle(io, :Precompiling, target[])\n+                    printpkgstyle(logio, :Precompiling, target[])\n                 end\n                 if fancyprint\n-                    print(io, ansi_disablecursor)\n+                    print(logio, ansi_disablecursor)\n                 end\n             end\n             t = Timer(0; interval=1/10)\n@@ -891,7 +966,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n             n_print_rows = 0\n             while !printloop_should_exit[]\n                 @lock print_lock begin\n-                    term_size = displaysize(io)::Tuple{Int, Int}\n+                    term_size = displaysize(logio)::Tuple{Int, Int}\n                     num_deps_show = max(term_size[1] - 3, 2) # show at least 2 deps\n                     pkg_queue_show = if !interrupted_or_done[] && length(pkg_queue) > num_deps_show\n                         last(pkg_queue, num_deps_show)\n@@ -908,7 +983,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                         # window between print cycles\n                         termwidth = (displaysize(io)::Tuple{Int,Int})[2] - 4\n                         if !final_loop\n-                            s = sprint(io -> show_progress(io, bar; termwidth, carriagereturn=false); context=io)\n+                            s = sprint(io -> show_progress(io, bar; termwidth, carriagereturn=false); context=logio)\n                             print(iostr, Base._truncate_at_width_or_chars(true, s, termwidth), \"\\n\")\n                         end\n                         for pkg_config in pkg_queue_show\n@@ -949,11 +1024,11 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                     end\n                     last_length = length(pkg_queue_show)\n                     n_print_rows = count(\"\\n\", str_)\n-                    print(io, str_)\n+                    print(logio, str_)\n                     printloop_should_exit[] = interrupted_or_done[] && final_loop\n                     final_loop = interrupted_or_done[] # ensures one more loop to tidy last task after finish\n                     i += 1\n-                    printloop_should_exit[] || print(io, ansi_moveup(n_print_rows), ansi_movecol1)\n+                    printloop_should_exit[] || print(logio, ansi_moveup(n_print_rows), ansi_movecol1)\n                 end\n                 wait(t)\n             end\n@@ -963,7 +1038,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n             # Base.display_error(ErrorException(\"\"), Base.catch_backtrace())\n             handle_interrupt(err, true) || rethrow()\n         finally\n-            fancyprint && print(io, ansi_enablecursor)\n+            fancyprint && print(logio, ansi_enablecursor)\n         end\n     end\n \n@@ -990,8 +1065,10 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                 notify(was_processed[pkg_config])\n                 continue\n             end\n-            # Heuristic for when precompilation is disabled\n-            if occursin(r\"\\b__precompile__\\(\\s*false\\s*\\)\", read(sourcepath, String))\n+            # Heuristic for when precompilation is disabled, which must not over-estimate however for any dependent\n+            # since it will also block precompilation of all dependents\n+            if _from_loading && single_requested_pkg && occursin(r\"\\b__precompile__\\(\\s*false\\s*\\)\", read(sourcepath, String))\n+                Base.@logmsg logcalls \"Disabled precompiling $(repr(\"text/plain\", pkg)) since the text `__precompile__(false)` was found in file.\"\n                 notify(was_processed[pkg_config])\n                 continue\n             end\n@@ -1013,8 +1090,8 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                     end\n                     if !circular && is_stale\n                         Base.acquire(parallel_limiter)\n-                        is_project_dep = pkg in project_deps\n                         is_serial_dep = pkg in serial_deps\n+                        is_project_dep = pkg in project_deps\n \n                         # std monitoring\n                         std_pipe = Base.link_pipe!(Pipe(); reader_supports_async=true, writer_supports_async=true)\n@@ -1024,7 +1101,7 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                             name = describe_pkg(pkg, is_project_dep, is_serial_dep, flags, cacheflags)\n                             @lock print_lock begin\n                                 if !fancyprint && isempty(pkg_queue)\n-                                    printpkgstyle(io, :Precompiling, something(target[], \"packages...\"))\n+                                    printpkgstyle(logio, :Precompiling, something(target[], \"packages...\"))\n                                 end\n                             end\n                             push!(pkg_queue, pkg_config)\n@@ -1035,7 +1112,13 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                             end\n                             # for extensions, any extension in our direct dependencies is one we have a right to load\n                             # for packages, we may load any extension (all possible triggers are accounted for above)\n-                            loadable_exts = haskey(ext_to_parent, pkg) ? filter((dep)->haskey(ext_to_parent, dep), direct_deps[pkg]) : nothing\n+                            loadable_exts = haskey(ext_to_parent, pkg) ? filter((dep)->haskey(ext_to_parent, dep), deps) : nothing\n+                            if !isempty(deps)\n+                                # if deps is empty, either it doesn't have any (so compiled-modules is\n+                                # irrelevant) or we couldn't compute them (so we actually should attempt\n+                                # serial compile, as the dependencies are not in the parallel list)\n+                                flags = `$flags --compiled-modules=strict`\n+                            end\n                             if _from_loading && pkg in requested_pkgids\n                                 # loading already took the cachefile_lock and printed logmsg for its explicit requests\n                                 t = @elapsed ret = begin\n@@ -1067,11 +1150,11 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                             if ret isa Exception\n                                 push!(precomperr_deps, pkg_config)\n                                 !fancyprint && @lock print_lock begin\n-                                    println(io, _timing_string(t), color_string(\"  ? \", Base.warn_color()), name)\n+                                    println(logio, _timing_string(t), color_string(\"  ? \", Base.warn_color()), name)\n                                 end\n                             else\n                                 !fancyprint && @lock print_lock begin\n-                                    println(io, _timing_string(t), color_string(\"  \u2713 \", loaded ? Base.warn_color() : :green), name)\n+                                    println(logio, _timing_string(t), color_string(\"  \u2713 \", loaded ? Base.warn_color() : :green), name)\n                                 end\n                                 if ret !== nothing\n                                     was_recompiled[pkg_config] = true\n@@ -1087,11 +1170,9 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                             close(std_pipe.in) # close pipe to end the std output monitor\n                             wait(t_monitor)\n                             if err isa ErrorException || (err isa ArgumentError && startswith(err.msg, \"Invalid header in cache file\"))\n-                                errmsg = String(take!(get(IOBuffer, std_outputs, pkg_config)))\n-                                delete!(std_outputs, pkg_config) # so it's not shown as warnings, given error report\n-                                failed_deps[pkg_config] = (strict || is_project_dep) ? string(sprint(showerror, err), \"\\n\", strip(errmsg)) : \"\"\n+                                failed_deps[pkg_config] = sprint(showerror, err)\n                                 !fancyprint && @lock print_lock begin\n-                                    println(io, \" \"^12, color_string(\"  \u2717 \", Base.error_color()), name)\n+                                    println(logio, \" \"^12, color_string(\"  \u2717 \", Base.error_color()), name)\n                                 end\n                             else\n                                 rethrow()\n@@ -1139,9 +1220,25 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n     quick_exit = any(t -> !istaskdone(t) || istaskfailed(t), tasks) || interrupted[] # all should have finished (to avoid memory corruption)\n     seconds_elapsed = round(Int, (time_ns() - time_start) / 1e9)\n     ndeps = count(values(was_recompiled))\n-    if ndeps > 0 || !isempty(failed_deps) || (quick_exit && !isempty(std_outputs))\n-        str = sprint(context=io) do iostr\n-            if !quick_exit\n+    # Determine if any of failures were a requested package\n+    requested_errs = false\n+    for ((dep, config), err) in failed_deps\n+        if dep in requested_pkgids\n+            requested_errs = true\n+            break\n+        end\n+    end\n+    # if every requested package succeeded, filter away output from failed packages\n+    # since it didn't contribute to the overall success and can be regenerated if that package is later required\n+    if !strict && !requested_errs\n+        for (pkg_config, err) in failed_deps\n+            delete!(std_outputs, pkg_config)\n+        end\n+        empty!(failed_deps)\n+    end\n+    if ndeps > 0 || !isempty(failed_deps)\n+        if !quick_exit\n+            logstr = sprint(context=logio) do iostr\n                 if fancyprint # replace the progress bar\n                     what = isempty(requested_pkgids) ? \"packages finished.\" : \"$(join((p.name for p in requested_pkgids), \", \", \" and \")) finished.\"\n                     printpkgstyle(iostr, :Precompiling, what)\n@@ -1174,10 +1271,17 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                     )\n                 end\n             end\n+            @lock print_lock begin\n+                println(logio, logstr)\n+            end\n+        end\n+    end\n+    if !isempty(std_outputs)\n+        str = sprint(context=io) do iostr\n             # show any stderr output, even if Pkg.precompile has been interrupted (quick_exit=true), given user may be\n-            # interrupting a hanging precompile job with stderr output. julia#48371\n+            # interrupting a hanging precompile job with stderr output.\n             let std_outputs = Tuple{PkgConfig,SubString{String}}[(pkg_config, strip(String(take!(io)))) for (pkg_config,io) in std_outputs]\n-                filter!(kv -> !isempty(last(kv)), std_outputs)\n+                filter!(!isempty\u2218last, std_outputs)\n                 if !isempty(std_outputs)\n                     local plural1 = length(std_outputs) == 1 ? \"y\" : \"ies\"\n                     local plural2 = length(std_outputs) == 1 ? \"\" : \"s\"\n@@ -1195,49 +1299,32 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                 end\n             end\n         end\n-        @lock print_lock begin\n+        isempty(str) || @lock print_lock begin\n             println(io, str)\n         end\n-        if interrupted[]\n-            # done cleanup, now ensure caller aborts too\n-            throw(InterruptException())\n-        end\n-        quick_exit && return Vector{String}[]\n+    end\n+    # Done cleanup and sub-process output, now ensure caller aborts too with the right error\n+    if interrupted[]\n+        throw(InterruptException())\n+    end\n+    # Fail noisily now with failed_deps if any.\n+    # Include all messages from compilecache since any might be relevant in the failure.\n+    if !isempty(failed_deps)\n         err_str = IOBuffer()\n-        n_direct_errs = 0\n-        for (pkg_config, err) in failed_deps\n-            dep, config = pkg_config\n-            if strict || (dep in project_deps)\n-                print(err_str, \"\\n\", dep.name, \" \")\n-                for cfg in config[1]\n-                    print(err_str, cfg, \" \")\n-                end\n-                print(err_str, \"\\n\\n\", err)\n-                n_direct_errs > 0 && write(err_str, \"\\n\")\n-                n_direct_errs += 1\n-            end\n+        for ((dep, config), err) in failed_deps\n+            write(err_str, \"\\n\")\n+            print(err_str, \"\\n\", dep.name, \" \")\n+            join(err_str, config[1], \" \")\n+            print(err_str, \"\\n\", err)\n         end\n-        if position(err_str) > 0\n-            skip(err_str, -1)\n-            truncate(err_str, position(err_str))\n-            pluralde = n_direct_errs == 1 ? \"y\" : \"ies\"\n-            direct = strict ? \"\" : \"direct \"\n-            err_msg = \"The following $n_direct_errs $(direct)dependenc$(pluralde) failed to precompile:\\n$(String(take!(err_str)))\"\n-            if internal_call # aka. auto-precompilation\n-                if isinteractive()\n-                    plural1 = length(failed_deps) == 1 ? \"y\" : \"ies\"\n-                    println(io, \"  \", color_string(\"$(length(failed_deps))\", Base.error_color()), \" dependenc$(plural1) errored.\")\n-                    println(io, \"  For a report of the errors see `julia> err`. To retry use `pkg> precompile`\")\n-                    setglobal!(Base.MainInclude, :err, PkgPrecompileError(err_msg))\n-                else\n-                    # auto-precompilation shouldn't throw but if the user can't easily access the\n-                    # error messages, just show them\n-                    print(io, \"\\n\", err_msg)\n-                end\n-            else\n-                println(io)\n-                throw(PkgPrecompileError(err_msg))\n-            end\n+        n_errs = length(failed_deps)\n+        pluraled = n_errs == 1 ? \"\" : \"s\"\n+        err_msg = \"The following $n_errs package$(pluraled) failed to precompile:$(String(take!(err_str)))\\n\"\n+        if internal_call\n+            # Pkg does not implement correct error handling, so this sometimes handles them instead\n+            print(io, err_msg)\n+        else\n+            throw(PkgPrecompileError(err_msg))\n         end\n     end\n     return collect(String, Iterators.flatten((v for (pkgid, v) in cachepath_cache if pkgid in requested_pkgids)))"
    },
    {
      "sha": "279ffec5360e8f7cbf50febf4f95630be711ae4e",
      "filename": "doc/src/devdocs/precompile_hang.md",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/1b89cc25e636da382dc6fd37bf0f228630226690/doc%2Fsrc%2Fdevdocs%2Fprecompile_hang.md",
      "raw_url": "https://github.com/JuliaLang/julia/raw/1b89cc25e636da382dc6fd37bf0f228630226690/doc%2Fsrc%2Fdevdocs%2Fprecompile_hang.md",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/doc%2Fsrc%2Fdevdocs%2Fprecompile_hang.md?ref=1b89cc25e636da382dc6fd37bf0f228630226690",
      "patch": "@@ -17,7 +17,7 @@ If you follow the advice and hit `Ctrl-C`, you might see\n \n   1 dependency had warnings during precompilation:\n \u250c Test1 [ac89d554-e2ba-40bc-bc5c-de68b658c982]\n-\u2502  [pid 2745] waiting for IO to finish:\n+\u2502  [pid 2745] Waiting for background task / IO / timer to finish:\n \u2502   Handle type        uv_handle_t->data\n \u2502   timer              0x55580decd1e0->0x7f94c3a4c340\n ```"
    },
    {
      "sha": "e41b8963206930344d7f356d2a63e0b5ac013576",
      "filename": "src/jl_uv.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/1b89cc25e636da382dc6fd37bf0f228630226690/src%2Fjl_uv.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/1b89cc25e636da382dc6fd37bf0f228630226690/src%2Fjl_uv.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjl_uv.c?ref=1b89cc25e636da382dc6fd37bf0f228630226690",
      "patch": "@@ -68,7 +68,7 @@ static void wait_empty_func(uv_timer_t *t)\n     uv_unref((uv_handle_t*)&signal_async);\n     if (!uv_loop_alive(t->loop))\n         return;\n-    jl_safe_printf(\"\\n[pid %zd] waiting for IO to finish:\\n\"\n+    jl_safe_printf(\"\\n[pid %zd] Waiting for background task / IO / timer to finish:\\n\"\n                    \" Handle type        uv_handle_t->data\\n\",\n                    (size_t)uv_os_getpid());\n     uv_walk(jl_io_loop, walk_print_cb, NULL);"
    },
    {
      "sha": "4d2fa1728ae7ff4cc221725a54c690e6550338a9",
      "filename": "test/loading.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/1b89cc25e636da382dc6fd37bf0f228630226690/test%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/1b89cc25e636da382dc6fd37bf0f228630226690/test%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Floading.jl?ref=1b89cc25e636da382dc6fd37bf0f228630226690",
      "patch": "@@ -1376,10 +1376,8 @@ end\n             \"\"\")\n         write(joinpath(foo_path, \"Manifest.toml\"),\n             \"\"\"\n-            # This file is machine-generated - editing it directly is not advised\n-            julia_version = \"1.13.0-DEV\"\n+            julia_version = \"1.13.0\"\n             manifest_format = \"2.0\"\n-            project_hash = \"8699765aeeac181c3e5ddbaeb9371968e1f84d6b\"\n \n             [[deps.Foo51989]]\n             path = \".\""
    },
    {
      "sha": "12f7a5b1f89ba6e4b11db4a4d67cadb3cda8ff15",
      "filename": "test/precompile.jl",
      "status": "modified",
      "additions": 159,
      "deletions": 17,
      "changes": 176,
      "blob_url": "https://github.com/JuliaLang/julia/blob/1b89cc25e636da382dc6fd37bf0f228630226690/test%2Fprecompile.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/1b89cc25e636da382dc6fd37bf0f228630226690/test%2Fprecompile.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2Fprecompile.jl?ref=1b89cc25e636da382dc6fd37bf0f228630226690",
      "patch": "@@ -687,15 +687,7 @@ precompile_test_harness(false) do dir\n           error(\"break me\")\n           end\n           \"\"\")\n-    try\n-        Base.require(Main, :FooBar2)\n-        error(\"the \\\"break me\\\" test failed\")\n-    catch exc\n-        isa(exc, LoadError) || rethrow()\n-        exc = exc.error\n-        isa(exc, ErrorException) || rethrow()\n-        \"break me\" == exc.msg || rethrow()\n-    end\n+    @test_throws Base.Precompilation.PkgPrecompileError Base.require(Main, :FooBar2)\n \n     # Test that trying to eval into closed modules during precompilation is an error\n     FooBar3_file = joinpath(dir, \"FooBar3.jl\")\n@@ -707,14 +699,7 @@ precompile_test_harness(false) do dir\n         $code\n         end\n         \"\"\")\n-        try\n-            Base.require(Main, :FooBar3)\n-        catch exc\n-            isa(exc, LoadError) || rethrow()\n-            exc = exc.error\n-            isa(exc, ErrorException) || rethrow()\n-            occursin(\"Evaluation into the closed module `Base` breaks incremental compilation\", exc.msg) || rethrow()\n-        end\n+        @test_throws Base.Precompilation.PkgPrecompileError Base.require(Main, :FooBar3)\n     end\n \n     # Test transitive dependency for #21266\n@@ -2544,4 +2529,161 @@ let io = IOBuffer()\n     @test isempty(String(take!(io)))\n end\n \n+# Test --compiled-modules=strict in precompilepkgs\n+@testset \"compiled-modules=strict with dependencies\" begin\n+    mkdepottempdir() do depot\n+        # Create three packages: one that fails to precompile, one that loads it, one that doesn't\n+        project_path = joinpath(depot, \"testenv\")\n+        mkpath(project_path)\n+\n+        # Create FailPkg - a package that can't be precompiled\n+        fail_pkg_path = joinpath(depot, \"dev\", \"FailPkg\")\n+        mkpath(joinpath(fail_pkg_path, \"src\"))\n+        write(joinpath(fail_pkg_path, \"Project.toml\"),\n+              \"\"\"\n+              name = \"FailPkg\"\n+              uuid = \"10000000-0000-0000-0000-000000000001\"\n+              version = \"0.1.0\"\n+              \"\"\")\n+        write(joinpath(fail_pkg_path, \"src\", \"FailPkg.jl\"),\n+              \"\"\"\n+              module FailPkg\n+              print(\"Now FailPkg is running.\\n\")\n+              error(\"expected fail\")\n+              end\n+              \"\"\")\n+\n+        # Create LoadsFailPkg - depends on and loads FailPkg (should fail with strict)\n+        loads_pkg_path = joinpath(depot, \"dev\", \"LoadsFailPkg\")\n+        mkpath(joinpath(loads_pkg_path, \"src\"))\n+        write(joinpath(loads_pkg_path, \"Project.toml\"),\n+              \"\"\"\n+              name = \"LoadsFailPkg\"\n+              uuid = \"20000000-0000-0000-0000-000000000002\"\n+              version = \"0.1.0\"\n+\n+              [deps]\n+              FailPkg = \"10000000-0000-0000-0000-000000000001\"\n+              \"\"\")\n+        write(joinpath(loads_pkg_path, \"src\", \"LoadsFailPkg.jl\"),\n+              \"\"\"\n+              module LoadsFailPkg\n+              print(\"Now LoadsFailPkg is running.\\n\")\n+              import FailPkg\n+              print(\"unreachable\\n\")\n+              end\n+              \"\"\")\n+\n+        # Create DependsOnly - depends on FailPkg but doesn't load it (should succeed)\n+        depends_pkg_path = joinpath(depot, \"dev\", \"DependsOnly\")\n+        mkpath(joinpath(depends_pkg_path, \"src\"))\n+        write(joinpath(depends_pkg_path, \"Project.toml\"),\n+              \"\"\"\n+              name = \"DependsOnly\"\n+              uuid = \"30000000-0000-0000-0000-000000000003\"\n+              version = \"0.1.0\"\n+\n+              [deps]\n+              FailPkg = \"10000000-0000-0000-0000-000000000001\"\n+              \"\"\")\n+        write(joinpath(depends_pkg_path, \"src\", \"DependsOnly.jl\"),\n+              \"\"\"\n+              module DependsOnly\n+              # Has FailPkg as a dependency but doesn't load it\n+              print(\"Now DependsOnly is running.\\n\")\n+              end\n+              \"\"\")\n+\n+        # Create main project with all packages\n+        write(joinpath(project_path, \"Project.toml\"),\n+              \"\"\"\n+              [deps]\n+              LoadsFailPkg = \"20000000-0000-0000-0000-000000000002\"\n+              DependsOnly = \"30000000-0000-0000-0000-000000000003\"\n+              \"\"\")\n+        write(joinpath(project_path, \"Manifest.toml\"),\n+              \"\"\"\n+              julia_version = \"1.13.0\"\n+              manifest_format = \"2.0\"\n+\n+              [[DependsOnly]]\n+              deps = [\"FailPkg\"]\n+              uuid = \"30000000-0000-0000-0000-000000000003\"\n+              version = \"0.1.0\"\n+\n+              [[FailPkg]]\n+              uuid = \"10000000-0000-0000-0000-000000000001\"\n+              version = \"0.1.0\"\n+\n+              [[LoadsFailPkg]]\n+              deps = [\"FailPkg\"]\n+              uuid = \"20000000-0000-0000-0000-000000000002\"\n+              version = \"0.1.0\"\n+\n+              [[deps.DependsOnly]]\n+              deps = [\"FailPkg\"]\n+              path = \"../dev/DependsOnly/\"\n+              uuid = \"30000000-0000-0000-0000-000000000003\"\n+              version = \"0.1.0\"\n+\n+              [[deps.FailPkg]]\n+              path = \"../dev/FailPkg/\"\n+              uuid = \"10000000-0000-0000-0000-000000000001\"\n+              version = \"0.1.0\"\n+\n+              [[deps.LoadsFailPkg]]\n+              deps = [\"FailPkg\"]\n+              path = \"../dev/LoadsFailPkg/\"\n+              uuid = \"20000000-0000-0000-0000-000000000002\"\n+              version = \"0.1.0\"\n+              \"\"\")\n+\n+        # Call precompilepkgs with output redirected to a file\n+        LoadsFailPkg_output = joinpath(depot, \"LoadsFailPkg_output.txt\")\n+        DependsOnly_output = joinpath(depot, \"DependsOnly_output.txt\")\n+        original_depot_path = copy(Base.DEPOT_PATH)\n+        old_proj = Base.active_project()\n+        try\n+            push!(empty!(DEPOT_PATH), depot)\n+            Base.set_active_project(project_path)\n+            precompile_capture(file, pkg) = open(file, \"w\") do io\n+                try\n+                    r = Base.Precompilation.precompilepkgs([pkg]; io, fancyprint=true)\n+                    @test r isa Vector{String}\n+                    r\n+                catch ex\n+                    ex isa Base.Precompilation.PkgPrecompileError || rethrow()\n+                    ex\n+                end\n+            end\n+            loadsfailpkg = precompile_capture(LoadsFailPkg_output, \"LoadsFailPkg\")\n+            @test loadsfailpkg isa Base.Precompilation.PkgPrecompileError\n+            dependsonly = precompile_capture(DependsOnly_output, \"DependsOnly\")\n+            @test length(dependsonly) == 1\n+        finally\n+            Base.set_active_project(old_proj)\n+            append!(empty!(DEPOT_PATH), original_depot_path)\n+        end\n+\n+        output = read(LoadsFailPkg_output, String)\n+        # LoadsFailPkg should fail because it tries to load FailPkg with --compiled-modules=strict\n+        @test count(\"LoadError: expected fail\", output) == 1\n+        @test count(\"expected fail\", output) == 1\n+        @test count(\"\u2717 FailPkg\", output) > 0\n+        @test count(\"\u2717 LoadsFailPkg\", output) > 0\n+        @test count(\"Now FailPkg is running.\", output) == 1\n+        @test count(\"Now LoadsFailPkg is running.\", output) == 1\n+        @test count(\"DependsOnly precompiling.\", output) == 0\n+\n+        # DependsOnly should succeed because it doesn't actually load FailPkg\n+        output = read(DependsOnly_output, String)\n+        @test count(\"LoadError: expected fail\", output) == 0\n+        @test count(\"expected fail\", output) == 0\n+        @test count(\"\u2717 FailPkg\", output) > 0\n+        @test count(\"Precompiling DependsOnly finished.\", output) == 1\n+        @test count(\"Now FailPkg is running.\", output) == 0\n+        @test count(\"Now DependsOnly is running.\", output) == 1\n+    end\n+end\n+\n finish_precompile_test!()"
    }
  ]
}