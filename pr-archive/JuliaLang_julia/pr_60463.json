{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60463",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60463/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60463/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60463/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60463",
  "id": 3758598056,
  "node_id": "PR_kwDOABkWpM66ZJ1D",
  "number": 60463,
  "title": "[Windows] Use `TimerQueue` API to register Profile watchdog",
  "user": {
    "login": "topolarity",
    "id": 84105208,
    "node_id": "MDQ6VXNlcjg0MTA1MjA4",
    "avatar_url": "https://avatars.githubusercontent.com/u/84105208?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/topolarity",
    "html_url": "https://github.com/topolarity",
    "followers_url": "https://api.github.com/users/topolarity/followers",
    "following_url": "https://api.github.com/users/topolarity/following{/other_user}",
    "gists_url": "https://api.github.com/users/topolarity/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/topolarity/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/topolarity/subscriptions",
    "organizations_url": "https://api.github.com/users/topolarity/orgs",
    "repos_url": "https://api.github.com/users/topolarity/repos",
    "events_url": "https://api.github.com/users/topolarity/events{/privacy}",
    "received_events_url": "https://api.github.com/users/topolarity/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 5669611,
      "node_id": "MDU6TGFiZWw1NjY5NjEx",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/system:windows",
      "name": "system:windows",
      "color": "0b02e1",
      "default": false,
      "description": "Affects only Windows"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 4,
  "created_at": "2025-12-23T21:21:34Z",
  "updated_at": "2025-12-24T00:17:32Z",
  "closed_at": "2025-12-24T00:17:06Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60463",
    "html_url": "https://github.com/JuliaLang/julia/pull/60463",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60463.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60463.patch",
    "merged_at": "2025-12-24T00:17:06Z"
  },
  "body": "This goes in the opposite direction to https://github.com/JuliaLang/julia/pull/60454.\r\n\r\nOn x86-64 Windows, we're unfortunately pretty reliant on this timer to avoid (otherwise unavoidable) deadlocks between `RtlLookupFunctionEntry` and many other internal functions in the Windows runtime (incl. `RtlAllocateHeap` and `LdrLoadDll`).\r\n\r\nFor unknown reasons, `RegisterWaitForSingleObject` seems to be quite bad about dropping the callback on the floor in contended situations (we deadlock but the timer callback is simply never called). This alternative API appears to be better-behaved.\r\n\r\nThis does not solve the deadlock identified by @xal-0 in https://github.com/JuliaLang/julia/pull/60454#issuecomment-3687877148 (or several others)\r\n\r\nNonetheless it appears to be a significant improvement on my machine.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60463/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60463/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "db6e1f61de0c0dbb6d013eaeddb75df808b4ea85",
      "filename": "src/signals-win.c",
      "status": "modified",
      "additions": 15,
      "deletions": 12,
      "changes": 27,
      "blob_url": "https://github.com/JuliaLang/julia/blob/d53e65e56175d9b091db3a056a632110442de94c/src%2Fsignals-win.c",
      "raw_url": "https://github.com/JuliaLang/julia/raw/d53e65e56175d9b091db3a056a632110442de94c/src%2Fsignals-win.c",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fsignals-win.c?ref=d53e65e56175d9b091db3a056a632110442de94c",
      "patch": "@@ -484,10 +484,9 @@ int jl_thread_suspend(int16_t tid, bt_context_t *ctx)\n static DWORD WINAPI profile_bt( LPVOID lparam )\n {\n     // Note: illegal to use jl_* functions from this thread except for profiling-specific functions\n-    // Dummy event for RegisterWaitForSingleObject (to use timeout callback)\n-    HANDLE hProfileEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n-    if (hProfileEvent == NULL) {\n-        jl_safe_fprintf(ios_safe_stderr, \"failed to create profile event.\\n\");\n+    HANDLE hTimerQueue = CreateTimerQueue();\n+    if (hTimerQueue == NULL) {\n+        jl_safe_fprintf(ios_safe_stderr, \"failed to create profile watchdog timer queue.\\n\");\n         abort();\n     }\n     while (1) {\n@@ -531,25 +530,29 @@ static DWORD WINAPI profile_bt( LPVOID lparam )\n                 timeout_data.abort_ptr = &abort_profiling;\n                 timeout_data.tid = tid;\n                 jl_set_profile_abort_ptr(&abort_profiling);\n-                HANDLE hWaitHandle = NULL;\n-                if (!RegisterWaitForSingleObject(&hWaitHandle, hProfileEvent, profile_timeout_cb,\n-                                                 &timeout_data, 100, WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD)) {\n+                HANDLE hTimer = NULL;\n+                if (!CreateTimerQueueTimer(&hTimer, hTimerQueue, profile_timeout_cb,\n+                                           &timeout_data, 1000 /* milliseconds */, 0,\n+                                           WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD)) {\n                     // Failed to register wait, proceed without timeout protection\n-                    hWaitHandle = NULL;\n+                    hTimer = NULL;\n                 }\n #endif\n+\n                 // Get backtrace data\n                 profile_bt_size_cur += rec_backtrace_ctx((jl_bt_element_t*)profile_bt_data_prof + profile_bt_size_cur,\n                         profile_bt_size_max - profile_bt_size_cur - 1, &c, NULL);\n #ifdef _CPU_X86_64_\n                 // Clear abort pointer from TLS\n                 jl_set_profile_abort_ptr(NULL);\n                 // Wait for callback to complete or cancel before continuing\n-                if (hWaitHandle != NULL)\n-                    UnregisterWaitEx(hWaitHandle, INVALID_HANDLE_VALUE);\n+                if (hTimer != NULL)\n+                    DeleteTimerQueueTimer(hTimerQueue, hTimer, INVALID_HANDLE_VALUE);\n                 if (timeout_data.tid != -1)\n-#endif\n                     jl_thread_resume(tid);\n+#else\n+                jl_thread_resume(tid);\n+#endif\n \n                 // META_OFFSET_THREADID store threadid but add 1 as 0 is preserved to indicate end of block\n                 profile_bt_data_prof[profile_bt_size_cur++].uintptr = tid + 1;\n@@ -575,7 +578,7 @@ static DWORD WINAPI profile_bt( LPVOID lparam )\n     hBtThread = NULL;\n     uv_mutex_unlock(&bt_data_prof_lock);\n     jl_profile_stop_timer();\n-    CloseHandle(hProfileEvent);\n+    DeleteTimerQueue(hTimerQueue);\n     return 0;\n }\n "
    }
  ]
}