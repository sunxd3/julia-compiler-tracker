{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60191",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60191/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60191/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60191/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60191",
  "id": 3652716976,
  "node_id": "PR_kwDOABkWpM604bWe",
  "number": 60191,
  "title": "[JuliaLowering] Tidy up node creation functions",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 250223102,
      "node_id": "MDU6TGFiZWwyNTAyMjMxMDI=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:lowering",
      "name": "compiler:lowering",
      "color": "5319e7",
      "default": false,
      "description": "Syntax lowering (compiler front end, 2nd stage)"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 2,
  "created_at": "2025-11-21T18:40:08Z",
  "updated_at": "2025-12-19T18:24:31Z",
  "closed_at": "2025-12-03T21:45:48Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60191",
    "html_url": "https://github.com/JuliaLang/julia/pull/60191",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60191.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60191.patch",
    "merged_at": "2025-12-03T21:45:48Z"
  },
  "body": "We currently use keyword arguments as arbitrary key-value pairs in a number of\r\n     places, which I've realized isn't really how they're intended to be used.\r\n      This change fixes this and reduces the JuliaLowering package image size by\r\n     about 20% on my machine from `26.910 MiB -> 21.701 MiB`, or when compiled\r\n     into sysbase.dylib, `+55MB -> +45MB`.  Unfortunately no change to\r\n     precompile time as I had hoped, but I figured this is worth doing anyway.\r\n     Lowering performance looks unchanged.\r\n\r\nI've just used `Vector{Pair}` or explicit `setattr` calls, but let me know if\r\n     there's a better way of doing this.\r\n\r\nAlso let me know if you have a reason for the difference in size when compiled\r\n     into Base---I don't think I'm accidentally producing two copies, but you\r\n     never know.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60191/reactions",
    "total_count": 2,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 2,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60191/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "4588517906b88a73e5a7bba2fc1eb9940052cc8b",
      "filename": "JuliaLowering/src/ast.jl",
      "status": "modified",
      "additions": 86,
      "deletions": 70,
      "changes": 156,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fast.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fast.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fast.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -126,48 +126,53 @@ function _append_nodeids!(graph::SyntaxGraph, ids::Vector{NodeId}, vals::SyntaxL\n     append!(ids, vals.ids)\n end\n \n-function makeleaf(graph::SyntaxGraph, srcref, proto; attrs...)\n+# TODO: \"proto\", if SyntaxTree, is rarely different from srcref. reorganize to:\n+# newnode/newleaf(ctx, srcref, k::Kind[, attrs])\n+# makenode/makeleaf(ctx, old::SyntaxTree[, attrs])\n+\n+function makeleaf(graph::SyntaxGraph, srcref, proto::Union{Kind, SyntaxTree})\n     id = newnode!(graph)\n     ex = SyntaxTree(graph, id)\n     copy_attrs!(ex, proto, true)\n-    setattr!(graph, id; source=_unpack_srcref(graph, srcref), attrs...)\n+    ex.source = _unpack_srcref(graph, srcref)\n     return ex\n end\n \n-function _makenode(graph::SyntaxGraph, srcref, proto, children; attrs...)\n-    id = newnode!(graph)\n-    setchildren!(graph, id, children)\n-    ex = SyntaxTree(graph, id)\n-    copy_attrs!(ex, proto, true)\n-    setattr!(graph, id; source=_unpack_srcref(graph, srcref), attrs...)\n-    return SyntaxTree(graph, id)\n-end\n-function _makenode(ctx, srcref, proto, children; attrs...)\n-    _makenode(syntax_graph(ctx), srcref, proto, children; attrs...)\n+function makeleaf(ctx::AbstractLoweringContext, srcref, proto)\n+    makeleaf(syntax_graph(ctx), srcref, proto)\n end\n \n-function makenode(ctx, srcref, proto, children...; attrs...)\n-    _makenode(ctx, srcref, proto, _node_ids(syntax_graph(ctx), children...); attrs...)\n+function makeleaf(ctx, srcref, proto, @nospecialize(attrs::AbstractVector))\n+    graph = syntax_graph(ctx)\n+    ex = makeleaf(graph, srcref, proto)\n+    for (k, v) in attrs\n+        setattr!(graph, ex._id, k, v)\n+    end\n+    return ex\n end\n \n-function makeleaf(ctx, srcref, proto; kws...)\n-    makeleaf(syntax_graph(ctx), srcref, proto; kws...)\n+function makenode(ctx, srcref, proto, children, attrs=nothing)\n+    graph = syntax_graph(ctx)\n+    ex = isnothing(attrs) ? makeleaf(graph, srcref, proto) :\n+        makeleaf(graph, srcref, proto, attrs)\n+    setchildren!(graph, ex._id, children isa SyntaxList ? children.ids : children)\n+    return ex\n end\n \n-function makeleaf(ctx, srcref, k::Kind, value; kws...)\n-    graph = syntax_graph(ctx)\n+function newleaf(ctx, srcref, k::Kind, @nospecialize(value))\n+    leaf = makeleaf(ctx, srcref, k)\n     if k == K\"Identifier\" || k == K\"core\" || k == K\"top\" || k == K\"Symbol\" ||\n             k == K\"globalref\" || k == K\"Placeholder\" ||\n             k == K\"StrMacroName\" || k == K\"CmdMacroName\"\n-        makeleaf(graph, srcref, k; name_val=value, kws...)\n+        setattr!(leaf._graph, leaf._id, :name_val, value)\n     elseif k == K\"BindingId\"\n-        makeleaf(graph, srcref, k; var_id=value, kws...)\n+        setattr!(leaf._graph, leaf._id, :var_id, value)\n     elseif k == K\"label\"\n-        makeleaf(graph, srcref, k; id=value, kws...)\n+        setattr!(leaf._graph, leaf._id, :id, value)\n     elseif k == K\"symbolic_label\"\n-        makeleaf(graph, srcref, k; name_val=value, kws...)\n+        setattr!(leaf._graph, leaf._id, :name_val, value)\n     elseif k in KSet\"TOMBSTONE SourceLocation latestworld latestworld_if_toplevel\"\n-        makeleaf(graph, srcref, k; kws...)\n+        # no attributes\n     else\n         val = k == K\"Integer\" ? convert(Int,     value) :\n               k == K\"Float\"   ? convert(Float64, value) :\n@@ -177,8 +182,9 @@ function makeleaf(ctx, srcref, k::Kind, value; kws...)\n               k == K\"Bool\"    ? value                   :\n               k == K\"VERSION\" ? value                   :\n               error(\"Unexpected leaf kind `$k`\")\n-        makeleaf(graph, srcref, k; value=val, kws...)\n+        setattr!(leaf._graph, leaf._id, :value, val)\n     end\n+    leaf\n end\n \n # TODO: Replace this with makeleaf variant?\n@@ -192,7 +198,7 @@ end\n \n # Convenience functions to create leaf nodes referring to identifiers within\n # the Core and Top modules.\n-core_ref(ctx, ex, name) = makeleaf(ctx, ex, K\"core\", name)\n+core_ref(ctx, ex, name) = newleaf(ctx, ex, K\"core\", name)\n svec_type(ctx, ex) = core_ref(ctx, ex, \"svec\")\n nothing_(ctx, ex) = core_ref(ctx, ex, \"nothing\")\n \n@@ -202,7 +208,7 @@ top_ref(ctx, ex, name) = makeleaf(ctx, ex, K\"top\", name)\n # Return (variable, assignment_node)\n function assign_tmp(ctx::AbstractLoweringContext, ex, name=\"tmp\")\n     var = ssavar(ctx, ex, name)\n-    assign_var = makenode(ctx, ex, K\"=\", var, ex)\n+    assign_var = makenode(ctx, ex, K\"=\", NodeId[var._id, ex._id])\n     var, assign_var\n end\n \n@@ -211,7 +217,7 @@ function emit_assign_tmp(stmts::SyntaxList, ctx, ex, name=\"tmp\")\n         return ex\n     end\n     var = ssavar(ctx, ex, name)\n-    push!(stmts, makenode(ctx, ex, K\"=\", var, ex))\n+    push!(stmts, makenode(ctx, ex, K\"=\", NodeId[var._id, ex._id]))\n     var\n end\n \n@@ -225,31 +231,38 @@ function _match_srcref(ex)\n     end\n end\n \n-function _match_kind(f::Function, srcref, ex)\n+function _kw_to_pair(ex)\n+    if ex isa Expr && ex.head === :kw && ex.args[1] isa Symbol\n+        (QuoteNode(ex.args[1]), esc(ex.args[2]))\n+    elseif ex isa Symbol\n+        (QuoteNode(ex), esc(ex))\n+    else\n+        @assert false \"invalid keyword form in @ast $ex\"\n+    end\n+end\n+\n+function _match_kind(srcref, ex)\n     kws = []\n     if Meta.isexpr(ex, :call)\n         kind = esc(ex.args[1])\n         args = ex.args[2:end]\n         if Meta.isexpr(args[1], :parameters)\n-            kws = map(esc, args[1].args)\n+            kws = map(_kw_to_pair, args[1].args)\n             popfirst!(args)\n         end\n         while length(args) >= 1 && Meta.isexpr(args[end], :kw)\n-            pushfirst!(kws, esc(pop!(args)))\n+            pushfirst!(kws, _kw_to_pair(pop!(args)))\n         end\n         if length(args) == 1\n             srcref_tmp = gensym(\"srcref\")\n-            return quote\n-                $srcref_tmp = $(_match_srcref(args[1]))\n-                $(f(kind, srcref_tmp, kws))\n-            end\n+            return (kind, _match_srcref(args[1]), kws)\n         elseif length(args) > 1\n             error(\"Unexpected: extra srcref argument in `$ex`?\")\n         end\n     else\n         kind = esc(ex)\n     end\n-    f(kind, srcref, kws)\n+    return (kind, srcref, kws)\n end\n \n function _expand_ast_tree(ctx, srcref, tree)\n@@ -262,8 +275,12 @@ function _expand_ast_tree(ctx, srcref, tree)\n             val = nothing\n             kindspec = tree.args[1]\n         end\n-        _match_kind(srcref, kindspec) do kind, srcref, kws\n-            :(makeleaf($ctx, $srcref, $kind, $(val), $(kws...)))\n+        let (kind, srcref, kws) = _match_kind(srcref, kindspec)\n+            n = :(newleaf($ctx, $srcref, $kind, $val))\n+            for (attr, val) in kws\n+                n = :(setattr!($n, $attr, $val))\n+            end\n+            n\n         end\n     elseif Meta.isexpr(tree, :call) && tree.args[1] === :(=>)\n         # Leaf node with copied attributes\n@@ -292,8 +309,12 @@ function _expand_ast_tree(ctx, srcref, tree)\n             end\n         end\n         push!(child_stmts, :(child_ids))\n-        _match_kind(srcref, flatargs[1]) do kind, srcref, kws\n-            :(_makenode($ctx, $srcref, $kind, $children_ex; $(kws...)))\n+        let (kind, srcref, kws) = _match_kind(srcref, flatargs[1])\n+            n = :(makenode($ctx, $srcref, $kind, $children_ex))\n+            for (attr, val) in kws\n+                n = :(setattr!($n, $attr, $val))\n+            end\n+            n\n         end\n     elseif Meta.isexpr(tree, :(:=))\n         lhs = tree.args[1]\n@@ -389,17 +410,17 @@ end\n \n function copy_attrs!(dest, head::Union{Kind,JuliaSyntax.SyntaxHead}, all=false)\n     if all\n-        sethead!(dest._graph, dest._id, head)\n+        setattr!(dest._graph, dest._id, :kind, kind(head))\n+        !(head isa Kind) && setattr!(dest._graph, dest._id, :syntax_flags, flags(head))\n     end\n end\n \n-function mapchildren(f::Function, ctx, ex::SyntaxTree, do_map_child::Function;\n-                     extra_attrs...)\n+function mapchildren(f::Function, ctx, ex::SyntaxTree, do_map_child::Function)\n     if is_leaf(ex)\n         return ex\n     end\n     orig_children = children(ex)\n-    cs = isempty(extra_attrs) ? nothing : SyntaxList(ctx)\n+    cs = nothing\n     for (i,e) in enumerate(orig_children)\n         newchild = do_map_child(i) ? f(e) : e\n         if isnothing(cs)\n@@ -418,14 +439,12 @@ function mapchildren(f::Function, ctx, ex::SyntaxTree, do_map_child::Function;\n         return ex\n     end\n     cs::SyntaxList\n-    ex2 = makenode(ctx, ex, head(ex), cs)\n-    copy_attrs!(ex2, ex)\n-    setattr!(ex2; extra_attrs...)\n+    ex2 = makenode(ctx, ex, ex, cs)\n     return ex2\n end\n \n-function mapchildren(f::Function, ctx, ex::SyntaxTree, mapped_children::AbstractVector{<:Integer};\n-                     extra_attrs...)\n+function mapchildren(f::Function, ctx, ex::SyntaxTree,\n+                     mapped_children::AbstractVector{<:Integer})\n     j = Ref(firstindex(mapped_children))\n     function do_map_child(i)\n         ind = j[]\n@@ -436,11 +455,11 @@ function mapchildren(f::Function, ctx, ex::SyntaxTree, mapped_children::Abstract\n             false\n         end\n     end\n-    mapchildren(f, ctx, ex, do_map_child; extra_attrs...)\n+    mapchildren(f, ctx, ex, do_map_child)\n end\n \n-function mapchildren(f::Function, ctx, ex::SyntaxTree; extra_attrs...)\n-    mapchildren(f, ctx, ex, i->true; extra_attrs...)\n+function mapchildren(f::Function, ctx, ex::SyntaxTree)\n+    mapchildren(f, ctx, ex, i->true)\n end\n \n \n@@ -477,7 +496,7 @@ function _copy_ast(graph2::SyntaxGraph, graph1::SyntaxGraph,\n         src1\n     end\n     copy_attrs!(SyntaxTree(graph2, id2), SyntaxTree(graph1, id1), true)\n-    setattr!(graph2, id2; source=src2)\n+    setattr!(graph2, id2, :source, src2)\n     if !is_leaf(graph1, id1)\n         cs = NodeId[]\n         for cid in children(graph1, id1)\n@@ -491,20 +510,19 @@ end\n #-------------------------------------------------------------------------------\n function set_scope_layer(ctx, ex, layer_id, force)\n     k = kind(ex)\n-    scope_layer = force ? layer_id : get(ex, :scope_layer, layer_id)\n-    if k == K\"module\" || k == K\"toplevel\" || k == K\"inert\"\n-        makenode(ctx, ex, ex, children(ex);\n-                 scope_layer=scope_layer)\n+    new_layer = force ? layer_id : get(ex, :scope_layer, layer_id)\n+\n+    ex2 = if k == K\"module\" || k == K\"toplevel\" || k == K\"inert\"\n+        makenode(ctx, ex, ex, children(ex))\n     elseif k == K\".\"\n-        makenode(ctx, ex, ex, set_scope_layer(ctx, ex[1], layer_id, force), ex[2],\n-                 scope_layer=scope_layer)\n+        children = NodeId[set_scope_layer(ctx, ex[1], layer_id, force), ex[2]]\n+        makenode(ctx, ex, ex, children)\n     elseif !is_leaf(ex)\n-        mapchildren(e->set_scope_layer(ctx, e, layer_id, force), ctx, ex;\n-                    scope_layer=scope_layer)\n+        mapchildren(e->set_scope_layer(ctx, e, layer_id, force), ctx, ex)\n     else\n-        makeleaf(ctx, ex, ex;\n-                 scope_layer=scope_layer)\n+        makeleaf(ctx, ex, ex)\n     end\n+    setattr!(ex2, :scope_layer, new_layer)\n end\n \n \"\"\"\n@@ -513,7 +531,7 @@ end\n Copy `ex`, adopting the scope layer of `ref`.\n \"\"\"\n function adopt_scope(ex::SyntaxTree, scope_layer::LayerId)\n-    set_scope_layer(ex, ex, scope_layer, true)\n+    set_scope_layer(ex._graph, ex, scope_layer, true)\n end\n \n function adopt_scope(ex::SyntaxTree, layer::ScopeLayer)\n@@ -539,19 +557,17 @@ end\n # the middle of a pass.\n const CompileHints = Base.ImmutableDict{Symbol,Any}\n \n-function setmeta!(ex::SyntaxTree; kws...)\n-    @assert length(kws) == 1 # todo relax later ?\n-    key = first(keys(kws))\n-    value = first(values(kws))\n+function setmeta!(ex::SyntaxTree, key::Symbol, @nospecialize(val))\n     meta = begin\n         m = get(ex, :meta, nothing)\n-        isnothing(m) ? CompileHints(key, value) : CompileHints(m, key, value)\n+        isnothing(m) ? CompileHints(key, val) : CompileHints(m, key, val)\n     end\n-    setattr!(ex; meta=meta)\n+    setattr!(ex, :meta, meta)\n     ex\n end\n \n-setmeta(ex::SyntaxTree; kws...) = setmeta!(copy_node(ex); kws...)\n+setmeta(ex::SyntaxTree, k::Symbol, @nospecialize(v)) =\n+    setmeta!(copy_node(ex), k, v)\n \n function getmeta(ex::SyntaxTree, name::Symbol, default)\n     meta = get(ex, :meta, nothing)"
    },
    {
      "sha": "f07eb166beb159d2c95a3a9b28f8227f393bdaf7",
      "filename": "JuliaLowering/src/bindings.jl",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fbindings.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fbindings.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fbindings.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -151,14 +151,16 @@ end\n \n # Create a new SSA binding\n function ssavar(ctx::AbstractLoweringContext, srcref, name=\"tmp\")\n-    nameref = makeleaf(ctx, srcref, K\"Identifier\", name_val=name)\n+    nameref = makeleaf(ctx, srcref, K\"Identifier\")\n+    nameref.name_val = name\n     new_binding(ctx, nameref, name, :local; is_ssa=true, is_internal=true)\n end\n \n # Create a new local mutable binding or lambda argument\n function new_local_binding(ctx::AbstractLoweringContext, srcref, name; kind=:local, kws...)\n     @assert kind === :local || kind === :argument\n-    nameref = makeleaf(ctx, srcref, K\"Identifier\", name_val=name)\n+    nameref = makeleaf(ctx, srcref, K\"Identifier\")\n+    nameref.name_val = name\n     ex = new_binding(ctx, nameref, name, kind; is_internal=true, kws...)\n     lbindings = current_lambda_bindings(ctx)\n     if !isnothing(lbindings)\n@@ -168,7 +170,8 @@ function new_local_binding(ctx::AbstractLoweringContext, srcref, name; kind=:loc\n end\n \n function new_global_binding(ctx::AbstractLoweringContext, srcref, name, mod; kws...)\n-    nameref = makeleaf(ctx, srcref, K\"Identifier\", name_val=name)\n+    nameref = makeleaf(ctx, srcref, K\"Identifier\")\n+    nameref.name_val = name\n     new_binding(ctx, nameref, name, :global; is_internal=true, mod=mod, kws...)\n end\n "
    },
    {
      "sha": "1cf199066a3706a5dc3d543587f8e7e840e6afd2",
      "filename": "JuliaLowering/src/closure_conversion.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fclosure_conversion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fclosure_conversion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fclosure_conversion.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -593,7 +593,7 @@ function closure_convert_lambda(ctx, ex)\n         push!(lambda_children, _convert_closures(ctx2, ex[4]))\n     end\n \n-    lam = makenode(ctx, ex, ex, lambda_children; lambda_bindings=lambda_bindings)\n+    lam = makenode(ctx, ex, ex, lambda_children, [:lambda_bindings=>lambda_bindings])\n     if !isnothing(interpolations) && !isempty(interpolations)\n         @ast ctx ex [K\"call\"\n             replace_captured_locals!::K\"Value\""
    },
    {
      "sha": "25b73e08fde660cc8327392232bd4e81f43f1ef8",
      "filename": "JuliaLowering/src/compat.jl",
      "status": "modified",
      "additions": 15,
      "deletions": 12,
      "changes": 27,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fcompat.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -1,11 +1,14 @@\n const JS = JuliaSyntax\n \n function _insert_tree_node(graph::SyntaxGraph, k::Kind, src::SourceAttrType,\n-                           flags::UInt16=0x0000; attrs...)\n+                           attrs=[], flags::UInt16=0x0000)\n     id = newnode!(graph)\n-    sethead!(graph, id, k)\n-    flags !== 0 && setflags!(graph, id, flags)\n-    setattr!(graph, id; source=src, attrs...)\n+    setattr!(graph, id, :kind, k)\n+    flags !== 0 && setattr!(graph, id, :syntax_flags, flags)\n+    setattr!(graph, id, :source, src)\n+    for (k,v) in attrs\n+        setattr!(graph, id, k, v)\n+    end\n     return id\n end\n \n@@ -184,28 +187,28 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n     #---------------------------------------------------------------------------\n     # Non-expr types\n     if isnothing(e)\n-        st_id = _insert_tree_node(graph, K\"core\", src; name_val=\"nothing\")\n+        st_id = _insert_tree_node(graph, K\"core\", src, [:name_val=>\"nothing\"])\n         return st_id, src\n     elseif e isa LineNumberNode\n         # A LineNumberNode in value position evaluates to nothing\n-        st_id = _insert_tree_node(graph, K\"core\", src; name_val=\"nothing\")\n+        st_id = _insert_tree_node(graph, K\"core\", src, [:name_val=>\"nothing\"])\n         return st_id, e\n     elseif e isa Symbol\n-        st_id = _insert_tree_node(graph, K\"Identifier\", src; name_val=String(e))\n+        st_id = _insert_tree_node(graph, K\"Identifier\", src, [:name_val=>String(e)])\n         return st_id, src\n     elseif e isa QuoteNode\n         if e.value isa Symbol\n             return _insert_convert_expr(Expr(:quoted_symbol, e.value), graph, src)\n         elseif e.value isa Expr\n             return _insert_convert_expr(Expr(:inert, e.value), graph, src)\n         elseif e.value isa LineNumberNode\n-            return _insert_tree_node(graph, K\"Value\", src; value=e.value), src\n+            return _insert_tree_node(graph, K\"Value\", src, [:value=>e.value]), src\n         else\n             return _insert_convert_expr(e.value, graph, src)\n         end\n     elseif e isa String\n         st_id = _insert_tree_node(graph, K\"string\", src)\n-        id_inner = _insert_tree_node(graph, K\"String\", src; value=e)\n+        id_inner = _insert_tree_node(graph, K\"String\", src, [:value=>e])\n         setchildren!(graph, st_id, [id_inner])\n         return st_id, src\n     elseif !(e isa Expr)\n@@ -214,7 +217,7 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n         st_k = e isa Bool ? K\"Bool\" :\n             e isa Integer ? K\"Integer\" :\n             find_kind(string(typeof(e)))\n-        st_id = _insert_tree_node(graph, isnothing(st_k) ? K\"Value\" : st_k, src; value=e)\n+        st_id = _insert_tree_node(graph, isnothing(st_k) ? K\"Value\" : st_k, src, [:value=>e])\n         return st_id, src\n     end\n \n@@ -497,7 +500,7 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n         @assert e.args[1] isa Symbol\n         @assert e.args[2] isa LayerId\n         st_id, src = _insert_convert_expr(e.args[1], graph, src)\n-        setattr!(graph, st_id, scope_layer=e.args[2])\n+        setattr!(graph, st_id, :scope_layer, e.args[2])\n         return st_id, src\n     elseif e.head === :symbolicgoto || e.head === :symboliclabel\n         @assert nargs === 1\n@@ -576,7 +579,7 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n         return nothing, src\n     end\n \n-    st_id = _insert_tree_node(graph, st_k, src, st_flags; st_attrs...)\n+    st_id = _insert_tree_node(graph, st_k, src, collect(st_attrs), st_flags)\n \n     # child_exprs === nothing means we want a leaf.  Note that setchildren! with\n     # an empty list makes a node non-leaf."
    },
    {
      "sha": "16f2c929d1ef28c824b2bacff79273f1eee00769",
      "filename": "JuliaLowering/src/desugaring.jl",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fdesugaring.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fdesugaring.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -2166,9 +2166,9 @@ function make_lhs_decls(ctx, stmts, declkind, declmeta, ex, type_decls=true)\n         # other Exprs that cannot be produced by the parser (tested by\n         # test/precompile.jl #50538).\n         if !isnothing(declmeta)\n-            push!(stmts, makenode(ctx, ex, declkind, ex; meta=declmeta))\n+            push!(stmts, makenode(ctx, ex, declkind, NodeId[ex._id], [:meta=>declmeta]))\n         else\n-            push!(stmts, makenode(ctx, ex, declkind, ex))\n+            push!(stmts, makenode(ctx, ex, declkind, NodeId[ex._id]))\n         end\n     elseif k == K\"Placeholder\"\n         nothing\n@@ -2177,7 +2177,7 @@ function make_lhs_decls(ctx, stmts, declkind, declmeta, ex, type_decls=true)\n             @chk numchildren(ex) == 2\n             name = ex[1]\n             if kind(name) == K\"Identifier\"\n-                push!(stmts, makenode(ctx, ex, K\"decl\", name, ex[2]))\n+                push!(stmts, makenode(ctx, ex, K\"decl\", NodeId[name._id, ex[2]._id]))\n             else\n                 # TODO: Currently, this ignores the LHS in `_::T = val`.\n                 # We should probably do one of the following:\n@@ -2516,7 +2516,7 @@ function expand_function_generator(ctx, srcref, callex_srcref, func_name, func_n\n     # Apply nospecialize to all arguments to prevent so much codegen and add\n     # Core.Any type for them\n     for i in first_trailing_arg:length(gen_arg_names)\n-        gen_arg_names[i] = setmeta(gen_arg_names[i]; nospecialize=true)\n+        gen_arg_names[i] = setmeta(gen_arg_names[i], :nospecialize, true)\n         push!(gen_arg_types, @ast ctx gen_arg_names[i] \"Any\"::K\"core\")\n     end\n     # Code generator definition"
    },
    {
      "sha": "73f88d0b23d0bd7142689384bd4ead0aa5981784",
      "filename": "JuliaLowering/src/eval.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Feval.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Feval.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Feval.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -532,3 +532,5 @@ function include_string(mod::Module, code::AbstractString, filename::AbstractStr\n                         expr_compat_mode=false)\n     eval(mod, parseall(SyntaxTree, code; filename=filename); expr_compat_mode)\n end\n+\n+include(path::AbstractString) = include(JuliaLowering, path)"
    },
    {
      "sha": "a2448cb2971077e3202084dd74e3bbaa28e9394e",
      "filename": "JuliaLowering/src/linear_ir.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 10,
      "changes": 17,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Flinear_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Flinear_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Flinear_ir.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -173,10 +173,6 @@ function emit(ctx::LinearIRContext, ex)\n     return ex\n end\n \n-function emit(ctx::LinearIRContext, srcref, k, args...)\n-    emit(ctx, makenode(ctx, srcref, k, args...))\n-end\n-\n # Emit computation of ex, assigning the result to an ssavar and returning that\n function emit_assign_tmp(ctx::LinearIRContext, ex, name=\"tmp\")\n     tmp = ssavar(ctx, ex, name)\n@@ -328,7 +324,7 @@ function emit_simple_assignment(ctx, srcref, lhs, rhs, op=K\"=\")\n             rhs\n         ])\n     else\n-        emit(ctx, srcref, op, lhs, rhs)\n+        emit(ctx, @ast ctx srcref [op lhs rhs])\n     end\n end\n \n@@ -351,7 +347,7 @@ end\n function make_label(ctx, srcref)\n     id = ctx.next_label_id[]\n     ctx.next_label_id[] += 1\n-    makeleaf(ctx, srcref, K\"label\", id=id)\n+    makeleaf(ctx, srcref, K\"label\", [:id=>id])\n end\n \n # flisp: make&mark-label\n@@ -773,7 +769,7 @@ function compile(ctx::LinearIRContext, ex, needs_value, in_tail_pos)\n             else\n                 lam = emit_assign_tmp(ctx, compile(ctx, lam, true, false))\n             end\n-            emit(ctx, ex, K\"method\", fname, sig, lam)\n+            emit(ctx, @ast ctx ex [K\"method\" fname sig lam])\n             @assert !needs_value && !in_tail_pos\n             nothing\n         end\n@@ -970,20 +966,21 @@ function _renumber(ctx, ssa_rewrites, slot_rewrites, label_table, ex)\n     if k == K\"BindingId\"\n         id = ex.var_id\n         if haskey(ssa_rewrites, id)\n-            makeleaf(ctx, ex, K\"SSAValue\"; var_id=ssa_rewrites[id])\n+            makeleaf(ctx, ex, K\"SSAValue\", [:var_id=>ssa_rewrites[id]])\n         else\n             new_id = get(slot_rewrites, id, nothing)\n             binfo = lookup_binding(ctx, id)\n             if !isnothing(new_id)\n                 sk = binfo.kind == :local || binfo.kind == :argument ? K\"slot\"             :\n                      binfo.kind == :static_parameter                 ? K\"static_parameter\" :\n                      throw(LoweringError(ex, \"Found unexpected binding of kind $(binfo.kind)\"))\n-                makeleaf(ctx, ex, sk; var_id=new_id)\n+                makeleaf(ctx, ex, sk, [:var_id=>new_id])\n             else\n                 if binfo.kind !== :global\n                     throw(LoweringError(ex, \"Found unexpected binding of kind $(binfo.kind)\"))\n                 end\n-                makeleaf(ctx, ex, K\"globalref\", binfo.name, mod=binfo.mod)\n+                makeleaf(ctx, ex, K\"globalref\",\n+                         [:name_val=>binfo.name, :mod=>binfo.mod])\n             end\n         end\n     elseif k == K\"meta\" || k == K\"static_eval\""
    },
    {
      "sha": "61d76719d4fa61768e6b2abfa4a542a0f1cfbc3f",
      "filename": "JuliaLowering/src/macro_expansion.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fmacro_expansion.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -143,15 +143,16 @@ function fixup_macro_name(ctx::MacroExpansionContext, ex::SyntaxTree)\n     if k == K\"StrMacroName\" || k == K\"CmdMacroName\"\n         layerid = get(ex, :scope_layer, current_layer_id(ctx))\n         newname = JuliaSyntax.lower_identifier_name(ex.name_val, k)\n-        makeleaf(ctx, ex, ex, kind=K\"Identifier\", scope_layer=layerid, name_val=newname)\n+        makeleaf(ctx, ex, ex, [:kind=>K\"Identifier\", :scope_layer=>layerid,\n+                               :name_val=>newname])\n     elseif k == K\"macro_name\"\n         @chk numchildren(ex) === 1\n         if kind(ex[1]) === K\".\"\n             @ast ctx ex [K\".\" ex[1][1] [K\"macro_name\" ex[1][2]]]\n         else\n             layerid = get(ex, :scope_layer, current_layer_id(ctx))\n             newname = JuliaSyntax.lower_identifier_name(ex[1].name_val, K\"macro_name\")\n-            makeleaf(ctx, ex[1], ex[1], kind=kind(ex[1]), name_val=newname)\n+            makeleaf(ctx, ex[1], ex[1], [:kind=>kind(ex[1]), :name_val=>newname])\n         end\n     else\n         mapchildren(e->fixup_macro_name(ctx,e), ctx, ex)\n@@ -215,7 +216,7 @@ function set_macro_arg_hygiene(ctx, ex, layer_ids, layer_idx)\n     k = kind(ex)\n     scope_layer = get(ex, :scope_layer, layer_ids[layer_idx])\n     if is_leaf(ex)\n-        makeleaf(ctx, ex, ex; scope_layer=scope_layer)\n+        makeleaf(ctx, ex, ex, [:scope_layer=>scope_layer])\n     else\n         inner_layer_idx = layer_idx\n         if k == K\"escape\"\n@@ -229,8 +230,9 @@ function set_macro_arg_hygiene(ctx, ex, layer_ids, layer_idx)\n                 throw(MacroExpansionError(ex, \"`escape` node in outer context\"))\n             end\n         end\n-        mapchildren(e->set_macro_arg_hygiene(ctx, e, layer_ids, inner_layer_idx),\n-                    ctx, ex; scope_layer=scope_layer)\n+        node = mapchildren(e->set_macro_arg_hygiene(\n+            ctx, e, layer_ids, inner_layer_idx), ctx, ex)\n+        setattr!(node, :scope_layer, scope_layer)\n     end\n end\n \n@@ -380,10 +382,10 @@ function append_sourceref(ctx, ex, secondary_prov)\n     srcref = (ex, secondary_prov)\n     if !is_leaf(ex)\n         if kind(ex) == K\"macrocall\"\n-            makenode(ctx, srcref, ex, children(ex)...)\n+            makenode(ctx, srcref, ex, children(ex))\n         else\n-            makenode(ctx, srcref, ex,\n-                     map(e->append_sourceref(ctx, e, secondary_prov), children(ex))...)\n+            cs = map(e->append_sourceref(ctx, e, secondary_prov)._id, children(ex))\n+            makenode(ctx, srcref, ex, cs)\n         end\n     else\n         makeleaf(ctx, srcref, ex)\n@@ -429,7 +431,7 @@ function expand_forms_1(ctx::MacroExpansionContext, ex::SyntaxTree)\n         else\n             k = all(==('_'), name_str) ? K\"Placeholder\" : K\"Identifier\"\n             scope_layer = get(ex, :scope_layer, current_layer_id(ctx))\n-            makeleaf(ctx, ex, ex; kind=k, scope_layer)\n+            makeleaf(ctx, ex, ex, [:kind=>k, :scope_layer=>scope_layer])\n         end\n     elseif k == K\"StrMacroName\" || k == K\"CmdMacroName\" || k == K\"macro_name\"\n         # These can appear outside of a macrocall, e.g. in `import`\n@@ -567,7 +569,8 @@ function expand_forms_1(ctx::MacroExpansionContext, ex::SyntaxTree)\n         # TODO: Should every form get layerid systematically? Or only the ones\n         # which expand_forms_2 needs?\n         layerid = get(ex, :scope_layer, current_layer_id(ctx))\n-        mapchildren(e->expand_forms_1(ctx,e), ctx, ex; scope_layer=layerid)\n+        setattr(mapchildren(e->expand_forms_1(ctx,e), ctx, ex),\n+                :scope_layer, layerid)\n     else\n         mapchildren(e->expand_forms_1(ctx,e), ctx, ex)\n     end"
    },
    {
      "sha": "50faef169e96fe30bc638c60100907212ffef07b",
      "filename": "JuliaLowering/src/runtime.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fruntime.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fruntime.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fruntime.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -63,9 +63,9 @@ function _interpolated_value(ctx::InterpolationContext, srcref, ex)\n         # Plain symbols become identifiers. This is an accommodation for\n         # compatibility to allow `:x` (a Symbol) and `:(x)` (a SyntaxTree) to\n         # be used interchangeably in macros.\n-        makeleaf(ctx, srcref, K\"Identifier\", string(ex))\n+        newleaf(ctx, srcref, K\"Identifier\", string(ex))\n     else\n-        makeleaf(ctx, srcref, K\"Value\", ex)\n+        newleaf(ctx, srcref, K\"Value\", ex)\n     end\n end\n "
    },
    {
      "sha": "2e16877aee70cf37b19e109d2cdd5e4befbd58b5",
      "filename": "JuliaLowering/src/syntax_graph.jl",
      "status": "modified",
      "additions": 27,
      "deletions": 39,
      "changes": 66,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fsyntax_graph.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -104,11 +104,8 @@ function newnode!(graph::SyntaxGraph)\n     return length(graph.edge_ranges)\n end\n \n-function setchildren!(graph::SyntaxGraph, id, children::NodeId...)\n-    setchildren!(graph, id, children)\n-end\n-\n-function setchildren!(graph::SyntaxGraph, id, children)\n+function setchildren!(graph::SyntaxGraph, id::NodeId,\n+                      children::AbstractVector{NodeId})\n     n = length(graph.edges)\n     graph.edge_ranges[id] = n+1:(n+length(children))\n     # TODO: Reuse existing edges if possible\n@@ -152,12 +149,11 @@ function hasattr(graph::SyntaxGraph, name::Symbol)\n end\n \n # TODO: Probably terribly non-inferable?\n-function setattr!(graph::SyntaxGraph, id; attrs...)\n-    for (k,v) in pairs(attrs)\n-        if !isnothing(v)\n-            getattr(graph, k)[id] = v\n-        end\n+function setattr!(graph::SyntaxGraph, id::NodeId, k::Symbol, @nospecialize(v))\n+    if !isnothing(v)\n+        getattr(graph, k)[id] = v\n     end\n+    id\n end\n \n function deleteattr!(graph::SyntaxGraph, id::NodeId, name::Symbol)\n@@ -172,19 +168,6 @@ function Base.getproperty(graph::SyntaxGraph, name::Symbol)\n     return getattr(graph, name)\n end\n \n-function sethead!(graph, id::NodeId, h::JuliaSyntax.SyntaxHead)\n-    sethead!(graph, id, kind(h))\n-    setflags!(graph, id, flags(h))\n-end\n-\n-function sethead!(graph, id::NodeId, k::Kind)\n-    graph.kind[id] = k\n-end\n-\n-function setflags!(graph, id::NodeId, f::UInt16)\n-    graph.syntax_flags[id] = f\n-end\n-\n \"\"\"\n     syntax_graph(ctx)\n \n@@ -225,8 +208,9 @@ function Base.getproperty(ex::SyntaxTree, name::Symbol)\n     end\n end\n \n-function Base.setproperty!(ex::SyntaxTree, name::Symbol, val)\n-    return setattr!(ex._graph, ex._id; name=>val)\n+function Base.setproperty!(ex::SyntaxTree, name::Symbol, @nospecialize(val))\n+    setattr!(ex._graph, ex._id, name, val)\n+    val\n end\n \n function Base.propertynames(ex::SyntaxTree)\n@@ -264,22 +248,19 @@ function copy_node(ex::SyntaxTree)\n     graph = syntax_graph(ex)\n     id = newnode!(graph)\n     if !is_leaf(ex)\n-        setchildren!(graph, id, _node_ids(graph, children(ex)...))\n+        setchildren!(graph, id, children(ex._graph, ex._id))\n     end\n     ex2 = SyntaxTree(graph, id)\n     copy_attrs!(ex2, ex, true)\n     ex2\n end\n \n-function setattr(ex::SyntaxTree; extra_attrs...)\n-    ex2 = copy_node(ex)\n-    setattr!(ex2; extra_attrs...)\n-    ex2\n-end\n-\n-function setattr!(ex::SyntaxTree; attrs...)\n-    setattr!(ex._graph, ex._id; attrs...)\n+function setattr!(ex::SyntaxTree, name::Symbol, @nospecialize(val))\n+    setattr!(ex._graph, ex._id, name, val)\n+    ex\n end\n+setattr(ex::SyntaxTree, name::Symbol, @nospecialize(val)) =\n+    setattr!(copy_node(ex), name, val)\n \n function deleteattr!(ex::SyntaxTree, name::Symbol)\n     deleteattr!(ex._graph, ex._id, name)\n@@ -709,9 +690,14 @@ end\n \n SyntaxList(graph::SyntaxGraph) = SyntaxList(graph, Vector{NodeId}())\n SyntaxList(ctx) = SyntaxList(syntax_graph(ctx))\n+SyntaxList(ctx, v::Vector{SyntaxTree}) =\n+    SyntaxList(syntax_graph(ctx), NodeId[x._id for x in v])\n \n syntax_graph(lst::SyntaxList) = lst.graph\n \n+setchildren!(graph::SyntaxGraph, id::NodeId, children::SyntaxList) =\n+    setchildren!(graph, id, children.ids)\n+\n Base.size(v::SyntaxList) = size(v.ids)\n \n Base.IndexStyle(::Type{<:SyntaxList}) = IndexLinear()\n@@ -853,8 +839,9 @@ function _insert_green(graph::SyntaxGraph, sf::SourceFile,\n                        txtbuf::Vector{UInt8}, offset::Int,\n                        cursor::RedTreeCursor)\n     id = newnode!(graph)\n-    sethead!(graph, id, head(cursor))\n-    setattr!(graph, id, source=SourceRef(sf, first_byte(cursor), last_byte(cursor)))\n+    setattr!(graph, id, :kind, kind(cursor))\n+    setattr!(graph, id, :syntax_flags, flags(cursor))\n+    setattr!(graph, id, :source, SourceRef(sf, first_byte(cursor), last_byte(cursor)))\n     if !is_leaf(cursor)\n         cs = NodeId[]\n         for c in reverse(cursor)\n@@ -865,9 +852,9 @@ function _insert_green(graph::SyntaxGraph, sf::SourceFile,\n         v = parse_julia_literal(txtbuf, head(cursor), byte_range(cursor) .+ offset)\n         if v isa Symbol\n             # TODO: Fixes in JuliaSyntax to avoid ever converting to Symbol\n-            setattr!(graph, id, name_val=string(v))\n+            setattr!(graph, id, :name_val, string(v))\n         elseif !isnothing(v)\n-            setattr!(graph, id, value=v)\n+            setattr!(graph, id, :value, v)\n         end\n     end\n     return id\n@@ -902,7 +889,8 @@ function _green_to_ast(parent::Kind, ex::SyntaxTree; eq_to_kw=false)\n         @assert length(cs) === 1\n         cs[1]\n     elseif k === K\"=\" && eq_to_kw\n-        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex)); kind=K\"kw\")\n+        setattr!(makenode(graph, ex, ex, _map_green_to_ast(k, children(ex))),\n+                 :kind, K\"kw\")\n     elseif is_leaf(ex)\n         return ex\n     else"
    },
    {
      "sha": "f8ff00600525b550720b0b6876678ec4fa5fea00",
      "filename": "JuliaLowering/src/syntax_macros.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fsyntax_macros.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Fsrc%2Fsyntax_macros.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fsyntax_macros.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -18,7 +18,7 @@\n function _apply_nospecialize(ctx, ex)\n     k = kind(ex)\n     if k == K\"Identifier\" || k == K\"Placeholder\" || k == K\"tuple\"\n-        setmeta(ex; nospecialize=true)\n+        setmeta(ex, :nospecialize, true)\n     elseif k == K\"...\" || k == K\"::\" || k == K\"=\" || k == K\"kw\"\n         # The @nospecialize macro is responsible for converting K\"=\" to K\"kw\".\n         # Desugaring uses this helper internally, so we may see K\"kw\" too."
    },
    {
      "sha": "9e625a62fe2651ee84e720e26dd6ad15c868d1bc",
      "filename": "JuliaLowering/test/compat.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Ftest%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Ftest%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fcompat.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -95,31 +95,31 @@ const JL = JuliaLowering\n             end\n             pre_st_flags = (JS.flags(st) & ~JS.INFIX_FLAG) | JS.PREFIX_CALL_FLAG\n             JL.setchildren!(st._graph, st._id, pre_st_args)\n-            JL.setflags!(st._graph, st._id, pre_st_flags)\n+            JL.setattr!(st._graph, st._id, :syntax_flags, pre_st_flags)\n         elseif JS.is_postfix_op_call(st) && (k === K\"call\" || k === K\"dotcall\")\n             pre_st_args = JL.NodeId[st[end]._id]\n             for c in st[1:end-1]\n                 push!(pre_st_args, c._id)\n             end\n             pre_st_flags = (JS.flags(st) & ~JS.POSTFIX_OP_FLAG) | JS.PREFIX_CALL_FLAG\n             JL.setchildren!(st._graph, st._id, pre_st_args)\n-            JL.setflags!(st._graph, st._id, pre_st_flags)\n+            JL.setattr!(st._graph, st._id, :syntax_flags, pre_st_flags)\n         elseif k in JS.KSet\"tuple block macrocall\"\n-            JL.setflags!(st._graph, st._id, JS.flags(st) & ~JS.PARENS_FLAG)\n+            JL.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.PARENS_FLAG)\n         elseif k === K\"toplevel\"\n-            JL.setflags!(st._graph, st._id, JS.flags(st) & ~JS.TOPLEVEL_SEMICOLONS_FLAG)\n+            JL.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.TOPLEVEL_SEMICOLONS_FLAG)\n         end\n \n         if k in JS.KSet\"tuple call dotcall macrocall vect curly braces <: >:\"\n-            JL.setflags!(st._graph, st._id, JS.flags(st) & ~JS.TRAILING_COMMA_FLAG)\n+            JL.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.TRAILING_COMMA_FLAG)\n         end\n \n-        k === K\"quote\" && JL.setflags!(st._graph, st._id, JS.flags(st) & ~JS.COLON_QUOTE)\n-        k === K\"wrapper\" && JL.sethead!(st._graph, st._id, K\"block\")\n+        k === K\"quote\" && JL.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) & ~JS.COLON_QUOTE)\n+        k === K\"wrapper\" && JL.setattr!(st._graph, st._id, :kind, K\"block\")\n \n         # All ops are prefix ops in an expr.\n         # Ignore trivia (shows up on some K\"error\"s)\n-        JL.setflags!(st._graph, st._id, JS.flags(st) &\n+        JL.setattr!(st._graph, st._id, :syntax_flags, JS.flags(st) &\n             ~JS.PREFIX_OP_FLAG & ~JS.INFIX_FLAG & ~JS.TRIVIA_FLAG & ~JS.NON_TERMINAL_FLAG)\n \n         for c in JS.children(st)"
    },
    {
      "sha": "d781ff66ad3d6006901d2de657fc2c34614e0f43",
      "filename": "JuliaLowering/test/scopes.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Ftest%2Fscopes.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Ftest%2Fscopes.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fscopes.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -62,7 +62,7 @@ end\n function wrapscope(ex, scope_type)\n     g = JuliaLowering.ensure_attributes(ex._graph, scope_type=Symbol)\n     ex = JuliaLowering.reparent(g, ex)\n-    makenode(ex, ex, K\"scope_block\", ex; scope_type=scope_type)\n+    makenode(g, ex, K\"scope_block\", [ex._id], [:scope_type=>scope_type])\n end\n \n assign_z_2 = parsestmt(SyntaxTree, \"begin z = 2 end\", filename=\"foo.jl\")"
    },
    {
      "sha": "e82e524e13342a1e54a27ef5500074c7c261e93d",
      "filename": "JuliaLowering/test/utils.jl",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/JuliaLang/julia/blob/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Ftest%2Futils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/3ab60a6e8a670e27b92e85a7a873d605f233b2ac/JuliaLowering%2Ftest%2Futils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Futils.jl?ref=3ab60a6e8a670e27b92e85a7a873d605f233b2ac",
      "patch": "@@ -17,7 +17,7 @@ using .JuliaSyntax: sourcetext, set_numeric_flags\n using .JuliaLowering:\n     SyntaxGraph, newnode!, ensure_attributes!,\n     Kind, SourceRef, SyntaxTree, NodeId,\n-    makenode, makeleaf, setattr!, sethead!,\n+    makenode, makeleaf, setattr!,\n     is_leaf, numchildren, children,\n     @ast, flattened_provenance, showprov, LoweringError, MacroExpansionError,\n     syntax_graph, Bindings, ScopeLayer, mapchildren\n@@ -33,8 +33,8 @@ end\n \n function _source_node(graph, src)\n     id = newnode!(graph)\n-    sethead!(graph, id, K\"None\")\n-    setattr!(graph, id, source=src)\n+    setattr!(graph, id, :kind, K\"None\")\n+    setattr!(graph, id, :source, src)\n     SyntaxTree(graph, id)\n end\n "
    }
  ]
}