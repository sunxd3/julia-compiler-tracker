{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60170",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60170/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60170/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60170/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60170",
  "id": 3640557876,
  "node_id": "PR_kwDOABkWpM60PV6t",
  "number": 60170,
  "title": "[JuliaLowering] Reconstruct macro name before, not during, macro expansion",
  "user": {
    "login": "mlechu",
    "id": 61633163,
    "node_id": "MDQ6VXNlcjYxNjMzMTYz",
    "avatar_url": "https://avatars.githubusercontent.com/u/61633163?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mlechu",
    "html_url": "https://github.com/mlechu",
    "followers_url": "https://api.github.com/users/mlechu/followers",
    "following_url": "https://api.github.com/users/mlechu/following{/other_user}",
    "gists_url": "https://api.github.com/users/mlechu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mlechu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mlechu/subscriptions",
    "organizations_url": "https://api.github.com/users/mlechu/orgs",
    "repos_url": "https://api.github.com/users/mlechu/repos",
    "events_url": "https://api.github.com/users/mlechu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mlechu/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 250223102,
      "node_id": "MDU6TGFiZWwyNTAyMjMxMDI=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/compiler:lowering",
      "name": "compiler:lowering",
      "color": "5319e7",
      "default": false,
      "description": "Syntax lowering (compiler front end, 2nd stage)"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-11-19T00:49:44Z",
  "updated_at": "2025-12-04T21:30:38Z",
  "closed_at": "2025-12-04T21:30:38Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60170",
    "html_url": "https://github.com/JuliaLang/julia/pull/60170",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60170.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60170.patch",
    "merged_at": "2025-12-04T21:30:38Z"
  },
  "body": "On top of https://github.com/JuliaLang/julia/pull/60162.  This simplification lets macro expansion handle the macro name as an identifier rather than the nonterminal `K\"macro_name\"` node.  That and the old `MacroName` node (as well as `CmdMacroName`, `StrMacroName`) are mainly the result of restrictions on raw parser output: we can't parse `@Base.x` to a non-contiguous `@x`, even though that's what we want in the AST in almost every case.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60170/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60170/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "924279f9d06541f48675d2e03848888beacec522",
      "filename": "JuliaLowering/src/ast.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Fsrc%2Fast.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Fsrc%2Fast.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fast.jl?ref=80b451f3dab95ed32fc481e2b723091d99c959f7",
      "patch": "@@ -162,8 +162,7 @@ end\n function newleaf(ctx, srcref, k::Kind, @nospecialize(value))\n     leaf = makeleaf(ctx, srcref, k)\n     if k == K\"Identifier\" || k == K\"core\" || k == K\"top\" || k == K\"Symbol\" ||\n-            k == K\"globalref\" || k == K\"Placeholder\" ||\n-            k == K\"StrMacroName\" || k == K\"CmdMacroName\"\n+            k == K\"globalref\" || k == K\"Placeholder\"\n         setattr!(leaf._graph, leaf._id, :name_val, value)\n     elseif k == K\"BindingId\"\n         setattr!(leaf._graph, leaf._id, :var_id, value)"
    },
    {
      "sha": "b8b91ad96ba22c543e7159ee63ccbc689b048f83",
      "filename": "JuliaLowering/src/compat.jl",
      "status": "modified",
      "additions": 7,
      "deletions": 25,
      "changes": 32,
      "blob_url": "https://github.com/JuliaLang/julia/blob/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Fsrc%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Fsrc%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fcompat.jl?ref=80b451f3dab95ed32fc481e2b723091d99c959f7",
      "patch": "@@ -267,14 +267,10 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n             src = child_exprs[2]\n         end\n         deleteat!(child_exprs, 2)\n-        if a1 isa Symbol\n-            child_exprs[1] = a1_esc(Expr(:macro_name, a1))\n-        elseif a1 isa Expr && a1.head === :(.)\n-            a12,a12_esc = unwrap_esc(a1.args[2])\n-            if a12 isa QuoteNode\n-                child_exprs[1] = a1_esc(Expr(:(.), a1.args[1],\n-                                             Expr(:macro_name, a12_esc(a12.value))))\n-            end\n+        if a1 isa Symbol && a1 === Symbol(\"@__dot__\")\n+            child_exprs[1] = Symbol(\"@.\")\n+        elseif a1 isa Expr && nargs === 2 && a1.args[2] === Symbol(\"@__dot__\")\n+            child_exprs[1] = Expr(a1.head, a1.args[1], Symbol(\"@.\"))\n         elseif a1 isa GlobalRef && a1.mod === Core\n             # Syntax-introduced macrocalls are listed here for reference.  We\n             # probably don't need to convert these.\n@@ -412,16 +408,15 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n         # (do (call f args...) (-> (tuple lam_args...) (block ...)))\n         # SyntaxTree:\n         # (call f args... (do (tuple lam_args...) (block ...)))\n-        callargs = collect_expr_parameters(e.args[1], 2)\n         if e.args[1].head === :macrocall\n             st_k = K\"macrocall\"\n+            callargs = collect_expr_parameters(e.args[1], 3)\n             if callargs[2] isa LineNumberNode\n                 src = callargs[2]\n             end\n             deleteat!(callargs, 2)\n-            c1,c1_esc = unwrap_esc(callargs[1])\n-            callargs[1] = c1_esc(Expr(:macro_name, c1))\n         else\n+            callargs = collect_expr_parameters(e.args[1], 2)\n             st_k = K\"call\"\n         end\n         child_exprs = Any[callargs..., Expr(:do_lambda, e.args[2].args...)]\n@@ -538,20 +533,7 @@ function _insert_convert_expr(@nospecialize(e), graph::SyntaxGraph, src::SourceA\n \n     #---------------------------------------------------------------------------\n     # Possibly-temporary heads introduced by us converting the parent expr\n-    if e.head === :macro_name\n-        @assert nargs === 1\n-        # Trim `@` for a correct SyntaxTree, although we need to add it back\n-        # later for finding the macro\n-        if e.args[1] === :(.)\n-            mac_name = string(e.args[1][2])\n-            mac_name = mac_name == \"@__dot__\" ? \".\" : mac_name[2:end]\n-            child_exprs[1] = Expr(:(.), e.args[1][1], Symbol(mac_name))\n-        else\n-            mac_name = string(e.args[1])\n-            mac_name = mac_name == \"@__dot__\" ? \".\" : mac_name[2:end]\n-            child_exprs[1] = Symbol(mac_name)\n-        end\n-    elseif e.head === :catch_var_placeholder\n+    if e.head === :catch_var_placeholder\n         st_k = K\"Placeholder\"\n         st_attrs[:name_val] = \"\"\n         child_exprs = nothing"
    },
    {
      "sha": "ebd85685db6cb41f734e1100f6f2023ff63efe18",
      "filename": "JuliaLowering/src/macro_expansion.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 27,
      "changes": 29,
      "blob_url": "https://github.com/JuliaLang/julia/blob/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Fsrc%2Fmacro_expansion.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fmacro_expansion.jl?ref=80b451f3dab95ed32fc481e2b723091d99c959f7",
      "patch": "@@ -138,27 +138,6 @@ function Base.showerror(io::IO, exc::MacroExpansionError)\n     end\n end\n \n-function fixup_macro_name(ctx::MacroExpansionContext, ex::SyntaxTree)\n-    k = kind(ex)\n-    if k == K\"StrMacroName\" || k == K\"CmdMacroName\"\n-        layerid = get(ex, :scope_layer, current_layer_id(ctx))\n-        newname = JuliaSyntax.lower_identifier_name(ex.name_val, k)\n-        makeleaf(ctx, ex, ex, [:kind=>K\"Identifier\", :scope_layer=>layerid,\n-                               :name_val=>newname])\n-    elseif k == K\"macro_name\"\n-        @chk numchildren(ex) === 1\n-        if kind(ex[1]) === K\".\"\n-            @ast ctx ex [K\".\" ex[1][1] [K\"macro_name\" ex[1][2]]]\n-        else\n-            layerid = get(ex, :scope_layer, current_layer_id(ctx))\n-            newname = JuliaSyntax.lower_identifier_name(ex[1].name_val, K\"macro_name\")\n-            makeleaf(ctx, ex[1], ex[1], [:kind=>kind(ex[1]), :name_val=>newname])\n-        end\n-    else\n-        mapchildren(e->fixup_macro_name(ctx,e), ctx, ex)\n-    end\n-end\n-\n function _eval_dot(world::UInt, mod, ex::SyntaxTree)\n     if kind(ex) === K\".\"\n         mod = _eval_dot(world, mod, ex[1])\n@@ -175,7 +154,7 @@ end\n # isn't clear the language is meant to support this).\n function eval_macro_name(ctx::MacroExpansionContext, mctx::MacroContext, ex0::SyntaxTree)\n     mod = current_layer(ctx).mod\n-    ex = fixup_macro_name(ctx, expand_forms_1(ctx, ex0))\n+    ex = expand_forms_1(ctx, ex0)\n     try\n         if kind(ex) === K\"Value\"\n             !(ex.value isa GlobalRef) ? ex.value :\n@@ -433,10 +412,6 @@ function expand_forms_1(ctx::MacroExpansionContext, ex::SyntaxTree)\n             scope_layer = get(ex, :scope_layer, current_layer_id(ctx))\n             makeleaf(ctx, ex, ex, [:kind=>k, :scope_layer=>scope_layer])\n         end\n-    elseif k == K\"StrMacroName\" || k == K\"CmdMacroName\" || k == K\"macro_name\"\n-        # These can appear outside of a macrocall, e.g. in `import`\n-        e2 = fixup_macro_name(ctx, ex)\n-        expand_forms_1(ctx, e2)\n     elseif k == K\"var\" || k == K\"char\" || k == K\"parens\"\n         # Strip \"container\" nodes\n         @chk numchildren(ex) == 1\n@@ -512,7 +487,7 @@ function expand_forms_1(ctx::MacroExpansionContext, ex::SyntaxTree)\n         @ast ctx ex [K\".\" expand_forms_1(ctx, ex[1]) e2]\n     elseif k == K\"cmdstring\"\n         @chk numchildren(ex) == 1\n-        e2 = @ast ctx ex [K\"macrocall\" [K\"macro_name\" \"cmd\"::K\"core\"] ex[1]]\n+        e2 = @ast ctx ex [K\"macrocall\" \"@cmd\"::K\"core\" ex[1]]\n         expand_macro(ctx, e2)\n     elseif (k == K\"call\" || k == K\"dotcall\")\n         # Do some initial desugaring of call and dotcall here to simplify"
    },
    {
      "sha": "beee824adcb095bff2a2bd30ce61d1675f746913",
      "filename": "JuliaLowering/src/syntax_graph.jl",
      "status": "modified",
      "additions": 22,
      "deletions": 9,
      "changes": 31,
      "blob_url": "https://github.com/JuliaLang/julia/blob/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Fsrc%2Fsyntax_graph.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Fsrc%2Fsyntax_graph.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Fsrc%2Fsyntax_graph.jl?ref=80b451f3dab95ed32fc481e2b723091d99c959f7",
      "patch": "@@ -1,7 +1,8 @@\n # TODO: This whole file should probably be moved to JuliaSyntax.\n import .JuliaSyntax: ParseStream, RedTreeCursor, reverse_toplevel_siblings,\n     has_toplevel_siblings, _unsafe_wrap_substring, parse_julia_literal, is_trivia,\n-    is_prefix_op_call, @isexpr, SyntaxHead, COLON_QUOTE, is_syntactic_operator\n+    is_prefix_op_call, @isexpr, SyntaxHead, COLON_QUOTE, is_syntactic_operator,\n+    lower_identifier_name\n \n const NodeId = Int\n \n@@ -417,7 +418,7 @@ attrsummary(name, value::Number) = \"$name=$value\"\n \n function _value_string(ex)\n     k = kind(ex)\n-    str = k in KSet\"Identifier StrMacroName CmdMacroName\" || is_operator(k) ? ex.name_val :\n+    str = k == K\"Identifier\" || is_operator(k) ? ex.name_val :\n           k == K\"Placeholder\" ? ex.name_val           :\n           k == K\"SSAValue\"    ? \"%\"                   :\n           k == K\"BindingId\"   ? \"#\"                   :\n@@ -584,17 +585,11 @@ function _find_SyntaxTree_macro(ex, line)\n         # We're in the line range. Either\n         if firstline == line && kind(c) == K\"macrocall\" && begin\n                     name = c[1]\n-                    if kind(name) == K\"macro_name\"\n-                        name = name[1]\n-                    end\n                     if kind(name) == K\".\"\n                         name = name[2]\n-                        if kind(name) == K\"macro_name\"\n-                            name = name[1]\n-                        end\n                     end\n                     @assert kind(name) == K\"Identifier\"\n-                    name.name_val == \"SyntaxTree\"\n+                    name.name_val == \"@SyntaxTree\"\n                 end\n             # We find the node we're looking for. NB: Currently assuming a max\n             # of one @SyntaxTree invocation per line. Though we could relax\n@@ -891,6 +886,24 @@ function _green_to_ast(parent::Kind, ex::SyntaxTree; eq_to_kw=false)\n     elseif k === K\"=\" && eq_to_kw\n         setattr!(makenode(graph, ex, ex, _map_green_to_ast(k, children(ex))),\n                  :kind, K\"kw\")\n+    elseif k === K\"CmdMacroName\" || k === K\"StrMacroName\"\n+        name = lower_identifier_name(ex.name_val, k)\n+        setattr!(makeleaf(graph, ex, K\"Identifier\"),\n+                 :name_val, name)\n+    elseif k === K\"macro_name\"\n+        # M.@x parses to (. M (macro_name x))\n+        # @M.x parses to (macro_name (. M x))\n+        # We want (. M @x) (both identifiers) in either case\n+        @assert numchildren(ex) === 2 && kind(ex[1]) === K\"@\"\n+        id = ex[2]\n+        mname_raw = (kind(id) === K\".\" ? id[2] : id).name_val\n+        mac_id = setattr!(makeleaf(graph, ex, K\"Identifier\"), :name_val,\n+                          lower_identifier_name(mname_raw, K\"macro_name\"))\n+        if kind(id) === K\".\"\n+            makenode(graph, ex, ex, NodeId[id[1]._id, mac_id._id])\n+        else\n+            mac_id\n+        end\n     elseif is_leaf(ex)\n         return ex\n     else"
    },
    {
      "sha": "b810fef71efb7bbfee7804cee5bec8da056ff487",
      "filename": "JuliaLowering/test/compat.jl",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/JuliaLang/julia/blob/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Ftest%2Fcompat.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Ftest%2Fcompat.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fcompat.jl?ref=80b451f3dab95ed32fc481e2b723091d99c959f7",
      "patch": "@@ -494,7 +494,7 @@ const JL = JuliaLowering\n         # `@mac x` with macro name escaped\n         @test JuliaLowering.expr_to_syntaxtree(Expr(:macrocall, esc(Symbol(\"@mac\")), nothing, :x)) \u2248\n             @ast_ [K\"macrocall\"\n-                [K\"escape\" [K\"macro_name\" \"mac\"::K\"Identifier\"]]\n+                [K\"escape\" \"@mac\"::K\"Identifier\"]\n                 \"x\"::K\"Identifier\"\n             ]\n \n@@ -505,7 +505,7 @@ const JL = JuliaLowering\n             [K\"escape\"\n                 [K\".\"\n                     \"A\"::K\"Identifier\"\n-                    [K\"macro_name\" \"mac\"::K\"Identifier\"]\n+                    \"@mac\"::K\"Identifier\"\n                 ]\n             ]\n             \"x\"::K\"Identifier\"\n@@ -577,7 +577,7 @@ const JL = JuliaLowering\n             Expr(:macrocall, Expr(:var\"hygienic-scope\", Symbol(\"@mac\"), :other, :args), nothing, :x)) \u2248\n             @ast_ [K\"macrocall\"\n                 [K\"hygienic_scope\"\n-                    [K\"macro_name\" \"mac\"::K\"Identifier\"]\n+                    \"@mac\"::K\"Identifier\"\n                     \"other\"::K\"Identifier\" # (<- normally a Module)\n                     \"args\"::K\"Identifier\" # (<- normally a LineNumberNode)\n                 ]\n@@ -587,7 +587,7 @@ const JL = JuliaLowering\n         # One example of double escaping\n         @test JuliaLowering.expr_to_syntaxtree(Expr(:macrocall, esc(esc(Symbol(\"@mac\"))), nothing, :x)) \u2248\n             @ast_ [K\"macrocall\"\n-                [K\"escape\" [K\"escape\" [K\"macro_name\" \"mac\"::K\"Identifier\"]]]\n+                [K\"escape\" [K\"escape\" \"@mac\"::K\"Identifier\"]]\n                 \"x\"::K\"Identifier\"\n             ]\n \n@@ -600,7 +600,7 @@ const JL = JuliaLowering\n             @ast_ [K\"macrocall\"\n                 [K\"hygienic_scope\"\n                     [K\"escape\"\n-                        [K\"macro_name\" \"mac\"::K\"Identifier\"]\n+                        \"@mac\"::K\"Identifier\"\n                     ]\n                     \"other\"::K\"Identifier\" # (<- normally a Module)\n                     \"args\"::K\"Identifier\" # (<- normally a LineNumberNode)"
    },
    {
      "sha": "9d368122aa715444752444ec1e6c5b7033fc28b5",
      "filename": "JuliaLowering/test/macros.jl",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/JuliaLang/julia/blob/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Ftest%2Fmacros.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Ftest%2Fmacros.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmacros.jl?ref=80b451f3dab95ed32fc481e2b723091d99c959f7",
      "patch": "@@ -347,6 +347,14 @@ end\n         GC.@preserve x unsafe_load(p)\n     end\"\"\") === 101 # Expr(:gc_preserve)\n \n+    # JuliaLowering.jl/issues/121\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    GC.@preserve @static if true @__MODULE__ else end\n+    \"\"\") isa Module\n+    @test JuliaLowering.include_string(test_mod, \"\"\"\n+    GC.@preserve @static if true v\"1.14\" else end\n+    \"\"\") isa VersionNumber\n+\n     # only invokelatest produces :isglobal now, so MWE here\n     Base.eval(test_mod, :(macro isglobal(x); esc(Expr(:isglobal, x)); end))\n     @test JuliaLowering.include_string(test_mod, \"\"\""
    },
    {
      "sha": "2889023a14b3bf6092a62bfd21e643adbecaf578",
      "filename": "JuliaLowering/test/macros_ir.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Ftest%2Fmacros_ir.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Ftest%2Fmacros_ir.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Fmacros_ir.jl?ref=80b451f3dab95ed32fc481e2b723091d99c959f7",
      "patch": "@@ -147,7 +147,7 @@ _never_exist = @m_not_exist 42\n #---------------------\n MacroExpansionError while expanding @m_not_exist in module Main.TestMod:\n _never_exist = @m_not_exist 42\n-#               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Macro not found\n+#              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2500 Macro not found\n Caused by:\n UndefVarError: `@m_not_exist` not defined in `Main.TestMod`\n Suggestion: check for spelling errors or missing imports."
    },
    {
      "sha": "0a150a38c1351821ab85a7319863cb5de8c5e88b",
      "filename": "JuliaLowering/test/utils.jl",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/JuliaLang/julia/blob/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Ftest%2Futils.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/80b451f3dab95ed32fc481e2b723091d99c959f7/JuliaLowering%2Ftest%2Futils.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/JuliaLowering%2Ftest%2Futils.jl?ref=80b451f3dab95ed32fc481e2b723091d99c959f7",
      "patch": "@@ -167,7 +167,8 @@ end\n function format_ir_for_test(mod, case)\n     ex = parsestmt(SyntaxTree, case.input)\n     try\n-        if kind(ex) == K\"macrocall\" && kind(ex[1]) == K\"macro_name\" && ex[1][1].name_val == \"ast_\"\n+        if (kind(ex) == K\"macrocall\" && kind(ex[1]) == K\"Identifier\" &&\n+            ex[1].name_val == \"@ast_\")\n             # Total hack, until @ast_ can be implemented in terms of new-style\n             # macros.\n             ex = Base.eval(mod, Expr(ex))"
    },
    {
      "sha": "881861174b50dc10ce27dd45eb601df6868ae742",
      "filename": "test/JuliaLowering_stdlibs.jl",
      "status": "modified",
      "additions": 13,
      "deletions": 4,
      "changes": 17,
      "blob_url": "https://github.com/JuliaLang/julia/blob/80b451f3dab95ed32fc481e2b723091d99c959f7/test%2FJuliaLowering_stdlibs.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/80b451f3dab95ed32fc481e2b723091d99c959f7/test%2FJuliaLowering_stdlibs.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/test%2FJuliaLowering_stdlibs.jl?ref=80b451f3dab95ed32fc481e2b723091d99c959f7",
      "patch": "@@ -1,10 +1,19 @@\n import Libdl\n \n-### 38 / 52 (non-sysimage) stdlibs precompile successfully with JuliaLowering ###\n+# known precompilation failures under JL\n const INCOMPATIBLE_STDLIBS = String[\n-    \"Statistics\", \"JuliaSyntaxHighlighting\", \"Markdown\", \"LibGit2\",\n-    \"InteractiveUtils\", \"Test\", \"REPL\", \"Pkg\", \"LazyArtifacts\", \"SparseArrays\",\n-    \"TOML\", \"StyledStrings\", \"Profile\", \"SuiteSparse\",\n+    \"InteractiveUtils\"\n+    \"LazyArtifacts\"\n+    \"LibGit2\"\n+    \"Pkg\"\n+    \"REPL\"\n+    \"REPLExt\"\n+    \"SparseArrays\"\n+    \"SparseArraysExt\"\n+    \"Statistics\"\n+    \"SuiteSparse\"\n+    \"TOML\"\n+    \"Test\"\n ]\n \n const JULIA_EXECUTABLE = Base.unsafe_string(Base.JLOptions().julia_bin)"
    }
  ]
}