{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/50509",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/50509/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/50509/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/50509/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/50509",
  "id": 1799305823,
  "node_id": "PR_kwDOABkWpM5VOO1K",
  "number": 50509,
  "title": "speed-up `randperm` by using our current `rand(1:n)`",
  "user": {
    "login": "rfourquet",
    "id": 8462914,
    "node_id": "MDQ6VXNlcjg0NjI5MTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8462914?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rfourquet",
    "html_url": "https://github.com/rfourquet",
    "followers_url": "https://api.github.com/users/rfourquet/followers",
    "following_url": "https://api.github.com/users/rfourquet/following{/other_user}",
    "gists_url": "https://api.github.com/users/rfourquet/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rfourquet/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rfourquet/subscriptions",
    "organizations_url": "https://api.github.com/users/rfourquet/orgs",
    "repos_url": "https://api.github.com/users/rfourquet/repos",
    "events_url": "https://api.github.com/users/rfourquet/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rfourquet/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 115858,
      "node_id": "MDU6TGFiZWwxMTU4NTg=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/performance",
      "name": "performance",
      "color": "d7e102",
      "default": false,
      "description": "Must go faster"
    },
    {
      "id": 150298040,
      "node_id": "MDU6TGFiZWwxNTAyOTgwNDA=",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/randomness",
      "name": "randomness",
      "color": "f7c6c7",
      "default": false,
      "description": "Random number generation and the Random stdlib"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 7,
  "created_at": "2023-07-11T16:22:56Z",
  "updated_at": "2025-10-26T00:37:03Z",
  "closed_at": "2025-10-26T00:37:02Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/50509",
    "html_url": "https://github.com/JuliaLang/julia/pull/50509",
    "diff_url": "https://github.com/JuliaLang/julia/pull/50509.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/50509.patch",
    "merged_at": "2025-10-26T00:37:01Z"
  },
  "body": "And similarly for `randcycle` and `shuffle`.\r\n\r\nWe had a custom version of range generation for `randperm`, which was based on the ideas of our previous default range sampler `SamplerRangeFast` (generate `k`-bits integers using masking and reject out-of-range ones) and took advantage of the fact that `randperm` needs to generate `rand(1:i)` for `i = 2:n`.\r\n\r\nBut our current range sampler (\"Nearly Division Less\") is usually better than this hack, and makes these functions more readable. Typically, for array lengths `< 2^20`, the new version is faster, but gets slightly slower beyond 2^22.\r\n\r\nHere are some speedups:\r\n![randperm-ndl-speedup](https://github.com/JuliaLang/julia/assets/8462914/b999ba43-e588-49f4-91a2-a4b23e79716d)\r\n\r\nThe slow down for big arrays seems fine to me, but I will see if I can find an easy workaround.\r\n\r\nFix #57771.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/50509/reactions",
    "total_count": 6,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 3,
    "rocket": 2,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/50509/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "0e7f8717387ee7863e6dfb93a9a86f050eb26145",
      "filename": "stdlib/Random/src/misc.jl",
      "status": "modified",
      "additions": 39,
      "deletions": 59,
      "changes": 98,
      "blob_url": "https://github.com/JuliaLang/julia/blob/b6ff22a3f02387db68e5dd8c2db7897898b8ff07/stdlib%2FRandom%2Fsrc%2Fmisc.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/b6ff22a3f02387db68e5dd8c2db7897898b8ff07/stdlib%2FRandom%2Fsrc%2Fmisc.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/stdlib%2FRandom%2Fsrc%2Fmisc.jl?ref=b6ff22a3f02387db68e5dd8c2db7897898b8ff07",
      "patch": "@@ -176,11 +176,6 @@ julia> randsubseq(Xoshiro(123), 1:8, 0.3)\n randsubseq(A::AbstractArray, p::Real) = randsubseq(default_rng(), A, p)\n \n \n-## rand Less Than Masked 52 bits (helper function)\n-\n-\"Return a sampler generating a random `Int` (masked with `mask`) in ``[0, n)``, when `n <= 2^52`.\"\n-ltm52(n::Int, mask::Int=nextpow(2, n)-1) = LessThan(n-1, Masked(mask, UInt52Raw(Int)))\n-\n ## shuffle & shuffle!\n \n function shuffle(rng::AbstractRNG, tup::NTuple{N}) where {N}\n@@ -219,31 +214,22 @@ optionally supplying the random-number generator `rng`.\n \n # Examples\n ```jldoctest\n-julia> shuffle!(Xoshiro(123), Vector(1:10))\n-10-element Vector{Int64}:\n-  5\n-  4\n-  2\n-  3\n-  6\n- 10\n-  8\n-  1\n-  9\n-  7\n+julia> shuffle!(Xoshiro(0), Vector(1:6))\n+6-element Vector{Int64}:\n+ 5\n+ 1\n+ 2\n+ 6\n+ 3\n+ 4\n ```\n \"\"\"\n-function shuffle!(r::AbstractRNG, a::AbstractArray)\n+function shuffle!(rng::AbstractRNG, a::AbstractArray)\n     # keep it consistent with `randperm!` and `randcycle!` if possible\n     require_one_based_indexing(a)\n-    n = length(a)\n-    @assert n <= Int64(2)^52\n-    n == 0 && return a\n-    mask = 3\n-    @inbounds for i = 2:n\n-        j = 1 + rand(r, ltm52(i, mask))\n+    @inbounds for i = 2:length(a)\n+        j = rand(rng, 1:i)\n         a[i], a[j] = a[j], a[i]\n-        i == 1 + mask && (mask = 2 * mask + 1)\n     end\n     return a\n end\n@@ -278,18 +264,14 @@ indices, see [`randperm`](@ref).\n \n # Examples\n ```jldoctest\n-julia> shuffle(Xoshiro(123), Vector(1:10))\n-10-element Vector{Int64}:\n-  5\n-  4\n-  2\n-  3\n-  6\n- 10\n-  8\n-  1\n-  9\n-  7\n+julia> shuffle(Xoshiro(0), 1:6)\n+6-element Vector{Int64}:\n+ 5\n+ 1\n+ 2\n+ 6\n+ 3\n+ 4\n ```\n \"\"\"\n function shuffle end\n@@ -318,12 +300,14 @@ To randomly permute an arbitrary vector, see [`shuffle`](@ref) or\n \n # Examples\n ```jldoctest\n-julia> randperm(Xoshiro(123), 4)\n-4-element Vector{Int64}:\n+julia> randperm(Xoshiro(0), 6)\n+6-element Vector{Int64}:\n+ 5\n  1\n- 4\n  2\n+ 6\n  3\n+ 4\n ```\n \"\"\"\n randperm(r::AbstractRNG, n::T) where {T <: Integer} = randperm!(r, Vector{T}(undef, n))\n@@ -342,29 +326,28 @@ optional `rng` argument specifies a random number generator (see\n \n # Examples\n ```jldoctest\n-julia> randperm!(Xoshiro(123), Vector{Int}(undef, 4))\n-4-element Vector{Int64}:\n+julia> randperm!(Xoshiro(0), Vector{Int}(undef, 6))\n+6-element Vector{Int64}:\n+ 5\n  1\n- 4\n  2\n+ 6\n  3\n+ 4\n ```\n \"\"\"\n-function randperm!(r::AbstractRNG, a::AbstractArray{<:Integer})\n+function randperm!(rng::AbstractRNG, a::AbstractArray{<:Integer})\n     # keep it consistent with `shuffle!` and `randcycle!` if possible\n     Base.require_one_based_indexing(a)\n     n = length(a)\n-    @assert n <= Int64(2)^52\n     n == 0 && return a\n     a[1] = 1\n-    mask = 3\n     @inbounds for i = 2:n\n-        j = 1 + rand(r, ltm52(i, mask))\n+        j = rand(rng, 1:i)\n         if i != j # a[i] is undef (and could be #undef)\n             a[i] = a[j]\n         end\n         a[j] = i\n-        i == 1 + mask && (mask = 2 * mask + 1)\n     end\n     return a\n end\n@@ -393,14 +376,14 @@ which are sampled uniformly.  If `n == 0`, `randcycle` returns an empty vector.\n \n # Examples\n ```jldoctest\n-julia> randcycle(Xoshiro(123), 6)\n+julia> randcycle(Xoshiro(0), 6)\n 6-element Vector{Int64}:\n  5\n+ 1\n  4\n- 2\n  6\n  3\n- 1\n+ 2\n ```\n \"\"\"\n randcycle(r::AbstractRNG, n::T) where {T <: Integer} = randcycle!(r, Vector{T}(undef, n))\n@@ -424,30 +407,27 @@ which are sampled uniformly.  If `A` is empty, `randcycle!` leaves it unchanged.\n \n # Examples\n ```jldoctest\n-julia> randcycle!(Xoshiro(123), Vector{Int}(undef, 6))\n+julia> randcycle!(Xoshiro(0), Vector{Int}(undef, 6))\n 6-element Vector{Int64}:\n  5\n+ 1\n  4\n- 2\n  6\n  3\n- 1\n+ 2\n ```\n \"\"\"\n-function randcycle!(r::AbstractRNG, a::AbstractArray{<:Integer})\n+function randcycle!(rng::AbstractRNG, a::AbstractArray{<:Integer})\n     # keep it consistent with `shuffle!` and `randperm!` if possible\n     Base.require_one_based_indexing(a)\n     n = length(a)\n-    @assert n <= Int64(2)^52\n     n == 0 && return a\n     a[1] = 1\n-    mask = 3\n     # Sattolo's algorithm:\n     @inbounds for i = 2:n\n-        j = 1 + rand(r, ltm52(i-1, mask))\n+        j = rand(rng, 1:i-1)\n         a[i] = a[j]\n         a[j] = i\n-        i == 1 + mask && (mask = 2 * mask + 1)\n     end\n     return a\n end"
    }
  ]
}