{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60146",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60146/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60146/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60146/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60146",
  "id": 3629968503,
  "node_id": "PR_kwDOABkWpM6zrzet",
  "number": 60146,
  "title": "loading: More extension loading cleanup",
  "user": {
    "login": "Keno",
    "id": 1291671,
    "node_id": "MDQ6VXNlcjEyOTE2NzE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1291671?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Keno",
    "html_url": "https://github.com/Keno",
    "followers_url": "https://api.github.com/users/Keno/followers",
    "following_url": "https://api.github.com/users/Keno/following{/other_user}",
    "gists_url": "https://api.github.com/users/Keno/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Keno/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Keno/subscriptions",
    "organizations_url": "https://api.github.com/users/Keno/orgs",
    "repos_url": "https://api.github.com/users/Keno/repos",
    "events_url": "https://api.github.com/users/Keno/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Keno/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-11-16T05:32:55Z",
  "updated_at": "2025-11-17T07:58:40Z",
  "closed_at": "2025-11-17T07:58:38Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60146",
    "html_url": "https://github.com/JuliaLang/julia/pull/60146",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60146.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60146.patch",
    "merged_at": "2025-11-17T07:58:38Z"
  },
  "body": "In #59863, I removed a special case that allowed extensions to be identified cross-environment. As it turns out, `locate_package` has a similar special case, except this one is even weirder (because it will definitely break if any package other than the intended base package is found).\r\n\r\nHowever, it turns out that removing this special case breaks stdlib precompilation. Why you ask? Well, when we precompile stdlibs we set the LOAD_PATH to `@stdlib:$(pwd)/stdlib` and then run the precompile function (which calls locate_package directly). Note that `@stdlib` is an implicit env that we symlink together, while `$(pwd)/stdlib` is an explicit env with Project and Manifest. However, these projects and manifests are somewhat malformed, because we don't actually have the stdlibs in our depot, so they cannot be used for loading.\r\n\r\nWhat's happening here is that it turns out we had a separate bug where we cannot properly load extensions from implicit environments unless the parent package has previously been loaded. This is usually the case (because extensions by definitions have their parent packages loaded), but is not the case during an explicit precompile.\r\n\r\nThe tangled setup previously described found `Statistics` in the first environment, then found Statistics' SparseArrayExt in the second environemnt, which then computed the extension path by looking up `Statistics` in the first environment again.\r\n\r\nWith loading properly fixed to find extensions in implicit environments (which is painful since we need to scan each project.toml in each directory), everything goes through and we find all the packages and the appropriate extensions in the implicit environment.\r\n\r\nI don't think any of this was ever intentionally designed this way but just happened to be a combination of bugs covering for each other.\r\n\r\nI also don't think that this fallback case will actually trigger in practice although it does of course trigger when looking up any package that is not actually present in the environment.\r\n\r\nAs such, it is advisable to avoid large implicit environments at the start of the loadpath. `@stdlib` is last in the default setup and our other environments are explicit, so again I don't forsee this to happen too often in practice, but we might want to consider making `@stdlib` an explicit environemnt also to explicitly record everything.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60146/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60146/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "a1fa054d20f214ac5308a9011cb5a26cec535ce1",
      "filename": "base/loading.jl",
      "status": "modified",
      "additions": 10,
      "deletions": 3,
      "changes": 13,
      "blob_url": "https://github.com/JuliaLang/julia/blob/c223ef2eb395e2bfac9740a5440bb83b502eafa3/base%2Floading.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/c223ef2eb395e2bfac9740a5440bb83b502eafa3/base%2Floading.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Floading.jl?ref=c223ef2eb395e2bfac9740a5440bb83b502eafa3",
      "patch": "@@ -824,7 +824,10 @@ function manifest_uuid_path(env::String, pkg::PkgId)::Union{Nothing,String,Missi\n         # if env names a directory, search it\n         proj = implicit_manifest_uuid_path(env, pkg)\n         proj === nothing || return proj\n-        # if not found\n+        # if not found, this might be an extension - first we fast path needing\n+        # to scan the whole directory for a matching extension by peeking at\n+        # EXT_PRIMED. However, this only works if the parent package was loaded.\n+        # This is usually the case, but not always, e.g. in precompilation.\n         triggers = get(EXT_PRIMED, pkg, nothing)\n         if triggers !== nothing\n             parentid = triggers[1]\n@@ -836,6 +839,10 @@ function manifest_uuid_path(env::String, pkg::PkgId)::Union{Nothing,String,Missi\n                     mby_ext === nothing || return mby_ext\n                 end\n             end\n+        else\n+            # We still need to scan the whole directory for extensions.\n+            ext_path, ext_proj = implicit_env_project_file_extension(env, pkg)\n+            ext_path === nothing || return ext_path\n         end\n     end\n     return nothing\n@@ -1130,8 +1137,8 @@ function explicit_manifest_uuid_path(project_file::String, pkg::PkgId)::Union{No\n             uuid = get(entry, \"uuid\", nothing)::Union{Nothing, String}\n             extensions = get(entry, \"extensions\", nothing)::Union{Nothing, Dict{String, Any}}\n             if extensions !== nothing && haskey(extensions, pkg.name) && uuid !== nothing && uuid5(UUID(uuid), pkg.name) == pkg.uuid\n-                parent_path = locate_package(PkgId(UUID(uuid), name))\n-                if parent_path === nothing\n+                parent_path = explicit_manifest_entry_path(manifest_file, PkgId(UUID(uuid), name), entry)\n+                if parent_path === nothing || parent_path === missing\n                     error(\"failed to find source of parent package: \\\"$name\\\"\")\n                 end\n                 p = normpath(dirname(parent_path), \"..\")"
    }
  ]
}