{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60547",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60547/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60547/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60547/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60547",
  "id": 3781517679,
  "node_id": "PR_kwDOABkWpM67iNju",
  "number": 60547,
  "title": "Avoid more `Core.Box` in Base (and Compiler)",
  "user": {
    "login": "KristofferC",
    "id": 1282691,
    "node_id": "MDQ6VXNlcjEyODI2OTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1282691?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KristofferC",
    "html_url": "https://github.com/KristofferC",
    "followers_url": "https://api.github.com/users/KristofferC/followers",
    "following_url": "https://api.github.com/users/KristofferC/following{/other_user}",
    "gists_url": "https://api.github.com/users/KristofferC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KristofferC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KristofferC/subscriptions",
    "organizations_url": "https://api.github.com/users/KristofferC/orgs",
    "repos_url": "https://api.github.com/users/KristofferC/repos",
    "events_url": "https://api.github.com/users/KristofferC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KristofferC/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [
    {
      "id": 9546926682,
      "node_id": "LA_kwDOABkWpM8AAAACOQqKWg",
      "url": "https://api.github.com/repos/JuliaLang/julia/labels/backport%201.13",
      "name": "backport 1.13",
      "color": "699295",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2026-01-05T13:32:17Z",
  "updated_at": "2026-01-07T20:01:18Z",
  "closed_at": "2026-01-07T20:01:15Z",
  "author_association": "MEMBER",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60547",
    "html_url": "https://github.com/JuliaLang/julia/pull/60547",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60547.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60547.patch",
    "merged_at": "2026-01-07T20:01:15Z"
  },
  "body": "Moving out closures into separate functions, using `@lock` instead of `lock() do`. ",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60547/reactions",
    "total_count": 1,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 1,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60547/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "66c774c5da399265d3d5b2520c0068b44647595f",
      "filename": "Compiler/src/ssair/passes.jl",
      "status": "modified",
      "additions": 42,
      "deletions": 30,
      "changes": 72,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ca29f8ff90ed6813327c2630045eae2d4b35717a/Compiler%2Fsrc%2Fssair%2Fpasses.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ca29f8ff90ed6813327c2630045eae2d4b35717a/Compiler%2Fsrc%2Fssair%2Fpasses.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2Fpasses.jl?ref=ca29f8ff90ed6813327c2630045eae2d4b35717a",
      "patch": "@@ -361,20 +361,25 @@ function already_inserted(compact::IncrementalCompact, old::OldSSAValue)\n     already_inserted_ssa(compact, compact.idx-1)(0, old)\n end\n \n-function already_inserted_ssa(compact::IncrementalCompact, processed_idx::Int)\n-    return function did_already_insert(phi_arg::Int, old::OldSSAValue)\n-        id = old.id\n-        if id <= length(compact.ir.stmts)\n-            return id <= processed_idx\n-        end\n-        id -= length(compact.ir.stmts)\n-        if id <= length(compact.ir.new_nodes)\n-            return did_already_insert(phi_arg, OldSSAValue(compact.ir.new_nodes.info[id].pos))\n-        end\n-        id -= length(compact.ir.new_nodes)\n-        @assert id <= length(compact.pending_nodes)\n-        return !(id in compact.pending_perm)\n+function _already_inserted_ssa(compact::IncrementalCompact, processed_idx::Int,\n+                               phi_arg::Int, old::OldSSAValue)\n+    id = old.id\n+    if id <= length(compact.ir.stmts)\n+        return id <= processed_idx\n+    end\n+    id -= length(compact.ir.stmts)\n+    if id <= length(compact.ir.new_nodes)\n+        return _already_inserted_ssa(compact, processed_idx, phi_arg,\n+                                     OldSSAValue(compact.ir.new_nodes.info[id].pos))\n     end\n+    id -= length(compact.ir.new_nodes)\n+    @assert id <= length(compact.pending_nodes)\n+    return !(id in compact.pending_perm)\n+end\n+\n+function already_inserted_ssa(compact::IncrementalCompact, processed_idx::Int)\n+    return (phi_arg::Int, old::OldSSAValue) ->\n+        _already_inserted_ssa(compact, processed_idx, phi_arg, old)\n end\n \n function is_pending(compact::IncrementalCompact, old::OldSSAValue)\n@@ -1647,6 +1652,25 @@ function reachable_blocks(cfg::CFG, from_bb::Int, to_bb::Int)\n     return visited\n end\n \n+function _update_finalizer_insert!(ir::IRCode, lazypostdomtree::LazyPostDomtree,\n+                                   finalizer_idx::Int, insert_bb::Int,\n+                                   insert_idx::Union{Int,Nothing}, x::Union{Int,SSAUse})\n+    defuse_idx = x isa SSAUse ? x.idx : x\n+    defuse_idx == finalizer_idx && return insert_bb, insert_idx\n+    defuse_bb = block_for_inst(ir, defuse_idx)\n+    new_insert_bb = nearest_common_dominator(get!(lazypostdomtree),\n+        insert_bb, defuse_bb)\n+    if new_insert_bb == insert_bb && insert_idx !== nothing\n+        insert_idx = max(insert_idx::Int, defuse_idx)\n+    elseif new_insert_bb == defuse_bb\n+        insert_idx = defuse_idx\n+    else\n+        insert_idx = nothing\n+    end\n+    insert_bb = new_insert_bb\n+    return insert_bb, insert_idx\n+end\n+\n function try_resolve_finalizer!(ir::IRCode, alloc_idx::Int, finalizer_idx::Int, defuse::SSADefUse,\n         inlining::InliningState, lazydomtree::LazyDomtree,\n         lazypostdomtree::LazyPostDomtree, @nospecialize(info::CallInfo))\n@@ -1668,24 +1692,12 @@ function try_resolve_finalizer!(ir::IRCode, alloc_idx::Int, finalizer_idx::Int,\n     # Check #2: The insertion block for the finalizer is the post-dominator of all uses\n     insert_bb::Int = finalizer_bb\n     insert_idx::Union{Int,Nothing} = finalizer_idx\n-    function note_defuse!(x::Union{Int,SSAUse})\n-        defuse_idx = x isa SSAUse ? x.idx : x\n-        defuse_idx == finalizer_idx && return nothing\n-        defuse_bb = block_for_inst(ir, defuse_idx)\n-        new_insert_bb = nearest_common_dominator(get!(lazypostdomtree),\n-            insert_bb, defuse_bb)\n-        if new_insert_bb == insert_bb && insert_idx !== nothing\n-            insert_idx = max(insert_idx::Int, defuse_idx)\n-        elseif new_insert_bb == defuse_bb\n-            insert_idx = defuse_idx\n-        else\n-            insert_idx = nothing\n-        end\n-        insert_bb = new_insert_bb\n-        nothing\n+    for x in defuse.uses\n+        insert_bb, insert_idx = _update_finalizer_insert!(ir, lazypostdomtree, finalizer_idx, insert_bb, insert_idx, x)\n+    end\n+    for x in defuse.defs\n+        insert_bb, insert_idx = _update_finalizer_insert!(ir, lazypostdomtree, finalizer_idx, insert_bb, insert_idx, x)\n     end\n-    foreach(note_defuse!, defuse.uses)\n-    foreach(note_defuse!, defuse.defs)\n     insert_bb != 0 || return nothing # verify post-dominator of all uses exists\n \n     if !OptimizationParams(inlining.interp).assume_fatal_throw"
    },
    {
      "sha": "f00d0b894546ea28f2a8cff9def9497e62fc3110",
      "filename": "Compiler/src/ssair/show.jl",
      "status": "modified",
      "additions": 85,
      "deletions": 80,
      "changes": 165,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ca29f8ff90ed6813327c2630045eae2d4b35717a/Compiler%2Fsrc%2Fssair%2Fshow.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ca29f8ff90ed6813327c2630045eae2d4b35717a/Compiler%2Fsrc%2Fssair%2Fshow.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Fssair%2Fshow.jl?ref=ca29f8ff90ed6813327c2630045eae2d4b35717a",
      "patch": "@@ -534,37 +534,33 @@ function DILineInfoPrinter(debuginfo, def, showtypes::Bool=false)\n                 started::Bool = false\n                 if !update_line_only && showtypes && !isa(frame.method, Symbol) && nctx != 1\n                     print(io, linestart)\n-                    with_output_color(linecolor, io) do io\n-                        print(io, indent(\"\u2502\"))\n-                        print(io, \"\u250c invoke \", frame.method)\n-                        println(io)\n-                    end\n+                    printstyled(io, indent(\"\u2502\"), color=linecolor)\n+                    printstyled(io, \"\u250c invoke \", frame.method, color=linecolor)\n+                    println(io)\n                     started = true\n                 end\n                 print(io, linestart)\n-                with_output_color(linecolor, io) do io\n-                    print(io, indent(\"\u2502\"))\n-                    push!(context, frame)\n-                    if update_line_only\n-                        update_line_only = false\n-                    else\n-                        context_depth[] += 1\n-                        nctx != 1 && print(io, started ? \"\u2502\" : \"\u250c\")\n-                    end\n-                    print(io, \" @ \", frame.file)\n-                    if frame.line != typemax(frame.line) && frame.line != 0\n-                        print(io, \":\", frame.line)\n-                    end\n-                    print(io, \" within `\", method_name(frame), \"`\")\n-                    if collapse\n-                        method = method_name(frame)\n-                        while nctx < nframes\n-                            frame = DI[nframes - nctx]\n-                            method_name(frame) === method || break\n-                            nctx += 1\n-                            push!(context, frame)\n-                            print(io, \" @ \", frame.file, \":\", frame.line)\n-                        end\n+                printstyled(io, indent(\"\u2502\"), color=linecolor)\n+                push!(context, frame)\n+                if update_line_only\n+                    update_line_only = false\n+                else\n+                    context_depth[] += 1\n+                    nctx != 1 && printstyled(io, started ? \"\u2502\" : \"\u250c\", color=linecolor)\n+                end\n+                printstyled(io, \" @ \", frame.file, color=linecolor)\n+                if frame.line != typemax(frame.line) && frame.line != 0\n+                    printstyled(io, \":\", frame.line, color=linecolor)\n+                end\n+                printstyled(io, \" within `\", method_name(frame), \"`\", color=linecolor)\n+                if collapse\n+                    method = method_name(frame)\n+                    while nctx < nframes\n+                        frame = DI[nframes - nctx]\n+                        method_name(frame) === method || break\n+                        nctx += 1\n+                        push!(context, frame)\n+                        printstyled(io, \" @ \", frame.file, \":\", frame.line, color=linecolor)\n                     end\n                 end\n                 println(io)\n@@ -681,6 +677,60 @@ function show_ir_stmt(io::IO, code::Union{IRCode, CodeInfo, IncrementalCompact},\n                         sptypes, used, cfg, bb_idx; pop_new_node!, only_after, config.bb_color, config.label_dynamic_calls)\n end\n \n+function _print_ir_indentation(io::IO, cfg::CFG, bb_idx::Int, max_bb_idx_size::Int, bb_color,\n+                               line_info_preprinter, idx::Int, i::Int; final::Bool=true)\n+    # Compute BB guard rail\n+    if bb_idx > length(cfg.blocks)\n+        # If invariants are violated, print a special leader\n+        linestart = \" \"^(max_bb_idx_size + 2) # not inside a basic block bracket\n+        inlining_indent = line_info_preprinter(io, linestart, i == 1 ? idx : 0)\n+        printstyled(io, \"!!! \", \"\u2500\"^max_bb_idx_size, color=bb_color)\n+    else\n+        bbrange = cfg.blocks[bb_idx].stmts\n+        # Print line info update\n+        linestart = idx == first(bbrange) ? \"  \" : sprint(io -> printstyled(io, \"\u2502 \", color=bb_color), context=io)\n+        linestart *= \" \"^max_bb_idx_size\n+        # idx == 0 means only indentation is printed, so we don't print linfos\n+        # multiple times if the are new nodes\n+        inlining_indent = line_info_preprinter(io, linestart, i == 1 ? idx : 0)\n+\n+        if i == 1 && idx == first(bbrange)\n+            bb_idx_str = string(bb_idx)\n+            bb_pad = max_bb_idx_size - length(bb_idx_str)\n+            bb_type = length(cfg.blocks[bb_idx].preds) <= 1 ? \"\u2500\" : \"\u2504\"\n+            printstyled(io, bb_idx_str, \" \", bb_type, \"\u2500\"^bb_pad, color=bb_color)\n+        elseif final && idx == last(bbrange) # print separator\n+            printstyled(io, \"\u2514\", \"\u2500\"^(1 + max_bb_idx_size), color=bb_color)\n+        else\n+            printstyled(io, \"\u2502 \", \" \"^max_bb_idx_size, color=bb_color)\n+        end\n+    end\n+    print(io, inlining_indent, \" \")\n+    return nothing\n+end\n+\n+function _print_ir_new_node(io::IO, node, code, sptypes::Vector{VarState}, used::BitSet, maxlength_idx::Int,\n+                            label_dynamic_calls::Bool, line_info_postprinter, cfg::CFG, bb_idx::Int,\n+                            max_bb_idx_size::Int, bb_color, line_info_preprinter, idx::Int, i::Int; final::Bool=true)\n+    _print_ir_indentation(io, cfg, bb_idx, max_bb_idx_size, bb_color, line_info_preprinter, idx, i; final)\n+\n+    node_idx, new_node_inst, new_node_type = node\n+    @assert new_node_inst !== UNDEF # we filtered these out earlier\n+    show_type = should_print_ssa_type(new_node_inst)\n+    with_output_color(:green, io) do io\u2032\n+        print_stmt(io\u2032, node_idx, new_node_inst, code, sptypes, used, maxlength_idx, false, show_type, label_dynamic_calls)\n+    end\n+\n+    if new_node_type === UNDEF\n+        # Try to be robust against errors\n+        printstyled(io, \"::#UNDEF\", color=:red)\n+    else\n+        line_info_postprinter(io; type = new_node_type, used = node_idx in used, show_type, idx = node_idx)\n+    end\n+    println(io)\n+    return nothing\n+end\n+\n function show_ir_stmt(io::IO, code::Union{IRCode, CodeInfo, IncrementalCompact}, idx::Int, line_info_preprinter, line_info_postprinter,\n                       sptypes::Vector{VarState}, used::BitSet, cfg::CFG, bb_idx::Int; pop_new_node! = Returns(nothing), only_after::Bool=false,\n                       bb_color=:light_black, label_dynamic_calls::Bool=true)\n@@ -703,58 +753,11 @@ function show_ir_stmt(io::IO, code::Union{IRCode, CodeInfo, IncrementalCompact},\n     end\n \n     i = 1\n-    function print_indentation(final::Bool=true)\n-        # Compute BB guard rail\n-        if bb_idx > length(cfg.blocks)\n-            # If invariants are violated, print a special leader\n-            linestart = \" \"^(max_bb_idx_size + 2) # not inside a basic block bracket\n-            inlining_indent = line_info_preprinter(io, linestart, i == 1 ? idx : 0)\n-            printstyled(io, \"!!! \", \"\u2500\"^max_bb_idx_size, color=bb_color)\n-        else\n-            bbrange = cfg.blocks[bb_idx].stmts\n-            # Print line info update\n-            linestart = idx == first(bbrange) ? \"  \" : sprint(io -> printstyled(io, \"\u2502 \", color=bb_color), context=io)\n-            linestart *= \" \"^max_bb_idx_size\n-            # idx == 0 means only indentation is printed, so we don't print linfos\n-            # multiple times if the are new nodes\n-            inlining_indent = line_info_preprinter(io, linestart, i == 1 ? idx : 0)\n-\n-            if i == 1 && idx == first(bbrange)\n-                bb_idx_str = string(bb_idx)\n-                bb_pad = max_bb_idx_size - length(bb_idx_str)\n-                bb_type = length(cfg.blocks[bb_idx].preds) <= 1 ? \"\u2500\" : \"\u2504\"\n-                printstyled(io, bb_idx_str, \" \", bb_type, \"\u2500\"^bb_pad, color=bb_color)\n-            elseif final && idx == last(bbrange) # print separator\n-                printstyled(io, \"\u2514\", \"\u2500\"^(1 + max_bb_idx_size), color=bb_color)\n-            else\n-                printstyled(io, \"\u2502 \", \" \"^max_bb_idx_size, color=bb_color)\n-            end\n-        end\n-        print(io, inlining_indent, \" \")\n-    end\n-\n     # first, print new nodes that are to be inserted before the current statement\n-    function print_new_node(node; final::Bool=true)\n-        print_indentation(final)\n-\n-        node_idx, new_node_inst, new_node_type = node\n-        @assert new_node_inst !== UNDEF # we filtered these out earlier\n-        show_type = should_print_ssa_type(new_node_inst)\n-        let maxlength_idx=maxlength_idx, show_type=show_type\n-            with_output_color(:green, io) do io\u2032\n-                print_stmt(io\u2032, node_idx, new_node_inst, code, sptypes, used, maxlength_idx, false, show_type, label_dynamic_calls)\n-            end\n-        end\n-\n-        if new_node_type === UNDEF # try to be robust against errors\n-            printstyled(io, \"::#UNDEF\", color=:red)\n-        else\n-            line_info_postprinter(io; type = new_node_type, used = node_idx in used, show_type, idx = node_idx)\n-        end\n-        println(io)\n-    end\n     while (next = pop_new_node!(idx)) !== nothing\n-        only_after || print_new_node(next; final=false)\n+        only_after || _print_ir_new_node(io, next, code, sptypes, used, maxlength_idx, label_dynamic_calls,\n+                                         line_info_postprinter, cfg, bb_idx, max_bb_idx_size, bb_color,\n+                                         line_info_preprinter, idx, i; final=false)\n         i += 1\n     end\n \n@@ -766,7 +769,7 @@ function show_ir_stmt(io::IO, code::Union{IRCode, CodeInfo, IncrementalCompact},\n     # FIXME: `only_after` is hack so that we can call this function to print uncompacted\n     #        attach-after nodes when the current node has already been compated already\n     if !only_after\n-        print_indentation(next===nothing)\n+        _print_ir_indentation(io, cfg, bb_idx, max_bb_idx_size, bb_color, line_info_preprinter, idx, i; final=next===nothing)\n         if code isa CodeInfo\n             stmt = statement_indices_to_labels(stmt, cfg)\n         end\n@@ -786,7 +789,9 @@ function show_ir_stmt(io::IO, code::Union{IRCode, CodeInfo, IncrementalCompact},\n \n     # finally, print new nodes that are to be inserted after the current statement\n     while next !== nothing\n-        print_new_node(next)\n+        _print_ir_new_node(io, next, code, sptypes, used, maxlength_idx, label_dynamic_calls,\n+                           line_info_postprinter, cfg, bb_idx, max_bb_idx_size, bb_color,\n+                           line_info_preprinter, idx, i)\n         i += 1\n         next = pop_new_node!(idx; attach_after=true)\n     end"
    },
    {
      "sha": "2059a293a18124c76bdf4f64c550002f4dca6921",
      "filename": "Compiler/src/typeinfer.jl",
      "status": "modified",
      "additions": 34,
      "deletions": 29,
      "changes": 63,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ca29f8ff90ed6813327c2630045eae2d4b35717a/Compiler%2Fsrc%2Ftypeinfer.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ca29f8ff90ed6813327c2630045eae2d4b35717a/Compiler%2Fsrc%2Ftypeinfer.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/Compiler%2Fsrc%2Ftypeinfer.jl?ref=ca29f8ff90ed6813327c2630045eae2d4b35717a",
      "patch": "@@ -1104,6 +1104,39 @@ function codeinst_as_edge(interp::AbstractInterpreter, sv::InferenceState, @nosp\n     return ci\n end\n \n+function _schedule_edge_infer_task!(caller::AbsIntState, frame::InferenceState, result::InferenceResult,\n+                                    method::Method, edge_ci::Union{Nothing,CodeInstance},\n+                                    edgecycle::Bool, edgelimited::Bool)\n+    mresult = Future{MethodCallResult}()\n+    push!(caller.tasks, function get_infer_result(interp, caller)\n+        update_valid_age!(caller, get_inference_world(interp), frame.valid_worlds)\n+        isinferred = is_inferred(frame)\n+        effects = nothing\n+        edge = nothing\n+        call_result = nothing\n+        if isinferred\n+            edge = result.ci\n+            if edge_ci isa CodeInstance && codeinst_edges_sub(edge_ci, edge.min_world, edge.max_world, edge.edges)\n+                edge = edge_ci # override the edge for tracking invalidation\n+            end\n+            result.ci_as_edge = edge # override the edge for tracking purposes\n+            effects = result.ipo_effects # effects are adjusted already within `finish` for ipo_effects\n+            call_result = result\n+        else\n+            effects = adjust_effects(effects_for_cycle(frame.ipo_effects), method)\n+            add_cycle_backedge!(caller, frame)\n+        end\n+        bestguess = frame.bestguess\n+        exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)\n+        # propagate newly inferred source to the inliner, allowing efficient inlining w/o deserialization:\n+        # note that this result is cached globally exclusively, so we can use this local result destructively\n+        mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,\n+            edge, edgecycle, edgelimited, call_result)\n+        return true\n+    end)\n+    return mresult\n+end\n+\n # compute (and cache) an inferred AST and return the current best estimate of the result type\n function typeinf_edge(interp::AbstractInterpreter, method::Method, @nospecialize(atype), sparams::SimpleVector, caller::AbsIntState, edgecycle::Bool, edgelimited::Bool)\n     mi = specialize_method(method, atype, sparams)\n@@ -1204,35 +1237,7 @@ function typeinf_edge(interp::AbstractInterpreter, method::Method, @nospecialize\n         assign_parentchild!(frame, caller)\n         # the actual inference task for this edge is going to be scheduled within `typeinf_local` via the callstack queue\n         # while splitting off the rest of the work for this caller into a separate workq thunk\n-        let mresult = Future{MethodCallResult}()\n-            push!(caller.tasks, function get_infer_result(interp, caller)\n-                update_valid_age!(caller, get_inference_world(interp), frame.valid_worlds)\n-                local isinferred = is_inferred(frame)\n-                local effects\n-                local edge = nothing\n-                local call_result = nothing\n-                if isinferred\n-                    edge = result.ci\n-                    if edge_ci isa CodeInstance && codeinst_edges_sub(edge_ci, edge.min_world, edge.max_world, edge.edges)\n-                        edge = edge_ci # override the edge for tracking invalidation\n-                    end\n-                    result.ci_as_edge = edge # override the edge for tracking purposes\n-                    effects = result.ipo_effects # effects are adjusted already within `finish` for ipo_effects\n-                    call_result = result\n-                else\n-                    effects = adjust_effects(effects_for_cycle(frame.ipo_effects), method)\n-                    add_cycle_backedge!(caller, frame)\n-                end\n-                local bestguess = frame.bestguess\n-                local exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)\n-                # propagate newly inferred source to the inliner, allowing efficient inlining w/o deserialization:\n-                # note that this result is cached globally exclusively, so we can use this local result destructively\n-                mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,\n-                    edge, edgecycle, edgelimited, call_result)\n-                return true\n-            end)\n-            return mresult\n-        end\n+        return _schedule_edge_infer_task!(caller, frame, result, method, edge_ci, edgecycle, edgelimited)\n     elseif frame === true\n         # unresolvable cycle\n         add_remark!(interp, caller, \"[typeinf_edge] Unresolvable cycle\")"
    },
    {
      "sha": "c8b2805fcd7ad2487636775ab6374f9884234c32",
      "filename": "base/precompilation.jl",
      "status": "modified",
      "additions": 16,
      "deletions": 14,
      "changes": 30,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ca29f8ff90ed6813327c2630045eae2d4b35717a/base%2Fprecompilation.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ca29f8ff90ed6813327c2630045eae2d4b35717a/base%2Fprecompilation.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fprecompilation.jl?ref=ca29f8ff90ed6813327c2630045eae2d4b35717a",
      "patch": "@@ -560,6 +560,21 @@ function precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}}=String[];\n                    IOContext{IO}(io), fancyprint, manifest, ignore_loaded)\n end\n \n+function _visit_indirect_deps!(direct_deps::Dict{PkgId, Vector{PkgId}}, visited::Set{PkgId},\n+                               node::PkgId, all_deps::Set{PkgId})\n+    if node in visited\n+        return\n+    end\n+    push!(visited, node)\n+    for dep in get(Set{PkgId}, direct_deps, node)\n+        if !(dep in all_deps)\n+            push!(all_deps, dep)\n+            _visit_indirect_deps!(direct_deps, visited, dep, all_deps)\n+        end\n+    end\n+    return\n+end\n+\n function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n                          internal_call::Bool,\n                          strict::Bool,\n@@ -705,25 +720,12 @@ function _precompilepkgs(pkgs::Union{Vector{String}, Vector{PkgId}},\n \n     # A package depends on an extension if it (indirectly) depends on all extension triggers\n     function expand_indirect_dependencies(direct_deps)\n-        function visit!(visited, node, all_deps)\n-            if node in visited\n-                return\n-            end\n-            push!(visited, node)\n-            for dep in get(Set{Base.PkgId}, direct_deps, node)\n-                if !(dep in all_deps)\n-                    push!(all_deps, dep)\n-                    visit!(visited, dep, all_deps)\n-                end\n-            end\n-        end\n-\n         local indirect_deps = Dict{Base.PkgId, Set{Base.PkgId}}()\n         for package in keys(direct_deps)\n             # Initialize a set to keep track of all dependencies for 'package'\n             all_deps = Set{Base.PkgId}()\n             visited = Set{Base.PkgId}()\n-            visit!(visited, package, all_deps)\n+            _visit_indirect_deps!(direct_deps, visited, package, all_deps)\n             # Update direct_deps with the complete set of dependencies for 'package'\n             indirect_deps[package] = all_deps\n         end"
    },
    {
      "sha": "e04f8cdd4a1f639f61340555cac77f9fed3812aa",
      "filename": "base/weakkeydict.jl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ca29f8ff90ed6813327c2630045eae2d4b35717a/base%2Fweakkeydict.jl",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ca29f8ff90ed6813327c2630045eae2d4b35717a/base%2Fweakkeydict.jl",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/base%2Fweakkeydict.jl?ref=ca29f8ff90ed6813327c2630045eae2d4b35717a",
      "patch": "@@ -195,7 +195,7 @@ function length(t::WeakKeyDict)\n end\n \n function iterate(t::WeakKeyDict{K,V}, state...) where {K, V}\n-    return lock(t) do\n+    @lock t begin\n         while true\n             y = iterate(t.ht, state...)\n             y === nothing && return nothing"
    }
  ]
}