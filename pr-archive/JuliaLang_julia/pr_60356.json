{
  "url": "https://api.github.com/repos/JuliaLang/julia/issues/60356",
  "repository_url": "https://api.github.com/repos/JuliaLang/julia",
  "labels_url": "https://api.github.com/repos/JuliaLang/julia/issues/60356/labels{/name}",
  "comments_url": "https://api.github.com/repos/JuliaLang/julia/issues/60356/comments",
  "events_url": "https://api.github.com/repos/JuliaLang/julia/issues/60356/events",
  "html_url": "https://github.com/JuliaLang/julia/pull/60356",
  "id": 3716627806,
  "node_id": "PR_kwDOABkWpM64Ny2N",
  "number": 60356,
  "title": "(Mostly) Trivial part of LLVM 21 support",
  "user": {
    "login": "yuyichao",
    "id": 712232,
    "node_id": "MDQ6VXNlcjcxMjIzMg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/712232?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/yuyichao",
    "html_url": "https://github.com/yuyichao",
    "followers_url": "https://api.github.com/users/yuyichao/followers",
    "following_url": "https://api.github.com/users/yuyichao/following{/other_user}",
    "gists_url": "https://api.github.com/users/yuyichao/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/yuyichao/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/yuyichao/subscriptions",
    "organizations_url": "https://api.github.com/users/yuyichao/orgs",
    "repos_url": "https://api.github.com/users/yuyichao/repos",
    "events_url": "https://api.github.com/users/yuyichao/events{/privacy}",
    "received_events_url": "https://api.github.com/users/yuyichao/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "labels": [],
  "state": "closed",
  "locked": false,
  "assignee": {
    "login": "JeffBezanson",
    "id": 744556,
    "node_id": "MDQ6VXNlcjc0NDU1Ng==",
    "avatar_url": "https://avatars.githubusercontent.com/u/744556?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JeffBezanson",
    "html_url": "https://github.com/JeffBezanson",
    "followers_url": "https://api.github.com/users/JeffBezanson/followers",
    "following_url": "https://api.github.com/users/JeffBezanson/following{/other_user}",
    "gists_url": "https://api.github.com/users/JeffBezanson/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JeffBezanson/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JeffBezanson/subscriptions",
    "organizations_url": "https://api.github.com/users/JeffBezanson/orgs",
    "repos_url": "https://api.github.com/users/JeffBezanson/repos",
    "events_url": "https://api.github.com/users/JeffBezanson/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JeffBezanson/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "JeffBezanson",
      "id": 744556,
      "node_id": "MDQ6VXNlcjc0NDU1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/744556?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeffBezanson",
      "html_url": "https://github.com/JeffBezanson",
      "followers_url": "https://api.github.com/users/JeffBezanson/followers",
      "following_url": "https://api.github.com/users/JeffBezanson/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeffBezanson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeffBezanson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeffBezanson/subscriptions",
      "organizations_url": "https://api.github.com/users/JeffBezanson/orgs",
      "repos_url": "https://api.github.com/users/JeffBezanson/repos",
      "events_url": "https://api.github.com/users/JeffBezanson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeffBezanson/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2025-12-10T20:11:56Z",
  "updated_at": "2025-12-11T18:50:23Z",
  "closed_at": "2025-12-11T18:50:21Z",
  "author_association": "CONTRIBUTOR",
  "type": null,
  "active_lock_reason": null,
  "draft": false,
  "pull_request": {
    "url": "https://api.github.com/repos/JuliaLang/julia/pulls/60356",
    "html_url": "https://github.com/JuliaLang/julia/pull/60356",
    "diff_url": "https://github.com/JuliaLang/julia/pull/60356.diff",
    "patch_url": "https://github.com/JuliaLang/julia/pull/60356.patch",
    "merged_at": "2025-12-11T18:50:21Z"
  },
  "body": "Split out of https://github.com/JuliaLang/julia/pull/59946 to make it hopefully easier to review.",
  "reactions": {
    "url": "https://api.github.com/repos/JuliaLang/julia/issues/60356/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/JuliaLang/julia/issues/60356/timeline",
  "performed_via_github_app": null,
  "state_reason": null,
  "score": 1.0,
  "files": [
    {
      "sha": "6e86b7d245558e50e868e3223e0e4721e04ed6d5",
      "filename": "src/aotcompile.cpp",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Faotcompile.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Faotcompile.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Faotcompile.cpp?ref=ad589da1f96b82bcd60ea269d7fae60a73012fb8",
      "patch": "@@ -565,7 +565,9 @@ Function *IRLinker_copyFunctionProto(Module *DstM, Function *SF) {\n   auto *F = Function::Create(SF->getFunctionType(), SF->getLinkage(),\n                              SF->getAddressSpace(), SF->getName(), DstM);\n   F->copyAttributesFrom(SF);\n+#if JL_LLVM_VERSION < 210000\n   F->IsNewDbgInfoFormat = SF->IsNewDbgInfoFormat;\n+#endif\n \n   // Remove these copied constants since they point to the source module.\n   F->setPersonalityFn(nullptr);\n@@ -1557,7 +1559,11 @@ static AOTOutputs add_output_impl(Module &M, TargetMachine &SourceTM, ShardTimer\n     AOTOutputs out;\n     auto TM = std::unique_ptr<TargetMachine>(\n         SourceTM.getTarget().createTargetMachine(\n+#if JL_LLVM_VERSION < 210000\n             SourceTM.getTargetTriple().str(),\n+#else\n+            SourceTM.getTargetTriple(),\n+#endif\n             SourceTM.getTargetCPU(),\n             SourceTM.getTargetFeatureString(),\n             SourceTM.Options,\n@@ -1585,7 +1591,11 @@ static AOTOutputs add_output_impl(Module &M, TargetMachine &SourceTM, ShardTimer\n \n         auto PMTM = std::unique_ptr<TargetMachine>(\n             SourceTM.getTarget().createTargetMachine(\n+#if JL_LLVM_VERSION < 210000\n                 SourceTM.getTargetTriple().str(),\n+#else\n+                SourceTM.getTargetTriple(),\n+#endif\n                 SourceTM.getTargetCPU(),\n                 SourceTM.getTargetFeatureString(),\n                 SourceTM.Options,\n@@ -2141,7 +2151,11 @@ void jl_dump_native_impl(void *native_code,\n     }\n     std::unique_ptr<TargetMachine> SourceTM(\n         jl_ExecutionEngine->getTarget().createTargetMachine(\n+#if JL_LLVM_VERSION < 210000\n             TheTriple.getTriple(),\n+#else\n+            TheTriple,\n+#endif\n             jl_ExecutionEngine->getTargetCPU(),\n             jl_ExecutionEngine->getTargetFeatureString(),\n             jl_ExecutionEngine->getTargetOptions(),\n@@ -2174,7 +2188,11 @@ void jl_dump_native_impl(void *native_code,\n         LLVMContext Context;\n         Context.setDiscardValueNames(true);\n         Module sysimgM(\"sysimg\", Context);\n+#if JL_LLVM_VERSION < 210000\n         sysimgM.setTargetTriple(TheTriple.str());\n+#else\n+        sysimgM.setTargetTriple(TheTriple);\n+#endif\n         sysimgM.setDataLayout(DL);\n         sysimgM.setStackProtectorGuard(StackProtectorGuard);\n         sysimgM.setOverrideStackAlignment(OverrideStackAlignment);\n@@ -2242,7 +2260,11 @@ void jl_dump_native_impl(void *native_code,\n \n     data->M.withModuleDo([&](Module &dataM) {\n         JL_TIMING(NATIVE_AOT, NATIVE_Setup);\n+#if JL_LLVM_VERSION < 210000\n         dataM.setTargetTriple(TheTriple.str());\n+#else\n+        dataM.setTargetTriple(TheTriple);\n+#endif\n         dataM.setDataLayout(DL);\n         dataM.setPICLevel(PICLevel::BigPIC);\n         auto &Context = dataM.getContext();\n@@ -2343,7 +2365,11 @@ void jl_dump_native_impl(void *native_code,\n         LLVMContext Context;\n         Context.setDiscardValueNames(true);\n         Module metadataM(\"metadata\", Context);\n+#if JL_LLVM_VERSION < 210000\n         metadataM.setTargetTriple(TheTriple.str());\n+#else\n+        metadataM.setTargetTriple(TheTriple);\n+#endif\n         metadataM.setDataLayout(DL);\n         metadataM.setStackProtectorGuard(StackProtectorGuard);\n         metadataM.setOverrideStackAlignment(OverrideStackAlignment);"
    },
    {
      "sha": "6f7bd71ffb08a5b6879907e3700c76ed4cdb1b19",
      "filename": "src/cgmemmgr.cpp",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fcgmemmgr.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fcgmemmgr.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcgmemmgr.cpp?ref=ad589da1f96b82bcd60ea269d7fae60a73012fb8",
      "patch": "@@ -1013,10 +1013,19 @@ class JLJITLinkMemoryManager::InFlightAlloc\n             if (!FA)\n                 return OnFinalized(FA.takeError());\n             // Need to handle dealloc actions when we GC code\n+#if JL_LLVM_VERSION >= 210000 && JL_LLVM_VERSION < 220000\n+            // This change was reverted before llvm 22 is branched off\n+            orc::shared::runFinalizeActions(GP->allocActions(), [&] (auto E) {\n+                if (!E)\n+                    return OnFinalized(E.takeError());\n+                OnFinalized(std::move(FA));\n+            });\n+#else\n             auto E = orc::shared::runFinalizeActions(GP->allocActions());\n             if (!E)\n                 return OnFinalized(E.takeError());\n             OnFinalized(std::move(FA));\n+#endif\n         });\n     }\n };"
    },
    {
      "sha": "92bfcc869cc6840b9876fbfc8f96a5a6a8ce2ba1",
      "filename": "src/cgutils.cpp",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fcgutils.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fcgutils.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcgutils.cpp?ref=ad589da1f96b82bcd60ea269d7fae60a73012fb8",
      "patch": "@@ -1158,8 +1158,13 @@ static void emit_memcpy_llvm(jl_codectx_t &ctx, Value *dst, jl_aliasinfo_t const\n     // above problem won't be as serious.\n \n     auto merged_ai = dst_ai.merge(src_ai);\n+#if JL_LLVM_VERSION < 210000\n     ctx.builder.CreateMemCpy(dst, align_dst, src, align_src, sz, is_volatile,\n                              merged_ai.tbaa, merged_ai.tbaa_struct, merged_ai.scope, merged_ai.noalias);\n+#else\n+    ctx.builder.CreateMemCpy(dst, align_dst, src, align_src, sz, is_volatile,\n+                             merged_ai.toAAMDNodes());\n+#endif\n }\n \n template<typename T1>"
    },
    {
      "sha": "3729b7dbf0a18d013838a13bc1eab53ae4ae41ca",
      "filename": "src/codegen.cpp",
      "status": "modified",
      "additions": 43,
      "deletions": 10,
      "changes": 53,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fcodegen.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fcodegen.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fcodegen.cpp?ref=ad589da1f96b82bcd60ea269d7fae60a73012fb8",
      "patch": "@@ -605,6 +605,24 @@ AttributeSet Attributes(LLVMContext &C, std::initializer_list<Attribute::AttrKin\n     return AttributeSet::get(C, ArrayRef<Attribute>(attrs));\n }\n \n+static inline Attribute NoCaptureAttr(LLVMContext &C)\n+{\n+#if JL_LLVM_VERSION < 210000\n+    return Attribute::get(C, Attribute::NoCapture);\n+#else\n+    return Attribute::getWithCaptureInfo(C, CaptureInfo(CaptureComponents::None));\n+#endif\n+}\n+\n+static inline void addNoCaptureAttr(AttrBuilder &param)\n+{\n+#if JL_LLVM_VERSION < 210000\n+    param.addAttribute(Attribute::NoCapture);\n+#else\n+    param.addCapturesAttr(CaptureInfo(CaptureComponents::None));\n+#endif\n+}\n+\n static Type *get_pjlvalue(LLVMContext &C) { return JuliaType::get_pjlvalue_ty(C); }\n \n static FunctionType *get_func_sig(LLVMContext &C) { return JuliaType::get_jlfunc_ty(C); }\n@@ -617,7 +635,7 @@ static AttributeList get_func_attrs(LLVMContext &C)\n             AttributeSet(),\n             Attributes(C, {Attribute::NonNull}),\n             {AttributeSet(),\n-             Attributes(C, {Attribute::NoAlias, Attribute::ReadOnly, Attribute::NoCapture, Attribute::NoUndef})});\n+             Attributes(C, {Attribute::NoAlias, Attribute::ReadOnly, Attribute::NoUndef}, {NoCaptureAttr(C)})});\n }\n \n static AttributeList get_attrs_noreturn(LLVMContext &C)\n@@ -996,7 +1014,7 @@ static const auto jllockvalue_func = new JuliaFunction<>{\n     [](LLVMContext &C) { return AttributeList::get(C,\n             AttributeSet(),\n             AttributeSet(),\n-            {Attributes(C, {Attribute::NoCapture})}); },\n+            {Attributes(C, {}, {NoCaptureAttr(C)})}); },\n };\n static const auto jlunlockvalue_func = new JuliaFunction<>{\n     XSTR(jl_unlock_value),\n@@ -1005,7 +1023,7 @@ static const auto jlunlockvalue_func = new JuliaFunction<>{\n     [](LLVMContext &C) { return AttributeList::get(C,\n             AttributeSet(),\n             AttributeSet(),\n-            {Attributes(C, {Attribute::NoCapture})}); },\n+            {Attributes(C, {}, {NoCaptureAttr(C)})}); },\n };\n static const auto jllockfield_func = new JuliaFunction<>{\n     XSTR(jl_lock_field),\n@@ -1014,7 +1032,7 @@ static const auto jllockfield_func = new JuliaFunction<>{\n     [](LLVMContext &C) { return AttributeList::get(C,\n             AttributeSet(),\n             AttributeSet(),\n-            {Attributes(C, {Attribute::NoCapture})}); },\n+            {Attributes(C, {}, {NoCaptureAttr(C)})}); },\n };\n static const auto jlunlockfield_func = new JuliaFunction<>{\n     XSTR(jl_unlock_field),\n@@ -1023,7 +1041,7 @@ static const auto jlunlockfield_func = new JuliaFunction<>{\n     [](LLVMContext &C) { return AttributeList::get(C,\n             AttributeSet(),\n             AttributeSet(),\n-            {Attributes(C, {Attribute::NoCapture})}); },\n+            {Attributes(C, {}, {NoCaptureAttr(C)})}); },\n };\n static const auto jlenter_func = new JuliaFunction<>{\n     XSTR(jl_enter_handler),\n@@ -1489,7 +1507,7 @@ static const auto gc_loaded_func = new JuliaFunction<>{\n         RetAttrs.addAttribute(Attribute::NonNull);\n         RetAttrs.addAttribute(Attribute::NoUndef);\n         return AttributeList::get(C, AttributeSet::get(C,FnAttrs), AttributeSet::get(C,RetAttrs),\n-                { Attributes(C, {Attribute::NonNull, Attribute::NoUndef, Attribute::ReadNone, Attribute::NoCapture}),\n+                { Attributes(C, {Attribute::NonNull, Attribute::NoUndef, Attribute::ReadNone}, {NoCaptureAttr(C)}),\n                   Attributes(C, {Attribute::NonNull, Attribute::NoUndef, Attribute::ReadNone}) });\n                   },\n };\n@@ -1703,6 +1721,15 @@ struct jl_aliasinfo_t {\n     // memory region non-aliasing. It should be deleted once the TBAA metadata\n     // is improved to encode only memory layout and *not* memory regions.\n     static jl_aliasinfo_t fromTBAA(jl_codectx_t &ctx, MDNode *tbaa);\n+\n+    AAMDNodes toAAMDNodes() const\n+    {\n+#if JL_LLVM_VERSION < 220000\n+        return AAMDNodes(tbaa, tbaa_struct, scope, noalias);\n+#else\n+        return AAMDNodes(tbaa, tbaa_struct, scope, noalias, nullptr);\n+#endif\n+    }\n };\n \n // metadata tracking for a llvm Value* during codegen\n@@ -2812,7 +2839,11 @@ std::unique_ptr<Module> jl_create_llvm_module(StringRef name, LLVMContext &conte\n         m->addModuleFlag(llvm::Module::Warning, \"Debug Info Version\",\n             llvm::DEBUG_METADATA_VERSION);\n     m->setDataLayout(DL);\n+#if JL_LLVM_VERSION < 210000\n     m->setTargetTriple(triple.str());\n+#else\n+    m->setTargetTriple(triple);\n+#endif\n \n     if (triple.isOSWindows() && triple.getArch() == Triple::x86) {\n         // tell Win32 to assume the stack is always 16-byte aligned,\n@@ -8105,15 +8136,15 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n             param.addAttribute(\"julia.return_roots\", std::to_string(tracked_count));\n         }\n         param.addAttribute(Attribute::NoAlias);\n-        param.addAttribute(Attribute::NoCapture);\n+        addNoCaptureAttr(param);\n         param.addAttribute(Attribute::NoUndef);\n         attrs.push_back(AttributeSet::get(M->getContext(), param));\n         assert(fsig.size() == 1);\n     }\n     if (props.cc == jl_returninfo_t::Union) {\n         AttrBuilder param(M->getContext());\n         param.addAttribute(Attribute::NoAlias);\n-        param.addAttribute(Attribute::NoCapture);\n+        addNoCaptureAttr(param);\n         param.addAttribute(Attribute::NoUndef);\n         attrs.push_back(AttributeSet::get(M->getContext(), param));\n         assert(fsig.size() == 1);\n@@ -8122,7 +8153,7 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n     if (props.return_roots) {\n         AttrBuilder param(M->getContext());\n         param.addAttribute(Attribute::NoAlias);\n-        param.addAttribute(Attribute::NoCapture);\n+        addNoCaptureAttr(param);\n         param.addAttribute(Attribute::NoUndef);\n         param.addAttribute(\"julia.return_roots\", std::to_string(props.return_roots));\n         attrs.push_back(AttributeSet::get(M->getContext(), param));\n@@ -8157,7 +8188,7 @@ static jl_returninfo_t get_specsig_function(jl_codegen_params_t &params, Module\n         AttrBuilder param(M->getContext());\n         Type *ty = et;\n         if (et == nullptr || et->isAggregateType()) { // aggregate types are passed by pointer\n-            param.addAttribute(Attribute::NoCapture);\n+            addNoCaptureAttr(param);\n             param.addAttribute(Attribute::ReadOnly);\n             ty = PointerType::get(M->getContext(), AddressSpace::Derived);\n         }\n@@ -10038,7 +10069,9 @@ void linkFunctionBody(Function &Dst, Function &Src)\n         Dst.setPersonalityFn(Src.getPersonalityFn());\n     if (Src.hasPersonalityFn())\n         Dst.setPersonalityFn(Src.getPersonalityFn());\n+#if JL_LLVM_VERSION < 210000\n     assert(Src.IsNewDbgInfoFormat == Dst.IsNewDbgInfoFormat);\n+#endif\n \n     // Copy over the metadata attachments without remapping.\n     Dst.copyMetadata(&Src, 0);"
    },
    {
      "sha": "c461f0938e0c5dda7ea667a7321b31d1445e8927",
      "filename": "src/debuginfo.cpp",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fdebuginfo.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fdebuginfo.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fdebuginfo.cpp?ref=ad589da1f96b82bcd60ea269d7fae60a73012fb8",
      "patch": "@@ -505,8 +505,13 @@ static int lookup_pointer(\n         else {\n             int havelock = jl_lock_profile_wr();\n             assert(havelock); (void)havelock;\n-            info = context->getLineInfoForAddress(makeAddress(Section, pointer + slide), infoSpec);\n+            auto lineinfo = context->getLineInfoForAddress(makeAddress(Section, pointer + slide), infoSpec);\n             jl_unlock_profile_wr();\n+#if JL_LLVM_VERSION < 210000\n+            info = std::move(lineinfo);\n+#else\n+            info = std::move(lineinfo.value());\n+#endif\n         }\n \n         jl_frame_t *frame = &(*frames)[i];"
    },
    {
      "sha": "7f79737a9a7cb342b6fed99d3cc7a517d13e7319",
      "filename": "src/disasm.cpp",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fdisasm.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fdisasm.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fdisasm.cpp?ref=ad589da1f96b82bcd60ea269d7fae60a73012fb8",
      "patch": "@@ -924,7 +924,11 @@ static void jl_dump_asm_internal(\n     // LLVM will destroy the formatted stream, and we keep the raw stream.\n     std::unique_ptr<formatted_raw_ostream> ustream(new formatted_raw_ostream(rstream));\n     std::unique_ptr<MCStreamer> Streamer(\n-#if JL_LLVM_VERSION >= 190000\n+#if JL_LLVM_VERSION >= 210000\n+        TheTarget->createAsmStreamer(Ctx, std::move(ustream),\n+\n+                                     std::move(IP), std::move(CE), std::move(MAB))\n+#elif JL_LLVM_VERSION >= 190000\n         TheTarget->createAsmStreamer(Ctx, std::move(ustream),\n \n                                      IP.release(), std::move(CE), std::move(MAB))\n@@ -1268,8 +1272,8 @@ jl_value_t *jl_dump_function_asm_impl(jl_llvmf_dump_t* dump, char emit_mc, const\n                 OutputAsmDialect = 0;\n             if (!strcmp(asm_variant, \"intel\"))\n                 OutputAsmDialect = 1;\n-            MCInstPrinter *InstPrinter = TM->getTarget().createMCInstPrinter(\n-                jl_ExecutionEngine->getTargetTriple(), OutputAsmDialect, MAI, MII, MRI);\n+            std::unique_ptr<MCInstPrinter> InstPrinter(TM->getTarget().createMCInstPrinter(\n+                                                           jl_ExecutionEngine->getTargetTriple(), OutputAsmDialect, MAI, MII, MRI));\n             std::unique_ptr<MCAsmBackend> MAB(TM->getTarget().createMCAsmBackend(\n                 STI, MRI, Options));\n             std::unique_ptr<MCCodeEmitter> MCE;\n@@ -1278,8 +1282,10 @@ jl_value_t *jl_dump_function_asm_impl(jl_llvmf_dump_t* dump, char emit_mc, const\n             }\n             auto FOut = std::make_unique<formatted_raw_ostream>(asmfile);\n             std::unique_ptr<MCStreamer> S(TM->getTarget().createAsmStreamer(\n-#if JL_LLVM_VERSION >= 190000\n-                *Context, std::move(FOut), InstPrinter, std::move(MCE), std::move(MAB)\n+#if JL_LLVM_VERSION >= 210000\n+                *Context, std::move(FOut), std::move(InstPrinter), std::move(MCE), std::move(MAB)\n+#elif JL_LLVM_VERSION >= 190000\n+                *Context, std::move(FOut), InstPrinter.release(), std::move(MCE), std::move(MAB)\n #else\n                 *Context, std::move(FOut), true, true, InstPrinter, std::move(MCE),\n                 std::move(MAB), false"
    },
    {
      "sha": "0d504ec3e75f6a6564ce9b581bbb4d51b302ad77",
      "filename": "src/jitlayers.cpp",
      "status": "modified",
      "additions": 15,
      "deletions": 2,
      "changes": 17,
      "blob_url": "https://github.com/JuliaLang/julia/blob/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fjitlayers.cpp",
      "raw_url": "https://github.com/JuliaLang/julia/raw/ad589da1f96b82bcd60ea269d7fae60a73012fb8/src%2Fjitlayers.cpp",
      "contents_url": "https://api.github.com/repos/JuliaLang/julia/contents/src%2Fjitlayers.cpp?ref=ad589da1f96b82bcd60ea269d7fae60a73012fb8",
      "patch": "@@ -14,6 +14,9 @@\n #include <llvm/ExecutionEngine/Orc/CompileUtils.h>\n #include <llvm/ExecutionEngine/Orc/ExecutionUtils.h>\n #include <llvm/ExecutionEngine/Orc/DebugObjectManagerPlugin.h>\n+#if JL_LLVM_VERSION >= 210000\n+#  include <llvm/ExecutionEngine/Orc/SelfExecutorProcessControl.h>\n+#endif\n #include <llvm/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.h>\n #if JL_LLVM_VERSION >= 200000\n #include <llvm/ExecutionEngine/Orc/AbsoluteSymbols.h>\n@@ -1396,7 +1399,12 @@ namespace {\n         }\n         auto optlevel = CodeGenOptLevelFor(jl_options.opt_level);\n         auto TM = TheTarget->createTargetMachine(\n-                TheTriple.getTriple(), TheCPU, FeaturesStr,\n+#if JL_LLVM_VERSION < 210000\n+                TheTriple.getTriple(),\n+#else\n+                TheTriple,\n+#endif\n+                TheCPU, FeaturesStr,\n                 options,\n                 relocmodel,\n                 codemodel,\n@@ -1926,7 +1934,8 @@ JuliaOJIT::JuliaOJIT()\n     MemMgr(createRTDyldMemoryManager()),\n     UnlockedObjectLayer(\n             ES,\n-            [this]() {\n+            [this](auto&&...) {\n+                // LLVM 21+ passes in a memory buffer\n                 std::unique_ptr<RuntimeDyld::MemoryManager> result(new ForwardingMemoryManager(MemMgr));\n                 return result;\n             }\n@@ -2382,7 +2391,11 @@ std::unique_ptr<TargetMachine> JuliaOJIT::cloneTargetMachine() const\n {\n     auto NewTM = std::unique_ptr<TargetMachine>(getTarget()\n         .createTargetMachine(\n+#if JL_LLVM_VERSION < 210000\n             getTargetTriple().str(),\n+#else\n+            getTargetTriple(),\n+#endif\n             getTargetCPU(),\n             getTargetFeatureString(),\n             getTargetOptions(),"
    }
  ]
}