schema_version: "1.0"

pr:
  number: 58107
  title: "Mention Base.Lockable in \"multi-threading.md\""
  url: "https://github.com/JuliaLang/julia/pull/58107"
  diff_url: "https://github.com/JuliaLang/julia/pull/58107.diff"
  author: "KronosTheLate"
  labels:
    - "docs"
    - "parallelism"
    - "multithreading"
  created_at: "2025-04-14T14:51:01Z"
  merged_at: "2025-10-22T22:21:49Z"
  merge_commit_sha: "edc7465dbc2e30af0629114bcd66c4f02c3e7594"

scope:
  files_touched:
    - "doc/src/manual/multi-threading.md"
  components:
    - "Documentation"
  pipeline_stages: []

analysis:
  intent:
    summary: |
      Adds documentation for Base.Lockable to the multi-threading manual. The helper type
      Base.Lockable (introduced in Julia 1.11) allows programmers to programmatically
      associate a lock with a value, rather than relying on convention. This PR documents
      its usage with examples showing the wrapper, indexing syntax, and functional lock patterns.
    issue_links: []
    quoted_from_pr: |
      I was therefore very happy to see Base.Lockable introduced in Julia 1.11. What was
      missing, was any mention of it in the relevant section of the manual.

      This PR adds a subsection under locks (So a forth level of headings, not sure if that
      is fine), showcasing and reccomending the use of Base.Lockable. I have made heavy use
      of comments in the example, which breaks with the general style, but adds valuable
      interpretation along the way.

  direct_changes:
    - summary: "Added new subsection documenting Base.Lockable usage with examples"
      component: "Documentation"
      evidence:
        - source: "diff"
          path: "doc/src/manual/multi-threading.md"
          loc: "347-387"
          url: "https://github.com/JuliaLang/julia/blob/edc7465dbc2e30af0629114bcd66c4f02c3e7594/doc/src/manual/multi-threading.md#L347-L387"
          snippet: |
            #### [Using Base.Lockable to associate a lock and a value](@id man-lockable)
            As mentioned in the previous section, the helper-type [`Base.Lockable`](@ref) can be used
            to programmatically ensure the association between a lock and a value. This is generally
            recommended, as it is both less prone to error and more readable for others compared to
            having the association only by convention.

            Any object can be wrapped in `Base.Lockable`:
            ```julia-repl
            julia> my_array = [];

            julia> my_locked_array = Base.Lockable(my_array);
            ```

            If the lock is held, the underlying object can be accessed with the empty indexing notation:
            ```julia-repl
            julia> begin
                       lock(my_locked_array)
                       try
                           push!(my_locked_array[], 1)
                       finally
                           unlock(my_locked_array)
                       end
                   end
            1-element Vector{Any}:
             1
            ```

            It is usually easier and safer to pass a function as the first argument to `lock`.
            The function is applied to the unlocked object, and the locking/unlocking is handled
            automatically:
            ```julia-repl
            julia> lock(x -> push!(x, 2), my_locked_array);

            julia> lock(display, my_locked_array)
            2-element Vector{Any}:
             1
             2

            julia> lock(my_locked_array) do x
                       x[1] = pi
                       display(x)
                   end
            2-element Vector{Any}:
             pi = 3.1415926535897...
             2
            ```

    - summary: "Minor grammar fix in lock introduction paragraph"
      component: "Documentation"
      evidence:
        - source: "diff"
          path: "doc/src/manual/multi-threading.md"
          loc: "308-311"
          url: "https://github.com/JuliaLang/julia/blob/edc7465dbc2e30af0629114bcd66c4f02c3e7594/doc/src/manual/multi-threading.md#L308-L311"
          snippet: |
            # BEFORE:
            An important tool to avoid data-races, and thereby write thread-safe code,
            is the concept of a "lock".

            # AFTER:
            An important tool for avoiding data races, and writing thread-safe code in general,
            is the concept of a "lock".

    - summary: "Added cross-reference from locks section to new Lockable subsection"
      component: "Documentation"
      evidence:
        - source: "diff"
          path: "doc/src/manual/multi-threading.md"
          loc: "311"
          url: "https://github.com/JuliaLang/julia/blob/edc7465dbc2e30af0629114bcd66c4f02c3e7594/doc/src/manual/multi-threading.md#L311"
          snippet: |
            Note that the link between a lock and a variable is made by the programmer, and not
            the program. A helper-type [`Base.Lockable`](@ref) exists that helps you associate a
            lock and a value. This is often more safe than keeping track yourself, and is detailed
            under [Using Base.Lockable to associate a lock and a value](@ref man-lockable).

  pipeline_impact: []

  secondary_effects:
    - effect: "Documentation now references the Base.Lockable API"
      mechanism: |
        The documentation includes docref links:
          [`Base.Lockable`](@ref) -> links to base/lock.jl:400-428 docstring

        The Lockable struct implementation in base/lock.jl:
          struct Lockable{T, L <: AbstractLock}
              value::T
              lock::L
          end

        Lockable(value) = Lockable(value, ReentrantLock())
        getindex(l::Lockable) = (assert_havelock(l.lock); l.value)

        lock(f, l::Lockable) -> acquires l.lock, calls f(l.value), releases lock
        lock(l::Lockable) -> lock(l.lock)
        trylock(l::Lockable) -> trylock(l.lock)
        unlock(l::Lockable) -> unlock(l.lock)
      downstream_surfaces:
        - "Julia documentation website"
        - "help> REPL for Base.Lockable and related functions"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "base/lock.jl"
          loc: "400-455"
          url: "https://github.com/JuliaLang/julia/blob/edc7465dbc2e30af0629114bcd66c4f02c3e7594/base/lock.jl#L400-L455"
          snippet: |
            """
                Lockable(value, lock = ReentrantLock())

            Create a `Lockable` object that wraps `value` and
            associates it with the provided `lock`. This object
            supports [`@lock`](@ref), [`lock`](@ref), [`trylock`](@ref),
            [`unlock`](@ref). To access the value, index the lockable object while
            holding the lock.

            !!! compat "Julia 1.11"
                Requires at least Julia 1.11.
            """
            struct Lockable{T, L <: AbstractLock}
                value::T
                lock::L
            end

            Lockable(value) = Lockable(value, ReentrantLock())
            getindex(l::Lockable) = (assert_havelock(l.lock); l.value)

            # lock with function for Lockable
            function lock(f, l::Lockable)
                lock(l.lock) do
                    f(l.value)
                end
            end

            # Lock interface delegation
            lock(l::Lockable) = lock(l.lock)
            trylock(l::Lockable) = trylock(l.lock)
            unlock(l::Lockable) = unlock(l.lock)

    - effect: "Complements existing API reference documentation"
      mechanism: |
        Base.Lockable was already documented in the API reference at doc/src/base/parallel.md.
        This PR adds usage-oriented manual documentation to complement that API reference.
        The manual documentation explains WHY and HOW to use Lockable with practical examples.
      downstream_surfaces:
        - "Julia manual section on multi-threading"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "doc/src/base/parallel.md"
          loc: "54-58"
          url: "https://github.com/JuliaLang/julia/blob/edc7465dbc2e30af0629114bcd66c4f02c3e7594/doc/src/base/parallel.md#L54-L58"
          snippet: |
            Base.islocked
            Base.ReentrantLock
            Base.@lock
            Base.Lockable

  internal_usage:
    description: |
      Lockable is used within Julia's own codebase for thread-safe caching,
      demonstrating the pattern documented in this PR.
    examples:
      - file: "base/env.jl"
        loc: "6"
        url: "https://github.com/JuliaLang/julia/blob/edc7465dbc2e30af0629114bcd66c4f02c3e7594/base/env.jl#L6"
        description: "Windows environment variable lookup cache"
        snippet: |
          const env_dict = Lockable(Dict{String, Vector{Cwchar_t}}())
      - file: "stdlib/Random/src/DSFMT.jl"
        loc: "129"
        url: "https://github.com/JuliaLang/julia/blob/edc7465dbc2e30af0629114bcd66c4f02c3e7594/stdlib/Random/src/DSFMT.jl#L129"
        description: "Cache for X^(2i) mod m computations in MersenneTwister"
        snippet: |
          const _squares = Base.Lockable(Dict{GF2X, Vector{GF2X}}())
      - file: "stdlib/Random/src/DSFMT.jl"
        loc: "162"
        url: "https://github.com/JuliaLang/julia/blob/edc7465dbc2e30af0629114bcd66c4f02c3e7594/stdlib/Random/src/DSFMT.jl#L162"
        description: "Cached jump polynomials for MersenneTwister"
        snippet: |
          const JumpPolys = Base.Lockable(Dict{BigInt,GF2X}())

  compatibility:
    internal_api: []
    behavioral: []

  performance:
    compile_time: []
    runtime: []

  tests:
    changed_files: []
    new_behavior_assertions: []
    coverage_gaps:
      - "No tests added by this PR - documentation-only change"
    existing_test_coverage:
      - file: "test/misc.jl"
        loc: "132-160"
        url: "https://github.com/JuliaLang/julia/blob/edc7465dbc2e30af0629114bcd66c4f02c3e7594/test/misc.jl#L132-L160"
        description: "Existing tests for Lockable functionality cover export status, constructor variants, indexing, lock/trylock/unlock delegation"
        snippet: |
          # Lockable{T, L<:AbstractLock}
          using Base: Lockable
          let
              @test Base.isexported(Base, :Lockable)
              lockable = Lockable(Dict("foo" => "hello"), ReentrantLock())
              # note field access is non-public
              @test lockable.value["foo"] == "hello"
              @test @lock(lockable, lockable[]["foo"]) == "hello"
              lock(lockable) do d
                  @test d["foo"] == "hello"
              end
              lock(lockable) do d
                  d["foo"] = "goodbye"
              end
              @test lockable.value["foo"] == "goodbye"
              @lock lockable begin
                  @test lockable[]["foo"] == "goodbye"
              end
              l = trylock(lockable)
              try
                  @test l
              finally
                  unlock(lockable)
              end
              # Test 1-arg constructor
              lockable2 = Lockable(Dict("foo" => "hello"))
              @test lockable2.lock isa ReentrantLock
              @test @lock(lockable2, lockable2[]["foo"]) == "hello"
          end

  risk:
    level: "low"
    rationale:
      - "Purely documentation change - no code modifications"
      - "No compiler internals, type inference, or codegen affected"
      - "No API changes - only documents existing Base.Lockable feature"
      - "Base.Lockable has existed since Julia 1.11; this only adds manual documentation"

  open_questions: []

  recommendations:
    - "No action required for downstream compiler packages"
    - "This PR has zero impact on JET, Enzyme, IRTools, GPUCompiler, or Cassette"
    - "Documentation improvement helps users discover Base.Lockable for thread-safe code"

classification:
  type: "documentation"
  compiler_relevant: false
  breaking_change: false
  requires_downstream_action: false

notes: |
  This PR is NOT a compiler change - it only adds documentation to the multi-threading
  manual explaining the Base.Lockable helper type.

  Base.Lockable background (verified against HISTORY.md):
  - Introduced in Julia 1.11 via PR #52898:
      "A new public (but unexported) struct `Base.Lockable{T, L<:AbstractLock}` makes
       it easy to bundle a resource and its lock together"
  - Exported in Julia 1.11 via PR #54595:
      "Lockable is now exported"
  - Export confirmed in base/exports.jl:100

  The Lockable type provides a structured way to associate a lock with a value:
  - Wraps any value with an associated ReentrantLock (or custom AbstractLock)
  - Provides empty indexing l[] to access the value (asserts lock is held)
  - Delegates lock/trylock/unlock to the internal lock
  - Provides lock(f, l::Lockable) that automatically handles locking/unlocking

  Implementation in base/lock.jl:
    struct Lockable{T, L <: AbstractLock}
        value::T
        lock::L
    end

  Key safety feature - getindex checks lock is held:
    getindex(l::Lockable) = (assert_havelock(l.lock); l.value)

  This PR has absolutely NO impact on:
  - Type inference
  - Lowering or IR generation
  - Optimization passes
  - Code generation
  - OpaqueClosure handling
  - Generated functions
  - World age / invalidation
  - Any internal compiler APIs

  It is safe to ignore for all compiler-focused downstream package analysis.

reviewer_enhancement:
  date: "2026-01-21"
  findings:
    - description: "Verified HISTORY.md references are accurate"
      details: |
        Both PR #52898 (introduction) and PR #54595 (export) are correctly referenced
        in HISTORY.md under Julia 1.11 changes.
    - description: "Added existing test coverage documentation"
      details: |
        The Lockable functionality has comprehensive tests in test/misc.jl (lines 132-160)
        that cover: export status verification, constructor variants, indexing syntax,
        lock/trylock/unlock delegation, and the @lock macro integration.
    - description: "Added internal usage examples showing real-world patterns"
      details: |
        Found Lockable used in Julia's own codebase:
        - base/env.jl: Windows environment variable caching
        - stdlib/Random/src/DSFMT.jl: Jump polynomial caching for MersenneTwister
        These demonstrate the thread-safe caching pattern documented in this PR.
    - description: "Identified complementary API documentation"
      details: |
        Base.Lockable already had API reference documentation in doc/src/base/parallel.md.
        This PR specifically fills the gap of usage-oriented manual documentation.
  assessment: |
    The original analysis is accurate and thorough. The enhancements add:
    1. Verification of historical PR references against HISTORY.md
    2. Documentation of existing test coverage (tests existed before this PR)
    3. Real-world usage examples from Julia's internal codebase
    4. Reference to existing API documentation that this PR complements

    No additional compiler-relevant findings. This remains a documentation-only change
    with zero impact on downstream tooling.
