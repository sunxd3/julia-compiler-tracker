schema_version: "1.0"

pr:
  number: 59466
  title: "Improve strided array docs"
  url: "https://github.com/JuliaLang/julia/pull/59466"
  diff_url: "https://github.com/JuliaLang/julia/pull/59466.diff"
  author: "nhz2"
  labels:
    - "docs"
    - "arrays"
  created_at: "2025-09-02T16:14:04Z"
  merged_at: "2025-10-10T19:04:15Z"
  merge_commit_sha: "5c7e099c93f03ddf8b925e8e8ca411dc36d990d9"

scope:
  files_touched:
    - "doc/src/manual/interfaces.md"
  components:
    - "Documentation"
  pipeline_stages: []

analysis:
  intent:
    summary: |
      This PR improves the documentation for the strided array interface by:
      1. Clarifying that `Base.elsize` returns stride in bytes (not elements)
      2. Fixing a typo: "dimension k" changed to "dimension i" for `stride(A, i::Int)`
      3. Adding a concrete example function `unsafe_strided_getindex` demonstrating
         how `strides`, `elsize`, `unsafe_convert`, and `axes` work together
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/59435"
    quoted_from_pr: |
      This PR improves the docs for the strided array interface by clarifying that
      `elsize` is in bytes and not elements, and adding an example of how the
      functions fit together.

  direct_changes:
    - summary: "Clarified `Base.elsize` returns stride in bytes, not elements"
      component: "Documentation"
      evidence:
        - source: "diff"
          path: "doc/src/manual/interfaces.md"
          loc: "404"
          url: "https://github.com/JuliaLang/julia/blob/5c7e099c93f03ddf8b925e8e8ca411dc36d990d9/doc/src/manual/interfaces.md#L404"
          snippet: |
            # BEFORE:
            | `Base.elsize(::Type{<:A})`  |   | Return the stride between consecutive elements in the array. |

            # AFTER:
            | `Base.elsize(::Type{<:A})`  |   | Return the stride (in number of bytes) between consecutive elements in the array. |

    - summary: "Fixed typo in stride documentation: 'dimension k' to 'dimension i'"
      component: "Documentation"
      evidence:
        - source: "diff"
          path: "doc/src/manual/interfaces.md"
          loc: "406"
          url: "https://github.com/JuliaLang/julia/blob/5c7e099c93f03ddf8b925e8e8ca411dc36d990d9/doc/src/manual/interfaces.md#L406"
          snippet: |
            # BEFORE:
            | `stride(A, i::Int)`  | `strides(A)[i]` | Return the distance in memory (in number of elements) between adjacent elements in dimension k. |

            # AFTER:
            | `stride(A, i::Int)`  | `strides(A)[i]` | Return the distance in memory (in number of elements) between adjacent elements in dimension i. |

    - summary: "Added comprehensive example function demonstrating strided array access"
      component: "Documentation"
      evidence:
        - source: "diff"
          path: "doc/src/manual/interfaces.md"
          loc: "416-442"
          url: "https://github.com/JuliaLang/julia/blob/5c7e099c93f03ddf8b925e8e8ca411dc36d990d9/doc/src/manual/interfaces.md#L416-L442"
          snippet: |
            The following function demonstrates how an element at indices `I` in a strided array `A` can be accessed.
            This function assumes the element type `isbitstype` and the indices are inbounds.

            ```jldoctest
            julia> function unsafe_strided_getindex(A::AbstractArray{T,N}, I::Vararg{Int, N})::T where {T, N}
                       A_cconv = Base.cconvert(Ptr{T}, A)
                       GC.@preserve A_cconv begin
                           A_ptr = Base.unsafe_convert(Ptr{T}, A_cconv)
                           for d in 1:N
                               stride_in_bytes = stride(A, d) * Base.elsize(typeof(A))
                               first_idx = first(axes(A, d))
                               A_ptr += (I[d] - first_idx) * stride_in_bytes
                           end
                           unsafe_load(A_ptr)
                       end
                   end;

            julia> A = [1 5; 2 6; 3 7; 4 8];

            julia> unsafe_strided_getindex(A, 3, 2)
            7

            julia> V = view(A, 1:2:3, 1:2);

            julia> unsafe_strided_getindex(V, 2, 2)
            7
            ```

  pipeline_impact: []

  secondary_effects:
    - effect: "Clarifies the relationship between strides (in elements) and elsize (in bytes)"
      mechanism: |
        The documentation now clearly explains that:
        - `strides(A)` returns distances in NUMBER OF ELEMENTS
        - `Base.elsize(typeof(A))` returns stride in NUMBER OF BYTES
        - To convert from element-strides to byte-strides: stride(A, d) * Base.elsize(typeof(A))

        This clarification is demonstrated in the example code:
          stride_in_bytes = stride(A, d) * Base.elsize(typeof(A))

        The underlying implementation in base/array.jl confirms this:
          elsize(::Type{A}) where {T,A<:Array{T}} = aligned_sizeof(T)  [base/array.jl:217]

        Where aligned_sizeof(T) returns the size in bytes for type T with proper alignment.
      downstream_surfaces:
        - "Users implementing custom strided array types"
        - "Package authors working with low-level memory access"
        - "BLAS/LAPACK interop code"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "base/array.jl"
          loc: "216-225"
          url: "https://github.com/JuliaLang/julia/blob/54fde7e012e6883a5bc9acd964593c8b9c9b5c74/base/array.jl#L216-L225"
          snippet: |
            # TODO: deprecate this (aligned_sizeof and/or elsize and/or sizeof(Some{T}) are more correct)
            elsize(::Type{A}) where {T,A<:Array{T}} = aligned_sizeof(T)
            function elsize(::Type{Ptr{T}}) where T
                # this only must return something valid for values which satisfy is_valid_intrinsic_elptr(T),
                # which includes Any and most concrete datatypes
                T === Any && return sizeof(Ptr{Any})
                T isa DataType || sizeof(Any) # throws
                return LLT_ALIGN(Core.sizeof(T), datatype_alignment(T))
            end
            elsize(::Type{Union{}}, slurp...) = 0

    - effect: "Provides canonical example for strided array interface implementers"
      mechanism: |
        The new `unsafe_strided_getindex` example demonstrates the complete workflow:
        1. Use Base.cconvert() before unsafe_convert (mentioned in issue #59435)
        2. Use GC.@preserve to keep array alive during pointer operations
        3. Use Base.unsafe_convert to get the native address
        4. Combine stride(A, d) * Base.elsize(typeof(A)) for byte offsets
        5. Use first(axes(A, d)) to handle non-1-indexed arrays (OffsetArrays)
        6. Use unsafe_load to retrieve the value

        This addresses the documentation gap noted in issue #59435 regarding
        the need to pair unsafe_convert with cconvert.
      downstream_surfaces:
        - "Custom array type implementers"
        - "FFI and interop libraries"
        - "OffsetArrays.jl users implementing strided access"
      likelihood: "medium"
      impact: "low"
      evidence:
        - source: "issue"
          path: "https://github.com/JuliaLang/julia/issues/59435"
          snippet: |
            The docs state it should "Return the native address of an array,"
            but don't mention that this method needs to be paired with `cconvert`.

    - effect: "Addresses GC rooting concerns for SubArray pointer operations"
      mechanism: |
        The example's use of GC.@preserve addresses a known implementation quirk.
        In base/reshapedarray.jl, there is a commented-out cconvert for SubArray:

          # cconvert(::Type{<:Ptr}, V::SubArray{...}) = V  [reshapedarray.jl:364]

        And the unsafe_convert contains this note:

          p = cconvert(Ptr{T}, parent) # XXX: this should occur in cconvert, the result is not GC-rooted
          [reshapedarray.jl:367]

        The documentation example shows the correct pattern: call cconvert FIRST,
        store the result, then use GC.@preserve around the unsafe_convert call.
        This ensures the converted value is rooted during pointer operations.
      downstream_surfaces:
        - "Package authors using pointer access on views/SubArrays"
        - "FFI libraries passing array views to C code"
      likelihood: "medium"
      impact: "low"
      evidence:
        - source: "code"
          path: "base/reshapedarray.jl"
          loc: "364-370"
          url: "https://github.com/JuliaLang/julia/blob/5c7e099c93f03ddf8b925e8e8ca411dc36d990d9/base/reshapedarray.jl#L364-L370"
          snippet: |
            # cconvert(::Type{<:Ptr}, V::SubArray{T,N,P,<:Tuple{Vararg{Union{RangeIndex,ReshapedUnitRange}}}}) where {T,N,P} = V
            function unsafe_convert(::Type{Ptr{S}}, V::SubArray{T,N,P,<:Tuple{Vararg{Union{RangeIndex,ReshapedUnitRange}}}}) where {S,T,N,P}
                parent = V.parent
                p = cconvert(Ptr{T}, parent) # XXX: this should occur in cconvert, the result is not GC-rooted
                Î”mem = if _checkcontiguous(Bool, parent)
                    (first_index(V) - firstindex(parent)) * elsize(parent)

  compatibility:
    internal_api: []
    behavioral: []

  performance:
    compile_time: []
    runtime: []

  tests:
    changed_files: []
    new_behavior_assertions:
      - "The new jldoctest example is tested during doc builds"
      - "unsafe_strided_getindex(A, 3, 2) == 7 verified"
      - "unsafe_strided_getindex(V, 2, 2) == 7 for strided view verified"
    coverage_gaps: []

  risk:
    level: "low"
    rationale:
      - "Documentation-only change - no code modifications"
      - "No compiler internals, type inference, or codegen affected"
      - "No API changes - only documentation text and examples"
      - "The jldoctest ensures the example code is correct"
      - "Addresses documented confusion from issue #59435"

  open_questions:
    - "Issue #59435 also requested an `isstrided(A)::Bool` function which this PR does NOT add"
    - "Issue #59435 noted questionable implementations in FixedSizeArrays.jl and PythonCall.jl due to unclear docs - these packages may need updates"

  recommendations:
    - "No action required for downstream compiler packages"
    - "This PR has zero impact on JET, Enzyme, IRTools, GPUCompiler, or Cassette"
    - "Custom strided array implementers should review the new example for best practices"

classification:
  type: "documentation"
  compiler_relevant: false
  breaking_change: false
  requires_downstream_action: false

notes: |
  This PR is NOT a compiler change - it modifies only documentation for the
  strided array interface in doc/src/manual/interfaces.md.

  Key clarifications made:
  1. `strides(A)` returns distances in ELEMENTS
  2. `stride(A, i)` returns distance in ELEMENTS for dimension i (typo fix: k -> i)
  3. `Base.elsize(typeof(A))` returns stride in BYTES
  4. To compute byte offsets: stride(A, d) * Base.elsize(typeof(A))

  The new example function demonstrates proper usage of:
  - Base.cconvert() and Base.unsafe_convert() pairing (addresses #59435 concern)
  - GC.@preserve for pointer safety
  - axes(A, d) for non-1-indexed array support
  - The strides/elsize relationship for byte offset calculation

  Cross-references:
  - Issue #59435: "Strided arrays interface unclear"
  - The issue raised specific concerns about elsize documentation being misleading

  Implementation details for elsize (all return BYTES):

  $ rg "^elsize" julia/base/*.jl
  base/abstractarray.jl:261:elsize(A::AbstractArray) = elsize(typeof(A))
  base/array.jl:217:elsize(::Type{A}) where {T,A<:Array{T}} = aligned_sizeof(T)
  base/subarray.jl:457:elsize(::Type{<:SubArray{<:Any,<:Any,P}}) where {P} = elsize(P)
  base/reinterpretarray.jl:391:elsize(::Type{<:ReinterpretArray{T}}) where {T} = sizeof(T)
  base/reshapedarray.jl:261:elsize(::Type{<:ReshapedArray{<:Any,<:Any,P}}) where {P} = elsize(P)
  base/genericmemory.jl:96:elsize(@nospecialize _::Type{A}) where {T,A<:GenericMemory{<:Any,T}} = aligned_sizeof(T)
  base/strings/basic.jl:792:elsize(s::Type{<:CodeUnits{T}}) where {T} = sizeof(T)

  NOTE: The TODO comment at base/array.jl:216 indicates elsize may be deprecated:
    # TODO: deprecate this (aligned_sizeof and/or elsize and/or sizeof(Some{T}) are more correct)

  NOTE: The XXX comment at base/genericmemory.jl:96 shows some uncertainty:
    elsize(...) = aligned_sizeof(T) # XXX: probably supposed to be the stride?

  All implementations return values in BYTES, confirming the documentation fix is correct.

  This PR has absolutely NO impact on:
  - Type inference
  - Lowering or IR generation
  - Optimization passes
  - Code generation
  - OpaqueClosure handling
  - Generated functions
  - World age / invalidation
  - Any internal compiler APIs

  It is safe to ignore for all compiler-focused downstream package analysis.

reviewer_verification:
  date: "2026-01-21"
  verified_claims:
    - claim: "elsize returns bytes, not elements"
      verified: true
      evidence: "All elsize implementations use aligned_sizeof(T) or sizeof(T), both return bytes"
    - claim: "stride(A, i) returns distance in elements"
      verified: true
      evidence: "strides() returns element counts, stride(A,i) delegates to strides(A)[i]"
    - claim: "The example correctly demonstrates cconvert/unsafe_convert pairing"
      verified: true
      evidence: "Pattern matches best practice: cconvert first, store result, GC.@preserve, then unsafe_convert"
    - claim: "No compiler impact"
      verified: true
      evidence: "Only doc/src/manual/interfaces.md modified - pure documentation change"
  additional_findings:
    - "Found XXX comment in reshapedarray.jl:367 about GC rooting issue that the example addresses"
    - "Found XXX comment in genericmemory.jl:96 showing uncertainty about elsize definition"
    - "Issue #59435 also requested isstrided(A)::Bool which was NOT added by this PR"
    - "Packages mentioned as potentially affected by unclear docs: FixedSizeArrays.jl, PythonCall.jl"
  conclusion: |
    The original analysis is accurate and thorough. This review added:
    1. Additional secondary effect about GC rooting concerns for SubArray
    2. Open questions about unfixed requests from issue #59435
    3. More detailed elsize implementation references
    4. XXX comments in codebase showing known uncertainties

    The PR is correctly classified as documentation-only with no compiler relevance.
