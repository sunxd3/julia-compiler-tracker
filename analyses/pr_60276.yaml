schema_version: "1.0"
pr:
  number: 60276
  title: "Backports for 1.13.0-alpha2"
  url: "https://github.com/JuliaLang/julia/pull/60276"
  author: "KristofferC"
  labels: []
  merged_at: "2025-11-30T08:28:30Z"
  merge_commit_sha: "af3e3bb21e4cae85fb4694451c725adf54748cc1"
  diff_url: "https://github.com/JuliaLang/julia/pull/60276.diff"
scope:
  files_touched:
    - "Compiler/extras/CompilerDevTools/test/testpkg.jl"
    - "JuliaLowering/Manifest.toml"
    - "base/loading.jl"
    - "contrib/generate_precompile.jl"
    - "deps/checksums/Pkg-4f9884fdb867f2c928ba43dc41da5f150aaec4ab.tar.gz/md5"
    - "deps/checksums/Pkg-4f9884fdb867f2c928ba43dc41da5f150aaec4ab.tar.gz/sha512"
    - "deps/checksums/Pkg-d0be1daf22f15da346e83429b323a82554ef241c.tar.gz/md5"
    - "deps/checksums/Pkg-d0be1daf22f15da346e83429b323a82554ef241c.tar.gz/sha512"
    - "deps/jlutilities/documenter/Manifest.toml"
    - "deps/jlutilities/objectfile/Manifest.toml"
    - "deps/jlutilities/objectfile/Project.toml"
    - "doc/make.jl"
    - "doc/src/index.md"
    - "src/llvm-multiversioning.cpp"
    - "stdlib/Pkg.version"
    - "test/llvmpasses/multiversioning-clone-only.ll"
    - "test/llvmpasses/multiversioning-x86.ll"
    - "test/loading.jl"
    - "test/project/deps/BadStdlibDeps2/Manifest.toml"
    - "test/project/deps/BadStdlibDeps2/Project.toml"
    - "test/runtests.jl"
    - "test/stdlib_dependencies.jl"
  components:
    - "Compiler.Codegen"
    - "Base.Loading"
    - "Tests"
  pipeline_stages:
    - "Codegen"
    - "RuntimeLoading"
analysis:
  intent:
    summary: "Backport a set of fixes and dependency updates for the 1.13.0-alpha2 release, including LLVM multiversioning trampoline initialization and stdlib loading fallback behavior."
    issue_links: []
  direct_changes:
    - summary: "Introduce a reusable LLVM multiversioning trampoline helper and use it to initialize relocation slots with an autoinit trampoline for multiversioned entrypoints."
      component: "Compiler.Codegen"
      evidence:
        - source: "code"
          path: "src/llvm-multiversioning.cpp"
          loc: "498-543"
          url: "https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/src/llvm-multiversioning.cpp#L498-L543"
          snippet: |
            Function *CloneCtx::create_trampoline(Function *F, GlobalVariable *slot, bool autoinit)
            {
                Function *trampoline =
                    Function::Create(F->getFunctionType(), GlobalValue::ExternalLinkage, "", &M);
            
                trampoline->copyAttributesFrom(F);
                trampoline->setVisibility(GlobalValue::HiddenVisibility);
                trampoline->setDSOLocal(true);
            
                // drop multiversioning attributes
                trampoline->removeFnAttr("julia.mv.reloc");
                trampoline->removeFnAttr("julia.mv.clones");
            
                auto BB = BasicBlock::Create(F->getContext(), "top", trampoline);
                IRBuilder<> irbuilder(BB);
            
                if (autoinit) {
                    irbuilder.CreateCall(F->getParent()->getOrInsertFunction(
                        XSTR(jl_autoinit_and_adopt_thread),
                        PointerType::get(F->getContext(), 0)
                    ));
                }
            
                auto ptr = irbuilder.CreateLoad(F->getType(), slot);
                ptr->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
                ptr->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(F->getContext(), None));
            
                SmallVector<Value *, 0> Args;
                for (auto &arg : trampoline->args())
                    Args.push_back(&arg);
                auto call = irbuilder.CreateCall(F->getFunctionType(), ptr, ArrayRef<Value *>(Args));
                if (F->isVarArg()) {
                    assert(!TT.isARM() && !TT.isPPC() && "musttail not supported on ARM/PPC!");
                    call->setTailCallKind(CallInst::TCK_MustTail);
                } else {
                    call->setTailCallKind(CallInst::TCK_Tail);
            
                }
            
                if (F->getReturnType() == Type::getVoidTy(F->getContext()))
                    irbuilder.CreateRetVoid();
                else
                    irbuilder.CreateRet(call);
            
                return trampoline;
            }
        - source: "code"
          path: "src/llvm-multiversioning.cpp"
          loc: "545-568"
          url: "https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/src/llvm-multiversioning.cpp#L545-L568"
          snippet: |
            void CloneCtx::prepare_slots()
            {
                for (auto &F : orig_funcs) {
                    if (F->hasFnAttribute("julia.mv.reloc")) {
                        assert(F->hasFnAttribute("julia.mv.clones"));
                        GlobalVariable *GV = new GlobalVariable(M, F->getType(), false, GlobalValue::ExternalLinkage, nullptr, F->getName() + ".reloc_slot");
                        GV->setVisibility(GlobalValue::HiddenVisibility);
                        GV->setDSOLocal(true);
                        if (F->isDeclaration()) {
                            extern_relocs[F] = GV;
                        }
                        else {
                            auto id = get_func_id(F);
                            const_relocs[id] = GV;
            
                            // Initialize with a single-use trampoline that calls `jl_autoinit_and_adopt_thread`,
                            // so that auto-initialization works with multi-versioned entrypoints.
                            Function *trampoline = create_trampoline(F, GV, /* autoinit */ true);
                            trampoline->setName(F->getName() + ".autoinit_trampoline");
                            GV->setInitializer(trampoline);
                        }
                    }
                }
            }
        - source: "rg"
          path: "src/llvm-multiversioning.cpp"
          loc: "498,562,727"
          url: "https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/src/llvm-multiversioning.cpp#L498-L727"
          snippet: |
            498:Function *CloneCtx::create_trampoline(Function *F, GlobalVariable *slot, bool autoinit)
            562:                Function *trampoline = create_trampoline(F, GV, /* autoinit */ true);
            727:    Function *trampoline = create_trampoline(F, slot, /* autoinit */ false);
    - summary: "Rewrite multiversioning aliases through the new trampoline helper to keep alias metadata and slot usage consistent."
      component: "Compiler.Codegen"
      evidence:
        - source: "code"
          path: "src/llvm-multiversioning.cpp"
          loc: "718-737"
          url: "https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/src/llvm-multiversioning.cpp#L718-L737"
          snippet: |
            void CloneCtx::rewrite_alias(GlobalAlias *alias, Function *F)
            {
                assert(!is_vector(F->getFunctionType()));
            
                uint32_t id;
                GlobalVariable *slot;
                std::tie(id, slot) = get_reloc_slot(F);
                assert(slot);
            
                Function *trampoline = create_trampoline(F, slot, /* autoinit */ false);
                trampoline->addFnAttr("julia.mv.alias"); // add alias attribute for testing purposes
            
                trampoline->takeName(alias);
                trampoline->setLinkage(alias->getLinkage());
                trampoline->setVisibility(alias->getVisibility());
                trampoline->setDSOLocal(alias->isDSOLocal());
                trampoline->setDLLStorageClass(alias->getDLLStorageClass());
            
                alias->eraseFromParent();
            }
        - source: "test"
          path: "test/llvmpasses/multiversioning-clone-only.ll"
          loc: "76-82"
          url: "https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/test/llvmpasses/multiversioning-clone-only.ll#L76-L82"
          snippet: |
            ; COM: check that the autoinit trampoline is generated correctly
            ; CHECK: define{{.*}}@subtarget_cloned.autoinit_trampoline({{.*}}
            ; CHECK-NEXT: top:
            ; CHECK-NEXT: call ptr @ijl_autoinit_and_adopt_thread()
            ; CHECK-NEXT: [[FUNC_PTR:%[0-9]+]] = load ptr, ptr @subtarget_cloned.reloc_slot{{.*}}!tbaa ![[TBAA_CONST_METADATA]], !invariant.load
            ; CHECK-NEXT: call{{.*}}[[FUNC_PTR]]({{.*}})
            ; CHECK: ret i32
    - summary: "When locating packages, fall back to stdlib manifests even if a project manifest returned a sentinel missing entry."
      component: "Base.Loading"
      evidence:
        - source: "code"
          path: "base/loading.jl"
          loc: "468-494"
          url: "https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/base/loading.jl#L468-L494"
          snippet: |
            for env in load_path()
                path = manifest_uuid_path(env, pkg)
                # missing is used as a sentinel to stop looking further down in envs
                if path === missing
                    # Before stopping, try stdlib fallback
                    is_stdlib(pkg) && @goto stdlib_fallback
                    path = nothing
                    @goto done
                end
                if path !== nothing
                    env′ = env
                    @goto done
                end
                if !(loading_extension || precompiling_extension)
                    stopenv == env && break
                end
            end
            @label stdlib_fallback
            # Allow loading of stdlibs if the name/uuid are given
            # e.g. if they have been explicitly added to the project/manifest
            mbypath = manifest_uuid_path(Sys.STDLIB, pkg)
            if mbypath isa String
                path = mbypath
                env′ = Sys.STDLIB
                @goto done
            end
        - source: "test"
          path: "test/loading.jl"
          loc: "1535-1563"
          url: "https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/test/loading.jl#L1535-L1563"
          snippet: |
            @testset "Fallback for stdlib deps if manifest deps aren't found" begin
                s = Sys.iswindows() ? ';' : ':'
                mktempdir() do depot
                    # This manifest has a LibGit2 entry that is missing LibGit2_jll, which should be
                    # handled by falling back to the stdlib Project.toml for dependency truth.
                    badmanifest_test_dir = joinpath(@__DIR__, "project", "deps", "BadStdlibDeps")
                    @test success(addenv(
                        `$(Base.julia_cmd()) --project=$badmanifest_test_dir --startup-file=no -e 'using LibGit2'`,
                        "JULIA_DEPOT_PATH" => string(depot * Base.Filesystem.pathsep(), s),
                    ))
                end
                mktempdir() do depot
                    # This manifest has a LibGit2 entry that has a LibGit2_jll with a git-tree-hash1
                    # which simulates an old manifest where LibGit2_jll was not a stdlib
                    badmanifest_test_dir2 = joinpath(@__DIR__, "project", "deps", "BadStdlibDeps2")
                    @test success(addenv(
                        `$(Base.julia_cmd()) --project=$badmanifest_test_dir2 --startup-file=no -e 'using LibGit2'`,
                        "JULIA_DEPOT_PATH" => string(depot * Base.Filesystem.pathsep(), s),
                    ))
                end
                mktempdir() do depot
                    # This manifest has a LibGit2 entry that has a LibGit2_jll with a git-tree-hash1
                    # which simulates an old manifest where LibGit2_jll was not a stdlib
                    badmanifest_test_dir2 = joinpath(@__DIR__, "project", "deps", "BadStdlibDeps2")
                    @test success(addenv(
                        `$(Base.julia_cmd()) --project=$badmanifest_test_dir2 --startup-file=no -e 'using LibGit2'`,
                        "JULIA_DEPOT_PATH" => depot * Base.Filesystem.pathsep(),
                    ))
                end
            end
  secondary_effects:
    - effect: "Multiversioned relocation slots now initially point to a trampoline that performs thread auto-initialization before tail-calling the resolved target."
      mechanism: |
        CloneCtx::prepare_slots() creates relocation slots and calls create_trampoline(..., autoinit=true) to initialize each slot. [src/llvm-multiversioning.cpp:545-565]
          -> create_trampoline(...) emits a call to jl_autoinit_and_adopt_thread() before loading the slot target and tail-calling it. [src/llvm-multiversioning.cpp:498-542]
      downstream_surfaces:
        - "LLVM IR produced by the JuliaMultiVersioning pass"
        - "System image/runtime init for multiversioned entrypoints"
      likelihood: "medium"
      impact: "low"
    - effect: "Packages with older or incomplete manifests can still resolve stdlib dependencies (including JLL stdlibs) even when manifest lookup stops early."
      mechanism: |
        locate_package_env() now jumps to stdlib_fallback when manifest_uuid_path() returns missing and the target is a stdlib, then retries against Sys.STDLIB. [base/loading.jl:468-494]
      downstream_surfaces:
        - "Pkg/manifest-based loading of stdlib deps"
        - "Legacy environments with LibGit2_jll entries"
      likelihood: "high"
      impact: "low"
  compatibility:
    internal_api: []
    behavioral:
      - change: "Package loading falls back to stdlib manifests for stdlib deps even after a missing sentinel, which may resolve packages that previously failed with missing deps."
        affected_surfaces:
          - "Base.locate_package"
          - "Pkg environments created on older Julia versions"
  performance:
    compile_time:
      - summary: "ESTIMATED: negligible additional IR in the multiversioning pass from emitting a small trampoline per multiversioned entrypoint."
    runtime:
      - summary: "ESTIMATED: one extra call to jl_autoinit_and_adopt_thread in the first execution of a multiversioned entrypoint via its reloc slot; subsequent calls still go through the reloc slot load and tail-call."
  risk:
    level: "low"
    rationale:
      - "Changes are localized to codegen initialization paths and stdlib loading fallback, with tests covering both behaviors."
  open_questions: []
  recommendations:
    - "Downstream tooling that inspects LLVM IR for multiversioning should accept the new autoinit trampoline symbol name and the non-null reloc slot initializer."
    - "Package environment diagnostics should note that stdlib fallback may succeed even when manifest entries are incomplete."
