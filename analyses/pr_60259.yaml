schema_version: "1.0"
pr:
  number: 60259
  title: "Proactively compile lambdas when the type of the closure is known"
  url: "https://github.com/JuliaLang/julia/pull/60259"
  author: "xal-0"
  labels: []
  merged_at: "2025-12-09T19:17:27Z"
  merge_commit_sha: "3efd5e7c9b31f02d70f39f16702823b769d7c4d1"
  diff_url: "https://github.com/JuliaLang/julia/pull/60259.diff"
scope:
  files_touched:
    - "Compiler/src/typeinfer.jl"
  components:
    - "Compiler.TypeInference"
  pipeline_stages:
    - "TypeInference"
    - "Precompile"
analysis:
  intent:
    summary: "When precompiling methods, detect construction of Function-typed structs (closures) via :new expressions and proactively compile their single compileable specialization. This enables closure methods to be compiled ahead of time when the closure type is concrete, reducing first-call latency. Motivated by making REPL precompile scripts more 'static', particularly for @task and @async which expand into no-argument lambdas."
    issue_links: []
  direct_changes:
    - summary: "Extend collectinvokes! to recognize :new expressions that instantiate Function-typed structs, derive their concrete closure type via instanceof_tfunc, and enqueue a compileable specialization for invokelatest precompile work queues."
      component: "Compiler/src/typeinfer.jl"
      evidence:
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "1645-1661"
          url: "https://github.com/JuliaLang/julia/blob/3efd5e7c9b31f02d70f39f16702823b769d7c4d1/Compiler/src/typeinfer.jl#L1645-L1661"
          snippet: |
            elseif isexpr(stmt, :new)
                # When creating a struct of Function type, check to see if we should
                # proactively compile the lambda
                t, _, _, _ = instanceof_tfunc(argextype(stmt.args[1], ci, sptypes))
                t <: Function || continue
                atype = Tuple{t, Vararg}
            else
                # TODO: handle other StmtInfo like OpaqueClosure?
                continue
            end
            let workqueue = invokelatest_queue
                # make a best-effort attempt to enqueue the relevant code for the dynamic invokelatest call
                mi = compileable_specialization_for_call(workqueue.interp, atype)
                mi === nothing && continue

                push!(workqueue, mi)
            end
        - source: "pr_body"
          path: "PR description"
          loc: "N/A"
          url: "https://github.com/JuliaLang/julia/pull/60259"
          snippet: |
            # Example from PR body showing the motivation:
            f(x::T) where {T <: Number} = y::T -> x+y
            precompile(f, (Int,))
            f(1)(2)

            # Before this PR, the closure method would not get precompiled,
            # resulting in --trace-compile output:
            # precompile(Tuple{Foo.var"#f##0#f##1"{Int64, Int64}, Int64})

            # After this PR, the closure method is proactively compiled when
            # f is precompiled, eliminating the trace-compile output.
  secondary_effects:
    - effect: "Closure methods created via struct construction during precompile may now be eagerly compiled when the closure type is concrete, reducing later runtime compilation for those closures."
      mechanism: |
        typeinf_ext_toplevel(methods, worlds, trim_mode)  [typeinfer.jl:1805-1835]
          creates invokelatest_queue = CompilationQueue(...)  [typeinfer.jl:1810-1812]
          -> compile!(codeinfos, workqueue; invokelatest_queue)  [typeinfer.jl:1822]
            -> for CodeInstance items: collectinvokes!(workqueue, src, sptypes; invokelatest_queue)  [typeinfer.jl:1780]
              -> isexpr(stmt, :new) branch derives closure type with instanceof_tfunc  [typeinfer.jl:1645-1650]
              -> compileable_specialization_for_call(workqueue.interp, atype)  [typeinfer.jl:1657]
                 resolves single compileable MethodInstance via method_table lookup  [typeinfer.jl:1557-1580]
              -> push!(invokelatest_queue, mi) enqueues closure method  [typeinfer.jl:1660]
          -> compile!(codeinfos, invokelatest_queue; invokelatest_queue)  [typeinfer.jl:1828]
            drains the invokelatest_queue, compiling enqueued closure methods
      downstream_surfaces:
        - "Precompile scripts and cache generation (e.g., REPL precompile)"
        - "Task/Channel closures built during module precompilation"
        - "@task and @async macro expansions that create no-argument lambdas"
      likelihood: "medium"
      impact: "medium"
    - effect: "@task and @async macros expand to closures that can now be proactively compiled when the containing method is precompiled."
      mechanism: |
        @task macro expansion  [base/task.jl:141-143]:
          macro task(ex)
              thunk = replace_linenums!(:(()->$(esc(ex))), __source__)
              :(Task($thunk))
          end

        The ()->$(esc(ex)) creates a closure struct. When a method containing
        @task is precompiled, the :new expression for the closure is now
        detected by collectinvokes!, and the closure's method is enqueued
        for compilation via the invokelatest_queue.
      downstream_surfaces:
        - "Any code using @task or @async in precompiled methods"
        - "REPL startup latency (primary motivation per PR description)"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api: []
    behavioral:
      - change: "Precompile may now emit extra CodeInstances for closure methods when the closure type is concrete and has a single compileable specialization. This is purely additive - closures that previously required runtime compilation may now be precompiled."
        evidence:
          - source: "code"
            path: "Compiler/src/typeinfer.jl"
            loc: "1655-1661"
            url: "https://github.com/JuliaLang/julia/blob/3efd5e7c9b31f02d70f39f16702823b769d7c4d1/Compiler/src/typeinfer.jl#L1655-L1661"
            snippet: |
              let workqueue = invokelatest_queue
                  # make a best-effort attempt to enqueue the relevant code for the dynamic invokelatest call
                  mi = compileable_specialization_for_call(workqueue.interp, atype)
                  mi === nothing && continue

                  push!(workqueue, mi)
              end
  performance:
    compile_time:
      - impact: "ESTIMATED: Additional compileable_specialization_for_call lookup (O(1) method table lookup + signature matching) for each :new expression of Function-typed struct encountered during precompile. The lookup is guarded by `t <: Function` check, so non-closure :new expressions skip this path entirely. Minimal overhead expected."
        evidence:
          - source: "code"
            path: "Compiler/src/typeinfer.jl"
            loc: "1557-1580"
            url: "https://github.com/JuliaLang/julia/blob/3efd5e7c9b31f02d70f39f16702823b769d7c4d1/Compiler/src/typeinfer.jl#L1557-L1580"
            snippet: |
              function compileable_specialization_for_call(interp::AbstractInterpreter, @nospecialize(argtype))
                  mt = ccall(:jl_method_table_for, Any, (Any,), argtype)
                  if mt === nothing
                      # this would require scanning all method tables, so give up instead
                      return nothing
                  end

                  matches = findall(argtype, method_table(interp); limit = 1)
                  matches === nothing && return nothing
                  length(matches.matches) == 0 && return nothing
                  match = only(matches.matches)

                  compileable_atype = get_compileable_sig(match.method, match.spec_types, match.sparams)
                  compileable_atype === nothing && return nothing
                  if match.spec_types !== compileable_atype
                      sp_ = ccall(:jl_type_intersection_with_env, Any, (Any, Any), compileable_atype, match.method.sig)::SimpleVector
                      sparams = sp_[2]::SimpleVector
                      mi = specialize_method(match.method, compileable_atype, sparams)
                  else
                      mi = specialize_method(match.method, compileable_atype, match.sparams)
                  end

                  return mi
              end
    runtime:
      - impact: "ESTIMATED: Reduced first-call latency for closure invocations whose types are known and concrete at precompile time. Instead of JIT-compiling the closure method on first call, the method is already compiled in the precompile cache. Benefit is proportional to how many closures with concrete types are created in precompiled code."
        evidence:
          - source: "pr_body"
            path: "PR description"
            loc: "N/A"
            url: "https://github.com/JuliaLang/julia/pull/60259"
            snippet: |
              # PR motivation: "This idea was motivated by trying to make the
              # REPL precompile script more 'static'. Creating a task with
              # @task or @async expands into a no-argument lambda, which won't
              # get precompiled with the containing method."

              # After this PR: closure methods created via @task/@async in
              # precompiled code will be proactively compiled, reducing REPL
              # startup latency and eliminating --trace-compile output for
              # those closures.
  risk:
    level: "low"
    rationale:
      - "Change is limited to enqueueing additional compileable MethodInstances during precompile/invokelatest handling; no changes to runtime dispatch semantics."
      - "Guarded by instanceof_tfunc returning a concrete Function subtype and compileable_specialization_for_call finding exactly one compileable method."
      - "Best-effort approach: if closure type is not concrete or has multiple/no compileable signatures, the code path simply continues without enqueueing."
      - "No changes to method tables, type inference, or inlining behavior."
  open_questions:
    - "Should similar proactive compilation be extended to OpaqueClosure creation, as hinted by the existing TODO comment at typeinfer.jl:1652?"
    - "Could this approach be extended to other patterns that create callable objects (e.g., functors, callable structs)?"
  recommendations:
    - "Consider adding a targeted precompile test that asserts closure methods created during precompile (such as @task/@async lambdas) appear in the code cache, using --trace-compile to verify no runtime compilation is required."
    - "Monitor REPL startup time benchmarks to quantify the latency improvement from proactive closure compilation."
    - "Consider documenting this behavior so users understand that closures with concrete types will be proactively compiled during precompilation."
