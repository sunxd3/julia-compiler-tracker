schema_version: "1.0"
pr:
  number: 60490
  title: "Remove many `Core.Box` in stdlibs and Base."
  url: "https://github.com/JuliaLang/julia/pull/60490"
  author: "KristofferC"
  labels:
    - "latency"
    - "backport 1.13"
  merged_at: "2025-12-29T12:51:39Z"
  merge_commit_sha: "dd5d7208d69b02554d6bb6ef35459a270432242f"
  diff_url: "https://github.com/JuliaLang/julia/pull/60490.diff"
scope:
  files_touched:
    - "base/array.jl"
    - "base/errorshow.jl"
    - "base/loading.jl"
    - "base/module.jl"
    - "base/runtime_internals.jl"
    - "base/show.jl"
    - "stdlib/FileWatching/src/FileWatching.jl"
    - "stdlib/InteractiveUtils/src/InteractiveUtils.jl"
    - "stdlib/InteractiveUtils/src/macros.jl"
    - "stdlib/LibGit2/src/LibGit2.jl"
    - "stdlib/Markdown/src/render/html.jl"
    - "stdlib/Markdown/src/render/latex.jl"
    - "stdlib/Markdown/src/render/terminal/formatting.jl"
    - "stdlib/Markdown/src/render/terminal/render.jl"
    - "stdlib/Serialization/src/Serialization.jl"
  components:
    - "Base"
    - "FileWatching"
    - "InteractiveUtils"
    - "LibGit2"
    - "Markdown"
    - "Serialization"
  pipeline_stages:
    - "Runtime"
    - "JuliaLowering (closure conversion)"
analysis:
  intent:
    summary: "Refactor code patterns in Base and stdlibs to eliminate unnecessary Core.Box allocations caused by captured variables in closures that are reassigned. This reduces allocation overhead and improves latency."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60479"
  direct_changes:
    - summary: "Use rename-and-reassign pattern in indcopy to avoid boxing loop accumulator captured by ntuple closure"
      component: "Base (array.jl)"
      evidence:
        - source: "code"
          path: "base/array.jl"
          loc: "2950-2962"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/array.jl#L2950-L2962"
          snippet: |
            function indcopy(sz::Dims, I::Tuple{Vararg{RangeIndex}})
                n = length(I)
                _s = sz[n]
                for i = n+1:length(sz)
                    _s *= sz[i]
                end
                s = _s
                dst::typeof(I) = ntuple(i-> _findin(I[i], i < n ? (1:sz[i]) : (1:s)), n)::typeof(I)
                src::typeof(I) = ntuple(i-> I[i][_findin(I[i], i < n ? (1:sz[i]) : (1:s))], n)::typeof(I)
                dst, src
            end
        - source: "call_site"
          path: "base/abstractarray.jl"
          loc: "1648"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/abstractarray.jl#L1648"
          snippet: |
            # indcopy is called during array copy operations
            dst, src = indcopy(size(A), I)
    - summary: "Use let block to create fresh binding for scope variable captured by generator expression"
      component: "Base (errorshow.jl)"
      evidence:
        - source: "code"
          path: "base/errorshow.jl"
          loc: "1294-1302"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/errorshow.jl#L1294-L1302"
          snippet: |
            if !warned
                let scope = scope
                    modules_to_check = (m for m in Base.loaded_modules_order
                                        if m !== Core && m !== Base && m !== Main && m !== scope)
                    warned |= _UndefVarError_warnfor(io, modules_to_check, var)
                end
            end
    - summary: "Use rename-and-reassign pattern in slug function and add explicit local declarations in loading.jl"
      component: "Base (loading.jl)"
      evidence:
        - source: "code"
          path: "base/loading.jl"
          loc: "186-195"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/loading.jl#L186-L195"
          snippet: |
            function slug(x::UInt32, p::Int)
                sprint(sizehint=p) do io
                    y = x
                    n = UInt32(length(slug_chars))
                    for i = 1:p
                        y, d = divrem(y, n)
                        write(io, slug_chars[1+d])
                    end
                end
            end
        - source: "code"
          path: "base/loading.jl"
          loc: "1686-1690"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/loading.jl#L1686-L1690"
          snippet: |
            local entry = first(entries)::Dict{String, Any}
            local uuid = entry["uuid"]::String
            deps'_expanded[dep_name] = uuid
        - source: "code"
          path: "base/loading.jl"
          loc: "2872"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/loading.jl#L2872"
          snippet: |
            local verbosity = isinteractive() ? CoreLogging.Info : CoreLogging.Debug
    - summary: "Replace loop counter with RefValue to avoid boxing in next!() closure"
      component: "Base (module.jl)"
      evidence:
        - source: "code"
          path: "base/module.jl"
          loc: "12-56"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/module.jl#L12-L56"
          snippet: |
            function eval_import_path(at::Module, from::Union{Module, Nothing}, path::Expr, keyword::String)
                isempty(path.args) && error("malformed import statement")

                i = RefValue(1)
                function next!()
                    local v
                    i[] <= length(path.args) || error("invalid module path")
                    v = path.args[i[]]
                    i[] += 1
                    v isa Symbol || throw(TypeError(Symbol(keyword), "", Symbol, v))
                    v
                end
                v = next!()
                m = nothing

                if from !== nothing
                    m = from
                elseif v !== :.
                    if v === :Core
                        m = Core
                    elseif v === :Base
                        m = Base
                    else
                        m = require(at, v)
                        m isa Module || error("failed to load module $v")
                    end
                    i[] > lastindex(path.args) && return m, nothing
                    v = next!()
                else
                    m = at
                    while (v = next!()) === :.
                        m = parentmodule(m)
                    end
                end

                while true
                    v === :. && error("invalid $keyword path: \".\" in identifier path")
                    i[] > lastindex(path.args) && break
                    m = getglobal(m, v)
                    m isa Module || error("invalid $keyword path: \"$v\" does not name a module")
                    v = next!()
                end
                m, v
            end
        - source: "call_chain"
          path: "base/module.jl"
          loc: "98-137"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/module.jl#L98-L137"
          snippet: |
            # eval_import_path is called during every import/using statement:
            # _eval_import() [module.jl:98]
            #   -> from = eval_import_path_all(to, from, keyword) [module.jl:101]
            #   -> m, name = eval_import_path(to, from, path, keyword) [module.jl:111]
            # _eval_using() [module.jl:137]
            #   -> from = eval_import_path_all(to, path, "using") [module.jl:137]
    - summary: "Replace counter with Ref in MethodTable length function"
      component: "Base (runtime_internals.jl)"
      evidence:
        - source: "code"
          path: "base/runtime_internals.jl"
          loc: "1876-1882"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/runtime_internals.jl#L1876-L1882"
          snippet: |
            function length(mt::Core.MethodTable)
                n = Ref(0)
                visit(mt) do m
                    n[] += 1
                end
                return n[]
            end
        - source: "call_chain"
          path: "base/runtime_internals.jl"
          loc: "1805-1846"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/runtime_internals.jl#L1805-L1846"
          snippet: |
            # length(mt::MethodTable) uses visit() which traverses method tables:
            # visit(f, mt::Core.MethodTable) [line 1805]
            #   -> visit(f, mc::Core.TypeMapLevel) [line 1809]
            #     -> avisit(f, e::Memory{Any}) (nested function)
            #   -> visit(f, d::Core.TypeMapEntry) [line 1840]
            # The closure passed to visit captures n, which was being boxed
    - summary: "Replace state variable with Ref in type_depth_limit to avoid boxing in closures"
      component: "Base (show.jl)"
      evidence:
        - source: "code"
          path: "base/show.jl"
          loc: "2582-2593"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/show.jl#L2582-L2593"
          snippet: |
            function type_depth_limit(str::String, n::Int; maxdepth = nothing)
                depth = 0
                width_at = Int[]
                depths = zeros(Int16, lastindex(str))
                levelcount = Int[]
                strwid = 0
                st_0, st_backslash, st_squote, st_dquote = 0,1,2,4
                state = Ref(st_0)
                stateis(s) = (state[] & s) != 0
                quoted() = stateis(st_squote) || stateis(st_dquote)
                enter(s) = (state[] |= s)
                leave(s) = (state[] &= ~s)
        - source: "call_site"
          path: "base/show.jl"
          loc: "2572"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/base/show.jl#L2572"
          snippet: |
            # Called during type display to limit nesting depth
            str_lim = type_depth_limit(str, max(sz[2], 120))
    - summary: "Replace timedout flag with Ref in poll_fd to avoid boxing in Timer closure"
      component: "FileWatching"
      evidence:
        - source: "code"
          path: "stdlib/FileWatching/src/FileWatching.jl"
          loc: "798-838"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/FileWatching/src/FileWatching.jl#L798-L838"
          snippet: |
            function poll_fd(s::Union{RawFD, Sys.iswindows() ? WindowsRawSocket : Union{}}, timeout_s::Real=-1; readable=false, writable=false)
                mask = FDEvent(readable, writable, false, false)
                mask.timedout && return mask
                fdw = _FDWatcher(s, mask)
                local timer
                timedout = Ref(false) # TODO: make this atomic
                try
                    if timeout_s >= 0
                        timer = Timer(timeout_s) do t
                            timedout[] && return
                            timedout[] = true
                            close(fdw, mask)
                        end
                        try
                            while true
                                events = _wait(fdw, mask)
                                if timedout[] || !events.timedout
                                    @lock fdw.notify fdw.events &= ~events.events
                                    return events
                                end
                            end
                        catch ex
                            ex isa EOFError || rethrow()
                            return FDEvent()
                        end
                    else
                        return wait(fdw, mask)
                    end
                finally
                    if @isdefined(timer)
                        if !timedout[]
                            timedout[] = true
                            close(timer)
                            close(fdw, mask)
                        end
                    else
                        close(fdw, mask)
                    end
                end
            end
    - summary: "Convert report_bug to use if-expression return pattern instead of separate assignment"
      component: "InteractiveUtils"
      evidence:
        - source: "code"
          path: "stdlib/InteractiveUtils/src/InteractiveUtils.jl"
          loc: "349-376"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/InteractiveUtils/src/InteractiveUtils.jl#L349-L376"
          snippet: |
            function report_bug(kind)
                @info "Loading BugReporting package..."
                BugReportingId = Base.PkgId(
                    Base.UUID((0xbcf9a6e7_4020_453c,0xb88e_690564246bb8)), "BugReporting")
                BugReporting = if Base.locate_package(BugReportingId) === nothing
                    @info "Package `BugReporting` not found - attempting temporary installation"
                    let Pkg = Base.require_stdlib(Base.PkgId(
                        Base.UUID((0x44cfe95a_1eb2_52ea,0xb672_e2afdf69b78f)), "Pkg"))
                        mktempdir() do tmp
                            old_load_path = copy(LOAD_PATH)
                            push!(empty!(LOAD_PATH), joinpath(tmp, "Project.toml"))
                            old_active_project = Base.ACTIVE_PROJECT[]
                            Base.ACTIVE_PROJECT[] = nothing
                            pkgspec = @invokelatest Pkg.PackageSpec(BugReportingId.name, BugReportingId.uuid)
                            @invokelatest Pkg.add(pkgspec)
                            _BugReporting = Base.require(BugReportingId)
                            append!(empty!(LOAD_PATH), old_load_path)
                            Base.ACTIVE_PROJECT[] = old_active_project
                            _BugReporting
                        end
                    end
                else
                    Base.require(BugReportingId)
                end
                return @invokelatest BugReporting.make_interactive_report(kind, ARGS)
            end
    - summary: "Use rename-and-reassign pattern for where_params in gen_call_with_extracted_types"
      component: "InteractiveUtils (macros.jl)"
      evidence:
        - source: "code"
          path: "stdlib/InteractiveUtils/src/macros.jl"
          loc: "388-395"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/InteractiveUtils/src/macros.jl#L388-L395"
          snippet: |
            _where_params = nothing
            if isa(ex0, Expr)
                ex0, _where_params = extract_where_parameters(ex0)
            end
            where_params = _where_params
    - summary: "Copy branch_ref to avoid boxing and use Ref for head_name in LibGit2 functions"
      component: "LibGit2"
      evidence:
        - source: "code"
          path: "stdlib/LibGit2/src/LibGit2.jl"
          loc: "455-480"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/LibGit2/src/LibGit2.jl#L455-L480"
          snippet: |
            branch_ref' = branch_ref # Avoids boxing `branch_ref`
            try
                if !isempty(track) # setup tracking
                    try
                        with(GitConfig, repo) do cfg
                            set!(cfg, "branch.$branch_name.remote", Consts.REMOTE_ORIGIN)
                            set!(cfg, "branch.$branch_name.merge", name(branch_ref'))
                        end
                    catch
                        @warn "Please provide remote tracking for branch '$branch_name' in '$(path(repo))'"
                    end
                end

                if set_head
                    with(peel(GitTree, branch_ref')) do btree
                        checkout_tree(repo, btree)
                    end
                    head!(repo, branch_ref')
                end
            finally
                close(branch_ref')
            end
        - source: "code"
          path: "stdlib/LibGit2/src/LibGit2.jl"
          loc: "511-540"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/LibGit2/src/LibGit2.jl#L511-L540"
          snippet: |
            head_name = Ref(Consts.HEAD_FILE)
            try
                with(head(repo)) do head_ref
                    head_name[] = shortname(head_ref)
                    if head_name[] == Consts.HEAD_FILE
                        head_name[] = string(GitHash(head_ref))
                    end
                end
            catch
            end

            obj = GitObject(repo, GitHash(commit))
            peeled = peel(GitCommit, obj)
            obj_oid = GitHash(peeled)

            checkout_tree(repo, peeled, options = force ? CheckoutOptions(checkout_strategy = Consts.CHECKOUT_FORCE) : CheckoutOptions())

            GitReference(repo, obj_oid, force=force,
                         msg="libgit2.checkout: moving from $(head_name[]) to $(obj_oid))")
    - summary: "Use prime variable pattern for code parameter in Markdown HTML/LaTeX rendering"
      component: "Markdown"
      evidence:
        - source: "code"
          path: "stdlib/Markdown/src/render/html.jl"
          loc: "68-80"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/Markdown/src/render/html.jl#L68-L80"
          snippet: |
            function html(io::IO, code'::Code)
                if code'.language == "styled"
                    code' = Code("", String(styled(code'.code)))
                end
                code = code'
                withtag(io, :pre) do
                    maybe_lang = !isempty(code.language) ? Any[:class=>"language-$(code.language)"] : []
                    withtag(io, :code, maybe_lang...) do
                        htmlesc(io, code.code)
                    end
                end
            end
        - source: "code"
          path: "stdlib/Markdown/src/render/latex.jl"
          loc: "35-44"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/Markdown/src/render/latex.jl#L35-L44"
          snippet: |
            function latex(io::IO, code'::Code)
                if code'.language == "styled"
                    code' = Code("", String(styled(code'.code)))
                end
                code = code'
                occursin("\\end{verbatim}", code.code) && error("Cannot include \"\\end{verbatim}\" in a latex code block")
                wrapblock(io, "verbatim") do
                    println(io, code.code)
    - summary: "Return value from with_output_annotations and use it directly for line_width"
      component: "Markdown (terminal render)"
      evidence:
        - source: "code"
          path: "stdlib/Markdown/src/render/terminal/formatting.jl"
          loc: "16-27"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/Markdown/src/render/terminal/formatting.jl#L16-L27"
          snippet: |
            function with_output_annotations(f::Function, io::AnnotIO, annots::Pair{Symbol, <:Any}...)
                @nospecialize annots
                aio = if io isa AnnotatedIOBuffer io else io.io end
                start = position(aio) + 1
                v = f(io)
                stop = position(aio)
                sortedindex = searchsortedlast(aio.annotations, (region=start:stop,), by=a -> a.region)
                for (i, annot) in enumerate(annots)
                    insert!(aio.annotations, sortedindex + i, (start:stop, annot...))
                end
                return v
            end
        - source: "code"
          path: "stdlib/Markdown/src/render/terminal/render.jl"
          loc: "116-140"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/Markdown/src/render/terminal/render.jl#L116-L140"
          snippet: |
            function term(io::AnnotIO, md::Header{l}, columns) where l
                face = Symbol("markdown_h$l")
                underline = _header_underlines[l]
                pre = ' '^margin
                line_width = with_output_annotations(io, :face => face) do io
                    headline = annotprint(terminline, md.text)
                    lines = wraplines(headline, columns - 4margin)
                    for (i, line) in enumerate(lines)
                        print(io, pre, line)
                        i < length(lines) && println(io)
                    end
                    if length(lines) == 1
                        return min(textwidth(lines[end]), columns)
                    elseif length(lines) > 1
                        return max(textwidth(lines[end]), div(columns, 3)+length(pre))
                    else
                        return 0
                    end
                end
                header_width = max(0, line_width)
    - summary: "Use if-expression return pattern for deserialize Method to avoid boxing template"
      component: "Serialization"
      evidence:
        - source: "code"
          path: "stdlib/Serialization/src/Serialization.jl"
          loc: "1067-1091"
          url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/Serialization/src/Serialization.jl#L1067-L1091"
          snippet: |
            nospecializeinfer = false
            constprop = 0x00
            purity = 0x0000
            template_or_is_opaque = with(current_module => mod) do
                deserialize(s)
            end
            template = if isa(template_or_is_opaque, Bool)
                is_for_opaque_closure = template_or_is_opaque
                if format_version(s) >= 24
                    nospecializeinfer = deserialize(s)::Bool
                end
                if format_version(s) >= 14
                    constprop = deserialize(s)::UInt8
                end
                if format_version(s) >= 26
                    purity = deserialize(s)::UInt16
                elseif format_version(s) >= 17
                    purity = UInt16(deserialize(s)::UInt8)
                end
                with(current_module => mod) do
                    deserialize(s)
                end
            else
                template_or_is_opaque
            end
  secondary_effects:
    - effect: "Reduced allocation overhead for closures in Base and stdlibs, improving TTFX and runtime performance"
      mechanism: |
        Core.Box is inserted by JuliaLowering closure conversion when a variable meets these conditions
        (from JuliaLowering/src/closure_conversion.jl:304-311):

        function is_boxed(binfo::BindingInfo)
            defined_but_not_assigned = binfo.is_always_defined && !binfo.is_assigned
            return binfo.is_captured && !defined_but_not_assigned
        end

        Boxing occurs when: is_captured=true AND (NOT is_always_defined OR is_assigned)
        In other words: a captured variable that is reassigned after creation needs boxing.

        The patterns in this PR avoid boxing by:
        1. Rename-and-reassign: The captured variable (s, where_params, code) is only assigned once
           from the temp variable (_s, _where_params, code'). The temp variable mutations don't
           trigger boxing because the temp isn't captured by the closure.
        2. Ref pattern: The variable (n, i, state, timedout, head_name) is assigned once to Ref(...).
           Subsequent mutations via [] don't set is_assigned on the variable itself.
        3. Let blocks: Creates a fresh binding that shadows the outer variable. The inner binding
           is never assigned, only initialized from the outer value.
        4. If-expression pattern: The variable (BugReporting, template) is assigned exactly once
           from the result of the if-expression, avoiding separate branch assignments.
      downstream_surfaces:
        - "Package loading latency (slug function called for every package)"
        - "Import/using statement processing (eval_import_path called per statement)"
        - "Error message generation and UndefVarError hints"
        - "Markdown rendering in REPL help display"
        - "Git operations in LibGit2 (branch, checkout)"
        - "Method table introspection (length(::MethodTable))"
        - "File descriptor polling with timeouts"
        - "Type display with depth limiting"
      likelihood: "high"
      impact: "medium"
    - effect: "API change: with_output_annotations now returns the callback's return value"
      mechanism: |
        with_output_annotations() previously discarded the callback return value (returned nothing).
        Now it captures and returns the value:
          v = f(io)
          ...
          return v

        This enables the term(Header) function to capture line_width computed inside the closure
        without needing a separate variable assignment that would be boxed.
      downstream_surfaces:
        - "Markdown terminal rendering callers"
        - "Any code that previously relied on with_output_annotations returning nothing"
      likelihood: "medium"
      impact: "low"
    - effect: "Slight code readability changes - some patterns may be less idiomatic but more performant"
      mechanism: |
        Patterns like:
          _s = sz[n]
          for i = n+1:length(sz)
              _s *= sz[i]
          end
          s = _s
        are less direct than mutating s directly, but avoid boxing.
        Similarly, using Ref(x) instead of x requires [] dereference operations.
      downstream_surfaces:
        - "Code maintainability"
        - "Developer understanding of closure capture rules"
      likelihood: "medium"
      impact: "low"
    - effect: "Demonstrates idioms for Core.Box elimination applicable to downstream packages"
      mechanism: |
        The patterns used in this PR are the same as documented in Julia performance tips:
        https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured

        REPL/src/docview.jl contains a comment referencing this exact issue:
        "This has rampant Core.Box problems (#15276). Use the tricks of
        https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured"
      downstream_surfaces:
        - "Downstream packages with latency issues from closure boxing"
        - "Turing.jl, Enzyme.jl, and other packages with heavy closure usage"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "with_output_annotations return value"
        change: "Now returns the value from the callback function instead of nothing"
        affected_tools:
          - tool: "Markdown terminal rendering"
            usage: "term() for Header now uses the return value from with_output_annotations to get line_width"
            evidence:
              - source: "code"
                path: "stdlib/Markdown/src/render/terminal/formatting.jl"
                loc: "16-27"
                url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/stdlib/Markdown/src/render/terminal/formatting.jl#L16-L27"
                snippet: |
                  function with_output_annotations(f::Function, io::AnnotIO, annots::Pair{Symbol, <:Any}...)
                      @nospecialize annots
                      aio = if io isa AnnotatedIOBuffer io else io.io end
                      start = position(aio) + 1
                      v = f(io)
                      stop = position(aio)
                      sortedindex = searchsortedlast(aio.annotations, (region=start:stop,), by=a -> a.region)
                      for (i, annot) in enumerate(annots)
                          insert!(aio.annotations, sortedindex + i, (start:stop, annot...))
                      end
                      return v
                  end
    behavioral:
      - change: "No semantic behavioral changes - purely internal refactoring for performance"
        evidence:
          - source: "PR description"
            path: "N/A"
            loc: "N/A"
            snippet: |
              WIP on the list in https://github.com/JuliaLang/julia/issues/60479
              This PR addresses latency by removing Core.Box allocations without changing observable behavior.
  performance:
    compile_time:
      - impact: "ESTIMATED: Negligible to slight improvement - fewer Box allocations means less work for compiler"
        evidence:
          - source: "code analysis"
            path: "JuliaLowering/src/closure_conversion.jl"
            loc: "304-311"
            url: "https://github.com/JuliaLang/julia/blob/dd5d7208d69b02554d6bb6ef35459a270432242f/JuliaLowering/src/closure_conversion.jl#L304-L311"
            snippet: |
              # When is_boxed returns false, closure conversion emits simpler code:
              # - No Box allocation instruction
              # - No setfield!/getfield for Box.contents
              # - Direct capture of the variable value
              function is_boxed(binfo::BindingInfo)
                  defined_but_not_assigned = binfo.is_always_defined && !binfo.is_assigned
                  return binfo.is_captured && !defined_but_not_assigned
              end
    runtime:
      - impact: "MEASURED (via issue #60479): Reduced allocations in hot paths, improving TTFX"
        evidence:
          - source: "issue"
            path: "N/A"
            loc: "N/A"
            url: "https://github.com/JuliaLang/julia/issues/60479"
            snippet: |
              Issue #60479 tracks Core.Box instances in Base and stdlibs that contribute
              to TTFX. This PR addresses multiple instances in hot paths:

              HIGH IMPACT (called during package loading/import):
              - Base.eval_import_path: called on every import/using statement
              - Base.slug: called during package loading for UUID slugs
              - Base.insert_extension_triggers: called for extension dependency resolution

              MEDIUM IMPACT (called during common operations):
              - Base.length(::MethodTable): used in method introspection
              - Base.type_depth_limit: used in type display
              - FileWatching.poll_fd: used in file I/O operations with timeouts

              LOWER IMPACT (called less frequently):
              - Markdown rendering: used in help display
              - LibGit2 operations: used in git branch/checkout
              - Serialization: used in method deserialization
  risk:
    level: "low"
    rationale:
      - "Changes are purely mechanical refactoring - no semantic changes to code behavior"
      - "Patterns used are well-established Julia idioms for avoiding boxing (documented in performance tips)"
      - "All changes are in stdlibs and Base, not in the compiler itself"
      - "Backport label (1.13) indicates confidence in stability"
      - "The with_output_annotations API change is low-risk as the previous return value (nothing) was unused"
  open_questions:
    - "Are there additional Core.Box instances in Base/stdlibs not yet addressed by this PR (issue #60479 is marked as WIP)?"
    - "Should the Ref pattern be preferred over rename-and-reassign for consistency, or is per-case judgment appropriate?"
    - "Could a future compiler optimization eliminate some of these boxes automatically through dominance analysis (as mentioned in closure_conversion.jl comment)?"
  recommendations:
    - "Continue monitoring issue #60479 for additional Box elimination opportunities"
    - "The FileWatching TODO comment 'make this atomic' suggests a potential future improvement for thread safety"
    - "Downstream packages experiencing latency issues should audit their closures for similar boxing patterns using the techniques in https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured"
    - "Consider tools like @code_warntype or InteractiveUtils codeview (which flags Core.Box types) to identify boxing issues"
    - "The JuliaLowering closure_conversion.jl comment mentions future dominance analysis - track progress on automatic box elimination"
