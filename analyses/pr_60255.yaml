schema_version: "1.0"
pr:
  number: 60255
  title: "[JuliaLowering] Restrict `K\"VERSION\"` to module arg"
  url: "https://github.com/JuliaLang/julia/pull/60255"
  author: "mlechu"
  labels:
    - "compiler:lowering"
  merged_at: "2025-12-01T21:03:21Z"
  merge_commit_sha: "68553c5863b81a27335aff82898405dd86392c8b"
  diff_url: "https://github.com/JuliaLang/julia/pull/60255.diff"
scope:
  files_touched:
    - "JuliaLowering/src/compat.jl"
    - "JuliaLowering/src/macro_expansion.jl"
    - "JuliaLowering/test/macros.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Lowering"
    - "MacroExpansion"
analysis:
  intent:
    summary: "Limit special `K\"VERSION\"` handling to module version syntax so standalone `VersionNumber` literals (e.g. v\"1.14\") are not treated as special syntax during lowering, fixing stdlib precompilation regressions after #60018."
    issue_links:
      - "https://github.com/JuliaLang/julia/pull/60018"
  direct_changes:
    - summary: "Module expressions now wrap the version argument in a dedicated `:mod_version` Expr, ensuring only module version positions become `K\"VERSION\"` nodes."
      component: "JuliaLowering/src/compat.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/compat.jl"
          loc: "400-408"
          url: "https://github.com/JuliaLang/julia/blob/68553c5863b81a27335aff82898405dd86392c8b/JuliaLowering/src/compat.jl#L400-L408"
          snippet: |
            elseif e.head === :module
                @assert nargs in (3, 4)
                has_version = !isa(e.args[1], Bool)
                if !e.args[1+has_version]
                    st_flags |= JS.BARE_MODULE_FLAG
                end
                child_exprs = has_version ?
                    Any[Expr(:mod_version, e.args[1]), e.args[2+has_version], e.args[3+has_version]] :
                    Any[e.args[2+has_version], e.args[3+has_version]]
        - source: "code"
          path: "JuliaLowering/src/compat.jl"
          loc: "565-571"
          url: "https://github.com/JuliaLang/julia/blob/68553c5863b81a27335aff82898405dd86392c8b/JuliaLowering/src/compat.jl#L565-L571"
          snippet: |
            elseif e.head === :mod_version
                v = e.args[1]
                @assert v isa VersionNumber
                st_k = K"VERSION"
                st_flags = JS.set_numeric_flags(v.minor*10)
                st_attrs[:value] = v
                child_exprs = nothing
    - summary: "Old-style macro invocation now treats a leading `K\"VERSION\"` argument as a macro source payload and avoids pushing `K\"VERSION\"` into `macro_args`."
      component: "JuliaLowering/src/macro_expansion.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/macro_expansion.jl"
          loc: "325-346"
          url: "https://github.com/JuliaLang/julia/blob/68553c5863b81a27335aff82898405dd86392c8b/JuliaLowering/src/macro_expansion.jl#L325-L346"
          snippet: |
            # Compat: attempt to invoke an old-style macro if there's no applicable
            # method for new-style macro arguments.
            macro_args = Any[macro_loc, ctx.scope_layers[1].mod]

            if length(raw_args) >= 1 && kind(raw_args[1]) === K"VERSION"
                # Hack: see jl_invoke_julia_macro.  We may see an extra argument
                # depending on who parsed this macrocall.
                macro_args[1] = Core.MacroSource(macro_loc, raw_args[1].value)
            end

            for arg in raw_args
                # For hygiene in old-style macros, we omit any additional scope
                # layer information from macro arguments. Old-style macros will
                # handle that using manual escaping in the macro itself.
                #
                # Note that there's one slight incompatibility here for identifiers
                # interpolated into the `raw_args` from outer macro expansions of
                # new-style macros which call old-style macros. Instead of seeing
                # `Expr(:escape)` in such situations, old-style macros will now see
                # `Expr(:scope_layer)` inside `macro_args`.
                kind(arg) !== K"VERSION" && push!(macro_args, Expr(arg))
            end
  secondary_effects:
    - effect: 'Standalone `VersionNumber` literals produced by `v""` no longer become `K\"VERSION\"` nodes during compat conversion, avoiding unhandled syntax outside module headers.'
      mechanism: |
        _insert_convert_expr(e, graph, src) [compat.jl:186]
          sees Expr(:module, ...) and wraps version as Expr(:mod_version, v) [compat.jl:400-408]
          -> :mod_version branch converts to K"VERSION" only for module header [compat.jl:565-571]
        All other VersionNumber literals fall through the non-Expr handling path and are treated as regular values.
      downstream_surfaces:
        - "Macro expansion compatibility mode (old-style macros)"
        - "Stdlib precompilation when parsing v\"x.y\" literals"
      likelihood: "high"
      impact: "medium"
    - effect: "Old-style macros see one fewer argument when a K\"VERSION\" token is present in raw args, aligning with jl_invoke_julia_macro behavior."
      mechanism: |
        expand_macro(ctx, ex) [macro_expansion.jl:281]
          builds macro_args = Any[macro_loc, ctx.scope_layers[1].mod]
          -> replaces macro_loc with Core.MacroSource when raw_args[1] is K"VERSION" [macro_expansion.jl:329-333]
          -> skips pushing K"VERSION" into macro_args [macro_expansion.jl:335-345]
      downstream_surfaces:
        - "Old-style macros that consume MacroSource arguments"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api:
      - field: "SyntaxTree kind K\"VERSION\""
        change: "K\"VERSION\" nodes are now produced only via Expr(:mod_version) in module headers; standalone VersionNumber literals are treated as values."
        affected_tools:
          - tool: "JuliaLowering compat mode consumers"
            usage: "Tools that parse SyntaxTree kinds from JuliaLowering (e.g. custom macro loaders) and assumed K\"VERSION\" could appear anywhere in expressions."
    behavioral:
      - change: "`v\"x.y\"` literals in compat-mode parsing now yield VersionNumber values without triggering K\"VERSION\" syntax errors."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/macros.jl"
            loc: "125-136"
            url: "https://github.com/JuliaLang/julia/blob/68553c5863b81a27335aff82898405dd86392c8b/JuliaLowering/test/macros.jl#L125-L136"
            snippet: |
              @test JuliaLowering.include_string(test_mod, raw"""
              v"1.14"
              """) isa VersionNumber
              @test JuliaLowering.include_string(test_mod, raw"""
              v"1.14"
              """;expr_compat_mode=true) isa VersionNumber
              @test JuliaLowering.include_string(test_mod, raw"""
              Base.Experimental.@VERSION
              """) isa NamedTuple
              @test JuliaLowering.include_string(test_mod, raw"""
              Base.Experimental.@VERSION
              """;expr_compat_mode=true) isa NamedTuple
  performance:
    compile_time:
      - impact: "ESTIMATED: negligible. Adds a small Expr(:mod_version, v) wrapper during compat conversion and a conditional in old-style macro argument handling."
    runtime:
      - impact: "No runtime impact; changes are limited to lowering and macro expansion paths."
  risk:
    level: "low"
    rationale:
      - "Changes are localized to JuliaLowering compat conversion and macro expansion; tests cover VersionNumber and @VERSION cases."
      - "No changes to CodeInfo/SSA or optimizer pipelines."
  open_questions:
    - "Do any downstream tools rely on seeing K\"VERSION\" outside of module headers in SyntaxTree graphs? If so, they may need to adjust for the new :mod_version gating."
  recommendations:
    - "Downstream macro tooling that inspects raw macro arguments should ignore or special-case K\"VERSION\" similarly to JuliaLowering to avoid extra-argument mismatches."
