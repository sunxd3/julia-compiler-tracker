schema_version: "1.0"
pr:
  number: 59888
  title: "Type-assert `isfinite(::AbstractFloat)`"
  url: "https://github.com/JuliaLang/julia/pull/59888"
  author: "JamesWrigley"
  co_author: "Simeon David Schaub"
  labels: []
  merged_at: "2025-10-20T11:13:36Z"
  merge_commit_sha: "78ba3be7e44da8ae686cc0ccf0b125d1fad820ca"
  head_commit_sha: "5dd00a927e458ef84ced8438defbaf58f4a0ad9e"
  diff_url: "https://github.com/JuliaLang/julia/pull/59888.diff"
  commits:
    - sha: "212d7279b9"
      message: "Type-assert `isfinite(::AbstractFloat)`"
      change: "(!isnan(x - x))::Bool"
    - sha: "5dd00a927e"
      message: "Update base/float.jl (refinement by co-author)"
      change: "!(isnan(x - x)::Bool)"
scope:
  files_touched:
    - "base/float.jl"
  components:
    - "Base"
    - "TypeInference"
  pipeline_stages:
    - "TypeInference"
    - "Runtime"
analysis:
  intent:
    summary: "Fixes type inference for isfinite(::AbstractFloat) by adding a ::Bool type assertion, preventing method invalidations in downstream packages caused by the inferred Any return type."
    issue_links: []
    issue_context: |
      The function isfinite(x::AbstractFloat) was returning an Any-typed result because
      the subtraction x - x on an abstract type AbstractFloat cannot be narrowed to a
      concrete type by the compiler. This caused the following inference chain:

      1. isfinite(x::AbstractFloat) = !isnan(x - x)
      2. x - x is inferred as Any (AbstractFloat has many subtypes with different - methods)
      3. isnan(Any) returns Bool, but the overall expression type becomes Any
      4. isinf(x::Real) = !isnan(x) & !isfinite(x) then has signature &(Bool, Any)
      5. This triggered massive method invalidations in packages like PythonCall.jl

      The PR author identified this through Cthulhu analysis showing:
        isinf(x::AbstractFloat::Real)::Any = !(isnan(x::AbstractFloat)::Bool)::Bool & !(isfinite(x::AbstractFloat)::Any)::Any
  direct_changes:
    - summary: "Added ::Bool type assertion to the isnan(x - x) call in isfinite(::AbstractFloat), refined in follow-up commit"
      component: "Base"
      evidence:
        - source: "diff"
          path: "base/float.jl"
          loc: "711"
          url: "https://github.com/JuliaLang/julia/blob/78ba3be7e44da8ae686cc0ccf0b125d1fad820ca/base/float.jl#L711"
          snippet: |
            # BEFORE (original, no assertion):
            isfinite(x::AbstractFloat) = !isnan(x - x)

            # FIRST COMMIT (212d7279b9 - assertion on outer expression):
            isfinite(x::AbstractFloat) = (!isnan(x - x))::Bool

            # FINAL (5dd00a927e - assertion on inner isnan call):
            isfinite(x::AbstractFloat) = !(isnan(x - x)::Bool)
        - source: "code"
          path: "base/float.jl"
          loc: "708-723"
          url: "https://github.com/JuliaLang/julia/blob/78ba3be7e44da8ae686cc0ccf0b125d1fad820ca/base/float.jl#L708-L723"
          snippet: |
            isnan(x::AbstractFloat) = (x != x)::Bool
            isnan(x::Number) = false

            isfinite(x::AbstractFloat) = !(isnan(x - x)::Bool)
            isfinite(x::Real) = decompose(x)[3] != 0
            isfinite(x::Integer) = true

            """
                isinf(f)::Bool

            Test whether a number is infinite.

            See also: [`Inf`](@ref), [`iszero`](@ref), [`isfinite`](@ref), [`isnan`](@ref).
            """
            isinf(x::Real) = !isnan(x) & !isfinite(x)
  secondary_effects:
    - effect: "isinf(x::Real) now infers as Bool instead of Any, eliminating invalidations"
      mechanism: |
        Call chain with file:line references:
        1. isinf(x::Real) = !isnan(x) & !isfinite(x)  [base/float.jl:722]
        2.   !isnan(x) returns Bool (already correctly typed)  [base/float.jl:708]
        3.   !isfinite(x) was returning Any, now returns Bool  [base/float.jl:711]
        4.   &(Bool, Bool) infers as Bool (not &(Bool, Any))
        5.   !Bool returns Bool
        6.   Overall isinf(x::Real) now correctly infers as Bool

        BEFORE: isinf signature triggered edge Tuple{typeof(&), Bool, Any}
        AFTER:  isinf signature uses Tuple{typeof(&), Bool, Bool}

        The invalidation chain from PR description showed 588 children invalidated
        from div(::Unsigned, ::Int64, ::RoundingMode{:Down}) alone, plus 202 from
        isinf(::AbstractFloat). The type assertion breaks this invalidation cascade.
      downstream_surfaces:
        - "PythonCall.jl - ampersand operator overload on Py"
        - "Any package defining &(x::Number, y::SomeType)"
        - "Code calling isinf on AbstractFloat subtypes"
        - "Code pattern-matching on isinf return type"
      likelihood: "high"
      impact: "high"
    - effect: "Type inference stability improved for isfinite callers"
      mechanism: |
        Many functions in Base call isfinite() and depend on its return type:

        Call sites in base/float.jl:
        - eps(x::AbstractFloat) = isfinite(x) ? ... : oftype(x, NaN)  [line 983]
        - rem(x::T, y::T, ::RoundingMode{:ToZero}) uses isfinite(x)  [line 597]
        - rem(x::T, y::T, ::RoundingMode{:Down}) checks isfinite(x)  [line 607]

        Call sites in base/complex.jl (17+ occurrences):
        - isfinite(z::Complex) = isfinite(real(z)) & isfinite(imag(z))  [line 150]
        - sqrt(z::Complex) uses isfinite in multiple branches  [lines 512-541]
        - exp(z::Complex) checks isfinite(zi)  [lines 698-758]
        - log(z::Complex) uses isfinite  [lines 822-857]

        All these call sites now have stable Bool return type inference when
        the argument is AbstractFloat, improving downstream type stability.
      downstream_surfaces:
        - "Complex number operations"
        - "Floating-point math functions"
        - "Range construction and iteration"
      likelihood: "high"
      impact: "medium"
    - effect: "Reduced method invalidation cascade on package loading"
      mechanism: |
        The PR description shows the invalidation chain from PythonCall.jl:

        inserting &(x::Number, y::PythonCall.Py) @ PythonCall.Core invalidated:
          mt_backedges:
          - Tuple{typeof(&), Bool, Any} triggered MethodInstance for isinf(::AbstractFloat) (202 children)
          - Tuple{typeof(&), Bool, Any} triggered MethodInstance for div(::Unsigned, ::Int64, ::RoundingMode{:Down}) (588 children)
          - ... and 10 more invalidation entries

        The root cause was &(Bool, Any) in isinf's compiled code. When PythonCall
        defined &(::Number, ::Py), it matched the Any and caused invalidation.

        With the fix, &(Bool, Bool) no longer matches &(::Number, ::Py) since
        Bool is not a supertype of Py, preventing the invalidation.

        CALL CHAIN:
        1. Package defines &(x::Number, y::CustomType)
        2. Julia checks if existing MethodInstances could match new signature
        3. BEFORE: isinf had &(Bool, Any), Any matches CustomType -> invalidate
        4. AFTER:  isinf has &(Bool, Bool), Bool doesn't match CustomType -> no invalidation
      downstream_surfaces:
        - "PythonCall.jl"
        - "Any package overloading bitwise & for Number"
        - "Package load times"
        - "First-call latency"
      likelihood: "high"
      impact: "high"
    - effect: "Complex{AbstractFloat} isfinite/isinf inference improved"
      mechanism: |
        Call chain showing transitive fix for Complex numbers [base/complex.jl:150-152]:

        isfinite(z::Complex) = isfinite(real(z)) & isfinite(imag(z))
        isinf(z::Complex) = isinf(real(z)) | isinf(imag(z))

        For Complex{AbstractFloat} (e.g., Complex{AbstractFloat}):
        - real(z) returns AbstractFloat
        - BEFORE: isfinite(AbstractFloat) returned Any
                  isfinite(z::Complex{AbstractFloat}) inferred as &(Any, Any) -> Any
        - AFTER:  isfinite(AbstractFloat) returns Bool
                  isfinite(z::Complex{AbstractFloat}) infers as &(Bool, Bool) -> Bool

        This transitively fixes inference for all Complex operations that use
        isfinite, including sqrt, exp, log defined in base/complex.jl lines 512-857.
      downstream_surfaces:
        - "Complex{AbstractFloat} arithmetic"
        - "Complex math functions (sqrt, exp, log, etc.)"
        - "Packages using complex number calculations with abstract float types"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "isfinite(::AbstractFloat) return type"
        change: "Now explicitly typed as Bool instead of inferred Any"
        affected_tools:
          - tool: "Type inference dependent code"
            usage: "Code that previously worked around the Any return type may need review"
      - field: "No API changes"
        change: "The function signature and behavior are unchanged"
        affected_tools:
          - tool: "All callers"
            usage: "Fully backward compatible, only inference quality improved"
    behavioral:
      - change: "No behavioral change - only type inference improvement"
        severity: "none"
        notes: |
          The ::Bool type assertion is semantically redundant since isnan always
          returns Bool. The assertion only affects the compiler's type inference,
          not runtime behavior. The function still computes the same result for
          all inputs.
  performance:
    compile_time:
      - change: "Improved type inference leads to better code generation"
        estimate: "ESTIMATED: slight improvement in compilation of code using isfinite/isinf on AbstractFloat"
      - change: "Reduced invalidations improve package load times"
        estimate: "MEASURED: PR description shows 588+ MethodInstances that no longer need recompilation when loading PythonCall.jl"
    runtime:
      - change: "No runtime overhead from type assertion"
        estimate: "MEASURED: zero overhead - type assertions are compile-time only when value already has correct type"
      - change: "Better inlining opportunities due to concrete Bool type"
        estimate: "ESTIMATED: potential for better optimization of code branches on isfinite/isinf results"
  risk:
    level: "low"
    rationale:
      - "Single line change with minimal scope"
      - "Type assertion is semantically redundant (isnan always returns Bool)"
      - "No behavioral changes, only inference quality improvement"
      - "Fixes known invalidation issues in downstream packages"
      - "Assignee is vtjnash (core Julia developer)"
      - "Pattern is already used elsewhere: isnan(x::AbstractFloat) = (x != x)::Bool"
  open_questions:
    - question: "Why does x - x for AbstractFloat infer as Any?"
      status: "ANSWERED"
      answer: |
        AbstractFloat is an abstract type with many subtypes (Float16, Float32, Float64,
        BigFloat, and potentially user-defined types). The compiler cannot determine
        which concrete - method will be called at runtime, so it conservatively infers
        the return type as Any. This is standard Julia type inference behavior for
        abstract types with multiple potential method matches.
    - question: "Should isfinite(::Real) also have a type assertion?"
      status: "OPEN"
      answer: |
        The isfinite(x::Real) = decompose(x)[3] != 0 implementation on line 712 does
        not have a type assertion. However, decompose returns NTuple{3,Int} for concrete
        types, so the comparison should infer correctly. If Real subtypes exist that
        don't specialize decompose, a similar issue could occur. Worth monitoring.
    - question: "Are there other similar type inference issues in Base?"
      status: "OPEN"
      answer: |
        The pattern of calling functions on abstract types and expecting Bool can
        occur elsewhere. The isnan function already has ::Bool assertion (line 708).
        A systematic audit of isXXX predicates on abstract types would be valuable.
    - question: "Does isfinite(x::Number) = iszero(x - x) have the same inference issue?"
      status: "ANSWERED"
      answer: |
        No. The generic fallback in base/number.jl:78 uses iszero(x - x), not isnan.
        iszero is defined as iszero(x) = x == zero(x) [base/number.jl:42], and the
        == operator always returns Bool (or throws), so iszero(Any) correctly infers
        as Bool. This is different from isnan where the implementation (x != x)::Bool
        needed the explicit assertion because != on abstract types can have varying
        return types from user-defined methods.
    - question: "Why was the assertion placement refined from (!isnan(...))::Bool to !(isnan(...)::Bool)?"
      status: "ANSWERED"
      answer: |
        The second commit (5dd00a927e by Simeon Schaub) moved the type assertion
        from the outer negation to the inner isnan call. Both are semantically
        equivalent for inference purposes, but the refined version:
        1. Is more precise - asserts at the point of type uncertainty (isnan call)
        2. Follows the same pattern as isnan(x::AbstractFloat) = (x != x)::Bool
        3. Makes the intent clearer - asserting isnan returns Bool, not that !Any is Bool
  recommendations:
    - "Downstream packages experiencing invalidations from isinf/isfinite can upgrade to Julia versions including this fix"
    - "Package maintainers should verify that their & overloads no longer cause cascading invalidations after this fix"
    - "Consider adding similar ::Bool assertions to other predicate functions on abstract types if inference issues are found"
    - "Use Cthulhu.jl's descend functionality to identify Any-typed intermediate values in performance-critical code"
    - "Complex number code with abstract float components will benefit - test Complex{AbstractFloat} inference in downstream packages"
    - "The pattern (!expr)::Bool vs !(expr::Bool) is equivalent for inference but the latter is preferred for consistency with isnan"
evidence_search:
  - summary: "rg results for isfinite usage in base"
    evidence:
      - source: "rg"
        path: "rg 'isfinite\\(' base/"
        loc: "output"
        snippet: |
          base/number.jl:65:    isfinite(f)::Bool
          base/number.jl:78:isfinite(x::Number) = iszero(x - x)
          base/float.jl:597:    if isfinite(x) && !iszero(x) && isfinite(y) && !iszero(y)
          base/float.jl:607:    if isinf(y) && isfinite(x)
          base/float.jl:711:isfinite(x::AbstractFloat) = !(isnan(x - x)::Bool)
          base/float.jl:712:isfinite(x::Real) = decompose(x)[3] != 0
          base/float.jl:713:isfinite(x::Integer) = true
          base/float.jl:722:isinf(x::Real) = !isnan(x) & !isfinite(x)
          base/float.jl:983:eps(x::AbstractFloat) = isfinite(x) ? abs(x) >= floatmin(x) ? ...
          base/complex.jl:150:isfinite(z::Complex) = isfinite(real(z)) & isfinite(imag(z))
          ... (40+ additional occurrences in complex.jl, floatfuncs.jl, etc.)
  - summary: "isinf implementation depending on isfinite"
    evidence:
      - source: "code"
        path: "base/float.jl"
        loc: "715-723"
        url: "https://github.com/JuliaLang/julia/blob/78ba3be7e44da8ae686cc0ccf0b125d1fad820ca/base/float.jl#L715-L723"
        snippet: |
          """
              isinf(f)::Bool

          Test whether a number is infinite.

          See also: [`Inf`](@ref), [`iszero`](@ref), [`isfinite`](@ref), [`isnan`](@ref).
          """
          isinf(x::Real) = !isnan(x) & !isfinite(x)
          isinf(x::IEEEFloat) = abs(x) === oftype(x, Inf)
  - summary: "isnan already uses ::Bool assertion pattern"
    evidence:
      - source: "code"
        path: "base/float.jl"
        loc: "700-709"
        url: "https://github.com/JuliaLang/julia/blob/78ba3be7e44da8ae686cc0ccf0b125d1fad820ca/base/float.jl#L700-L709"
        snippet: |
          """
              isnan(f)::Bool

          Test whether a number value is a NaN, an indeterminate value which is neither an infinity
          nor a finite number ("not a number").

          See also: [`iszero`](@ref), [`isone`](@ref), [`isinf`](@ref), [`ismissing`](@ref).
          """
          isnan(x::AbstractFloat) = (x != x)::Bool
          isnan(x::Number) = false
  - summary: "Generic isfinite fallback in number.jl"
    evidence:
      - source: "code"
        path: "base/number.jl"
        loc: "64-78"
        url: "https://github.com/JuliaLang/julia/blob/78ba3be7e44da8ae686cc0ccf0b125d1fad820ca/base/number.jl#L64-L78"
        snippet: |
          """
              isfinite(f)::Bool

          Test whether a number is finite.

          # Examples
          ```jldoctest
          julia> isfinite(5)
          true

          julia> isfinite(NaN32)
          false
          ```
          """
          isfinite(x::Number) = iszero(x - x)
  - summary: "Git history verification of two-commit evolution"
    evidence:
      - source: "git"
        path: "git log --oneline"
        loc: "PR branch"
        snippet: |
          5dd00a927e Update base/float.jl
          212d7279b9 Type-assert `isfinite(::AbstractFloat)`

          Commit 212d7279b9 added the initial fix with assertion on outer expression.
          Commit 5dd00a927e refined placement to inner isnan call (co-authored by Simeon Schaub).
  - summary: "Complex{T} predicate implementations that benefit from this fix"
    evidence:
      - source: "code"
        path: "base/complex.jl"
        loc: "147-154"
        url: "https://github.com/JuliaLang/julia/blob/78ba3be7e44da8ae686cc0ccf0b125d1fad820ca/base/complex.jl#L147-L154"
        snippet: |
          isreal(x::Real) = true
          isreal(z::Complex) = iszero(imag(z))
          isinteger(z::Complex) = isreal(z) & isinteger(real(z))
          isfinite(z::Complex) = isfinite(real(z)) & isfinite(imag(z))
          isnan(z::Complex) = isnan(real(z)) | isnan(imag(z))
          isinf(z::Complex) = isinf(real(z)) | isinf(imag(z))
          iszero(z::Complex) = iszero(real(z)) & iszero(imag(z))
          isone(z::Complex) = isone(real(z)) & iszero(imag(z))
  - summary: "iszero implementation showing why Number fallback doesn't have same issue"
    evidence:
      - source: "code"
        path: "base/number.jl"
        loc: "42"
        url: "https://github.com/JuliaLang/julia/blob/78ba3be7e44da8ae686cc0ccf0b125d1fad820ca/base/number.jl#L42"
        snippet: |
          iszero(x) = x == zero(x) # fallback method

          # The == operator always returns Bool, so iszero(Any) -> Bool.
          # This is why isfinite(x::Number) = iszero(x - x) doesn't need
          # a type assertion like isfinite(x::AbstractFloat) does.
