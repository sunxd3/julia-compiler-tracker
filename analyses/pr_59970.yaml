schema_version: "1.0"

pr:
  number: 59970
  title: "Fix calloc argument order"
  url: "https://github.com/JuliaLang/julia/pull/59970"
  diff_url: "https://github.com/JuliaLang/julia/pull/59970.diff"
  author: "yuyichao"
  labels: []
  merged_at: "2025-10-29T12:29:20Z"
  merge_commit_sha: "95a0b8491e"
  assignee: "d-netto"

scope:
  files_touched:
    - "src/debuginfo.cpp"
  components:
    - "Runtime"
    - "DebugInfo"
  pipeline_stages:
    - "Runtime"
    - "StackWalking"

analysis:
  intent:
    summary: |
      Fixes incorrect argument order in calloc() calls that GCC 15 warns about.
      The calloc() signature is `calloc(size_t nmemb, size_t size)` - number of
      elements first, then size of each element. The original code had these
      arguments reversed. While functionally equivalent (multiplication is
      commutative), the swap fixes compiler warnings and follows the correct API.
    pr_description: |
      GCC 15 warns about these. These shouldn't behave any different AFAICT but
      just looks confusing (granted I never remember what's the correct order either...)
    issue_links: []

  direct_changes:
    - summary: "Fix calloc argument order in lookup_pointer() for frame allocation"
      component: "debuginfo.cpp"
      evidence:
        - source: "diff"
          path: "src/debuginfo.cpp"
          loc: "494"
          url: "https://github.com/JuliaLang/julia/blob/95a0b8491e/src/debuginfo.cpp#L494"
          snippet: |
            # BEFORE:
            jl_frame_t *new_frames = (jl_frame_t*)calloc(sizeof(jl_frame_t), n_frames);

            # AFTER:
            jl_frame_t *new_frames = (jl_frame_t*)calloc(n_frames, sizeof(jl_frame_t));

    - summary: "Fix calloc argument order in jl_getFunctionInfo_impl() for initial frame"
      component: "debuginfo.cpp"
      evidence:
        - source: "diff"
          path: "src/debuginfo.cpp"
          loc: "1285"
          url: "https://github.com/JuliaLang/julia/blob/95a0b8491e/src/debuginfo.cpp#L1285"
          snippet: |
            # BEFORE:
            jl_frame_t *frames = (jl_frame_t*)calloc(sizeof(jl_frame_t), 1);

            # AFTER:
            jl_frame_t *frames = (jl_frame_t*)calloc(1, sizeof(jl_frame_t));

  code_context:
    jl_frame_t_definition:
      path: "src/julia_internal.h"
      loc: "1483-1490"
      url: "https://github.com/JuliaLang/julia/blob/95a0b8491e/src/julia_internal.h#L1483-L1490"
      snippet: |
        // Function metadata arising from debug info lookup of instruction pointer
        typedef struct {
            char *func_name;
            char *file_name;
            int line;
            jl_code_instance_t *ci;
            int fromC;
            int inlined;
        } jl_frame_t;

    lookup_pointer_function:
      path: "src/debuginfo.cpp"
      loc: "450-498"
      url: "https://github.com/JuliaLang/julia/blob/95a0b8491e/src/debuginfo.cpp#L450-L498"
      description: |
        lookup_pointer() expands a single frame into multiple frames when
        inlined code is detected. It allocates a new array of jl_frame_t
        structures to hold all the inlined frames.
      snippet: |
        static int lookup_pointer(
                object::SectionRef Section, DIContext *context,
                jl_frame_t **frames, size_t pointer, uint64_t slide,
                bool demangle, bool noInline) JL_NOTSAFEPOINT
        {
            // ... context setup ...
            int n_frames = inlineInfo.getNumberOfFrames();
            if (noInline)
                n_frames = 1;
            if (n_frames > 1) {
                jl_frame_t *new_frames = (jl_frame_t*)calloc(n_frames, sizeof(jl_frame_t));
                memcpy(&new_frames[n_frames - 1], *frames, sizeof(jl_frame_t));
                free(*frames);
                *frames = new_frames;
            }
            // ... populate frame info ...
        }

    jl_getFunctionInfo_impl_function:
      path: "src/debuginfo.cpp"
      loc: "1280-1299"
      url: "https://github.com/JuliaLang/julia/blob/95a0b8491e/src/debuginfo.cpp#L1280-L1299"
      description: |
        jl_getFunctionInfo_impl() is the main entry point for looking up debug
        info for an instruction pointer. It allocates an initial single frame
        and then calls lookup_pointer() to expand it with debug info.
      snippet: |
        extern "C" JL_DLLEXPORT_CODEGEN int jl_getFunctionInfo_impl(
                jl_frame_t **frames_out, size_t pointer, int skipC, int noInline) JL_NOTSAFEPOINT
        {
            // This function is not allowed to reference any TLS variables if noInline
            // since it can be called from an unmanaged thread on OSX.
            jl_frame_t *frames = (jl_frame_t*)calloc(1, sizeof(jl_frame_t));
            frames[0].line = -1;
            *frames_out = frames;
            // ... lookup in debug context ...
            int nf = lookup_pointer(Section, context, frames_out, pointer, slide, true, noInline);
            return nf;
        }

    callers:
      - function: "jl_lookup_code_address"
        path: "src/stackwalk.c"
        loc: "712-743"
        url: "https://github.com/JuliaLang/julia/blob/95a0b8491e/src/stackwalk.c#L712-L743"
        description: "Julia-callable function to look up code address info"
        snippet: |
          JL_DLLEXPORT jl_value_t *jl_lookup_code_address(void *ip, int skipC)
          {
              jl_task_t *ct = jl_current_task;
              jl_frame_t *frames = NULL;
              int8_t gc_state = jl_gc_safe_enter(ct->ptls);
              int n = jl_getFunctionInfo(&frames, (uintptr_t)ip, skipC, 0);
              jl_gc_safe_leave(ct->ptls, gc_state);
              jl_value_t *rs = (jl_value_t*)jl_alloc_svec(n);
              JL_GC_PUSH1(&rs);
              for (int i = 0; i < n; i++) {
                  jl_frame_t frame = frames[i];
                  // ... populate Julia svec from frame ...
              }
              free(frames);
              JL_GC_POP();
              return rs;
          }
      - function: "jl_fprint_native_codeloc"
        path: "src/stackwalk.c"
        loc: "760-781"
        url: "https://github.com/JuliaLang/julia/blob/95a0b8491e/src/stackwalk.c#L760-L781"
        description: "Prints function/file/line for a native instruction pointer"
        snippet: |
          void jl_fprint_native_codeloc(ios_t *s, uintptr_t ip) JL_NOTSAFEPOINT
          {
              jl_frame_t *frames = NULL;
              int n = jl_getFunctionInfo(&frames, ip, 0, 0);
              for (int i = 0; i < n; i++) {
                  jl_frame_t frame = frames[i];
                  // ... print frame info ...
                  free(frame.func_name);
                  free(frame.file_name);
              }
              free(frames);
          }
      - function: "SymbolTable::lookupLocalPC"
        path: "src/disasm.cpp"
        loc: "677-687"
        url: "https://github.com/JuliaLang/julia/blob/95a0b8491e/src/disasm.cpp#L677-L687"
        description: "Used in disassembly for debug info lookup"
        snippet: |
          const char *SymbolTable::lookupLocalPC(size_t addr) {
              jl_frame_t *frame = NULL;
              jl_getFunctionInfo(&frame, addr, /*skipC*/0,
                  /*noInline*/1/* the entry pointer shouldn't have inlining */);
              char *name = frame->func_name; // TODO: free me
              free(frame->file_name);
              free(frame);
              return name;
          }

    memory_lifecycle:
      description: |
        Complete memory lifecycle for jl_frame_t allocations showing
        allocation in debuginfo.cpp and deallocation in callers.
      call_chain: |
        jl_lookup_code_address() [stackwalk.c:712]
          -> jl_getFunctionInfo() [julia_internal.h:2123]
            -> jl_getFunctionInfo_impl() [debuginfo.cpp:1280]
              -> calloc(1, sizeof(jl_frame_t))  [LINE 1285 - FIXED]
              -> lookup_pointer() [debuginfo.cpp:450]
                -> calloc(n_frames, sizeof(jl_frame_t))  [LINE 494 - FIXED]
                -> free(*frames) to free single initial frame
          <- returns frames array
          -> for each frame: free(frame.func_name), free(frame.file_name)
          -> free(frames)
        Similar pattern for jl_fprint_native_codeloc() and SymbolTable::lookupLocalPC()

  secondary_effects:
    - effect: "None - semantically equivalent change"
      mechanism: |
        calloc(nmemb, size) internally computes nmemb * size for the total
        allocation. Since multiplication is commutative, swapping the arguments
        produces identical behavior at runtime. The change only affects compiler
        warnings and code correctness according to the API specification.
      downstream_surfaces: []
      likelihood: "none"
      impact: "none"

  compatibility:
    internal_api: []
    behavioral:
      - item: "No behavioral changes"
        description: |
          The allocated memory size is identical (n_frames * sizeof(jl_frame_t)).
          All downstream code that uses jl_frame_t arrays continues to work
          identically.

  performance:
    compile_time:
      - item: "No compile-time impact"
        description: "Change only affects runtime C code, not Julia compilation"
    runtime:
      - item: "No runtime impact"
        description: |
          calloc internally multiplies its arguments. The order does not affect
          the multiplication result or allocation performance.
          ESTIMATED: 0% change in runtime performance.

  downstream_package_impact:
    opaque_closure: "Not affected - change is in debug info lookup only"
    generated_functions: "Not affected"
    world_age_invalidation: "Not affected"
    jet: "Not affected - does not interact with native debug info lookup"
    irtools: "Not affected"
    cassette: "Not affected"
    gpucompiler: "Not affected"
    enzyme: "Not affected"

  risk:
    level: "low"
    rationale:
      - "Purely cosmetic fix - no semantic change to memory allocation"
      - "Fixes GCC 15 compiler warnings"
      - "Simple two-line change with no behavioral impact"
      - "Author is experienced Julia contributor (yuyichao)"
      - "Change is in non-critical debug info path"
      - "No tests modified - existing tests cover the functionality"

  testing:
    description: |
      No new tests added. The change is semantically equivalent, so existing
      tests for stack walking and debug info continue to pass and provide
      coverage.
    tests_modified: []

  open_questions: []

  recommendations:
    - "No action required for downstream packages"

  reviewer_verification:
    codebase_audit: |
      Independent search confirmed no remaining calloc(sizeof...) patterns in src/:
        $ rg 'calloc\(sizeof' julia/src/
        (no matches)
      All calloc calls now follow correct argument order (nmemb, size).
    calloc_patterns_verified:
      - "calloc(1, sizeof(jl_ast_context_t)) - ast.c:203"
      - "calloc(nm, sz) - gc-mmtk.c, gc-common.c, gc-stock.c"
      - "calloc(n_frames, sizeof(jl_frame_t)) - debuginfo.cpp:494 (FIXED)"
      - "calloc(1, sizeof(jl_frame_t)) - debuginfo.cpp:1285 (FIXED)"
      - "calloc(maxsize, sizeof(jl_bt_element_t)) - signal-handling.c:43"
      - "calloc(1, sizeof(logdata_block)) - coverage.cpp:37"
      - "calloc(newsize, sizeof(jl_ptls_t)) - threading.c:379"
      - "calloc(jl_all_tls_states_size, sizeof(jl_ptls_t)) - threading.c:809"
    all_callers_traced: true
    memory_safety_verified: |
      All callers properly free the allocated frames array and its string members:
      - stackwalk.c:740 - free(frames) after iterating
      - stackwalk.c:780 - free(frames) after iterating
      - disasm.cpp:685 - free(frame) after use

metadata:
  analysis_date: "2025-01-22"
  analyst: "claude"
  reviewer: "claude-opus-4-5"
  review_date: "2025-01-22"
  confidence: "high"
  notes: |
    This is a minimal correctness fix with no functional impact. The PR
    addresses GCC 15 warnings about calloc argument order. The standard C
    library function calloc() takes the number of elements as the first
    argument and the size of each element as the second. The original code
    had these reversed, which while functionally equivalent, is technically
    incorrect and triggers compiler warnings.
  reviewer_notes: |
    Independent verification confirmed:
    1. All calloc calls in src/ now use correct argument order (nmemb first, size second)
    2. Complete memory lifecycle traced: allocation in debuginfo.cpp, deallocation in callers
    3. Three caller sites verified: jl_lookup_code_address, jl_fprint_native_codeloc, lookupLocalPC
    4. No secondary effects - purely cosmetic fix for compiler warnings
    5. Analysis accuracy validated - original analysis was thorough and correct
