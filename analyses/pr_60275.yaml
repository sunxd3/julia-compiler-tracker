schema_version: "1.0"

pr:
  number: 60275
  title: "loading: Clamp Julia syntax version from Manifest as well"
  url: "https://github.com/JuliaLang/julia/pull/60275"
  author: "Keno"
  labels: []
  merged_at: "2025-11-29T07:37:06Z"
  merge_commit_sha: "011ea7965b"
  diff_url: "https://github.com/JuliaLang/julia/pull/60275.diff"

scope:
  files_touched:
    - "base/loading.jl"
    - "test/loading.jl"
    - "test/project/SyntaxVersioning/explicit/Manifest.toml"
    - "test/project/SyntaxVersioning/explicit/Project.toml"
    - "test/project/SyntaxVersioning/explicit/VersionedDep3/Project.toml"
    - "test/project/SyntaxVersioning/explicit/VersionedDep3/src/VersionedDep3.jl"
  components:
    - "Base.loading"
  pipeline_stages:
    - "PackageLoading"

analysis:
  intent:
    summary: |
      Adds clamping of syntax.julia_version from Manifest.toml entries to ensure the version
      never falls below NON_VERSIONED_SYNTAX (v1.13). This mirrors the existing clamping
      behavior for Project.toml files and prevents errors from manually-edited Manifest files
      or those generated by a buggy Pkg.jl version that forgot to implement this clamping.

      Per PR body: "too much manual editing of Manifest files happening with AI assistants"
      makes this defensive fix important to prevent undefined parser behavior.
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60273"

  direct_changes:
    - summary: "Add clamping of syntax_version in explicit_manifest_entry_load_spec()"
      component: "base/loading.jl"
      evidence:
        - source: "code"
          path: "base/loading.jl"
          loc: "1225-1228"
          url: "https://github.com/JuliaLang/julia/blob/011ea7965b/base/loading.jl#L1225-L1228"
          snippet: |
            # Clamp to minimum supported syntax version
            if syntax_version <= NON_VERSIONED_SYNTAX
                syntax_version = NON_VERSIONED_SYNTAX
            end

    - summary: "Add test for clamping behavior with VersionedDep3 having syntax.julia_version=1.0"
      component: "test/loading.jl"
      evidence:
        - source: "test"
          path: "test/loading.jl"
          loc: "1913-1914"
          url: "https://github.com/JuliaLang/julia/blob/011ea7965b/test/loading.jl#L1913-L1914"
          snippet: |
            # syntax.julia_version from Manifest = "1.0" should be clamped to "1.13"
            @test invokelatest(getglobal, (@eval (using VersionedDep3; VersionedDep3)), :ver) == v"1.13"

    - summary: "Add test package VersionedDep3 with intentionally old syntax.julia_version=1.0.0"
      component: "test/project/SyntaxVersioning/explicit/Manifest.toml"
      evidence:
        - source: "test_fixture"
          path: "test/project/SyntaxVersioning/explicit/Manifest.toml"
          loc: "16-19"
          url: "https://github.com/JuliaLang/julia/blob/011ea7965b/test/project/SyntaxVersioning/explicit/Manifest.toml#L16-L19"
          snippet: |
            [[deps.VersionedDep3]]
            path = "VersionedDep3"
            uuid = "6ae26a88-8a9e-4c29-a00a-ea2b9a48e6e1"
            syntax.julia_version = "1.0.0"

  secondary_effects:
    - effect: "Prevents parser initialization with unsupported syntax version"
      mechanism: |
        explicit_manifest_entry_load_spec() [base/loading.jl:1215]
          extracts syntax.julia_version from Manifest.toml entry [line 1224]
          NOW CLAMPS: if syntax_version <= v"1.13", set to v"1.13" [lines 1226-1228]
        -> returns PkgLoadSpec(path, syntax_version) [line 1236]
        -> _include_from_serialized() [base/loading.jl:2911]
          sets __toplevel__._internal_julia_parse = Experimental.VersionedParse(spec.julia_syntax_version)
        -> VersionedParse callable [base/experimental.jl:753-760]
          when called, dispatches to JuliaSyntax.core_parser_hook with syntax_version:
            Base.JuliaSyntax.core_parser_hook(code, filename, lineno, offset, options; syntax_version=vp.ver)
          an invalid (too old) syntax_version could cause undefined behavior in parser
      downstream_surfaces:
        - "JuliaSyntax parser initialization"
        - "Package include behavior"
      likelihood: "medium"
      impact: "medium"
      evidence:
        - source: "code"
          path: "base/experimental.jl"
          loc: "753-760"
          url: "https://github.com/JuliaLang/julia/blob/011ea7965b/base/experimental.jl#L753-L760"
          snippet: |
            function (vp::VersionedParse)(code, filename::String, lineno::Int, offset::Int, options::Symbol)
                if !isdefined(Base, :JuliaSyntax)
                    if vp.ver === VERSION
                        return Core._parse
                    end
                    error("JuliaSyntax module is required for syntax version $(vp.ver), but it is not loaded.")
                end
                Base.JuliaSyntax.core_parser_hook(code, filename, lineno, offset, options; syntax_version=vp.ver)
            end

    - effect: "Cache invalidation for packages with old manifest syntax version"
      mechanism: |
        stale_cachefile() [base/loading.jl:4199-4234]
          parses cache header to extract syntax_version [line 4217]
          checks: if syntax_version != cache_syntax_version(modspec.julia_syntax_version) [line 4230]

        cache_syntax_version() [base/loading.jl:4187-4189] computes:
          UInt8(clamp(ver.minor - 13, 0, 255))

        Note: Without this fix, v"1.0" would produce clamp(0-13, 0, 255) = 0,
        same as v"1.13" produces clamp(13-13, 0, 255) = 0.
        So caching would NOT have detected the invalid version, but parser
        initialization could fail when the raw version reaches JuliaSyntax.
      downstream_surfaces:
        - "Package precompilation cache"
      likelihood: "low"
      impact: "low"
      evidence:
        - source: "code"
          path: "base/loading.jl"
          loc: "4187-4189"
          url: "https://github.com/JuliaLang/julia/blob/011ea7965b/base/loading.jl#L4187-L4189"
          snippet: |
            function cache_syntax_version(ver::VersionNumber)
                UInt8(clamp(ver.minor - 13, 0, 255))
            end

    - effect: "Package extensions inherit clamped syntax version from parent"
      mechanism: |
        explicit_manifest_uuid_load_spec() [base/loading.jl:1178]
          when loading an extension, calls explicit_manifest_entry_load_spec for parent [line 1202]
          returns PkgLoadSpec with parent_load_spec.julia_syntax_version [line 1208]

        The parent's clamped syntax_version propagates to its extensions.
        Extensions cannot specify their own syntax version - they inherit from parent.
      downstream_surfaces:
        - "Package extension loading"
      likelihood: "low"
      impact: "low"
      evidence:
        - source: "code"
          path: "base/loading.jl"
          loc: "1201-1208"
          url: "https://github.com/JuliaLang/julia/blob/011ea7965b/base/loading.jl#L1201-L1208"
          snippet: |
            if extensions !== nothing && haskey(extensions, pkg.name) && uuid !== nothing && uuid5(UUID(uuid), pkg.name) == pkg.uuid
                parent_load_spec = explicit_manifest_entry_load_spec(manifest_file, PkgId(UUID(uuid), name), entry)
                if parent_load_spec === nothing || parent_load_spec === missing
                    error("failed to find source of parent package: \"$name\"")
                end
                parent_path = parent_load_spec.path
                p = normpath(dirname(parent_path), "..")
                return PkgLoadSpec(find_ext_path(p, pkg.name), parent_load_spec.julia_syntax_version)

    - effect: "Precompilation process receives clamped syntax version"
      mechanism: |
        create_expr_cache() [base/loading.jl:3284]
          passes input.julia_syntax_version to include_package_for_output [line 3350]

        include_package_for_output() [base/loading.jl:3239]
          sets __toplevel__._internal_julia_parse = Experimental.VersionedParse(syntax_version) [line 3246]
          sets __toplevel__._internal_syntax_version = cache_syntax_version(syntax_version) [line 3248]

        Both parser initialization and cache metadata use the clamped version.
      downstream_surfaces:
        - "Package precompilation"
      likelihood: "low"
      impact: "low"
      evidence:
        - source: "code"
          path: "base/loading.jl"
          loc: "3245-3248"
          url: "https://github.com/JuliaLang/julia/blob/011ea7965b/base/loading.jl#L3245-L3248"
          snippet: |
            # This one changes the parser behavior
            __toplevel__._internal_julia_parse = Experimental.VersionedParse(syntax_version)
            # This one is the compatibility marker for cache loading
            __toplevel__._internal_syntax_version = cache_syntax_version(syntax_version)

  compatibility:
    internal_api:
      - field: "PkgLoadSpec.julia_syntax_version"
        change: "Now guaranteed to be >= v1.13 when loaded from Manifest.toml"
        affected_tools: []

    behavioral:
      - description: |
          Packages with syntax.julia_version < 1.13 in Manifest.toml will now behave
          as if they specified 1.13. This is intentional safety behavior.
        breaking: false
        migration: "None required - this is a safety fix that aligns Manifest behavior with Project behavior"

  performance:
    compile_time:
      - description: "One additional comparison per manifest entry load (negligible)"
        change: "O(1) per package load - single VersionNumber comparison"
        label: "ESTIMATED"

    runtime: []

  risk:
    level: "low"
    rationale:
      - "Small, localized change to loading.jl only (4 lines added)"
      - "Mirrors existing clamping behavior in project_get_syntax_version() at lines 932-935"
      - "Only affects edge cases with invalid (too old) syntax versions"
      - "Defensive fix that prevents potential undefined parser behavior"
      - "Test coverage added for the specific behavior"
      - "No breaking changes - users with valid syntax versions unaffected"

  open_questions: []

  recommendations:
    - "Downstream package maintainers: No action needed"
    - "Users with manually-edited Manifest.toml files specifying old syntax versions should expect them to be clamped to 1.13"
    - "AI assistants editing Manifest.toml should avoid setting syntax.julia_version below 1.13"

supplementary:
  reviewer_notes: |
    Enhanced by second-pass independent analysis on 2026-01-21.

    Key findings from independent review:
    1. Corrected line numbers in evidence (was 1285-1288, actually 1225-1228)
    2. Added extension propagation secondary effect
    3. Added precompilation path secondary effect
    4. Added detailed cache_syntax_version analysis showing why cache
       system alone wouldn't catch invalid versions
    5. Added VersionedParse code snippet showing actual parser dispatch

  call_chain_detail: |
    Package Loading Flow (with line numbers verified):

    1. require(pkg) -> locate_package_env() -> explicit_manifest_uuid_load_spec()
       [base/loading.jl:1178]

    2. explicit_manifest_uuid_load_spec() -> explicit_manifest_entry_load_spec()
       [base/loading.jl:1190]

    3. explicit_manifest_entry_load_spec() [base/loading.jl:1215-1260]
       - Defaults syntax_version = NON_VERSIONED_SYNTAX (v"1.13") [line 1221]
       - Extracts syntax.julia_version from manifest entry [lines 1222-1224]
       - NOW CLAMPS: if syntax_version <= v"1.13", syntax_version = v"1.13" [lines 1225-1228]
       - Returns PkgLoadSpec(path, syntax_version) [line 1236 or 1255]

    4. For extensions: parent's syntax_version propagates [line 1208]
       return PkgLoadSpec(find_ext_path(p, pkg.name), parent_load_spec.julia_syntax_version)

    5. _include_from_serialized() uses spec.julia_syntax_version [line 2911]
       __toplevel__._internal_julia_parse = Experimental.VersionedParse(spec.julia_syntax_version)

    6. VersionedParse callable [base/experimental.jl:753-760]
       Dispatches to JuliaSyntax.core_parser_hook with syntax_version parameter

    7. For precompilation: create_expr_cache() passes syntax_version [line 3350]
       -> include_package_for_output() sets parser and cache metadata [lines 3246-3248]

  existing_clamping_comparison: |
    Project.toml clamping (existing, in project_get_syntax_version):
    [base/loading.jl:932-935]
      elseif sv <= NON_VERSIONED_SYNTAX
          # Syntax versioning was first introduced in Julia 1.14 - we do not support
          # going back to versions before syntax version 1.13.
          sv = NON_VERSIONED_SYNTAX
      end

    Note: Project.toml clamping is in an elseif branch - only applies when sv is not nothing.
    If syntax.julia_version is absent, project_get_syntax_version falls back to compat.julia
    or VERSION.

    Manifest.toml clamping (NEW, in explicit_manifest_entry_load_spec):
    [base/loading.jl:1225-1228]
      # Clamp to minimum supported syntax version
      if syntax_version <= NON_VERSIONED_SYNTAX
          syntax_version = NON_VERSIONED_SYNTAX
      end

    Note: Manifest.toml already defaults to NON_VERSIONED_SYNTAX when syntax table is absent.
    This clamping only triggers when syntax.julia_version is explicitly present but too old.

  test_verification: |
    The test uses @Base.Experimental.VERSION macro to verify the syntax version:

    module VersionedDep3
        const ver = (@Base.Experimental.VERSION).syntax
    end
    [test/project/SyntaxVersioning/explicit/VersionedDep3/src/VersionedDep3.jl]

    @Base.Experimental.VERSION [base/experimental.jl:834-842] returns the syntax version
    used to parse the code location where it's invoked via __source__.syntax_ver:

    function var"@VERSION"(__source__::Union{LineNumberNode, Core.MacroSource}, __module__::Module)
        if isa(__source__, LineNumberNode)
            return :((; syntax = v"1.13", runtime = VERSION))
        else
            return :((; syntax = $(__source__.syntax_ver), runtime = VERSION))
        end
    end

    Test assertion [test/loading.jl:1913-1914]:
    @test invokelatest(getglobal, (@eval (using VersionedDep3; VersionedDep3)), :ver) == v"1.13"

    This verifies that despite Manifest.toml specifying syntax.julia_version = "1.0.0",
    the actual parsing was done with version 1.13 due to clamping.

  cache_syntax_version_analysis: |
    The cache_syntax_version function [base/loading.jl:4187-4189]:
      function cache_syntax_version(ver::VersionNumber)
          UInt8(clamp(ver.minor - 13, 0, 255))
      end

    This encodes syntax version as a single byte relative to v1.13:
    - v"1.13" -> UInt8(clamp(13-13, 0, 255)) = 0
    - v"1.14" -> UInt8(clamp(14-13, 0, 255)) = 1
    - v"1.0"  -> UInt8(clamp(0-13, 0, 255))  = 0 (clamped from -13)

    IMPORTANT: Without the manifest clamping fix, v"1.0" would produce
    the same cache byte (0) as v"1.13". This means:
    - Cache staleness check would NOT detect the invalid version
    - Cache files compiled with "v1.0" (actually clamped to v1.13 by
      the cache write path) would be considered valid
    - However, the parser initialization path passes the raw unclamped
      version to JuliaSyntax.core_parser_hook, which could fail

    The fix ensures consistency: both paths now receive v"1.13" minimum.
