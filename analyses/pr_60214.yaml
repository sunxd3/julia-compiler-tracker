schema_version: "1.0"
pr:
  number: 60214
  title: "Finish PR: inference: fix the ptrfree field check"
  url: "https://github.com/JuliaLang/julia/pull/60214"
  author: "MasonProtter"
  labels: []
  merged_at: "2025-11-24T18:22:57Z"
  merge_commit_sha: "08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f"
  diff_url: "https://github.com/JuliaLang/julia/pull/60214.diff"
scope:
  files_touched:
    - "Compiler/src/abstractinterpretation.jl"
    - "Compiler/src/tfuncs.jl"
    - "Compiler/test/effects.jl"
  components:
    - "Compiler/src/abstractinterpretation.jl"
    - "Compiler/src/tfuncs.jl"
    - "Compiler/test/effects.jl"
  pipeline_stages:
    - "TypeInference"
    - "Effects"
analysis:
  intent:
    summary: "Complete the pointer-free field check fix started in PR #57550 by adding a layout guard to prevent UndefRefError when accessing DataTypeFieldDesc on types without a layout."
    issue_links:
      - "https://github.com/JuliaLang/julia/pull/57550"
  direct_changes:
    - summary: "Add `is_field_pointerfree` function with layout guard to safely check if a field is pointer-free, preventing UndefRefError when the DataType has no layout."
      component: "Compiler/src/abstractinterpretation.jl"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "3082-3087"
          url: "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler/src/abstractinterpretation.jl#L3082-L3087"
          snippet: |
            function is_field_pointerfree(dt::DataType, fidx::Int)
                dt.layout::Ptr{Cvoid} == C_NULL && return false
                DataTypeFieldDesc(dt)[fidx].isptr && return false
                ft = fieldtype(dt, fidx)
                return ft isa DataType && datatype_pointerfree(ft)
            end
    - summary: "Remove `is_undefref_fieldtype` function which used a type-based check (`!allocatedinline(ftyp)`) that was less precise than the new layout-based approach."
      component: "Compiler/src/tfuncs.jl"
      evidence:
        - source: "code"
          path: "Compiler/src/tfuncs.jl"
          loc: "1286-1297 (deleted)"
          url: "https://github.com/JuliaLang/julia/pull/60214/files#diff-tfuncs"
          snippet: |
            # DELETED CODE:
            # checks if a field of this type is guaranteed to be defined to a value
            # and that access to an uninitialized field will cause an `UndefRefError` or return zero
            # - is_undefref_fieldtype(String) === true
            # - is_undefref_fieldtype(Integer) === true
            # - is_undefref_fieldtype(Any) === true
            # - is_undefref_fieldtype(Int) === false
            # - is_undefref_fieldtype(Union{Int32,Int64}) === false
            # - is_undefref_fieldtype(T) === false
            function is_undefref_fieldtype(@nospecialize ftyp)
                return !has_free_typevars(ftyp) && !allocatedinline(ftyp)
            end
    - summary: "Update `abstract_eval_new` to use `is_field_pointerfree` instead of the negated `is_undefref_fieldtype` for determining allocation consistency."
      component: "Compiler/src/abstractinterpretation.jl"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "3089-3110"
          url: "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler/src/abstractinterpretation.jl#L3089-L3110"
          snippet: |
            function abstract_eval_new(interp::AbstractInterpreter, e::Expr, sstate::StatementState,
                                       sv::AbsIntState)
                ð•ƒáµ¢ = typeinf_lattice(interp)
                rt, _... = instanceof_tfunc(abstract_eval_value(interp, e.args[1], sstate, sv), true)
                ut = unwrap_unionall(rt)
                exct = Union{ErrorException,TypeError}
                if isa(ut, DataType) && !isabstracttype(ut)
                    ismutable = ismutabletype(ut)
                    fcount = datatype_fieldcount(ut)
                    nargs = length(e.args) - 1
                    has_any_uninitialized = fcount === nothing || (fcount > nargs &&
                        any(i::Int->is_field_pointerfree(ut, i), (nargs+1):fcount))
                    if has_any_uninitialized
                        # allocation with undefined field is inconsistent always
                        consistent = ALWAYS_FALSE
                    elseif ismutable
                        # mutable allocation isn't `:consistent`, but we still have a chance that
                        # return type information later refines the `:consistent`-cy of the method
                        consistent = CONSISTENT_IF_NOTRETURNED
                    else
                        consistent = ALWAYS_TRUE # immutable allocation is consistent
                    end
    - summary: "Add test for nested type `Maybe{Some{Base.RefValue{Int}}}` to verify consistency inference for types with pointer fields in nested wrappers."
      component: "Compiler/test/effects.jl"
      evidence:
        - source: "test"
          path: "Compiler/test/effects.jl"
          loc: "269-271"
          url: "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler/test/effects.jl#L269-L271"
          snippet: |
            @test Base.infer_effects() do
                Maybe{Some{Base.RefValue{Int}}}()
            end |> Compiler.is_consistent
  secondary_effects:
    - effect: "Prevents `UndefRefError` during effect inference when evaluating `:new` expressions on types without a computed layout."
      mechanism: |
        abstract_eval_statement_expr(interp, e, sstate, sv)  [abstractinterpretation.jl:3435-3441]
          dispatches on e.head === :new
          -> abstract_eval_new(interp, e, sstate, sv)  [abstractinterpretation.jl:3089]
            computes has_any_uninitialized = any(i->is_field_pointerfree(ut, i), ...)
          -> is_field_pointerfree(dt, fidx)  [abstractinterpretation.jl:3082-3087]
            guards: dt.layout::Ptr{Cvoid} == C_NULL && return false
            otherwise would call: DataTypeFieldDesc(dt)[fidx].isptr
          -> DataTypeFieldDesc(dt)  [base/runtime_internals.jl:747-752]
            constructor throws: dt.layout == C_NULL && throw(UndefRefError())
      downstream_surfaces:
        - "Core.Compiler effect inference (`Compiler.is_consistent`)"
        - "Allocation consistency decisions for `:new` expressions"
        - "Downstream tools using abstract interpretation (JET, etc.)"
      likelihood: "high"
      impact: "medium"
    - effect: "Changes semantic approach from type-based (`allocatedinline`) to layout-based (`DataTypeFieldDesc.isptr` + `datatype_pointerfree`) checking for uninitialized field consistency."
      mechanism: |
        Old approach in is_undefref_fieldtype:
          !has_free_typevars(ftyp) && !allocatedinline(ftyp)
          -> allocatedinline checks if type is stored inline (ccall to jl_stored_inline)
          -> returned true for boxed types (String, Any, etc.) that throw UndefRefError on access

        New approach in is_field_pointerfree:
          dt.layout::Ptr{Cvoid} == C_NULL && return false  # guard against no-layout types
          DataTypeFieldDesc(dt)[fidx].isptr && return false  # pointer fields are safe
          ft isa DataType && datatype_pointerfree(ft)  # field type has no GC pointers

        Key difference: New approach uses actual field layout metadata rather than
        type-level heuristics, providing more accurate consistency inference.
      downstream_surfaces:
        - "Effect inference accuracy for allocations with uninitialized fields"
      likelihood: "high"
      impact: "low"
  compatibility:
    internal_api:
      - change: "Removed `is_undefref_fieldtype` function from `Compiler/src/tfuncs.jl`"
        evidence:
          - source: "code"
            path: "Compiler/src/tfuncs.jl"
            loc: "1286-1297 (deleted)"
            url: "https://github.com/JuliaLang/julia/pull/60214/files"
            snippet: |
              # Function removed - was not exported, internal to Compiler module
              function is_undefref_fieldtype(@nospecialize ftyp)
                  return !has_free_typevars(ftyp) && !allocatedinline(ftyp)
              end
    behavioral:
      - change: "Effect inference no longer risks UndefRefError when evaluating `:new` on types without a layout; such fields are now conservatively treated as not pointer-free (returning false from `is_field_pointerfree`)."
        evidence:
          - source: "code"
            path: "Compiler/src/abstractinterpretation.jl"
            loc: "3083"
            url: "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler/src/abstractinterpretation.jl#L3083"
            snippet: |
              dt.layout::Ptr{Cvoid} == C_NULL && return false
      - change: "Nested wrapper types like `Maybe{Some{Base.RefValue{Int}}}` are now correctly inferred as consistent when uninitialized, because the outer field contains a pointer type."
        evidence:
          - source: "test"
            path: "Compiler/test/effects.jl"
            loc: "269-271"
            url: "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler/test/effects.jl#L269-L271"
            snippet: |
              @test Base.infer_effects() do
                  Maybe{Some{Base.RefValue{Int}}}()
              end |> Compiler.is_consistent
  performance:
    compile_time:
      - impact: "ESTIMATED: negligible; adds one pointer comparison (`dt.layout == C_NULL`) before accessing `DataTypeFieldDesc`. This is O(1) per field checked during `:new` evaluation."
    runtime:
      - impact: "No runtime effect; all changes are confined to inference-time consistency checks that determine effect flags."
  risk:
    level: "low"
    rationale:
      - "Change is localized to inference-time pointer-free checks with a strict layout guard."
      - "The removed `is_undefref_fieldtype` was internal to Compiler module and not exported."
      - "New test locks in expected behavior for nested wrapper types."
      - "Guards against a potential crash (UndefRefError) during compilation, improving robustness."
  open_questions:
    - "The TODO comment at lines 3154-3157 suggests `is_field_pointerfree` could be used in PartialStruct handling for more precise undefined field tracking - this remains unimplemented."
  recommendations:
    - "Downstream tools that extend abstract interpretation should be aware that `is_undefref_fieldtype` no longer exists; use `is_field_pointerfree` pattern if needed."
    - "Consider adding a test that explicitly exercises a layout-less DataType to verify the guard prevents UndefRefError during effect inference."
