schema_version: "1.0"
pr:
  number: 60567
  title: "[JuliaLowering] Implement flisp-compatible Box optimization"
  url: "https://github.com/JuliaLang/julia/pull/60567"
  author: "aviatesk"
  labels:
    - "JuliaLowering"
  merged_at: "2026-01-10T01:21:52Z"
  merge_commit_sha: "8ca9bc66edc471d265657eca9e5682e343e16d4d"
  diff_url: "https://github.com/JuliaLang/julia/pull/60567.diff"
scope:
  files_touched:
    - "JuliaLowering/src/JuliaLowering.jl"
    - "JuliaLowering/src/binding_analysis.jl"
    - "JuliaLowering/src/scope_analysis.jl"
    - "JuliaLowering/src/closure_conversion.jl"
    - "JuliaLowering/test/closures.jl"
    - "JuliaLowering/test/closures_ir.jl"
    - "JuliaLowering/test/scopes_ir.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Lowering"
    - "ScopeAnalysis"
analysis:
  intent:
    summary: "Implement JuliaLowering def-use pass mirroring flisp's lambda-optimize-vars!; captured single-assigned locals/arguments avoid Core.Box allocations."
    issue_links:
      - "https://github.com/aviatesk/JETLS.jl/pull/452"
      - "https://github.com/JuliaLang/julia/issues/37690"
    quoted_from_pr: |
      JETLS recently added a diagnostic for captured boxed variables (aviatesk/JETLS.jl#452).
      However, without proper Box optimization in JuliaLowering (the lowering backend for
      JETLS's analysis), there were too many false positives to be useful. This PR brings
      JuliaLowering's Box optimization roughly on par with flisp's `lambda-optimize-vars!`
      implementation.
  direct_changes:
    - summary: "Add tree-based def/use pass (analyze_def_and_use!) tracking captured single-assigned locals/arguments; mark is_always_defined when proven."
      component: "JuliaLowering/binding_analysis"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/binding_analysis.jl"
          loc: "28-52"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/binding_analysis.jl#L28-L52"
          snippet: |
            """
                analyze_def_and_use!(ctx, ex)

            Perform tree-based def-use analysis to find captured variables that are
            assigned before any closure captures them (never-undef) and not modified
            afterward. For such variables, as an abuse of binding flags we can mark them
            as `is_always_defined=true` to avoid unnecessary `Core.Box` allocations during
            closure conversion.

            This is called on the outermost lambda, and recursively processes nested lambdas.
            """
            function analyze_def_and_use!(ctx, ex)
                k = kind(ex)
                if k != K"lambda"
                    return
                end

                # First, recursively analyze nested lambdas (depth-first)
                if numchildren(ex) >= 3
                    _analyze_nested_lambdas!(ctx, ex[3])
                end

                # Now analyze this lambda
                _analyze_lambda_vars!(ctx, ex)
            end
        - source: "diff"
          path: "JuliaLowering/src/binding_analysis.jl"
          loc: "65-109"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/binding_analysis.jl#L65-L109"
          snippet: |
            function _analyze_lambda_vars!(ctx, ex)
                lambda_bindings = ex.lambda_bindings

                # Collect candidate variables: captured and single-assigned
                candidates = Set{IdTag}()
                for (id, _) in lambda_bindings.locals_capt
                    binfo = get_binding(ctx, id)
                    if (binfo.is_captured && binfo.is_assigned_once &&
                        (binfo.kind == :local || binfo.kind == :argument))
                        push!(candidates, id)
                        # For arguments, reset is_always_defined so we can determine if the
                        # outer-scope assignment dominates the capture.
                        if binfo.kind == :argument
                            binfo.is_always_defined = false
                        end
                    end
                end
                isempty(candidates) && return

                # flisp-compatible tables for tracking variable def and use:
                # - unused: candidate variables not yet used (read) in current block
                # - live: variables that have been assigned in current block
                # - seen: all variables we've seen assigned
                # - decl: variables scoped in current scope
                # - decl_outside_loop: variables scoped outside enclosing loop
                # - args: argument variables (never undefined, special handling)
                unused = candidates
                live = Set{IdTag}()
                seen = Set{IdTag}()
                decl = Set{IdTag}()
                decl_outside_loop = Set{IdTag}()
                args = Set{IdTag}()
                # Initialize decl and args with arguments
                for id in candidates
                    binfo = get_binding(ctx, id)
                    if binfo.kind == :argument
                        push!(decl, id)
                        push!(args, id)
                    end
                end
        - source: "diff"
          path: "JuliaLowering/src/binding_analysis.jl"
          loc: "116-152"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/binding_analysis.jl#L116-L152"
          snippet: |
            function kill!()
                union!(unused, live)
                empty!(live)
            end

            # Restore live to a previous state, moving new additions back to unused
            function restore!(prev)
                for id in decl_outside_loop
                    if (id in prev) && !(id in unused)
                        # This variable was 'used' inside this branch, but it's declared
                        # outside of a loop so it may see the dominating assignment execute
                        # multiple times. Invalidate it here for soundness.
                        delete!(prev, id)
                    end
                end
                for id in live
                    if !(id in prev)
                        push!(unused, id)
                    end
                end
                empty!(live)
                union!(live, prev)
            end

            # At the beginning of a loop, move all active decls into "decl_outside_loop"
            function enter_loop!()
                prev_decl_outside_loop = decl_outside_loop
                decl_outside_loop = decl
                decl = copy(decl)
                return prev_decl_outside_loop
            end

            # At the end of a loop, restore the previous set of "declared" variables.
            function leave_loop!(prev_decl_outside_loop)
                decl = decl_outside_loop
                decl_outside_loop = prev_decl_outside_loop
            end
        - source: "diff"
          path: "JuliaLowering/src/binding_analysis.jl"
          loc: "262-292"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/binding_analysis.jl#L262-L292"
          snippet: |
            elseif k in KSet"if elseif trycatchelse tryfinally"
                prev = copy(live)
                has_label = false
                for child in children(e)
                    has_label |= visit(child)
                    kill!()
                end
                if has_label
                    # If there's a label inside, we could have skipped a prior
                    # variable initialization
                    return true
                else
                    restore!(prev)
                    return false
                end

            elseif k in KSet"_while _do_while"
                prev = copy(live)
                old_decl = enter_loop!()
                has_label = false
                for child in children(e)
                    has_label |= visit(child)
                end
                leave_loop!(old_decl)
                if has_label
                    kill!()
                    return true
                else
                    restore!(prev)
                    return false
                end
        - source: "diff"
          path: "JuliaLowering/src/binding_analysis.jl"
          loc: "334-339"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/binding_analysis.jl#L334-L339"
          snippet: |
            # Variables in live or unused (that were seen assigned) are never-undef
            for id in union(live, unused)
                if id in seen
                    get_binding(ctx, id).is_always_defined = true
                end
            end
    - summary: "Scope resolution runs analyze_def_and_use! after analyze_variables!; include new binding_analysis pass in JuliaLowering.jl."
      component: "JuliaLowering/scope_analysis"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/JuliaLowering.jl"
          loc: "36"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/JuliaLowering.jl#L36"
          snippet: |
            _include("binding_analysis.jl")
        - source: "diff"
          path: "JuliaLowering/src/scope_analysis.jl"
          loc: "711-719"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/scope_analysis.jl#L711-L719"
          snippet: |
            @fzone "JL: resolve_scopes" function resolve_scopes(ctx::DesugaringContext, ex)
                ctx2 = ScopeResolutionContext(ctx, ex)
                ex2 = resolve_scopes(ctx2, reparent(ctx2, ex))
                ctx3 = VariableAnalysisContext(
                    ctx2.graph, ctx2.bindings, ctx2.mod, ctx2.scopes, ex2.lambda_bindings)
                analyze_variables!(ctx3, ex2)
                analyze_def_and_use!(ctx3, ex2)
                ctx3, ex2
            end
    - summary: "Closure boxing treats captured single-assigned locals/arguments marked is_always_defined as unboxed."
      component: "JuliaLowering/closure_conversion"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/closure_conversion.jl"
          loc: "304-317"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/closure_conversion.jl#L304-L317"
          snippet: |
            function is_boxed(binfo::BindingInfo)
                # No box needed for:
                # * :argument when it's not reassigned
                # * :static_parameter (these can't be reassigned)
                defined_but_not_assigned = binfo.is_always_defined && !binfo.is_assigned
                # * Single-assigned variables (local or argument) assigned before any closure captures them
                #   (identified by liveness analysis in optimize_captured_vars!)
                #   For arguments, the liveness analysis resets is_always_defined and only sets it back
                #   if the outer-scope assignment dominates all captures. This distinguishes arguments
                #   reassigned in outer scope (no box) from those reassigned only inside closures (needs box).
                single_assigned_never_undef = binfo.kind in (:local, :argument) &&
                                              binfo.is_always_defined && binfo.is_assigned_once
                return binfo.is_captured && !defined_but_not_assigned && !single_assigned_never_undef
            end
        - source: "diff"
          path: "JuliaLowering/src/closure_conversion.jl"
          loc: "409-418"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/closure_conversion.jl#L409-L418"
          snippet: |
            elseif k == K"local"
                var = ex[1]
                binfo = get_binding(ctx, var)
                if is_boxed(binfo)
                    @ast ctx ex [K"=" var [K"call" "Box"::K"core"]]
                elseif !binfo.is_always_defined
                    @ast ctx ex [K"newvar" var]
                else
                    newleaf(ctx, ex, K"TOMBSTONE")
                end
    - summary: "Add IR tests for unboxed captures in control-flow patterns (if, ternary, guard); labels still require boxing."
      component: "JuliaLowering/tests"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/closures_ir.jl"
          loc: "779-824"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/test/closures_ir.jl#L779-L824"
          snippet: |
            ########################################
            # Assignment after if statement doesn't need Box (flisp-compatible save/restore)
            function f_after_if(cond)
                if cond
                    println("hello")
                end
                y = 1
                () -> y
            end
            #---------------------
            # ...
            20  --- method core.nothing %₁₉
                slots: [slot₁/#self#(!read) slot₂/cond slot₃/y(single_assign)]
                # <-- single_assign = no box needed
                1   (gotoifnot slot₂/cond label₄)
                2   TestMod.println
                3   (call %₂ "hello")
                4   (= slot₃/y 1)
                5   TestMod.#f_after_if#->##0
                6   (call core.typeof slot₃/y)
                7   (call core.apply_type %₅ %₆)
                8   (new %₇ slot₃/y)  # <-- captures slot directly, not Core.Box
                9   (return %₈)
        - source: "test"
          path: "JuliaLowering/test/closures_ir.jl"
          loc: "976-1013"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/test/closures_ir.jl#L976-L1013"
          snippet: |
            ########################################
            # Label can be jumped to, bypassing assignment - needs Box
            let
                @goto L
                y = 1
                @label L
                ()->y
            end
            #---------------------
            1   (= slot₁/y (call core.Box))  # <-- Box required due to label
            2   (goto label₆)
            3   1
            4   slot₁/y
            5   (call core.setfield! %₄ :contents %₃)
            # ...
            18  --- method core.nothing %₁₇
                slots: [slot₁/#self#(!read) slot₂/y(!read,maybe_undef)]
                1   (call core.getfield slot₁/#self# :y)
                2   (call core.isdefined %₁ :contents)  # <-- isdefined check for boxed var
                3   (gotoifnot %₂ label₅)
                4   (goto label₇)
                5   (newvar slot₂/y)
                6   slot₂/y
                7   (call core.getfield %₁ :contents)
                8   (return %₇)
  secondary_effects:
    - effect: "Captured locals/arguments that are single-assigned can now become unboxed, changing closure field layout (boxed vs unboxed fields) and the IR for closure construction."
      mechanism: |
        resolve_scopes(...) runs analyze_def_and_use!(ctx3, ex2)  [scope_analysis.jl:717]
          -> _analyze_lambda_vars!(ctx, ex) iterates candidates  [binding_analysis.jl:65-87]
          -> visit(e) walks AST, tracking live/unused/seen sets  [binding_analysis.jl:186-320]
          -> assigns get_binding(ctx, id).is_always_defined = true  [binding_analysis.jl:337]
          -> is_boxed(binfo) checks is_always_defined && is_assigned_once  [closure_conversion.jl:314-315]
          -> closure_type_fields(...) calls is_boxed(ctx, id) per capture  [closure_conversion.jl:278]
          -> type_for_closure builds closure type with field_is_box  [closure_conversion.jl:288-301]
      downstream_surfaces:
        - "Closure field layout (boxed vs unboxed captured vars)"
        - "OpaqueClosure type parameters and capture allocation"
        - "Lowered IR shape in closure bodies"
      likelihood: "high"
      impact: "medium"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/closure_conversion.jl"
          loc: "275-282"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/closure_conversion.jl#L275-L282"
          snippet: |
            field_inds = Dict{IdTag,Int}()
            field_is_box = Vector{Bool}()
            for (i,id) in enumerate(field_orig_bindings)
                push!(field_is_box, is_boxed(ctx, id))
                field_inds[id] = i
            end

            return field_syms, field_orig_bindings, field_inds, field_is_box
    - effect: "isdefined checks and newvar emission for captured locals can change when variables become unboxed and always-defined, affecting diagnostics and IR shape for closure bodies."
      mechanism: |
        is_boxed(binfo) uses is_always_defined to decide boxing  [closure_conversion.jl:304-316]
          -> _convert_closures K"isdefined" branch: if is_boxed, emit core.isdefined call  [closure_conversion.jl:367-373]
          -> else if binfo.is_always_defined, emit true::K"Bool"  [closure_conversion.jl:374-376]
          -> _convert_closures K"local" branch: if is_boxed, emit Box allocation  [closure_conversion.jl:412-413]
          -> else if !binfo.is_always_defined, emit newvar  [closure_conversion.jl:414-415]
      downstream_surfaces:
        - "IRTools/Lowering consumers that inspect isdefined/newvar patterns"
        - "JET/diagnostic tooling that flags boxed captures"
      likelihood: "medium"
      impact: "low"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/closure_conversion.jl"
          loc: "363-386"
          url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/closure_conversion.jl#L363-L386"
          snippet: |
            elseif k == K"isdefined"
                # Convert isdefined expr to function for closure converted variables
                var = ex[1]
                binfo = get_binding(ctx, var)
                if is_boxed(binfo)
                    access = is_self_captured(ctx, var) ? captured_var_access(ctx, var) : var
                    @ast ctx ex [K"call"
                        "isdefined"::K"core"
                        access
                        "contents"::K"Symbol"
                    ]
                elseif binfo.is_always_defined || is_self_captured(ctx, var)
                    # Captured but unboxed vars are always defined
                    @ast ctx ex true::K"Bool"
                elseif binfo.kind == :global
                    # Normal isdefined won't work for globals (#56985)
                    @ast ctx ex [K"call"
                        "isdefinedglobal"::K"core"
                        ctx.mod::K"Value"
                        binfo.name::K"Symbol"
                        false::K"Bool"]
                else
                    ex
                end
  compatibility:
    internal_api:
      - summary: "BindingInfo.is_always_defined is now reset for captured arguments and recomputed by analyze_def_and_use! before closure conversion, widening the set of captured vars treated as always-defined."
        evidence:
          - source: "diff"
            path: "JuliaLowering/src/binding_analysis.jl"
            loc: "78-84"
            url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/binding_analysis.jl#L78-L84"
            snippet: |
              # For arguments, reset is_always_defined so we can determine if the
              # outer-scope assignment dominates the capture. Arguments start with
              # is_always_defined=true, but if they're reassigned inside a closure
              # (not in outer scope), we need the def-use analysis to decide.
              if binfo.kind == :argument
                  binfo.is_always_defined = false
              end
    behavioral:
      - summary: "Captured single-assigned locals/arguments are unboxed in more control-flow patterns, reducing Core.Box allocations and changing closure field layout."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/closures_ir.jl"
            loc: "811-821"
            url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/test/closures_ir.jl#L811-L821"
            snippet: |
              slots: [slot₁/#self#(!read) slot₂/cond slot₃/y(single_assign)]
              4   (= slot₃/y 1)
              8   (new %₇ slot₃/y)
      - summary: "Code paths containing symbolic labels still force boxing to preserve correctness when assignments can be bypassed."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/closures_ir.jl"
            loc: "985-989"
            url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/test/closures_ir.jl#L985-L989"
            snippet: |
              1   (= slot₁/y (call core.Box))
              5   (call core.setfield! %₄ :contents %₃)
  performance:
    compile_time:
      - summary: "ESTIMATED: Adds an extra tree-walk per lambda (analyze_def_and_use!), O(n) in AST size. Expected <5% increase in lowering time for typical functions."
        evidence:
          - source: "diff"
            path: "JuliaLowering/src/binding_analysis.jl"
            loc: "186-332"
            url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/binding_analysis.jl#L186-L332"
            snippet: |
              # Returns whether e contained a symbolic_label
              function visit(e)
                  k = kind(e)

                  if k == K"BindingId"
                      mark_used!(e.var_id)
                      return false
                  elseif k == K"symbolic_label"
                      kill!()
                      return true
                  # ... O(n) tree walk visiting each AST node once
    runtime:
      - summary: "Reduced Core.Box allocations for captured single-assigned locals/arguments in common control-flow patterns (e.g., if/ternary/guard), improving closure allocation behavior."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/closures.jl"
            loc: "244-253"
            url: "https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/test/closures.jl#L244-L253"
            snippet: |
              # Argument reassigned in outer scope - no Box needed
              @test JuliaLowering.include_string(test_mod, """
              begin
                  function f_arg_reassign(x)
                      x = 1
                      return ()->x
                  end
                  f_arg_reassign(100)()
              end
              """) == 1
  tests:
    changed_files:
      - "JuliaLowering/test/closures.jl"
      - "JuliaLowering/test/closures_ir.jl"
      - "JuliaLowering/test/scopes_ir.jl"
    new_behavior_assertions:
      - "f_after_if: Assignment after if statement doesn't need Box (save/restore pattern)"
      - "f_ternary: Ternary operator value position doesn't need Box"
      - "f_or_guard: || guard pattern with early exit doesn't need Box"
      - "f_arg_reassign: Argument reassigned in outer scope doesn't need Box"
      - "f_arg_if_branch: Argument reassigned in if-branch before capture doesn't need Box"
      - "f_loop_capture: Variable declared outside loop, assigned inside needs Box (issue #37690)"
      - "f_typed_local_loop: Typed local outside loop needs Box"
      - "Label with @goto bypassing assignment needs Box"
      - "f_arg_loop: Argument reassigned inside loop needs Box"
      - "f_break_loop: Variable in while-true loop with conditional capture needs Box"
      - "f_break_loop2: Variable in while-true loop with post-dominated capture doesn't need Box"
      - "f_local_no_box: Local single-assigned after declaration doesn't need Box"
      - "f_typed_local_no_box: Typed local single-assigned doesn't need Box"
    coverage_gaps:
      - "No explicit tests for nested try/catch/finally interactions with the def-use analysis"
      - "No benchmarks measuring compile-time overhead of the new pass"
  risk:
    level: "medium"
    rationale:
      - "Changes when captured variables are boxed/unboxed; incorrect dominance handling could change semantics or produce invalid IR."
      - "Adds control-flow-sensitive state (live/unused/decl_outside_loop) which must stay in sync with JuliaLowering AST kinds."
      - "The pass under-approximates is_always_defined to mean 'always_defined_and_not_modified_after_capture' which is subtle."
  open_questions:
    - "Do any JuliaSyntax/JuliaLowering AST kinds missing from visit(...) require kill!/restore! treatment to preserve soundness?"
    - "Should arguments reassigned only in nested lambdas remain boxed in all CFG shapes (e.g., with try/catch and labels)?"
    - "Could the linearization-based approach mentioned in Future work provide additional optimization opportunities?"
  recommendations:
    - "Downstream tooling that assumes captured locals are boxed should consult closure field metadata (field_is_box/is_boxed) rather than the presence of Core.Box in IR."
    - "Consider adding regression tests for try/catch/label interactions to ensure kill!/restore! remains sound for new syntax kinds."
    - "JET and similar tools should update their diagnostics to account for the reduced false-positive rate for boxed variables."
