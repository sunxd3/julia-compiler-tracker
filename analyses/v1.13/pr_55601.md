# PR #55601: inference: track reaching defs for slots

**Author:** Jameson Nash (vtjnash) | **Merged:** 2025-12-30 | **Risk:** medium

This PR implements reaching-definition tracking for slots during type inference by adding an `ssadef` marker and threading it through refinement/alias machinery. It enables the Path-Convergence Criterion at SSA/ϕ joins and replaces eager invalidation with lazy staleness checks based on `ssadef` mismatches (commit `94ae0acea1`).

## Changes

`Compiler/src/types.jl:L?`:
```julia
struct VarState
    typ
    ssadef::Int  # reaching definition: 0=argument, >0=SSA pc, <0=virtual ϕ-block
    undef::Bool
    VarState(@nospecialize(typ), ssadef::Int, undef::Bool) = new(typ, ssadef, undef)
end
```

`Compiler/src/typelattice.jl:L?`:
```julia
# Old: Conditional(slot::Int, thentype, elsetype; isdefined=false)
# New:
# Conditional(slot::Int, ssadef::Int, thentype, elsetype; isdefined=false)
```

`Compiler/src/typelattice.jl:L?`:
```julia
# Old: MustAlias(slot::Int, vartyp, fldidx::Int, fldtyp)
# New:
# MustAlias(slot::Int, ssadef::Int, vartyp, fldidx::Int, fldtyp)
```

`Compiler/src/abstractinterpretation.jl:L?` (new refinement carrier; replaces `StateUpdate.conditional`):
```julia
struct StateRefinement
    slot::Int
    newtyp
    undef::Bool
end
```

`Compiler/src/abstractinterpretation.jl:L?` / `Compiler/src/typeinfer.jl:L?` (merge/update APIs gain join context):
```julia
# smerge(..., join_pc::Int)
# schanged(..., join_pc::Int)
# stupdate!(..., join_pc::Int)
```

`Compiler/src/typelattice.jl:L?` (new equality predicate for refinement identity):
```julia
# checks both slot AND ssadef
is_same_conditionals(a::Conditional, b::Conditional)
```

`Compiler/src/abstractinterpretation.jl:L?` (apply refinement without clobbering reaching-def tracking):
```julia
strefine1!(state, refinement::StateRefinement)  # preserves VarState.ssadef
```

`Compiler/src/*:L?` (removals and cleanup tied to lazy staleness detection):
```julia
# removed (no longer needed with ssadef-based conditional_valid() checks)
invalidate_slotwrapper(...)
widenwrappedslotwrapper(...)

# removed constructors
Conditional(cnd::InterConditional)
MustAlias(alias::InterMustAlias)
```

## Breaking for downstream tools

- `VarState` layout changed: new field `ssadef::Int` inserted between `typ` and `undef::Bool` (`Compiler/src/types.jl`).
- `Conditional` signature/fields changed: now includes `ssadef::Int` (`Compiler/src/typelattice.jl`).
- `MustAlias` signature/fields changed: now includes `ssadef::Int` (`Compiler/src/typelattice.jl`).
- `StateUpdate` no longer has a `conditional::Bool` field; refinements are represented via the new `StateRefinement` struct (`Compiler/src/abstractinterpretation.jl`).
- Function signatures changed: `smerge`, `schanged`, `stupdate!` all gain `join_pc::Int`, impacting any callers that were reaching into these internals (`Compiler/src/abstractinterpretation.jl`, `Compiler/src/typeinfer.jl`).
- Removed internals: `invalidate_slotwrapper` and `widenwrappedslotwrapper` are deleted; any tooling that referenced them must migrate to `ssadef`/`conditional_valid()`-style staleness checks.
- Removed conversions: `Conditional(::InterConditional)` and `MustAlias(::InterMustAlias)` constructors are gone, so downstream code must construct the new shapes explicitly (including `ssadef`).

## Behavioral differences

- More precise join reasoning at control-flow convergence: when two paths have the same reaching definition (`ssadef` matches), inference can treat the slot contents as identical (`x₀ === x₁`) rather than conservatively forgetting refinements across the join.
- Fewer spurious refinement/alias drops on reassignment: instead of eagerly invalidating `Conditional`/`MustAlias` when a slot is reassigned, inference now detects staleness lazily by rejecting refinements whose `ssadef` no longer matches the reaching definition at that program point.
- Potentially different inferred types and optimization opportunities (and corresponding test expectations) in code with slot reassignments and ϕ-nodes, especially where prior invalidation caused unnecessary widening.