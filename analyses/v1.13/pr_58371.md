# PR #58371: Allow constant propagation of mutables with const fields

**Author:** Gabriel Baraldi (gbaraldi) | **Merged:** 2025-05-22 | **Risk:** medium

This PR loosens the “is it worth constant-propagating this `Const` argument?” heuristic to include certain mutable objects: those whose types declare at least one `const` field. That enables the optimizer to fold away reads of those immutable-in-practice fields, fixing missed optimization for `ScopedValue` constants.

## Changes

```diff
# Compiler/src/abstractlattice.jl:229
 return isa(val, Symbol) || isa(val, Type) || isa(val, Method) || isa(val, CodeInstance) ||
-        !ismutable(val)
+        !ismutable(val) || (typeof(val).name.constfields != C_NULL)
```

```julia
# Compiler/test/irpasses.jl:?
const svalconstprop = ScopedValue(1)
# Compile/optimize `svalconstprop[]` and verify the resulting IR no longer contains:
#   getfield(_, :has_default)
#   getfield(_, :default)
```

## Breaking for downstream tools

IR shape can change for calls where a mutable constant argument has `const` fields (fewer `getfield` nodes, more folded constants), which may require updating IR-based golden tests or pattern-matching passes.

## Behavioral differences

None (semantic). Compiler output and performance can change: constant mutable values with `const` fields (notably `ScopedValue`) can now constant-propagate into callees and eliminate loads of those fields.