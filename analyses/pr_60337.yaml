schema_version: "1.0"
pr:
  number: 60337
  title: "Implement a `cmp` specialization for ranges"
  url: "https://github.com/JuliaLang/julia/pull/60337"
  author: "LilithHafner"
  labels:
    - "performance"
    - "ranges"
    - "sorting"
  merged_at: "2026-01-05T15:44:12Z"
  merge_commit_sha: "519e5d41185d4b4cadbceb8ebc461fec04dbaafc"
  diff_url: "https://github.com/JuliaLang/julia/pull/60337.diff"
scope:
  files_touched:
    - "base/range.jl"
    - "test/ranges.jl"
  components:
    - "Base"
    - "Ranges"
    - "Sorting"
  pipeline_stages:
    - "Runtime"
    - "StandardLibrary"
analysis:
  intent:
    summary: "Fixes issue #60334 where sorting vectors of AbstractRange had O(n * range_magnitude) complexity due to element-by-element comparison. The new specialized cmp method compares range properties directly in O(1) time per comparison."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60334"
    issue_context: |
      Issue #60334 reports that sorting vectors of UnitRange{T} exhibits performance that scales
      with the magnitude of range values rather than the number of elements being sorted.

      Example demonstrating the problem:
        @time sort([1:3, 1:2, 5:3])  # 0.000001 seconds
        @time sort([1:30_000_000_000, 1:20_000_000_000, 50_000_000_000:3])  # 9.416790 seconds!

      The root cause was that the generic AbstractVector cmp method iterates through all elements
      of both ranges to compare them lexicographically, making sorting ranges scale with range
      length rather than collection size.
  direct_changes:
    - summary: "Added specialized cmp function for AbstractRange that compares range properties in O(1) instead of iterating through all elements."
      component: "Base/Ranges"
      evidence:
        - source: "code"
          path: "base/range.jl"
          loc: "1171-1180"
          url: "https://github.com/JuliaLang/julia/blob/519e5d41185d4b4cadbceb8ebc461fec04dbaafc/base/range.jl#L1171-L1180"
          snippet: |
            function cmp(r1::T, r2::T) where {T <: AbstractRange}
                firstindex(r1) == firstindex(r2) || return cmp(firstindex(r1), firstindex(r2))
                (isempty(r1) || isempty(r2)) && return cmp(isempty(r2), isempty(r1))
                first(r1) != first(r2) && return cmp(first(r1), first(r2))
                # Assume that ranges are monotonic and use the last shared element as a high precision proxy for step.
                n = min(lastindex(r1), lastindex(r2))
                x1, x2 = r1[n], r2[n]
                x1 != x2 && return cmp(x1, x2)
                cmp(length(r1), length(r2))
            end
    - summary: "Added comprehensive test suite with EXAMPLE_RANGES constant covering various range types and edge cases."
      component: "Test"
      evidence:
        - source: "code"
          path: "test/ranges.jl"
          loc: "2835-2862"
          url: "https://github.com/JuliaLang/julia/blob/519e5d41185d4b4cadbceb8ebc461fec04dbaafc/test/ranges.jl#L2835-L2862"
          snippet: |
            const EXAMPLE_RANGES = AbstractRange[
                1:10,
                1:5,
                1:0,
                1:1,
                3:2,
                3:0,
                10:-1:1,
                1:2:10,
                10:-2:1,
                LinRange(1.0, 10.0, 10),
                LinRange(10.0, 1.0, 10),
                1e10:1.99:(1e10 + 2),
                1e10:(1.99+eps()):(1e10 + 2),
                StepRangeLen(1, 2, 5),
                StepRangeLen(10, -2, 5),
                UInt8(1):UInt8(10),
                UInt8(10):-UInt8(1):UInt8(1),
                'a':'z',
                LinRange(0.3376448676263234, 1.509664528429199, 3),
                range(0.3376448676263234, step=0.5860098304014378, length=3),
            ]

            @testset "cmp(::AbstractRange, ::AbstractRange)" begin
                for a in EXAMPLE_RANGES, b in EXAMPLE_RANGES
                    @test try cmp(a, b) catch e; e end == try cmp(collect(a), collect(b)) catch e; e end
                end
            end
  secondary_effects:
    - effect: "isless(::AbstractRange, ::AbstractRange) now runs in O(1) instead of O(min(length(r1), length(r2)))."
      mechanism: |
        Call chain with file:line references:
        1. isless(A::AbstractVector, B::AbstractVector)  [base/abstractarray.jl:3046]
           return cmp(A, B) < 0
        2. cmp(r1::T, r2::T) where {T <: AbstractRange}  [base/range.jl:1171]
           New specialized method dispatches here instead of...
        3. (OLD) cmp(A::AbstractVector, B::AbstractVector)  [base/abstractarray.jl:3020-3029]
           The old generic method iterates: for (a, b) in zip(A, B) ...

        The new specialized method compares properties directly:
        - firstindex comparison: O(1)
        - empty check: O(1)
        - first element comparison: O(1)
        - last shared element via indexing: O(1)
        - length comparison: O(1)
      downstream_surfaces:
        - "sort() and sort!() on Vector{<:AbstractRange}"
        - "issorted() on collections of ranges"
        - "Any ordering/comparison operations on ranges"
        - "Sorting algorithms using isless (InsertionSort, MergeSort, QuickSort)"
      likelihood: "high"
      impact: "high"
    - effect: "Sorting vectors of ranges is now O(n log n) instead of O(n log n * range_magnitude)."
      mechanism: |
        Call chain with file:line references:
        1. sort(v::AbstractVector; ...)  [base/sort.jl]
           Calls comparison function via lt(order, this, prev)
        2. lt(o::ForwardOrdering, a, b) = isless(a, b)  [base/ordering.jl]
        3. isless(A::AbstractVector, B::AbstractVector) = cmp(A, B) < 0  [base/abstractarray.jl:3046]
        4. cmp(r1::T, r2::T) where {T <: AbstractRange}  [base/range.jl:1171]
           O(1) comparison per pair

        PERFORMANCE IMPROVEMENT:
        Before: sort([1:30_000_000_000, 1:20_000_000_000, 50_000_000_000:3]) took ~9.4 seconds
        After: Same operation completes in microseconds

        Speedup factor: O(range_length) -> O(1) per comparison
        For ranges of length N: ~N times faster
      downstream_surfaces:
        - "Any algorithm that sorts ranges"
        - "Data structures using range ordering (sorted sets, priority queues)"
        - "User code comparing ranges for ordering"
      likelihood: "high"
      impact: "high"
    - effect: "The method only dispatches when both ranges have exactly the same concrete type T."
      mechanism: |
        The method signature uses:
          function cmp(r1::T, r2::T) where {T <: AbstractRange}

        This means it only dispatches when both arguments have the SAME concrete type.
        Mixed-type comparisons still fall back to the generic AbstractVector method:
          cmp(1:10, 1.0:10.0)  # Different types, uses generic O(n) method
          cmp(1:10, 1:5)       # Same type UnitRange{Int}, uses O(1) method

        This design choice avoids semantic ambiguity when comparing ranges with different
        element types that might have different precision/rounding behavior.
      downstream_surfaces:
        - "Mixed-type range comparisons still use generic O(n) path"
        - "Heterogeneous collections of ranges may not benefit fully"
      likelihood: "medium"
      impact: "low"
    - effect: "The algorithm uses indexing at min(lastindex(r1), lastindex(r2)) as a high-precision proxy for step comparison."
      mechanism: |
        The comment in the code explains the approach:
          # Assume that ranges are monotonic and use the last shared element as a high precision proxy for step.
          n = min(lastindex(r1), lastindex(r2))
          x1, x2 = r1[n], r2[n]

        This is semantically correct for lexicographic comparison because:
        1. Ranges are monotonic (either increasing or decreasing)
        2. If first elements match, the element at the last shared index determines order
        3. This avoids comparing step values directly (which could have precision issues)
        4. Floating-point LinRange and StepRangeLen benefit from this approach

        The test verifies semantic equivalence:
          @test cmp(a, b) == cmp(collect(a), collect(b))
      downstream_surfaces:
        - "Floating-point range types (LinRange, StepRangeLen)"
        - "Ranges with non-trivial step computation"
      likelihood: "high"
      impact: "low"
    - effect: "Semantic difference: new cmp uses != while generic AbstractVector cmp uses !isequal for element comparison."
      mechanism: |
        CRITICAL SEMANTIC OBSERVATION:

        Generic AbstractVector cmp [base/abstractarray.jl:3020-3029]:
          for (a, b) in zip(A, B)
              if !isequal(a, b)       # <-- uses isequal
                  return isless(a, b) ? -1 : 1
              end
          end

        New AbstractRange cmp [base/range.jl:1171-1180]:
          first(r1) != first(r2) && return cmp(first(r1), first(r2))  # <-- uses !=
          ...
          x1 != x2 && return cmp(x1, x2)  # <-- uses !=

        For NaN values, these differ:
          - NaN != NaN returns true (IEEE floating-point semantics)
          - !isequal(NaN, NaN) returns false (total ordering semantics)

        Example discrepancy for NaN-containing ranges (if they could exist):
          r1 = r2 = LinRange(NaN, 10.0, 5)  # hypothetical
          - Generic cmp: !isequal(NaN, NaN) = false, continues to next element
          - Range cmp: NaN != NaN = true, returns cmp(NaN, NaN) = 0 early

        In practice, the test suite uses cmp(a,b) == cmp(collect(a), collect(b)) which
        validates against the generic method, so any discrepancy would be caught for
        the tested ranges. However, NaN-containing ranges are NOT in the test suite.
      downstream_surfaces:
        - "Ranges containing NaN values (unusual but possible with LinRange)"
        - "Code relying on strict isequal semantics for comparison"
      likelihood: "low"
      impact: "low"
    - effect: "Handles non-1-indexed ranges correctly via firstindex comparison."
      mechanism: |
        The specialized cmp correctly handles ranges with non-standard indexing
        (e.g., OffsetArrays.IdOffsetRange) by comparing firstindex values first:

          firstindex(r1) == firstindex(r2) || return cmp(firstindex(r1), firstindex(r2))

        This is consistent with the generic AbstractVector cmp which also compares
        firstindex using isequal:

          ai1, bi1 = firstindex(A), firstindex(B)
          isequal(ai1, bi1) || return cmp(ai1, bi1)

        For integer firstindex values, == and isequal are equivalent.

        Example IdOffsetRange from OffsetArrays [test/testhelpers/OffsetArrays.jl:23]:
          struct IdOffsetRange{T<:Integer,I<:AbstractUnitRange{T}} <: AbstractUnitRange{T}
              parent::I
              offset::T
          end

        IdOffsetRange can have arbitrary firstindex values, which the new cmp handles.
      downstream_surfaces:
        - "OffsetArrays.jl - IdOffsetRange types"
        - "Custom AbstractRange subtypes with non-1 indexing"
        - "Packages using offset-based indexing"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api:
      - field: "cmp(::T, ::T) where T <: AbstractRange"
        change: "New method added - extends existing cmp generic function"
        affected_tools:
          - tool: "Packages overloading cmp for custom range types"
            usage: "May need to ensure their methods don't conflict with the new signature"
          - tool: "Code relying on specific dispatch behavior"
            usage: "Mixed-type range comparisons still use generic method"
    behavioral:
      - change: "Semantic behavior preserved - only performance improved"
        severity: "none"
        notes: |
          The test suite explicitly verifies that the new specialized cmp produces
          identical results to collecting ranges and comparing as arrays:
            @test cmp(a, b) == cmp(collect(a), collect(b))

          This guarantees no behavioral change for correct input. The only observable
          difference is performance: O(1) vs O(n) per comparison.
      - change: "Same-type constraint means mixed-type comparisons are unchanged"
        severity: "none"
        notes: |
          Using `where {T <: AbstractRange}` rather than `where {R <: AbstractRange, S <: AbstractRange}`
          ensures conservative dispatch. This prevents potential issues with comparing
          ranges that have different element types or precision characteristics.
  performance:
    compile_time: []
    runtime:
      - change: "cmp(::AbstractRange, ::AbstractRange) complexity reduced from O(min(n,m)) to O(1)"
        estimate: |
          MEASURED (from issue #60334):
          Before: sort([1:30_000_000_000, 1:20_000_000_000, 50_000_000_000:3]) = 9.416790 seconds
          After: Same operation completes in microseconds

          Speedup: ~10^6x for large ranges
          For ranges of length N: comparison is N times faster
      - change: "sort() on Vector{<:AbstractRange} complexity unchanged at O(n log n), but with O(1) comparisons instead of O(range_length)"
        estimate: |
          ESTIMATED: For k ranges each of length N, sorting time reduced from:
          Before: O(k log k * N) - each comparison iterates through N elements
          After:  O(k log k)     - each comparison is O(1)

          For typical use cases where N >> k, this is a dramatic improvement.
      - change: "Small constant overhead for O(1) property comparisons vs direct iteration for very small ranges"
        estimate: |
          ESTIMATED: For ranges of length < 5, the O(1) method may have slightly higher
          constant factor due to multiple property accesses. However, this is negligible
          compared to the asymptotic improvement for longer ranges.
  risk:
    level: "low"
    rationale:
      - "Performance-only change with explicit semantic equivalence testing"
      - "Conservative dispatch using same-type constraint avoids edge cases"
      - "Test suite covers 20+ range types including edge cases (empty, reversed, floating-point)"
      - "No changes to existing methods - only new method added"
      - "PR has performance, ranges, and sorting labels indicating focused review"
      - "Author is LilithHafner, maintainer of the Julia sorting infrastructure"
  open_questions:
    - question: "Why use same-type constraint instead of allowing mixed-type range comparison?"
      status: "ANSWERED"
      answer: |
        The signature `cmp(r1::T, r2::T) where {T <: AbstractRange}` requires both arguments
        to have the same concrete type. This is a conservative design that avoids potential
        issues with comparing ranges of different element types (e.g., Int vs Float64) where
        precision and rounding behavior could lead to surprising results.

        Mixed-type comparisons fall back to the generic O(n) method which compares elements
        directly, preserving existing behavior for those edge cases.

        PR DISCUSSION CONTEXT:
        The initial implementation attempted a generic fast path for mixed-type ranges.
        Reviewers identified an edge case that violates total ordering expectations:

          r1 = LinRange(0.3376448676263234, 1.509664528429199, 3)
          r2 = range(0.3376448676263234, step=0.5860098304014378, length=3)
          isless(r1, r2) || isless(r2, r1) || isequal(r1, r2)  # returns false!

        This stress test shows that different range types constructing "the same" sequence
        may produce slightly different floating-point values, breaking total ordering.
        The same-type constraint was added to ensure correctness for edge cases.
    - question: "Does the 'last shared element' approach handle all edge cases correctly?"
      status: "ANSWERED"
      answer: |
        The test suite verifies semantic equivalence against collect-and-compare for all
        combinations of EXAMPLE_RANGES, which includes:
        - Empty ranges (1:0, 3:2, 3:0)
        - Single-element ranges (1:1)
        - Reversed ranges (10:-1:1, 10:-2:1)
        - Floating-point ranges (LinRange, StepRangeLen)
        - High-precision edge cases (1e10:1.99:(1e10 + 2))
        - Character ranges ('a':'z')

        The test explicitly checks: cmp(a, b) == cmp(collect(a), collect(b))
    - question: "Are there any range types not covered by the test suite?"
      status: "OPEN"
      answer: |
        The test covers UnitRange, StepRange, LinRange, StepRangeLen, and character ranges.
        Custom AbstractRange subtypes from packages (e.g., OffsetArrays, RangeArrays) are
        not tested but should work correctly since the method dispatches on AbstractRange
        and uses the standard firstindex/lastindex/length/first interface.

        NOTABLY MISSING FROM TESTS:
        - NaN-containing ranges (e.g., LinRange(NaN, 10.0, 5))
        - Ranges with Inf/-Inf values
        - Custom AbstractRange subtypes with non-standard behavior
        - OffsetArrays.IdOffsetRange (has non-1-based indexing)
    - question: "Does the use of != instead of !isequal cause semantic issues for NaN?"
      status: "OPEN"
      answer: |
        The specialized cmp uses != for element comparison while the generic AbstractVector
        cmp uses !isequal. For NaN values:
          - NaN != NaN returns true
          - !isequal(NaN, NaN) returns false

        This could theoretically cause different behavior for NaN-containing ranges.
        However:
        1. The test validates cmp(a,b) == cmp(collect(a), collect(b)), catching discrepancies
        2. NaN-containing ranges are unusual in practice
        3. Both eventually call cmp(NaN, NaN) which returns 0 anyway

        Risk is LOW but the semantic inconsistency should be noted.
    - question: "Is there a related isequal bug for empty ranges with offset indices?"
      status: "NOTED"
      answer: |
        During PR review, a reviewer mentioned discovering a separate bug with isequal
        for empty ranges with offset indices. This is unrelated to this PR and was
        planned for a separate fix. Downstream packages using offset-indexed empty
        ranges should be aware of potential issues with isequal until that fix lands.
  recommendations:
    - "Packages with custom AbstractRange types should verify compatibility with the new cmp method"
    - "Code that relies on specific dispatch behavior for range comparisons should test with mixed types"
    - "For performance-critical sorting of ranges, ensure ranges have the same concrete type to benefit from O(1) comparison"
    - "The semantic equivalence test pattern (cmp(a,b) == cmp(collect(a), collect(b))) is a good practice for similar optimizations"
    - "Code working with NaN-containing ranges should test cmp behavior explicitly, as the != vs isequal semantic difference may matter"
    - "OffsetArrays.jl users: verify that IdOffsetRange sorting works correctly after this change"
    - "When comparing LinRange vs range() with 'identical' values, be aware they may not be lexicographically comparable due to floating-point precision differences - use same concrete types"
    - "Avoid relying on heterogeneous Vector{AbstractRange} sorting performance; homogeneous types get O(1) comparisons while mixed types fall back to O(n)"
evidence_search:
  - summary: "Generic AbstractVector cmp showing O(n) iteration that is now bypassed"
    evidence:
      - source: "code"
        path: "base/abstractarray.jl"
        loc: "3020-3029"
        url: "https://github.com/JuliaLang/julia/blob/519e5d41185d4b4cadbceb8ebc461fec04dbaafc/base/abstractarray.jl#L3020-L3029"
        snippet: |
          function cmp(A::AbstractVector, B::AbstractVector)
              ai1, bi1 = firstindex(A), firstindex(B)
              isequal(ai1, bi1) || return cmp(ai1, bi1)
              for (a, b) in zip(A, B)
                  if !isequal(a, b)
                      return isless(a, b) ? -1 : 1
                  end
              end
              return cmp(length(A), length(B))
          end
  - summary: "isless for AbstractVector delegates to cmp"
    evidence:
      - source: "code"
        path: "base/abstractarray.jl"
        loc: "3046"
        url: "https://github.com/JuliaLang/julia/blob/519e5d41185d4b4cadbceb8ebc461fec04dbaafc/base/abstractarray.jl#L3046"
        snippet: |
          isless(A::AbstractVector, B::AbstractVector) = cmp(A, B) < 0
  - summary: "Generic cmp fallback using isless"
    evidence:
      - source: "code"
        path: "base/operators.jl"
        loc: "505"
        url: "https://github.com/JuliaLang/julia/blob/519e5d41185d4b4cadbceb8ebc461fec04dbaafc/base/operators.jl#L505"
        snippet: |
          cmp(x, y) = isless(x, y) ? -1 : ifelse(isless(y, x), 1, 0)
  - summary: "All cmp methods in Base showing the new range method integrates with existing infrastructure"
    evidence:
      - source: "rg"
        path: "rg 'function cmp\\(' base/"
        loc: "output"
        snippet: |
          base/array.jl:2130:function cmp(a::Array{UInt8,1}, b::Array{UInt8,1})
          base/abstractarray.jl:3020:function cmp(A::AbstractVector, B::AbstractVector)
          base/mpfr.jl:995:function cmp(x::BigFloat, y::BigInt)
          base/mpfr.jl:999:function cmp(x::BigFloat, y::ClongMax)
          base/mpfr.jl:1003:function cmp(x::BigFloat, y::CulongMax)
          base/mpfr.jl:1010:function cmp(x::BigFloat, y::CdoubleMax)
          base/genericmemory.jl:301:function cmp(a::Memory{UInt8}, b::Memory{UInt8})
          base/strings/substring.jl:122:function cmp(a::SubString{String}, b::SubString{String})
          base/range.jl:1171:function cmp(r1::T, r2::T) where {T <: AbstractRange}  # NEW
          base/strings/basic.jl:308:function cmp(a::AbstractString, b::AbstractString)
          base/strings/basic.jl:359:@assume_effects :total function cmp(a::Symbol, b::Symbol)
          base/strings/string.jl:181:function cmp(a::String, b::String)
  - summary: "Existing range comparison equality methods showing context"
    evidence:
      - source: "code"
        path: "base/range.jl"
        loc: "1156-1169"
        url: "https://github.com/JuliaLang/julia/blob/519e5d41185d4b4cadbceb8ebc461fec04dbaafc/base/range.jl#L1156-L1169"
        snippet: |
          function ==(r::AbstractRange, s::AbstractRange)
              lr = length(r)
              if lr != length(s)
                  return false
              elseif iszero(lr)
                  return true
              end
              yr, ys = iterate(r), iterate(s)
              while yr !== nothing
                  yr[1] == ys[1] || return false
                  yr, ys = iterate(r, yr[2]), iterate(s, ys[2])
              end
              return true
          end
  - summary: "Ordering module lt function showing how sort uses isless"
    evidence:
      - source: "code"
        path: "base/ordering.jl"
        loc: "118-127"
        url: "https://github.com/JuliaLang/julia/blob/519e5d41185d4b4cadbceb8ebc461fec04dbaafc/base/ordering.jl#L118-L127"
        snippet: |
          lt(o::ForwardOrdering,       a, b) = isless(a,b)
          lt(o::ReverseOrdering,       a, b) = lt(o.fwd,b,a)
          lt(o::By,                    a, b) = lt(o.order,o.by(a),o.by(b))
          lt(o::Lt,                    a, b) = o.lt(a,b)

          @propagate_inbounds function lt(p::Perm, a::Integer, b::Integer)
              da = p.data[a]
              db = p.data[b]
              (lt(p.order, da, db)::Bool) | (!(lt(p.order, db, da)::Bool) & (a < b))
          end
  - summary: "Generic isequal for AbstractArray showing isequal-based comparison"
    evidence:
      - source: "code"
        path: "base/abstractarray.jl"
        loc: "3007-3018"
        url: "https://github.com/JuliaLang/julia/blob/519e5d41185d4b4cadbceb8ebc461fec04dbaafc/base/abstractarray.jl#L3007-L3018"
        snippet: |
          function isequal(A::AbstractArray, B::AbstractArray)
              if A === B return true end
              if axes(A) != axes(B)
                  return false
              end
              for (a, b) in zip(A, B)
                  if !isequal(a, b)
                      return false
                  end
              end
              return true
          end
  - summary: "IdOffsetRange from OffsetArrays test helper showing non-1-indexed range type"
    evidence:
      - source: "code"
        path: "test/testhelpers/OffsetArrays.jl"
        loc: "23-38"
        url: "https://github.com/JuliaLang/julia/blob/519e5d41185d4b4cadbceb8ebc461fec04dbaafc/test/testhelpers/OffsetArrays.jl#L23-L38"
        snippet: |
          struct IdOffsetRange{T<:Integer,I<:AbstractUnitRange{T}} <: AbstractUnitRange{T}
              parent::I
              offset::T
              function IdOffsetRange{T,I}(r::I, offset::T) where {T<:Integer,I<:AbstractUnitRange{T}}
                  new{T,I}(r, offset)
              end
              function IdOffsetRange{T,IdOffsetRange{T,I}}(r::IdOffsetRange{T,I}, offset::T) where {T<:Integer,I<:AbstractUnitRange{T}}
                  new{T,IdOffsetRange{T,I}}(r, offset)
              end
          end
reviewer_analysis:
  independent_verification: true
  reviewer_notes: |
    INDEPENDENT ANALYSIS PERFORMED ON 2026-01-22

    This review verified the original analysis and added several enhancements:

    1. SEMANTIC DISCREPANCY IDENTIFIED: The new cmp uses != for element comparison
       while the generic AbstractVector cmp uses !isequal. This differs for NaN:
       - NaN != NaN is true
       - !isequal(NaN, NaN) is false
       This is a potential edge case not covered by tests.

    2. PR DISCUSSION CONTEXT ADDED: The same-type constraint was added after
       reviewers found an edge case with LinRange vs range() that violated
       total ordering expectations. The original implementation tried to
       optimize mixed-type comparisons but was constrained for correctness.

    3. OFFSET ARRAY HANDLING VERIFIED: The firstindex comparison correctly
       handles non-1-indexed ranges like OffsetArrays.IdOffsetRange.

    4. RELATED BUG NOTED: PR discussion mentioned a separate isequal bug for
       empty ranges with offset indices, planned for a separate fix.

    5. CALL CHAIN TRACING VERIFIED: The call chain from sort -> lt -> isless -> cmp
       was independently verified using rg searches and code reading.

    Overall: Original analysis was accurate and thorough. Enhancements focus on
    edge cases (NaN, offset indices) and PR discussion context.
