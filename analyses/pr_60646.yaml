schema_version: "1.0"
pr:
  number: 60646
  title: "[JuliaLowering] Avoid analyzing variables 'owned' by outer closures"
  url: "https://github.com/JuliaLang/julia/pull/60646"
  author: "topolarity"
  labels:
    - "JuliaLowering"
  merged_at: "2026-01-12T21:47:03Z"
  merge_commit_sha: "65eade52d8cabc43d1f8be4a9f7781b6e66eed7e"
  diff_url: "https://github.com/JuliaLang/julia/pull/60646.diff"
scope:
  files_touched:
    - "JuliaLowering/src/binding_analysis.jl"
    - "JuliaLowering/test/closures.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Lowering"
analysis:
  intent:
    summary: "Skip def-use analysis for variables owned by outer lambda; prevent incorrect unboxing of inner-lambda captures."
    issue_links:
      - "https://github.com/JuliaLang/JuliaLowering.jl/issues/134#issuecomment-3739626003"
  direct_changes:
    - summary: "Filter def-use candidates to exclude outer-lambda locals; analyze only owned, captured, single-assigned locals."
      component: "JuliaLowering/src/binding_analysis.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/binding_analysis.jl"
          loc: "65-84"
          url: "https://github.com/JuliaLang/julia/blob/65eade52d8cabc43d1f8be4a9f7781b6e66eed7e/JuliaLowering/src/binding_analysis.jl#L65-L84"
          snippet: |
            function _analyze_lambda_vars!(ctx, ex)
                lambda_bindings = ex.lambda_bindings

                # Collect candidate variables: captured and single-assigned
                candidates = Set{IdTag}()
                for (id, from_outer_lambda) in lambda_bindings.locals_capt
                    binfo = get_binding(ctx, id)
                    maybe_boxed = binfo.is_captured && binfo.kind in (:local, :argument)
                    safe_to_analyze = binfo.is_assigned_once
                    if !from_outer_lambda && maybe_boxed && safe_to_analyze
                        push!(candidates, id)
                        # For arguments, reset is_always_defined so we can determine if the
                        # outer-scope assignment dominates the capture. Arguments start with
                        # is_always_defined=true, but if they're reassigned inside a closure
                        # (not in outer scope), we need the def-use analysis to decide.
                        if binfo.kind == :argument
                            binfo.is_always_defined = false
                        end
                    end
                end
    - summary: "Add regression test: outer local mutated in inner closure stays boxed and updates correctly."
      component: "JuliaLowering/test/closures.jl"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/closures.jl"
          loc: "475-489"
          url: "https://github.com/JuliaLang/julia/blob/65eade52d8cabc43d1f8be4a9f7781b6e66eed7e/JuliaLowering/test/closures.jl#L475-L489"
          snippet: |
            JuliaLowering.include_string(test_mod, """
            function f_update_outer_capture()
                local response # declare outside closure
                f = ()->begin
                    response = 1
                end
                f()
                return (f, response)
            end
            """)
            let (f, response) = test_mod.f_update_outer_capture()
                @test f.response isa Core.Box
                @test response == 1
            end
  secondary_effects:
    - effect: "Outer-scope locals that are only captured by inner lambdas are no longer reclassified as 'always defined' by def-use analysis, so they remain boxed in closure conversion."
      mechanism: |
        analyze_def_and_use!(ctx, ex)  [binding_analysis.jl:39-52]
          -> _analyze_lambda_vars!(ctx, ex)  [binding_analysis.jl:65-85]
             skips locals_capt entries where from_outer_lambda=true
          -> is_boxed(binfo)  [closure_conversion.jl:304-318]
             uses is_always_defined && is_assigned_once to suppress boxing
          -> closure_type_fields(...)  [closure_conversion.jl:235-283]
             field_is_box = is_boxed(ctx, id) for captured variables
      downstream_surfaces:
        - "Closure field layout (boxed vs unboxed captures)"
        - "OpaqueClosure capture representation"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "BindingInfo.is_always_defined"
        change: "Flags for outer-scope captured locals are no longer recalculated by _analyze_lambda_vars!, so tooling that inspects binding flags will see fewer 'always defined' captures for those cases."
        affected_tools:
          - tool: "JET"
            usage: "JET inspects BindingInfo flags when rendering closure capture diagnostics in its inference error reports."
          - tool: "IRTools"
            usage: "IRTools examines closure field layouts derived from boxing decisions when reflecting on lowered code."
    behavioral:
      - change: "Captures of outer-scope locals mutated inside an inner closure remain boxed; regressions are covered by the new f_update_outer_capture test."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/closures.jl"
            loc: "475-489"
            url: "https://github.com/JuliaLang/julia/blob/65eade52d8cabc43d1f8be4a9f7781b6e66eed7e/JuliaLowering/test/closures.jl#L475-L489"
            snippet: |
              let (f, response) = test_mod.f_update_outer_capture()
                  @test f.response isa Core.Box
                  @test response == 1
              end
  performance:
    compile_time:
      - impact: "ESTIMATED: negligible; candidate filtering is a constant-time predicate on existing locals_capt entries."
    runtime:
      - impact: "ESTIMATED: slight increase in boxing (allocations) for the corrected outer-capture case, offset by correctness."
  risk:
    level: "low"
    rationale:
      - "Change is localized to candidate selection in binding analysis and adds a targeted regression test."
  open_questions:
    - "Should LambdaBindings.locals_capt or the is_captured naming be clarified to distinguish 'captured by inner' from 'defined in outer' (as hinted in the PR description)?"
  recommendations:
    - "Downstream tooling that assumes unboxed captures for single-assigned locals should account for outer-scope captures remaining boxed in this pattern."
