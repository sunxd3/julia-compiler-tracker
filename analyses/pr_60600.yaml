schema_version: "1.0"
pr:
  number: 60600
  title: "[JuliaLowering] Avoid creating global binding for keyword slurp argument"
  url: "https://github.com/JuliaLang/julia/pull/60600"
  author: "aviatesk"
  labels:
    - "JuliaLowering"
  merged_at: "2026-01-12T13:06:26Z"
  merge_commit_sha: "64d451869ff2fdb5964e4e327fb170d6a82ee296"
  diff_url: "https://github.com/JuliaLang/julia/pull/60600.diff"
scope:
  files_touched:
    - "JuliaLowering/src/desugaring.jl"
    - "JuliaLowering/test/functions.jl"
    - "JuliaLowering/test/functions_ir.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Lowering"
analysis:
  intent:
    summary: "Exclude keyword slurp names from kwcall value bindings when defaults depend on other keyword names, preventing accidental global binding and extra kwcall arguments."
    issue_links: []
  direct_changes:
    - summary: "When not using SSA keyword temps, kw_val_vars is now built without the slurp keyword so remaining keywords are only passed via remaining_kws."
      component: "JuliaLowering desugaring"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "2808-2817"
          url: "https://github.com/JuliaLang/julia/blob/64d451869ff2fdb5964e4e327fb170d6a82ee296/JuliaLowering/src/desugaring.jl#L2808-L2817"
          snippet: |
            # Use kw_names directly as the values, but exclude slurp if present
            # because slurp is passed via remaining_kws
            if has_kw_slurp
                kw_val_vars = SyntaxList(ctx)
                for i in 1:length(kw_names)-1
                    push!(kw_val_vars, kw_names[i])
                end
            else
                kw_val_vars = kw_names
            end
        - source: "code"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "2857-2864"
          url: "https://github.com/JuliaLang/julia/blob/64d451869ff2fdb5964e4e327fb170d6a82ee296/JuliaLowering/src/desugaring.jl#L2857-L2864"
          snippet: |
            [K"call"
                body_func_name
                kw_val_vars...
                if has_kw_slurp
                    remaining_kws
                end
                positional_forwarding_args...
            ]
    - summary: "Adds runtime and IR tests covering keyword slurping with defaults depending on keyword names."
      component: "JuliaLowering tests"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/functions.jl"
          loc: "433-440"
          url: "https://github.com/JuliaLang/julia/blob/64d451869ff2fdb5964e4e327fb170d6a82ee296/JuliaLowering/test/functions.jl#L433-L440"
          snippet: |
            # Slurping with defaults depending on keyword names
            JuliaLowering.include_string(test_mod, """
            function f_kw_slurp_dep(; a=1, b=a, kws...)
                (a, b, length(kws))
            end
            """)
            @test test_mod.f_kw_slurp_dep(; a=1) == (1, 1, 0)
            @test test_mod.f_kw_slurp_dep(; a=2, c=3) == (2, 2, 1)
        - source: "test"
          path: "JuliaLowering/test/functions_ir.jl"
          loc: "1369-1451"
          url: "https://github.com/JuliaLang/julia/blob/64d451869ff2fdb5964e4e327fb170d6a82ee296/JuliaLowering/test/functions_ir.jl#L1369-L1451"
          snippet: |
            ########################################
            # Keyword slurping with defaults depending on keyword names
            # This tests the case where use_ssa_kw_temps=false because a keyword default
            # depends on another keyword name. The slurp argument should not be included
            # in kw_val_vars to avoid creating an unwanted global binding.
            function f_kw_slurp_dep(; a=1, b=a, kws...)
                (a, b, kws)
            end
            #---------------------
            1   (method TestMod.f_kw_slurp_dep)
            2   latestworld
            3   (method TestMod.#f_kw_slurp_dep#0)
            4   latestworld
            5   TestMod.#f_kw_slurp_dep#0
            6   (call core.Typeof %₅)
            7   (call top.pairs core.NamedTuple)
            8   TestMod.f_kw_slurp_dep
            9   (call core.Typeof %₈)
            10  (call core.svec %₆ core.Any core.Any %₇ %₉)
            11  (call core.svec)
            12  SourceLocation::1:10
            13  (call core.svec %₁₀ %₁₁ %₁₂)
            14  --- method core.nothing %₁₃
                slots: [slot₁/#self#(!read) slot₂/a slot₃/b slot₄/kws slot₅/#self#]
                1   (meta :nkw 3)
                2   (call core.tuple slot₂/a slot₃/b slot₄/kws)
                3   (return %₂)
            15  latestworld
            16  (call core.typeof core.kwcall)
            17  TestMod.f_kw_slurp_dep
            18  (call core.Typeof %₁₇)
            19  (call core.svec %₁₆ core.NamedTuple %₁₈)
            20  (call core.svec)
            21  SourceLocation::1:10
            22  (call core.svec %₁₉ %₂₀ %₂₁)
            23  --- method core.nothing %₂₂
                # kwcall method - key fix: no global kws reference, correct argument count
                slots: [slot₁/#self#(!read) slot₂/kws slot₃/#self# slot₄/kwtmp slot₅/a(single_assign) slot₆/b(single_assign)]
                1   (call core.isdefined slot₂/kws :a)
                2   (gotoifnot %₁ label₆)
                3   (call core.getfield slot₂/kws :a)
                4   (= slot₄/kwtmp %₃)
                5   (goto label₇)
                6   (= slot₄/kwtmp 1)
                7   slot₄/kwtmp
                8   (= slot₅/a %₇)
                9   (call core.isdefined slot₂/kws :b)
                10  (gotoifnot %₉ label₁₄)
                11  (call core.getfield slot₂/kws :b)
                12  (= slot₄/kwtmp %₁₁)
                13  (goto label₁₆)
                14  slot₅/a
                15  (= slot₄/kwtmp %₁₄)
                16  slot₄/kwtmp
                17  (= slot₆/b %₁₆)
                18  (call core.tuple :a :b)
                19  (call core.apply_type core.NamedTuple %₁₈)
                20  (call top.structdiff slot₂/kws %₁₉)
                21  (call top.pairs %₂₀)
                22  TestMod.#f_kw_slurp_dep#0
                # Fixed: (call %₂₂ slot₅/a slot₆/b %₂₁ slot₃/#self#) - no extra kws argument
                23  (call %₂₂ slot₅/a slot₆/b %₂₁ slot₃/#self#)
                24  (return %₂₃)
            24  latestworld
            25  TestMod.f_kw_slurp_dep
            26  (call core.Typeof %₂₅)
            27  (call core.svec %₂₆)
            28  (call core.svec)
            29  SourceLocation::1:10
            30  (call core.svec %₂₇ %₂₈ %₂₉)
            31  --- method core.nothing %₃₀
                slots: [slot₁/#self# slot₂/a(single_assign) slot₃/b(single_assign) slot₄/kws(single_assign)]
                1   1
                2   (= slot₂/a %₁)
                3   slot₂/a
                4   (= slot₃/b %₃)
                5   (call core.NamedTuple)
                6   (call top.pairs %₅)
                7   (= slot₄/kws %₆)
                8   TestMod.#f_kw_slurp_dep#0
                9   (call %₈ slot₂/a slot₃/b slot₄/kws slot₁/#self#)
                10  (return %₉)
            32  latestworld
            33  TestMod.f_kw_slurp_dep
            34  (return %₃₃)
  secondary_effects:
    - effect: "Keyword slurp defaults no longer introduce an unbound identifier/global binding in the kwcall path, and the body method call no longer receives an extra argument."
      mechanism: |
        expand_function_def(ctx, ex, ...)  [desugaring.jl:2945]
          -> keyword_function_defs(ctx, ...)  [desugaring.jl:3185]
          -> use_ssa_kw_temps=false when defaults_depend_on_kw_names  [desugaring.jl:2793]
          -> kw_val_vars computed without slurp when has_kw_slurp=true  [desugaring.jl:2808-2817]
          -> kwcall_body_tail builds body call with kw_val_vars..., remaining_kws, positional args  [desugaring.jl:2857-2864]
          -> scope_nest(...) supplies kw_values for keyword names only (excluding slurp)  [desugaring.jl:2872-2873]
      downstream_surfaces:
        - "Lowered IR for kwcall methods (CodeInfo/IR used by tooling that inspects keyword lowering)"
        - "Static analysis reporting of undefined globals in lowered kwcall IR"
        - "JETLS (JET Language Server) undefined global variable analysis"
      likelihood: "high"
      impact: "medium"
    - effect: "JETLS no longer reports false positive undefined global variable warnings for keyword slurp functions with dependent defaults."
      mechanism: |
        Before fix: kw_val_vars included slurp name as unbound Identifier
          -> scope analysis resolved it as global binding (e.g., Main.kws)
          -> JETLS flagged undefined global variable warning
        After fix: kw_val_vars excludes slurp when has_kw_slurp=true
          -> remaining keywords passed only via remaining_kws (from structdiff/pairs)
          -> no spurious global binding reference in lowered IR
      downstream_surfaces:
        - tool: "JETLS"
          usage: "JETLS performs static analysis on lowered IR to detect undefined global variables"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api: []
    behavioral:
      - change: "Keyword slurping with defaults depending on other keyword names now produces kwcall IR that omits the slurp identifier and avoids passing an extra argument."
        evidence:
          - source: "pr_description"
            path: "PR body"
            loc: "N/A"
            url: "https://github.com/JuliaLang/julia/pull/60600"
            snippet: |
              # Before/after IR comparison from PR for f(; a=1, b=a, kws...) = (a, b, kws)
              # Before (buggy):
              22  TestMod.#f#0
              23  slot₅/a
              24  slot₆/b
              25  Main.kws                                    # unwanted global
              26  (call %₂₂ %₂₃ %₂₄ %₂₅ %₂₁ slot₃/#self#)    # extra argument

              # After (fixed):
              22  TestMod.#f#0
              23  slot₅/a
              24  slot₆/b
              25  (call %₂₂ %₂₃ %₂₄ %₂₁ slot₃/#self#)        # correct - no global, no extra arg
          - source: "test"
            path: "JuliaLowering/test/functions_ir.jl"
            loc: "1369-1451"
            url: "https://github.com/JuliaLang/julia/blob/64d451869ff2fdb5964e4e327fb170d6a82ee296/JuliaLowering/test/functions_ir.jl#L1369-L1451"
            snippet: |
              # IR annotated: kwcall path omits any global slurp identifier
              slots: [slot₁/#self#(!read) slot₂/kws slot₃/#self# slot₄/kwtmp slot₅/a(single_assign) slot₆/b(single_assign)]
              18  (call core.tuple :a :b)
              19  (call core.apply_type core.NamedTuple %₁₈)
              20  (call top.structdiff slot₂/kws %₁₉)
              21  (call top.pairs %₂₀)
              22  TestMod.#f_kw_slurp_dep#0
              # Fixed call: no Main.kws global, passes remaining_kws from %₂₁ (pairs result)
              23  (call %₂₂ slot₅/a slot₆/b %₂₁ slot₃/#self#)
  performance:
    compile_time: []
    runtime: []
  risk:
    level: "low"
    rationale:
      - "Change is localized to JuliaLowering keyword desugaring and guarded by has_kw_slurp + use_ssa_kw_temps=false paths."
      - "New tests cover both runtime behavior and IR structure for the affected case."
  open_questions: []
  recommendations:
    - "If downstream tools rely on kwcall IR argument counts, ensure they match the updated kwcall body signature for keyword slurps with dependent defaults."
    - "JETLS and other static analysis tools that flag undefined globals will now produce correct results for keyword slurp functions with dependent defaults."
