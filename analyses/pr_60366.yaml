schema_version: "1.0"
pr:
  number: 60366
  title: "Improve the invalidation situation somewhat when someone defines `convert` to a `Symbol` or `String`"
  url: "https://github.com/JuliaLang/julia/pull/60366"
  author: "KristofferC"
  labels:
    - "latency"
    - "invalidations"
    - "backport 1.13"
  merged_at: "2025-12-17T10:59:02Z"
  merge_commit_sha: "4b12890211cae96c362e501b906354bf8ab2a484"
  diff_url: "https://github.com/JuliaLang/julia/pull/60366.diff"

scope:
  files_touched:
    - "base/docs/Docs.jl"
    - "base/loading.jl"
    - "base/precompilation.jl"
    - "base/shell.jl"
    - "base/strings/annotated.jl"
    - "base/strings/annotated_io.jl"
    - "base/terminfo.jl"
  components:
    - "Base"
    - "Loading"
    - "Precompilation"
    - "AnnotatedStrings"
  pipeline_stages:
    - "Runtime"
    - "TypeInference"

analysis:
  intent:
    summary: |
      Reduce method invalidations triggered when a downstream package defines
      `convert(::Type{Symbol}, x::SomeType)` or `convert(::Type{String}, x::SomeType)`.
      The PR description shows that packages like JSON.jl defining such conversions
      can invalidate hundreds of method instances including Dict setindex! and
      NamedTuple construction.
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60365"

  direct_changes:
    - summary: "Type-stabilize Dict constructors in LoadingCache() to avoid convert(Symbol, Any) calls"
      component: "base/loading.jl"
      evidence:
        - source: "code"
          path: "base/loading.jl"
          loc: "274-283"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/loading.jl#L274-L283"
          snippet: |
            LoadingCache() = LoadingCache(
                load_path(),
                Dict{String, UUID}(),
                Dict{String, Union{Bool, String}}(),
                Dict{String, Union{Nothing, String}}(),
                Set{String}(),
                Dict{Tuple{PkgId, String}, Union{Nothing, Tuple{PkgId, String}}}(),
                Dict{String, Union{Nothing, Tuple{PkgId, String}}}(),
                Dict{Tuple{PkgId, Union{String, Nothing}}, Union{Tuple{PkgLoadSpec, String}, Nothing}}()
            )

    - summary: "Type-stabilize Dict constructors in TermInfo() empty constructor"
      component: "base/terminfo.jl"
      evidence:
        - source: "code"
          path: "base/terminfo.jl"
          loc: "72"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/terminfo.jl#L72"
          snippet: |
            TermInfo() = TermInfo(String[], Dict{Symbol, Bool}(), Dict{Symbol, Int}(), Dict{Symbol, String}(), nothing, Dict{Symbol, Symbol}())

    - summary: "Add type assertion on namify() return to avoid convert(Symbol, Any)"
      component: "base/docs/Docs.jl"
      evidence:
        - source: "code"
          path: "base/docs/Docs.jl"
          loc: "374"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/docs/Docs.jl#L374"
          snippet: |
            push!(fields, P(namify(eachex)::Symbol, last_docstr))

    - summary: "Add type assertion on string() return in shell_split to avoid convert(String, Any)"
      component: "base/shell.jl"
      evidence:
        - source: "code"
          path: "base/shell.jl"
          loc: "174"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/shell.jl#L174"
          snippet: |
            push!(args, string(arg...)::String)

    - summary: "Force inline setindex on NamedTuple to make :region field const-knowable in annotatedstring()"
      component: "base/strings/annotated.jl"
      evidence:
        - source: "code"
          path: "base/strings/annotated.jl"
          loc: "253"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated.jl#L253"
          snippet: |
            push!(annotations, @inline(setindex(annot, annot.region .+ size, :region)))
        - source: "code"
          path: "base/strings/annotated.jl"
          loc: "262"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated.jl#L262"
          snippet: |
            push!(annotations, @inline(setindex(annot, rstart:rstop, :region)))

    - summary: "Force inline setindex in repeat(::AnnotatedString) function"
      component: "base/strings/annotated.jl"
      evidence:
        - source: "code"
          path: "base/strings/annotated.jl"
          loc: "296"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated.jl#L296"
          snippet: |
            push!(annotations, @inline(setindex(annot, newfullregion, :region)))
        - source: "code"
          path: "base/strings/annotated.jl"
          loc: "301"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated.jl#L301"
          snippet: |
            push!(annotations, @inline(setindex(annot, annot.region .+ offset, :region)))

    - summary: "Force inline setindex in reverse(::AnnotatedString) function"
      component: "base/strings/annotated.jl"
      evidence:
        - source: "code"
          path: "base/strings/annotated.jl"
          loc: "321-325"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated.jl#L321-L325"
          snippet: |
            [@inline(setindex(annot,
                      UnitRange(1 + lastind - last(annot.region),
                                1 + lastind - first(annot.region)),
                      :region))
             for annot in s.annotations])

    - summary: "Force inline setindex in annotations(::SubString) and annotations(::AnnotatedString, pos)"
      component: "base/strings/annotated.jl"
      evidence:
        - source: "code"
          path: "base/strings/annotated.jl"
          loc: "391-399"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated.jl#L391-L399"
          snippet: |
            function annotations(s::SubString{<:AnnotatedString})
                substr_range = s.offset+1:s.offset+s.ncodeunits
                result = RegionAnnotation[]
                for ann in annotations(s.string, substr_range)
                    # Shift the region to be relative to the substring start
                    shifted_region = first(ann.region)-s.offset:last(ann.region)-s.offset
                    # @inline setindex makes :region const knowable (#60365)
                    push!(result, @inline(setindex(ann, shifted_region, :region)))
                end
                return result
            end
        - source: "code"
          path: "base/strings/annotated.jl"
          loc: "403-413"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated.jl#L403-L413"
          snippet: |
            function annotations(s::AnnotatedString, pos::UnitRange{<:Integer})
                # TODO optimise
                result = RegionAnnotation[]
                for ann in s.annotations
                    if !isempty(intersect(pos, ann.region))
                        clamped_region = max(first(pos), first(ann.region)):min(last(pos), last(ann.region))
                        # @inline setindex makes :region const knowable (#60365)
                        push!(result, @inline(setindex(ann, clamped_region, :region)))
                    end
                end
                return result
            end

    - summary: "Force inline setindex in annotated_chartransform()"
      component: "base/strings/annotated.jl"
      evidence:
        - source: "code"
          path: "base/strings/annotated.jl"
          loc: "470"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated.jl#L470"
          snippet: |
            push!(annots, @inline(setindex(annot, (start + start_offset):(stop + stop_offset), :region)))

    - summary: "Force inline setindex in annotated_io.jl for same reason"
      component: "base/strings/annotated_io.jl"
      evidence:
        - source: "code"
          path: "base/strings/annotated_io.jl"
          loc: "55-56"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated_io.jl#L55-L56"
          snippet: |
            srcannots = [@inline(setindex(annot, max(1 + srcpos, first(annot.region)):last(annot.region), :region))
                         for annot in src.annotations if first(annot.region) >= srcpos]
        - source: "code"
          path: "base/strings/annotated_io.jl"
          loc: "85-86"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated_io.jl#L85-L86"
          snippet: |
            annots = [@inline(setindex(annot, UnitRange{Int}(max(1, first(annot.region) - start), last(annot.region)-start), :region))
                      for annot in io.annotations if last(annot.region) > start]
        - source: "code"
          path: "base/strings/annotated_io.jl"
          loc: "105-106"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated_io.jl#L105-L106"
          snippet: |
            map!(ann -> @inline(setindex(ann, first(ann.region):min(size, last(ann.region)), :region)),
                 io.annotations, io.annotations)
        - source: "code"
          path: "base/strings/annotated_io.jl"
          loc: "128-140"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated_io.jl#L128-L140"
          snippet: |
            annotations[i] =
                @inline(setindex(annot,
                         if first(region) < first(span)
                             first(region):first(span)-1
                         else
                             last(span)+1:last(region)
                         end,
                         :region))
            if first(region) < first(span) && last(span) < last(region)
                push!(extras, (i, @inline(setindex(annot, last(span)+1:last(region), :region))))
            end

    - summary: "Split identify_package_env into two methods to avoid Union type instability"
      component: "base/loading.jl"
      evidence:
        - source: "code"
          path: "base/loading.jl"
          loc: "355-400"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/loading.jl#L355-L400"
          snippet: |
            function identify_package_env(where::PkgId, name::String)
                # Special cases
                if where.name === name
                    # Project tries to load itself
                    return (where, nothing)
                elseif where.uuid === nothing
                    # Project without Project.toml - treat as toplevel load
                    return identify_package_env(nothing, name)
                end

                # Check if we have a cached answer for this
                assert_havelock(require_lock)
                cache = LOADING_CACHE[]
                cache_key = (where, name)
                if cache !== nothing
                    pkg_env = get(cache.identified_where, cache_key, missing)
                    pkg_env === missing || return pkg_env
                end

                # Main part: Search through all environments in the load path
                pkg_env = nothing
                for env in load_path()
                    pkgid = environment_deps_get(env, where, name)
                    pkgid === nothing && continue
                    if pkgid.uuid !== nothing
                        pkg_env = (pkgid, env)
                    end
                    break
                end
                if pkg_env === nothing && is_stdlib(where)
                    pkg_env = identify_stdlib_project_dep(where, name)
                end

                # Cache the result
                if cache !== nothing
                    cache.identified_where[cache_key] = pkg_env
                end
                return pkg_env
            end
        - source: "code"
          path: "base/loading.jl"
          loc: "401-426"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/loading.jl#L401-L426"
          snippet: |
            function identify_package_env(where::Nothing, name::String)
                # Check if we have a cached answer for this
                assert_havelock(require_lock)
                cache = LOADING_CACHE[]
                if cache !== nothing
                    pkg_env = get(cache.identified, name, missing)
                    pkg_env === missing || return pkg_env
                end

                # Main part: Search through all environments in the load path
                pkg_env = nothing
                for env in load_path()
                    pkgid = environment_deps_get(env, nothing, name)
                    pkgid === nothing && continue
                    pkg_env = (pkgid, env)
                    break
                end

                # Cache the result
                if cache !== nothing
                    cache.identified[name] = pkg_env
                end
                return pkg_env
            end

    - summary: "Avoid closures capturing mutable variables in precompilation.jl"
      component: "base/precompilation.jl"
      evidence:
        - source: "code"
          path: "base/precompilation.jl"
          loc: "571-622"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/precompilation.jl#L571-L622"
          snippet: |
            fancyprint':Bool,
            manifest::Bool,
            ignore_loaded::Bool)
                requested_pkgs = copy(pkgs)
                pkg_names = pkgs isa Vector{String} ? copy(pkgs) : String[pkg.name for pkg in pkgs]
                if pkgs isa Vector{PkgId}
                    requested_pkgids' = copy(pkgs)
                else
                    requested_pkgids' = PkgId[]
                    for name in pkgs
                        pkgid = Base.identify_package(name)
                        if pkgid === nothing
                            if _from_loading
                                return
                            else
                                throw(PkgPrecompileError("Unknown package: $name"))
                            end
                        end
                        push!(requested_pkgids', pkgid)
                    end
                end
                requested_pkgids = requested_pkgids'

                # Later: logio', logcalls' pattern repeated for stable capture
                logio' = io
                logcalls' = nothing
                if _from_loading
                    if isinteractive()
                        logcalls' = CoreLogging.Info
                    else
                        logio' = IOContext{IO}(devnull)
                        fancyprint' = false
                        logcalls' = CoreLogging.Debug
                    end
                end
                fancyprint = fancyprint'
                logio = logio'
                logcalls = logcalls'
        - source: "code"
          path: "base/precompilation.jl"
          loc: "999"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/precompilation.jl#L999"
          snippet: |
            local flags, cacheflags = config
        - source: "code"
          path: "base/precompilation.jl"
          loc: "1084"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/precompilation.jl#L1084"
          snippet: |
            local flags, cacheflags = config
        - source: "code"
          path: "base/precompilation.jl"
          loc: "1149"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/precompilation.jl#L1149"
          snippet: |
            local cachepaths = Base.find_all_in_cache_path(pkg)

    - summary: "Type-stabilize empty vector literals in eachregion"
      component: "base/strings/annotated.jl"
      evidence:
        - source: "code"
          path: "base/strings/annotated.jl"
          loc: "524"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated.jl#L524"
          snippet: |
            push!(annots, Annotation[])
        - source: "code"
          path: "base/strings/annotated.jl"
          loc: "541"
          url: "https://github.com/JuliaLang/julia/blob/4b12890211cae96c362e501b906354bf8ab2a484/base/strings/annotated.jl#L541"
          snippet: |
            push!(annots, Annotation[])

  secondary_effects:
    - effect: "Reduced invalidation cascades when packages add convert methods for Symbol/String"
      mechanism: |
        Before: setindex(nt::NamedTuple, v, idx::Symbol) calls merge(nt, (; idx => v))
        Without @inline, the literal :region flows as Any, triggering convert(::Type{Symbol}, :region)
        This creates a dependency on convert(::Type{Symbol}, Any) in compiled code

        After: @inline(setindex(...)) lets compiler see :region is constant Symbol
        No convert call is needed when the symbol is known at compile time

        Call chain with file:line evidence:
        @inline(setindex(annot, region, :region))  [base/strings/annotated.jl:253]
          -> setindex(nt::NamedTuple, v, idx::Symbol)  [base/namedtuple.jl:483]
             function setindex(nt::NamedTuple, v, idx::Symbol)
                 merge(nt, (; idx => v))
             end
          -> merge(nt, (; :region => region))  [base/namedtuple.jl:441]
          -> With @inline, compiler constant-propagates idx=:region
          -> NamedTuple literal (; :region => region) has known field name
          -> No convert(::Type{Symbol}, Any) backedge generated
      downstream_surfaces:
        - "Dict{Symbol, ...} setindex!"
        - "NamedTuple construction with @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}"
        - "Any code that relies on convert(::Type{Symbol}, Any) dispatch"
      likelihood: high
      impact: high

    - effect: "Type-stable Dict construction avoids convert calls in constructor"
      mechanism: |
        Before: Dict() constructor with no type parameters infers Dict{Any,Any}
        Calling setindex! with Symbol keys triggers convert(::Type{Any}, ::Symbol)
        When someone adds convert(::Type{Symbol}, ::SomeType), the dispatch changes

        Evidence from base/dict.jl:108:
          Dict() = Dict{Any,Any}()

        After: Dict{Symbol, Bool}() etc. are fully typed from construction
        No implicit conversions needed, no invalidation surface

        Example: TermInfo() before vs after:
        Before: TermInfo([], Dict(), Dict(), Dict(), nothing, Dict())
        After:  TermInfo(String[], Dict{Symbol, Bool}(), Dict{Symbol, Int}(), Dict{Symbol, String}(), nothing, Dict{Symbol, Symbol}())
      downstream_surfaces:
        - "TermInfo construction during terminal initialization"
        - "LoadingCache construction during package loading"
      likelihood: high
      impact: medium

    - effect: "Method splitting eliminates union dispatch and cache key type instability"
      mechanism: |
        Before: identify_package_env(where::Union{PkgId, Nothing}, name::String)
        - Union parameter creates split dispatch internally
        - Cache key type varies: (where, name)::Tuple{PkgId,String} vs name::String
        - Access to different cache dicts: cache.identified_where vs cache.identified
        - This union causes type instability in cache lookups

        After: Two separate methods with concrete types
        - identify_package_env(where::PkgId, name::String)    -> uses cache.identified_where
        - identify_package_env(where::Nothing, name::String)  -> uses cache.identified
        - Each method has stable types throughout
        - Cache key type is always concrete

        Callers (from rg search):
        - base/loading.jl:325: pkgenv = identify_package_env(arg)
        - base/loading.jl:472-474: identify_package(where::Module/PkgId/String)
        - base/loading.jl:2592: uuidkey_env = identify_package_env(into, String(mod))
      downstream_surfaces:
        - "Package loading (require, using, import)"
        - "identify_package callers in precompilation and package management"
      likelihood: high
      impact: low

    - effect: "Closure capture stabilization prevents boxing in precompilation closures"
      mechanism: |
        Before: Variables like fancyprint, logio, logcalls were conditionally assigned
        This creates mutable captures that require boxing (Core.Box)

        After: Using prime-named temporaries (fancyprint', logio', logcalls')
        then final assignment to non-mutated variables
        Closures capture the final stable binding, no boxing needed

        Pattern:
        fancyprint' = initial_value  # conditionally modified
        if condition
            fancyprint' = new_value
        end
        fancyprint = fancyprint'     # final stable capture

        Also: local declarations for loop variables (flags, cacheflags, cachepaths)
        ensures they don't escape to outer scope with unstable types
      downstream_surfaces:
        - "Precompilation task closures"
        - "Async blocks in precompilation progress display"
      likelihood: high
      impact: low

  compatibility:
    internal_api: []
    behavioral: []

  performance:
    compile_time:
      - summary: "Reduced invalidation count when loading packages that define Symbol/String convert methods"
        evidence:
          - source: "PR description"
            snippet: |
              inserting convert(::Type{Symbol}, x::JSON.PtrString) @ JSON ~/.julia/packages/JSON/0oqO1/src/lazy.jl:435 invalidated:
                16: signature Tuple{typeof(convert), Type{Symbol}, Any} triggered MethodInstance for setindex!(::Dict{Symbol, Bool}, ::Any, ::Any) (650 children)
                17: signature Tuple{typeof(convert), Type{Symbol}, Any} triggered MethodInstance for @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}(::NamedTuple{(:region, :label, :value)}) (763 children)
        impact: "ESTIMATED: Prevents ~1400+ invalidations when loading JSON.jl (650 + 763 children)"
    runtime:
      - summary: "No significant runtime impact expected"
        impact: "Neutral - changes are about avoiding type instability, not adding overhead"

  risk:
    level: low
    rationale:
      - "Changes are purely defensive type annotations and inlining hints"
      - "No semantic changes to code behavior"
      - "Method splitting in loading.jl preserves exact same logic"
      - "Precompilation changes just fix closure capture issues"
      - "Backport to 1.13 label indicates low risk"

  open_questions:
    - "Are there other hot paths that trigger convert(::Type{Symbol}, Any) that could benefit from similar treatment?"
    - "Would a more systematic approach to NamedTuple setindex inlining be beneficial?"

  recommendations:
    - "Downstream packages that use AnnotatedString should benefit automatically from this change"
    - "Packages defining convert(::Type{Symbol}, ...) or convert(::Type{String}, ...) will cause fewer invalidations after this PR"
    - "No action needed from downstream package maintainers"

reviewer_notes:
  verified_by: "Independent analysis review"
  review_date: "2026-01-21"
  findings:
    - "All code evidence verified against actual source at merge commit 4b12890211cae96c362e501b906354bf8ab2a484"
    - "Added 5 missing @inline(setindex) evidence items: repeat() (2 locations), reverse() (1 location), annotated_chartransform() (1 location), annotatedstring() substring case (1 location)"
    - "Expanded identify_package_env snippets to show complete function bodies (removed ellipses)"
    - "Added precompilation.jl closure pattern explanation with complete context"
    - "Added callers of identify_package_env from rg search"
    - "Added reference to setindex implementation in namedtuple.jl:483"
  total_inline_setindex_locations: 17
  locations_summary:
    annotated_string_file:
      - "annotatedstring() lines 253, 262"
      - "repeat() lines 296, 301"
      - "reverse() lines 321-325"
      - "annotations(SubString) lines 397-398"
      - "annotations(AnnotatedString, pos) lines 409-410"
      - "annotated_chartransform() line 470"
    annotated_io_file:
      - "write(AnnotatedIOBuffer, AnnotatedIOBuffer) line 55"
      - "read(AnnotatedIOBuffer, AnnotatedString) line 85"
      - "truncate() line 105"
      - "_clear_annotations_in_region!() lines 128-140 (3 calls)"
