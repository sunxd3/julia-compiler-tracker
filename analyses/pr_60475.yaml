schema_version: "1.0"
pr:
  number: 60475
  title: "Add `@stm` \"SyntaxTree match\" macro"
  url: "https://github.com/JuliaLang/julia/pull/60475"
  author: "mlechu"
  labels:
    - "JuliaLowering"
  merged_at: "2026-01-11T00:09:41Z"
  merge_commit_sha: "a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a"
  diff_url: "https://github.com/JuliaLang/julia/pull/60475.diff"
scope:
  files_touched:
    - "JuliaSyntax/src/porcelain/syntax_graph.jl"
    - "JuliaSyntax/test/syntax_graph.jl"
  components:
    - "JuliaSyntax"
  pipeline_stages:
    - "Parsing"
analysis:
  intent:
    summary: "Introduce a SyntaxTree pattern-matching macro (@stm) with optional debug tracing and usage checking, plus comprehensive tests."
    issue_links:
      - "https://github.com/JuliaLang/JuliaLowering.jl/pull/93"
  direct_changes:
    - summary: "Add @stm/@stm_debug macros plus a matcher/validator pipeline that builds nested conditionals, validates patterns, matches tree kinds/child counts, and binds pattern variables."
      component: "JuliaSyntax porcelain utilities"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
          loc: "811-1002"
          url: "https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax/src/porcelain/syntax_graph.jl#L811-L1002"
          snippet: |
            macro stm(st, pats)
                _stm(__source__, st, pats; debug=false)
            end

            "Like `@stm`, but prints a trace during matching."
            macro stm_debug(st, pats)
                _stm(__source__, st, pats; debug=true)
            end

            function _stm(line::LineNumberNode, st, pats; debug=false)
                _stm_check_usage(pats)
                st_gs, result_gs, k_gs, nc_gs = gensym.("st", "result", "k", "nc")
                out_blk = Expr(:let, Expr(:block, :($st_gs = $st::SyntaxTree),
                                          :($result_gs = nothing),
                                          :($k_gs = $kind($st_gs)),
                                          :($nc_gs = $numchildren($st_gs))),
                               Expr(:if, false, nothing))
                case_list_tail = out_blk.args[2].args
                for pcr in pats.args
                    pcr isa LineNumberNode && (line = pcr; continue)
                    p, cond, result = _stm_destruct_pat(pcr)
                    pat_ok = p isa Symbol ? true : _stm_matches(p, st_gs, k_gs, nc_gs, debug)
                    case = Expr(:elseif,
                                Expr(:&&, pat_ok,
                                     Expr(:let, _stm_assigns(p, st_gs),
                                          Expr(:&&, cond,
                                               Expr(:block, line,
                                                    :($result_gs = $result), true)))),
                                result_gs)
                    push!(case_list_tail, case)
                    case_list_tail = case_list_tail[3].args
                end
                push!(case_list_tail,
                      :(throw(ErrorException(string(
                          "No match found for `", $st_gs, "` at ", $(string(line)))))))
                return esc(out_blk)
            end

            function _stm_matches(p::Expr, st_gs::Symbol, k_gs::Symbol, nc_gs::Symbol, debug)
                pat_k = Kind(p.args[1].args[3])
                out = Expr(:&&, :($pat_k === $k_gs))
                debug && push!(out.args, Expr(:block, :(printstyled(
                    string("[kind]: ", $k_gs, "\n"); color=:yellow)), true))
                p_args = p.args[2:end]
                dots_i = findfirst(x->Meta.isexpr(x, :(...)), p_args)
                dots_start = something(dots_i, length(p_args) + 1)
                n_after_dots = length(p_args) - dots_start # -1 if no dots
                push!(out.args, isnothing(dots_i) ?
                    :($nc_gs === $(length(p_args))) :
                    :($nc_gs >= $(length(p_args) - 1)))
                debug && push!(out.args, Expr(:block, :(printstyled(
                    string("[numc]: ", $nc_gs, "\n"); color=:yellow)), true))
                for i in 1:dots_start-1
                    p_args[i] isa Symbol && continue
                    push!(out.args,
                          _stm_matches_wrapper(p_args[i], :($st_gs[$i]), debug))
                end
                for i in n_after_dots-1:-1:0
                    p_args[end-i] isa Symbol && continue
                    push!(out.args,
                          _stm_matches_wrapper(p_args[end-i], :($st_gs[end-$i]), debug))
                end
                debug && push!(out.args, Expr(:block, :(printstyled(
                    string("matched: ", $st_gs, " with ", $(QuoteNode(p)), "\n");
                    color=:green)), true))
                return out
            end

            function _stm_check_usage(pats::Expr)
                function _stm_check_pattern(p; syms=Set{Symbol}())
                    if Meta.isexpr(p, :(...), 1)
                        p = p.args[1]
                        @assert(p isa Symbol, "Expected symbol before `...` in $p")
                    end
                    if p isa Symbol
                        dup = p in syms && p !== :_
                        push!(syms, p)
                        @assert(!dup, "invalid duplicate non-underscore identifier $p")
                        return nothing
                    elseif Meta.isexpr(p, :vect)
                        @assert(length(p.args) === 1,
                                "use spaces, not commas, in @stm []-patterns")
                    elseif Meta.isexpr(p, :hcat)
                        @assert(length(p.args) >= 2)
                    elseif Meta.isexpr(p, :vcat)
                        p = _stm_vcat_to_hcat(p)
                        @assert(length(p.args) >= 2)
                    else
                        @assert(false, "malformed pattern $p")
                    end
                    @assert(count(x->Meta.isexpr(x, :(...)), p.args[2:end]) <= 1,
                            "Multiple `...` in a pattern is ambiguous")
                    @assert(Meta.isexpr(p.args[1], :macrocall, 3) &&
                        p.args[1].args[1] === Symbol("@K_str") &&
                        p.args[1].args[3] isa String, "first pattern elt must be K\"\"")
                    for subp in p.args[2:end]
                        _stm_check_pattern(subp; syms)
                    end
                end

                @assert Meta.isexpr(pats, :block) "Usage: @stm st begin; ...; end"
                for pcr in filter(e->!isa(e, LineNumberNode), pats.args)
                    @assert(Meta.isexpr(pcr, :(->), 2), "Expected pat -> res, got malformed case: $pcr")
                    if Meta.isexpr(pcr.args[1], :tuple)
                        @assert(length(pcr.args[1].args) === 2,
                                "Expected `pat` or `(pat, when=cond)`")
                        p = pcr.args[1].args[1]
                        c = pcr.args[1].args[2]
                        @assert(Meta.isexpr(c, :(=), 2) && c.args[1] === :when,
                                "Expected `(when=cond)` in tuple pattern, got $(c)")
                    else
                        p = pcr.args[1]
                    end
                    _stm_check_pattern(p)
                end
            end
    - summary: "Add tests covering matching success/failure, nested patterns, splat binding, `when=` guards, and side effects in the guard clause."
      component: "JuliaSyntax tests"
      evidence:
        - source: "tests"
          path: "JuliaSyntax/test/syntax_graph.jl"
          loc: "104-314"
          url: "https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax/test/syntax_graph.jl#L104-L314"
          snippet: |
            @testset "@stm SyntaxTree pattern-matching" begin
                st = parsestmt(SyntaxTree, "foo(a,b=1,c(d=2))")
                # (call foo a (kw b 1) (call c (kw d 2)))

                @testset "basic functionality" begin
                    @test @stm st begin
                        _ -> true
                    end

                    @test @stm st begin
                        x -> x isa SyntaxTree
                    end

                    @test @stm st begin
                        [K"function" f a b c] -> false
                        [K"call" f a b c] -> true
                    end
                end

                @testset "errors" begin
                    @test_throws ErrorException @stm st begin
                        [K"Identifier"] -> false
                    end
                end

                @testset "SyntaxList splat matching" begin
                    @test @stm st begin
                        [K"call" f args...] -> args isa SyntaxList && length(args) === 3
                    end
                end

                @testset "`when` clauses affect matching" begin
                    @test @stm st begin
                        (_, when=false) -> false
                        (_, when=true) -> true
                    end
                end

                @testset "effects of when=cond" begin
                    let x = Int[]
                        @test @stm st begin
                            (_, when=(push!(x, 1); true)) -> x == [1]
                        end
                    end
                end
            end
    - summary: "Call-site search indicates @stm is only referenced in JuliaSyntax tests and definition in this PR; not yet adopted in JuliaLowering."
      component: "JuliaSyntax usage survey"
      evidence:
        - source: "rg"
          path: "JuliaSyntax/test/syntax_graph.jl"
          loc: "1"
          url: "https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax/test/syntax_graph.jl#L1"
          snippet: |
            using .JuliaSyntax: SyntaxGraph, SyntaxTree, SyntaxList, freeze_attrs, unfreeze_attrs, ensure_attributes, ensure_attributes!, delete_attributes, copy_ast, attrdefs, @stm
        - source: "rg"
          path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
          loc: "811-818"
          url: "https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax/src/porcelain/syntax_graph.jl#L811-L818"
          snippet: |
            macro stm(st, pats)
                _stm(__source__, st, pats; debug=false)
            end

            "Like `@stm`, but prints a trace during matching."
            macro stm_debug(st, pats)
                _stm(__source__, st, pats; debug=true)
            end
  secondary_effects:
    - effect: "Pattern matching emits runtime `kind`/`numchildren` checks and recursive descent, so using @stm in lowering or analysis code adds a per-branch walk over the SyntaxTree and (optionally) debug printing."
      mechanism: |
        _stm(line, st, pats) [syntax_graph.jl:823]
          builds :if/:elseif chain with pattern guard
          -> _stm_matches(p, st_gs, k_gs, nc_gs, debug) [syntax_graph.jl:889]
             checks kind/child count and recurses into child SyntaxTree access
          -> debug=true inserts printstyled("[kind]") and printstyled("[numc]") blocks
      downstream_surfaces:
        - "JuliaLowering pattern-matching helpers"
        - "AST tooling that processes JuliaSyntax.SyntaxTree"
      likelihood: "medium"
      impact: "low"
    - effect: "Macro expansion time includes a full syntactic validation of patterns and variable uniqueness, which can surface assertion errors during macroexpand for invalid patterns."
      mechanism: |
        _stm(line, st, pats) calls _stm_check_usage(pats) [syntax_graph.jl:823-1002]
          -> _stm_check_pattern enforces K"kind" forms, single `...`, and no duplicate symbols
          -> @assert failures throw AssertionError at macro expansion
      downstream_surfaces:
        - "Packages that use @stm in generated code or macros"
      likelihood: "high"
      impact: "low"
  compatibility:
    internal_api:
      - field: "JuliaSyntax.@stm (new macro)"
        change: "Adds a new internal macro for SyntaxTree matching; not publicly exported, requires explicit import via `using JuliaSyntax: @stm` or qualified access `JuliaSyntax.@stm`. No existing API removed."
        affected_tools:
          - tool: "JuliaSyntax consumers"
            usage: "Can adopt @stm for tree matching via explicit import; existing code unchanged."
          - tool: "JuliaLowering"
            usage: "Intended primary consumer (see PR description); can use @stm for cleaner lowering code."
    behavioral:
      - change: "@stm throws ErrorException when no pattern matches; malformed patterns throw AssertionError during macro expansion."
        evidence:
          - source: "tests"
            path: "JuliaSyntax/test/syntax_graph.jl"
            loc: "141-179"
            url: "https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax/test/syntax_graph.jl#L141-L179"
            snippet: |
              @testset "errors" begin
                  # no match
                  @test_throws ErrorException @stm st begin
                      [K"Identifier"] -> false
                  end

                  @testset "_stm_check_usage" begin
                      bad = Expr[
                          :(@stm st begin
                                [a] -> false
                            end)
                          :(@stm st begin
                                [K"None",a] -> false
                            end)
                      ]
                      for e in bad
                          Base.remove_linenums!(e)
                          @testset "$(string(e))" begin
                          @test_throws AssertionError macroexpand(@__MODULE__, e)
                          end
                      end
                  end
              end
  performance:
    compile_time:
      - impact: "ESTIMATED: O(p) pattern validation and expansion per @stm, where p = number of pattern nodes; dominates macro expansion for large pattern blocks."
        evidence:
          - source: "code"
            path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
            loc: "823-1002"
            url: "https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax/src/porcelain/syntax_graph.jl#L823-L1002"
            snippet: |
              function _stm(line::LineNumberNode, st, pats; debug=false)
                  _stm_check_usage(pats)
                  st_gs, result_gs, k_gs, nc_gs = gensym.("st", "result", "k", "nc")
                  out_blk = Expr(:let, Expr(:block, :($st_gs = $st::SyntaxTree),
                                            :($result_gs = nothing),
                                            :($k_gs = $kind($st_gs)),
                                            :($nc_gs = $numchildren($st_gs))),
                                 Expr(:if, false, nothing))
                  case_list_tail = out_blk.args[2].args
                  for pcr in pats.args
                      pcr isa LineNumberNode && (line = pcr; continue)
                      p, cond, result = _stm_destruct_pat(pcr)
                      pat_ok = p isa Symbol ? true : _stm_matches(p, st_gs, k_gs, nc_gs, debug)
                      case = Expr(:elseif,
                                  Expr(:&&, pat_ok,
                                       Expr(:let, _stm_assigns(p, st_gs),
                                            Expr(:&&, cond,
                                                 Expr(:block, line,
                                                      :($result_gs = $result), true)))),
                                  result_gs)
                      push!(case_list_tail, case)
                      case_list_tail = case_list_tail[3].args
                  end
                  push!(case_list_tail,
                        :(throw(ErrorException(string(
                            "No match found for `", $st_gs, "` at ", $(string(line)))))))
                  return esc(out_blk)
              end
    runtime:
      - impact: "ESTIMATED: O(n) checks per pattern branch with recursion into child SyntaxTrees; debug mode adds I/O from printstyled." 
        evidence:
          - source: "code"
            path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
            loc: "889-919"
            url: "https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax/src/porcelain/syntax_graph.jl#L889-L919"
            snippet: |
              function _stm_matches(p::Expr, st_gs::Symbol, k_gs::Symbol, nc_gs::Symbol, debug)
                  pat_k = Kind(p.args[1].args[3])
                  out = Expr(:&&, :($pat_k === $k_gs))
                  debug && push!(out.args, Expr(:block, :(printstyled(
                      string("[kind]: ", $k_gs, "\n"); color=:yellow)), true))
                  p_args = p.args[2:end]
                  dots_i = findfirst(x->Meta.isexpr(x, :(...)), p_args)
                  dots_start = something(dots_i, length(p_args) + 1)
                  n_after_dots = length(p_args) - dots_start # -1 if no dots
                  push!(out.args, isnothing(dots_i) ?
                      :($nc_gs === $(length(p_args))) :
                      :($nc_gs >= $(length(p_args) - 1)))
                  debug && push!(out.args, Expr(:block, :(printstyled(
                      string("[numc]: ", $nc_gs, "\n"); color=:yellow)), true))
                  for i in 1:dots_start-1
                      p_args[i] isa Symbol && continue
                      push!(out.args,
                            _stm_matches_wrapper(p_args[i], :($st_gs[$i]), debug))
                  end
                  for i in n_after_dots-1:-1:0
                      p_args[end-i] isa Symbol && continue
                      push!(out.args,
                            _stm_matches_wrapper(p_args[end-i], :($st_gs[end-$i]), debug))
                  end
                  debug && push!(out.args, Expr(:block, :(printstyled(
                      string("matched: ", $st_gs, " with ", $(QuoteNode(p)), "\n");
                      color=:green)), true))
                  return out
              end
  risk:
    level: "low"
    rationale:
      - "Purely additive API in JuliaSyntax with no changes to existing parsing or lowering paths."
      - "Behavior only changes for code that opts into @stm; tests cover success/failure and guard semantics."
  open_questions: []
  recommendations:
    - "Downstream tooling that currently hand-matches SyntaxTree nodes could adopt @stm for clearer matching, but should be aware of its guard evaluation order and ErrorException behavior when no match is found."
