schema_version: "1.0"
pr:
  number: 60619
  title: "[JuliaLowering] Fix-up handling of `stmt_offset` in `K\"enter\"`"
  url: "https://github.com/JuliaLang/julia/pull/60619"
  author: "topolarity"
  labels:
    - "JuliaLowering"
  merged_at: "2026-01-09T21:55:02Z"
  merge_commit_sha: "e61a047e1c108ff555ee93cea27f7c5c1781484a"
  diff_url: "https://github.com/JuliaLang/julia/pull/60619.diff"
scope:
  files_touched:
    - "JuliaLowering/src/eval.jl"
    - "JuliaLowering/test/exceptions.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Lowering"
    - "CodeInfo"
analysis:
  intent:
    summary: "Fix one-line bug where K\"enter\" nodes were not adding stmt_offset to catch labels, causing try/catch blocks to silently bypass exception handlers when @nospecialize arguments are present."
    issue_links:
      - "https://github.com/JuliaLang/JuliaLowering.jl/issues/135"
  direct_changes:
    - summary: "Add stmt_offset to catch_idx when translating K\"enter\" nodes to Core.EnterNode, matching the behavior of K\"goto\" and K\"gotoifnot\" which already included the offset."
      component: "JuliaLowering/src/eval.jl"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/eval.jl"
          loc: "386"
          url: "https://github.com/JuliaLang/julia/blob/e61a047e1c108ff555ee93cea27f7c5c1781484a/JuliaLowering/src/eval.jl#L386"
          snippet: |
            # BEFORE (bug):
            catch_idx = ex[1].id
            # AFTER (fix):
            catch_idx = ex[1].id + stmt_offset
        - source: "code"
          path: "JuliaLowering/src/eval.jl"
          loc: "381-389"
          url: "https://github.com/JuliaLang/julia/blob/e61a047e1c108ff555ee93cea27f7c5c1781484a/JuliaLowering/src/eval.jl#L381-L389"
          snippet: |
            elseif k == K"goto"
                Core.GotoNode(ex[1].id + stmt_offset)
            elseif k == K"gotoifnot"
                Core.GotoIfNot(_to_lowered_expr(ex[1], stmt_offset), ex[2].id + stmt_offset)
            elseif k == K"enter"
                catch_idx = ex[1].id + stmt_offset
                numchildren(ex) == 1 ?
                    Core.EnterNode(catch_idx) :
                    Core.EnterNode(catch_idx, _to_lowered_expr(ex[2], stmt_offset))
        - source: "code"
          path: "JuliaLowering/src/eval.jl"
          loc: "246-256"
          url: "https://github.com/JuliaLang/julia/blob/e61a047e1c108ff555ee93cea27f7c5c1781484a/JuliaLowering/src/eval.jl#L246-L256"
          snippet: |
            if slot.is_nospecialize
                # Ideally this should be a slot flag instead
                add_ir_debug_info!(current_codelocs_stack, ex)
                push!(stmts, Expr(:meta, :nospecialize, Core.SlotNumber(i)))
            end

            stmt_offset = length(stmts)
            for stmt in children(ex)
                push!(stmts, _to_lowered_expr(stmt, stmt_offset))
                add_ir_debug_info!(current_codelocs_stack, stmt)
            end
    - summary: "Add regression test: try/catch with @nospecialize argument validates correct exception handling under JuliaLowering include_string."
      component: "JuliaLowering/test/exceptions.jl"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/exceptions.jl"
          loc: "338-353"
          url: "https://github.com/JuliaLang/julia/blob/e61a047e1c108ff555ee93cea27f7c5c1781484a/JuliaLowering/test/exceptions.jl#L338-L353"
          snippet: |
            @test JuliaLowering.include_string(test_mod, """
            begin
                function f_try_catch_nospecialize(@nospecialize(cond))
                    try
                        cond && throw(ArgumentError(""))
                    catch
                        return 1
                    end
                    return 2
                end
                (
                    f_try_catch_nospecialize(true),
                    f_try_catch_nospecialize(false),
                )
            end
            """) == (1,2)
  secondary_effects:
    - effect: "EnterNode catch targets now correctly point to the catch block statement when extra :meta statements (e.g., @nospecialize) are prepended before user code. Previously, the wrong catch_idx caused exceptions to bypass catch blocks entirely."
      mechanism: |
        BUG TRIGGER PATH:
        1. to_code_info(ex, slots, meta)  [eval.jl:220-257]
           - For each slot with is_nospecialize=true, pushes Expr(:meta, :nospecialize, SlotNumber(i))
           - This makes stmts non-empty BEFORE user code
           - stmt_offset = length(stmts) becomes non-zero (e.g., 1 for one @nospecialize arg)

        2. _to_lowered_expr(ex, stmt_offset)  [eval.jl:330-389]
           - K"goto" correctly used: ex[1].id + stmt_offset
           - K"gotoifnot" correctly used: ex[2].id + stmt_offset
           - K"enter" INCORRECTLY used: ex[1].id (missing + stmt_offset) <- BUG

        FAILURE MODE (before fix):
        - With @nospecialize, stmt_offset=1, but EnterNode got catch_idx=N instead of N+1
        - EnterNode pointed to statement BEFORE the actual catch block
        - When exception thrown, runtime jumped to wrong statement
        - Catch block was never executed; exception silently swallowed or wrong behavior

        FIX:
        - catch_idx = ex[1].id + stmt_offset  [eval.jl:386]
        - Now consistent with K"goto" and K"gotoifnot" offset handling
      downstream_surfaces:
        - "JuliaLowering include_string() evaluation paths"
        - "JuliaLowering-based REPL (enabled by this fix)"
        - "Any JuliaLowering-compiled function with @nospecialize args and try/catch"
      likelihood: "high"
      impact: "high"
  compatibility:
    internal_api: []
    behavioral:
      - change: "BUGFIX: Functions with @nospecialize arguments and try/catch blocks now correctly catch exceptions instead of silently bypassing catch handlers."
        evidence:
          - source: "issue"
            path: "JuliaLowering.jl#135"
            loc: "N/A"
            url: "https://github.com/JuliaLang/JuliaLowering.jl/issues/135"
            snippet: |
              # Reported behavior before fix:
              # Expected: function should print "catch" then throw
              # Actual: function printed "noerror" - catch block was bypassed entirely
              # The exception was silently swallowed due to wrong EnterNode catch target
          - source: "test"
            path: "JuliaLowering/test/exceptions.jl"
            loc: "338-353"
            url: "https://github.com/JuliaLang/julia/blob/e61a047e1c108ff555ee93cea27f7c5c1781484a/JuliaLowering/test/exceptions.jl#L338-L353"
            snippet: |
              # Test validates fix: @nospecialize + try/catch now works correctly
              # f_try_catch_nospecialize(true) returns 1 (catch path)
              # f_try_catch_nospecialize(false) returns 2 (no-throw path)
              @test JuliaLowering.include_string(test_mod, """
              begin
                  function f_try_catch_nospecialize(@nospecialize(cond))
                      try
                          cond && throw(ArgumentError(""))
                      catch
                          return 1
                      end
                      return 2
                  end
                  (f_try_catch_nospecialize(true), f_try_catch_nospecialize(false))
              end
              """) == (1,2)
  performance:
    compile_time:
      - impact: "No compile-time impact; change is a single integer addition during IR translation (ESTIMATED: O(1) per K\"enter\" node)."
    runtime:
      - impact: "No runtime impact; EnterNode catch_dest is computed at compile time. Runtime behavior unchanged except that catch blocks now execute correctly (ESTIMATED)."
  risk:
    level: "low"
    rationale:
      - "One-line surgical fix: adds + stmt_offset to match existing pattern used by K\"goto\" and K\"gotoifnot\"."
      - "No structural changes to IR representation or control flow handling."
      - "Regression test added to prevent future breakage."
      - "Fix is isolated to JuliaLowering code path; does not affect Base lowering."
  open_questions: []
  recommendations:
    - "Consider adding a unit test that directly inspects Core.EnterNode.catch_dest values in generated CodeInfo to detect offset bugs earlier."
    - "The PR description notes 'REPL is functional under JuliaLowering' - this was a blocking bug for JuliaLowering REPL adoption."
