schema_version: "1.0"
pr:
  number: 60013
  title: "signals: Implement fake_stack_pop for Linux on x86_64 and i686"
  url: "https://github.com/JuliaLang/julia/pull/60013"
  author: "vtjnash"
  labels:
    - "bugfix"
  merged_at: "2025-12-06T19:33:23Z"
  merge_commit_sha: "a934511542a269f20b697a5fc81dc28c3907d1fd"
  diff_url: "https://github.com/JuliaLang/julia/pull/60013.diff"

scope:
  files_touched:
    - "src/julia_threads.h"
    - "src/signals-mach.c"
    - "src/signals-unix.c"
  components:
    - "Runtime"
    - "SignalHandling"
  pipeline_stages:
    - "Runtime"
    - "Debugging"

analysis:
  intent:
    summary: |
      This PR improves stack unwinding in debuggers when analyzing core dumps from signals
      like SIGQUIT on Linux/BSD platforms. It implements a `jl_fake_signal_return` function
      with proper DWARF Call Frame Information (CFI) directives that help unwinders locate
      saved register values on the manipulated stack. Previously, only macOS had this
      capability; now Linux (x86_64, i686, aarch64), FreeBSD, and OpenBSD are supported.
    issue_links: []

  direct_changes:
    - summary: "Add signal context fields to jl_tls_states_t for stack unwinding"
      component: "julia_threads.h"
      evidence:
        - source: "code"
          path: "src/julia_threads.h"
          loc: "190-196"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/julia_threads.h#L190-L196"
          snippet: |
            #if defined(_OS_LINUX_) || defined(_OS_FREEBSD_) || defined(_OS_OPENBSD_)
                // Saved context from jl_call_in_ctx for stack unwinding
                uintptr_t signal_ctx_pc;
                uintptr_t signal_ctx_sp;
                void (*signal_ctx_fptr)(void);
                uintptr_t signal_ctx_arg;
            #endif

    - summary: "Implement jl_fake_signal_return for Linux x86_64 with CFI directives"
      component: "signals-unix.c"
      evidence:
        - source: "code"
          path: "src/signals-unix.c"
          loc: "77-102"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/signals-unix.c#L77-L102"
          snippet: |
            #if (defined(_OS_LINUX_) || defined(_OS_FREEBSD_) || defined(_OS_OPENBSD_)) && defined(_CPU_X86_64_)
            __asm__(
                "  .type jl_fake_signal_return, @function\n"
                "jl_fake_signal_return:\n"
                "  .cfi_startproc\n"
                "  .cfi_signal_frame\n"
                // Mark as end of stack until frame is set up
                "  .cfi_undefined %rip\n"
                "  .cfi_undefined %rsp\n"
                // rdi points to signal_ctx_pc in ptls (followed by signal_ctx_sp, signal_ctx_fptr, signal_ctx_arg)
                "  pushq (%rdi)\n"        // push pc (signal_ctx_pc)
                "  pushq 8(%rdi)\n"       // push sp (signal_ctx_sp)
                // stack layout: [sp, pc] (pc at higher address, like return address after call)
                "  .cfi_def_cfa %rsp, 8\n"
                "  .cfi_offset %rip, 0\n"  // previous %rip at CFA+0 (pc slot at rsp+8)
                "  .cfi_offset %rsp, -8\n" // previous %rsp at CFA-8 (sp slot at rsp+0)
                "  pushq 16(%rdi)\n"      // push fptr (signal_ctx_fptr)
                "  .cfi_def_cfa %rsp, 16\n"
                "  movq 24(%rdi), %rdi\n" // restore original rdi from signal_ctx_arg
                "  subq $8, %rsp\n"       // align stack to 16 bytes
                "  .cfi_def_cfa %rsp, 24\n"
                "  callq *8(%rsp)\n"      // call fptr
                "  ud2\n"                 // unreachable
                "  .cfi_endproc\n"
                "  .size jl_fake_signal_return, .-jl_fake_signal_return\n"
            );

    - summary: "Implement jl_fake_signal_return for Linux i686 with CFI directives"
      component: "signals-unix.c"
      evidence:
        - source: "code"
          path: "src/signals-unix.c"
          loc: "104-128"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/signals-unix.c#L104-L128"
          snippet: |
            #elif (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && defined(_CPU_X86_)
            __asm__(
                "  .type jl_fake_signal_return, @function\n"
                "jl_fake_signal_return:\n"
                "  .cfi_startproc\n"
                "  .cfi_signal_frame\n"
                // Mark as end of stack until frame is set up
                "  .cfi_undefined 1\n"
                // eax points to signal_ctx_pc in ptls (followed by signal_ctx_sp, signal_ctx_fptr, signal_ctx_arg)
                "  pushl (%eax)\n"        // push pc (signal_ctx_pc)
                "  pushl 4(%eax)\n"       // push sp (signal_ctx_sp)
                // stack layout: [sp, pc] (pc at higher address, like return address after call)
                "  .cfi_def_cfa %esp, 4\n"
                "  .cfi_offset %eip, 0\n"  // previous %eip at CFA+0 (pc slot at esp+4)
                "  .cfi_offset %esp, -4\n" // previous %esp at CFA-4 (sp slot at esp+0)
                "  pushl 8(%eax)\n"       // push fptr (signal_ctx_fptr)
                "  .cfi_def_cfa %esp, 8\n"
                "  movl 12(%eax), %eax\n" // restore original eax from signal_ctx_arg
                "  subl $4, %esp\n"       // align stack to 16 bytes
                "  .cfi_def_cfa %esp, 12\n"
                "  calll *4(%esp)\n"      // call fptr
                "  ud2\n"                 // unreachable
                "  .cfi_endproc\n"
                "  .size jl_fake_signal_return, .-jl_fake_signal_return\n"
            );

    - summary: "Implement jl_fake_signal_return for Linux aarch64 with CFI directives"
      component: "signals-unix.c"
      evidence:
        - source: "code"
          path: "src/signals-unix.c"
          loc: "129-153"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/signals-unix.c#L129-L153"
          snippet: |
            #elif (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && defined(_CPU_AARCH64_)
            __asm__(
                "  .type jl_fake_signal_return, @function\n"
                "jl_fake_signal_return:\n"
                "  .cfi_startproc\n"
                "  .cfi_signal_frame\n"
                // Mark as end of stack until frame is set up
                "  .cfi_undefined 1\n"
                // x0 points to signal_ctx_pc in ptls (followed by signal_ctx_sp, signal_ctx_fptr, signal_ctx_arg)
                "  ldp x1, x2, [x0]\n"      // load pc (x1) and sp (x2)
                "  stp x2, x1, [sp, #-16]!\n" // push sp and pc (sp at lower addr, pc at higher addr)
                // stack layout: [sp, pc] (pc at higher address, like return address after call)
                "  .cfi_def_cfa sp, 16\n"
                "  .cfi_offset lr, -8\n"   // previous lr (pc) at CFA-8 (pc slot at sp+8)
                "  .cfi_offset sp, -16\n"  // previous sp at CFA-16 (sp slot at sp+0)
                // This is not quite valid, since the AArch64 DWARF spec lacks the ability to define how to restore the LR register correctly,
                // so normally libunwind implementations on linux detect this function specially and hack around the invalid info:
                // https://github.com/llvm/llvm-project/commit/c82deed6764cbc63966374baf9721331901ca958
                "  ldp x1, x2, [x0, #16]\n" // load fptr (x1) and saved x0 (x2)
                "  mov x0, x2\n"           // restore original x0
                "  blr x1\n"               // call fptr
                "  brk #1\n"               // unreachable
                "  .cfi_endproc\n"
                "  .size jl_fake_signal_return, .-jl_fake_signal_return\n"
            );

    - summary: "Provide fallback jl_fake_signal_return for unsupported platforms (ARM, RISCV)"
      component: "signals-unix.c"
      evidence:
        - source: "code"
          path: "src/signals-unix.c"
          loc: "154-160"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/signals-unix.c#L154-L160"
          snippet: |
            #else
            extern void JL_NORETURN jl_fake_signal_return(void)
            {
                CFI_NORETURN
                abort();
            }
            #endif

    - summary: "Update jl_call_in_ctx to save context in ptls and call jl_fake_signal_return"
      component: "signals-unix.c"
      evidence:
        - source: "code"
          path: "src/signals-unix.c"
          loc: "216-225"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/signals-unix.c#L216-L225"
          snippet: |
            #if defined(_OS_LINUX_) && defined(_CPU_X86_64_)
                ucontext_t *ctx = (ucontext_t*)_ctx;
                // Save context in ptls for stack unwinding
                ptls->signal_ctx_pc = ctx->uc_mcontext.gregs[REG_RIP];
                ptls->signal_ctx_sp = ctx->uc_mcontext.gregs[REG_RSP];
                ptls->signal_ctx_fptr = fptr;
                ptls->signal_ctx_arg = ctx->uc_mcontext.gregs[REG_RDI];
                ctx->uc_mcontext.gregs[REG_RSP] = rsp; // set stack pointer
                ctx->uc_mcontext.gregs[REG_RDI] = (uintptr_t)&ptls->signal_ctx_pc; // first arg points to signal_ctx
                ctx->uc_mcontext.gregs[REG_RIP] = (uintptr_t)&jl_fake_signal_return; // "call" jl_fake_signal_return

    - summary: "ARM and RISCV64 do NOT use jl_fake_signal_return (no CFI support)"
      component: "signals-unix.c"
      evidence:
        - source: "code"
          path: "src/signals-unix.c"
          loc: "288-311"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/signals-unix.c#L288-L311"
          snippet: |
            #elif defined(_OS_LINUX_) && defined(_CPU_ARM_)
                ucontext_t *ctx = (ucontext_t*)_ctx;
                uintptr_t target = (uintptr_t)fptr;
                // Apparently some glibc's sigreturn target is running in thumb state.
                // Mimic a `bx` instruction by setting the T(5) bit of CPSR
                // depending on the target address.
                uintptr_t cpsr = ctx->uc_mcontext.arm_cpsr;
                // Thumb mode function pointer should have the lowest bit set
                if (target & 1) {
                    target = target & ~((uintptr_t)1);
                    cpsr = cpsr | (1 << 5);
                }
                else {
                    cpsr = cpsr & ~(1 << 5);
                }
                ctx->uc_mcontext.arm_cpsr = cpsr;
                ctx->uc_mcontext.arm_sp = rsp;
                ctx->uc_mcontext.arm_lr = 0; // Clear link register
                ctx->uc_mcontext.arm_pc = target;
            #elif defined(_OS_LINUX_) && (defined(_CPU_RISCV64_))
                ucontext_t *ctx = (ucontext_t*)_ctx;
                ctx->uc_mcontext.__gregs[REG_SP] = rsp;
                ctx->uc_mcontext.__gregs[REG_RA] = 0; // Clear return address address (ra)
                ctx->uc_mcontext.__gregs[REG_PC] = (uintptr_t)fptr;

    - summary: "Rename and update jl_fake_signal_return in signals-mach.c for consistency"
      component: "signals-mach.c"
      evidence:
        - source: "code"
          path: "src/signals-mach.c"
          loc: "226-250"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/signals-mach.c#L226-L250"
          snippet: |
            __attribute__((naked)) static void jl_fake_signal_return(void)
            {
            #if defined(_CPU_X86_64_)
            __asm__(
                "  .cfi_signal_frame\n"
                "  .cfi_def_cfa %rsp, 0\n" // CFA here uses %rsp directly
                "  .cfi_offset %rip, 0\n" // previous value of %rip at CFA
                "  .cfi_offset %rsp, 8\n" // previous value of %rsp at CFA
                "  ud2\n"
                "  ud2\n"
            );
            #elif defined(_CPU_AARCH64_)
            __asm__(
                "  .cfi_signal_frame\n"
                "  .cfi_def_cfa sp, 0\n" // use sp as fp here
                // This is not quite valid, since the AArch64 DWARF spec lacks the ability to define how to restore the LR register correctly,
                // so normally libunwind implementations on linux detect this function specially and hack around the invalid info:
                // https://github.com/llvm/llvm-project/commit/c82deed6764cbc63966374baf9721331901ca958
                "  .cfi_offset lr, 0\n"
                "  .cfi_offset sp, 8\n"
                "  brk #1\n"
                "  brk #1\n"
            );
            #endif
            }

    - summary: "Add jl_call_in_state1 function with argument passing support"
      component: "signals-mach.c"
      evidence:
        - source: "code"
          path: "src/signals-mach.c"
          loc: "252-286"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/signals-mach.c#L252-L286"
          snippet: |
            static void jl_call_in_state1(host_thread_state_t *state, void (*fptr)(void), uintptr_t arg0)
            {
            #ifdef _CPU_X86_64_
                uintptr_t sp = state->__rsp;
            #elif defined(_CPU_AARCH64_)
                uintptr_t sp = state->__sp;
            #endif
                sp = (sp - 256) & ~(uintptr_t)15; // redzone and re-alignment
                assert(sp % 16 == 0);
            #ifdef _CPU_X86_64_
                // push {%rsp, %rip}
                sp -= sizeof(void*);
                *(uintptr_t*)sp = state->__rsp;
                sp -= sizeof(void*);
                *(uintptr_t*)sp = state->__rip;
                // pushq .jl_fake_signal_return + 1; aka call from jl_fake_signal_return
                sp -= sizeof(void*);
                *(uintptr_t*)sp = (uintptr_t)&jl_fake_signal_return + 1;
                state->__rsp = sp; // set stack pointer
                state->__rip = (uint64_t)fptr; // "call" the function
                state->__rdi = arg0;

    - summary: "Remove JL_NORETURN from jl_exit_thread0_cb on both platforms"
      component: "signals-unix.c/signals-mach.c"
      evidence:
        - source: "code"
          path: "src/signals-unix.c"
          loc: "674-680"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/signals-unix.c#L674-L680"
          snippet: |
            static void jl_exit_thread0_cb(void)
            {
                jl_atomic_fetch_add(&jl_gc_disable_counter, -1);
                jl_fprint_critical_error(ios_safe_stderr, thread0_exit_signo, 0, NULL, jl_current_task);
                jl_atexit_hook(128);
                jl_raise(thread0_exit_signo);
            }
        - source: "code"
          path: "src/signals-mach.c"
          loc: "588-593"
          url: "https://github.com/JuliaLang/julia/blob/a934511542a269f20b697a5fc81dc28c3907d1fd/src/signals-mach.c#L588-L593"
          snippet: |
            static void jl_exit_thread0_cb(int signo)
            {
                jl_fprint_critical_error(ios_safe_stderr, signo, 0, NULL, jl_current_task);
                jl_atexit_hook(128);
                jl_raise(signo);
            }

  secondary_effects:
    - effect: "Improved debugger backtrace quality for signal-triggered core dumps"
      mechanism: |
        When a signal handler manipulates the stack via jl_call_in_ctx, the original
        call chain is obscured. The CFI directives in jl_fake_signal_return provide
        DWARF unwinding information that allows debuggers (gdb, lldb) to:

        1. Detect the signal frame via .cfi_signal_frame
        2. Locate the saved PC (instruction pointer) and SP (stack pointer)
        3. Reconstruct the call chain that was active when the signal occurred

        Explicit call chain with file:line references:
        usr2_handler() [signals-unix.c:708]
          -> request == 3 triggers exit path [signals-unix.c:762-764]
          -> jl_call_in_ctx(ptls, jl_exit_thread0_cb, sig, ctx) [signals-unix.c:763]
            -> saves context to ptls->signal_ctx_* [signals-unix.c:219-222]
            -> modifies ucontext to jump to jl_fake_signal_return [signals-unix.c:225]
          -> sigreturn with modified context
          -> jl_fake_signal_return() [signals-unix.c:80]
            -> reads ptls->signal_ctx_* via %rdi register
            -> pushes saved pc/sp to stack for CFI unwinding
            -> calls fptr (e.g., jl_exit_thread0_cb) [signals-unix.c:674]

        The unwinder can now walk back through jl_fake_signal_return to the
        original signal context using the saved pc/sp values.
      downstream_surfaces:
        - "Debugger integrations (gdb, lldb)"
        - "Core dump analysis tools"
        - "Crash reporting systems"
      likelihood: "high"
      impact: "medium"

    - effect: "ARM (32-bit) and RISCV64 platforms do NOT receive CFI support"
      mechanism: |
        The PR only implements jl_fake_signal_return with CFI directives for:
        - x86_64 (Linux, FreeBSD, OpenBSD)
        - i686 (Linux, FreeBSD)
        - aarch64 (Linux, FreeBSD)

        ARM (32-bit) and RISCV64 platforms use a different code path in jl_call_in_ctx
        that directly sets the program counter to fptr without going through
        jl_fake_signal_return. This means:

        ARM path [signals-unix.c:288-306]:
          - Sets arm_pc directly to fptr
          - Clears arm_lr to 0
          - No saved context in ptls
          - No CFI support for unwinding

        RISCV64 path [signals-unix.c:307-311]:
          - Sets REG_PC directly to fptr
          - Clears REG_RA to 0
          - No saved context in ptls
          - No CFI support for unwinding

        The fallback jl_fake_signal_return [signals-unix.c:155-159] exists but is
        never called by these architectures - it only contains CFI_NORETURN and abort().
      downstream_surfaces:
        - "Debugger backtraces on ARM/RISCV will still be incomplete during signal handling"
        - "Core dump analysis on these platforms remains limited"
      likelihood: "high"
      impact: "medium"

    - effect: "TLS structure size increase on Linux/FreeBSD/OpenBSD"
      mechanism: |
        Four new fields added to jl_tls_states_t [julia_threads.h:191-195]:
        - signal_ctx_pc: uintptr_t (8 bytes on 64-bit)
        - signal_ctx_sp: uintptr_t (8 bytes on 64-bit)
        - signal_ctx_fptr: void (*)(void) (8 bytes on 64-bit)
        - signal_ctx_arg: uintptr_t (8 bytes on 64-bit)

        Total: 32 bytes on 64-bit, 16 bytes on 32-bit platforms.

        These fields are only present on Linux/FreeBSD/OpenBSD via #ifdef guards.
        macOS does NOT have these fields because Mach exception handling allows
        direct stack manipulation via thread_get_state/thread_set_state.
      downstream_surfaces:
        - "Memory usage per thread"
        - "Binary compatibility with pre-compiled code accessing TLS"
      likelihood: "high"
      impact: "low"

    - effect: "Unified signal handling behavior between macOS and Linux"
      mechanism: |
        Previously, macOS had jl_call_in_state with fake_stack_pop for stack unwinding,
        while Linux/BSD platforms did not have proper CFI directives. Now both platforms
        use a similar approach:

        macOS: jl_call_in_state1() [signals-mach.c:252] + static jl_fake_signal_return()
        Linux: jl_call_in_ctx() [signals-unix.c:204] + global jl_fake_signal_return() (with ptls context)

        Key difference: The Linux implementation uses ptls to store saved context because
        the signal handler cannot directly manipulate the stack like the Mach exception
        handler can. The Mach handler has direct access to thread state via Mach APIs.
      downstream_surfaces:
        - "Cross-platform debugging experience"
      likelihood: "high"
      impact: "low"

    - effect: "jl_exit_thread0_cb signature differs between macOS and Linux"
      mechanism: |
        On macOS [signals-mach.c:588]:
          static void jl_exit_thread0_cb(int signo)

        On Linux [signals-unix.c:674]:
          static void jl_exit_thread0_cb(void)
          // reads from global: static int thread0_exit_signo

        This is because on Linux, the signal number is stored in a global variable
        thread0_exit_signo [signals-unix.c:673] before calling jl_call_in_ctx.
        On macOS, jl_call_in_state1 can pass the signal number directly as an argument.
      downstream_surfaces:
        - "Internal implementation detail only"
      likelihood: "high"
      impact: "low"

    - effect: "OpenBSD support limited to x86_64 only"
      mechanism: |
        The jl_fake_signal_return implementation for OpenBSD is only provided for x86_64:
          #if (defined(_OS_LINUX_) || defined(_OS_FREEBSD_) || defined(_OS_OPENBSD_)) && defined(_CPU_X86_64_)

        i686 support only covers Linux and FreeBSD (not OpenBSD):
          #elif (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && defined(_CPU_X86_)

        aarch64 support only covers Linux and FreeBSD (not OpenBSD):
          #elif (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && defined(_CPU_AARCH64_)

        Similarly in jl_call_in_ctx, the OpenBSD path only handles x86_64 [signals-unix.c:256-265].
      downstream_surfaces:
        - "OpenBSD users on non-x86_64 platforms will not benefit from this change"
      likelihood: "medium"
      impact: "low"

  compatibility:
    internal_api:
      - field: "jl_tls_states_t.signal_ctx_pc"
        change: "New field added for Linux/FreeBSD/OpenBSD (not macOS)"
        affected_tools:
          - tool: "Tools accessing jl_tls_states_t"
            usage: "TLS layout changed - tools that compute offsets into jl_tls_states_t may need updates"
      - field: "jl_tls_states_t.signal_ctx_sp"
        change: "New field added for Linux/FreeBSD/OpenBSD"
        affected_tools: []
      - field: "jl_tls_states_t.signal_ctx_fptr"
        change: "New field added for Linux/FreeBSD/OpenBSD"
        affected_tools: []
      - field: "jl_tls_states_t.signal_ctx_arg"
        change: "New field added for Linux/FreeBSD/OpenBSD"
        affected_tools: []
      - field: "jl_fake_signal_return"
        change: "New global symbol on Linux/FreeBSD/OpenBSD, renamed from fake_stack_pop on macOS (now static)"
        affected_tools:
          - tool: "Custom debugger scripts"
            usage: "Scripts that look for fake_stack_pop on macOS should now use jl_fake_signal_return"
          - tool: "Symbol lookup tools"
            usage: "jl_fake_signal_return is global and exported on Linux, static on macOS"
      - field: "jl_call_in_state renamed to jl_call_in_state1"
        change: "Internal macOS function now takes an additional argument (arg0)"
        affected_tools: []

    behavioral:
      - change: "jl_exit_thread0_cb no longer marked JL_NORETURN"
        rationale: |
          CFI_NORETURN macro removed from jl_exit_thread0_cb on both platforms.
          Function behavior unchanged but annotation removed for stack unwinding compatibility.
          The function still never returns in practice (calls jl_raise which exits).
        affected_usage: "No user-visible change"

  performance:
    compile_time: []
    runtime:
      - change: "Slight additional overhead in signal handling path"
        detail: |
          ESTIMATED: Negligible overhead (<1 microsecond per signal)

          The additional operations in jl_call_in_ctx [signals-unix.c:219-225]:
          1. Save 4 values to ptls (4 store instructions)
          2. Set 3 registers in ucontext (3 store instructions)

          The additional operations in jl_fake_signal_return:
          1. Load values from ptls via pointer (memory loads)
          2. Push values to stack (push instructions)
          3. Call the actual handler function

          This path is only exercised during signal handling (SIGQUIT, SIGUSR2),
          which is inherently slow and rare during normal execution.

  risk:
    level: "low"
    rationale:
      - "Changes are confined to signal handling code, which is exercised only during exceptional conditions"
      - "Platform-specific code is guarded by appropriate #ifdef directives"
      - "The implementation follows the same pattern already used successfully on macOS"
      - "CFI directives are passively consumed by debuggers; they don't affect runtime behavior"
      - "No changes to the Julia compiler, type inference, or optimization passes"
      - "ARM and RISCV platforms continue to work with existing behavior (just no CFI improvement)"

  open_questions:
    - "Are there edge cases where the saved signal context in ptls could become stale or corrupted?"
    - "Does the aarch64 implementation work correctly with all libunwind versions given the noted DWARF spec limitation?"
    - "Should ARM (32-bit) and RISCV64 platforms receive CFI support in a future PR?"
    - "Should OpenBSD support be extended to i686 and aarch64?"

  recommendations:
    - "When debugging Julia crashes on Linux, use recent versions of gdb/lldb that properly handle .cfi_signal_frame"
    - "Downstream tools that parse Julia core dumps should benefit automatically from improved stack traces"
    - "The jl_fake_signal_return symbol can be used as a marker to identify signal handler frames in custom tooling"
    - "Tools accessing jl_tls_states_t should account for the new signal_ctx_* fields on Linux/FreeBSD/OpenBSD"
    - "ARM and RISCV users should be aware that debugger backtraces during signal handling remain limited"

# Reviewer notes (independent analysis findings):
# 1. Verified all platform-specific code paths in jl_call_in_ctx
# 2. Confirmed ARM/RISCV do NOT use jl_fake_signal_return - this is a significant gap
# 3. OpenBSD support is x86_64 only, not documented in original analysis
# 4. jl_exit_thread0_cb signature difference between platforms is a design consequence
# 5. The fallback jl_fake_signal_return (abort()) is never reached by ARM/RISCV paths
# 6. TLS field additions are properly guarded by OS defines (not architecture)
