schema_version: "1.0"
pr:
  number: 60170
  title: "[JuliaLowering] Reconstruct macro name before, not during, macro expansion"
  url: "https://github.com/JuliaLang/julia/pull/60170"
  author: "mlechu"
  labels:
    - "compiler:lowering"
  merged_at: "2025-12-04T21:30:38Z"
  merge_commit_sha: "f163ed8c"
  diff_url: "https://github.com/JuliaLang/julia/pull/60170.diff"
scope:
  files_touched:
    - "JuliaLowering/src/ast.jl"
    - "JuliaLowering/src/compat.jl"
    - "JuliaLowering/src/macro_expansion.jl"
    - "JuliaLowering/src/syntax_graph.jl"
    - "JuliaLowering/test/compat.jl"
    - "JuliaLowering/test/macros.jl"
    - "JuliaLowering/test/macros_ir.jl"
    - "JuliaLowering/test/utils.jl"
    - "test/JuliaLowering_stdlibs.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Parsing"
    - "Lowering"
    - "MacroExpansion"
analysis:
  intent:
    summary: "Move macro-name reconstruction into SyntaxGraph lowering so macro expansion sees identifiers (e.g., @mac) directly, simplifying macro name handling and fixing edge cases like @__dot__ and @static in @preserve."
    issue_links:
      - "https://github.com/JuliaLang/JuliaLowering.jl/issues/121"
  direct_changes:
    - summary: "Convert macro-name nodes (macro_name / StrMacroName / CmdMacroName) into K\"Identifier\" with @-prefixed name_val during green->AST conversion, including dotted macro paths."
      component: "JuliaLowering/src/syntax_graph.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/syntax_graph.jl"
          loc: "889-906"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/syntax_graph.jl#L889-L906"
          snippet: |
            elseif k === K"CmdMacroName" || k === K"StrMacroName"
                name = lower_identifier_name(ex.name_val, k)
                setattr!(makeleaf(graph, ex, K"Identifier"),
                         :name_val, name)
            elseif k === K"macro_name"
                # M.@x parses to (. M (macro_name x))
                # @M.x parses to (macro_name (. M x))
                # We want (. M @x) (both identifiers) in either case
                @assert numchildren(ex) === 2 && kind(ex[1]) === K"@"
                id = ex[2]
                mname_raw = (kind(id) === K"." ? id[2] : id).name_val
                mac_id = setattr!(makeleaf(graph, ex, K"Identifier"), :name_val,
                                  lower_identifier_name(mname_raw, K"macro_name"))
                if kind(id) === K"."
                    makenode(graph, ex, ex, NodeId[id[1]._id, mac_id._id])
                else
                    mac_id
                end
    - summary: "Macro expansion now operates on the reconstructed identifier directly (no fixup pass) and builds cmdstring macrocalls with @cmd identifiers."
      component: "JuliaLowering/src/macro_expansion.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/macro_expansion.jl"
          loc: "155-183"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/macro_expansion.jl#L155-L183"
          snippet: |
            function eval_macro_name(ctx::MacroExpansionContext, mctx::MacroContext, ex0::SyntaxTree)
                mod = current_layer(ctx).mod
                ex = expand_forms_1(ctx, ex0)
                try
                    if kind(ex) === K"Value"
                        !(ex.value isa GlobalRef) ? ex.value :
                            Base.invoke_in_world(ctx.macro_world, getglobal,
                                                 ex.value.mod, ex.value.name)
                    elseif kind(ex) === K"Identifier"
                        layer = get(ex, :scope_layer, nothing)
                        if !isnothing(layer)
                            mod = ctx.scope_layers[layer].mod
                        end
                        Base.invoke_in_world(ctx.macro_world, getproperty,
                                             mod, Symbol(ex.name_val))
                    elseif kind(ex) === K"." &&
                            (ed = _eval_dot(ctx.macro_world, mod, ex); !isnothing(ed))
                        ed
                    else
                        ctx2, ex2 = expand_forms_2(ctx, ex)
                        ctx3, ex3 = resolve_scopes(ctx2, ex2)
                        ctx4, ex4 = convert_closures(ctx3, ex3)
                        ctx5, ex5 = linearize_ir(ctx4, ex4)
                        expr_form = to_lowered_expr(ex5)
                        ccall(:jl_toplevel_eval, Any, (Any, Any), mod, expr_form)
                    end
                catch err
                    throw(MacroExpansionError(mctx, ex, "Macro not found", :all, err))
                end
            end
        - source: "code"
          path: "JuliaLowering/src/macro_expansion.jl"
          loc: "488-491"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/macro_expansion.jl#L488-L491"
          snippet: |
            elseif k == K"cmdstring"
                @chk numchildren(ex) == 1
                e2 = @ast ctx ex [K"macrocall" "@cmd"::K"core" ex[1]]
                expand_macro(ctx, e2)
    - summary: "Compat Expr->SyntaxTree conversion treats macrocall names as @-prefixed identifiers, including @__dot__ rewriting and do-block macrocalls without wrapping a macro_name node."
      component: "JuliaLowering/src/compat.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/compat.jl"
          loc: "262-274"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/compat.jl#L262-L274"
          snippet: |
            elseif e.head === :macrocall
                @assert nargs >= 2
                a1,a1_esc = unwrap_esc(e.args[1])
                child_exprs = collect_expr_parameters(e, 3)
                if child_exprs[2] isa LineNumberNode
                    src = child_exprs[2]
                end
                deleteat!(child_exprs, 2)
                if a1 isa Symbol && a1 === Symbol("@__dot__")
                    child_exprs[1] = Symbol("@.")
                elseif a1 isa Expr && nargs === 2 && a1.args[2] === Symbol("@__dot__")
                    child_exprs[1] = Expr(a1.head, a1.args[1], Symbol("@."))
                elseif a1 isa GlobalRef && a1.mod === Core
                    # Syntax-introduced macrocalls are listed here for reference.  We
                    # probably don't need to convert these.
                    if a1.name === Symbol("@cmd")
                    elseif a1.name === Symbol("@doc") && nargs === 4 # two macro args only
                        # Single-arg @doc is a lookup not corresponding to K"doc"
                        # Revise sometimes calls @doc with three args, but probably shouldn't
                        st_k = K"doc"
                        child_exprs = child_exprs[2:3]
        - source: "code"
          path: "JuliaLowering/src/compat.jl"
          loc: "406-422"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/compat.jl#L406-L422"
          snippet: |
            elseif e.head === :do
                # Expr:
                # (do (call f args...) (-> (tuple lam_args...) (block ...)))
                # SyntaxTree:
                # (call f args... (do (tuple lam_args...) (block ...)))
                if e.args[1].head === :macrocall
                    st_k = K"macrocall"
                    callargs = collect_expr_parameters(e.args[1], 3)
                    if callargs[2] isa LineNumberNode
                        src = callargs[2]
                    end
                    deleteat!(callargs, 2)
                else
                    callargs = collect_expr_parameters(e.args[1], 2)
                    st_k = K"call"
                end
                child_exprs = Any[callargs..., Expr(:do_lambda, e.args[2].args...)]
  secondary_effects:
    - effect: "Macrocall names now carry the '@' prefix as identifiers throughout the SyntaxTree, which changes match patterns for utilities that search for specific macros (e.g., @SyntaxTree, @ast_)."
      mechanism: |
        _green_to_ast() converts K"macro_name"/K"StrMacroName"/K"CmdMacroName" into K"Identifier" with @-prefixed name_val  [syntax_graph.jl:889-906]
        -> expand_forms_1() operates on the identifier directly during macro expansion  [macro_expansion.jl:155-183]
        -> _find_SyntaxTree_macro() now matches name.name_val == "@SyntaxTree" instead of "SyntaxTree"  [syntax_graph.jl:576-593]
        -> format_ir_for_test() special-cases @ast_ by checking for Identifier "@ast_"  [test/utils.jl:167-175]
      downstream_surfaces:
        - "JuliaLowering SyntaxTree utilities (macro search and test harnesses)"
        - "Tools pattern-matching SyntaxTree kinds for macro names"
      likelihood: "high"
      impact: "medium"
    - effect: "Expr compatibility lowering emits macrocall nodes that contain escaped @-prefixed identifiers (instead of K\"macro_name\" nodes), changing legacy macrocall shape accepted by expr_to_syntaxtree." 
      mechanism: |
        _insert_convert_expr() handles Expr(:macrocall, ...) by directly rewriting @__dot__ and leaving macro name as an identifier  [compat.jl:262-274]
        -> tests assert escaped macro names appear as K"Identifier" "@mac" in the SyntaxTree  [test/compat.jl:494-608]
      downstream_surfaces:
        - "Legacy macro producers emitting Expr(:macrocall, ...)"
        - "Downstream AST transforms that expect K\"macro_name\" wrappers"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "SyntaxTree node kinds for macro names"
        change: "K\"macro_name\"/K\"StrMacroName\"/K\"CmdMacroName\" are normalized to K\"Identifier\" with @-prefixed name_val during SyntaxGraph lowering."
        affected_tools:
          - tool: "JuliaLowering SyntaxTree utilities"
            usage: "_find_SyntaxTree_macro expects Identifier name_val == \"@SyntaxTree\" when matching macrocall nodes."
        evidence:
          - source: "code"
            path: "JuliaLowering/src/syntax_graph.jl"
            loc: "576-593"
            url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/syntax_graph.jl#L576-L593"
            snippet: |
              if firstline == line && kind(c) == K"macrocall" && begin
                          name = c[1]
                          if kind(name) == K"."
                              name = name[2]
                          end
                          @assert kind(name) == K"Identifier"
                          name.name_val == "@SyntaxTree"
                      end
    behavioral:
      - change: "Expr-to-SyntaxTree compatibility now expects escaped macro names to appear as @-prefixed identifiers (e.g., \"@mac\") rather than K\"macro_name\" wrappers."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/compat.jl"
            loc: "494-609"
            url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/test/compat.jl#L494-L609"
            snippet: |
              # `@mac x` with macro name escaped
              @test JuliaLowering.expr_to_syntaxtree(Expr(:macrocall, esc(Symbol("@mac")), nothing, :x)) ≈
                  @ast_ [K"macrocall"
                      [K"escape" "@mac"::K"Identifier"]
                      "x"::K"Identifier"
                  ]

              # `@mac x` with macro name escaped
              @test JuliaLowering.expr_to_syntaxtree(
                  Expr(:macrocall, esc(Expr(:(.), :A, QuoteNode(Symbol("@mac")))), nothing, :x)
              ) ≈ @ast_ [K"macrocall"
                  [K"escape"
                      [K"."
                          "A"::K"Identifier"
                          "@mac"::K"Identifier"
                      ]
                  ]
                  "x"::K"Identifier"
              ]
  performance:
    compile_time: []
    runtime: []
  risk:
    level: "medium"
    rationale:
      - "Macro name nodes are normalized earlier, which can break downstream SyntaxTree pattern matching in tooling that relied on K\"macro_name\"/StrMacroName/CmdMacroName nodes."
      - "Changes affect macro expansion hygiene and compat lowering paths that are widely exercised (macrocalls, @__dot__, @cmd)."
  open_questions:
    - "Are there downstream packages (IRTools/CSTParser/JET extensions) that rely on K\"macro_name\" or Str/CmdMacroName nodes from JuliaLowering SyntaxTree output?"
    - "Do any macro tooling paths rely on name strings without '@' (e.g., 'SyntaxTree' vs '@SyntaxTree') outside the updated helpers?"
  recommendations:
    - "Update downstream SyntaxTree visitors to treat macro names as K\"Identifier\" with '@' prefix, including dotted macro paths."
    - "Audit macro-related utilities for string comparisons to ensure they match '@macro' names (e.g., @SyntaxTree, @ast_)."
    - "When converting Expr(:macrocall, ...) in tooling, avoid reintroducing K\"macro_name\" nodes; use identifiers to align with the new lowering pipeline."
