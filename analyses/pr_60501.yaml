schema_version: "1.0"
pr:
  number: 60501
  title: "Test: add context arg for `@test` etc."
  url: "https://github.com/JuliaLang/julia/pull/60501"
  author: "IanButterworth"
  labels:
    - "testsystem"
  merged_at: "2025-12-31T09:21:55Z"
  merge_commit_sha: "35eaf05348215063bd239f3609a625e97735685d"
  diff_url: "https://github.com/JuliaLang/julia/pull/60501.diff"
scope:
  files_touched:
    - "Compiler/test/inference.jl"
    - "Compiler/test/inline.jl"
    - "NEWS.md"
    - "stdlib/FileWatching/test/runtests.jl"
    - "stdlib/InteractiveUtils/test/runtests.jl"
    - "stdlib/Test/src/Test.jl"
    - "stdlib/Test/test/runtests.jl"
    - "test/bitarray.jl"
    - "test/cmdlineargs.jl"
    - "test/math.jl"
    - "test/strings/basic.jl"
  components:
    - "Test stdlib"
    - "Test system"
  pipeline_stages:
    - "Testing/Diagnostics"
analysis:
  intent:
    summary: "Add a `context` keyword to @test, @test_throws, and @test_broken so test failures can report extra debugging information. This enables using `broken=true` with context (previously impossible with non-Boolean workarounds)."
    issue_links: []
  direct_changes:
    - summary: "`@test` macro now parses a `context=...` keyword and passes the evaluated context to `do_test` or `do_broken_test`."
      component: "Test stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Test/src/Test.jl"
          loc: "524-557"
          url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L524-L557"
          snippet: |
            macro test(ex, kws...)
                # Collect the broken/skip/context keywords and remove them from the rest of keywords
                broken = [kw.args[2] for kw in kws if kw.args[1] === :broken]
                skip = [kw.args[2] for kw in kws if kw.args[1] === :skip]
                context = [kw.args[2] for kw in kws if kw.args[1] === :context]
                kws = filter(kw -> kw.args[1] âˆ‰ (:skip, :broken, :context), kws)
                # Validation of broken/skip/context keywords
                for (kw, name) in ((broken, :broken), (skip, :skip), (context, :context))
                    if length(kw) > 1
                        error("invalid test macro call: cannot set $(name) keyword multiple times")
                    end
                end
                if length(skip) > 0 && length(broken) > 0
                    error("invalid test macro call: cannot set both skip and broken keywords")
                end

                # Build the test expression
                test_expr!("@test", ex, kws...)

                result = get_test_result(ex, __source__)

                ex = Expr(:inert, ex)
                ctx = length(context) > 0 ? esc(context[1]) : nothing
                result = quote
                    if $(length(skip) > 0 && esc(skip[1]))
                        record(get_testset(), Broken(:skipped, $ex))
                    else
                        let _do = $(length(broken) > 0 && esc(broken[1])) ? do_broken_test : do_test
                            _do($result, $ex, $ctx)
                        end
                    end
                end
                return result
            end
    - summary: "`@test_broken` macro now parses a `context=...` keyword and passes it to `do_broken_test`."
      component: "Test stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Test/src/Test.jl"
          loc: "589-599"
          url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L589-L599"
          snippet: |
            macro test_broken(ex, kws...)
                # Extract context keyword if present
                context = [kw.args[2] for kw in kws if isa(kw, Expr) && kw.head === :(=) && kw.args[1] === :context]
                kws = filter(kw -> !(isa(kw, Expr) && kw.head === :(=) && kw.args[1] === :context), kws)
                test_expr!("@test_broken", ex, kws...)
                result = get_test_result(ex, __source__)
                ctx = length(context) > 0 ? esc(context[1]) : nothing
                # code to call do_test with execution result and original expr
                ex = Expr(:inert, ex)
                return :(do_broken_test($result, $ex, $ctx))
            end
    - summary: "`do_test` and `do_broken_test` now accept an optional `context` argument, stringify it via `sprint(show, ...)`, and attach it to Fail/Error results."
      component: "Test stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Test/src/Test.jl"
          loc: "781-808"
          url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L781-L808"
          snippet: |
            function do_test(result::ExecutionResult, @nospecialize(orig_expr), context=nothing)
                # get_testset() returns the most recently added test set
                # We then call record() with this test set and the test result
                context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)
                if isa(result, Returned)
                    # expr, in the case of a comparison, will contain the
                    # comparison with evaluated values of each term spliced in.
                    # For anything else, just contains the test expression.
                    # value is the evaluated value of the whole test expression.
                    # Ideally it is true, but it may be false or non-Boolean.
                    value = result.value
                    testres = if isa(value, Bool)
                        # a true value Passes
                        value ? Pass(:test, orig_expr, result.data, value, result.source) :
                                Fail(:test, orig_expr, result.data, value, context_str, result.source, false)
                    else
                        # If the result is non-Boolean, this counts as an Error
                        Error(:test_nonbool, orig_expr, value, nothing, result.source, context_str)
                    end
                else
                    # The predicate couldn't be evaluated without throwing an
                    # exception, so that is an Error and not a Fail
                    @assert isa(result, Threw)
                    testres = Error(:test_error, orig_expr, result.exception, result.current_exceptions, result.source, context_str)
                end
                isa(testres, Pass) || trigger_test_failure_break(result)
                record(get_testset(), testres)
            end
        - source: "code"
          path: "stdlib/Test/src/Test.jl"
          loc: "810-826"
          url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L810-L826"
          snippet: |
            function do_broken_test(result::ExecutionResult, @nospecialize(orig_expr), context=nothing)
                testres = Broken(:test, orig_expr)
                context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)
                # Assume the test is broken and only change if the result is true
                if isa(result, Returned)
                    value = result.value
                    if isa(value, Bool)
                        if value
                            testres = Error(:test_unbroken, orig_expr, value, nothing, result.source, context_str)
                        end
                    else
                        # If the result is non-Boolean, this counts as an Error
                        testres = Error(:test_nonbool, orig_expr, value, nothing, result.source, context_str)
                    end
                end
                record(get_testset(), testres)
            end
    - summary: "Failure rendering for `Test.Fail` and `Test.Error` now appends a Context line whenever `context` is present."
      component: "Test stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Test/src/Test.jl"
          loc: "174-208"
          url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L174-L208"
          snippet: |
            function Base.show(io::IO, t::Fail)
                printstyled(io, "Test Failed"; bold=true, color=Base.error_color())
                print(io, " at ")
                printstyled(io, something(t.source.file, :none), ":", t.source.line, "\n"; bold=true, color=:default)
                print(io, "  Expression: ", t.orig_expr)
                value, data = t.value, t.data
                if t.test_type === :test_throws_wrong
                    # An exception was thrown, but it was of the wrong type
                    if t.message_only
                        print(io, "\n    Expected: ", data)
                        print(io, "\n     Message: ", value)
                    else
                        print(io, "\n    Expected: ", data)
                        print(io, "\n      Thrown: ", value)
                        print(io, "\n")
                        if t.backtrace !== nothing
                            # Capture error message and indent to match
                            join(io, ("      " * line for line in filter!(!isempty, split(t.backtrace, "\n"))), "\n")
                        end
                    end
                elseif t.test_type === :test_throws_nothing
                    # An exception was expected, but no exception was thrown
                    print(io, "\n    Expected: ", data)
                    print(io, "\n  No exception thrown")
                elseif t.test_type === :test
                    if data !== nothing && t.orig_expr != data
                        # The test was an expression, so display the term-by-term
                        # evaluated version as well
                        print(io, "\n   Evaluated: ", data)
                    end
                end
                if t.context !== nothing
                    print(io, "\n     Context: ", t.context)
                end
            end
        - source: "code"
          path: "stdlib/Test/src/Test.jl"
          loc: "273-304"
          url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L273-L304"
          snippet: |
            function Base.show(io::IO, t::Error)
                if t.test_type === :test_interrupted
                    printstyled(io, "Interrupted", color=Base.error_color())
                    return
                end
                printstyled(io, "Error During Test"; bold=true, color=Base.error_color())
                print(io, " at ")
                printstyled(io, something(t.source.file, :none), ":", t.source.line, "\n"; bold=true, color=:default)
                if t.test_type === :test_nonbool
                    println(io, "  Expression evaluated to non-Boolean")
                    println(io, "  Expression: ", t.orig_expr)
                    print(  io, "       Value: ", t.value)
                elseif t.test_type === :test_error
                    println(io, "  Test threw exception")
                    println(io, "  Expression: ", t.orig_expr)
                    # Capture error message and indent to match
                    join(io, ("  " * line for line in filter!(!isempty, split(t.backtrace, "\n"))), "\n")
                elseif t.test_type === :test_unbroken
                    # A test that was expected to fail did not
                    println(io, " Unexpected Pass")
                    println(io, " Expression: ", t.orig_expr)
                    print(io, " Got correct result, please change to @test if no longer broken.")
                elseif t.test_type === :nontest_error
                    # we had an error outside of a @test
                    println(io, "  Got exception outside of a @test")
                    # Capture error message and indent to match
                    join(io, ("  " * line for line in filter!(!isempty, split(t.backtrace, "\n"))), "\n")
                end
                if t.context !== nothing
                    print(io, "\n     Context: ", t.context)
                end
            end
    - summary: "`@test_throws` is now a single varargs macro that accepts an optional trailing `context=...` keyword, passing it into `do_test_throws`."
      component: "Test stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Test/src/Test.jl"
          loc: "887-923"
          url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L887-L923"
          snippet: |
            macro test_throws(args...)
                # Parse arguments: expect (extype, ex) or (extype, pattern, ex), with optional context=... at end
                nargs = length(args)
                nargs >= 2 || error("@test_throws requires at least 2 arguments")

                # Check for context=... keyword at end
                ctx = nothing
                if nargs >= 3 && args[end] isa Expr && args[end].head === :(=) && args[end].args[1] === :context
                    ctx = esc(args[end].args[2])
                    args = args[1:end-1]
                    nargs -= 1
                end

                if nargs == 2
                    extype, ex = args
                    pattern = nothing
                elseif nargs == 3
                    extype, pattern, ex = args
                    pattern = esc(pattern)
                else
                    error("@test_throws expects 2 or 3 positional arguments (plus optional context=...)")
                end

                orig_ex = Expr(:inert, ex)
                ex = Expr(:block, __source__, esc(ex))
                result = quote
                    try
                        Returned($ex, nothing, $(QuoteNode(__source__)))
                    catch _e
                        if $(esc(extype)) != InterruptException && _e isa InterruptException
                            rethrow()
                        end
                        Threw(_e, Base.current_exceptions(), $(QuoteNode(__source__)))
                    end
                end
                return :(do_test_throws($result, $orig_ex, $(esc(extype)), $pattern, $ctx))
            end
    - summary: "`do_test_throws` now accepts an optional `context` argument, stringifies it, and includes it in Fail results for wrong exception type, wrong message, or no exception thrown."
      component: "Test stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Test/src/Test.jl"
          loc: "942-1045"
          url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L942-L1045"
          snippet: |
            function do_test_throws(result::ExecutionResult, @nospecialize(orig_expr), extype, pattern=nothing, context=nothing)
                context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)
                if isa(result, Threw)
                    # Check that the right type of exception was thrown
                    success = false
                    message_only = false
                    exc = result.exception

                    # Handle three-argument form (type + pattern)
                    if pattern !== nothing
                        # In 3-arg form, first argument must be a type
                        if !isa(extype, Type)
                            testres = Fail(:test_throws_wrong, orig_expr, extype, exc, context_str, result.source, false, "First argument must be an exception type in three-argument form")
                            record(get_testset(), testres)
                            return
                        end
                        # ... pattern matching logic continues ...
                    end
                    # ... exception type checking continues ...
                    if success
                        testres = Pass(:test_throws, orig_expr, extype, exc, result.source, message_only)
                    else
                        # ... build Fail with context_str ...
                        testres = Fail(:test_throws_wrong, orig_expr, extype, exc, context_str, result.source, message_only, bt_str)
                    end
                else
                    # Handle no exception case
                    testres = Fail(:test_throws_nothing, orig_expr, extype, nothing, context_str, result.source, false)
                end
                record(get_testset(), testres)
            end
    - summary: "NEWS.md documents the new `context` keyword argument for @test, @test_throws, and @test_broken."
      component: "Documentation"
      evidence:
        - source: "docs"
          path: "NEWS.md"
          loc: "61-63"
          url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/NEWS.md#L61-L63"
          snippet: |
            * `@test`, `@test_throws`, and `@test_broken` now support a `context` keyword argument
              that provides additional information displayed on test failure. This is useful for
              debugging which specific case failed in parameterized tests ([#60501]).
    - summary: "New tests exercise context propagation for @test, @test_throws, and @test_broken, asserting the context string is stored on Fail/Error results."
      component: "Test stdlib tests"
      evidence:
        - source: "test"
          path: "stdlib/Test/test/runtests.jl"
          loc: "469-543"
          url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/test/runtests.jl#L469-L543"
          snippet: |
            # Tests for context keyword
            @testset "@test with context keyword" begin
                # Test that context appears in Fail
                let f = Test.Fail(:test, "false", nothing, "false", "(sin, Float64)", LineNumberNode(1), false)
                    @test occursin("Context: (sin, Float64)", sprint(show, f))
                end

                # Test that context is evaluated and shown in @test
                let fails = @testset NoThrowTestSet begin
                        @test false context=(sin, Float64)
                    end
                    @test length(fails) == 1
                    @test fails[1] isa Test.Fail
                    @test occursin("(sin, Float64)", fails[1].context)
                end

                # Test context with broken=true (should record as Broken)
                let results = @testset NoThrowTestSet begin
                        @test false context="info" broken=true
                    end
                    @test length(results) == 1
                    @test results[1] isa Test.Broken
                end

                # Test context with Error (exception thrown)
                let errors = @testset NoThrowTestSet begin
                        @test error("boom") context="error info"
                    end
                    @test length(errors) == 1
                    @test errors[1] isa Test.Error
                    @test errors[1].context == "\"error info\""
                end
            end

            @testset "@test_throws with context keyword" begin
                # Test context appears when wrong exception thrown
                let fails = @testset NoThrowTestSet begin
                        @test_throws ArgumentError error("wrong") context="extra info"
                    end
                    @test length(fails) == 1
                    @test fails[1] isa Test.Fail
                    @test fails[1].context == "\"extra info\""
                end

                # Test context with three-arg form
                let fails = @testset NoThrowTestSet begin
                        @test_throws ErrorException "pattern" error("wrong msg") context=(1, 2)
                    end
                    @test length(fails) == 1
                    @test fails[1] isa Test.Fail
                    @test occursin("(1, 2)", fails[1].context)
                end

                # Test context when no exception thrown
                let fails = @testset NoThrowTestSet begin
                        @test_throws ErrorException 1 + 1 context="no throw info"
                    end
                    @test length(fails) == 1
                    @test fails[1] isa Test.Fail
                    @test fails[1].test_type === :test_throws_nothing
                    @test fails[1].context == "\"no throw info\""
                end
            end

            @testset "@test_broken with context keyword" begin
                # Test context with @test_broken when test unexpectedly passes
                let errors = @testset NoThrowTestSet begin
                        @test_broken true context="broken info"
                    end
                    @test length(errors) == 1
                    @test errors[1] isa Test.Error
                    @test errors[1].test_type === :test_unbroken
                    @test errors[1].context == "\"broken info\""
                end
            end
  secondary_effects:
    - effect: "Tests that previously used non-Boolean workarounds like `@test cond || \"info\"` can now use `context=...`, and `broken=true` tests can now include context information (previously impossible since non-Boolean broke broken handling)."
      mechanism: |
        @test macro parses context keyword  [stdlib/Test/src/Test.jl:528]
          ctx = length(context) > 0 ? esc(context[1]) : nothing  [stdlib/Test/src/Test.jl:546]
          -> selects do_test or do_broken_test based on broken flag  [stdlib/Test/src/Test.jl:551]
          -> do_test/do_broken_test stringifies via sprint(show, context; context=:limit => true)  [stdlib/Test/src/Test.jl:784,812]
          -> Fail/Error constructors store context_str  [stdlib/Test/src/Test.jl:795,798,804,818,822]
          -> Base.show methods render "Context: ..." line  [stdlib/Test/src/Test.jl:205-207,301-303]
      downstream_surfaces:
        - "Test failure output formatting"
        - "`Test.Fail.context` and `Test.Error.context` fields"
      likelihood: "high"
      impact: "low"
    - effect: "`@test_throws` now accepts a trailing `context=...` keyword, which is threaded to `do_test_throws` and included when reporting wrong/no-throw failures."
      mechanism: |
        @test_throws macro checks for context=... at end of args  [stdlib/Test/src/Test.jl:894-898]
          ctx = esc(args[end].args[2]) if context keyword present
          -> do_test_throws(result, orig_ex, extype, pattern, ctx)  [stdlib/Test/src/Test.jl:922]
          -> do_test_throws stringifies context  [stdlib/Test/src/Test.jl:943]
          -> Fail results include context_str  [stdlib/Test/src/Test.jl:954,1032,1042]
      downstream_surfaces:
        - "`@test_throws` call sites in packages"
        - "Test failure output formatting"
      likelihood: "high"
      impact: "low"
    - effect: "Existing tests in Julia's test suite converted from non-Boolean workaround (`|| expr`) to use `context=expr`, demonstrating the intended migration pattern."
      mechanism: |
        Tests like `@test cond || (a, b)` replaced with `@test cond context=(a, b)`
        Examples in: Compiler/test/inference.jl, Compiler/test/inline.jl, test/math.jl, test/cmdlineargs.jl, test/strings/basic.jl
      downstream_surfaces:
        - "Package test migration patterns"
      likelihood: "high"
      impact: "low"
  compatibility:
    internal_api:
      - field: "Test.do_test(result, orig_expr, context)"
        change: "Added optional third `context` argument (default `nothing`). Callers passing only 2 args continue to work."
        affected_tools: []
      - field: "Test.do_broken_test(result, orig_expr, context)"
        change: "Added optional third `context` argument (default `nothing`). Callers passing only 2 args continue to work."
        affected_tools: []
      - field: "Test.do_test_throws(result, orig_expr, extype, pattern, context)"
        change: "Added optional fifth `context` argument (default `nothing`). Existing 3-arg and 4-arg calls continue to work."
        affected_tools: []
      - field: "Test.Fail struct"
        change: "Already has `context::Union{Nothing, String}` field (added in Julia 1.9). No struct change, but field now populated by macros."
        affected_tools: []
      - field: "Test.Error struct"
        change: "Already has `context::Union{Nothing, String}` field. No struct change, but field now populated by macros."
        affected_tools: []
    behavioral:
      - change: "`context` becomes a reserved keyword for `@test`, `@test_throws`, and `@test_broken`. Tests that used `context=...` as a generic keyword argument to a function being tested must rename the parameter."
        affected_surfaces:
          - "Test macro call syntax"
  performance:
    compile_time:
      - impact: "ESTIMATED: Negligible. Macro expansion adds one conditional check for context keyword presence."
        evidence: []
    runtime:
      - impact: "ESTIMATED: When `context=...` is provided, `sprint(show, context; context=:limit => true)` adds per-test-failure formatting work. Only affects failing tests, not passing tests."
        evidence:
          - source: "code"
            path: "stdlib/Test/src/Test.jl"
            loc: "784"
            url: "https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L784"
            snippet: |
              context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)
  risk:
    level: "low"
    rationale:
      - "Changes are isolated to the Test stdlib and only affect test failure output/metadata."
      - "New optional arguments with defaults preserve backward compatibility for internal API."
      - "Comprehensive tests cover context propagation for @test, @test_throws, and @test_broken including edge cases."
      - "Real-world migration examples included in PR (Julia's own test suite updated)."
  open_questions: []
  recommendations:
    - "Update package test suites to use `context=...` instead of non-Boolean short-circuit tricks like `@test cond || info` when extra debugging info is needed."
    - "Avoid using `context` as a keyword argument name in functions tested via @test/@test_throws/@test_broken to prevent conflicts with the reserved keyword."
