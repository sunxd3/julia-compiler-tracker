schema_version: "1.0"
pr:
  number: 60199
  title: "Reject decimal points after hex float literals"
  url: "https://github.com/JuliaLang/julia/pull/60199"
  author: "Keno"
  labels:
    - "parser"
    - "bugfix"
  merged_at: "2025-11-22T04:19:06Z"
  merge_commit_sha: "59ff9f957b9bff31d34986d55521966a5452791d"
  diff_url: "https://github.com/JuliaLang/julia/pull/60199.diff"
scope:
  files_touched:
    - "JuliaSyntax/src/julia/tokenize.jl"
    - "JuliaSyntax/test/tokenize.jl"
    - "test/syntax.jl"
  components:
    - "JuliaSyntax"
  pipeline_stages:
    - "Parsing"
analysis:
  intent:
    summary: "Reject hex float literals followed by a decimal point or decimal digits to avoid implicit multiplication ambiguities (issue #60189)."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60189"
  direct_changes:
    - summary: "Lexer now rejects hex float literals that have a trailing decimal point or decimal digits after the exponent."
      component: "JuliaSyntax tokenization"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/julia/tokenize.jl"
          loc: "1054-1067"
          url: "https://github.com/JuliaLang/julia/blob/59ff9f957b9bff31d34986d55521966a5452791d/JuliaSyntax/src/julia/tokenize.jl#L1054-L1067"
          snippet: |
            if accept(l, "pP")
                kind = K"Float"
                accept(l, "+-âˆ’")
                if !accept_number(l, isdigit) || !had_digits
                    return emit(l, K"ErrorInvalidNumericConstant") # `0x1p` `0x.p0`
                end
                # Check for invalid trailing decimal point
                # https://github.com/JuliaLang/julia/issues/60189
                pc = peekchar(l)
                if pc == '.'
                    accept_batch(l, c->(c == '.' || isdigit(c)))
                    # `0x1p3.` `0x1p3.2` `0x1.5p2.3`
                    return emit(l, K"ErrorInvalidNumericConstant")
                end
            elseif isfloat
                return emit(l, K"ErrorHexFloatMustContainP") # `0x.` `0x1.0`
            end
    - summary: "Tokenizer tests lock in the new rejection of trailing decimal points/digits after hex float exponents."
      component: "JuliaSyntax tests"
      evidence:
        - source: "test"
          path: "JuliaSyntax/test/tokenize.jl"
          loc: "626-638"
          url: "https://github.com/JuliaLang/julia/blob/59ff9f957b9bff31d34986d55521966a5452791d/JuliaSyntax/test/tokenize.jl#L626-L638"
          snippet: |
            # errors
            @test onlytok("0x") == K"ErrorInvalidNumericConstant"
            @test onlytok("0x2__2") == K"ErrorInvalidNumericConstant"
            @test onlytok("0x1p") == K"ErrorInvalidNumericConstant"
            @test onlytok("0x.p0") == K"ErrorInvalidNumericConstant"
            @test onlytok("0x.")   == K"ErrorHexFloatMustContainP"
            @test onlytok("0x1.0") == K"ErrorHexFloatMustContainP"
            # https://github.com/JuliaLang/julia/issues/60189
            @test onlytok("0x1p3.") == K"ErrorInvalidNumericConstant"
            @test onlytok("0x1p3.2") == K"ErrorInvalidNumericConstant"
            @test onlytok("0x1.5p2.3") == K"ErrorInvalidNumericConstant"
    - summary: "Parser-level test asserts the new parse error for a hex float followed by decimal digits."
      component: "parser tests"
      evidence:
        - source: "test"
          path: "test/syntax.jl"
          loc: "1684-1689"
          url: "https://github.com/JuliaLang/julia/blob/59ff9f957b9bff31d34986d55521966a5452791d/test/syntax.jl#L1684-L1689"
          snippet: |
            # #16356
            @test_parseerror "0xapi"

            # #60189
            @test_parseerror "0x1p3.2"
  secondary_effects:
    - effect: |
        Expressions like 0x1p3.2 now emit ErrorInvalidNumericConstant instead of tokenizing as
        separate tokens (hex float + dot + decimal), which previously allowed implicit multiplication.
        Before: 0x1p3.2 -> tokens [0x1p3, ., 2] -> parsed as 0x1p3 * 0.2 = 8.0 * 0.2 = 1.6
        After:  0x1p3.2 -> token [ErrorInvalidNumericConstant] -> parse error
      mechanism: |
        next_token(l::Lexer)  [tokenize.jl:450]
          -> _next_token(l, readchar(l))  [tokenize.jl:455]
        _next_token(l::Lexer, c)  [tokenize.jl:459]
          -> isdigit(c): lex_digit(l, K"Integer")  [tokenize.jl:535]
        lex_digit(l::Lexer, kind)  [tokenize.jl:985]
          -> if c == '0' && pc == 'x': parse hex literal
          -> if accept(l, "pP"): parse exponent  [tokenize.jl:1054]
          -> NEW: pc = peekchar(l) after exponent  [tokenize.jl:1062]
          -> NEW: if pc == '.': emit(l, K"ErrorInvalidNumericConstant")  [tokenize.jl:1063-1066]
        -> parser sees ErrorInvalidNumericConstant token and raises parse error
      downstream_surfaces:
        - "JuliaSyntax token stream consumers"
        - "Base parser error handling"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api: []
    behavioral:
      - "Source text like 0x1p3.2 (previously lexed into tokens allowing implicit multiplication) now raises a parse error; affected code must insert explicit operators or whitespace."
  performance:
    compile_time:
      - "ESTIMATED: Adds a peek and potential accept_batch after parsing hex float exponents; O(k) scan over trailing digits/dots in the invalid-case only. Expected negligible impact in valid code."
    runtime: []
  risk:
    level: "low"
    rationale:
      - "Change is limited to JuliaSyntax lexing of hex float literals and guarded by tests for the exact new error cases."
  open_questions: []
  recommendations:
    - "Downstream tooling that tokenizes Julia source (e.g., formatters or syntax highlighters built on JuliaSyntax) should expect ErrorInvalidNumericConstant for 0x1p3.2-style inputs and handle it as a hard error rather than implicit multiplication."
