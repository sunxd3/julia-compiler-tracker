schema_version: "1.0"
pr:
  number: 60432
  title: "[JuliaLowering] fix `@nospecialize` on unnamed arguments"
  url: "https://github.com/JuliaLang/julia/pull/60432"
  author: "aviatesk"
  labels: []
  merged_at: "2025-12-22T18:47:35Z"
  merge_commit_sha: "b7a217c55c07d7c975b2d1250f832731c2053284"
  diff_url: "https://github.com/JuliaLang/julia/pull/60432.diff"
scope:
  files_touched:
    - "JuliaLowering/src/desugaring.jl"
    - "JuliaLowering/src/linear_ir.jl"
    - "JuliaLowering/test/functions.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Lowering"
    - "LinearIR"
analysis:
  intent:
    summary: "Propagate @nospecialize metadata for placeholder (unnamed) arguments through lowering and linear IR so the resulting Method nospecialize bitset matches user annotations."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/44428"
    quoted_from_pr: "Propagate `is_nospecialize` metadata for Placeholder arguments in desugaring and linear_ir generation. Separated from #60416."
  direct_changes:
    - summary: "Desugaring now extracts :nospecialize metadata from placeholder argument AST nodes and passes it to new_local_binding, ensuring unnamed arguments preserve @nospecialize during lowering."
      component: "JuliaLowering desugaring"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "2329-2339"
          url: "https://github.com/JuliaLang/julia/blob/b7a217c55c07d7c975b2d1250f832731c2053284/JuliaLowering/src/desugaring.jl#L2329-L2339"
          snippet: |
            elseif k == K"Placeholder"
                # Lowering should be able to use placeholder args as rvalues internally,
                # e.g. for kw method dispatch.  Duplicate positional placeholder names
                # should be allowed.
                is_nospecialize = getmeta(ex, :nospecialize, false)
                name = if is_kw
                    @ast ctx ex ex=>K"Identifier"
                else
                    new_local_binding(ctx, ex, "#arg$(string(arg_id))#"; kind=:argument,
                                      is_nospecialize=is_nospecialize)
                end
    - summary: "Linear IR Slot construction for placeholder arguments now reads :nospecialize metadata directly from the AST node via getmeta(), ensuring CodeInfo meta is emitted for unnamed arguments."
      component: "JuliaLowering linear_ir"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/linear_ir.jl"
          loc: "1065-1069"
          url: "https://github.com/JuliaLang/julia/blob/b7a217c55c07d7c975b2d1250f832731c2053284/JuliaLowering/src/linear_ir.jl#L1065-L1069"
          snippet: |
            for arg in children(lambda_args)
                if kind(arg) == K"Placeholder"
                    # Unused functions arguments like: `_` or `::T`
                    push!(slots, Slot(arg.name_val, :argument, getmeta(arg, :nospecialize, false),
                                      false, false, false, false))
  secondary_effects:
    - effect: "@nospecialize on unnamed arguments now survives all the way to emitted CodeInfo meta, so Method.nospecialize bitsets reflect placeholder annotations."
      mechanism: |
        expand_function_arg(ctx, body_stmts, arg, ...) [desugaring.jl:2285]
          checks kind(ex) == K"Placeholder" [desugaring.jl:2329]
          -> getmeta(ex, :nospecialize, false) [desugaring.jl:2333]
          -> new_local_binding(..., is_nospecialize=is_nospecialize) [desugaring.jl:2337-2338]
          -> _new_binding(..., is_nospecialize=...) [bindings.jl:137]
          -> BindingInfo(..., is_nospecialize=...) [bindings.jl:42-45]

        compile_lambda(outer_ctx, ex) [linear_ir.jl:1055]
          checks kind(arg) == K"Placeholder" [linear_ir.jl:1066]
          -> Slot(..., getmeta(arg, :nospecialize, false), ...) [linear_ir.jl:1068]

        to_code_info(ex, slots, meta) [eval.jl:220]
          iterates over slots [eval.jl:229]
          -> if slot.is_nospecialize [eval.jl:246]
          -> push!(stmts, Expr(:meta, :nospecialize, Core.SlotNumber(i))) [eval.jl:249]
      downstream_surfaces:
        - "Method.nospecialize bitset"
        - "CodeInfo :nospecialize meta on placeholder slots"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/eval.jl"
          loc: "246-250"
          url: "https://github.com/JuliaLang/julia/blob/b7a217c55c07d7c975b2d1250f832731c2053284/JuliaLowering/src/eval.jl#L246-L250"
          snippet: |
            if slot.is_nospecialize
                # Ideally this should be a slot flag instead
                add_ir_debug_info!(current_codelocs_stack, ex)
                push!(stmts, Expr(:meta, :nospecialize, Core.SlotNumber(i)))
            end
  compatibility:
    internal_api:
      - summary: "Method.nospecialize now includes bits for unnamed placeholder arguments when annotated, which may change expectations in tooling that inspects Method.nospecialize for specialization control."
        evidence:
          - source: "diff"
            path: "JuliaLowering/src/bindings.jl"
            loc: "17"
            url: "https://github.com/JuliaLang/julia/blob/b7a217c55c07d7c975b2d1250f832731c2053284/JuliaLowering/src/bindings.jl#L17"
            snippet: |
              is_nospecialize::Bool # @nospecialize on this argument (only valid for kind == :argument)
    behavioral:
      - summary: "User code with @nospecialize on unnamed arguments now produces the expected nospecialize bitmask, aligning runtime specialization behavior with annotations."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/functions.jl"
            loc: "328-334"
            url: "https://github.com/JuliaLang/julia/blob/b7a217c55c07d7c975b2d1250f832731c2053284/JuliaLowering/test/functions.jl#L328-L334"
            snippet: |
              # @nospecialize on unnamed arguments (issue #44428)
              JuliaLowering.include_string(test_mod, """
              function f_nospecialize_unnamed(@nospecialize(::Any), @nospecialize(x::Any))
                  x
              end
              """)
              @test only(methods(test_mod.f_nospecialize_unnamed)).nospecialize == 0b11
  performance:
    compile_time:
      - summary: "ESTIMATED: Slightly reduced specialization work for methods that use unnamed @nospecialize arguments (now correctly marked), which can lower method instance churn in codegen."
        evidence:
          - source: "discussion"
            path: "JuliaLowering/src/desugaring.jl"
            loc: "2333"
            snippet: "The fix adds one getmeta() call per placeholder argument during desugaring - O(1) per argument, negligible overhead."
    runtime:
      - summary: "ESTIMATED: No runtime behavior change beyond honoring the existing @nospecialize annotation; specialization decisions align with user intent."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/functions.jl"
            loc: "334"
            snippet: "Test verifies Method.nospecialize == 0b11 for function with two @nospecialize arguments (one unnamed, one named)."
  tests:
    changed_files:
      - "JuliaLowering/test/functions.jl"
    new_behavior_assertions:
      - "Test that @nospecialize on unnamed argument (::Any) sets the nospecialize bit: only(methods(test_mod.f_nospecialize_unnamed)).nospecialize == 0b11"
    coverage_gaps: []
  risk:
    level: "low"
    rationale:
      - "Change is limited to propagating existing metadata for placeholder arguments and is guarded by tests for Method.nospecialize."
      - "No changes to inference or optimization passes beyond carrying metadata into slots."
      - "The fix only affects the nospecialize bit for unnamed arguments - no semantic changes to named arguments."
  open_questions: []
  recommendations:
    - "Downstream tooling that inspects Method.nospecialize should include placeholder (unnamed) arguments in its expectations going forward."
    - "Tools using reflection on method signatures should be aware that unnamed @nospecialize arguments now correctly show in the nospecialize bitmask."
