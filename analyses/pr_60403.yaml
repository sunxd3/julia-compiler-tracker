schema_version: "1.0"
pr:
  number: 60403
  title: "JuliaSyntax:force specialize on function in `parse_brackets`"
  url: "https://github.com/JuliaLang/julia/pull/60403"
  author: "KristofferC"
  labels:
    - "backport 1.12"
    - "backport 1.13"
  merged_at: "2025-12-17T17:56:23Z"
  merge_commit_sha: "b34261b5d099153c7d454588332f822ddcb12ea9"
  diff_url: "https://github.com/JuliaLang/julia/pull/60403.diff"
scope:
  files_touched:
    - "JuliaSyntax/src/julia/parser.jl"
  components:
    - "JuliaSyntax"
  pipeline_stages:
    - "Parsing"
analysis:
  intent:
    summary: "Force specialization on the `after_parse` callable passed to `parse_brackets` so bracket parsing avoids heuristic despecialization (notably when default-argument wrappers call into the parser), reducing REPL lag after heavy package loads."
    issue_links:
      - "https://github.com/JuliaLang/JuliaSyntax.jl/pull/601"
  direct_changes:
    - summary: "Change `parse_brackets` function signature from `after_parse::Function` to `after_parse::F where {F}` to force specialization on each distinct closure passed by callers."
      component: "JuliaSyntax parser"
      evidence:
        - source: "diff"
          path: "JuliaSyntax/src/julia/parser.jl"
          loc: "3192-3193"
          url: "https://github.com/JuliaLang/julia/pull/60403/files"
          snippet: |
            # BEFORE:
            function parse_brackets(after_parse::Function,
                                    ps::ParseState, closing_kind, generator_is_last=true)
            # AFTER:
            function parse_brackets(after_parse::F,
                                    ps::ParseState, closing_kind, generator_is_last=true) where {F}
        - source: "code"
          path: "JuliaSyntax/src/julia/parser.jl"
          loc: "3192-3200"
          url: "https://github.com/JuliaLang/julia/blob/b34261b5d099153c7d454588332f822ddcb12ea9/JuliaSyntax/src/julia/parser.jl#L3192-L3200"
          snippet: |
            function parse_brackets(after_parse::F,
                                    ps::ParseState, closing_kind, generator_is_last=true) where {F}
                ps = ParseState(ps, range_colon_enabled=true,
                                space_sensitive=false,
                                where_enabled=true,
                                whitespace_newline=true)
                params_positions = acquire_positions(ps.stream)
                last_eq_before_semi = 0
                num_subexprs = 0
    - summary: "Callers pass in distinct `do`-block closures that now specialize independently, covering parse-unary, paren, and other bracketed forms."
      component: "JuliaSyntax parser"
      evidence:
        - source: "rg"
          path: "JuliaSyntax/src/julia/parser.jl"
          loc: "1275-3315"
          url: "https://github.com/JuliaLang/julia/blob/b34261b5d099153c7d454588332f822ddcb12ea9/JuliaSyntax/src/julia/parser.jl#L1275-L3315"
          snippet: |
            1275:        opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
            2218:            opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
            2764:    parse_brackets(ps, closer, false) do _, _, _, _
            2780:    opts = parse_brackets(ps, closer) do _, _, _, num_subexprs
            3133:        opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
            3315:                opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
    - summary: "Behavioral expectations for bracket parsing remain validated by existing parser tests (no syntax changes expected)."
      component: "JuliaSyntax tests"
      evidence:
        - source: "code"
          path: "JuliaSyntax/test/parser.jl"
          loc: "388-399"
          url: "https://github.com/JuliaLang/julia/blob/b34261b5d099153c7d454588332f822ddcb12ea9/JuliaSyntax/test/parser.jl#L388-L399"
          snippet: |
            # calls with brackets
            "f(a,b)"  => "(call f a b)"
            "f(a,)"   => "(call-, f a)"
            "f(a=1; b=2)" => "(call f (= a 1) (parameters (= b 2)))"
            "f(a; b; c)" => "(call f a (parameters b) (parameters c))"
            "(a=1)()" =>  "(call (parens (= a 1)))"
            "f (a)" => "(call f (error-t) a)"
            "@x(a, b)"   =>  "(macrocall-p (macro_name x) a b)"
            "@x(a, b,)"  =>  "(macrocall-p-, (macro_name x) a b)"
            "A.@x(y)"    =>  "(macrocall-p (. A (macro_name x)) y)"
            "A.@x(y).z"  =>  "(. (macrocall-p (. A (macro_name x)) y) z)"
            "f(y for x = xs; a)" => "(call f (generator y (iteration (in x xs))) (parameters a))"
  secondary_effects:
    - effect: "Parser call-sites now get specialized `parse_brackets` instantiations per closure, reducing dynamic dispatch in bracket parsing hot paths (notably `parse_unary`)."
      mechanism: |
        The default argument `generator_is_last=true` causes Julia to generate two methods:
          g(f, x) = <body calling f>           # calls f directly
          g(f) = g(f, true)                    # wrapper - does NOT call f directly

        The second wrapper method heuristically gets despecialized on `f` since it doesn't
        call `f` directly. By using `where {F}`, both methods MUST specialize on F.

        Call chain affected:
        parse_unary(ps::ParseState)  [parser.jl:1191]
          -> parse_brackets(ps, K")") do ... end  [parser.jl:1275]
          -> after_parse closure specializes via parse_brackets(after_parse::F)  [parser.jl:3192]
          -> opts influences call-vs-block parsing and operator precedence  [parser.jl:1276-1283]

        Six distinct call sites now each get specialized code paths:
          - parse_unary (line 1275): prefix operator calls like +(a,b)
          - function definition parsing (line 2218): anonymous function argument lists
          - parse_call_arglist (line 2764): call argument lists with generators
          - parse_vect (line 2780): vector/array parsing [x, y]
          - parse_paren (line 3133): tuple and block syntax (x, y) or (a; b)
          - parse_string (line 3315): string interpolation $(x + y)
      downstream_surfaces:
        - "REPL parsing latency during heavy package loads (3586ms recompile time reported for REPL.LineEdit.refresh_multi_line after loading GLMakie)"
        - "JuliaSyntax-based tooling that repeatedly parses bracketed call forms"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "parse_brackets(after_parse::F) where {F}"
        change: "Callable argument now specialized by concrete closure type instead of `Function`, increasing method specialization for JuliaSyntax internals."
        affected_tools:
          - tool: "JuliaSyntax internal callers"
            usage: "`parse_unary` and other parser entry points pass `do`-block closures to `parse_brackets`."
    behavioral: []
  performance:
    compile_time:
      - impact: "ESTIMATED: Slight increase in method specialization count (~6 additional specialized methods for parse_brackets, one per call site closure type)."
    runtime:
      - impact: |
          MEASURED (from PR): Before fix, loading GLMakie caused 3586ms recompile time for:
            precompile(Tuple{typeof(REPL.LineEdit.refresh_multi_line), ...})
          After fix, specialized code paths avoid recompilation on first REPL use.
          Root cause: default-argument wrapper methods were being despecialized on closure type.
  risk:
    level: "low"
    rationale:
      - "Change is signature-level specialization only; parse logic and tests for bracket syntax remain unchanged."
      - "Affected surface is JuliaSyntax internal parsing; no user-facing syntax semantics are altered."
  open_questions:
    - "Does the increased specialization materially raise method cache size for long-lived JuliaSyntax sessions?"
  recommendations:
    - "Monitor parser-related precompile and REPL latency to confirm the expected responsiveness improvement without significant code size growth."
