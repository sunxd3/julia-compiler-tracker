schema_version: "1.0"
pr:
  number: 60353
  title: "codegen load/store/union cleanup and fix"
  url: "https://github.com/JuliaLang/julia/pull/60353"
  author: "vtjnash"
  labels:
    - "compiler:codegen"
    - "don't squash"
  merged_at: "2025-12-11T12:23:47Z"
  merge_commit_sha: "2fe1efb65ccc68dad2017b7bb26f1dd36abc798f"
  diff_url: "https://github.com/JuliaLang/julia/pull/60353.diff"
scope:
  files_touched:
    - "Compiler/test/codegen.jl"
    - "src/cgutils.cpp"
    - "src/codegen.cpp"
    - "src/intrinsics.cpp"
  components:
    - "Compiler.Codegen"
    - "Compiler.Tests"
  pipeline_stages:
    - "Codegen"
    - "LLVM IR"
analysis:
  intent:
    summary: "Clean up and de-duplicate codegen load/store/union handling, while fixing union phi/root handling bugs and atomic pointer operation paths."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60345"
      - "https://github.com/JuliaLang/julia/issues/60355"
  direct_changes:
    - summary: "Add StoreKind enum replacing multiple boolean flags in store paths, centralizing operation naming and call sites."
      component: "Compiler.Codegen"
      evidence:
        - source: "code"
          path: "src/cgutils.cpp"
          loc: "40-58"
          url: "https://github.com/JuliaLang/julia/blob/2fe1efb65ccc68dad2017b7bb26f1dd36abc798f/src/cgutils.cpp#L40-L58"
          snippet: |
            // Enum to represent field operation types, replacing multiple boolean parameters
            enum class StoreKind {
                Set,         // setfield!/setglobal!/memoryrefset!
                Swap,        // swapfield!/swapglobal!/memoryrefswap!
                Replace,     // replacefield!/replaceglobal!/memoryrefreplace!
                Modify,      // modifyfield!/modifyglobal!/memoryrefmodify!
                SetOnce      // setfieldonce!/setglobalonce!/memoryrefsetonce!
            };

            static const char *store_kind_name(StoreKind op, const char *suffix) {
                switch (op) {
                case StoreKind::Set:     return suffix[0] == 'g' ? "setglobal!" : suffix[0] == 'm' ? "memoryrefset!" : "setfield!";
                case StoreKind::Swap:    return suffix[0] == 'g' ? "swapglobal!" : suffix[0] == 'm' ? "memoryrefswap!" : "swapfield!";
                case StoreKind::Replace: return suffix[0] == 'g' ? "replaceglobal!" : suffix[0] == 'm' ? "memoryrefreplace!" : "replacefield!";
                case StoreKind::Modify:  return suffix[0] == 'g' ? "modifyglobal!" : suffix[0] == 'm' ? "memoryrefmodify!" : "modifyfield!";
                case StoreKind::SetOnce: return suffix[0] == 'g' ? "setglobalonce!" : suffix[0] == 'm' ? "memoryrefsetonce!" : "setfieldonce!";
                }
                return "";
            }
    - summary: "Add shared helpers for aliased loads/stores; centralize union tag loading in typed_load via ptindex." 
      component: "Compiler.Codegen"
      evidence:
        - source: "code"
          path: "src/cgutils.cpp"
          loc: "2342-2405"
          url: "https://github.com/JuliaLang/julia/blob/2fe1efb65ccc68dad2017b7bb26f1dd36abc798f/src/cgutils.cpp#L2342-L2405"
          snippet: |
            // Helper to create a load with TBAA and alias scope metadata
            static LoadInst *emit_aliased_load(jl_codectx_t &ctx, Type *elty, Value *ptr, Align alignment,
                                               MDNode *tbaa, MDNode *aliasscope, AtomicOrdering Order,
                                               bool maybe_mark_dereferenceable = false, bool maybe_null = true,
                                               jl_value_t *jltype_for_dereferenceable = nullptr)
            {
                LoadInst *load = ctx.builder.CreateAlignedLoad(elty, ptr, alignment, false);
                load->setOrdering(Order);
                jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);
                ai.scope = MDNode::concatenate(aliasscope, ai.scope);
                ai.decorateInst(load);
                if (maybe_mark_dereferenceable && jltype_for_dereferenceable)
                    maybe_mark_load_dereferenceable(load, maybe_null, jltype_for_dereferenceable);
                return load;
            }

            // Load union type tag from ptindex, returns tindex+1 (1-indexed)
            static Value *emit_load_tindex(jl_codectx_t &ctx, Value *ptindex, unsigned union_max, MDNode *tbaa_ptindex)
            {
                assert(union_max > 0);
                jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa_ptindex);
                Instruction *tindex0 = ai.decorateInst(ctx.builder.CreateAlignedLoad(getInt8Ty(ctx.builder.getContext()), ptindex, Align(1)));
                tindex0->setMetadata(LLVMContext::MD_range, MDNode::get(ctx.builder.getContext(), {
                    ConstantAsMetadata::get(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0)),
                    ConstantAsMetadata::get(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), union_max)) }));
                return ctx.builder.CreateNUWAdd(ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 1), tindex0);
            }

            // If `nullcheck` is not NULL and a pointer NULL check is necessary
            // store the pointer to be checked in `*nullcheck` instead of checking it
            static jl_cgval_t typed_load(jl_codectx_t &ctx, Value *ptr, Value *idx_0based, jl_value_t *jltype,
                                         MDNode *tbaa, MDNode *aliasscope, bool isboxed, AtomicOrdering Order,
                                         bool maybe_null_if_boxed = true, unsigned alignment = 0,
                                         Value **nullcheck = nullptr,
                                         Value *ptindex = nullptr, MDNode *tbaa_ptindex = nullptr)
            {
                // Handle union types (when ptindex is provided)
                if (ptindex != nullptr) {
                    assert(jl_is_uniontype(jltype));
                    size_t fsz = 0, al = 0;
                    int union_max = jl_islayout_inline(jltype, &fsz, &al);
                    Value *tindex = emit_load_tindex(ctx, ptindex, union_max, tbaa_ptindex ? tbaa_ptindex : tbaa);
                    Value *data = ptr;
                    if (fsz > 0) {
                        AllocaInst *lv = emit_static_alloca(ctx, fsz, Align(al));
                        setName(ctx.emission_context, lv, "immutable_union");
                        jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);
                        emit_memcpy(ctx, lv, ai, ptr, ai, fsz, Align(al), Align(al));
                        data = lv;
                    }
                    return mark_julia_slot(fsz > 0 ? data : nullptr, jltype, tindex, tbaa);
                }
    - summary: "Refactor typed_store for union handling via ptindex, storing tag bytes and routing through shared helpers." 
      component: "Compiler.Codegen"
      evidence:
        - source: "code"
          path: "src/cgutils.cpp"
          loc: "2530-2660"
          url: "https://github.com/JuliaLang/julia/blob/2fe1efb65ccc68dad2017b7bb26f1dd36abc798f/src/cgutils.cpp#L2530-L2660"
          snippet: |
            // Union type setup
            bool is_union = ptindex != nullptr;
            MDNode *tbaa_tindex = is_union ? (tbaa_ptindex ? tbaa_ptindex : tbaa) : nullptr;
            jl_cgval_t rhs_union = rhs;
            if (is_union) {
                assert(!isboxed && Order == AtomicOrdering::NotAtomic);
                // Union SetOnce always returns false (no undefined element in these unions)
                if (op == StoreKind::SetOnce)
                    return mark_julia_const(ctx, jl_false);
                if (op != StoreKind::Modify) {
                    rhs_union = convert_julia_type_to_union(ctx, rhs_union, jltype, false);
                    if (rhs_union.typ == jl_bottom_type)
                        return jl_cgval_t();
                }
            }
            auto store_union = [&](const jl_cgval_t &val, const jl_cgval_t &val_union) {
                Value *tindex = ctx.builder.CreateAnd(val_union.TIndex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), ~UNION_BOX_MARKER));
                Value *stindex = ctx.builder.CreateNUWSub(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 1));
                jl_aliasinfo_t ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa_tindex);
                ai.decorateInst(ctx.builder.CreateAlignedStore(stindex, ptindex, Align(1)));
                if (!val.isghost)
                    emit_unionmove(ctx, ptr, jltype, tbaa, val, tindex, /*skip*/nullptr);
            };
            auto load_union = [&]() {
                return typed_load(ctx, ptr, NULL, jltype, tbaa, nullptr, false,
                        AtomicOrdering::NotAtomic, false, 0, nullptr, ptindex, tbaa_tindex);
            };

            if (op == StoreKind::Set || (Order == AtomicOrdering::NotAtomic && op == StoreKind::Swap)) {
                if (op == StoreKind::Swap) {
                    if (is_union) {
                        oldval = load_union();
                    }
                    else {
                        instr = emit_aliased_load(ctx, elty, ptr, Align(alignment), tbaa, aliasscope, isboxed ? AtomicOrdering::Unordered : AtomicOrdering::NotAtomic);
                        setName(ctx.emission_context, instr, "swap_load");
                    }
                }
                if (is_union) {
                    store_union(rhs, rhs_union);
                }
                else if (r) {
                    AtomicOrdering storeOrder = Order == AtomicOrdering::NotAtomic && isboxed ? AtomicOrdering::Release : Order;
                    emit_aliased_store(ctx, r, ptr, Align(alignment), tbaa, aliasscope, storeOrder);
                }
                else {
                    assert(Order == AtomicOrdering::NotAtomic && !isboxed && rhs.typ == jltype);
                    emit_unbox_store(ctx, rhs, ptr, tbaa, MaybeAlign(), Align(alignment));
                }
            }
    - summary: "Fix union phi node assignment to handle inline roots and pointer phis when union storage or inline roots exist." 
      component: "Compiler.Codegen"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "5909-5950"
          url: "https://github.com/JuliaLang/julia/blob/2fe1efb65ccc68dad2017b7bb26f1dd36abc798f/src/codegen.cpp#L5909-L5950"
          snippet: |
            if (jl_is_uniontype(phiType)) {
                bool allunbox;
                size_t min_align, nbytes, inline_roots;
                dest = try_emit_union_alloca(ctx, ((jl_uniontype_t*)phiType), allunbox, min_align, nbytes, inline_roots);
                if (dest || allunbox || inline_roots) {
                    Value *ptr = nullptr;
                    PHINode *ptr_phi = nullptr;
                    auto tbaa = ctx.tbaa().tbaa_stack;
                    PHINode *Tindex_phi = PHINode::Create(getInt8Ty(ctx.builder.getContext()), jl_array_nrows(edges), "tindex_phi");
                    Tindex_phi->insertInto(BB, InsertPt);
                    if (inline_roots) {
                        roots.resize(inline_roots);
                        for (size_t nr = 0; nr < inline_roots; nr++) {
                            auto root_phi = PHINode::Create(ctx.types().T_prjlvalue, jl_array_nrows(edges), "root_phi");
                            root_phi->insertInto(BB, InsertPt);
                            roots[nr] = root_phi;
                        }
                    }
                    if (dest || inline_roots) {
                        ptr_phi = PHINode::Create(ctx.types().T_prjlvalue, jl_array_nrows(edges), "ptr_phi");
                        ptr_phi->insertInto(BB, InsertPt);
                        if (dest) {
                            Value *isboxed = ctx.builder.CreateICmpNE(
                                    ctx.builder.CreateAnd(Tindex_phi, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER)),
                                    ConstantInt::get(getInt8Ty(ctx.builder.getContext()), 0));
                            AllocaInst *phi = cast<AllocaInst>(dest->clone());
                            phi->insertAfter(dest);
                            ctx.builder.CreateMemCpy(phi, Align(min_align), dest, dest->getAlign(), nbytes, false);
                            ctx.builder.CreateLifetimeEnd(dest);
                            ptr = ctx.builder.CreateSelect(isboxed,
                                decay_derived(ctx, ptr_phi),
                                decay_derived(ctx, phi));
                        }
                        tbaa = best_tbaa(ctx.tbaa(), phiType);
                    }
                    jl_cgval_t val = mark_julia_slot(ptr, phiType, Tindex_phi, tbaa,
                        roots.empty() ? ArrayRef<Value*>() : ArrayRef((Value *const *)&roots.front(), roots.size()));
                    val.Vboxed = ptr_phi;
                    ctx.PhiNodes.push_back(std::make_tuple(val, BB, dest, ptr_phi, roots, r));
                    ctx.SAvalues[idx] = val;
                    ctx.ssavalue_assigned[idx] = true;
                    return;
                }
            }
    - summary: "Add regression test for union-typed phi nodes with inline roots." 
      component: "Compiler.Tests"
      evidence:
        - source: "test"
          path: "Compiler/test/codegen.jl"
          loc: "1079-1087"
          url: "https://github.com/JuliaLang/julia/blob/2fe1efb65ccc68dad2017b7bb26f1dd36abc798f/Compiler/test/codegen.jl#L1079-L1087"
          snippet: |
            # Test phi node codegen for union types with inline roots
            function union_phi_inline_roots(x::Bool)
                if x
                    return ("Q8", 1)
                else
                    return ("Q10", Ref(5))
                end
            end
            @test union_phi_inline_roots(true) === ("Q8", 1)
    - summary: "Ensure union and ghost returns convert through union representation; adjust return ABI for inline roots." 
      component: "Compiler.Codegen"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "7136-7169"
          url: "https://github.com/JuliaLang/julia/blob/2fe1efb65ccc68dad2017b7bb26f1dd36abc798f/src/codegen.cpp#L7136-L7169"
          snippet: |
            case jl_returninfo_t::Union: {
                Type *retty = gf_thunk->getReturnType();
                jl_cgval_t retvalinfo = convert_julia_type_to_union(ctx, gf_retval, rettype, false);
                if (retvalinfo.typ == jl_bottom_type) {
                    CreateTrap(ctx.builder, false);
                    break;
                }
                Value *tindex = retvalinfo.TIndex;
                Value *gf_ret = boxed(ctx, gf_retval); // TODO: this is not the most optimal way to emit this
                if (!retvalinfo.inline_roots.empty()) {
                    auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, ctx.tbaa().tbaa_gcframe);
                    ArrayRef<Value*> inline_roots(retvalinfo.inline_roots);
                    Argument *roots;
                    if (return_roots) {
                        roots = gf_thunk->arg_begin() + 1; // root1 has type [n x {}*]*
                        inline_roots = inline_roots.slice(0, std::min(inline_roots.size(), (size_t)return_roots)); // TODO: unreachable?
                    }
                    else {
                        roots = gf_thunk->arg_begin(); // root1 has type [n x {}*]*
                    }
                    store_all_roots(ctx, inline_roots, roots, roots_ai, false);
                }
                Value *retval = Constant::getNullValue(retty);
                tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER));
                retval = ctx.builder.CreateInsertValue(retval, gf_ret, 0);
                retval = ctx.builder.CreateInsertValue(retval, tindex, 1);
                ctx.builder.CreateRet(retval);
                break;
            }
            case jl_returninfo_t::Ghosts: {
                gf_retval = convert_julia_type_to_union(ctx, gf_retval, rettype, false);
                Value *retval = compute_tindex_unboxed(ctx, gf_retval, rettype);
                ctx.builder.CreateRet(retval);
                break;
            }
        - source: "code"
          path: "src/codegen.cpp"
          loc: "8053-8137"
          url: "https://github.com/JuliaLang/julia/blob/2fe1efb65ccc68dad2017b7bb26f1dd36abc798f/src/codegen.cpp#L8053-L8137"
          snippet: |
            else if (jl_is_uniontype(jlrettype)) {
                bool allunbox;
                size_t return_roots;
                union_alloca_type((jl_uniontype_t*)jlrettype, allunbox, props.union_bytes, props.union_align,
                        props.union_minalign, return_roots);
                tracked_count = return_roots;
                if (props.union_bytes == 0 && return_roots > 0) {
                    // convert all_roots to only union_bytes
                    props.union_bytes = return_roots * sizeof(void*);
                    props.union_minalign = props.union_align = sizeof(void*);
                    //return_roots = 0;
                    //all_roots = true;
                }
                props.return_roots = (int) return_roots;
                if (props.union_bytes) {
                    props.cc = jl_returninfo_t::Union;
                    fsig.push_back(PointerType::getUnqual(M->getContext()));
                    argnames.push_back("union_bytes_return");
                    Type *pair[] = { T_prjlvalue, getInt8Ty(M->getContext()) };
                    rt = StructType::get(M->getContext(), ArrayRef<Type*>(pair));
                }
                else if (allunbox) {
                    props.cc = jl_returninfo_t::Ghosts;
                    rt = getInt8Ty(M->getContext());
                }
                else {
                    rt = T_prjlvalue;
                }
            }

            if (props.cc == jl_returninfo_t::Union) {
                AttrBuilder param(M->getContext());
                if (all_roots) {
                    assert(!props.return_roots);
                    param.addAttribute("julia.return_roots", std::to_string(tracked_count));
                }
                param.addAttribute(Attribute::NoAlias);
                param.addAttribute(Attribute::NoCapture);
                param.addAttribute(Attribute::NoUndef);
                attrs.push_back(AttributeSet::get(M->getContext(), param));
                assert(fsig.size() == 1);
            }
  secondary_effects:
    - effect: "Union-typed loads/stores share a single path that loads/stores the union tag (ptindex) via typed_load/typed_store helpers, reducing inconsistencies between union array and memory ref handling."
      mechanism: |
        typed_store(ctx, ptr, rhs, ..., ptindex, tbaa_ptindex)  [src/cgutils.cpp:2504-2660]
          -> store_union(...) stores tag byte into ptindex and calls emit_unionmove(...)  [src/cgutils.cpp:2545-2552]
          -> emit_unionmove(...) dispatches per-union member and writes payload  [src/cgutils.cpp:4153-4228]
        typed_load(ctx, ..., ptindex, tbaa_ptindex)  [src/cgutils.cpp:2384-2405]
          -> emit_load_tindex(...) loads tag byte with range metadata  [src/cgutils.cpp:2370-2379]
          -> mark_julia_slot(..., tindex, ...) for union value  [src/cgutils.cpp:2391-2405]
      downstream_surfaces:
        - "Union array element codegen (e.g., union-typed array loads/stores)"
        - "MemoryRef/atomic pointer operations that route through typed_load/typed_store"
      likelihood: "high"
      impact: "medium"
    - effect: "Union phi nodes with inline roots create ptr phi and root phis even when storage is only needed for inline roots, preventing missing root slots in IR."
      mechanism: |
        emit_phinode_assign(...)  [src/codegen.cpp:5886-5950]
          -> try_emit_union_alloca(...) computes inline_roots  [src/codegen.cpp:5910-5913]
          -> if (dest || allunbox || inline_roots) create Tindex_phi and root_phi nodes  [src/codegen.cpp:5913-5925]
          -> if (dest || inline_roots) create ptr_phi and set tbaa  [src/codegen.cpp:5927-5943]
          -> mark_julia_slot(..., roots) populates PhiNodes entry  [src/codegen.cpp:5944-5949]
      downstream_surfaces:
        - "Codegen of union return values and phi nodes with inline roots"
        - "GC root tracking for union values in SSA form"
      likelihood: "high"
      impact: "medium"
    - effect: "Union return ABI forces union_bytes storage when return_roots exist but union_bytes is 0, routing return roots through the union calling convention." 
      mechanism: |
        get_specsig_function(...)  [src/codegen.cpp:8033-8137]
          -> union_alloca_type(..., return_roots)  [src/codegen.cpp:8055-8057]
          -> if union_bytes == 0 && return_roots > 0, set union_bytes and align  [src/codegen.cpp:8059-8063]
          -> cc = Union, add "julia.return_roots" attr when all_roots  [src/codegen.cpp:8128-8134]
        emit_specsig_to_specsig(...) uses convert_julia_type_to_union for Union/Ghosts returns  [src/codegen.cpp:7136-7169]
      downstream_surfaces:
        - "ABI for functions returning unions with inline roots"
        - "OpaqueClosure/return value rooting paths" 
      likelihood: "medium"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "StoreKind (new enum)"
        change: "Replaces multiple boolean flags in typed_store/atomic pointer helpers and affects internal call sites in cgutils.cpp/intrinsics.cpp."
        affected_tools:
          - tool: "Julia codegen internals"
            usage: "Internal helper typed_store signature and call sites in src/cgutils.cpp and src/intrinsics.cpp."
    behavioral:
      - change: "Union phi nodes with inline roots now create root PHI nodes even when no direct union payload alloca exists, changing LLVM IR root placement."
        risk: "low"
  performance:
    compile_time:
      - impact: "ESTIMATED: neutral to slight improvement from sharing aliased load/store helpers; no new passes added."
    runtime:
      - impact: "ESTIMATED: neutral; union store/load logic is refactored but still emits the same operations plus consistent tag handling."
  risk:
    level: "medium"
    rationale:
      - "Touches core codegen paths for unions and atomic pointer ops (cgutils.cpp, intrinsics.cpp)."
      - "Adds new union phi handling and ABI adjustments that can affect GC root placement in LLVM IR."
  open_questions:
    - "Are there additional union layouts with inline roots and no payload (union_bytes == 0) that require dedicated regression tests beyond union_phi_inline_roots?"
    - "Do downstream tooling users (e.g., IR inspection tools) rely on previous union phi pointer behavior, and should they update tests for new root PHI patterns?"
  recommendations:
    - "Add another test covering union return with inline roots where union_bytes == 0 to validate the new union_bytes promotion path."
    - "Monitor codegen output for union array element loads/stores to ensure ptindex handling does not regress alias metadata in specialized contexts."
