schema_version: "1.0"
pr:
  number: 59841
  title: "Libdl: Add documentation for LazyLibrary and friends"
  url: "https://github.com/JuliaLang/julia/pull/59841"
  author: "vtjnash"
  labels:
    - "docs"
    - "stdlib"
  merged_at: "2025-10-17T19:12:02Z"
  merge_commit_sha: "298f8ad81dffebef3fd34f4153f33b366f2583f4"
  diff_url: "https://github.com/JuliaLang/julia/pull/59841.diff"
scope:
  files_touched:
    - "Compiler/src/abstractinterpretation.jl"
    - "base/libdl.jl"
    - "doc/src/manual/calling-c-and-fortran-code.md"
    - "stdlib/Libdl/docs/src/index.md"
    - "stdlib/Libdl/src/Libdl.jl"
  components:
    - "Compiler.AbstractInterpretation"
    - "Libdl"
    - "Docs"
  pipeline_stages:
    - "TypeInference"
analysis:
  intent:
    summary: "Add and expand documentation for Libdl.LazyLibrary (manual + docstrings), clarify lazy-loading guidance, and fix the LazyLibrary dependency initializer to copy the provided dependency vector."
    issue_links: []
  direct_changes:
    - summary: "Expanded LazyLibrary/LazyLibraryPath/BundledLazyLibraryPath/add_dependency! docstrings with examples and compatibility notes, and clarified LazyLibrary constructor semantics." 
      component: "Libdl"
      evidence:
        - source: "code"
          path: "base/libdl.jl"
          loc: "321-483"
          url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/base/libdl.jl#L321-L483"
          snippet: |
            """
                LazyLibraryPath(path_pieces...)

            Helper type for lazily constructed library paths for use with [`LazyLibrary`](@ref).
            Path pieces are stored unevaluated and joined with `joinpath()` when the library is first
            accessed. Arguments must be able to have `string()` called on them.

            # Example

            ```julia
            const mylib = LazyLibrary(LazyLibraryPath(artifact_dir, "lib", "libmylib.so.1.2.3"))
            ```

            !!! compat "Julia 1.11"
                `LazyLibraryPath` was added in Julia 1.11.

            See also [`LazyLibrary`](@ref), [`BundledLazyLibraryPath`](@ref).
            """
            struct LazyLibraryPath
                pieces::Tuple{Vararg{Any}}
                LazyLibraryPath(pieces...) = new(pieces)
            end
            @inline Base.string(llp::LazyLibraryPath) = joinpath(String[string(p) for p in llp.pieces])
            Base.cconvert(::Type{Cstring}, llp::LazyLibraryPath) = Base.cconvert(Cstring, string(llp))
            # Define `print` so that we can wrap this in a `LazyString`
            Base.print(io::IO, llp::LazyLibraryPath) = print(io, string(llp))

            """
                BundledLazyLibraryPath(subpath)

            Helper type for lazily constructed library paths within the Julia distribution.
            Constructs paths relative to Julia's private shared library directory.

            Primarily used by Julia's standard library. For example:
            ```julia
            const libgmp = LazyLibrary(BundledLazyLibraryPath("libgmp.so.10"))
            ```

            !!! compat "Julia 1.11"
                `BundledLazyLibraryPath` was added in Julia 1.11.

            See also [`LazyLibrary`](@ref), [`LazyLibraryPath`](@ref).
            """
            BundledLazyLibraryPath(subpath) = LazyLibraryPath(PrivateShlibdirGetter(), subpath)

            """
                LazyLibrary(name; flags = <default dlopen flags>,
                            dependencies = LazyLibrary[], on_load_callback = nothing)

            Represents a lazily-loaded shared library that delays loading itself and its dependencies
            until first use in a `ccall()`, `@ccall`, `dlopen()`, `dlsym()`, `dlpath()`, or `cglobal()`.
            This is a thread-safe mechanism for on-demand library initialization.
            """
            mutable struct LazyLibrary
                # Name and flags to open with
                const path
                const flags::UInt32

                # Dependencies that must be loaded before we can load
                #
                # The OncePerProcess is introduced here so that any registered dependencies are
                # always ephemeral to a given process (instead of, e.g., persisting depending
                # on whether they were added in the process where this LazyLibrary was created)
                dependencies::Base.OncePerProcess{Vector{LazyLibrary}, InitialDependencies{LazyLibrary}}

                # Function that get called once upon initial load
                on_load_callback
                const lock::Base.ReentrantLock

                # Pointer that we eventually fill out upon first `dlopen()`
                @atomic handle::Ptr{Cvoid}
                function LazyLibrary(path; flags = default_rtld_flags, dependencies = LazyLibrary[],
                                     on_load_callback = nothing)
                    return new(
                        path,
                        UInt32(flags),
                        Base.OncePerProcess{Vector{LazyLibrary}}(
                            InitialDependencies{LazyLibrary}(dependencies)
                        ),
                        on_load_callback,
                        Base.ReentrantLock(),
                        C_NULL,
                    )
                end
            end

            """
                add_dependency!(library::LazyLibrary, dependency::LazyLibrary)

            Dynamically add a dependency that must be loaded before `library`. Only needed when
            dependencies cannot be determined at construction time.

            !!! warning
                Dependencies added with this function are **ephemeral** and only persist within the
                current process. They will not persist across precompilation boundaries.
            """
            function add_dependency!(ll::LazyLibrary, dep::LazyLibrary)
                @lock ll.lock begin
                    push!(ll.dependencies(), dep)
                end
            end
    - summary: "Added a comprehensive manual section on LazyLibrary usage with examples for platform-specific libraries, dependencies, lazy paths, and initialization callbacks." 
      component: "Docs"
      evidence:
        - source: "docs"
          path: "doc/src/manual/calling-c-and-fortran-code.md"
          loc: "853-1027"
          url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/doc/src/manual/calling-c-and-fortran-code.md#L853-L1027"
          snippet: |
            ## Non-constant Function Specifications

            In some cases, the exact name or path of the needed library is not known in
            advance and must be computed at run time. To handle such cases, the library
            component specification can be a value such as `Libdl.LazyLibrary`. The runtime
            will call `Libdl.dlopen` on that object when first used by a `ccall`.

            ### [Using LazyLibrary for Lazy Loading](@id man-lazylibrary)

            [`Libdl.LazyLibrary`](@ref) provides a thread-safe mechanism for deferring library loading
            until first use. This is the recommended approach for library initialization in modern Julia code.

            A `LazyLibrary` represents a library that opens itself (and its dependencies) automatically
            on first use in a `ccall()`, `@ccall`, `dlopen()`, `dlsym()`, `dlpath()`, or `cglobal()`.
            The library is loaded exactly once in a thread-safe manner, and subsequent calls reuse the
            loaded library handle.

            #### Basic Usage

            ```julia
            using Libdl

            # Define a LazyLibrary as a const for optimal performance
            const libz = LazyLibrary("libz")

            # Use directly in @ccall - library loads automatically on first call
            @ccall libz.deflate(strm::Ptr{Cvoid}, flush::Cint)::Cint

            # Also works with ccall
            ccall((:inflate, libz), Cint, (Ptr{Cvoid}, Cint), strm, flush)
            ```

            #### Platform-Specific Libraries

            For code that needs to work across different platforms:

            ```julia
            const mylib = LazyLibrary(
                if Sys.iswindows()
                    "mylib.dll"
                elseif Sys.isapple()
                    "libmylib.dylib"
                else
                    "libmylib.so"
                end
            )
            ```

            #### Libraries with Dependencies

            When a library depends on other libraries, specify the dependencies to ensure
            they load in the correct order:

            ```julia
            const libfoo = LazyLibrary("libfoo")
            const libbar = LazyLibrary("libbar"; dependencies=[libfoo])

            # When libbar is first used, libfoo is loaded first automatically
            @ccall libbar.bar_function(x::Cint)::Cint
            ```

            #### Lazy Path Construction

            For libraries whose paths are determined at runtime, use `LazyLibraryPath`:

            ```julia
            # Path is constructed when library is first accessed
            const mylib = LazyLibrary(LazyLibraryPath(artifact_dir, "lib", "libmylib.so"))
            ```

            #### Initialization Callbacks

            If a library requires initialization after loading:

            ```julia
            const mylib = LazyLibrary("libmylib";
                on_load_callback = () -> @ccall mylib.initialize()::Cvoid
            )
            ```

            !!! warning
                The `on_load_callback` should be minimal and must not call `wait()` on any tasks.
                It is called exactly once by the thread that loads the library.
            ```
            const mylibvar = LazyLibrary("mylib")
            @ccall $(@dlsym(dlopen(mylibvar), "myfunc"))()::Cvoid
            ```
    - summary: "Registered `add_dependency!` as a public Libdl API and included it in the Libdl docs index." 
      component: "Libdl"
      evidence:
        - source: "code"
          path: "stdlib/Libdl/src/Libdl.jl"
          loc: "10-19"
          url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/stdlib/Libdl/src/Libdl.jl#L10-L19"
          snippet: |
            export DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,
                RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,
                dlpath, find_library, dlext, dllist, LazyLibrary, LazyLibraryPath, BundledLazyLibraryPath

            public add_dependency!

            import Base.Libc.Libdl: DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,
                                    RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,
                                    dlpath, find_library, dlext, dllist, LazyLibrary, LazyLibraryPath,
                                    BundledLazyLibraryPath, default_rtld_flags, add_dependency!
        - source: "docs"
          path: "stdlib/Libdl/docs/src/index.md"
          loc: "25-31"
          url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/stdlib/Libdl/docs/src/index.md#L25-L31"
          snippet: |
            # Lazy Library Loading

            ```@docs
            Libdl.LazyLibrary
            Libdl.LazyLibraryPath
            Libdl.BundledLazyLibraryPath
            Libdl.add_dependency!
            ```
    - summary: "Clarified inference commentary for foreigncall evaluation without altering runtime behavior." 
      component: "Compiler.AbstractInterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "3483-3497"
          url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/Compiler/src/abstractinterpretation.jl#L3483-L3497"
          snippet: |
            function abstract_eval_foreigncall(interp::AbstractInterpreter, e::Expr, sstate::StatementState, sv::AbsIntState)
                callee = e.args[1]
                if isexpr(callee, :tuple)
                    if length(callee.args) >= 1
                        # Evaluate the arguments to constrain the world, effects, and other info for codegen,
                        # but note there is an implied `if !=(C_NULL)` branch here that might read data
                        # in a different world (the exact cache behavior is unspecified), so we do not use
                        # these results to refine reachability of the subsequent foreigncall.
                        abstract_eval_value(interp, callee.args[1], sstate, sv)
                        if length(callee.args) >= 2
                            abstract_eval_value(interp, callee.args[2], sstate, sv)
                            #TODO: implement abstract_eval_nonlinearized_foreigncall_name correctly?
                            # lib_effects = abstract_call(interp, ArgInfo(e.args, Any[typeof(Libdl.dlopen), lib]), sstate, sv)::Future
                        end
                    end
                else
                    abstract_eval_value(interp, callee, sstate, sv)
                end
    - summary: "Existing stdlib test continues to validate LazyLibrary dependency lists for JLLs (no new tests added in this PR)." 
      component: "Tests"
      evidence:
        - source: "code"
          path: "test/stdlib_dependencies.jl"
          loc: "203-249"
          url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/test/stdlib_dependencies.jl#L203-L249"
          snippet: |
            @testset "Stdlib JLL dependency check" begin
                for (_, (stdlib_name, _)) in Pkg.Types.stdlibs()
                    if !endswith(stdlib_name, "_jll")
                        continue
                    end

                    # Import the stdlib, skip it if it's not available on this platform
                    m = eval(Meta.parse("import $(stdlib_name); $(stdlib_name)"))
                    if !Base.invokelatest(getproperty(m, :is_available))
                        continue
                    end

                    for prop_name in names(m)
                        prop = getproperty(m, prop_name)
                        if isa(prop, Libdl.LazyLibrary)
                            lib_path = dlpath(prop)
                            lazy_lib_deps = strip_soversion.(basename.(dlpath.(prop.dependencies())))
                            real_lib_deps = filter(!is_system_lib, get_deps_objectfile(lib_path))

                            # See if there are missing dependencies in the lazy library deps
                            missing_deps = setdiff(real_lib_deps, lazy_lib_deps)
                            extraneous_deps = setdiff(lazy_lib_deps, real_lib_deps)

                            # We expect there to be no missing or extraneous deps
                            deps_mismatch = !isempty(missing_deps) || !isempty(extraneous_deps)
  secondary_effects:
    - effect: "Downstream packages can treat `add_dependency!` as a documented public API for dynamic dependency wiring (e.g., libblastrampoline_jll)."
      mechanism: |
        Libdl module marks add_dependency! as public  [stdlib/Libdl/src/Libdl.jl:10-19]
        -> stdlib/libblastrampoline_jll delegates to Libdl.add_dependency! for dynamic BLAS dependencies  [stdlib/libblastrampoline_jll/src/libblastrampoline_jll.jl:28-31]
      downstream_surfaces:
        - "Libdl.add_dependency!"
        - "libblastrampoline_jll LazyLibrary dependency wiring"
      likelihood: "high"
      impact: "low"
  compatibility:
    internal_api:
      - field: "Libdl.add_dependency! (public API marker)"
        change: "Now declared public in Libdl module; downstream tooling can rely on it as part of Libdl's public surface."
        affected_tools:
          - tool: "libblastrampoline_jll"
            usage: "Calls Libdl.add_dependency! to register dynamic BLAS dependencies." 
        evidence:
          - source: "code"
            path: "stdlib/Libdl/src/Libdl.jl"
            loc: "10-19"
            url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/stdlib/Libdl/src/Libdl.jl#L10-L19"
            snippet: |
              export DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,
                  RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,
                  dlpath, find_library, dlext, dllist, LazyLibrary, LazyLibraryPath, BundledLazyLibraryPath

              public add_dependency!

              import Base.Libc.Libdl: DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,
                                      RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,
                                      dlpath, find_library, dlext, dllist, LazyLibrary, LazyLibraryPath,
                                      BundledLazyLibraryPath, default_rtld_flags, add_dependency!
          - source: "code"
            path: "stdlib/libblastrampoline_jll/src/libblastrampoline_jll.jl"
            loc: "17-31"
            url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/stdlib/libblastrampoline_jll/src/libblastrampoline_jll.jl#L17-L31"
            snippet: |
              # Because LBT needs to have a weak-dependence on OpenBLAS (or any other BLAS)
              # we must manually construct a list of which modules and libraries we're going
              # to be using with it, as well as the on load callbacks they may or may not need.
              const on_load_callbacks::Vector{Function} = Function[]
              const eager_mode_modules::Vector{Module} = Module[]
              function libblastrampoline_on_load_callback()
                  for callback = on_load_callbacks
                      callback()
                  end
              end

              function add_dependency!(mod::Module, lib::LazyLibrary, on_load_callback::Function = () -> nothing)
                  Libdl.add_dependency!(libblastrampoline, lib)
                  push!(eager_mode_modules, mod)
                  push!(on_load_callbacks, on_load_callback)
              end
    behavioral:
      - item: "LazyLibrary dependency initializer now copies the provided vector without re-wrapping through Any."
        change: "InitialDependencies is now parameterized on element type and its callable returns copy(init.dependencies)."
        evidence:
          - source: "code"
            path: "base/libdl.jl"
            loc: "374-378"
            url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/base/libdl.jl#L374-L378"
            snippet: |
              # Small helper struct to initialize a LazyLibrary with its initial set of dependencies
              struct InitialDependencies{T}
                  dependencies::Vector{T}
              end
              (init::InitialDependencies)() = copy(init.dependencies)
  performance:
    compile_time:
      - item: "ESTIMATED: no measurable change; documentation-only edits plus a simple vector copy in dependency initialization."
        evidence:
          - source: "code"
            path: "base/libdl.jl"
            loc: "374-378"
            url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/base/libdl.jl#L374-L378"
            snippet: |
              struct InitialDependencies{T}
                  dependencies::Vector{T}
              end
              (init::InitialDependencies)() = copy(init.dependencies)
    runtime:
      - item: "ESTIMATED: no runtime behavior change; LazyLibrary loading semantics are unchanged aside from clearer documentation."
        evidence:
          - source: "docs"
            path: "doc/src/manual/calling-c-and-fortran-code.md"
            loc: "860-969"
            url: "https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/doc/src/manual/calling-c-and-fortran-code.md#L860-L969"
            snippet: |
              [`Libdl.LazyLibrary`](@ref) provides a thread-safe mechanism for deferring library loading
              until first use. This is the recommended approach for library initialization in modern Julia code.

              A `LazyLibrary` represents a library that opens itself (and its dependencies) automatically
              on first use in a `ccall()`, `@ccall`, `dlopen()`, `dlsym()`, `dlpath()`, or `cglobal()`.
              The library is loaded exactly once in a thread-safe manner, and subsequent calls reuse the
              loaded library handle.
  risk:
    level: "low"
    rationale:
      - "Core behavior is unchanged; the compiler edit is a comment-only clarification."
      - "The only codepath modification is a small dependency initializer refactor that preserves existing semantics for Vector{LazyLibrary} inputs."
  open_questions:
    - "Should LazyLibrary's constructor accept AbstractVector/tuple dependencies with implicit conversion, or is Vector{LazyLibrary} the intended contract going forward?"
  recommendations:
    - "Downstream packages should adopt the new LazyLibrary documentation section as the preferred guidance for lazy loading and dependency ordering."
