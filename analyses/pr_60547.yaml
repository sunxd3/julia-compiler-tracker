schema_version: "1.0"
pr:
  number: 60547
  title: "Avoid more `Core.Box` in Base (and Compiler)"
  url: "https://github.com/JuliaLang/julia/pull/60547"
  author: "KristofferC"
  labels:
    - "backport 1.13"
  merged_at: "2026-01-07T20:01:15Z"
  merge_commit_sha: "915a892ba340153b6d77084cb5f3d19108ea7874"
  diff_url: "https://github.com/JuliaLang/julia/pull/60547.diff"
scope:
  files_touched:
    - "Compiler/src/ssair/passes.jl"
    - "Compiler/src/ssair/show.jl"
    - "Compiler/src/typeinfer.jl"
    - "base/precompilation.jl"
    - "base/weakkeydict.jl"
  components:
    - "Compiler.SSAIR"
    - "Compiler.TypeInference"
    - "Compiler.Diagnostics"
    - "Base.Precompilation"
    - "Base.WeakKeyDict"
  pipeline_stages:
    - "SSA IR"
    - "TypeInference"
    - "Diagnostics"
    - "Precompilation"
analysis:
  intent:
    summary: "Reduce closure allocations that lead to `Core.Box` by extracting local closures into named helper functions and using `@lock` instead of `lock() do` blocks in Base and compiler code paths."
    issue_links: []
  direct_changes:
    - summary: "Extract recursive SSA insertion check into `_already_inserted_ssa` and keep a thin lambda wrapper to reduce closure capture in the compacting pass."
      component: "Compiler.SSAIR"
      evidence:
        - source: "code"
          path: "Compiler/src/ssair/passes.jl"
          loc: "360-383"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/Compiler/src/ssair/passes.jl#L360-L383"
          snippet: |
            function already_inserted(compact::IncrementalCompact, old::OldSSAValue)
                already_inserted_ssa(compact, compact.idx-1)(0, old)
            end

            function _already_inserted_ssa(compact::IncrementalCompact, processed_idx::Int,
                                           phi_arg::Int, old::OldSSAValue)
                id = old.id
                if id <= length(compact.ir.stmts)
                    return id <= processed_idx
                end
                id -= length(compact.ir.stmts)
                if id <= length(compact.ir.new_nodes)
                    return _already_inserted_ssa(compact, processed_idx, phi_arg,
                                                 OldSSAValue(compact.ir.new_nodes.info[id].pos))
                end
                id -= length(compact.ir.new_nodes)
                @assert id <= length(compact.pending_nodes)
                return !(id in compact.pending_perm)
            end

            function already_inserted_ssa(compact::IncrementalCompact, processed_idx::Int)
                return (phi_arg::Int, old::OldSSAValue) ->
                    _already_inserted_ssa(compact, processed_idx, phi_arg, old)
            end
        - source: "call_site"
          path: "Compiler/src/ssair/ir.jl"
          loc: "1459-1464"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/Compiler/src/ssair/ir.jl#L1459-L1464"
          note: "This file was NOT modified by the PR; shown as call site demonstrating usage of already_inserted_ssa"
          snippet: |
            function process_node!(compact::IncrementalCompact, result_idx::Int, inst::Instruction, idx::Int, processed_idx::Int, active_bb::Int, do_rename_ssa::Bool)
                stmt = inst[:stmt]
                (; result, ssa_rename, late_fixup, used_ssas, new_new_used_ssas) = compact
                (; cfg_transforms_enabled, fold_constant_branches, bb_rename_succ, bb_rename_pred, result_bbs) = compact.cfg_transform
                mark_refined! = Refiner(result.flag, result_idx)
                already_inserted_phi_arg = already_inserted_ssa(compact, processed_idx)  # <-- uses refactored function
    - summary: "Move finalizer insertion bookkeeping into `_update_finalizer_insert!` and iterate def-use lists with explicit loops instead of a captured closure."
      component: "Compiler.SSAIR"
      evidence:
        - source: "code"
          path: "Compiler/src/ssair/passes.jl"
          loc: "1655-1701"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/Compiler/src/ssair/passes.jl#L1655-L1701"
          note: "Lines 1655-1672 define _update_finalizer_insert!; lines 1674-1701 show try_resolve_finalizer! usage with explicit loops replacing the former closure"
          snippet: |
            function _update_finalizer_insert!(ir::IRCode, lazypostdomtree::LazyPostDomtree,
                                               finalizer_idx::Int, insert_bb::Int,
                                               insert_idx::Union{Int,Nothing}, x::Union{Int,SSAUse})
                defuse_idx = x isa SSAUse ? x.idx : x
                defuse_idx == finalizer_idx && return insert_bb, insert_idx
                defuse_bb = block_for_inst(ir, defuse_idx)
                new_insert_bb = nearest_common_dominator(get!(lazypostdomtree),
                    insert_bb, defuse_bb)
                if new_insert_bb == insert_bb && insert_idx !== nothing
                    insert_idx = max(insert_idx::Int, defuse_idx)
                elseif new_insert_bb == defuse_bb
                    insert_idx = defuse_idx
                else
                    insert_idx = nothing
                end
                insert_bb = new_insert_bb
                return insert_bb, insert_idx
            end

            function try_resolve_finalizer!(ir::IRCode, alloc_idx::Int, finalizer_idx::Int, defuse::SSADefUse,
                    inlining::InliningState, lazydomtree::LazyDomtree,
                    lazypostdomtree::LazyPostDomtree, @nospecialize(info::CallInfo))
                insert_bb::Int = finalizer_bb
                insert_idx::Union{Int,Nothing} = finalizer_idx
                for x in defuse.uses
                    insert_bb, insert_idx = _update_finalizer_insert!(ir, lazypostdomtree, finalizer_idx, insert_bb, insert_idx, x)
                end
                for x in defuse.defs
                    insert_bb, insert_idx = _update_finalizer_insert!(ir, lazypostdomtree, finalizer_idx, insert_bb, insert_idx, x)
                end
                insert_bb != 0 || return nothing
        - source: "code"
          path: "Compiler/src/ssair/passes.jl"
          loc: "1821-1831"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/Compiler/src/ssair/passes.jl#L1821-L1831"
          note: "Call site in sroa_mutables! showing usage of try_resolve_finalizer!"
          snippet: |
            finalizer_useidx = find_finalizer_useidx(defuse)
            if finalizer_useidx isa Int
                finalizer_idx = defuse.uses[finalizer_useidx].idx
                try_resolve_finalizer!(ir, defidx, finalizer_idx, defuse, inlining::InliningState,
                    lazydomtree, lazypostdomtree, ir[SSAValue(finalizer_idx)][:info])
                deleteat!(defuse.uses, finalizer_useidx)
                all_eliminated = all_forwarded = false # can't eliminate `setfield!` calls safely
            elseif !finalizer_useidx
                continue
            end
    - summary: "Refactor IR printing to use `printstyled` directly and extract `_print_ir_indentation` / `_print_ir_new_node` helpers, reducing closure capture in `show_ir_stmt`."
      component: "Compiler.Diagnostics"
      evidence:
        - source: "code"
          path: "Compiler/src/ssair/show.jl"
          loc: "534-566"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/Compiler/src/ssair/show.jl#L534-L566"
          snippet: |
            if !update_line_only && showtypes && !isa(frame.method, Symbol) && nctx != 1
                print(io, linestart)
                printstyled(io, indent("│"), color=linecolor)
                printstyled(io, "┌ invoke ", frame.method, color=linecolor)
                println(io)
                started = true
            end
            print(io, linestart)
            printstyled(io, indent("│"), color=linecolor)
            push!(context, frame)
            if update_line_only
                update_line_only = false
            else
                context_depth[] += 1
                nctx != 1 && printstyled(io, started ? "│" : "┌", color=linecolor)
            end
            printstyled(io, " @ ", frame.file, color=linecolor)
            if frame.line != typemax(frame.line) && frame.line != 0
                printstyled(io, ":", frame.line, color=linecolor)
            end
            printstyled(io, " within `", method_name(frame), "`", color=linecolor)
            if collapse
                method = method_name(frame)
                while nctx < nframes
                    frame = DI[nframes - nctx]
                    method_name(frame) === method || break
                    nctx += 1
                    push!(context, frame)
                    printstyled(io, " @ ", frame.file, ":", frame.line, color=linecolor)
                end
            end
            println(io)
        - source: "code"
          path: "Compiler/src/ssair/show.jl"
          loc: "680-732"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/Compiler/src/ssair/show.jl#L680-L732"
          note: "Two new helper functions extracted from show_ir_stmt: _print_ir_indentation (680-710) and _print_ir_new_node (712-732)"
          snippet: |
            function _print_ir_indentation(io::IO, cfg::CFG, bb_idx::Int, max_bb_idx_size::Int, bb_color,
                                           line_info_preprinter, idx::Int, i::Int; final::Bool=true)
                # Compute BB guard rail
                if bb_idx > length(cfg.blocks)
                    # If invariants are violated, print a special leader
                    linestart = " "^(max_bb_idx_size + 2) # not inside a basic block bracket
                    inlining_indent = line_info_preprinter(io, linestart, i == 1 ? idx : 0)
                    printstyled(io, "!!! ", "─"^max_bb_idx_size, color=bb_color)
                else
                    bbrange = cfg.blocks[bb_idx].stmts
                    linestart = idx == first(bbrange) ? "  " : sprint(io -> printstyled(io, "│ ", color=bb_color), context=io)
                    linestart *= " "^max_bb_idx_size
                    inlining_indent = line_info_preprinter(io, linestart, i == 1 ? idx : 0)
                    if i == 1 && idx == first(bbrange)
                        bb_idx_str = string(bb_idx)
                        bb_pad = max_bb_idx_size - length(bb_idx_str)
                        bb_type = length(cfg.blocks[bb_idx].preds) <= 1 ? "─" : "┄"
                        printstyled(io, bb_idx_str, " ", bb_type, "─"^bb_pad, color=bb_color)
                    elseif final && idx == last(bbrange)
                        printstyled(io, "└", "─"^(1 + max_bb_idx_size), color=bb_color)
                    else
                        printstyled(io, "│ ", " "^max_bb_idx_size, color=bb_color)
                    end
                end
                print(io, inlining_indent, " ")
                return nothing
            end

            function _print_ir_new_node(io::IO, node, code, sptypes::Vector{VarState}, used::BitSet, maxlength_idx::Int,
                                        label_dynamic_calls::Bool, line_info_postprinter, cfg::CFG, bb_idx::Int,
                                        max_bb_idx_size::Int, bb_color, line_info_preprinter, idx::Int, i::Int; final::Bool=true)
                _print_ir_indentation(io, cfg, bb_idx, max_bb_idx_size, bb_color, line_info_preprinter, idx, i; final)
                node_idx, new_node_inst, new_node_type = node
                @assert new_node_inst !== UNDEF
                show_type = should_print_ssa_type(new_node_inst)
                with_output_color(:green, io) do io′
                    print_stmt(io′, node_idx, new_node_inst, code, sptypes, used, maxlength_idx, false, show_type, label_dynamic_calls)
                end
                if new_node_type === UNDEF
                    printstyled(io, "::#UNDEF", color=:red)
                else
                    line_info_postprinter(io; type = new_node_type, used = node_idx in used, show_type, idx = node_idx)
                end
                println(io)
                return nothing
            end
    - summary: "Extract inference edge task scheduling to `_schedule_edge_infer_task!` for reuse in `typeinf_edge` without capturing large closures."
      component: "Compiler.TypeInference"
      evidence:
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "1107-1138"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/Compiler/src/typeinfer.jl#L1107-L1138"
          snippet: |
            function _schedule_edge_infer_task!(caller::AbsIntState, frame::InferenceState, result::InferenceResult,
                                                method::Method, edge_ci::Union{Nothing,CodeInstance},
                                                edgecycle::Bool, edgelimited::Bool)
                mresult = Future{MethodCallResult}()
                push!(caller.tasks, function get_infer_result(interp, caller)
                    update_valid_age!(caller, get_inference_world(interp), frame.valid_worlds)
                    isinferred = is_inferred(frame)
                    effects = nothing
                    edge = nothing
                    call_result = nothing
                    if isinferred
                        edge = result.ci
                        if edge_ci isa CodeInstance && codeinst_edges_sub(edge_ci, edge.min_world, edge.max_world, edge.edges)
                            edge = edge_ci # override the edge for tracking invalidation
                        end
                        result.ci_as_edge = edge # override the edge for tracking purposes
                        effects = result.ipo_effects # effects are adjusted already within `finish` for ipo_effects
                        call_result = result
                    else
                        effects = adjust_effects(effects_for_cycle(frame.ipo_effects), method)
                        add_cycle_backedge!(caller, frame)
                    end
                    bestguess = frame.bestguess
                    exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
                    # propagate newly inferred source to the inliner, allowing efficient inlining w/o deserialization:
                    # note that this result is cached globally exclusively, so we can use this local result destructively
                    mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,
                        edge, edgecycle, edgelimited, call_result)
                    return true
                end)
                return mresult
            end
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "1237-1241"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/Compiler/src/typeinfer.jl#L1237-L1241"
          snippet: |
            assign_parentchild!(frame, caller)
            # the actual inference task for this edge is going to be scheduled within `typeinf_local` via the callstack queue
            # while splitting off the rest of the work for this caller into a separate workq thunk
            return _schedule_edge_infer_task!(caller, frame, result, method, edge_ci, edgecycle, edgelimited)
    - summary: "Factor the indirect dependency walk in precompilation into `_visit_indirect_deps!` instead of an inner closure."
      component: "Base.Precompilation"
      evidence:
        - source: "code"
          path: "base/precompilation.jl"
          loc: "563-576"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/base/precompilation.jl#L563-L576"
          snippet: |
            function _visit_indirect_deps!(direct_deps::Dict{PkgId, Vector{PkgId}}, visited::Set{PkgId},
                                           node::PkgId, all_deps::Set{PkgId})
                if node in visited
                    return
                end
                push!(visited, node)
                for dep in get(Set{PkgId}, direct_deps, node)
                    if !(dep in all_deps)
                        push!(all_deps, dep)
                        _visit_indirect_deps!(direct_deps, visited, dep, all_deps)
                    end
                end
                return
            end
        - source: "code"
          path: "base/precompilation.jl"
          loc: "722-733"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/base/precompilation.jl#L722-L733"
          snippet: |
            function expand_indirect_dependencies(direct_deps)
                local indirect_deps = Dict{Base.PkgId, Set{Base.PkgId}}()
                for package in keys(direct_deps)
                    # Initialize a set to keep track of all dependencies for 'package'
                    all_deps = Set{Base.PkgId}()
                    visited = Set{Base.PkgId}()
                    _visit_indirect_deps!(direct_deps, visited, package, all_deps)
                    # Update direct_deps with the complete set of dependencies for 'package'
                    indirect_deps[package] = all_deps
                end
                return indirect_deps
            end
    - summary: "Switch WeakKeyDict iteration to `@lock` to avoid creating a closure for `lock(t) do` while preserving the iteration loop."
      component: "Base.WeakKeyDict"
      evidence:
        - source: "code"
          path: "base/weakkeydict.jl"
          loc: "197-210"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/base/weakkeydict.jl#L197-L210"
          snippet: |
            function iterate(t::WeakKeyDict{K,V}, state...) where {K, V}
                @lock t begin
                    while true
                        y = iterate(t.ht, state...)
                        y === nothing && return nothing
                        wkv, state = y
                        k = wkv[1].value
                        GC.safepoint() # ensure `k` is now gc-rooted
                        k === nothing && continue # indicates `k` is scheduled for deletion
                        kv = Pair{K,V}(k::K, wkv[2])
                        return (kv, state)
                    end
                end
            end
        - source: "test"
          path: "test/dict.jl"
          loc: "1008-1054"
          url: "https://github.com/JuliaLang/julia/blob/915a892ba340153b6d77084cb5f3d19108ea7874/test/dict.jl#L1008-L1054"
          snippet: |
            @testset "WeakKeyDict" begin
                A = [1]
                B = [2]
                C = [3]

                # construction
                wkd = WeakKeyDict()
                wkd[A] = 2
                wkd[B] = 3
                wkd[C] = 4
                dd = convert(Dict{Any,Any},wkd)
                @test WeakKeyDict(dd) == wkd
                @test convert(WeakKeyDict{Any, Any}, dd) == wkd
                @test isa(WeakKeyDict(dd), WeakKeyDict{Any,Any})
                @test WeakKeyDict(A=>2, B=>3, C=>4) == wkd
                @test isa(WeakKeyDict(A=>2, B=>3, C=>4), WeakKeyDict{Array{Int,1},Int})
                @test WeakKeyDict(a=>i+1 for (i,a) in enumerate([A,B,C]) ) == wkd
                @test WeakKeyDict([(A,2), (B,3), (C,4)]) == wkd
                @test WeakKeyDict{typeof(A), Int64}(Pair(A,2), Pair(B,3), Pair(C,4)) == wkd
                @test WeakKeyDict(Pair(A,2), Pair(B,3), Pair(C,4)) == wkd
                D = [[4.0]]
                @test WeakKeyDict(Pair(A,2), Pair(B,3), Pair(D,4.0)) isa WeakKeyDict{Any, Any}
                @test isa(WeakKeyDict(Pair(A,2), Pair(B,3.0), Pair(C,4)), WeakKeyDict{Array{Int,1},Any})
                @test isa(WeakKeyDict(Pair(convert(Vector{Number}, A),2), Pair(B,3), Pair(C,4)), WeakKeyDict{Any,Int})
                @test copy(wkd) == wkd

                @test length(wkd) == 3
                @test !isempty(wkd)
                res = pop!(wkd, C)
                @test res == 4
                @test length(wkd) == 2
                res = pop!(wkd, C, 3)
                @test res == 3
                @test C ∉ keys(wkd)
                @test 4 ∉ values(wkd)
                @test length(wkd) == 2
                @test !isempty(wkd)
                wkd = filter!( p -> p.first != B, wkd)
                @test B ∉ keys(wkd)
                @test 3 ∉ values(wkd)
                @test length(wkd) == 1
                @test WeakKeyDict(Pair(A, 2)) == wkd
                @test !isempty(wkd)

                wkd = empty!(wkd)
                @test wkd == empty(wkd)
                @test typeof(wkd) == typeof(empty(wkd))
                @test length(wkd) == 0
                @test isempty(wkd)
  secondary_effects:
    - effect: "Lowered allocation/boxing pressure from fewer captured closures in SSA compaction and finalizer-inlining bookkeeping."
      mechanism: |
        process_node!(...) calls already_inserted_ssa(compact, processed_idx)  [Compiler/src/ssair/ir.jl:1464 - call site, not modified]
          -> already_inserted_ssa(...) returns a thin lambda  [Compiler/src/ssair/passes.jl:380-383]
          -> _already_inserted_ssa(...) performs recursion without capturing local state  [Compiler/src/ssair/passes.jl:364-378]
        try_resolve_finalizer!(...) updates insertion placement  [Compiler/src/ssair/passes.jl:1674-1757]
          -> _update_finalizer_insert!(...) handles per-use updates  [Compiler/src/ssair/passes.jl:1655-1672]
      downstream_surfaces:
        - "Compiler SSA passes (IncrementalCompact, finalizer inlining)"
      likelihood: "high"
      impact: "low"
    - effect: "Reduced closure allocations in inference scheduling, potentially trimming inference-time allocations for large call graphs."
      mechanism: |
        typeinf_edge(...) schedules inference tasks for edges  [Compiler/src/typeinfer.jl:1141-1241]
          -> _schedule_edge_infer_task!(...) builds the task closure and returns a Future  [Compiler/src/typeinfer.jl:1107-1138]
      downstream_surfaces:
        - "Core.Compiler inference task queue"
        - "Inlining source propagation"
      likelihood: "medium"
      impact: "low"
    - effect: "IR pretty-printer and precompilation dependency walk avoid inner closures, reducing allocations in debugging and precompile paths."
      mechanism: |
        show_ir_stmt(...) uses _print_ir_indentation / _print_ir_new_node helpers  [Compiler/src/ssair/show.jl:680-732]
        expand_indirect_dependencies(...) calls _visit_indirect_deps! for DFS traversal  [base/precompilation.jl:722-733]
      downstream_surfaces:
        - "IR dumping / diagnostics (e.g., @code_typed display)"
        - "Base precompilation graph expansion"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api: []
    behavioral: []
  performance:
    compile_time:
      - "ESTIMATED: minor reduction in allocation/boxing overhead in compiler passes and inference task scheduling due to fewer captured closures."
    runtime:
      - "ESTIMATED: negligible runtime change for user code; changes are largely in compiler/debug/precompile utilities."
  risk:
    level: "low"
    rationale:
      - "Changes are refactors that preserve logic while moving closures to named helpers; no algorithmic behavior changes observed in compiler passes or Base utilities."
      - "Existing WeakKeyDict tests continue to exercise iteration and mutation semantics."
  open_questions:
    - "No new tests were added in this PR; are there any allocation regressions intended to be measured (e.g., via @allocated benchmarks) for the compiler paths touched?"
  recommendations:
    - "Consider adding a micro-benchmark or @allocated check for SSA IR printing/inference task scheduling if allocation regressions reappear."
    - "If future work changes finalizer inlining heuristics, add compiler-specific tests for try_resolve_finalizer! insertion behavior."
