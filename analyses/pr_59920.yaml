schema_version: "1.0"
pr:
  number: 59920
  title: "Backports for 1.12.2"
  url: "https://github.com/JuliaLang/julia/pull/59920"
  author: "KristofferC"
  labels:
    - "release"
    - "don't squash"
  merged_at: "2025-11-13T10:43:13Z"
  merge_commit_sha: "d9323c0906ff3e30835a8d1b5cae37e78667b6ea"
  diff_url: "https://github.com/JuliaLang/julia/pull/59920.diff"
scope:
  files_touched:
    - "Compiler/src/abstractinterpretation.jl"
    - "Compiler/src/tfuncs.jl"
    - "Compiler/src/typeinfer.jl"
    - "Compiler/test/effects.jl"
  components:
    - "Compiler.AbstractInterpretation"
    - "Compiler.Inference"
    - "Other"
  pipeline_stages:
    - "TypeInference"
    - "AbstractInterpretation"
    - "EffectsInference"
analysis:
  intent:
    summary: "Backport inference and effects fixes for the 1.12.2 release, including concrete-eval guardrails, cycle backedge handling, and pointer arithmetic tfunc behavior."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60009"
      - "https://github.com/JuliaLang/julia/pull/59908"
      - "https://github.com/JuliaLang/julia/pull/59974"
      - "https://github.com/JuliaLang/julia/pull/60011"
      - "https://github.com/JuliaLang/julia/pull/59921"
  direct_changes:
    - summary: "Guard concrete-evaluation results so external abstract interpreters can disable concrete-eval ad hoc without breaking const-prop fallback."
      component: "Compiler.AbstractInterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "865-899"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/abstractinterpretation.jl#L865-L899"
          snippet: |
            function abstract_call_method_with_const_args(interp::AbstractInterpreter,
                result::MethodCallResult, @nospecialize(f), arginfo::ArgInfo, si::StmtInfo,
                match::MethodMatch, sv::AbsIntState, invokecall::Union{Nothing,InvokeCall}=nothing)
                if bail_out_const_call(interp, result, si, match, sv)
                    return nothing
                end
                eligibility = concrete_eval_eligible(interp, f, result, arginfo, sv)
                concrete_eval_result = nothing
                if eligibility === :concrete_eval
                    concrete_eval_result = concrete_eval_call(interp, f, result, arginfo, sv, invokecall)
                    if (concrete_eval_result !== nothing &&  # allow external abstract interpreters to disable concrete evaluation ad-hoc
                        # if we don't inline the result of this concrete evaluation,
                        # give const-prop' a chance to inline a better method body
                        (!may_optimize(interp) ||
                         may_inline_concrete_result(concrete_eval_result.const_result::ConcreteResult) ||
                         concrete_eval_result.rt === Bottom)) # unless this call deterministically throws and thus is non-inlineable
                        return concrete_eval_result
                    end
                    # TODO allow semi-concrete interp for this call?
                end
                mi = maybe_get_const_prop_profitable(interp, result, f, arginfo, si, match, sv)
                mi === nothing && return concrete_eval_result
                if is_constprop_recursed(result, mi, sv)
                    add_remark!(interp, sv, "[constprop] Edge cycle encountered")
                    return nothing
                end
                # try semi-concrete evaluation
                if eligibility === :semi_concrete_eval
                    irinterp_result = semi_concrete_eval_call(interp, mi, result, arginfo, sv)
                    if irinterp_result !== nothing
                        return irinterp_result
                    end
                end
                # try constant prop'
                return const_prop_call(interp, mi, result, arginfo, sv, concrete_eval_result)
            end
    - summary: "Type-assert futures inside nonlinearized foreigncall evaluation to avoid ambiguous local variable types."
      component: "Compiler.AbstractInterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "3452-3488"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/abstractinterpretation.jl#L3452-L3488"
          snippet: |
            function abstract_eval_nonlinearized_foreigncall_name(
                    interp::AbstractInterpreter, @nospecialize(e), sstate::StatementState, sv::InferenceState
                )
                if isexpr(e, :call)
                    n = length(e.args)
                    argtypes = Vector{Any}(undef, n)
                    callresult = Future{CallMeta}()
                    i::Int = 1
                    nextstate::UInt8 = 0x0
                    local ai::Future, res::Future
                    function evalargs(interp, sv)
                        if nextstate === 0x1
                            @goto state1
                        elseif nextstate === 0x2
                            @goto state2
                        end
                        while i <= n
                            ai = abstract_eval_nonlinearized_foreigncall_name(interp, e.args[i], sstate, sv)
                            if !isready(ai)
                                nextstate = 0x1
                                return false
                                @label state1
                            end
                            argtypes[i] = ai[].rt
                            i += 1
                        end
                        res = abstract_call(interp, ArgInfo(e.args, argtypes), sstate, sv)
                        if !isready(res)
                            nextstate = 0x2
                            return false
                            @label state2
                        end
                        callresult[] = res[]
                        return true
                    end
                    evalargs(interp, sv) || push!(sv.tasks, evalargs)
                    return callresult
                else
                    return Future(abstract_eval_basic_statement(interp, e, sstate, sv))
                end
            end
    - summary: "Pointer arithmetic tfunc now widens const pointers, and the pointer add/sub tfunc hooks remain the call sites."
      component: "Compiler.Tfuncs"
      evidence:
        - source: "code"
          path: "Compiler/src/tfuncs.jl"
          loc: "715-717"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/tfuncs.jl#L715-L717"
          snippet: |
            @nospecs function pointerarith_tfunc(ùïÉ::AbstractLattice, ptr, offset)
                return widenconst(ptr)
            end
        - source: "code"
          path: "Compiler/src/tfuncs.jl"
          loc: "761-762"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/tfuncs.jl#L761-L762"
          snippet: |
            add_tfunc(add_ptr, 2, 2, pointerarith_tfunc, 1)
            add_tfunc(sub_ptr, 2, 2, pointerarith_tfunc, 1)
        - source: "test"
          path: "Compiler/test/effects.jl"
          loc: "1483-1487"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/test/effects.jl#L1483-L1487"
          snippet: |
            # https://github.com/JuliaLang/julia/issues/60009
            function null_offset(offset)
                Ptr{UInt8}(C_NULL) + offset
            end
            @test null_offset(Int(100)) == Ptr{UInt8}(UInt(100))
    - summary: "Cycle resolution no longer injects backedges during merge; backedges are now added explicitly when returning inferred/cycle results."
      component: "Compiler.TypeInference"
      evidence:
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "763-780"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/typeinfer.jl#L763-L780"
          snippet: |
            function merge_call_chain!(::AbstractInterpreter, parent::InferenceState, child::InferenceState)
                # update all cycleid to be in the same group
                frames = parent.callstack::Vector{AbsIntState}
                @assert child.callstack === frames
                ancestorid = child.cycleid
                # ensure that walking the callstack has the same cycleid (DAG)
                for frameid = reverse(ancestorid:length(frames))
                    frame = frames[frameid]::InferenceState
                    frame.cycleid == ancestorid && break
                    @assert frame.cycleid > ancestorid
                    frame.cycleid = ancestorid
                end
            end

            function add_cycle_backedge!(caller::InferenceState, frame::InferenceState)
                backedge = (caller, caller.currpc)
                contains_is(frame.cycle_backedges, backedge) || push!(frame.cycle_backedges, backedge)
                return frame
            end
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "966-1006"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/typeinfer.jl#L966-L1006"
          snippet: |
            let mresult = Future{MethodCallResult}()
                push!(caller.tasks, function get_infer_result(interp, caller)
                    update_valid_age!(caller, frame.world.valid_worlds)
                    local isinferred = is_inferred(frame)
                    local edge = isinferred ? edge_ci : nothing
                    local effects, valid_worlds
                    if isinferred
                        effects = frame.result.ipo_effects # effects are adjusted already within `finish` for ipo_effects
                    else
                        (effects, valid_worlds) = adjust_effects(effects_for_cycle(frame.ipo_effects), method, frame.world.this)
                        update_valid_age!(caller, valid_worlds)
                    end
                    local bestguess = frame.bestguess
                    local exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
                    # propagate newly inferred source to the inliner, allowing efficient inlining w/o deserialization:
                    # note that this result is cached globally exclusively, so we can use this local result destructively
                    local volatile_inf_result = if isinferred && edge_ci isa CodeInstance
                        result.ci_as_edge = edge_ci # set the edge for the inliner usage
                        VolatileInferenceResult(result)
                    end
                    isinferred || add_cycle_backedge!(caller, frame)
                    mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,
                        edge, edgecycle, edgelimited, volatile_inf_result)
                    return true
                end)
                return mresult
            end
            # return the current knowledge about this cycle
            frame = frame::InferenceState
            update_valid_age!(caller, frame.world.valid_worlds)
            (effects, valid_worlds) = adjust_effects(effects_for_cycle(frame.ipo_effects), method, frame.world.this)
            update_valid_age!(caller, valid_worlds)
            bestguess = frame.bestguess
            exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
            add_cycle_backedge!(caller, frame)
            return Future(MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects, nothing, edgecycle, edgelimited))
  secondary_effects:
    - effect: "External AbstractInterpreter implementations can return `nothing` from concrete evaluation without tripping const-prop access, letting const-prop or semi-concrete evaluation proceed."
      mechanism: |
        abstract_call_method_with_const_args(interp, result, f, arginfo, ...) [abstractinterpretation.jl:865]
          -> concrete_eval_eligible(interp, f, result, arginfo, sv) [abstractinterpretation.jl:871]
             returns :concrete_eval, :semi_concrete_eval, or :none
          -> concrete_eval_call(interp, f, result, arginfo, sv, invokecall) [abstractinterpretation.jl:874]
             CAN NOW RETURN nothing (previously always returned ConstCallResult)
          -> if concrete_eval_result !== nothing [abstractinterpretation.jl:875]
             NEW CHECK: allows nil return to skip early return
          -> maybe_get_const_prop_profitable(interp, result, ...) [abstractinterpretation.jl:885]
             falls through to const-prop when concrete eval disabled
          -> const_prop_call(interp, mi, result, arginfo, sv, concrete_eval_result) [abstractinterpretation.jl:899]
      downstream_surfaces:
        - "GPUCompiler.jl - uses custom AbstractInterpreter with overlay methods"
        - "JET.jl - custom interpreter may want to disable concrete eval for analysis"
        - "Const-prop/inlining decisions when concrete eval is disabled"
      likelihood: "medium"
      impact: "low"
      evidence:
        - source: "diff"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "874-882"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/abstractinterpretation.jl#L874-L882"
          snippet: |
            concrete_eval_result = concrete_eval_call(interp, f, result, arginfo, sv, invokecall)
            if (concrete_eval_result !== nothing &&  # allow external abstract interpreters to disable concrete evaluation ad-hoc
                (!may_optimize(interp) ||
                 may_inline_concrete_result(concrete_eval_result.const_result::ConcreteResult) ||
                 concrete_eval_result.rt === Bottom))
                return concrete_eval_result
            end
    - effect: "Pointer arithmetic on Const Ptr values now widens to non-Const pointer types, preventing overly precise const propagation around null-pointer arithmetic."
      mechanism: |
        pointerarith_tfunc(ùïÉ, ptr, offset) [tfuncs.jl:715-717]
          BEFORE: return ptr  (preserved Const wrapper)
          AFTER:  return widenconst(ptr)  (strips Const, keeps Ptr{T})
        add_tfunc(add_ptr, 2, 2, pointerarith_tfunc, 1) [tfuncs.jl:761]
        add_tfunc(sub_ptr, 2, 2, pointerarith_tfunc, 1) [tfuncs.jl:762]
          registers tfunc for Core.Intrinsics.add_ptr/sub_ptr
        Example: Const(Ptr{UInt8}(0)) + Int -> Ptr{UInt8} (not Const)
        Test: null_offset(Int(100)) == Ptr{UInt8}(UInt(100)) [effects.jl:1483-1487]
      downstream_surfaces:
        - "Inference of pointer arithmetic in Base/ccall code"
        - "Effects inference relying on pointer arithmetic stability"
        - "Generated functions using C_NULL pointer arithmetic"
      likelihood: "high"
      impact: "medium"
      evidence:
        - source: "diff"
          path: "Compiler/src/tfuncs.jl"
          loc: "715-717"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/tfuncs.jl#L715-L717"
          snippet: |
            @nospecs function pointerarith_tfunc(ùïÉ::AbstractLattice, ptr, offset)
                return widenconst(ptr)
            end
        - source: "test"
          path: "Compiler/test/effects.jl"
          loc: "1483-1487"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/test/effects.jl#L1483-L1487"
          snippet: |
            # https://github.com/JuliaLang/julia/issues/60009
            function null_offset(offset)
                Ptr{UInt8}(C_NULL) + offset
            end
            @test null_offset(Int(100)) == Ptr{UInt8}(UInt(100))
    - effect: "Cycle backedge recording is deferred to edge resolution sites, improving consistency of cycle backedges for in-flight inference frames."
      mechanism: |
        resolve_call_cycle!(interp, mi, parent) [typeinfer.jl:798-821]
          -> merge_call_chain!(interp, parent, frame) [typeinfer.jl:817]
             NOW: only updates cycleid for frames in the cycle
             BEFORE: also added backedges here
        typeinf_edge(interp, method, ..., caller) [typeinfer.jl:900-1006]
          -> if !isinferred: add_cycle_backedge!(caller, frame) [typeinfer.jl:986]
             NEW: backedge added when returning from task with unfinished frame
          -> at cycle return: add_cycle_backedge!(caller, frame) [typeinfer.jl:1005]
             NEW: backedge added when returning cycle knowledge
        Backedges consumed by:
          -> update_cycle_worklists!(callback, frame) [abstractinterpretation.jl:4149-4154]
             iterates frame.cycle_backedges to propagate updates
          -> adjust_cycle_frame!(sv, worlds, effects) [typeinfer.jl:284-296]
             updates effect flags on cycle callers
      downstream_surfaces:
        - "Inference cycle resolution and invalidation tracking"
        - "AbstractInterpreter consumers relying on cycle_backedges timing"
        - "Effect propagation through recursive call graphs"
      likelihood: "medium"
      impact: "medium"
      evidence:
        - source: "diff"
          path: "Compiler/src/typeinfer.jl"
          loc: "986"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/typeinfer.jl#L986"
          snippet: |
            isinferred || add_cycle_backedge!(caller, frame)
        - source: "diff"
          path: "Compiler/src/typeinfer.jl"
          loc: "1005"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/typeinfer.jl#L1005"
          snippet: |
            add_cycle_backedge!(caller, frame)
  compatibility:
    internal_api:
      - summary: "add_cycle_backedge! is now called at specific edge resolution points rather than during merge_call_chain!"
        evidence:
          - source: "code"
            path: "Compiler/src/typeinfer.jl"
            loc: "777-780"
            url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/typeinfer.jl#L777-L780"
            snippet: |
              function add_cycle_backedge!(caller::InferenceState, frame::InferenceState)
                  backedge = (caller, caller.currpc)
                  contains_is(frame.cycle_backedges, backedge) || push!(frame.cycle_backedges, backedge)
                  return frame
              end
      - summary: "concrete_eval_call may now return nothing for external AbstractInterpreter implementations"
        evidence:
          - source: "code"
            path: "Compiler/src/abstractinterpretation.jl"
            loc: "874-882"
            url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/abstractinterpretation.jl#L874-L882"
            snippet: |
              concrete_eval_result = concrete_eval_call(interp, f, result, arginfo, sv, invokecall)
              if (concrete_eval_result !== nothing &&  # allow external abstract interpreters to disable concrete evaluation ad-hoc
                  # if we don't inline the result of this concrete evaluation,
                  # give const-prop' a chance to inline a better method body
                  (!may_optimize(interp) ||
                   may_inline_concrete_result(concrete_eval_result.const_result::ConcreteResult) ||
                   concrete_eval_result.rt === Bottom)) # unless this call deterministically throws and thus is non-inlineable
                  return concrete_eval_result
              end
    behavioral:
      - summary: "Inference for pointer arithmetic on Const Ptr values now widens to the underlying pointer type rather than preserving Const, which can change inferred types for C_NULL + offset patterns."
        evidence:
          - source: "code"
            path: "Compiler/src/tfuncs.jl"
            loc: "715-717"
            url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/tfuncs.jl#L715-L717"
            snippet: |
              @nospecs function pointerarith_tfunc(ùïÉ::AbstractLattice, ptr, offset)
                  return widenconst(ptr)
              end
          - source: "test"
            path: "Compiler/test/effects.jl"
            loc: "1483-1487"
            url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/test/effects.jl#L1483-L1487"
            snippet: |
              # https://github.com/JuliaLang/julia/issues/60009
              function null_offset(offset)
                  Ptr{UInt8}(C_NULL) + offset
              end
              @test null_offset(Int(100)) == Ptr{UInt8}(UInt(100))
  tests:
    changed_files:
      - "Compiler/test/effects.jl"
    new_behavior_assertions:
      - "null_offset test verifies pointer arithmetic on C_NULL produces correct result (issue #60009)"
    coverage_gaps:
      - "No explicit test for external AbstractInterpreter returning nothing from concrete_eval_call"
      - "No explicit test for cycle backedge timing changes in recursive inference scenarios"
  performance:
    compile_time:
      - summary: "ESTIMATED: Negligible overhead from additional nil check in concrete eval path"
        details: |
          The `concrete_eval_result !== nothing` check adds one pointer comparison
          per concrete_eval_eligible call. This is O(1) and dwarfed by the cost
          of concrete evaluation or const-prop that follows.
      - summary: "ESTIMATED: Potential slight speedup in cycle resolution by deferring backedge insertion"
        details: |
          Backedges are now added only at edge resolution sites (typeinf_edge return)
          rather than during merge_call_chain. This may reduce redundant insertions
          in complex recursive call graphs, but effect is likely negligible.
    runtime: []
  risk:
    level: "medium"
    rationale:
      - "Type inference cycle handling changed backedge insertion timing, which can affect invalidation behavior in edge cases."
      - "Pointer arithmetic inference now widens Const pointers; downstream tooling depending on exact Const propagation may see different inferred types."
  open_questions:
    - "Are there any downstream AbstractInterpreter implementations that relied on concrete_eval_call always returning a ConcreteResult rather than `nothing`?"
    - "Do any inference tooling tests need to be updated for widened Const pointer arithmetic types?"
    - "Does the changed timing of cycle_backedges insertion affect any downstream analysis tools that inspect inference state during inference?"
  recommendations:
    - "GPUCompiler.jl, JET.jl, and other AbstractInterpreter consumers should verify their concrete_eval_call overrides handle the new nil-return contract correctly."
    - "Packages using C_NULL pointer arithmetic in @generated functions or inference-sensitive code should add regression tests similar to null_offset (issue #60009)."
    - "Tools that inspect InferenceState.cycle_backedges during inference (not just after) should verify they handle the deferred insertion timing."
    - "Enzyme.jl and other autodiff tools that depend on precise type inference for pointer operations should verify pointer arithmetic inference results."
