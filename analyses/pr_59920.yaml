schema_version: "1.0"
pr:
  number: 59920
  title: "Backports for 1.12.2"
  url: "https://github.com/JuliaLang/julia/pull/59920"
  author: "KristofferC"
  labels:
    - "release"
    - "don't squash"
  merged_at: "2025-11-13T10:43:13Z"
  merge_commit_sha: "d9323c0906ff3e30835a8d1b5cae37e78667b6ea"
  diff_url: "https://github.com/JuliaLang/julia/pull/59920.diff"
scope:
  files_touched:
    - "Compiler/src/abstractinterpretation.jl"
    - "Compiler/src/tfuncs.jl"
    - "Compiler/src/typeinfer.jl"
    - "Compiler/test/effects.jl"
  components:
    - "Compiler.AbstractInterpretation"
    - "Compiler.TypeInference"
    - "Compiler.Tfuncs"
    - "Compiler.Tests"
  pipeline_stages:
    - "TypeInference"
    - "ConstProp"
    - "Effects"
analysis:
  intent:
    summary: "Backport inference and effects fixes for the 1.12.2 release, including concrete-eval guardrails, cycle backedge handling, and pointer arithmetic tfunc behavior."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60009"
  direct_changes:
    - summary: "Guard concrete-evaluation results so external abstract interpreters can disable concrete-eval ad hoc without breaking const-prop fallback."
      component: "Compiler.AbstractInterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "865-899"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/abstractinterpretation.jl#L865-L899"
          snippet: |
            function abstract_call_method_with_const_args(interp::AbstractInterpreter,
                result::MethodCallResult, @nospecialize(f), arginfo::ArgInfo, si::StmtInfo,
                match::MethodMatch, sv::AbsIntState, invokecall::Union{Nothing,InvokeCall}=nothing)
                if bail_out_const_call(interp, result, si, match, sv)
                    return nothing
                end
                eligibility = concrete_eval_eligible(interp, f, result, arginfo, sv)
                concrete_eval_result = nothing
                if eligibility === :concrete_eval
                    concrete_eval_result = concrete_eval_call(interp, f, result, arginfo, sv, invokecall)
                    if (concrete_eval_result !== nothing &&  # allow external abstract interpreters to disable concrete evaluation ad-hoc
                        # if we don't inline the result of this concrete evaluation,
                        # give const-prop' a chance to inline a better method body
                        (!may_optimize(interp) ||
                         may_inline_concrete_result(concrete_eval_result.const_result::ConcreteResult) ||
                         concrete_eval_result.rt === Bottom)) # unless this call deterministically throws and thus is non-inlineable
                        return concrete_eval_result
                    end
                    # TODO allow semi-concrete interp for this call?
                end
                mi = maybe_get_const_prop_profitable(interp, result, f, arginfo, si, match, sv)
                mi === nothing && return concrete_eval_result
                if is_constprop_recursed(result, mi, sv)
                    add_remark!(interp, sv, "[constprop] Edge cycle encountered")
                    return nothing
                end
                # try semi-concrete evaluation
                if eligibility === :semi_concrete_eval
                    irinterp_result = semi_concrete_eval_call(interp, mi, result, arginfo, sv)
                    if irinterp_result !== nothing
                        return irinterp_result
                    end
                end
                # try constant prop'
                return const_prop_call(interp, mi, result, arginfo, sv, concrete_eval_result)
            end
    - summary: "Type-assert futures inside nonlinearized foreigncall evaluation to avoid ambiguous local variable types."
      component: "Compiler.AbstractInterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "3452-3488"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/abstractinterpretation.jl#L3452-L3488"
          snippet: |
            function abstract_eval_nonlinearized_foreigncall_name(
                    interp::AbstractInterpreter, @nospecialize(e), sstate::StatementState, sv::InferenceState
                )
                if isexpr(e, :call)
                    n = length(e.args)
                    argtypes = Vector{Any}(undef, n)
                    callresult = Future{CallMeta}()
                    i::Int = 1
                    nextstate::UInt8 = 0x0
                    local ai::Future, res::Future
                    function evalargs(interp, sv)
                        if nextstate === 0x1
                            @goto state1
                        elseif nextstate === 0x2
                            @goto state2
                        end
                        while i <= n
                            ai = abstract_eval_nonlinearized_foreigncall_name(interp, e.args[i], sstate, sv)
                            if !isready(ai)
                                nextstate = 0x1
                                return false
                                @label state1
                            end
                            argtypes[i] = ai[].rt
                            i += 1
                        end
                        res = abstract_call(interp, ArgInfo(e.args, argtypes), sstate, sv)
                        if !isready(res)
                            nextstate = 0x2
                            return false
                            @label state2
                        end
                        callresult[] = res[]
                        return true
                    end
                    evalargs(interp, sv) || push!(sv.tasks, evalargs)
                    return callresult
                else
                    return Future(abstract_eval_basic_statement(interp, e, sstate, sv))
                end
            end
    - summary: "Pointer arithmetic tfunc now widens const pointers, and the pointer add/sub tfunc hooks remain the call sites."
      component: "Compiler.Tfuncs"
      evidence:
        - source: "code"
          path: "Compiler/src/tfuncs.jl"
          loc: "715-717"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/tfuncs.jl#L715-L717"
          snippet: |
            @nospecs function pointerarith_tfunc(ùïÉ::AbstractLattice, ptr, offset)
                return widenconst(ptr)
            end
        - source: "code"
          path: "Compiler/src/tfuncs.jl"
          loc: "761-762"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/tfuncs.jl#L761-L762"
          snippet: |
            add_tfunc(add_ptr, 2, 2, pointerarith_tfunc, 1)
            add_tfunc(sub_ptr, 2, 2, pointerarith_tfunc, 1)
        - source: "test"
          path: "Compiler/test/effects.jl"
          loc: "1483-1487"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/test/effects.jl#L1483-L1487"
          snippet: |
            # https://github.com/JuliaLang/julia/issues/60009
            function null_offset(offset)
                Ptr{UInt8}(C_NULL) + offset
            end
            @test null_offset(Int(100)) == Ptr{UInt8}(UInt(100))
    - summary: "Cycle resolution no longer injects backedges during merge; backedges are now added explicitly when returning inferred/cycle results."
      component: "Compiler.TypeInference"
      evidence:
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "763-780"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/typeinfer.jl#L763-L780"
          snippet: |
            function merge_call_chain!(::AbstractInterpreter, parent::InferenceState, child::InferenceState)
                # update all cycleid to be in the same group
                frames = parent.callstack::Vector{AbsIntState}
                @assert child.callstack === frames
                ancestorid = child.cycleid
                # ensure that walking the callstack has the same cycleid (DAG)
                for frameid = reverse(ancestorid:length(frames))
                    frame = frames[frameid]::InferenceState
                    frame.cycleid == ancestorid && break
                    @assert frame.cycleid > ancestorid
                    frame.cycleid = ancestorid
                end
            end

            function add_cycle_backedge!(caller::InferenceState, frame::InferenceState)
                backedge = (caller, caller.currpc)
                contains_is(frame.cycle_backedges, backedge) || push!(frame.cycle_backedges, backedge)
                return frame
            end
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "966-1006"
          url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/typeinfer.jl#L966-L1006"
          snippet: |
            let mresult = Future{MethodCallResult}()
                push!(caller.tasks, function get_infer_result(interp, caller)
                    update_valid_age!(caller, frame.world.valid_worlds)
                    local isinferred = is_inferred(frame)
                    local edge = isinferred ? edge_ci : nothing
                    local effects, valid_worlds
                    if isinferred
                        effects = frame.result.ipo_effects # effects are adjusted already within `finish` for ipo_effects
                    else
                        (effects, valid_worlds) = adjust_effects(effects_for_cycle(frame.ipo_effects), method, frame.world.this)
                        update_valid_age!(caller, valid_worlds)
                    end
                    local bestguess = frame.bestguess
                    local exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
                    # propagate newly inferred source to the inliner, allowing efficient inlining w/o deserialization:
                    # note that this result is cached globally exclusively, so we can use this local result destructively
                    local volatile_inf_result = if isinferred && edge_ci isa CodeInstance
                        result.ci_as_edge = edge_ci # set the edge for the inliner usage
                        VolatileInferenceResult(result)
                    end
                    isinferred || add_cycle_backedge!(caller, frame)
                    mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,
                        edge, edgecycle, edgelimited, volatile_inf_result)
                    return true
                end)
                return mresult
            end
            # return the current knowledge about this cycle
            frame = frame::InferenceState
            update_valid_age!(caller, frame.world.valid_worlds)
            (effects, valid_worlds) = adjust_effects(effects_for_cycle(frame.ipo_effects), method, frame.world.this)
            update_valid_age!(caller, valid_worlds)
            bestguess = frame.bestguess
            exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
            add_cycle_backedge!(caller, frame)
            return Future(MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects, nothing, edgecycle, edgelimited))
  secondary_effects:
    - effect: "External AbstractInterpreter implementations can return `nothing` from concrete evaluation without tripping const-prop access, letting const-prop or semi-concrete evaluation proceed."
      mechanism: |
        abstract_call_method_with_const_args(...) [Compiler/src/abstractinterpretation.jl:865-899]
          calls concrete_eval_call(...)
          -> skips the const-prop eligibility check unless concrete_eval_result !== nothing
          -> falls through to maybe_get_const_prop_profitable(...) and const_prop_call(...)
      downstream_surfaces:
        - "External AbstractInterpreter implementations"
        - "Const-prop/inlining decisions when concrete eval is disabled"
      likelihood: "medium"
      impact: "low"
    - effect: "Pointer arithmetic on Const Ptr values now widens to non-Const pointer types, preventing overly precise const propagation around null-pointer arithmetic."
      mechanism: |
        pointerarith_tfunc(...) [Compiler/src/tfuncs.jl:715-717]
          returns widenconst(ptr)
        add_tfunc(add_ptr/sub_ptr, pointerarith_tfunc, ...) [Compiler/src/tfuncs.jl:761-762]
          ensures Ptr +/- Int uses widened pointer inference
        null_offset test covers C_NULL + offset -> Ptr{UInt8}(UInt(100)) [Compiler/test/effects.jl:1483-1487]
      downstream_surfaces:
        - "Inference of pointer arithmetic in Base/ccall code"
        - "Effects inference relying on pointer arithmetic stability"
      likelihood: "high"
      impact: "medium"
    - effect: "Cycle backedge recording is deferred to edge resolution sites, improving consistency of cycle backedges for in-flight inference frames."
      mechanism: |
        resolve_call_cycle!(...) -> merge_call_chain!(...) updates cycleid only [Compiler/src/typeinfer.jl:763-818]
        typeinf_edge(...) adds backedges when returning inferred or cycle results [Compiler/src/typeinfer.jl:966-1006]
      downstream_surfaces:
        - "Inference cycle resolution and invalidation tracking"
        - "AbstractInterpreter consumers relying on cycle_backedges"
      likelihood: "medium"
      impact: "medium"
  compatibility:
    internal_api: []
    behavioral:
      - summary: "Inference for pointer arithmetic on Const Ptr values now widens to the underlying pointer type rather than preserving Const, which can change inferred types for C_NULL + offset patterns."
        evidence:
          - source: "code"
            path: "Compiler/src/tfuncs.jl"
            loc: "715-717"
            url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/tfuncs.jl#L715-L717"
            snippet: |
              @nospecs function pointerarith_tfunc(ùïÉ::AbstractLattice, ptr, offset)
                  return widenconst(ptr)
              end
          - source: "test"
            path: "Compiler/test/effects.jl"
            loc: "1483-1487"
            url: "https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/test/effects.jl#L1483-L1487"
            snippet: |
              # https://github.com/JuliaLang/julia/issues/60009
              function null_offset(offset)
                  Ptr{UInt8}(C_NULL) + offset
              end
              @test null_offset(Int(100)) == Ptr{UInt8}(UInt(100))
  performance:
    compile_time: []
    runtime: []
  risk:
    level: "medium"
    rationale:
      - "Type inference cycle handling changed backedge insertion timing, which can affect invalidation behavior in edge cases."
      - "Pointer arithmetic inference now widens Const pointers; downstream tooling depending on exact Const propagation may see different inferred types."
  open_questions:
    - "Are there any downstream AbstractInterpreter implementations that relied on concrete_eval_call always returning a ConcreteResult rather than `nothing`?"
    - "Do any inference tooling tests need to be updated for widened Const pointer arithmetic types?"
  recommendations:
    - "Downstream tools implementing AbstractInterpreter should confirm their concrete_eval_call hooks tolerate returning `nothing` without assuming a ConcreteResult."
    - "Packages that depend on Const pointer inference (e.g., C_NULL arithmetic in generated code) should add regression tests similar to null_offset."
