schema_version: "1.0"
pr:
  number: 60168
  title: "[JuliaLowering] get macro name in `ctx.world`; fix lowering iterator"
  url: "https://github.com/JuliaLang/julia/pull/60168"
  author: "mlechu"
  labels:
    - "compiler:lowering"
  merged_at: "2025-11-24T23:22:51Z"
  merge_commit_sha: "8a0e033ee94bc4dca6524691fe5c884bb3d60c74"
  diff_url: "https://github.com/JuliaLang/julia/pull/60168.diff"
scope:
  files_touched:
    - "JuliaLowering/src/eval.jl"
    - "JuliaLowering/src/macro_expansion.jl"
    - "JuliaLowering/test/macros.jl"
    - "JuliaLowering/test/macros_ir.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "MacroExpansion"
    - "Lowering"
    - "Eval"
analysis:
  intent:
    summary: >-
      Ensure macro name resolution happens in the same world age used for
      lowering/expansion, and make the lowering iterator update world age between
      steps so toplevel macro definitions are immediately visible.
    issue_links: []
  direct_changes:
    - summary: >-
        Macro name evaluation now resolves GlobalRef/identifier/dot forms via
        Base.invoke_in_world using ctx.macro_world and only falls back to
        lowering + jl_toplevel_eval for complex expressions.
      component: "JuliaLowering/src/macro_expansion.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/macro_expansion.jl"
          loc: "161-206"
          url: "https://github.com/JuliaLang/julia/blob/8a0e033ee94bc4dca6524691fe5c884bb3d60c74/JuliaLowering/src/macro_expansion.jl#L161-L206"
          snippet: |
            function _eval_dot(world::UInt, mod, ex::SyntaxTree)
                if kind(ex) === K"."
                    mod = _eval_dot(world, mod, ex[1])
                    ex = ex[2]
                end
                kind(ex) in KSet"Identifier Symbol" && mod isa Module ?
                    Base.invoke_in_world(world, getproperty, mod, Symbol(ex.name_val)) :
                    nothing
            end

            function eval_macro_name(ctx::MacroExpansionContext, mctx::MacroContext, ex0::SyntaxTree)
                mod = current_layer(ctx).mod
                ex = fixup_macro_name(ctx, expand_forms_1(ctx, ex0))
                try
                    if kind(ex) === K"Value"
                        !(ex.value isa GlobalRef) ? ex.value :
                            Base.invoke_in_world(ctx.macro_world, getglobal,
                                                 ex.value.mod, ex.value.name)
                    elseif kind(ex) === K"Identifier"
                        layer = get(ex, :scope_layer, nothing)
                        if !isnothing(layer)
                            mod = ctx.scope_layers[layer].mod
                        end
                        Base.invoke_in_world(ctx.macro_world, getproperty,
                                             mod, Symbol(ex.name_val))
                    elseif kind(ex) === K"." &&
                            (ed = _eval_dot(ctx.macro_world, mod, ex); !isnothing(ed))
                        ed
                    else
                        ctx2, ex2 = expand_forms_2(ctx, ex)
                        ctx3, ex3 = resolve_scopes(ctx2, ex2)
                        ctx4, ex4 = convert_closures(ctx3, ex3)
                        ctx5, ex5 = linearize_ir(ctx4, ex4)
                        expr_form = to_lowered_expr(ex5)
                        ccall(:jl_toplevel_eval, Any, (Any, Any), mod, expr_form)
                    end
                catch err
                    throw(MacroExpansionError(mctx, ex, "Macro not found", :all, err))
                end
            end
    - summary: >-
        The lowering iterator no longer stores a MacroExpansionContext; it now
        takes the module + world per step, re-expands forms with the passed
        world, and eval uses a module stack to drive :begin_module/:end_module
        transitions.
      component: "JuliaLowering/src/eval.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/eval.jl"
          loc: "35-93"
          url: "https://github.com/JuliaLang/julia/blob/8a0e033ee94bc4dca6524691fe5c884bb3d60c74/JuliaLowering/src/eval.jl#L35-L93"
          snippet: |
            struct LoweringIterator{GraphType}
                expr_compat_mode::Bool # later stored in module?
                todo::Vector{Tuple{SyntaxTree{GraphType}, Bool, Int}}
            end

            function lower_init(ex::SyntaxTree{T};
                                expr_compat_mode::Bool=false) where {T}
                LoweringIterator{T}(expr_compat_mode, [(ex, false, 0)])
            end

            function lower_step(iter, mod, world=Base.get_world_counter())
                if isempty(iter.todo)
                    return Core.svec(:done)
                end

                top_ex, is_module_body, child_idx = pop!(iter.todo)
                if child_idx > 0
                    if child_idx <= numchildren(top_ex)
                        push!(iter.todo, (top_ex, is_module_body, child_idx + 1))
                        ex = top_ex[child_idx]
                    elseif is_module_body
                        return Core.svec(:end_module)
                    else
                        return lower_step(iter, mod)
                    end
                else
                    ex = top_ex
                end

                k = kind(ex)
                if !(k in KSet"toplevel module")
                    ctx1, ex = expand_forms_1(mod, ex, iter.expr_compat_mode, world)
                    k = kind(ex)
                end
                if k == K"toplevel"
                    push!(iter.todo, (ex, false, 1))
                    return lower_step(iter, mod)
                elseif k == K"module"
                    name = ex[1]
                    if kind(name) != K"Identifier"
                        throw(LoweringError(name, "Expected module name"))
                    end
                    newmod_name = Symbol(name.name_val)
                    body = ex[2]
                    if kind(body) != K"block"
                        throw(LoweringError(body, "Expected block in module body"))
                    end
                    std_defs = !has_flags(ex, JuliaSyntax.BARE_MODULE_FLAG)
                    loc = source_location(LineNumberNode, ex)
                    push!(iter.todo, (body, true, 1))
                    return Core.svec(:begin_module, newmod_name, std_defs, loc)
                else
                    ctx2, ex2 = expand_forms_2(ctx1, ex)
                    ctx3, ex3 = resolve_scopes(ctx2, ex2)
                    ctx4, ex4 = convert_closures(ctx3, ex3)
                    ctx5, ex5 = linearize_ir(ctx4, ex4)
                    thunk = to_lowered_expr(ex5)
                    return Core.svec(:thunk, thunk)
                end
            end
        - source: "code"
          path: "JuliaLowering/src/eval.jl"
          loc: "461-484"
          url: "https://github.com/JuliaLang/julia/blob/8a0e033ee94bc4dca6524691fe5c884bb3d60c74/JuliaLowering/src/eval.jl#L461-L484"
          snippet: |
            function _eval(mod, iter)
                modules = Module[mod]
                result = nothing
                while true
                    thunk = lower_step(iter, modules[end])::Core.SimpleVector
                    type = thunk[1]::Symbol
                    if type == :done
                        break
                    elseif type == :begin_module
                        filename = something(thunk[4].file, :none)
                        mod = @ccall jl_begin_new_module(
                            modules[end]::Any, thunk[2]::Symbol, thunk[3]::Cint,
                            filename::Cstring, thunk[4].line::Cint)::Module
                        push!(modules, mod)
                    elseif type == :end_module
                        @ccall jl_end_new_module(modules[end]::Module)::Cvoid
                        result = pop!(modules)
                    else
                        @assert type == :thunk
                        result = Core.eval(modules[end], thunk[2])
                    end
                end
                @assert length(modules) === 1
                return result
            end
  secondary_effects:
    - effect: >-
        Macro expansion now resolves macro names in the world age captured by
        ctx.macro_world for identifiers, GlobalRefs, and dotted module paths,
        reducing mismatches between lowering world age and macro lookup.
      mechanism: |
        expand_macro(ctx, ex)  [macro_expansion.jl:281-307]
          -> eval_macro_name(ctx, mctx, macname)  [macro_expansion.jl:175-206]
             -> Base.invoke_in_world(ctx.macro_world, getproperty/getglobal) for
                Identifier/GlobalRef/dot paths  [macro_expansion.jl:161-206]
      downstream_surfaces:
        - "Macro resolution for packages that define macros during precompilation"
        - "Macro tools expecting world-age-consistent lookup (e.g., hygienic macro loaders)"
      likelihood: "high"
      impact: "medium"
    - effect: >-
        Toplevel macro definitions produced by macro expansion become visible to
        subsequent lowering iterator steps because lower_step uses the current
        world age and eval drives a module stack per step.
      mechanism: |
        _eval(mod, iter)  [eval.jl:461-484]
          -> lower_step(iter, modules[end], world=Base.get_world_counter())
             expands forms with expand_forms_1(..., world)  [eval.jl:45-93]
          -> newly defined macros are seen by later steps at updated world age
      downstream_surfaces:
        - "JuliaLowering.include_string/toplevel macro pipelines"
        - "Macros that generate new macros in module or toplevel expressions"
      likelihood: "medium"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "LoweringIterator"
        change: >-
          LoweringIterator now stores only expr_compat_mode + todo; lower_init no
          longer takes (mod, macro_world), and lower_step now requires (iter, mod,
          world) rather than (iter, push_mod).
        affected_tools: []
      - field: "eval_macro_name"
        change: >-
          Macro name lookup prefers invoke_in_world for identifier/GlobalRef/dot
          paths before falling back to jl_toplevel_eval.
        affected_tools: []
    behavioral:
      - change: >-
          Macro name evaluation uses ctx.macro_world for identifiers/dots,
          aligning macro lookup with the lowering world age.
        evidence:
          - source: "code"
            path: "JuliaLowering/src/macro_expansion.jl"
            loc: "161-206"
            url: "https://github.com/JuliaLang/julia/blob/8a0e033ee94bc4dca6524691fe5c884bb3d60c74/JuliaLowering/src/macro_expansion.jl#L161-L206"
            snippet: |
              function _eval_dot(world::UInt, mod, ex::SyntaxTree)
                  if kind(ex) === K"."
                      mod = _eval_dot(world, mod, ex[1])
                      ex = ex[2]
                  end
                  kind(ex) in KSet"Identifier Symbol" && mod isa Module ?
                      Base.invoke_in_world(world, getproperty, mod, Symbol(ex.name_val)) :
                      nothing
              end

              function eval_macro_name(ctx::MacroExpansionContext, mctx::MacroContext, ex0::SyntaxTree)
                  mod = current_layer(ctx).mod
                  ex = fixup_macro_name(ctx, expand_forms_1(ctx, ex0))
                  try
                      if kind(ex) === K"Value"
                          !(ex.value isa GlobalRef) ? ex.value :
                              Base.invoke_in_world(ctx.macro_world, getglobal,
                                                   ex.value.mod, ex.value.name)
                      elseif kind(ex) === K"Identifier"
                          layer = get(ex, :scope_layer, nothing)
                          if !isnothing(layer)
                              mod = ctx.scope_layers[layer].mod
                          end
                          Base.invoke_in_world(ctx.macro_world, getproperty,
                                               mod, Symbol(ex.name_val))
                      elseif kind(ex) === K"." &&
                              (ed = _eval_dot(ctx.macro_world, mod, ex); !isnothing(ed))
                          ed
                      else
                          ctx2, ex2 = expand_forms_2(ctx, ex)
                          ctx3, ex3 = resolve_scopes(ctx2, ex2)
                          ctx4, ex4 = convert_closures(ctx3, ex3)
                          ctx5, ex5 = linearize_ir(ctx4, ex4)
                          expr_form = to_lowered_expr(ex5)
                          ccall(:jl_toplevel_eval, Any, (Any, Any), mod, expr_form)
                      end
                  catch err
                      throw(MacroExpansionError(mctx, ex, "Macro not found", :all, err))
                  end
              end
      - change: >-
          Macros that define macros in toplevel expansions are now exercised by
          tests; lower_step/world handling allows these definitions to be
          visible within the same include_string call.
        evidence:
          - source: "test"
            path: "JuliaLowering/test/macros.jl"
            loc: "521-538"
            url: "https://github.com/JuliaLang/julia/blob/8a0e033ee94bc4dca6524691fe5c884bb3d60c74/JuliaLowering/test/macros.jl#L521-L538"
            snippet: |
              @testset "macros defining macros" begin
                  @eval test_mod macro make_and_use_macro_toplevel()
                      Expr(:toplevel,
                           esc(:(macro from_toplevel_expansion()
                                 :(123)
                             end)),
                           esc(:(@from_toplevel_expansion())))
                  end

                  @test JuliaLowering.include_string(
                      test_mod, "@make_and_use_macro_toplevel()"; expr_compat_mode=true) === 123

                  if isdefined(test_mod, Symbol("@from_toplevel_expansion"))
                      Base.delete_binding(test_mod, Symbol("@from_toplevel_expansion"))
                  end

                  @test JuliaLowering.include_string(
                      test_mod, "@make_and_use_macro_toplevel()"; expr_compat_mode=false) === 123
              end
  performance:
    compile_time:
      - impact: >-
          ESTIMATED: negligible overhead from evaluating macro identifiers via
          invoke_in_world and from passing world into lower_step; no additional
          tree walks beyond existing expansion pipeline.
    runtime:
      - impact: >-
          ESTIMATED: no runtime impact on generated code; changes are confined
          to lowering/eval and macro expansion paths.
  risk:
    level: "medium"
    rationale:
      - "Macro name evaluation now depends on scope-layer module + world age; regressions would surface as macro-not-found or wrong-module lookup in tooling." 
      - "Lowering iterator API changes could affect downstream consumers that call lower_step directly (internal JuliaLowering API)."
  open_questions:
    - >-
      Should non-identifier macro names evaluated via jl_toplevel_eval also use
      ctx.macro_world (currently noted as TODO in code)?
  recommendations:
    - >-
      Downstream tooling that invokes JuliaLowering.lower_step or constructs
      LoweringIterator should update to pass module and optional world age per
      step instead of relying on stored MacroExpansionContext.
    - >-
      Macro tooling that uses dotted macro names should rely on module
      resolution in ctx.macro_world and avoid side-effectful macro-name
      expressions.
