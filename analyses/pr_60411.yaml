schema_version: "1.0"
pr:
  number: 60411
  title: "[JuliaLowering] Miscellaneous fixes for `SparseArrays` precompilation"
  url: "https://github.com/JuliaLang/julia/pull/60411"
  author: "topolarity"
  labels:
    - "bugfix"
    - "JuliaLowering"
  merged_at: "2025-12-18T18:53:04Z"
  merge_commit_sha: "3b1a5b6c52955394ac98772d0de36ffd66401fbc"
  diff_url: "https://github.com/JuliaLang/julia/pull/60411.diff"
scope:
  files_touched:
    - "JuliaLowering/src/compat.jl"
    - "JuliaLowering/src/desugaring.jl"
    - "JuliaLowering/src/eval.jl"
    - "JuliaLowering/test/compat.jl"
    - "JuliaLowering/test/macros.jl"
    - "JuliaLowering/test/typedefs.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Lowering"
analysis:
  intent:
    summary: "Fix JuliaLowering regressions encountered during SparseArrays precompilation, including Unicode operator handling, type-alias where expansion, and boundscheck lowering in expr compatibility mode."
    issue_links:
      - "https://github.com/JuliaLang/JuliaLowering.jl/issues/123"
  direct_changes:
    - summary: "Fix Unicode updating-assignment operators in expr->SyntaxTree conversion by slicing operator strings with `nextind`/`prevind`, avoiding invalid string indexing for multi-byte operators like `⊻=`."
      component: "JuliaLowering/src/compat.jl"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/compat.jl"
          loc: "240-252"
          url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/compat.jl#L240-L252"
          snippet: |
            if Base.isoperator(e.head) && st_k === K"None"
                # e.head is an updating assignment operator (+=, .-=, etc).  Non-=
                # dotted ops are wrapped in a call, so we don't reach this.
                s = string(e.head)
                @assert s[end] === '=' && nargs === 2
                if s[1] === '.'
                    st_k = K".op="
                    op = s[nextind(s,1):prevind(s,end)]
                else
                    st_k = K"op="
                    op = s[1:prevind(s,end)]
                end
                child_exprs = Any[e.args[1], Symbol(op), e.args[2]]
        - source: "test"
          path: "JuliaLowering/test/compat.jl"
          loc: "638-643"
          url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/test/compat.jl#L638-L643"
          snippet: |
            @testset "non-ASCII operator handling" begin
                # regression test for invalid string index
                @test JuliaLowering.include_string(test_mod, raw"""
                @noinline (x = 0xF; x ⊻= 1; x)
                """; expr_compat_mode=true) == 0xE
            end
    - summary: "Ensure `where` expansion for type-alias definitions with multiple type variables always wraps parameters in `braces`, preserving correct `UnionAll` structure."
      component: "JuliaLowering/src/desugaring.jl"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "1246-1259"
          url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/desugaring.jl#L1246-L1259"
          snippet: |
            function expand_unionall_def(ctx, srcref, lhs, rhs, is_const=true)
                if numchildren(lhs) <= 1
                    throw(LoweringError(lhs, "empty type parameter list in type alias"))
                end
                name = lhs[1]
                expand_forms_2(
                    ctx,
                    @ast ctx srcref [K"block"
                        rr := [K"where" rhs [K"braces" lhs[2:end]...]]
                        [is_const ? K"constdecl" : K"assign_or_constdecl_if_global" name rr]
                        [K"removable" rr]
                    ]
                )
            end
        - source: "test"
          path: "JuliaLowering/test/typedefs.jl"
          loc: "316-322"
          url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/test/typedefs.jl#L316-L322"
          snippet: |
            # Definition of type-alias with 2+ type-variables
            # See https://github.com/JuliaLang/JuliaLowering.jl/issues/123
            JuliaLowering.include_string(test_mod, """
            struct Foo{T,V,N}; end
            const Bar{T,V} = Foo{T,V,1}
            """)
            @test test_mod.Bar == (test_mod.Foo{T,V,1} where {T,V})
    - summary: "Add explicit boundscheck handling in lowered Expr conversion so `@boundscheck` forms survive expr compatibility mode."
      component: "JuliaLowering/src/eval.jl"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/eval.jl"
          loc: "426-448"
          url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/eval.jl#L426-L448"
          snippet: |
            # Allowed forms according to https://docs.julialang.org/en/v1/devdocs/ast/
            #
            # call invoke static_parameter `=` method struct_type abstract_type
            # primitive_type global const new splatnew isdefined
            # enter leave pop_exception inbounds boundscheck loopinfo copyast meta
            # lambda
            head = k == K"call"      ? :call       :
                   k == K"new"       ? :new        :
                   k == K"splatnew"  ? :splatnew   :
                   k == K"="         ? :(=)        :
                   k == K"leave"     ? :leave      :
                   k == K"isdefined" ? :isdefined  :
                   k == K"loopinfo"  ? :loopinfo   :
                   k == K"boundscheck"       ? :boundscheck       :
                   k == K"latestworld"       ? :latestworld       :
                   k == K"pop_exception"     ? :pop_exception     :
                   k == K"captured_local"    ? :captured_local    :
                   k == K"gc_preserve_begin" ? :gc_preserve_begin :
                   k == K"gc_preserve_end"   ? :gc_preserve_end   :
                   k == K"foreigncall"       ? :foreigncall       :
                   k == K"cfunction"         ? :cfunction         :
                   k == K"new_opaque_closure" ? :new_opaque_closure :
                   nothing
        - source: "test"
          path: "JuliaLowering/test/macros.jl"
          loc: "616-635"
          url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/test/macros.jl#L616-L635"
          snippet: |
            @testset "@boundscheck / @inbounds" begin
                JuliaLowering.include_string(test_mod, """
                function sum_inbounds(A::AbstractArray)
                    r = zero(eltype(A))
                    for i in eachindex(A)
                        @inbounds r += A[i]
                    end
                    return r
                end
                """; expr_compat_mode=true)
                @test test_mod.sum_inbounds([1,2,3]) == 6

                JuliaLowering.include_string(test_mod, """
                @inline function g_boundscheck(A, i)
                    @boundscheck checkbounds(A, i)
                    return A[i]
                end
                """; expr_compat_mode=true)
                @test test_mod.g_boundscheck(1:2, 2) == 2
            end
    - summary: "Assert that `where` expressions always have two children in `expand_wheres`, tightening invariants for desugaring."
      component: "JuliaLowering/src/desugaring.jl"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "4178-4207"
          url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/desugaring.jl#L4178-L4207"
          snippet: |
            function expand_where(ctx, srcref, lhs, rhs)
                bounds = analyze_typevar(ctx, rhs)
                v = bounds[1]
                @ast ctx srcref [K"let"
                    [K"block" [K"=" v bounds_to_TypeVar(ctx, srcref, bounds)]]
                    [K"call" "UnionAll"::K"core" v lhs]
                ]
            end

            function expand_wheres(ctx, ex)
                @chk numchildren(ex) == 2
                body = ex[1]
                rhs = ex[2]
                if kind(rhs) == K"braces"
                    # S{X,Y} where {X,Y}
                    for r in reverse(children(rhs))
                        body = expand_where(ctx, ex, body, r)
                    end
                elseif kind(rhs) == K"_typevars"
                    # Eg, `S{X,Y} where {X, Y}` but with X and Y
                    # already allocated `TypeVar`s
                    for r in reverse(children(rhs[1]))
                        body = @ast ctx ex [K"call" "UnionAll"::K"core" r body]
                    end
                else
                    # S{X} where X
                    body = expand_where(ctx, ex, body, rhs)
                end
                body
            end
  secondary_effects:
    - effect: "Expr compatibility mode now correctly lowers non-ASCII updating assignment operators like `⊻=` without raising string indexing errors."
      mechanism: |
        expr_to_syntaxtree(e, lnn)  [compat.jl:25-35]
          -> _insert_convert_expr(e, graph, src)  [compat.jl:186-252]
            -> operator slicing uses nextind/prevind for Unicode-safe indexing  [compat.jl:247,250]
        Before: s[2:end-1] fails on multi-byte chars like ⊻
        After: s[nextind(s,1):prevind(s,end)] correctly handles Unicode
      downstream_surfaces:
        - "Expr-producing macros relying on expr_to_syntaxtree (e.g., legacy macro expansion paths)"
        - "Precompilation paths in packages that emit updating operators (SparseArrays)"
      likelihood: "high"
      impact: "medium"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/compat.jl"
          loc: "247-250"
          url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/compat.jl#L247-L250"
          snippet: |
            op = s[nextind(s,1):prevind(s,end)]  # for .op= case
            op = s[1:prevind(s,end)]             # for op= case
    - effect: "Type-alias definitions with multiple type variables expand to `UnionAll` chains using braces, restoring expected `Foo{T,V,1} where {T,V}` structure."
      mechanism: |
        expand_assignment(ctx, ex, is_const)  [desugaring.jl:1268-1279]
          -> checks kl == K"curly" for type-alias LHS
          -> expand_unionall_def(ctx, srcref, lhs, rhs)  [desugaring.jl:1246-1259]
            -> emits rr := [K"where" rhs [K"braces" lhs[2:end]...]]
            -> braces wrapper ensures expand_wheres handles multiple params
          -> expand_wheres(ctx, ex) validates numchildren == 2  [desugaring.jl:4187-4207]
            -> K"braces" branch iterates over type vars in reverse
        Before: lhs[2:end]... was passed directly, breaking multi-param aliases
        After: [K"braces" lhs[2:end]...] wraps params for correct UnionAll nesting
      downstream_surfaces:
        - "Macro-generated type aliases with multiple parameters"
        - "Tools inspecting lowered type-alias `UnionAll` structure"
      likelihood: "medium"
      impact: "medium"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "1254"
          url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/desugaring.jl#L1254"
          snippet: |
            rr := [K"where" rhs [K"braces" lhs[2:end]...]]
    - effect: "`@boundscheck` forms survive expr compatibility lowering, enabling precompile-time evaluation of boundscheck wrappers."
      mechanism: |
        _to_lowered_expr(ex::SyntaxTree, stmt_offset::Int)  [eval.jl:330-458]
          -> maps K"boundscheck" -> :boundscheck Expr head  [eval.jl:439]
          -> used by eval(mod, ex::SyntaxTree)  [eval.jl:462-467]
        Before: K"boundscheck" was not in the head mapping, causing LoweringError
        After: boundscheck is recognized and converted to Expr(:boundscheck, ...)
      downstream_surfaces:
        - "Generated code that uses @boundscheck/@inbounds in expr_compat_mode"
        - "SparseArrays precompilation that relies on boundscheck wrappers"
      likelihood: "medium"
      impact: "low"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/eval.jl"
          loc: "439"
          url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/eval.jl#L439"
          snippet: |
            k == K"boundscheck"       ? :boundscheck       :
  compatibility:
    internal_api: []
    behavioral:
      - summary: "Behavioral fix: expr->SyntaxTree conversion no longer throws on Unicode updating operators in expr_compat_mode."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/compat.jl"
            loc: "638-643"
            url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/test/compat.jl#L638-L643"
            snippet: |
              @testset "non-ASCII operator handling" begin
                  @test JuliaLowering.include_string(test_mod, raw"""
                  @noinline (x = 0xF; x ⊻= 1; x)
                  """; expr_compat_mode=true) == 0xE
              end
      - summary: "Behavioral fix: type-alias `where` expansion now preserves multiple type-variable structure."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/typedefs.jl"
            loc: "316-322"
            url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/test/typedefs.jl#L316-L322"
            snippet: |
              JuliaLowering.include_string(test_mod, """
              struct Foo{T,V,N}; end
              const Bar{T,V} = Foo{T,V,1}
              """)
              @test test_mod.Bar == (test_mod.Foo{T,V,1} where {T,V})
      - summary: "Behavioral fix: boundscheck AST nodes are accepted in lowered Expr conversion."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/macros.jl"
            loc: "616-635"
            url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/test/macros.jl#L616-L635"
            snippet: |
              @testset "@boundscheck / @inbounds" begin
                  JuliaLowering.include_string(test_mod, """
                  function sum_inbounds(A::AbstractArray)
                      r = zero(eltype(A))
                      for i in eachindex(A)
                          @inbounds r += A[i]
                      end
                      return r
                  end
                  """; expr_compat_mode=true)
                  @test test_mod.sum_inbounds([1,2,3]) == 6
              end
  performance:
    compile_time:
      - summary: "ESTIMATED: negligible; changes are simple indexing/validation and do not add extra passes."
        evidence:
          - source: "diff"
            path: "JuliaLowering/src/compat.jl"
            loc: "247-250"
            url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/compat.jl#L247-L250"
            snippet: |
              # nextind/prevind are O(1) string operations
              op = s[nextind(s,1):prevind(s,end)]
    runtime:
      - summary: "ESTIMATED: none; modifications affect lowering/compatibility paths only."
        evidence:
          - source: "diff"
            path: "JuliaLowering/src/eval.jl"
            loc: "439"
            url: "https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/eval.jl#L439"
            snippet: |
              # Single pattern match addition in lowering, no runtime impact
              k == K"boundscheck"       ? :boundscheck       :
  tests:
    changed_files:
      - "JuliaLowering/test/compat.jl"
      - "JuliaLowering/test/macros.jl"
      - "JuliaLowering/test/typedefs.jl"
    new_behavior_assertions:
      - "Unicode updating operators (⊻=) work correctly in expr_compat_mode"
      - "Type-alias with multiple type variables produces correct UnionAll structure"
      - "@boundscheck and @inbounds work in expr_compat_mode"
    coverage_gaps: []
  risk:
    level: "low"
    rationale:
      - "Changes are localized to JuliaLowering compatibility/desugaring logic with targeted regression tests."
      - "No changes to inference, codegen, or runtime execution semantics beyond bug fixes."
      - "Each fix has a corresponding test case that exercises the corrected behavior."
  open_questions: []
  recommendations:
    - "Downstream tooling relying on expr_compat_mode should add coverage for Unicode updating operators and boundscheck forms similar to the new tests."
