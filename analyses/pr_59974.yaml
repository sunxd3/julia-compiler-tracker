schema_version: "1.0"
pr:
  number: 59974
  title: "inference: revisit all methods in cycle"
  url: "https://github.com/JuliaLang/julia/pull/59974"
  author: "vtjnash"
  labels:
    - "compiler:inference"
    - "backport 1.10"
    - "backport 1.11"
  merged_at: "2025-11-01T02:52:03Z"
  merge_commit_sha: "f4847bf687ab0fa37fdcd237512d5ec6486ae788"
  diff_url: "https://github.com/JuliaLang/julia/pull/59974.diff"
scope:
  files_touched:
    - "Compiler/src/typeinfer.jl"
  components:
    - "Compiler"
  pipeline_stages:
    - "TypeInference"
analysis:
  intent:
    summary: "Ensure inference revisits all methods in recursive cycles, preventing cached Union{} results; record backedges lazily to avoid allocations."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/59943"
  direct_changes:
    - summary: "Cycle merging only normalizes cycle IDs; no longer adds backedges during merge walk."
      component: "Compiler/src/typeinfer.jl"
      evidence:
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "893-905"
          url: "https://github.com/JuliaLang/julia/blob/f4847bf687ab0fa37fdcd237512d5ec6486ae788/Compiler/src/typeinfer.jl#L893-L905"
          snippet: |
            function merge_call_chain!(::AbstractInterpreter, parent::InferenceState, child::InferenceState)
                # update all cycleid to be in the same group
                frames = parent.callstack::Vector{AbsIntState}
                @assert child.callstack === frames
                ancestorid = child.cycleid
                # ensure that walking the callstack has the same cycleid (DAG)
                for frameid = reverse(ancestorid:length(frames))
                    frame = frames[frameid]::InferenceState
                    frame.cycleid == ancestorid && break
                    @assert frame.cycleid > ancestorid
                    frame.cycleid = ancestorid
                end
            end
    - summary: "Adding cycle backedge no longer updates caller world-age; only records (caller, pc) pair."
      component: "Compiler/src/typeinfer.jl"
      evidence:
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "907-911"
          url: "https://github.com/JuliaLang/julia/blob/f4847bf687ab0fa37fdcd237512d5ec6486ae788/Compiler/src/typeinfer.jl#L907-L911"
          snippet: |
            function add_cycle_backedge!(caller::InferenceState, frame::InferenceState)
                backedge = (caller, caller.currpc)
                contains_is(frame.cycle_backedges, backedge) || push!(frame.cycle_backedges, backedge)
                return frame
            end
    - summary: "Record cycle backedges at two points in typeinf_edge: (1) deferred task callback when inference incomplete, (2) immediate return for detected cycles."
      component: "Compiler/src/typeinfer.jl"
      evidence:
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "1111"
          url: "https://github.com/JuliaLang/julia/blob/f4847bf687ab0fa37fdcd237512d5ec6486ae788/Compiler/src/typeinfer.jl#L1111"
          snippet: |
            isinferred || add_cycle_backedge!(caller, frame)
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "1129"
          url: "https://github.com/JuliaLang/julia/blob/f4847bf687ab0fa37fdcd237512d5ec6486ae788/Compiler/src/typeinfer.jl#L1129"
          snippet: |
            add_cycle_backedge!(caller, frame)
  secondary_effects:
    - effect: "All call sites in a recursion cycle are re-visited when cycle effects are finalized, avoiding stale cached results (e.g., Union{})."
      mechanism: |
        resolve_call_cycle!(interp, mi, parent)  [typeinfer.jl:928-951]
          detects cycle and calls merge_call_chain! to unify cycleid values
          -> merge_call_chain!(interp, parent, frame)  [typeinfer.jl:893-905]
             only updates frame.cycleid, no longer adds backedges here
        typeinf_edge(...)  [typeinfer.jl:1096-1130]
          when returning results, adds backedges via add_cycle_backedge!
          -> add_cycle_backedge!(caller, frame)  [typeinfer.jl:907-911]
             records (caller, caller.currpc) in frame.cycle_backedges
        finish_cycle(interp, frames, cycleid, time_before)  [typeinfer.jl:250-312]
          -> adjust_cycle_frame!(caller, cycle_valid_worlds, cycle_valid_effects)  [typeinfer.jl:316-328]
             walks sv.cycle_backedges to update call-site effect flags
      downstream_surfaces:
        - "Inference caching and cycle revalidation"
        - "Effects propagation through recursive call graphs"
      likelihood: "high"
      impact: "medium"
    - effect: "World-age updates for cycle callers are now tied to explicit inference result usage rather than cycle-merge bookkeeping."
      mechanism: |
        Before this PR:
          add_cycle_backedge! called update_valid_age!(caller, frame.world.valid_worlds)
        After this PR:
          add_cycle_backedge! no longer updates valid age [typeinfer.jl:907-911]
          update_valid_age!(caller, frame.world.valid_worlds) remains in typeinf_edge
          at lines 1098 (deferred task) and 1125 (immediate return) before recording backedges
      downstream_surfaces:
        - "Inference world-range tracking for recursive edges"
      likelihood: "medium"
      impact: "low"
    - effect: "Cycle backedges are used by update_cycle_worklists! during abstract interpretation to propagate type refinements."
      mechanism: |
        update_cycle_worklists!(callback, frame)  [abstractinterpretation.jl:4135-4141]
          for (caller, caller_pc) in frame.cycle_backedges
            if callback(caller, caller_pc)
              push!(caller.ip, block_for_inst(caller.cfg, caller_pc))
        This function is called during type inference iteration to ensure
        that when a cycle frame's types change, all callers are re-queued
        for re-analysis at their call sites.
      downstream_surfaces:
        - "Type inference worklist management"
        - "Cycle convergence during abstract interpretation"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "InferenceState.cycle_backedges"
        change: "Field population timing changed: backedges now added at result consumption (typeinf_edge return) rather than during merge_call_chain! cycle detection"
        affected_tools:
          - "Tools inspecting InferenceState internals during inference"
    behavioral:
      - change: "Recursive inference cycles now guarantee call-site backedges are recorded when results are consumed, reducing chances of caching bottom (Union{}) without re-visitation."
        affected_surfaces:
          - "Core.Compiler inference cache"
  performance:
    compile_time:
      - impact: "ESTIMATED: negligible; backedges are still created lazily, but now only at result consumption sites. Avoids duplicate backedge creation during merge_call_chain! walk."
    runtime:
      - impact: "ESTIMATED: indirect improvements when recursive inference no longer caches Union{} and forces re-inference on call sites."
  risk:
    level: "medium"
    rationale:
      - "Touches recursion-cycle handling in type inference; changes when and where cycle backedges are recorded."
      - "Behavioral change is localized to recursive/cyclic call graphs, but could affect inference stability."
      - "PR has backport labels for 1.10 and 1.11, indicating it fixes a real regression."
  open_questions:
    - "Do we have a minimal reproducer for the cycle-within-cycle case described in #59943 to add as a regression test?"
    - "Are there edge cases where deferred task backedge recording (line 1111) might miss some cycle participants?"
  recommendations:
    - "Consider adding a focused regression test alongside existing cycle tests in Compiler/test/inference.jl to lock in the multi-cycle revisit behavior."
    - "Downstream tooling that inspects inference cache stability should re-run tests that involve recursive inference (e.g., analysis of code_typed for recursive functions)."
  evidence_tests:
    - summary: "Existing regression test for recursion cycles and cached Union{} return types (issue #21653)."
      path: "Compiler/test/inference.jl"
      loc: "1124-1133"
      url: "https://github.com/JuliaLang/julia/blob/f4847bf687ab0fa37fdcd237512d5ec6486ae788/Compiler/test/inference.jl#L1124-L1133"
      snippet: |
        # issue #21653
        # ensure that we don't try to resolve cycles using uncached edges
        # but which also means we should still be storing the inference result from inferring the cycle
        f21653() = f21653()
        @test code_typed(f21653, Tuple{}, optimize=false)[1] isa Pair{CodeInfo, typeof(Union{})}
        let meth = which(f21653, ())
            tt = Tuple{typeof(f21653)}
            mi = ccall(:jl_specializations_lookup, Any, (Any, Any), meth, tt)::Core.MethodInstance
            @test mi.cache.rettype === Union{}
        end
