schema_version: "1.0"
pr:
  number: 60410
  title: "[JuliaLowering] Add support for `Expr(:loopinfo, ...)`"
  url: "https://github.com/JuliaLang/julia/pull/60410"
  author: "topolarity"
  labels:
    - "JuliaLowering"
  merged_at: "2025-12-18T13:39:23Z"
  merge_commit_sha: "e7ef2c15e0ee62a67475d21a47df3ad74608fd11"
  diff_url: "https://github.com/JuliaLang/julia/pull/60410.diff"
scope:
  files_touched:
    - "JuliaLowering/src/eval.jl"
    - "JuliaLowering/src/linear_ir.jl"
    - "JuliaLowering/test/macros.jl"
    - "test/JuliaLowering_stdlibs.jl"
  components:
    - "JuliaLowering"
    - "Compiler.Codegen"
  pipeline_stages:
    - "Lowering"
    - "LinearIR"
    - "Codegen"
analysis:
  intent:
    summary: "Accept Expr(:loopinfo, ...) forms in JuliaLowering so SIMD loop annotations and stdlib precompilation work under the JL pipeline."
    issue_links: []
  direct_changes:
    - summary: "JuliaLowering now maps the SyntaxTree kind K\"loopinfo\" to Expr(:loopinfo) when building lowered expressions, avoiding the unhandled-form error for loopinfo nodes."
      component: "JuliaLowering/src/eval.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/eval.jl"
          loc: "426-449"
          url: "https://github.com/JuliaLang/julia/blob/e7ef2c15e0ee62a67475d21a47df3ad74608fd11/JuliaLowering/src/eval.jl#L426-L449"
          snippet: |
            # Allowed forms according to https://docs.julialang.org/en/v1/devdocs/ast/
            #
            # call invoke static_parameter `=` method struct_type abstract_type
            # primitive_type global const new splatnew isdefined
            # enter leave pop_exception inbounds boundscheck loopinfo copyast meta
            # lambda
            head = k == K"call"      ? :call       :
                   k == K"new"       ? :new        :
                   k == K"splatnew"  ? :splatnew   :
                   k == K"="         ? :(=)        :
                   k == K"leave"     ? :leave      :
                   k == K"isdefined" ? :isdefined  :
                   k == K"loopinfo"  ? :loopinfo   :
                   k == K"latestworld"       ? :latestworld       :
                   k == K"pop_exception"     ? :pop_exception     :
                   k == K"captured_local"    ? :captured_local    :
                   k == K"gc_preserve_begin" ? :gc_preserve_begin :
                   k == K"gc_preserve_end"   ? :gc_preserve_end   :
                   k == K"foreigncall"       ? :foreigncall       :
                   k == K"cfunction"         ? :cfunction         :
                   k == K"new_opaque_closure" ? :new_opaque_closure :
                   nothing
            if isnothing(head)
                throw(LoweringError(ex, "Unhandled form for kind $k"))
            end
    - summary: "Linear IR compilation treats K\"loopinfo\" like gc_preserve_end: it must be statement-position and is emitted directly."
      component: "JuliaLowering/src/linear_ir.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/linear_ir.jl"
          loc: "793-800"
          url: "https://github.com/JuliaLang/julia/blob/e7ef2c15e0ee62a67475d21a47df3ad74608fd11/JuliaLowering/src/linear_ir.jl#L793-L800"
          snippet: |
            elseif k == K"gc_preserve_begin"
                makenode(ctx, ex, k, compile_args(ctx, children(ex)))
            elseif k == K"gc_preserve_end" || k == K"loopinfo"
                if needs_value
                    throw(LoweringError(ex, "misplaced kind $k in value position"))
                end
                emit(ctx, ex)
                nothing
    - summary: "Adds JuliaLowering macro tests that execute Expr(:loopinfo, ...) in SIMD loops and verify expected results for both explicit loopinfo and @simd usage."
      component: "JuliaLowering/test/macros.jl"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/macros.jl"
          loc: "563-613"
          url: "https://github.com/JuliaLang/julia/blob/e7ef2c15e0ee62a67475d21a47df3ad74608fd11/JuliaLowering/test/macros.jl#L563-L613"
          snippet: |
            @testset "SIMD loopinfo" begin
                @test JuliaLowering.include_string(test_mod, raw"""
                @eval let
                    n = 10
                    x = zeros(n)
                    i = 1
                    while i ≤ n
                        x[i] += 1
                        i += 1
                        $(Expr(:loopinfo, Symbol("julia.simdloop"), nothing))  # Mark loop as SIMD loop
                    end
                    sum(x)
                end
                """; expr_compat_mode=true) == 10.0

                @test JuliaLowering.include_string(test_mod, raw"""
                @eval let
                    n = 10
                    x = zeros(n)
                    i = 1
                    while i ≤ n
                        x[i] += 1
                        i += 1
                        $(Expr(:loopinfo, Symbol("julia.simdloop"), Symbol("julia.ivdep")))  # Mark loop as SIMD loop
                    end
                    sum(x)
                end
                """; expr_compat_mode=true) == 10.0

                JuliaLowering.include_string(test_mod, """
                @noinline function inner(x, y)
                    s = zero(eltype(x))
                    for i in eachindex(x, y)
                        @inbounds s += x[i]*y[i]
                    end
                    return s
                end
                """)

                JuliaLowering.include_string(test_mod, """
                @noinline function innersimd(x, y)
                    s = zero(eltype(x))
                    @simd for i in eachindex(x, y)
                        @inbounds s += x[i] * y[i]
                    end
                    return s
                end
                """)

                @test test_mod.inner([1,2,3], [1,2,3]) == 14
                @test test_mod.innersimd([1,2,3], [1,2,3]) == 14
            end
    - summary: "JuliaLowering stdlib precompilation removes Statistics, REPLExt, and SparseArraysExt from the incompatible list, confirming these stdlibs now precompile under JL after the loopinfo fix."
      component: "test/JuliaLowering_stdlibs.jl"
      evidence:
        - source: "test"
          path: "test/JuliaLowering_stdlibs.jl"
          loc: "3-14"
          url: "https://github.com/JuliaLang/julia/blob/e7ef2c15e0ee62a67475d21a47df3ad74608fd11/test/JuliaLowering_stdlibs.jl#L3-L14"
          snippet: |
            # known precompilation failures under JL
            const INCOMPATIBLE_STDLIBS = String[
                "InteractiveUtils", # Invalid function name
                "LibGit2", # op isa Symbol (JuliaLang/JuliaLowering.jl#126)
                "SparseArrays", # type-alias bug (JuliaLang/JuliaLowering.jl#123)
                "TOML", # @invokelatest / QuoteNode bug
                "Test", # depends on InteractiveUtils
                "REPL", # depends on InteractiveUtils
                "Pkg", # depends on TOML
                "SuiteSparse", # depends on SparseArrays
                "LazyArtifacts", # depends on Pkg
            ]
            # NOTE: Statistics, REPLExt, SparseArraysExt were REMOVED from this list by this PR
  secondary_effects:
    - effect: "Expr(:loopinfo, ...) annotations emitted by macros like @simd survive JuliaLowering and can reach codegen, enabling loop metadata (e.g., SIMD and ivdep) when running under JL lowering."
      mechanism: |
        to_lowered_expr(ex)  [JuliaLowering/src/eval.jl:326-327]
          -> _to_lowered_expr(ex, stmt_offset)  [JuliaLowering/src/eval.jl:330]
            maps K"loopinfo" to Expr(:loopinfo)  [JuliaLowering/src/eval.jl:438]
          -> compile(ctx, ex, needs_value, in_tail_pos)  [JuliaLowering/src/linear_ir.jl:770-800]
            emits K"loopinfo" as a statement node  [JuliaLowering/src/linear_ir.jl:795-800]
          -> codegen handles jl_loopinfo_sym by building LLVM LoopID metadata
             [src/codegen.cpp:6875-6893]
          -> interpreter fallback returns jl_nothing for jl_loopinfo_sym
             [src/interpreter.c:343-345]
      downstream_surfaces:
        - "@simd / Base.simdloop.jl loop annotations"
        - "Packages emitting Expr(:loopinfo, ...) in macros"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "JuliaLowering _to_lowered_expr kind mapping"
        change: "K\"loopinfo\" is now translated to Expr(:loopinfo), so consumers of JuliaLowering SyntaxTree lowering can rely on loopinfo being preserved instead of throwing LoweringError."
        affected_tools:
          - tool: "JuliaLowering internal embedders"
            usage: "Downstream tools that call JuliaLowering.to_lowered_expr or include_string can now accept Expr(:loopinfo) payloads."
    behavioral:
      - change: "Expr(:loopinfo, ...) forms are accepted in expr_compat_mode rather than erroring as unhandled forms."
        impact: "SIMD-annotated loops (e.g., @simd) can be lowered and precompiled under JuliaLowering."
  performance:
    compile_time:
      - impact: "No measurable compile-time change expected; this adds a simple kind mapping and statement emission. ESTIMATED: ~O(1) extra branch in lowering and linear IR compile."
    runtime:
      - impact: "Restores loop metadata propagation for JL-lowered @simd loops, enabling LLVM vectorization. MEASURED: PR author demonstrated ~10x speedup (3.9 vs 39.9 GFlop/sec) on performance-tips inner product example with @simd."
  risk:
    level: "low"
    rationale:
      - "Change is additive and localized to loopinfo handling in JuliaLowering and tests."
      - "Linear IR already treats similar non-value forms (gc_preserve_end); loopinfo follows same pattern."
  open_questions:
    - "None identified; loopinfo is already a known AST head and codegen handles it."
  recommendations:
    - "Downstream tools that generate or inspect Expr(:loopinfo, ...) should ensure they set expr_compat_mode=true when using JuliaLowering include_string, matching the new tests."
    - "Consider adding a targeted regression test in downstream packages that rely on @simd to ensure loopinfo survives JuliaLowering-based pipelines."
  evidence:
    - source: "code"
      path: "base/simdloop.jl"
      loc: "69-85"
      url: "https://github.com/JuliaLang/julia/blob/e7ef2c15e0ee62a67475d21a47df3ad74608fd11/base/simdloop.jl#L69-L85"
      snippet: |
        let r = $(esc(range))
            for j in Base.simd_outer_range(r)
                let n = Base.simd_inner_length(r,j)
                    if zero(n) < n
                        # Lower loop in way that seems to work best for LLVM 3.3 vectorizer.
                        let i = zero(n)
                            while i < n
                                local $(esc(var)) = Base.simd_index(r,j,i)
                                $(esc(x.args[2]))        # Body of loop
                                i += 1
                                $(Expr(:loopinfo, Symbol("julia.simdloop"), ivdep))  # Mark loop as SIMD loop
                            end
                        end
                    end
                end
            end
        end
    - source: "code"
      path: "src/codegen.cpp"
      loc: "6875-6893"
      url: "https://github.com/JuliaLang/julia/blob/e7ef2c15e0ee62a67475d21a47df3ad74608fd11/src/codegen.cpp#L6875-L6893"
      snippet: |
        else if (head == jl_loopinfo_sym) {
            // parse Expr(:loopinfo, "julia.simdloop", ("llvm.loop.vectorize.width", 4))
            // to LLVM LoopID
            SmallVector<Metadata *, 8> MDs;

            // Reserve first location for self reference to the LoopID metadata node.
            TempMDTuple TempNode = MDNode::getTemporary(ctx.builder.getContext(), {});
            MDs.push_back(TempNode.get());

            for (int i = 0, ie = nargs; i < ie; ++i) {
                Metadata *MD = to_md_tree(args[i], ctx.builder.getContext());
                if (MD)
                    MDs.push_back(MD);
            }

            ctx.LoopID = MDNode::getDistinct(ctx.builder.getContext(), MDs);
            // Replace the temporary node with a self-reference.
            ctx.LoopID->replaceOperandWith(0, ctx.LoopID);
            return jl_cgval_t();
        }
    - source: "code"
      path: "src/interpreter.c"
      loc: "343-345"
      url: "https://github.com/JuliaLang/julia/blob/e7ef2c15e0ee62a67475d21a47df3ad74608fd11/src/interpreter.c#L343-L345"
      snippet: |
        else if (head == jl_meta_sym || head == jl_coverageeffect_sym || head == jl_inbounds_sym || head == jl_loopinfo_sym ||
                 head == jl_aliasscope_sym || head == jl_popaliasscope_sym || head == jl_inline_sym || head == jl_noinline_sym) {
            return jl_nothing;
        }
    - source: "pr_description"
      path: "N/A"
      loc: "N/A"
      url: "https://github.com/JuliaLang/julia/pull/60410"
      snippet: |
        PR author verified expected performance delta on performance-tips example:
        GFlop/sec        = 3.918357111230404
        GFlop/sec (SIMD) = 39.943280541630884
        MEASURED: ~10x speedup demonstrates loopinfo enables LLVM SIMD vectorization
