schema_version: "1.0"
pr:
  number: 60431
  title: "Document and further clean up node creation functions"
  url: "https://github.com/JuliaLang/julia/pull/60431"
  author: "mlechu"
  labels:
    - "JuliaLowering"
  merged_at: "2025-12-26T17:19:54Z"
  merge_commit_sha: "7b92a2aa070bb4a15f9ec71292770737718206da"
  diff_url: "https://github.com/JuliaLang/julia/pull/60431.diff"
scope:
  files_touched:
    - "JuliaLowering/src/JuliaLowering.jl"
    - "JuliaLowering/src/ast.jl"
    - "JuliaLowering/src/bindings.jl"
    - "JuliaLowering/src/closure_conversion.jl"
    - "JuliaLowering/src/compat.jl"
    - "JuliaLowering/src/desugaring.jl"
    - "JuliaLowering/src/linear_ir.jl"
    - "JuliaLowering/src/macro_expansion.jl"
    - "JuliaLowering/src/runtime.jl"
    - "JuliaLowering/src/scope_analysis.jl"
    - "JuliaLowering/test/compat.jl"
    - "JuliaLowering/test/macros.jl"
    - "JuliaLowering/test/scopes.jl"
    - "JuliaLowering/test/utils.jl"
    - "JuliaSyntax/src/porcelain/syntax_graph.jl"
  components:
    - "JuliaSyntax"
    - "JuliaLowering"
  pipeline_stages:
    - "Parsing"
    - "MacroExpansion"
    - "Lowering"
    - "LinearIR"
analysis:
  intent:
    summary: "Split AST node creation into explicit new-vs-copy operations, document provenance semantics, and tighten JuliaLowering node-construction APIs."
    issue_links: []
  direct_changes:
    - summary: "Introduce explicit node constructors in JuliaSyntax: newnode/newleaf for fresh provenance and mknode/mkleaf for immutable updates that copy attributes and set :source to the original node id."
      component: "JuliaSyntax"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
          loc: "577-616"
          url: "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaSyntax/src/porcelain/syntax_graph.jl#L577-L616"
          snippet: |
            """
                newnode(graph::SyntaxGraph, prov::SourceAttrType, k::Kind, children)

            Add a new node to `graph` with reference to parsed source text `prov`.
            """
            function newnode(graph::SyntaxGraph, prov::SourceAttrType, k::Kind, children)
                st = newleaf(graph, prov, k)
                setchildren!(graph, st._id, children)
                return st
            end
            function newleaf(graph::SyntaxGraph, prov::SourceAttrType, k::Kind)
                st = SyntaxTree(graph, new_id!(graph))
                setattr!(st, :kind, k)
                setattr!(st, :source, prov)
            end

            newnode(graph::SyntaxGraph, prov::SyntaxTree, k::Kind, children) =
                newnode(graph, prov._id, k, children)

            newleaf(graph::SyntaxGraph, prov::SyntaxTree, k::Kind) =
                newleaf(graph, prov._id, k)

            """
                mknode(old::SyntaxTree, children)

            Create a node in `old`'s graph that is an immutable update of `old`, but setting
            `old` as its provenance.  This is the main operation used by syntax
            transformations such as lowering.
            """
            function mknode(old::SyntaxTree, children)
                st = mkleaf(old)
                setchildren!(st._graph, st._id, children)
                return st
            end
            function mkleaf(old::SyntaxTree)
                graph = syntax_graph(old)
                st = SyntaxTree(graph, new_id!(graph))
                copy_attrs!(st, old, true)
                setattr!(st, :source, old._id)
            end
    - summary: "JuliaLowering now re-exports the new node APIs and uses them in helpers like newleaf/newnode wrappers and SSA assignment generation (tree_ids helper)."
      component: "JuliaLowering"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/JuliaLowering.jl"
          loc: "15-24"
          url: "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering/src/JuliaLowering.jl#L15-L24"
          snippet: |
            using .JuliaSyntax: highlight, Kind, @KSet_str, is_leaf, children, numchildren,
                head, kind, flags, has_flags, filename, first_byte, last_byte, byte_range,
                sourcefile, source_location, span, sourcetext, is_literal, is_infix_op_call,
                is_postfix_op_call, @isexpr, SyntaxHead, is_syntactic_operator,
                SyntaxGraph, SyntaxTree, SyntaxList, NodeId, SourceRef, SourceAttrType,
                ensure_attributes, ensure_attributes!, delete_attributes, new_id!, hasattr,
                setattr, setattr!, syntax_graph, is_compatible_graph,
                check_compatible_graph, copy_node, copy_ast, provenance, sourceref,
                reparent, mapchildren, flattened_provenance, mkleaf, mknode, newleaf,
                newnode, tree_ids
        - source: "code"
          path: "JuliaLowering/src/ast.jl"
          loc: "93-151"
          url: "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering/src/ast.jl#L93-L151"
          snippet: |
            function JuliaSyntax.newleaf(ctx::AbstractLoweringContext,
                                prov::Union{SyntaxTree, SourceAttrType},
                                k::Kind)
                newleaf(syntax_graph(ctx), prov, k)
            end

            function JuliaSyntax.newleaf(ctx, prov, k, @nospecialize(value))
                leaf = newleaf(ctx, prov, k)
                if k == K"Identifier" || k == K"core" || k == K"top" || k == K"Symbol" ||
                        k == K"globalref" || k == K"Placeholder"
                    setattr!(leaf._graph, leaf._id, :name_val, value)
                elseif k == K"BindingId"
                    setattr!(leaf._graph, leaf._id, :var_id, value)
                elseif k == K"label"
                    setattr!(leaf._graph, leaf._id, :id, value)
                elseif k == K"symbolic_label"
                    setattr!(leaf._graph, leaf._id, :name_val, value)
                elseif k in KSet"TOMBSTONE SourceLocation latestworld latestworld_if_toplevel
                                 softscope"
                    # no attributes
                else
                    val = k == K"Integer" ? convert(Int,     value) :
                          k == K"Float"   ? convert(Float64, value) :
                          k == K"String"  ? convert(String,  value) :
                          k == K"Char"    ? convert(Char,    value) :
                          k == K"Value"   ? value                   :
                          k == K"Bool"    ? value                   :
                          k == K"VERSION" ? value                   :
                          error("Unexpected leaf kind `$k`")
                    setattr!(leaf._graph, leaf._id, :value, val)
                end
                leaf
            end

            JuliaSyntax.newnode(ctx::AbstractLoweringContext,
                                prov::Union{SyntaxTree, SourceAttrType},
                                k::Kind, cs) =
                newnode(syntax_graph(ctx), prov, k, cs)

            function assign_tmp(ctx::AbstractLoweringContext, ex, name="tmp")
                var = ssavar(ctx, ex, name)
                assign_var = newnode(ctx, ex, K"=", tree_ids(var, ex))
                var, assign_var
            end

            function emit_assign_tmp(stmts::SyntaxList, ctx, ex, name="tmp")
                if is_ssa(ctx, ex)
                    return ex
                end
                var = ssavar(ctx, ex, name)
                push!(stmts, newnode(ctx, ex, K"=", tree_ids(var, ex)))
                var
            end
    - summary: "Macro expansion and generated-function support now use mknode/copy_node plus explicit :source updates, and GeneratedFunctionStub srcref is constrained to LineNumberNode/SourceRef while non-Expr output is wrapped with newleaf." 
      component: "JuliaLowering"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/macro_expansion.jl"
          loc: "363-376"
          url: "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering/src/macro_expansion.jl#L363-L376"
          snippet: |
            # Add a secondary source of provenance to each expression in the tree `ex`.
            function append_sourceref(ctx, ex, secondary_prov)
                srcref = (ex, secondary_prov)
                out = if !is_leaf(ex)
                    if kind(ex) == K"macrocall"
                        copy_node(ex)
                    else
                        cs = map(e->append_sourceref(ctx, e, secondary_prov)._id, children(ex))
                        mknode(ex, cs)
                    end
                else
                    copy_node(ex)
                end
                setattr!(out, :source, _unpack_srcref(syntax_graph(ctx), srcref))
            end
        - source: "code"
          path: "JuliaLowering/src/runtime.jl"
          loc: "292-346"
          url: "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering/src/runtime.jl#L292-L346"
          snippet: |
            struct GeneratedFunctionStub
                expr_compat_mode::Bool
                gen::Function
                srcref::Union{LineNumberNode,SourceRef}
                argnames::Core.SimpleVector
                spnames::Core.SimpleVector
            end

            function (g::GeneratedFunctionStub)(world::UInt, source::Method, @nospecialize args...)
                graph = ensure_attributes(SyntaxGraph(), kind=Kind, syntax_flags=UInt16, source=SourceAttrType,
                                          value=Any, name_val=String)
                graph = ensure_attributes(ensure_macro_attributes(graph),
                                          is_toplevel_thunk=Bool,
                                          toplevel_pure=Bool,
                                          )

                __module__ = source.module

                macro_world = Base.tls_world_age()
                ctx1 = MacroExpansionContext(graph, __module__, g.expr_compat_mode, macro_world)

                layer = only(ctx1.scope_layers)

                mctx = MacroContext(syntax_graph(ctx1), g.srcref, layer, g.expr_compat_mode)
                ex0 = g.gen(mctx, args...)
                if ex0 isa Expr
                    ex0 = expr_to_syntaxtree(ctx1, ex0, source_location(LineNumberNode, g.srcref))
                end
                if ex0 isa SyntaxTree
                    if !is_compatible_graph(ctx1, ex0)
                        ex0 = copy_ast(ctx1, ex0)
                    end
                else
                    ex0 = newleaf(syntax_graph(ctx1), g.srcref, K"Value", ex0)
                end
    - summary: "Linear IR generation now uses newleaf/newnode with explicit setattr! calls instead of makeleaf/makenode with attribute lists, affecting label creation, call/new IR construction, and binding renumbering."
      component: "JuliaLowering"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/linear_ir.jl"
          loc: "345-348"
          url: "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering/src/linear_ir.jl#L345-L348"
          snippet: |
            function make_label(ctx, srcref)
                id = ctx.next_label_id[]
                ctx.next_label_id[] += 1
                setattr!(newleaf(ctx, srcref, K"label"), :id, id)
            end
        - source: "code"
          path: "JuliaLowering/src/linear_ir.jl"
          loc: "964-982"
          url: "https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering/src/linear_ir.jl#L964-L982"
          snippet: |
            if k == K"BindingId"
                id = ex.var_id
                if haskey(ssa_rewrites, id)
                    setattr!(newleaf(ctx, ex, K"SSAValue"), :var_id, ssa_rewrites[id])
                else
                    new_id = get(slot_rewrites, id, nothing)
                    binfo = get_binding(ctx, id)
                    if !isnothing(new_id)
                        sk = binfo.kind == :local || binfo.kind == :argument ? K"slot"             :
                             binfo.kind == :static_parameter                 ? K"static_parameter" :
                             throw(LoweringError(ex, "Found unexpected binding of kind $(binfo.kind)"))
                        setattr!(newleaf(ctx, ex, sk), :var_id, new_id)
                    else
                        if binfo.kind !== :global
                            throw(LoweringError(ex, "Found unexpected binding of kind $(binfo.kind)"))
                        end
                        out = newleaf(ctx, ex, K"globalref")
                        setattr!(out, :name_val, binfo.name)
                        setattr!(out, :mod, binfo.mod)
                    end
                end
  secondary_effects:
    - effect: "AST provenance for macro-expanded trees is now explicitly rebuilt via copy_node/mknode and then re-stamped with a tuple source, which can change how downstream tools interpret :source as either a parsed span or a transformed-node reference."
      mechanism: |
        append_sourceref(ctx, ex, secondary_prov)  [JuliaLowering/src/macro_expansion.jl:363-376]
          -> mknode(ex, cs) for non-macrocall nodes
          -> mkleaf(old) copies attrs and sets :source = old._id  [JuliaSyntax/src/porcelain/syntax_graph.jl:606-616]
          -> append_sourceref then overwrites :source with _unpack_srcref((ex, secondary_prov))
      downstream_surfaces:
        - "Macro-expansion provenance for tooling that inspects :source / provenance"
        - "SyntaxTree copying during macro interpolation"
      likelihood: "medium"
      impact: "low"
    - effect: "Generated-function macro context now guarantees srcref is LineNumberNode/SourceRef and wraps non-Expr generator outputs as K\"Value\" leaves, which could affect custom generators that expected a SyntaxTree srcref."
      mechanism: |
        GeneratedFunctionStub.srcref is narrowed to Union{LineNumberNode,SourceRef}  [JuliaLowering/src/runtime.jl:292-298]
        -> MacroContext(syntax_graph(ctx1), g.srcref, layer, g.expr_compat_mode)
        -> non-Expr generator output is wrapped via newleaf(..., K"Value", ex0)  [JuliaLowering/src/runtime.jl:335-346]
      downstream_surfaces:
        - "@generated function expansion"
        - "MacroContext consumers in generated-function paths"
      likelihood: "low"
      impact: "low"
    - effect: "Quote interpolation now uses mknode(ex, args) instead of makenode(ctx, ex, ex, args), which simplifies the provenance chain by always setting :source to the original node id via mkleaf."
      mechanism: |
        _interp_makenode(ctx::InterpolationContext, ex, args)  [JuliaLowering/src/runtime.jl:48]
          changed from: makenode(ctx, ex, ex, args)
          changed to: mknode(ex, args)
        -> mknode(old, children) calls mkleaf(old)  [JuliaSyntax/src/porcelain/syntax_graph.jl:606-610]
        -> mkleaf sets :source = old._id (provenance points to original)
      downstream_surfaces:
        - "Quote interpolation AST construction"
        - "Provenance tracking for interpolated expressions"
      likelihood: "low"
      impact: "low"
  compatibility:
    internal_api:
      - api: "JuliaSyntax.new_id!"
        change: "Node-id allocator renamed and re-exported from JuliaLowering for node construction utilities."
        evidence:
          - "JuliaSyntax/src/porcelain/syntax_graph.jl:97-100"
          - "JuliaLowering/src/JuliaLowering.jl:20-24"
      - api: "JuliaSyntax.newnode/newleaf and mknode/mkleaf"
        change: "Node construction split between fresh-provenance creation and immutable updates that copy attributes." 
        evidence:
          - "JuliaSyntax/src/porcelain/syntax_graph.jl:577-616"
          - "JuliaLowering/src/JuliaLowering.jl:20-24"
      - api: "GeneratedFunctionStub.srcref"
        change: "srcref is now Union{LineNumberNode,SourceRef} instead of allowing SyntaxTree."
        evidence:
          - "JuliaLowering/src/runtime.jl:292-298"
      - api: "JuliaSyntax.makeleaf/makenode/mapleaf (removed)"
        change: "Old node construction functions removed; replaced by newleaf/newnode for fresh nodes and mkleaf/mknode for transformations that preserve provenance."
        evidence:
          - "JuliaSyntax/src/porcelain/syntax_graph.jl (functions removed)"
          - "JuliaLowering/src/JuliaLowering.jl:23-24 (no longer imports makeleaf/makenode)"
      - api: "JuliaSyntax.tree_ids"
        change: "New helper function added to convert SyntaxTree variadic args to NodeId array for use with newnode."
        evidence:
          - "JuliaSyntax/src/porcelain/syntax_graph.jl:463"
          - "JuliaLowering/src/JuliaLowering.jl:24 (re-exported)"
    behavioral:
      - area: "@ast macro usage in tests"
        change: "Tests now pass a concrete graph and SyntaxTree srcref into @ast, reflecting the stricter srcref typing and new constructors." 
        evidence:
          - "JuliaLowering/test/compat.jl:665-671"
          - "JuliaLowering/test/macros.jl:494-502"
          - "JuliaLowering/test/scopes.jl:149-153"
  performance:
    compile_time:
      - "ESTIMATED: neutral; node creation now uses new_id! and explicit constructors, but no new passes or extra traversals are introduced."
    runtime:
      - "ESTIMATED: neutral; changes are structural API refactors without new runtime logic in hot paths."
  risk:
    level: "low"
    rationale:
      - "Changes are primarily API refactors and provenance bookkeeping updates with targeted test adjustments."
  open_questions:
    - "Do downstream tools rely on legacy makeleaf/makenode names or pass non-SyntaxTree srcref values to @ast and MacroContext?"
  recommendations:
    - "Audit downstream compiler tooling for direct uses of makeleaf/makenode/newnode! and migrate to newnode/newleaf/mknode/mkleaf/new_id!."
    - "If custom macro or generated-function code passes srcref values, ensure they are SourceRef/LineNumberNode or SyntaxTree as required by @ast and MacroContext."
