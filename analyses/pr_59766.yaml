schema_version: "1.0"
pr:
  number: 59766
  title: "Align interpreter and codegen error behavior of setglobal! and friends"
  url: "https://github.com/JuliaLang/julia/pull/59766"
  author: "Keno"
  labels: []
  merged_at: "2025-10-08T15:38:01Z"
  merge_commit_sha: "3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a"
  diff_url: "https://github.com/JuliaLang/julia/pull/59766.diff"
scope:
  files_touched:
    - "Compiler/src/abstractinterpretation.jl"
    - "Compiler/test/inference.jl"
    - "base/boot.jl"
    - "base/errorshow.jl"
    - "src/codegen.cpp"
    - "src/datatype.c"
    - "src/genericmemory.c"
    - "src/julia.h"
    - "src/julia_internal.h"
    - "src/module.c"
    - "src/rtutils.c"
    - "test/core.jl"
  components:
    - "Compiler.AbstractInterpretation"
    - "Codegen"
    - "Runtime"
    - "Base.Errors"
  pipeline_stages:
    - "TypeInference"
    - "Codegen"
    - "Runtime"
    - "Diagnostics"
analysis:
  intent:
    summary: "Unify setglobal!/swapglobal!/replaceglobal!/modifyglobal! error behavior between interpreter and codegen by raising TypeError with binding-aware context instead of ErrorException, and update inference modeling to avoid inconsistent exception typing."
    issue_links: []
  direct_changes:
    - summary: "Inference for setglobal! now models TypeError (or TypeError/ErrorException union) in constant and partitioned global assignment paths."
      component: "Compiler.AbstractInterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "2480-2496"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/Compiler/src/abstractinterpretation.jl#L2480-L2496"
          snippet: |
            function abstract_eval_setglobal!(interp::AbstractInterpreter, sv::AbsIntState, saw_latestworld::Bool, @nospecialize(M), @nospecialize(s), @nospecialize(v))
                if isa(M, Const) && isa(s, Const)
                    M, s = M.val, s.val
                    if M isa Module && s isa Symbol
                        gr = GlobalRef(M, s)
                        (rt, exct) = global_assignment_rt_exct(interp, sv, saw_latestworld, gr, v)
                        return CallMeta(rt, exct, Effects(setglobal!_effects, nothrow=exct===Bottom), GlobalAccessInfo(convert(Core.Binding, gr)))
                    end
                    return CallMeta(Union{}, Union{TypeError, ErrorException}, EFFECTS_THROWS, NoCallInfo())
                end
                ⊑ = partialorder(typeinf_lattice(interp))
                if !(hasintersect(widenconst(M), Module) && hasintersect(widenconst(s), Symbol))
                    return CallMeta(Union{}, TypeError, EFFECTS_THROWS, NoCallInfo())
                elseif M ⊑ Module && s ⊑ Symbol
                    return CallMeta(v, ErrorException, setglobal!_effects, NoCallInfo())
                end
                return CallMeta(v, Union{TypeError, ErrorException}, setglobal!_effects, NoCallInfo())
            end
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "3752-3779"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/Compiler/src/abstractinterpretation.jl#L3752-L3779"
          snippet: |
            function global_assignment_rt_exct(interp::AbstractInterpreter, sv::AbsIntState, saw_latestworld::Bool, g::GlobalRef, @nospecialize(newty))
                if saw_latestworld
                    return Pair{Any,Any}(newty, Union{TypeError, ErrorException})
                end
                newty′ = RefValue{Any}(newty)
                (valid_worlds, ret) = scan_partitions(interp, g, sv.world) do interp::AbstractInterpreter, ::Core.Binding, partition::Core.BindingPartition
                    global_assignment_binding_rt_exct(interp, partition, newty′[])
                end
                update_valid_age!(sv, valid_worlds)
                return ret
            end

            function global_assignment_binding_rt_exct(interp::AbstractInterpreter, partition::Core.BindingPartition, @nospecialize(newty))
                kind = binding_kind(partition)
                if is_some_guard(kind)
                    return Pair{Any,Any}(newty, ErrorException)
                elseif is_some_const_binding(kind) || is_some_imported(kind)
                    # N.B.: Backdating should not improve inference in an earlier world
                    return Pair{Any,Any}(kind == PARTITION_KIND_BACKDATED_CONST ? newty : Bottom, ErrorException)
                end
                ty = kind == PARTITION_KIND_DECLARED ? Any : partition_restriction(partition)
                wnewty = widenconst(newty)
                if !hasintersect(wnewty, ty)
                    return Pair{Any,Any}(Bottom, TypeError)
                elseif !(wnewty <: ty)
                    retty = tmeet(typeinf_lattice(interp), newty, ty)
                    return Pair{Any,Any}(retty, TypeError)
                end
                return Pair{Any,Any}(newty, Bottom)
            end
    - summary: "Runtime global assignment checks now throw TypeError with a GlobalRef context, and showerror displays the binding name." 
      component: "Runtime / Base.Errors"
      evidence:
        - source: "code"
          path: "src/module.c"
          loc: "1887-1939"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/module.c#L1887-L1939"
          snippet: |
            jl_value_t *jl_check_binding_assign_value(jl_binding_t *b JL_PROPAGATES_ROOT, jl_module_t *mod, jl_sym_t *var, jl_value_t *rhs JL_MAYBE_UNROOTED, const char *msg)
            {
                JL_GC_PUSH1(&rhs); // callee-rooted
                jl_binding_partition_t *bpart = jl_get_binding_partition(b, jl_current_task->world_age);
                enum jl_partition_kind kind = jl_binding_kind(bpart);
                assert(kind == PARTITION_KIND_DECLARED || kind == PARTITION_KIND_GLOBAL);
                jl_value_t *old_ty = kind == PARTITION_KIND_DECLARED ? (jl_value_t*)jl_any_type : bpart->restriction;
                JL_GC_PROMISE_ROOTED(old_ty);
                if (old_ty != (jl_value_t*)jl_any_type && jl_typeof(rhs) != old_ty && !jl_isa(rhs, old_ty)) {
                    jl_type_error_global(msg, mod, var, old_ty, rhs);
                }
                JL_GC_POP();
                return old_ty;
            }

            JL_DLLEXPORT void jl_checked_assignment(jl_binding_t *b, jl_module_t *mod, jl_sym_t *var, jl_value_t *rhs)
            {
                if (jl_check_binding_assign_value(b, mod, var, rhs, "setglobal!") != NULL) {
                    jl_atomic_store_release(&b->value, rhs);
                    jl_gc_wb(b, rhs);
                }
            }

            JL_DLLEXPORT jl_value_t *jl_checked_modify(jl_binding_t *b, jl_module_t *mod, jl_sym_t *var, jl_value_t *op, jl_value_t *rhs)
            {
                jl_binding_partition_t *bpart = jl_get_binding_partition(b, jl_current_task->world_age);
                enum jl_partition_kind kind = jl_binding_kind(bpart);
                assert(!jl_bkind_is_some_guard(kind) && !jl_bkind_is_some_import(kind));
                if (jl_bkind_is_some_constant(kind))
                    jl_errorf("invalid assignment to constant %s.%s",
                              jl_symbol_name(mod->name), jl_symbol_name(var));
                jl_value_t *ty = bpart->restriction;
                JL_GC_PROMISE_ROOTED(ty);
                return modify_value(ty, &b->value, (jl_value_t*)b, op, rhs, 1, b, mod, var);
            }
        - source: "code"
          path: "src/rtutils.c"
          loc: "112-131"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/rtutils.c#L112-L131"
          snippet: |
            JL_DLLEXPORT void JL_NORETURN jl_type_error_rt(const char *fname, const char *context,
                                                   jl_value_t *expected JL_MAYBE_UNROOTED,
                                                   jl_value_t *got JL_MAYBE_UNROOTED)
            {
                jl_value_t *ctxt=NULL;
                JL_GC_PUSH3(&ctxt, &expected, &got);
                ctxt = jl_pchar_to_string((char*)context, strlen(context));
                jl_value_t *ex = jl_new_struct(jl_typeerror_type, jl_symbol(fname), ctxt, expected, got);
                jl_throw(ex);
            }

            JL_DLLEXPORT void JL_NORETURN jl_type_error_global(const char *fname, jl_module_t *mod, jl_sym_t *sym,
                                                   jl_value_t *expected JL_MAYBE_UNROOTED,
                                                   jl_value_t *got JL_MAYBE_UNROOTED)
            {
                jl_value_t *gr = jl_module_globalref(mod, sym);
                jl_value_t *ex = jl_new_struct(jl_typeerror_type, jl_symbol(fname), gr, expected, got);
                jl_throw(ex);
            }
        - source: "code"
          path: "base/boot.jl"
          loc: "406-418"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/base/boot.jl#L406-L418"
          snippet: |
            struct TypeError <: Exception
                # `func` is the name of the builtin function that encountered a type error,
                # the name of the type that hit an error in its definition or application, or
                # some other brief description of where the error happened.
                # `context` optionally adds extra detail, e.g. the name of the type parameter
                # that got a bad value.
                func::Symbol
                context::Union{AbstractString,GlobalRef,Symbol}
                expected::Type
                got
                TypeError(func, context, @nospecialize(expected::Type), @nospecialize(got)) =
                    new(func, context, expected, got)
            end
        - source: "code"
          path: "base/errorshow.jl"
          loc: "80-103"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/base/errorshow.jl#L80-L103"
          snippet: |
            function showerror(io::IO, ex::TypeError)
                print(io, "TypeError: ")
                if ex.expected === Bool
                    print(io, "non-boolean (", typeof(ex.got), ") used in boolean context")
                elseif ex.func === :var"dict key"
                    print(io, "$(limitrepr(ex.got)) is not a valid key for type $(ex.expected)")
                else
                    if isvarargtype(ex.got)
                        targs = (ex.got,)
                    elseif isa(ex.got, Type)
                        targs = ("Type{", ex.got, "}")
                    else
                        targs = ("a value of type $(typeof(ex.got))",)
                    end
                    if ex.context == ""
                        ctx = "in $(ex.func)"
                    elseif isa(ex.context, Core.GlobalRef)
                        gr = ex.context
                        ctx = "in $(ex.func) of global binding `$(gr.mod).$(gr.name)`"
                    elseif ex.func === :var"keyword argument"
                        ctx = "in keyword argument $(ex.context)"
                    else
                        ctx = "in $(ex.func), in $(ex.context)"
                    end
                    print(io, ctx, ", expected ", ex.expected, ", got ", targs...)
                end
                Experimental.show_error_hints(io, ex)
            end
    - summary: "Codegen type checks for global assignment now use setglobal!/swapglobal!/replaceglobal!/modifyglobal!/setglobalonce! as the TypeError function name."
      component: "Codegen"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "3224-3267"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/codegen.cpp#L3224-L3267"
          snippet: |
            jl_binding_t *bnd = jl_get_module_binding(mod, sym, 1);
            jl_binding_partition_t *bpart = jl_get_binding_partition_all(bnd, ctx.min_world, ctx.max_world);
            Value *bp = julia_binding_gv(ctx, bnd);
            if (bpart) {
                if (jl_binding_kind(bpart) == PARTITION_KIND_GLOBAL) {
                    int possibly_deprecated = bpart->kind & PARTITION_FLAG_DEPWARN;
                    jl_value_t *ty = bpart->restriction;
                    if (ty != nullptr) {
                        const std::string fname = issetglobal ? "setglobal!" : isreplaceglobal ? "replaceglobal!" : isswapglobal ? "swapglobal!" : ismodifyglobal ? "modifyglobal!" : "setglobalonce!";
                        if (!ismodifyglobal) {
                            emit_typecheck(ctx, rval, ty, fname.c_str());
                            rval = update_julia_type(ctx, rval, ty);
                            if (rval.typ == jl_bottom_type)
                                return jl_cgval_t();
                        }
                        bool isboxed = true;
                        bool maybe_null = jl_atomic_load_relaxed(&bnd->value) == NULL;
                        if (possibly_deprecated) {
                            ctx.builder.CreateCall(prepare_call(jldepcheck_func), { bp });
                        }
                        return typed_store(ctx,
                                        julia_binding_pvalue(ctx, bp),
                                        rval, cmp, ty,
                                        ctx.tbaa().tbaa_binding,
                                        nullptr,
                                        bp,
                                        isboxed,
                                        Order,
                                        FailOrder,
                                        0,
                                        nullptr,
                                        issetglobal,
                                        isreplaceglobal,
                                        isswapglobal,
                                        ismodifyglobal,
                                        issetglobalonce,
                                        maybe_null,
                                        modifyop,
                                        fname,
                                        mod,
                                        sym);
    - summary: "modifyglobal! and memoryrefmodify! now route through jl_check_binding_assign_value when operating on bindings, ensuring consistent TypeError behavior."
      component: "Runtime"
      evidence:
        - source: "code"
          path: "src/datatype.c"
          loc: "1995-2028"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/datatype.c#L1995-L2028"
          snippet: |
            inline jl_value_t *modify_value(jl_value_t *ty, _Atomic(jl_value_t*) *p, jl_value_t *parent, jl_value_t *op, jl_value_t *rhs, int isatomic, jl_binding_t *b, jl_module_t *mod, jl_sym_t *name)
            {
                jl_value_t *r = isatomic ? jl_atomic_load(p) : jl_atomic_load_relaxed(p);
                if (__unlikely(r == NULL)) {
                    if (b)
                        jl_undefined_var_error(name, (jl_value_t*)mod);
                    jl_throw(jl_undefref_exception);
                }
                jl_value_t **args;
                JL_GC_PUSHARGS(args, 2);
                args[0] = r;
                while (1) {
                    args[1] = rhs;
                    jl_value_t *y = jl_apply_generic(op, args, 2);
                    args[1] = y;
                    if (b)
                        jl_check_binding_assign_value(b, mod, name, y, "modifyglobal!");
                    else if (!jl_isa(y, ty))
                        jl_type_error(jl_is_genericmemory(parent) ? "memoryrefmodify!" : "modifyfield!", ty, y);
                    if (isatomic ? jl_atomic_cmpswap(p, &r, y) : jl_atomic_cmpswap_release(p, &r, y)) {
                        jl_gc_wb(parent, y);
                        break;
                    }
                    args[0] = r;
                    jl_gc_safepoint();
                }
                // args[0] == r (old)
                // args[1] == y (new)
                jl_datatype_t *rettyp = jl_apply_modify_type(ty);
                JL_GC_PROMISE_ROOTED(rettyp); // (JL_ALWAYS_LEAFTYPE)
                args[0] = jl_new_struct(rettyp, args[0], args[1]);
                JL_GC_POP();
                return args[0];
            }
        - source: "code"
          path: "src/genericmemory.c"
          loc: "501-510"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/genericmemory.c#L501-L510"
          snippet: |
            JL_DLLEXPORT jl_value_t *jl_memoryrefmodify(jl_genericmemoryref_t m, jl_value_t *op, jl_value_t *rhs, int isatomic)
            {
                jl_value_t *eltype = jl_tparam1(jl_typetagof(m.mem));
                const jl_datatype_layout_t *layout = ((jl_datatype_t*)jl_typetagof(m.mem))->layout;
                jl_value_t *owner = jl_genericmemory_owner(m.mem);
                char *data = (char*)m.ptr_or_offset;
                if (layout->flags.arrayelem_isboxed) {
                    assert(data - (char*)m.mem->ptr < sizeof(jl_value_t*) * m.mem->length);
                    return modify_value(eltype, (_Atomic(jl_value_t*)*)data, owner, op, rhs, isatomic, NULL, NULL, NULL);
                }
    - summary: "Header file API changes: jl_module_globalref annotated JL_GLOBALLY_ROOTED, jl_type_error_global exported, modify_value and jl_check_binding_assign_value signatures updated."
      component: "Runtime / Headers"
      evidence:
        - source: "code"
          path: "src/julia.h"
          loc: "2019"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/julia.h#L2019"
          snippet: |
            JL_DLLEXPORT jl_value_t *jl_module_globalref(jl_module_t *m, jl_sym_t *var) JL_GLOBALLY_ROOTED;
        - source: "code"
          path: "src/julia.h"
          loc: "2089-2092"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/julia.h#L2089-L2092"
          snippet: |
            JL_DLLEXPORT void JL_NORETURN jl_type_error_global(const char *fname,
                                                           jl_module_t *mod, jl_sym_t *sym,
                                                           jl_value_t *ty JL_MAYBE_UNROOTED,
                                                           jl_value_t *got JL_MAYBE_UNROOTED);
        - source: "code"
          path: "src/julia_internal.h"
          loc: "885"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/julia_internal.h#L885"
          snippet: |
            jl_value_t *modify_value(jl_value_t *ty, _Atomic(jl_value_t*) *p, jl_value_t *parent, jl_value_t *op, jl_value_t *rhs, int isatomic, jl_binding_t *b, jl_module_t *mod, jl_sym_t *name);
        - source: "code"
          path: "src/julia_internal.h"
          loc: "898"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/julia_internal.h#L898"
          snippet: |
            jl_value_t *jl_check_binding_assign_value(jl_binding_t *b JL_PROPAGATES_ROOT, jl_module_t *mod, jl_sym_t *var, jl_value_t *rhs JL_MAYBE_UNROOTED, const char *msg);
    - summary: "Tests now assert TypeError for invalid setglobal! assignments, matching inference and runtime behavior."
      component: "Tests"
      evidence:
        - source: "code"
          path: "Compiler/test/inference.jl"
          loc: "6458-6461"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/Compiler/test/inference.jl#L6458-L6461"
          snippet: |
            global invalid_setglobal!_exct_modeling::Int
            @test Base.infer_exception_type((Float64,)) do x
                setglobal!(@__MODULE__, :invalid_setglobal!_exct_modeling, x)
            end == TypeError
        - source: "code"
          path: "test/core.jl"
          loc: "8147-8159"
          url: "https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/test/core.jl#L8147-L8159"
          snippet: |
            @testset "setproperty! on modules" begin
                m = Module()
                @eval m global x::Int

                setglobal!(m, :x, 1)
                @test m.x === 1
                setglobal!(m, :x, 2, :release)
                @test m.x === 2
                @test_throws ConcurrencyViolationError setglobal!(m, :x, 3, :not_atomic)
                @test_throws TypeError setglobal!(m, :x, 4., :release)

                f_set_bad_type(m) = setglobal!(m, :x, 4., :release)
                @test_throws TypeError f_set_bad_type(m)
  secondary_effects:
    - effect: "Error reporting for global assignment type mismatches now includes the concrete binding in the TypeError context (GlobalRef), aligning interpreter and codegen error messages."
      mechanism: |
        jl_checked_assignment(b, mod, var, rhs) [module.c:1904-1909]
          -> jl_check_binding_assign_value(b, mod, var, rhs, "setglobal!") [module.c:1889-1902]
            -> jl_type_error_global("setglobal!", mod, var, old_ty, rhs) [module.c:1897-1898]
              -> jl_type_error_global builds TypeError with GlobalRef context [rtutils.c:124-131]
                -> showerror recognizes Core.GlobalRef context for message formatting [base/errorshow.jl:94-96]
      downstream_surfaces:
        - "User-facing error text for setglobal!/swapglobal!/replaceglobal!/modifyglobal!/setglobalonce!"
        - "Tests or tooling matching on TypeError.context"
      likelihood: high
      impact: medium
    - effect: "Inference exception modeling for setglobal! now propagates TypeError for non-intersecting assignments, reducing mismatches between inference and runtime/codegen."
      mechanism: |
        abstract_eval_setglobal!(...) [abstractinterpretation.jl:2480-2497]
          -> global_assignment_rt_exct(...) [abstractinterpretation.jl:3752-3762]
            -> global_assignment_binding_rt_exct(...) [abstractinterpretation.jl:3764-3781]
               returns TypeError when !hasintersect(wnewty, ty) or !(wnewty <: ty)
      downstream_surfaces:
        - "Base.infer_exception_type for global assignments"
        - "Core.Compiler effect analysis (setglobal! throw classification)"
      likelihood: high
      impact: low
    - effect: "swapglobal!/replaceglobal!/setglobalonce! inference automatically inherits TypeError exception modeling via delegation to abstract_eval_setglobal!."
      mechanism: |
        abstract_eval_swapglobal!(...) [abstractinterpretation.jl:2523-2529]
          -> scm = abstract_eval_setglobal!(...) [abstractinterpretation.jl:2525]
          -> returns CallMeta with Union{scm.exct, gcm.exct} including TypeError

        abstract_eval_setglobalonce!(...) [abstractinterpretation.jl:2555-2568]
          -> cm = abstract_eval_setglobal!(...) [abstractinterpretation.jl:2558]
          -> returns CallMeta(Bool, cm.exct, ...) preserving TypeError

        abstract_eval_replaceglobal! follows same delegation pattern
      downstream_surfaces:
        - "Base.infer_exception_type for swapglobal!/replaceglobal!/setglobalonce!"
        - "Consistent exception modeling across all global assignment builtins"
      likelihood: high
      impact: low
  compatibility:
    internal_api:
      - field: "TypeError.context"
        change: "Now accepts Core.GlobalRef in addition to AbstractString and Symbol."
        affected_tools:
          - "Code or tooling that pattern-matches on TypeError.context type in Julia base or packages."
      - field: "jl_check_binding_assign_value"
        change: "Signature now includes a const char *msg to supply the builtin name for TypeError."
        affected_tools:
          - "C extensions/embedders calling jl_check_binding_assign_value directly must update the call signature."
      - field: "jl_type_error_global"
        change: "New exported runtime helper for binding-aware TypeError creation."
        affected_tools:
          - "C code paths that want consistent global assignment error reporting."
      - field: "jl_module_globalref"
        change: "Now annotated with JL_GLOBALLY_ROOTED, indicating returned GlobalRef is permanently rooted."
        affected_tools:
          - "C extensions can now rely on returned value being GC-safe without immediate rooting."
      - field: "modify_value"
        change: "Signature changed to include jl_binding_t *b parameter for binding-aware type checking."
        affected_tools:
          - "Internal callers of modify_value (modify_nth_field, jl_memoryrefmodify, jl_checked_modify) updated to pass NULL or binding."
    behavioral:
      - change: "setglobal!/swapglobal!/replaceglobal!/modifyglobal!/setglobalonce! now throw TypeError (with binding context) instead of ErrorException for type mismatches."
        impact: "User code that caught ErrorException for these cases will now see TypeError; error message format includes global binding name."
  performance:
    compile_time:
      - impact: "ESTIMATED: negligible. Inference now unions TypeError into setglobal! exception type but does not add new passes." 
    runtime:
      - impact: "ESTIMATED: no measurable change on success paths; error paths allocate TypeError with GlobalRef context instead of ErrorException." 
  risk:
    level: low
    rationale:
      - "Changes are localized to error-path behavior and exception typing for global assignment operations."
      - "Tests explicitly lock in TypeError behavior for setglobal! and inference." 
  open_questions:
    - "Do any external C extensions call jl_check_binding_assign_value directly and rely on the old signature?"
    - "Are there packages that pattern-match on ErrorException for global assignment failures that should be updated?"
  recommendations:
    - "Downstream tooling that inspects TypeError.context should accept Core.GlobalRef in addition to strings/symbols."
    - "If embedding Julia, update any direct calls to jl_check_binding_assign_value to pass the builtin name for error reporting."
