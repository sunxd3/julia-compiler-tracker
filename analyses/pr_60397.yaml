schema_version: "1.0"
pr:
  number: 60397
  title: "Backports for 1.12.4"
  url: "https://github.com/JuliaLang/julia/pull/60397"
  author: "KristofferC"
  labels: ["release"]
  merged_at: "2025-12-19T12:38:01Z"
  merge_commit_sha: "4c54cafbd6db26108b3432b7c1906aaa0ff46e31"
  diff_url: "https://github.com/JuliaLang/julia/pull/60397.diff"
scope:
  files_touched:
    - "Compiler/src/abstractinterpretation.jl"
    - "src/julia-syntax.scm"
    - "test/syntax.jl"
    - "stdlib/Artifacts/src/Artifacts.jl"
    - "src/jloptions.c"
    - "base/logging/logging.jl"
    - "base/lock.jl"
    - "stdlib/Logging/test/runtests.jl"
    - "pkgimage.mk"
    - "stdlib/stdlib.mk"
    - "stdlib/Manifest.toml"
    - "stdlib/Project.toml"
    - "stdlib/LinearAlgebra.version"
    - "stdlib/Pkg.version"
    - "deps/libgit2.version"
    - "stdlib/MozillaCACerts_jll/Project.toml"
    - "NEWS.md"
  components:
    - "JuliaSyntax"
    - "Compiler.AbstractInterpretation"
    - "Base/Stdlib"
    - "Runtime/CLI"
    - "Build"
  pipeline_stages:
    - "Parsing"
    - "Lowering"
    - "TypeInference"
    - "Runtime"
analysis:
  intent:
    summary: "Release-1.12 backport bundle for the 1.12.4 patch release, including parser/lowering fixes, artifact world-age handling, logging compatibility, build strictness, and runtime/stdlib updates."
    issue_links:
      - "https://github.com/JuliaLang/julia/pull/60195"
      - "https://github.com/JuliaLang/julia/pull/60383"
      - "https://github.com/JuliaLang/julia/pull/60330"
      - "https://github.com/JuliaLang/julia/pull/60299"
      - "https://github.com/JuliaLang/julia/pull/60414"
      - "https://github.com/JuliaLang/julia/pull/60279"
      - "https://github.com/JuliaLang/julia/pull/60291"
      - "https://github.com/JuliaLang/julia/pull/60041"
      - "https://github.com/JuliaLang/julia/pull/60308"
  direct_changes:
    - summary: "Lowering now preserves keyword/parameters structure when removing argument side effects, so kwcall parameters are evaluated exactly once for broadcasted LHS expressions."
      component: "JuliaSyntax"
      evidence:
        - source: "code"
          path: "src/julia-syntax.scm"
          loc: "1788-1817"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/src/julia-syntax.scm#L1788-L1817"
          snippet: |
            (define (remove-argument-side-effects e)
              (if (not (pair? e))
                  (cons e '())
                  (let ((a '()))
                    (define (arg-to-temp x)
                      (cond ((effect-free? x) x)
                            ((eq? (car x) '...)
                             `(... ,(arg-to-temp (cadr x))))
                            ((eq? (car x) 'kw)
                             `(kw ,(cadr x) ,(arg-to-temp (caddr x))))
                            ((eq? (car x) 'parameters)
                             `(parameters ,@(map arg-to-temp (cdr x))))
                            (else
                             (let ((g (make-ssavalue)))
                               (begin (set! a (cons `(= ,g ,x) a))
                                      g)))))
                    (if (eq? (car e) 'let)
                      (cons (arg-to-temp e) (reverse a))
                      (cons (cons (car e) (map arg-to-temp (cdr e)))
                            (reverse a))))))
        - source: "test"
          path: "test/syntax.jl"
          loc: "3662-3687"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/test/syntax.jl#L3662-L3687"
          snippet: |
            @testset "removing argument side effects" begin
                # Allow let blocks in broadcasted LHSes, but only evaluate them once:
                execs = 0
                array = [1]
                let x = array; execs += 1; x; end .+= 2
                @test array == [3]
                @test execs == 1
                let; execs += 1; array; end .= 4
                @test array == [4]
                @test execs == 2
                let x = array; execs += 1; x; end::Vector{Int} .+= 2
                @test array == [6]
                @test execs == 3
                let; execs += 1; array; end::Vector{Int} .= 7
                @test array == [7]
                @test execs == 4

                # remove argument side effects on lhs kwcall
                pa_execs = 0
                kw_execs = 0
                f60152(v, pa; kw) = copy(v)
                @test (f60152([1, 2, 3], 0; kw=0) .*= 2) == [2,4,6]
                @test (f60152([1, 2, 3], (pa_execs+=1); kw=(kw_execs+=1)) .*= 2) == [2,4,6]
                @test pa_execs === 1
                @test kw_execs === 1
            end
    - summary: "Artifacts now freeze a local world-age at module init and use it for @artifact_str invocations to avoid depending on Base._require_world_age at call time."
      component: "Base/Stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Artifacts/src/Artifacts.jl"
          loc: "19-24"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/stdlib/Artifacts/src/Artifacts.jl#L19-L24"
          snippet: |
            const _artifacts_world_age = Ref{UInt}(typemax(UInt))

            function __init__()
                _artifacts_world_age[] = Base.get_world_counter()
                nothing
            end
        - source: "code"
          path: "stdlib/Artifacts/src/Artifacts.jl"
          loc: "552-558"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/stdlib/Artifacts/src/Artifacts.jl#L552-L558"
          snippet: |
            function _artifact_str(__module__, artifacts_toml, name, path_tail, artifact_dict, hash, platform, ::Val{LazyArtifacts}) where LazyArtifacts
                world = _artifacts_world_age[]
                if world == typemax(UInt)
                    world = Base.get_world_counter()
                end
                return Base.invoke_in_world(world, __artifact_str, __module__, artifacts_toml, name, path_tail, artifact_dict, hash, platform, Val(LazyArtifacts))::String
            end
        - source: "code"
          path: "stdlib/Artifacts/src/Artifacts.jl"
          loc: "728-739"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/stdlib/Artifacts/src/Artifacts.jl#L728-L739"
          snippet: |
            if isa(name, AbstractString) && isa(platform, AbstractPlatform)
                # To support slash-indexing, we need to split the artifact name from the path tail:
                artifact_name, artifact_path_tail, hash = artifact_slash_lookup(name, artifact_dict, artifacts_toml, platform)
                return quote
                    Base.invokelatest(_artifact_str, $(__module__), $(artifacts_toml), $(artifact_name), $(artifact_path_tail), $(artifact_dict), $(hash), $(platform), Val($(LazyArtifacts)))::String
                end
            else
                return quote
                    local platform = $(esc(platform))
                    local artifact_name, artifact_path_tail, hash = artifact_slash_lookup($(esc(name)), $(artifact_dict), $(artifacts_toml), platform)
                    Base.invokelatest(_artifact_str, $(__module__), $(artifacts_toml), artifact_name, artifact_path_tail, $(artifact_dict), hash, platform, Val($(LazyArtifacts)))::String
                end
            end
    - summary: "Logging now defines integer comparisons for LogLevel to make mixed comparisons well-defined."
      component: "Base/Stdlib"
      evidence:
        - source: "code"
          path: "base/logging/logging.jl"
          loc: "128-137"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/base/logging/logging.jl#L128-L137"
          snippet: |
            LogLevel(level::LogLevel) = level

            isless(a::LogLevel, b::LogLevel) = isless(a.level, b.level)
            isless(a::LogLevel, b::Integer) = isless(a.level, b)
            isless(a::Integer, b::LogLevel) = isless(a, b.level)
            +(level::LogLevel, inc::Integer) = LogLevel(level.level+inc)
            -(level::LogLevel, inc::Integer) = LogLevel(level.level-inc)
            convert(::Type{LogLevel}, level::Integer) = LogLevel(level)
        - source: "test"
          path: "stdlib/Logging/test/runtests.jl"
          loc: "15-27"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/stdlib/Logging/test/runtests.jl#L15-L27"
          snippet: |
            @testset "LogLevel compatibility with integers" begin
                @test Logging.Debug + 1000 == Logging.Info
                @test Logging.Warn - 1000 == Logging.Info
                @test Logging.Info < 500
                @test 500 < Logging.Warn
            end
    - summary: "Thread option parsing now guards the thread-pool array allocation to avoid writing past the end when only one pool is configured."
      component: "Runtime/CLI"
      evidence:
        - source: "code"
          path: "src/jloptions.c"
          loc: "671-676"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/src/jloptions.c#L671-L676"
          snippet: |
            assert(jl_options.nthreadpools == 1 || jl_options.nthreadpools == 2);
            int16_t *ntpp = (int16_t *)malloc_s(jl_options.nthreadpools * sizeof(int16_t));
            ntpp[0] = (int16_t)nthreads;
            if (jl_options.nthreadpools == 2)
                ntpp[1] = (int16_t)nthreadsi;
            jl_options.nthreads_per_pool = ntpp;
    - summary: "abstract_invoke retains ErrorException handling for Method-backed invocations with no owner, keeping the exception set conservative."
      component: "Compiler.AbstractInterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "2249-2253"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/Compiler/src/abstractinterpretation.jl#L2249-L2253"
          snippet: |
            # TODO: When we add curing, we may want to assume this is nothrow
            if (method_or_ci.owner === Nothing && method_or_ci.def.def isa Method)
                exct = Union{exct, ErrorException}
            end
            update_valid_age!(sv, callee_valid_range)
    - summary: "Stdlib precompilation now uses strict=true, causing precompile failures to throw instead of being silently ignored."
      component: "Build"
      evidence:
        - source: "code"
          path: "pkgimage.mk"
          loc: "28-29"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/pkgimage.mk#L28-L29"
          snippet: |
            $(BUILDDIR)/stdlib/%.image: $(JULIAHOME)/stdlib/Project.toml $(JULIAHOME)/stdlib/Manifest.toml $(INDEPENDENT_STDLIBS_SRCS) $(JULIA_DEPOT_PATH)/compiled
            	@$(call PRINT_JULIA, JULIA_CPU_TARGET="$(JULIA_CPU_TARGET)" $(call spawn,$(JULIA_EXECUTABLE)) --startup-file=no -e \
            		'Base.Precompilation.precompilepkgs(configs=[``=>Base.CacheFlags(debug_level=2, opt_level=3), ``=>Base.CacheFlags(check_bounds=1, debug_level=2, opt_level=3)]; strict=true)')
    - summary: "Corrected @lock macro compatibility note: exported in Julia 1.7, not 1.10."
      component: "Base/Stdlib"
      evidence:
        - source: "code"
          path: "base/lock.jl"
          loc: "368-369"
          url: "https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/base/lock.jl#L368-L369"
          snippet: |
            !!! compat
                `@lock` was added in Julia 1.3, and exported in Julia 1.7.
  secondary_effects:
    - effect: "Keyword argument expressions on broadcasted LHS kwcalls are guaranteed to be evaluated once, reducing duplicated side effects in lowered code."
      mechanism: |
        lower-kw-call() builds a `(call ...)` form and invokes remove-argument-side-effects  [src/julia-syntax.scm:1809-1813]
          -> remove-argument-side-effects() walks arguments via arg-to-temp  [src/julia-syntax.scm:1788-1803]
          -> arg-to-temp now handles `parameters` nodes by mapping each child once  [src/julia-syntax.scm:1798-1799]
          -> lowered kwcall uses the transformed args in the emitted block  [src/julia-syntax.scm:1816-1818]
      downstream_surfaces:
        - "Broadcasted assignment lowering"
        - "MacroTools/IRTools that inspect parser AST for kwcall/parameters"
      likelihood: "high"
      impact: "medium"
    - effect: "@artifact_str uses a stable world age captured at Artifacts.__init__, reducing accidental world-age shifts during precompile/invalidations."
      mechanism: |
        Artifacts.__init__() records Base.get_world_counter()  [stdlib/Artifacts/src/Artifacts.jl:21-23]
          -> _artifact_str reads _artifacts_world_age and calls Base.invoke_in_world  [stdlib/Artifacts/src/Artifacts.jl:552-557]
          -> @artifact_str expands to Base.invokelatest(_artifact_str, ...)  [stdlib/Artifacts/src/Artifacts.jl:728-738]
      downstream_surfaces:
        - "LazyArtifacts/Pkg artifact resolution"
        - "Precompile & world-age sensitive tooling"
      likelihood: "medium"
      impact: "medium"
    - effect: "Stdlib precompilation failures now cause build to fail instead of silently continuing, improving CI reliability."
      mechanism: |
        pkgimage.mk rule for stdlib/%.image  [pkgimage.mk:27-29]
          -> Base.Precompilation.precompilepkgs(...; strict=true)  [pkgimage.mk:29]
          -> strict=true causes precompile errors to throw  [Base.Precompilation]
      downstream_surfaces:
        - "Julia build system"
        - "CI pipelines that build Julia"
      likelihood: "high"
      impact: "low"
  compatibility:
    internal_api:
      - field: "Artifacts._artifacts_world_age"
        change: "New module-level Ref storing a frozen world age used by _artifact_str instead of Base._require_world_age."
        affected_tools:
          - tool: "Pkg"
            usage: "Pkg and LazyArtifacts invoke @artifact_str and rely on Base.invokelatest semantics for artifact resolution."
    behavioral:
      - change: "Broadcasted LHS kwcalls now evaluate keyword arguments once, matching positional-arg side-effect stripping semantics."
        affected_code: "User code with side-effecting kw arguments inside broadcasted assignments."
      - change: "Stdlib precompilation failures now halt the build instead of being silently ignored."
        affected_code: "Julia build scripts and CI that builds Julia from source; precompile errors will now be surfaced."
  performance:
    compile_time:
      - impact: "ESTIMATED: negligible extra work from mapping `parameters` nodes in remove-argument-side-effects; still linear in argument count."
    runtime:
      - impact: "ESTIMATED: no measurable overhead; prevents repeated evaluation of kw argument expressions in broadcasted assignments."
  risk:
    level: "low"
    rationale:
      - "Changes are targeted backports with explicit tests for kwcall side effects and LogLevel comparisons."
      - "World-age freeze for artifacts is localized to @artifact_str invocation path."
      - "Build strictness change only affects Julia builds, not end-user code; surfaces previously-hidden errors."
  open_questions:
    - "Do any packages rely on Base._require_world_age during artifact resolution, and should they update if they were indirectly depending on it?"
  recommendations:
    - "Downstream tools that pattern-match kwcall AST nodes should tolerate `parameters` nodes passing through remove-argument-side-effects unchanged except for argument temping."
    - "Pkg/LazyArtifacts maintainers should validate artifact resolution behavior under world-age sensitive precompile scenarios."
