schema_version: "1.0"
pr:
  number: 60326
  title: "Don't create a subprocess in the REPL precompile script"
  url: "https://github.com/JuliaLang/julia/pull/60326"
  diff_url: "https://github.com/JuliaLang/julia/pull/60326.diff"
  author: "xal-0"
  labels:
    - "REPL"
  merged_at: "2025-12-06T13:59:44Z"
  merge_commit_sha: "c8b626d3ad7ffa094cb78d38856faf179b37088a"
  # PR consists of two commits:
  # e977d6f: Remove "; pwd" line to prevent subprocess spawning
  # 40e467c: Add back ";" (code review suggestion) to keep shell mode transition precompiled
  branch_commits:
    - sha: "e977d6f499abf32d33aa1abf4c272a42f1a4f2de"
      message: "Don't create a subprocess in the REPL precompile script"
    - sha: "40e467c6d16a53ae972fba3fd6fe779e426ff86b"
      message: "Apply code review suggestion"

scope:
  files_touched:
    - "stdlib/REPL/src/precompile.jl"
  components:
    - "REPL"
  pipeline_stages:
    - "Precompilation"
    - "Runtime"

analysis:
  intent:
    summary: |
      Fixes CI deadlocks caused by subprocess spawning during REPL precompilation.
      The REPL precompile script uses raw PTY I/O via FakePTYs, and spawning a subprocess
      clears the O_NONBLOCK flag on the PTY (due to upstream libuv bug), causing deadlocks
      when libuv later reads or writes to it from Julia code.

      The PR author notes: "I haven't identified what caused this to become more of a problem
      recently, but I don't think some extra compilation latency when starting shell mode is
      worth it if it's causing mystery timeouts in CI."
    issue_links:
      - url: "https://github.com/JuliaLang/julia/issues/24440"
        description: "Original issue about libuv clearing O_NONBLOCK on subprocess spawn"
      - url: "https://github.com/JuliaLang/julia/issues/60141"
        description: "Detailed analysis showing TTY losing O_NONBLOCK flag after run() with TTY redirection"

  direct_changes:
    - summary: "Remove 'pwd' command from shell mode precompilation to avoid spawning subprocess"
      component: "REPL precompile script"
      evidence:
        - source: "diff"
          path: "stdlib/REPL/src/precompile.jl"
          loc: "79-81"
          url: "https://github.com/JuliaLang/julia/blob/c8b626d3ad7ffa094cb78d38856faf179b37088a/stdlib/REPL/src/precompile.jl#L79-L81"
          snippet: |
            # BEFORE (commit e977d6f parent):
            @time @eval foo(1)
            ; pwd
            $CTRL_C

            # AFTER commit e977d6f (removes pwd entirely):
            @time @eval foo(1)
            $CTRL_C

            # AFTER commit 40e467c (adds back semicolon only):
            @time @eval foo(1)
            ;
            $CTRL_C
        - source: "code"
          path: "stdlib/REPL/src/precompile.jl"
          loc: "71-97"
          url: "https://github.com/JuliaLang/julia/blob/c8b626d3ad7ffa094cb78d38856faf179b37088a/stdlib/REPL/src/precompile.jl#L71-L97"
          snippet: |
            repl_script = """
            2+2
            print("")
            printstyled("a", "b")
            display([1])
            display([1 2; 3 4])
            display("a string")
            foo(x) = 1
            @time @eval foo(1)
            ;
            $CTRL_C
            $CTRL_R$CTRL_C#
            ? reinterpret
            using Ra\t$CTRL_C
            \\alpha\t$CTRL_C
            \e[200~paste here ;)\e[201~"$CTRL_C
            $UP_ARROW$DOWN_ARROW$CTRL_C
            123\b\b\b$CTRL_C
            \b\b$CTRL_C
            f(x) = x03
            f(1,2)
            [][1]
            Base.Iterators.minimum
            cd("complete_path\t\t$CTRL_C
            \x12?\x7f\e[A\e[B\t history\r
            println("done")
            """
        - source: "code"
          path: "stdlib/REPL/src/REPL.jl"
          loc: "1392-1401"
          url: "https://github.com/JuliaLang/julia/blob/c8b626d3ad7ffa094cb78d38856faf179b37088a/stdlib/REPL/src/REPL.jl#L1392-L1401"
          description: "Shell mode transition triggered by semicolon keymap handler"
          snippet: |
            repl_keymap = AnyDict(
                ';' => function (s::MIState,o...)
                    if isempty(s) || position(LineEdit.buffer(s)) == 0
                        buf = copy(LineEdit.buffer(s))
                        transition(s, shell_mode) do
                            LineEdit.state(s, shell_mode).input_buffer = buf
                        end
                    else
                        edit_insert(s, ';')
                        LineEdit.check_show_hint(s)
                    end
                end,
        - source: "code"
          path: "stdlib/REPL/src/REPL.jl"
          loc: "1303-1317"
          url: "https://github.com/JuliaLang/julia/blob/c8b626d3ad7ffa094cb78d38856faf179b37088a/stdlib/REPL/src/REPL.jl#L1303-L1317"
          description: "Shell mode on_done handler that invokes Base.repl_cmd (NOT exercised with just semicolon)"
          snippet: |
            shell_mode = Prompt(SHELL_PROMPT;
                prompt_prefix = hascolor ? repl.shell_color : "",
                prompt_suffix = hascolor ?
                    (repl.envcolors ? Base.input_color : repl.input_color) : "",
                repl = repl,
                complete = ShellCompletionProvider(),
                # Transform "foo bar baz" into `foo bar baz` (shell quoting)
                # and pass into Base.repl_cmd for processing (handles `ls` and `cd`
                # special)
                on_done = respond(repl, julia_prompt) do line
                    Expr(:call, :(Base.repl_cmd),
                        :(Base.cmd_gen($(Base.shell_parse(line::String)[1]))),
                        outstream(repl))
                end,
                sticky = true)

  secondary_effects:
    - effect: "Shell mode still enters but immediately cancels, so shell mode transition is still precompiled"
      mechanism: |
        The semicolon (`;`) triggers shell mode transition via the keymap handler:

        1. User input `;` arrives at keymap handler [REPL.jl:1392-1401]
        2. Handler calls transition(s, shell_mode) [LineEdit.jl:2807-2828]
           - cancel_beep(s)
           - s.mode_state[newmode] = init_state(terminal(s), newmode)  <- first time only
           - s.mode_state[mode(s)] = deactivate(mode(s), state(s), termbuf, t)
           - s.current_mode = newmode
           - activate(newmode, state(s, newmode), termbuf, t)
        3. shell_mode prompt ("shell> ") is displayed
        4. CTRL_C ('\x03') cancels, returning to julia mode

        This precompiles: LineEdit.transition, LineEdit.init_state, LineEdit.activate,
        LineEdit.deactivate, prompt rendering code, and keymap dispatch.

        NOT precompiled: Base.repl_cmd (only called when command is entered and executed)
      downstream_surfaces:
        - "First shell command execution after Julia startup"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/LineEdit.jl"
          loc: "2807-2828"
          url: "https://github.com/JuliaLang/julia/blob/c8b626d3ad7ffa094cb78d38856faf179b37088a/stdlib/REPL/src/LineEdit.jl#L2807-L2828"
          snippet: |
            function transition(f::Function, s::MIState, newmode::Union{TextInterface,Symbol})
                cancel_beep(s)
                if newmode === :abort
                    s.aborted = true
                    return
                end
                if newmode === :reset
                    reset_state(s)
                    return
                end
                if !haskey(s.mode_state, newmode)
                    s.mode_state[newmode] = init_state(terminal(s), newmode)
                end
                termbuf = TerminalBuffer(IOBuffer())
                t = terminal(s)
                s.mode_state[mode(s)] = deactivate(mode(s), state(s), termbuf, t)
                s.current_mode = newmode
                f()
                activate(newmode, state(s, newmode), termbuf, t)
                commit_changes(t, termbuf)
                nothing
            end
    - effect: "Slight increase in startup latency for first shell command"
      mechanism: |
        Previously, the precompile script ran `pwd` which would compile the full shell command path:

        on_done handler [REPL.jl:1312-1316]
          -> Expr(:call, :(Base.repl_cmd), ...)
          -> Base.repl_cmd(cmd, out) [base/client.jl:34-79]
             -> cmd.exec .= expanduser.(cmd.exec)  [line 36]
             -> run(ignorestatus(cmd)) [line 70]  <- triggers subprocess spawn
                -> libuv uv_spawn()
                -> Shell execution ($SHELL -c "pwd")

        Now these are compiled on first shell command use instead.

        Code NOT precompiled includes:
        - Base.repl_cmd function body
        - Base.shell_split, Base.shell_escape_posixly
        - run(::Cmd) subprocess spawning path
        - ignorestatus wrapper
      downstream_surfaces:
        - "First shell mode command in new Julia session"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "base/client.jl"
          loc: "34-79"
          url: "https://github.com/JuliaLang/julia/blob/c8b626d3ad7ffa094cb78d38856faf179b37088a/base/client.jl#L34-L79"
          snippet: |
            function repl_cmd(cmd, out)
                # Immediately expand all arguments, so that typing e.g. ~/bin/foo works.
                cmd.exec .= expanduser.(cmd.exec)

                if isempty(cmd.exec)
                    throw(ArgumentError("no cmd to execute"))
                elseif cmd.exec[1] == "cd"
                    # ... cd handling (lines 40-62)
                else
                    if !Sys.iswindows()
                        shell = shell_split(get(ENV, "JULIA_SHELL", get(ENV, "SHELL", "/bin/sh")))
                        shell_escape_cmd = shell_escape_posixly(cmd)
                        cmd = `$shell -c $shell_escape_cmd`
                    end
                    try
                        run(ignorestatus(cmd))  # <- subprocess spawn happens here
                    catch
                        lasterr = current_exceptions()
                        lasterr = ExceptionStack(NamedTuple[(exception = e[1], backtrace = [] ) for e in lasterr])
                        invokelatest(display_error, lasterr)
                    end
                end
                nothing
            end
    - effect: "CI reliability improved by avoiding O_NONBLOCK race condition"
      mechanism: |
        The REPL precompile script uses raw PTY I/O via FakePTYs module:

        open_fake_pty() [test/testhelpers/FakePTYs.jl:11-49]
          -> posix_openpt(O_RDWR | O_NOCTTY)  <- PTY master with O_NONBLOCK
          -> open(ptsname(fdm), O_RDWR | O_NOCTTY)  <- PTY slave
          -> Returns (pts_fd, ptm_tty)

        When a subprocess is spawned with TTY redirection:
        run(`pwd`, devnull, stdout, devnull) where stdout is a TTY
          -> libuv uv_spawn()
          -> libuv internally duplicates file descriptors
          -> O_NONBLOCK flag is CLEARED on the underlying PTY kernel object
             (This is the libuv bug: libuv/libuv#24440 equivalent)

        After O_NONBLOCK is cleared:
        1. PTY read buffer gets drained
        2. libuv attempts blocking read (expecting non-blocking)
        3. No data available -> process deadlocks in uv__write
        4. One thread holds libuv mutex, blocked in write
        5. Another thread tries to acquire mutex -> deadlock

        Evidence from issue #60141: After `run(\`echo foo\`, devnull, stdout, devnull)`,
        lsof shows the TTY fd no longer has "NB" (non-blocking) flag set.
      downstream_surfaces:
        - "Julia CI infrastructure"
        - "REPL precompilation during sysimage build"
        - "Any test using FakePTYs with subprocess spawning"
      likelihood: "high"
      impact: "high"
      evidence:
        - source: "code"
          path: "test/testhelpers/FakePTYs.jl"
          loc: "27-48"
          url: "https://github.com/JuliaLang/julia/blob/c8b626d3ad7ffa094cb78d38856faf179b37088a/test/testhelpers/FakePTYs.jl#L27-L48"
          snippet: |
            else
                O_RDWR = Base.Filesystem.JL_O_RDWR
                O_NOCTTY = Base.Filesystem.JL_O_NOCTTY

                fdm = ccall(:posix_openpt, Cint, (Cint,), O_RDWR | O_NOCTTY)
                fdm == -1 && error("Failed to open ptm")
                rc = ccall(:grantpt, Cint, (Cint,), fdm)
                rc != 0 && error("grantpt failed")
                rc = ccall(:unlockpt, Cint, (Cint,), fdm)
                rc != 0 && error("unlockpt")

                fds = ccall(:open, Cint, (Ptr{UInt8}, Cint, UInt32...),
                    ccall(:ptsname, Ptr{UInt8}, (Cint,), fdm), O_RDWR | O_NOCTTY)
                pts = RawFD(fds)

                ptm = Base.TTY(RawFD(fdm))
            end
            return pts, ptm

  compatibility:
    internal_api: []
    behavioral:
      - item: "First shell command slightly slower on fresh Julia startup"
        description: |
          The Base.repl_cmd code path is no longer precompiled during sysimage creation.
          Users will experience a small compilation delay on their first shell mode command.
        severity: "minimal"
        workaround: "None needed - one-time minor delay"

  performance:
    compile_time:
      - item: "Slightly reduced precompilation work for sysimage"
        description: |
          Avoids compiling subprocess spawning code (Base.repl_cmd full path) during
          REPL precompilation. ESTIMATED: negligible reduction in sysimage build time.
    runtime:
      - item: "First shell command has compilation overhead"
        description: |
          First shell mode command in a fresh Julia session will trigger compilation
          of Base.repl_cmd and subprocess spawning code.
          ESTIMATED: ~100-500ms one-time delay on first shell command.
      - item: "Eliminated CI deadlocks from O_NONBLOCK race"
        description: |
          Removes the race condition that caused mystery timeouts in CI by avoiding
          subprocess spawning with PTY I/O during precompilation.
          MEASURED: CI reliability improvement (referenced in PR discussion).

  risk:
    level: "low"
    rationale:
      - "Change is minimal - removes one command from precompile script"
      - "No functional change to REPL behavior, only precompilation coverage"
      - "Trade-off: slightly slower first shell command vs CI reliability"
      - "Shell mode transition (`;`) is still precompiled, only execution is not"

  open_questions:
    - "Will the upstream libuv bug (#24440) ever be fixed to allow subprocess spawning with PTY I/O?"
    - "Are there other precompilation scenarios that might trigger similar O_NONBLOCK issues?"

  recommendations:
    - "Monitor CI for any remaining REPL precompilation deadlocks"
    - "Consider documenting the O_NONBLOCK limitation for developers working on REPL tests"
    - "The root cause (libuv #24440) should ideally be fixed upstream"

  reviewer_notes:
    verification_date: "2026-01-22"
    verified_items:
      - "Confirmed PR consists of two commits: e977d6f (remove '; pwd') and 40e467c (add back ';')"
      - "Verified shell mode transition code path in REPL.jl:1392-1401"
      - "Verified LineEdit.transition function at LineEdit.jl:2807-2828"
      - "Verified Base.repl_cmd function at base/client.jl:34-79"
      - "Verified FakePTYs module at test/testhelpers/FakePTYs.jl"
      - "Confirmed issue #60141 describes O_NONBLOCK flag being cleared after subprocess spawn"
    additional_findings:
      - "The shell_mode on_done handler constructs an Expr calling Base.repl_cmd, not invoked when CTRL_C cancels"
      - "The transition() function initializes mode state only on first entry, so shell mode init is precompiled"
      - "FakePTYs uses posix_openpt and ptsname for PTY creation, not Base.Filesystem.File directly"
    confidence: "high"
    notes: |
      Original analysis was accurate. Enhancements added:
      - Commit structure showing two-commit PR evolution
      - Complete code snippets for shell_mode setup and transition function
      - Detailed call chain showing what gets precompiled vs not
      - Evidence from FakePTYs showing PTY creation mechanism
      - Link to issue #60141 with O_NONBLOCK evidence

# =============================================================================
# DETAILED CALL CHAIN ANALYSIS
# =============================================================================
#
# WHAT IS PRECOMPILED (with `;` alone):
# =====================================
# 1. User types `;` -> dispatched to keymap handler
#    keymap_handler [REPL.jl:1392-1401]
#      -> if isempty(s) || position(LineEdit.buffer(s)) == 0
#      -> buf = copy(LineEdit.buffer(s))
#      -> transition(s, shell_mode) do ... end
#
# 2. LineEdit.transition() is called [LineEdit.jl:2807-2828]
#      -> cancel_beep(s)
#      -> s.mode_state[newmode] = init_state(terminal(s), newmode)  [first time]
#      -> s.mode_state[mode(s)] = deactivate(mode(s), state(s), termbuf, t)
#      -> s.current_mode = newmode
#      -> f()  (the callback function)
#      -> activate(newmode, state(s, newmode), termbuf, t)
#      -> commit_changes(t, termbuf)
#
# 3. Shell prompt "shell> " is rendered
#
# 4. CTRL_C ('\x03') is received -> cancels input, returns to julia mode
#
# WHAT IS NOT PRECOMPILED (previously was with `; pwd`):
# ======================================================
# 1. on_done callback [REPL.jl:1312-1316]
#      -> respond(repl, julia_prompt) do line
#           Expr(:call, :(Base.repl_cmd), ...)
#         end
#
# 2. Base.repl_cmd() [base/client.jl:34-79]
#      -> cmd.exec .= expanduser.(cmd.exec)
#      -> For non-cd commands:
#           shell = shell_split(get(ENV, "JULIA_SHELL", get(ENV, "SHELL", "/bin/sh")))
#           shell_escape_cmd = shell_escape_posixly(cmd)
#           cmd = `$shell -c $shell_escape_cmd`
#           run(ignorestatus(cmd))  <- SUBPROCESS SPAWNED HERE
#
# 3. run(::Cmd) [base/process.jl]
#      -> libuv uv_spawn()
#      -> Creates child process
#      -> On Unix: fork/exec
#      -> File descriptor manipulation can clear O_NONBLOCK
#
# WHY THE DEADLOCK OCCURRED:
# ==========================
# The FakePTYs module creates PTYs with expected O_NONBLOCK behavior.
# When subprocess runs with TTY output redirection:
#
# open_fake_pty() [test/testhelpers/FakePTYs.jl]
#   -> posix_openpt(O_RDWR | O_NOCTTY)
#   -> Returns PTY master with O_NONBLOCK set by libuv
#
# run(`pwd`) with TTY stdout:
#   -> libuv uv_spawn() internally manipulates fds
#   -> O_NONBLOCK flag gets cleared on PTY kernel object (libuv bug)
#
# Later in precompile script:
#   -> libuv tries to read/write PTY
#   -> Expects non-blocking I/O
#   -> Gets blocking I/O instead
#   -> Thread blocks in uv__write holding libuv mutex
#   -> Other thread waits for mutex -> DEADLOCK
#
# This PR removes the subprocess spawn, eliminating the O_NONBLOCK race.
# =============================================================================
