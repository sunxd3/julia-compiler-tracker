schema_version: "1.0"
pr:
  number: 59413
  title: "inference: reinfer and track missing code for inlining"
  url: "https://github.com/JuliaLang/julia/pull/59413"
  author: "vtjnash"
  labels:
    - "compiler:inference"
  merged_at: "2025-11-10T18:56:38Z"
  merge_commit_sha: "998cb27e4c83364a38378841c88c954ac1e7eb59"
  diff_url: "https://github.com/JuliaLang/julia/pull/59413.diff"
scope:
  files_touched:
    - "Compiler/src/abstractinterpretation.jl"
    - "Compiler/src/stmtinfo.jl"
    - "Compiler/src/typeinfer.jl"
    - "Compiler/test/inline.jl"
    - "Compiler/test/newinterp.jl"
    - "contrib/generate_precompile.jl"
    - "src/jltypes.c"
    - "src/staticdata.c"
    - "stdlib/REPL/src/REPLCompletions.jl"
    - "test/cmdlineargs.jl"
    - "test/core.jl"
  components:
    - "Compiler.AbstractInterpretation"
    - "Compiler.TypeInference"
    - "Compiler.StmtInfo"
    - "Compiler.Inlining"
    - "Runtime"
    - "Serialization"
    - "REPL"
    - "Tests"
  pipeline_stages:
    - "TypeInference"
    - "Inlining"
    - "Optimization"
    - "Sysimg/Serialization"
    - "REPL"
analysis:
  intent:
    summary: "Ensure inference regenerates inlineable IR when missing so that the optimizer can inline correctly, and track inference results per match to guide const-prop and inlining decisions."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/59846"
  direct_changes:
    - summary: "Method match metadata now stores per-match inferred call results, and generic-call inference records them for later compilation-signature inference."
      component: "Compiler.AbstractInterpretation / Compiler.StmtInfo"
      evidence:
        - source: "code"
          path: "Compiler/src/stmtinfo.jl"
          loc: "52-64"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/stmtinfo.jl#L52-L64"
          snippet: |
            struct MethodMatchInfo <: CallInfo
                results::MethodLookupResult
                mt::MethodTable
                atype
                fullmatch::Bool
                edges::Vector{Union{Nothing,CodeInstance}}
                call_results::Vector{Union{Nothing,InferredCallResult}}
                function MethodMatchInfo(
                    results::MethodLookupResult, mt::MethodTable, @nospecialize(atype), fullmatch::Bool)
                    edges = fill!(Vector{Union{Nothing,CodeInstance}}(undef, length(results)), nothing)
                    call_results = fill!(Vector{Union{Nothing,InferredCallResult}}(undef, length(results)), nothing)
                    return new(results, mt, atype, fullmatch, edges, call_results)
                end
            end
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "125-242"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L125-L242"
          snippet: |
            (; valid_worlds, applicable) = matches
            update_valid_age!(sv, get_inference_world(interp), valid_worlds) # need to record the negative world now, since even if we don't generate any useful information, inlining might want to add an invoke edge and it won't have this information anymore
            if bail_out_toplevel_call(interp, sv)
                local napplicable = length(applicable)
                for i = 1:napplicable
                    local sig = applicable[i].match.spec_types
                    if !isdispatchtuple(sig)
                        # only infer fully concrete call sites in top-level expressions (ignoring even isa_compileable_sig matches)
                        add_remark!(interp, sv, "Refusing to infer non-concrete call site in top-level expression")
                        return Future(CallMeta(Any, Any, Effects(), NoCallInfo()))
                    end
                end
            end
            mresult = abstract_call_method(interp, method, sig, match.sparams, multiple_matches, si, sv)::Future
            function handle1(interp, sv)
                local (; rt, exct, effects, edge, call_result) = mresult[]
                this_conditional = ignorelimited(rt)
                this_rt = widenwrappedconditional(rt)
                this_exct = exct
                const_call_result = abstract_call_method_with_const_args(interp,
                    mresult[], state.func, this_arginfo, si, match, sv)
                if const_call_result !== nothing
                    this_const_conditional = ignorelimited(const_call_result.rt)
                    this_const_rt = widenwrappedconditional(const_call_result.rt)
                    const_result = const_edge = nothing
                    if this_const_rt ⊑ₚ this_rt
                        this_conditional = this_const_conditional
                        this_rt = this_const_rt
                        (; effects, const_result, const_edge) = const_call_result
                    elseif is_better_effects(const_call_result.effects, effects)
                        (; effects, const_result, const_edge) = const_call_result
                    else
                        add_remark!(interp, sv, "[constprop] Discarded because the result was wider than inference")
                    end
                    if const_call_result.exct ⋤ this_exct
                        this_exct = const_call_result.exct
                        (; const_result, const_edge) = const_call_result
                    else
                        add_remark!(interp, sv, "[constprop] Discarded exception type because result was wider than inference")
                    end
                    if const_edge !== nothing
                        edge = const_edge
                        update_valid_age!(sv, get_inference_world(interp), world_range(const_edge))
                    end
                    if const_result !== nothing
                        call_result = const_result
                    end
                end
                state.all_effects = merge_effects(state.all_effects, effects)
                @assert !(this_conditional isa Conditional || this_rt isa MustAlias) "invalid lattice element returned from inter-procedural context"
                if can_propagate_conditional(this_conditional, argtypes)
                    this_rt = this_conditional
                end
                edges[edge_idx] = edge
                call_results[edge_idx] = call_result
    - summary: "Edge inference now returns an InferenceResult in MethodCallResult.call_result when available, enabling later inlineability checks against the actual inferred source."
      component: "Compiler.TypeInference"
      evidence:
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "1208-1231"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/typeinfer.jl#L1208-L1231"
          snippet: |
            push!(caller.tasks, function get_infer_result(interp, caller)
                update_valid_age!(caller, get_inference_world(interp), frame.valid_worlds)
                local isinferred = is_inferred(frame)
                local effects
                local edge = nothing
                local call_result = nothing
                if isinferred
                    edge = result.ci
                    if edge_ci isa CodeInstance && codeinst_edges_sub(edge_ci, edge.min_world, edge.max_world, edge.edges)
                        edge = edge_ci # override the edge for tracking invalidation
                    end
                    result.ci_as_edge = edge # override the edge for tracking purposes
                    effects = result.ipo_effects # effects are adjusted already within `finish` for ipo_effects
                    call_result = result
                else
                    effects = adjust_effects(effects_for_cycle(frame.ipo_effects), method)
                    add_cycle_backedge!(caller, frame)
                end
                local bestguess = frame.bestguess
                local exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
                mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,
                    edge, edgecycle, edgelimited, call_result)
                return true
            end)
    - summary: "Const-prop heuristics and semi-concrete evaluation now consult the inferred source carried in call_result for inlineability decisions and irinterp setup."
      component: "Compiler.AbstractInterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "1208-1278"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L1208-L1278"
          snippet: |
            if inf_result isa InferenceResult
                inferred = inf_result.src
                # TODO propagate a specific `CallInfo` that conveys information about this call
                if src_inlining_policy(interp, mi, inferred, NoCallInfo(), IR_FLAG_NULL)
                    return true
                end
            end
            return false # the cache isn't inlineable, so this constant-prop' will most likely be unfruitful
            end

            function semi_concrete_eval_call(interp::AbstractInterpreter,
                mi::MethodInstance, result::MethodCallResult, arginfo::ArgInfo, sv::AbsIntState)
                call_result = result.call_result
                call_result isa InferenceResult || return nothing
                codeinst = call_result.ci
                codeinst isa CodeInstance || return nothing
                inferred = call_result.src
                src_inlining_policy(interp, mi, inferred, NoCallInfo(), IR_FLAG_NULL) || return nothing # hack to work-around test failures caused by #58183 until both it and #48913 are fixed
                irsv = IRInterpretationState(interp, codeinst, mi, arginfo.argtypes, inferred)
                irsv === nothing && return nothing
                assign_parentchild!(irsv, sv)
                rt, (nothrow, noub) = ir_abstract_constant_propagation(interp, irsv)
                @assert !(rt isa Conditional || rt isa MustAlias) "invalid lattice element returned from irinterp"
                if !(isa(rt, Type) && hasintersect(rt, Bool))
                    ir = irsv.ir
                    effects = result.effects
                    if nothrow
                        effects = Effects(effects; nothrow=true)
                    end
                    if noub
                        effects = Effects(effects; noub=ALWAYS_TRUE)
                    end
                    exct = refine_exception_type(result.exct, effects)
                    semi_concrete_result = SemiConcreteResult(codeinst, ir, effects, spec_info(irsv))
                    const_edge = nothing # TODO use the edges from irsv?
                    return ConstCallResult(rt, exct, semi_concrete_result, effects, const_edge)
                end
                nothing
            end
    - summary: "Inlining tests now assert that a second inlining pass does not inline a call when inference recorded a noinline decision, even if the callsite flag is manually cleared."
      component: "Compiler.Inlining Tests"
      evidence:
        - source: "code"
          path: "Compiler/test/inline.jl"
          loc: "1876-1889"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/test/inline.jl#L1876-L1889"
          snippet: |
            call_func_mul_int(a::Int, b::Int) = @noinline func_mul_int(a, b)
            multi_inlining2(a::Int, b::Int) = call_func_mul_int(a, b)
            let i::Int, continue_::Bool
                interp = Compiler.NativeInterpreter()
                # check if callsite `@noinline` annotation works
                ir, = only(Base.code_ircode(multi_inlining2, (Int,Int); optimize_until="CC: INLINING", interp))
                i = findfirst(isinvoke(:func_mul_int), ir.stmts.stmt)
                @test i !== nothing
                # now delete the callsite flag, and see the second inlining pass does not inline the call, since inference recorded it should not
                ir.stmts[i][:flag] &= ~Compiler.IR_FLAG_NOINLINE
                inlining = Compiler.InliningState(interp)
                ir = Compiler.ssa_inlining_pass!(ir, inlining, false)
                @test findfirst(isinvoke(:func_mul_int), ir.stmts.stmt) !== nothing
                @test findfirst(iscall((ir, Core.Intrinsics.mul_int)), ir.stmts.stmt) === nothing
            end
    - summary: "CodeInstance const-field metadata no longer marks analysis_results as const, and tests reflect the updated const list."
      component: "Runtime"
      evidence:
        - source: "code"
          path: "src/jltypes.c"
          loc: "3719-3724"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/src/jltypes.c#L3719-L3724"
          snippet: |
            jl_svecset(jl_code_instance_type->types, 2, jl_code_instance_type);
            const static uint32_t code_instance_constfields[1]  = { 0b000001110000011100011 }; // Set fields 1, 2, 6-8, 14-16 as const
            const static uint32_t code_instance_atomicfields[1] = { 0b111110001011100011100 }; // Set fields 3-5, 9-12, 13, 17-21 as atomic
            // Fields 4-5 are only operated on by construction and deserialization, so are effectively const at runtime
            // Fields ipo_purity_bits and analysis_results are not currently threadsafe or reliable, as they get mutated after optimization, but are not declared atomic
        - source: "test"
          path: "test/core.jl"
          loc: "16-21"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/test/core.jl#L16-L21"
          snippet: |
            # sanity tests that our built-in types are marked correctly for const fields
            for (T, c) in (
                    (Core.CodeInfo, []),
                    (Core.CodeInstance, [:def, :owner, :rettype, :exctype, :rettype_const, :time_infer_total, :time_infer_cache_saved, :time_infer_self]),
                    (Core.Method, [#=:name, :module, :file, :line, :primary_world, :sig, :slot_syms, :external_mt, :nargs, :called, :nospecialize, :nkw, :isva, :is_for_opaque_closure, :constprop=#]),
  secondary_effects:
    - effect: "Inlining decisions become more stable because const-prop heuristics now consult the actual inferred source of callees, preventing a later inlining pass from undoing a noinline choice that inference already recorded."
      mechanism: |
        abstract_call_gf_by_type() stores call_results per MethodMatchTarget [abstractinterpretation.jl:148-242]
          -> infercalls2() passes call_results to const_prop_methodinstance_heuristic() [abstractinterpretation.jl:301-308]
          -> const_prop_methodinstance_heuristic() checks src_inlining_policy on inf_result.src [abstractinterpretation.jl:1233-1241]
          -> inlining tests verify no inlining on second pass when inference recorded noinline [Compiler/test/inline.jl:1876-1889]
      downstream_surfaces:
        - "Core.Compiler inlining and constant-propagation heuristics"
        - "SSA inlining pass stability"
      likelihood: "high"
      impact: "medium"
    - effect: "Semi-concrete evaluation (irinterp) now requires an InferenceResult-backed CodeInstance and inlineable source, which can reduce irinterp attempts on cached but non-inlineable code."
      mechanism: |
        typeinf_edge() populates MethodCallResult.call_result with InferenceResult when available [typeinfer.jl:1208-1231]
          -> semi_concrete_eval_call() uses result.call_result.ci and result.call_result.src [abstractinterpretation.jl:1248-1276]
          -> src_inlining_policy gate can block irinterp when source is not inlineable [abstractinterpretation.jl:1255-1256]
      downstream_surfaces:
        - "IRInterpreter-based const-prop"
        - "Inlining preparation for cached CodeInstances"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api:
      - field: "Core.Compiler.MethodMatchInfo.call_results"
        change: "New per-match storage for InferredCallResult; downstream CallInfo consumers should tolerate or use the extra field."
        affected_tools:
          - tool: "REPLInterpreter"
            usage: "REPL stdlib wraps MethodCallResult and forwards the new call_result field in concrete_eval_eligible."
            evidence:
              - source: "code"
                path: "stdlib/REPL/src/REPLCompletions.jl"
                loc: "602-609"
                url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/stdlib/REPL/src/REPLCompletions.jl#L602-L609"
                snippet: |
                  if (interp.limit_aggressive_inference ? is_repl_frame(sv) : is_call_stack_uncached(sv))
                      neweffects = CC.Effects(result.effects; consistent=CC.ALWAYS_TRUE)
                      result = CC.MethodCallResult(result.rt, result.exct, neweffects, result.edge,
                                                   result.edgecycle, result.edgelimited, result.call_result)
                  end
      - field: "Core.Compiler.MethodCallResult.call_result"
        change: "Replaces the previous volatile_inf_result slot and now carries InferredCallResult for use in const-prop and irinterp."
        affected_tools:
          - tool: "Custom AbstractInterpreter implementations"
            usage: "Any custom MethodCallResult constructors must pass/forward call_result to preserve inference metadata (as REPLInterpreter does)."
            evidence:
              - source: "code"
                path: "Compiler/src/abstractinterpretation.jl"
                loc: "821-833"
                url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L821-L833"
                snippet: |
                  struct MethodCallResult
                      rt
                      exct
                      effects::Effects
                      edge::Union{Nothing,CodeInstance}
                      edgecycle::Bool
                      edgelimited::Bool
                      call_result::Union{Nothing,InferredCallResult}
                      function MethodCallResult(@nospecialize(rt), @nospecialize(exct), effects::Effects,
                                                edge::Union{Nothing,CodeInstance}, edgecycle::Bool, edgelimited::Bool,
                                                call_result::Union{Nothing,InferredCallResult} = nothing)
                          return new(rt, exct, effects, edge, edgecycle, edgelimited, call_result)
                      end
                  end
    behavioral:
      - change: "Second inlining pass respects inference-recorded noinline decisions even if callsite flag is cleared, as enforced by updated tests."
        evidence:
          - source: "test"
            path: "Compiler/test/inline.jl"
            loc: "1876-1889"
            url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/test/inline.jl#L1876-L1889"
            snippet: |
              call_func_mul_int(a::Int, b::Int) = @noinline func_mul_int(a, b)
              multi_inlining2(a::Int, b::Int) = call_func_mul_int(a, b)
              let i::Int, continue_::Bool
                  interp = Compiler.NativeInterpreter()
                  # check if callsite `@noinline` annotation works
                  ir, = only(Base.code_ircode(multi_inlining2, (Int,Int); optimize_until="CC: INLINING", interp))
                  i = findfirst(isinvoke(:func_mul_int), ir.stmts.stmt)
                  @test i !== nothing
                  # now delete the callsite flag, and see the second inlining pass does not inline the call, since inference recorded it should not
                  ir.stmts[i][:flag] &= ~Compiler.IR_FLAG_NOINLINE
                  inlining = Compiler.InliningState(interp)
                  ir = Compiler.ssa_inlining_pass!(ir, inlining, false)
                  @test findfirst(isinvoke(:func_mul_int), ir.stmts.stmt) !== nothing
                  @test findfirst(iscall((ir, Core.Intrinsics.mul_int)), ir.stmts.stmt) === nothing
  performance:
    compile_time:
      - impact: "ESTIMATED: additional storage and bookkeeping for call_results per method match; minor overhead proportional to number of applicable methods."
        evidence:
          - source: "code"
            path: "Compiler/src/stmtinfo.jl"
            loc: "52-64"
            url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/stmtinfo.jl#L52-L64"
            snippet: |
              struct MethodMatchInfo <: CallInfo
                  results::MethodLookupResult
                  mt::MethodTable
                  atype
                  fullmatch::Bool
                  edges::Vector{Union{Nothing,CodeInstance}}
                  call_results::Vector{Union{Nothing,InferredCallResult}}
                  function MethodMatchInfo(
                      results::MethodLookupResult, mt::MethodTable, @nospecialize(atype), fullmatch::Bool)
                  edges = fill!(Vector{Union{Nothing,CodeInstance}}(undef, length(results)), nothing)
                  call_results = fill!(Vector{Union{Nothing,InferredCallResult}}(undef, length(results)), nothing)
                  return new(results, mt, atype, fullmatch, edges, call_results)
              end
    runtime:
      - impact: "ESTIMATED: improved runtime in cases where previously-missing inlineable IR prevented inlining, by ensuring inference regenerates inlineable sources when needed."
        evidence:
          - source: "code"
            path: "Compiler/src/typeinfer.jl"
            loc: "1123-1133"
            url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/typeinfer.jl#L1123-L1133"
            snippet: |
              if codeinst isa CodeInstance
                  need_inlineable_code = may_optimize(interp) && (force_inline || is_inlineable(inferred))
                  if need_inlineable_code
                      src = ci_get_source(interp, codeinst, inferred)
                      if src === nothing
                          # Re-infer to get the appropriate source representation
                          cache_mode = CACHE_MODE_LOCAL
                          edge_ci = codeinst
                      else # no reinference needed
                          @assert codeinst.def === mi "MethodInstance for cached edge does not match"
                          return return_cached_result(interp, method, code, src, caller, edgecycle, edgelimited)
                      end
                  else # no reinference needed
  risk:
    level: "medium"
    rationale:
      - "Touches inference/inlining heuristics and adds a new call_result dataflow; incorrect propagation could change inlining or const-prop behavior."
      - "Modifies CodeInstance const-field metadata, which affects assumptions about mutability during optimization."
  open_questions:
    - "Are there additional AbstractInterpreter implementations (outside stdlib) that construct MethodCallResult without forwarding call_result and need updates?"
    - "Should the semi-concrete eval inlineability gate be revisited once #58183 and #48913 are resolved to avoid skipping irinterp when source is available but not inlineable?"
  recommendations:
    - "Downstream compiler tooling that wraps or constructs MethodCallResult should forward call_result to preserve inference metadata."
    - "Consider adding a small note in developer docs about MethodMatchInfo.call_results and MethodCallResult.call_result to avoid silent tooling breakage."
