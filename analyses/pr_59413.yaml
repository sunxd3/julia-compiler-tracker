schema_version: "1.0"
pr:
  number: 59413
  title: "inference: reinfer and track missing code for inlining"
  url: "https://github.com/JuliaLang/julia/pull/59413"
  author: "vtjnash"
  labels:
    - "compiler:inference"
  merged_at: "2025-11-10T18:56:38Z"
  merge_commit_sha: "998cb27e4c83364a38378841c88c954ac1e7eb59"
  diff_url: "https://github.com/JuliaLang/julia/pull/59413.diff"
scope:
  files_touched:
    - "Compiler/src/abstractinterpretation.jl"
    - "Compiler/src/stmtinfo.jl"
    - "Compiler/src/typeinfer.jl"
    - "Compiler/src/types.jl"
    - "Compiler/src/ssair/inlining.jl"
    - "Compiler/test/inline.jl"
    - "Compiler/test/newinterp.jl"
    - "contrib/generate_precompile.jl"
    - "src/jltypes.c"
    - "src/staticdata.c"
    - "stdlib/REPL/src/REPLCompletions.jl"
    - "test/cmdlineargs.jl"
    - "test/core.jl"
  components:
    - "Compiler.AbstractInterpretation"
    - "Compiler.TypeInference"
    - "Compiler.StmtInfo"
    - "Compiler.Inlining"
    - "Runtime"
    - "Serialization"
    - "REPL"
    - "Tests"
  pipeline_stages:
    - "TypeInference"
    - "Inlining"
    - "Optimization"
    - "Sysimg/Serialization"
    - "REPL"
analysis:
  intent:
    summary: "Regenerate missing inlineable IR during inference; track per-match inference results for const-prop and inlining."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/59846"
  direct_changes:
    - summary: "MethodMatchInfo stores per-match inferred call results; generic-call inference records them for later use."
      component: "Compiler.AbstractInterpretation / Compiler.StmtInfo"
      evidence:
        - source: "code"
          path: "Compiler/src/stmtinfo.jl"
          loc: "52-65"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/stmtinfo.jl#L52-L65"
          snippet: |
            struct MethodMatchInfo <: CallInfo
                results::MethodLookupResult
                mt::MethodTable
                atype
                fullmatch::Bool
                edges::Vector{Union{Nothing,CodeInstance}}
                call_results::Vector{Union{Nothing,InferredCallResult}}
                function MethodMatchInfo(
                    results::MethodLookupResult, mt::MethodTable, @nospecialize(atype), fullmatch::Bool)
                    edges = fill!(Vector{Union{Nothing,CodeInstance}}(undef, length(results)), nothing)
                    call_results = fill!(Vector{Union{Nothing,InferredCallResult}}(undef, length(results)), nothing)
                    return new(results, mt, atype, fullmatch, edges, call_results)
                end
            end
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "53-58"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L53-L58"
          snippet: |
            struct MethodMatchTarget
                match::MethodMatch
                edges::Vector{Union{Nothing,CodeInstance}}
                call_results::Vector{Union{Nothing,InferredCallResult}}
                edge_idx::Int
            end
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "148-148"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L148"
          snippet: |
            (; match, edges, call_results, edge_idx) = applicable[state.inferidx]
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "241-242"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L241-L242"
          snippet: |
            edges[edge_idx] = edge
            call_results[edge_idx] = call_result
    - summary: "typeinf_edge populates MethodCallResult.call_result with InferenceResult for inlineability checks."
      component: "Compiler.TypeInference"
      evidence:
        - source: "code"
          path: "Compiler/src/typeinfer.jl"
          loc: "1207-1234"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/typeinfer.jl#L1207-L1234"
          snippet: |
            let mresult = Future{MethodCallResult}()
                push!(caller.tasks, function get_infer_result(interp, caller)
                    update_valid_age!(caller, get_inference_world(interp), frame.valid_worlds)
                    local isinferred = is_inferred(frame)
                    local effects
                    local edge = nothing
                    local call_result = nothing
                    if isinferred
                        edge = result.ci
                        if edge_ci isa CodeInstance && codeinst_edges_sub(edge_ci, edge.min_world, edge.max_world, edge.edges)
                            edge = edge_ci # override the edge for tracking invalidation
                        end
                        result.ci_as_edge = edge # override the edge for tracking purposes
                        effects = result.ipo_effects # effects are adjusted already within `finish` for ipo_effects
                        call_result = result
                    else
                        effects = adjust_effects(effects_for_cycle(frame.ipo_effects), method)
                        add_cycle_backedge!(caller, frame)
                    end
                    local bestguess = frame.bestguess
                    local exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
                    mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,
                        edge, edgecycle, edgelimited, call_result)
                    return true
                end)
                return mresult
            end
    - summary: "Const-prop heuristics and semi-concrete evaluation consult call_result.src for inlineability."
      component: "Compiler.AbstractInterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "1206-1246"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L1206-L1246"
          snippet: |
            function const_prop_methodinstance_heuristic(interp::AbstractInterpreter,
                inf_result::Union{InferenceResult,Nothing}, mi::MethodInstance, arginfo::ArgInfo, sv::AbsIntState)
                method = mi.def::Method
                if method.is_for_opaque_closure
                    # Not inlining an opaque closure can be very expensive, so be generous
                    # with the const-prop-ability.
                    return true
                end
                if is_declared_inline(method)
                    return true
                end
                flag = get_curr_ssaflag(sv)
                if is_stmt_inline(flag)
                    return true
                elseif is_stmt_noinline(flag)
                    return false
                else
                    if inf_result isa InferenceResult
                        inferred = inf_result.src
                        # TODO propagate a specific `CallInfo` that conveys information about this call
                        if src_inlining_policy(interp, mi, inferred, NoCallInfo(), IR_FLAG_NULL)
                            return true
                        end
                    end
                end
                return false # the cache isn't inlineable, so this constant-prop' will most likely be unfruitful
            end
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "1248-1281"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L1248-L1281"
          snippet: |
            function semi_concrete_eval_call(interp::AbstractInterpreter,
                mi::MethodInstance, result::MethodCallResult, arginfo::ArgInfo, sv::AbsIntState)
                call_result = result.call_result
                call_result isa InferenceResult || return nothing
                codeinst = call_result.ci
                codeinst isa CodeInstance || return nothing
                inferred = call_result.src
                src_inlining_policy(interp, mi, inferred, NoCallInfo(), IR_FLAG_NULL) || return nothing
                irsv = IRInterpretationState(interp, codeinst, mi, arginfo.argtypes, inferred)
                irsv === nothing && return nothing
                assign_parentchild!(irsv, sv)
                rt, (nothrow, noub) = ir_abstract_constant_propagation(interp, irsv)
                @assert !(rt isa Conditional || rt isa MustAlias) "invalid lattice element returned from irinterp"
                if !(isa(rt, Type) && hasintersect(rt, Bool))
                    ir = irsv.ir
                    effects = result.effects
                    if nothrow
                        effects = Effects(effects; nothrow=true)
                    end
                    if noub
                        effects = Effects(effects; noub=ALWAYS_TRUE)
                    end
                    exct = refine_exception_type(result.exct, effects)
                    semi_concrete_result = SemiConcreteResult(codeinst, ir, effects, spec_info(irsv))
                    const_edge = nothing # TODO use the edges from irsv?
                    return ConstCallResult(rt, exct, semi_concrete_result, effects, const_edge)
                end
                nothing
            end
    - summary: "Inlining tests verify second pass respects inference-recorded noinline when callsite flags cleared."
      component: "Compiler.Inlining Tests"
      evidence:
        - source: "code"
          path: "Compiler/test/inline.jl"
          loc: "1876-1890"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/test/inline.jl#L1876-L1890"
          snippet: |
            call_func_mul_int(a::Int, b::Int) = @noinline func_mul_int(a, b)
            multi_inlining2(a::Int, b::Int) = call_func_mul_int(a, b)
            let i::Int, continue_::Bool
                interp = Compiler.NativeInterpreter()
                # check if callsite `@noinline` annotation works
                ir, = only(Base.code_ircode(multi_inlining2, (Int,Int); optimize_until="CC: INLINING", interp))
                i = findfirst(isinvoke(:func_mul_int), ir.stmts.stmt)
                @test i !== nothing
                # now delete the callsite flag, and see the second inlining pass does not inline the call, since inference recorded it should not
                ir.stmts[i][:flag] &= ~Compiler.IR_FLAG_NOINLINE
                inlining = Compiler.InliningState(interp)
                ir = Compiler.ssa_inlining_pass!(ir, inlining, false)
                @test findfirst(isinvoke(:func_mul_int), ir.stmts.stmt) !== nothing
                @test findfirst(iscall((ir, Core.Intrinsics.mul_int)), ir.stmts.stmt) === nothing
            end
    - summary: "CodeInstance const-field metadata no longer marks analysis_results as const."
      component: "Runtime"
      evidence:
        - source: "code"
          path: "src/jltypes.c"
          loc: "3722-3726"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/src/jltypes.c#L3722-L3726"
          snippet: |
            const static uint32_t code_instance_constfields[1]  = { 0b000001110000011100011 }; // Set fields 1, 2, 6-8, 14-16 as const
            const static uint32_t code_instance_atomicfields[1] = { 0b111110001011100011100 }; // Set fields 3-5, 9-12, 13, 17-21 as atomic
            // Fields 4-5 are only operated on by construction and deserialization, so are effectively const at runtime
            // Fields ipo_purity_bits and analysis_results are not currently threadsafe or reliable, as they get mutated after optimization, but are not declared atomic
            // and there is no way to tell (during inference) if their value is finalized yet (to wait for them to be narrowed if applicable)
        - source: "test"
          path: "test/core.jl"
          loc: "16-21"
          url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/test/core.jl#L16-L21"
          snippet: |
            # sanity tests that our built-in types are marked correctly for const fields
            for (T, c) in (
                    (Core.CodeInfo, []),
                    (Core.CodeInstance, [:def, :owner, :rettype, :exctype, :rettype_const, :time_infer_total, :time_infer_cache_saved, :time_infer_self]),
                    (Core.Method, [#=:name, :module, :file, :line, :primary_world, :sig, :slot_syms, :external_mt, :nargs, :called, :nospecialize, :nkw, :isva, :is_for_opaque_closure, :constprop=#]),
  secondary_effects:
    - effect: "Inlining decisions stabilize: const-prop heuristics consult actual inferred source, preventing later passes from overriding inference-recorded noinline choices."
      mechanism: |
        abstract_call_gf_by_type() stores call_results per MethodMatchTarget [abstractinterpretation.jl:242]
          -> infercalls2() passes call_results to const_prop_methodinstance_heuristic() [abstractinterpretation.jl:306-307]
          -> const_prop_methodinstance_heuristic() checks src_inlining_policy on inf_result.src [abstractinterpretation.jl:1237-1241]
          -> if inlineable, returns true to allow const-prop; otherwise returns false
          -> inlining tests verify no inlining on second pass when inference recorded noinline [Compiler/test/inline.jl:1876-1890]
      downstream_surfaces:
        - "Core.Compiler inlining and constant-propagation heuristics"
        - "SSA inlining pass stability"
      likelihood: "high"
      impact: "medium"
    - effect: "Semi-concrete evaluation (irinterp) now requires InferenceResult-backed CodeInstance with inlineable source, reducing irinterp attempts on non-inlineable cached code."
      mechanism: |
        typeinf_edge() populates MethodCallResult.call_result with InferenceResult when isinferred [typeinfer.jl:1214-1221]
          -> semi_concrete_eval_call() retrieves call_result from result.call_result [abstractinterpretation.jl:1250]
          -> checks call_result isa InferenceResult [abstractinterpretation.jl:1251]
          -> extracts codeinst = call_result.ci and inferred = call_result.src [abstractinterpretation.jl:1252-1254]
          -> src_inlining_policy gate blocks irinterp when source is not inlineable [abstractinterpretation.jl:1255]
      downstream_surfaces:
        - "IRInterpreter-based const-prop"
        - "Inlining preparation for cached CodeInstances"
      likelihood: "medium"
      impact: "low"
    - effect: "Inlining retrieves call_results via getresult() to compute joint effects and dispatch to result handlers by type."
      mechanism: |
        getresult(info, idx) returns call_results[idx] [types.jl:559 -> stmtinfo.jl:159]
          -> compute_inlining_cases() iterates over matches calling getresult() [ssair/inlining.jl:1305]
          -> info_effects() extracts effects from call_result by type [ssair/inlining.jl:1273-1282]:
             - InferenceResult -> call_result.ipo_effects
             - ConcreteResult -> call_result.effects
             - SemiConcreteResult -> call_result.effects
          -> joint_effects = merge_effects(joint_effects, info_effects(...)) [ssair/inlining.jl:1306]
          -> handle_any_call_result!() dispatches based on result type [ssair/inlining.jl:1264-1270]:
             - ConcreteResult -> handle_concrete_result!()
             - SemiConcreteResult -> handle_semi_concrete_result!()
             - else -> handle_call_result!()
      downstream_surfaces:
        - "SSA inlining pass case handling"
        - "Effect inference during inlining"
      likelihood: "high"
      impact: "medium"
    - effect: "Cached results with inlineable source preserve InferenceResult as call_result for downstream inlining."
      mechanism: |
        return_cached_result() for CodeInstance with src [typeinfer.jl:1005-1027]:
          -> creates InferenceResult with cached source [typeinfer.jl:1012-1019]
          -> passes inf_result as call_result to MethodCallResult [typeinfer.jl:1026]
        return_cached_result() for InferenceResult [typeinfer.jl:1029-1041]:
          -> passes existing inf_result as call_result [typeinfer.jl:1040]
      downstream_surfaces:
        - "Cached edge inlining"
        - "Source preservation for inlining decisions"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "Core.Compiler.MethodMatchInfo.call_results"
        change: "New per-match InferredCallResult storage; CallInfo consumers must handle this field."
        affected_tools:
          - tool: "REPLInterpreter"
            usage: "REPL stdlib wraps MethodCallResult and forwards call_result in concrete_eval_eligible."
            evidence:
              - source: "code"
                path: "stdlib/REPL/src/REPLCompletions.jl"
                loc: "605-608"
                url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/stdlib/REPL/src/REPLCompletions.jl#L605-L608"
                snippet: |
                  if (interp.limit_aggressive_inference ? is_repl_frame(sv) : is_call_stack_uncached(sv))
                      neweffects = CC.Effects(result.effects; consistent=CC.ALWAYS_TRUE)
                      result = CC.MethodCallResult(result.rt, result.exct, neweffects, result.edge,
                                                   result.edgecycle, result.edgelimited, result.call_result)
      - field: "Core.Compiler.MethodCallResult.call_result"
        change: "Replaces volatile_inf_result; carries InferredCallResult for const-prop and irinterp."
        affected_tools:
          - tool: "Custom AbstractInterpreter implementations"
            usage: "Custom MethodCallResult constructors must forward call_result to preserve inference metadata (see REPLInterpreter)."
            evidence:
              - source: "code"
                path: "Compiler/src/abstractinterpretation.jl"
                loc: "821-834"
                url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L821-L834"
                snippet: |
                  struct MethodCallResult
                      rt
                      exct
                      effects::Effects
                      edge::Union{Nothing,CodeInstance}
                      edgecycle::Bool
                      edgelimited::Bool
                      call_result::Union{Nothing,InferredCallResult}
                      function MethodCallResult(@nospecialize(rt), @nospecialize(exct), effects::Effects,
                                                edge::Union{Nothing,CodeInstance}, edgecycle::Bool, edgelimited::Bool,
                                                call_result::Union{Nothing,InferredCallResult} = nothing)
                          return new(rt, exct, effects, edge, edgecycle, edgelimited, call_result)
                      end
                  end
      - field: "Core.Compiler.getresult(info::CallInfo, idx::Int)"
        change: "New API retrieving call_results from CallInfo for inlining; returns InferredCallResult or nothing."
        affected_tools:
          - tool: "Custom inlining implementations"
            usage: "Inlining code using nsplit/getsplit should call getresult() to obtain effects and source."
            evidence:
              - source: "code"
                path: "Compiler/src/types.jl"
                loc: "557-559"
                url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/types.jl#L557-L559"
                snippet: |
                  nsplit(info::CallInfo) = nsplit_impl(info)::Union{Nothing,Int}
                  getsplit(info::CallInfo, idx::Int) = getsplit_impl(info, idx)::MethodLookupResult
                  getresult(info::CallInfo, idx::Int) = getresult_impl(info, idx)
    behavioral:
      - change: "Second inlining pass respects inference-recorded noinline decisions even when callsite flags are cleared."
        evidence:
          - source: "test"
            path: "Compiler/test/inline.jl"
            loc: "1876-1890"
            url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/test/inline.jl#L1876-L1890"
            snippet: |
              call_func_mul_int(a::Int, b::Int) = @noinline func_mul_int(a, b)
              multi_inlining2(a::Int, b::Int) = call_func_mul_int(a, b)
              let i::Int, continue_::Bool
                  interp = Compiler.NativeInterpreter()
                  # check if callsite `@noinline` annotation works
                  ir, = only(Base.code_ircode(multi_inlining2, (Int,Int); optimize_until="CC: INLINING", interp))
                  i = findfirst(isinvoke(:func_mul_int), ir.stmts.stmt)
                  @test i !== nothing
                  # now delete the callsite flag, and see the second inlining pass does not inline the call, since inference recorded it should not
                  ir.stmts[i][:flag] &= ~Compiler.IR_FLAG_NOINLINE
                  inlining = Compiler.InliningState(interp)
                  ir = Compiler.ssa_inlining_pass!(ir, inlining, false)
                  @test findfirst(isinvoke(:func_mul_int), ir.stmts.stmt) !== nothing
                  @test findfirst(iscall((ir, Core.Intrinsics.mul_int)), ir.stmts.stmt) === nothing
  performance:
    compile_time:
      - impact: "ESTIMATED: Minor overhead from per-match call_results storage, proportional to applicable method count."
        evidence:
          - source: "code"
            path: "Compiler/src/stmtinfo.jl"
            loc: "58-63"
            url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/stmtinfo.jl#L58-L63"
            snippet: |
              call_results::Vector{Union{Nothing,InferredCallResult}}
              function MethodMatchInfo(
                  results::MethodLookupResult, mt::MethodTable, @nospecialize(atype), fullmatch::Bool)
                  edges = fill!(Vector{Union{Nothing,CodeInstance}}(undef, length(results)), nothing)
                  call_results = fill!(Vector{Union{Nothing,InferredCallResult}}(undef, length(results)), nothing)
                  return new(results, mt, atype, fullmatch, edges, call_results)
    runtime:
      - impact: "ESTIMATED: Improved runtime when inference regenerates previously-missing inlineable IR, enabling inlining."
        evidence:
          - source: "code"
            path: "Compiler/src/typeinfer.jl"
            loc: "1123-1134"
            url: "https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/typeinfer.jl#L1123-L1134"
            snippet: |
              if codeinst isa CodeInstance
                  need_inlineable_code = may_optimize(interp) && (force_inline || is_inlineable(inferred))
                  if need_inlineable_code
                      src = ci_get_source(interp, codeinst, inferred)
                      if src === nothing
                          # Re-infer to get the appropriate source representation
                          cache_mode = CACHE_MODE_LOCAL
                          edge_ci = codeinst
                      else # no reinference needed
                          @assert codeinst.def === mi "MethodInstance for cached edge does not match"
                          return return_cached_result(interp, method, code, src, caller, edgecycle, edgelimited)
                      end
  risk:
    level: "medium"
    rationale:
      - "New call_result dataflow in inference/inlining; incorrect propagation could alter inlining or const-prop behavior."
      - "CodeInstance const-field metadata changes affect mutability assumptions during optimization."
      - "MethodCallResult constructor signature change requires downstream tools to update."
  open_questions:
    - "Do external AbstractInterpreter implementations construct MethodCallResult without forwarding call_result?"
    - "Should the semi-concrete eval inlineability gate be revisited after #58183 and #48913?"
  recommendations:
    - "Forward call_result when constructing MethodCallResult to preserve inference metadata."
    - "Document MethodMatchInfo.call_results and MethodCallResult.call_result to prevent silent tooling breakage."
    - "Custom AbstractInterpreter implementations should follow REPLInterpreter pattern for forwarding call_result."
